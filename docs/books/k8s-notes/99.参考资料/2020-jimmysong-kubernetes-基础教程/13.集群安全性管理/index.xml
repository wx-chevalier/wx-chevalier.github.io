<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>_index | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/</link><atom:link href="https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><description>_index</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>_index</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/</link></image><item><title>auth-with-kubeconfig-or-token</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/auth-with-kubeconfig-or-token/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/auth-with-kubeconfig-or-token/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 88
title: 使用 kubeconfig 或 token 进行用户身份认证
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>在开启了 TLS 的集群中，每当与集群交互的时候少不了的是身份认证，使用 kubeconfig（即证书） 和 token 两种认证方式是最简单也最通用的认证方式，在 dashboard 的登录功能就可以使用这两种登录功能。&lt;/p>
&lt;p>下文分两块以示例的方式来讲解两种登陆认证方式：&lt;/p>
&lt;ul>
&lt;li>为 brand 命名空间下的 brand 用户创建 kubeconfig 文件&lt;/li>
&lt;li>为集群的管理员（拥有所有命名空间的 amdin 权限）创建 token&lt;/li>
&lt;/ul>
&lt;h2 id="使用-kubeconfig">使用 kubeconfig&lt;/h2>
&lt;p>如何生成&lt;code>kubeconfig&lt;/code>文件请参考&lt;a href="../../guide/kubectl-user-authentication-authorization">创建用户认证授权的 kubeconfig 文件&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>注意我们生成的 kubeconfig 文件中没有 token 字段，需要手动添加该字段。&lt;/p>
&lt;/blockquote>
&lt;p>比如我们为 brand namespace 下的 brand 用户生成了名为 &lt;code>brand.kubeconfig&lt;/code> 的 kubeconfig 文件，还要再该文件中追加一行 &lt;code>token&lt;/code> 的配置（如何生成 token 将在下文介绍），如下所示：&lt;/p>
&lt;p>
&lt;figure id="figure-kubeconfig-文件">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/brand-kubeconfig-yaml.jpg" alt="kubeconfig文件" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
kubeconfig 文件
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>对于访问 dashboard 时候的使用 kubeconfig 文件如&lt;code>brand.kubeconfig&lt;/code> 必须追到 &lt;code>token&lt;/code> 字段，否则认证不会通过。而使用 kubectl 命令时的用的 kubeconfig 文件则不需要包含 &lt;code>token&lt;/code> 字段。&lt;/p>
&lt;h2 id="生成-token">生成 token&lt;/h2>
&lt;p>需要创建一个 admin 用户并授予 admin 角色绑定，使用下面的 yaml 文件创建 admin 用户并赋予他管理员权限，然后可以通过 token 访问 kubernetes，该文件见&lt;a href="https://github.com/rootsongjc/kubernetes-handbook/tree/master/manifests/dashboard-1.7.1/admin-role.yaml" target="_blank" rel="noopener">admin-role.yaml&lt;/a>。&lt;/p>
&lt;h3 id="生成-kubernetes-集群最高权限-admin-用户的-token">生成 kubernetes 集群最高权限 admin 用户的 token&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rbac.authorization.kubernetes.io/autoupdate&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cluster-admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kubernetes.io/cluster-service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">addonmanager.kubernetes.io/mode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Reconcile&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后执行下面的命令创建 serviceaccount 和角色绑定，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create -f admin-role.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建完成后获取 secret 中 token 的值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取admin-token的secret名字&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl -n kube-system get secret&lt;span class="p">|&lt;/span>grep admin-token
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">admin-token-nwphb kubernetes.io/service-account-token &lt;span class="m">3&lt;/span> 6m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取token的值&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl -n kube-system describe secret admin-token-nwphb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Name: admin-token-nwphb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Namespace: kube-system
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Labels: &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Annotations: kubernetes.io/service-account.name&lt;span class="o">=&lt;/span>admin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> kubernetes.io/service-account.uid&lt;span class="o">=&lt;/span>f37bd044-bfb3-11e7-87c0-f4e9d49f8ed0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Type: kubernetes.io/service-account-token
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">====&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">namespace: &lt;span class="m">11&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">token: 非常长的字符串
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ca.crt: &lt;span class="m">1310&lt;/span> bytes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用 jsonpath 的方式直接获取 token 的值，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl -n kube-system get secret admin-token-nwphb -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">={&lt;/span>.data.token&lt;span class="o">}&lt;/span>&lt;span class="p">|&lt;/span>base64 -d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意&lt;/strong>：yaml 输出里的那个 token 值是进行 base64 编码后的结果，一定要将 kubectl 的输出中的 token 值进行 &lt;code>base64&lt;/code> 解码，在线解码工具 &lt;a href="https://www.base64decode.org/" target="_blank" rel="noopener">base64decode&lt;/a>，Linux 和 Mac 有自带的 &lt;code>base64&lt;/code> 命令也可以直接使用，输入 &lt;code>base64&lt;/code> 是进行编码，Linux 中&lt;code>base64 -d&lt;/code> 表示解码，Mac 中使用 &lt;code>base64 -D&lt;/code>。&lt;/p>
&lt;p>我们使用了 base64 对其重新解码，因为 secret 都是经过 base64 编码的，如果直接使用 kubectl 中查看到的 &lt;code>token&lt;/code> 值会认证失败，详见 &lt;a href="../../guide/secret-configuration">secret 配置&lt;/a>。关于 JSONPath 的使用请参考 &lt;a href="https://kubernetes.io/docs/user-guide/jsonpath/" target="_blank" rel="noopener">JSONPath 手册&lt;/a>。&lt;/p>
&lt;p>更简单的方式是直接使用&lt;code>kubectl describe&lt;/code>命令获取 token 的内容（经过 base64 解码之后）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl describe secret admin-token-nwphb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="为普通用户生成-token">为普通用户生成 token&lt;/h3>
&lt;p>为指定 namespace 分配该 namespace 的最高权限，这通常是在为某个用户（组织或者个人）划分了 namespace 之后，需要给该用户创建 token 登陆 kubernetes dashboard 或者调用 kubernetes API 的时候使用。&lt;/p>
&lt;p>每次创建了新的 namespace 下都会生成一个默认的 token，名为&lt;code>default-token-xxxx&lt;/code>。&lt;code>default&lt;/code>就相当于该 namespace 下的一个用户，可以使用下面的命令给该用户分配该 namespace 的管理员权限。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create rolebinding &lt;span class="nv">$ROLEBINDING_NAME&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>admin --serviceaccount&lt;span class="o">=&lt;/span>&lt;span class="nv">$NAMESPACE&lt;/span>:default --namespace&lt;span class="o">=&lt;/span>&lt;span class="nv">$NAMESPACE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>$ROLEBINDING_NAME&lt;/code>必须是该 namespace 下的唯一的&lt;/li>
&lt;li>&lt;code>admin&lt;/code>表示用户该 namespace 的管理员权限，关于使用&lt;code>clusterrole&lt;/code>进行更细粒度的权限控制请参考&lt;a href="../../concepts/rbac">RBAC——基于角色的访问控制&lt;/a>。&lt;/li>
&lt;li>我们给默认的 serviceaccount &lt;code>default&lt;/code>分配 admin 权限，这样就不要再创建新的 serviceaccount，当然你也可以自己创建新的 serviceaccount，然后给它 admin 权限&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/user-guide/jsonpath/" target="_blank" rel="noopener">JSONPath 手册 - kubernetes.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/admin/authentication/" target="_blank" rel="noopener">Kubernetes 中的认证 - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>authentication</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/authentication/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 89
title: Kubernetes 中的用户与身份认证授权
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>在安装集群的时候我们在 master 节点上生成了一堆证书、token，还在 kubelet 的配置中用到了 bootstrap token，安装各种应用时，为了能够与 API server 通信创建了各种 service account，在 Dashboard 中使用了 kubeconfig 或 token 登陆，那么这些都属于什么认证方式？如何区分用户的？我特地翻译了下这篇官方文档，想你看了之后你将找到答案。&lt;/p>
&lt;p>重点查看 bearer token 和 HTTP 认证中的 token 使用，我们已经有所应用，如 &lt;a href="auth-with-kubeconfig-or-token.md">使用 kubeconfig 或 token 进行用户身份认证&lt;/a>。&lt;/p>
&lt;h2 id="认识-kubernetes-中的用户">认识 Kubernetes 中的用户&lt;/h2>
&lt;p>Kubernetes 集群中包含两类用户：一类是由 Kubernetes 管理的 service account，另一类是普通用户。&lt;/p>
&lt;p>普通用户被假定为由外部独立服务管理。管理员分发私钥，用户存储（如 Keystone 或 Google 帐户），甚至包含用户名和密码列表的文件。在这方面，&lt;em>Kubernetes 没有代表普通用户帐户的对象&lt;/em>。无法通过 API 调用的方式向集群中添加普通用户。&lt;/p>
&lt;p>相对的，service account 是由 Kubernetes API 管理的帐户。它们都绑定到了特定的 namespace，并由 API server 自动创建，或者通过 API 调用手动创建。Service account 关联了一套凭证，存储在 &lt;code>Secret&lt;/code>，这些凭证同时被挂载到 pod 中，从而允许 pod 与 kubernetes API 之间的调用。&lt;/p>
&lt;p>API 请求被绑定到普通用户或 serivce account 上，或者作为匿名请求对待。这意味着集群内部或外部的每个进程，无论从在工作站上输入 &lt;code>kubectl&lt;/code> 的人类用户到节点上的 &lt;code>kubelet&lt;/code>，到控制平面的成员，都必须在向 API Server 发出请求时进行身份验证，或者被视为匿名用户。&lt;/p>
&lt;h2 id="认证策略">认证策略&lt;/h2>
&lt;p>Kubernetes 使用客户端证书、bearer token、身份验证代理或者 HTTP 基本身份验证等身份认证插件来对 API 请求进行身份验证。当有 HTTP 请求发送到 API server 时，插件会尝试将以下属性关联到请求上：&lt;/p>
&lt;ul>
&lt;li>用户名：标识最终用户的字符串。常用值可能是 &lt;code>kube-admin&lt;/code> 或 &lt;code>jane@example.com&lt;/code>。&lt;/li>
&lt;li>UID：标识最终用户的字符串，比用户名更加一致且唯一。&lt;/li>
&lt;li>组：一组将用户和常规用户组相关联的字符串。&lt;/li>
&lt;li>额外字段：包含其他有用认证信息的字符串列表的映射。&lt;/li>
&lt;/ul>
&lt;p>所有的值对于认证系统都是不透明的，只有 &lt;a href="https://kubernetes.io/docs/admin/authorization/" target="_blank" rel="noopener">授权人&lt;/a> 才能解释这些值的重要含义。&lt;/p>
&lt;p>您可以一次性启用多种身份验证方式。通常使用至少以下两种认证方式：&lt;/p>
&lt;ul>
&lt;li>服务帐户的 service account token&lt;/li>
&lt;li>至少一种其他的用户认证的方式&lt;/li>
&lt;/ul>
&lt;p>当启用了多个认证模块时，第一个认证模块成功认证后将短路请求，不会进行第二个模块的认证。API server 不会保证认证的顺序。&lt;/p>
&lt;p>&lt;code>system:authenticated&lt;/code> 组包含在所有已验证用户的组列表中。&lt;/p>
&lt;p>与其他身份验证协议（LDAP、SAML、Kerberos、x509 方案等）的集成可以使用身份验证代理或身份验证 webhook 来实现。&lt;/p>
&lt;h3 id="x509-客户端证书">X509 客户端证书&lt;/h3>
&lt;p>通过将 &lt;code>--client-ca-file=SOMEFILE&lt;/code> 选项传递给 API server 来启用客户端证书认证。引用的文件必须包含一个或多个证书颁发机构，用于验证提交给 API server 的客户端证书。如果客户端证书已提交并验证，则使用 subject 的 Common Name（CN）作为请求的用户名。从 Kubernetes 1.4 开始，客户端证书还可以使用证书的 organization 字段来指示用户的组成员身份。要为用户包含多个组成员身份，请在证书中包含多个 organization 字段。&lt;/p>
&lt;p>例如，使用 &lt;code>openssl&lt;/code> 命令工具生成用于签名认证请求的证书：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj &lt;span class="s2">&amp;#34;/CN=jbeda/O=app1/O=app2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将为一个用户名为 ”jbeda“ 的 CSR，属于两个组“app1”和“app2”。&lt;/p>
&lt;h3 id="静态-token-文件">静态 Token 文件&lt;/h3>
&lt;p>当在命令行上指定 &lt;code>--token-auth-file=SOMEFILE&lt;/code> 选项时，API server 从文件读取 bearer token。目前，token 会无限期地持续下去，并且不重新启动 API server 的话就无法更改令牌列表。&lt;/p>
&lt;p>token 文件是一个 csv 文件，每行至少包含三列：token、用户名、用户 uid，其次是可选的组名。请注意，如果您有多个组，则该列必须使用双引号。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">token,user,uid,&amp;#34;group1,group2,group3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="在请求中放置-bearer-token">在请求中放置 Bearer Token&lt;/h4>
&lt;p>当使用来自 http 客户端的 bearer token 时，API server 期望 &lt;code>Authorization&lt;/code> header 中包含 &lt;code>Bearer token&lt;/code> 的值。Bearer token 必须是一个字符串序列，只需使用 HTTP 的编码和引用功能就可以将其放入到 HTTP header 中。例如：如果 bearer token 是 &lt;code>31ada4fd-adec-460c-809a-9e56ceb75269&lt;/code>，那么它将出现在 HTTP header 中，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="bootstrap-token">Bootstrap Token&lt;/h3>
&lt;p>该功能仍处于 &lt;strong>alpha&lt;/strong> 版本。&lt;/p>
&lt;p>为了简化新集群的初始化引导过程，Kubernetes 中包含了一个名为 &lt;em>Bootstrap Token&lt;/em> 的动态管理的 bearer token。这些 token 使用 Secret 存储在 &lt;code>kube-system&lt;/code> namespace 中，在那里它们可以被动态管理和创建。Controller Manager 中包含了一个 TokenCleaner 控制器，用于在 bootstrap token 过期时删除将其删除。&lt;/p>
&lt;p>这些 token 的形式是 &lt;code>[a-z0-9]{6}.[a-z0-9]{16}&lt;/code>。第一部分是 Token ID，第二部分是 Token Secret。您在 HTTP header 中指定的 token 如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">Authorization: Bearer 781292.db7bc3a58fc5f07e
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 API server 的启动参数中加上 &lt;code>--experimental-bootstrap-token-auth&lt;/code> 标志以启用 Bootstrap Token Authenticator。您必须通过 Controller Manager 上的 &lt;code>--controllers&lt;/code> 标志启用 TokenCleaner 控制器，如 &lt;code>--controllers=*,tokencleaner&lt;/code>。如果您使用它来引导集群， &lt;code>kubeadm&lt;/code> 会为您完成。&lt;/p>
&lt;p>认证者认证为 &lt;code>system:bootstrap:&amp;lt;Token ID&amp;gt;&lt;/code> 。被包含在 &lt;code>system:bootstrappers&lt;/code> 组中。命名和组是有意限制用户使用过去的 bootstap token。可以使用用户名和组（&lt;code>kubeadm&lt;/code> 使用）来制定适当的授权策略以支持引导集群。&lt;/p>
&lt;p>有关 Bootstrap Token 身份验证器和控制器的更深入的文档，以及如何使用 &lt;code>kubeadm&lt;/code> 管理这些令牌，请参阅 &lt;a href="https://kubernetes.io/docs/admin/bootstrap-tokens/" target="_blank" rel="noopener">Bootstrap Token&lt;/a>。&lt;/p>
&lt;h3 id="静态密码文件">静态密码文件&lt;/h3>
&lt;p>通过将 &lt;code>--basic-auth-file=SOMEFILE&lt;/code> 选项传递给 API server 来启用基本身份验证。目前，基本身份验证凭证将无限期地保留，并且密码在不重新启动 API 服务器的情况下无法更改。请注意，为了方便起见，目前支持基本身份验证，而上述模式更安全更容易使用。&lt;/p>
&lt;p>基本身份认证是一个 csv 文件，至少包含 3 列：密码、用户名和用户 ID。在 Kubernetes 1.6 和更高版本中，可以指定包含以逗号分隔的组名称的可选第四列。如果您有多个组，则必须将第四列值用双引号（“）括起来，请参阅以下示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">password,user,uid,&amp;#34;group1,group2,group3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当使用来自 HTTP 客户端的基本身份验证时，API server 需要&lt;code> Authorization&lt;/code> header 中包含 &lt;code>Basic BASE64ENCODED(USER:PASSWORD)&lt;/code> 的值。&lt;/p>
&lt;h3 id="service-account-token">Service Account Token&lt;/h3>
&lt;p>Service account 是一个自动启用的验证器，它使用签名的 bearer token 来验证请求。该插件包括两个可选的标志：&lt;/p>
&lt;ul>
&lt;li>&lt;code>--service-account-key-file&lt;/code> 一个包含签名 bearer token 的 PEM 编码文件。如果未指定，将使用 API server 的 TLS 私钥。&lt;/li>
&lt;li>&lt;code>--service-account-lookup&lt;/code> 如果启用，从 API 中删除掉的 token 将被撤销。&lt;/li>
&lt;/ul>
&lt;p>Service account 通常 API server 自动创建，并通过 &lt;code>ServiceAccount&lt;/code> &lt;a href="https://kubernetes.io/docs/admin/admission-controllers/" target="_blank" rel="noopener">注入控制器&lt;/a> 关联到集群中运行的 Pod 上。Bearer token 挂载到 pod 中众所周知的位置，并允许集群进程与 API server 通信。帐户可以使用 &lt;code>PodSpec&lt;/code> 的 &lt;code>serviceAccountName&lt;/code> 字段显式地与 Pod 关联。&lt;/p>
&lt;p>注意： &lt;code>serviceAccountName&lt;/code> 通常被省略，因为这会自动生成。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1beta2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx-deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># ...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:1.7.9&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceAccountName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bob-the-bot&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Service account bearer token 在集群外使用也是完全有效的，并且可以用于为希望与 Kubernetes 通信的长期运行作业创建身份。要手动创建 service account，只需要使用 &lt;code>kubectl create serviceaccount (NAME)&lt;/code> 命令。这将在当前的 namespace 和相关连的 secret 中创建一个 service account。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl create serviceaccount jenkins
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">serviceaccount &lt;span class="s2">&amp;#34;jenkins&amp;#34;&lt;/span> created
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl get serviceaccounts jenkins -o yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apiVersion: v1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kind: ServiceAccount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">metadata:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">secrets:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- name: jenkins-token-1yvwg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建出的 secret 中拥有 API server 的公共 CA 和前面的 JSON Web Token（JWT）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get secret jenkins-token-1yvwg -o yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apiVersion: v1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">data:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ca.crt: &lt;span class="o">(&lt;/span>APISERVER&lt;span class="err">&amp;#39;&lt;/span>S CA BASE64 ENCODED&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> namespace: &lt;span class="nv">ZGVmYXVsdA&lt;/span>&lt;span class="o">==&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> token: &lt;span class="o">(&lt;/span>BEARER TOKEN BASE64 ENCODED&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kind: Secret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">metadata:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type: kubernetes.io/service-account-token
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：所有值是基于 base64 编码的，因为 secret 总是基于 base64 编码。&lt;/p>
&lt;p>经过签名的 JWT 可以用作 bearer token 与给定的 service account 进行身份验证。请参阅上面关于如何在请求中放置 bearer token。通常情况下，这些 secret 被挂载到 pod 中，以便对集群内的 API server 进行访问，但也可以从集群外访问。&lt;/p>
&lt;p>Service account 验证时用户名 &lt;code>system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)&lt;/code>，被指定到组 &lt;code>system:serviceaccounts&lt;/code> 和 &lt;code>system:serviceaccounts:(NAMESPACE)&lt;/code>。&lt;/p>
&lt;p>注意：由于 service account 的 token 存储在 secret 中，所以具有对这些 secret 的读取权限的任何用户都可以作为 service account 进行身份验证。授予 service account 权限和读取 secret 功能时要谨慎。&lt;/p>
&lt;h3 id="openid-connect-token">OpenID Connect Token&lt;/h3>
&lt;p>&lt;a href="https://openid.net/connect/" target="_blank" rel="noopener">OpenID Connect&lt;/a> 是由 OAuth2 供应商提供的 OAuth2，特别是 Azure Active Directory、Salesforce 和 Google。对 OAuth2 协议的主要扩展是返回一个称作 &lt;a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken" target="_blank" rel="noopener">ID Token&lt;/a> 的格外字段。该 token 是一个 JSON Web Token (JWT) ，有服务器签名，具有众所周知的字段，如用户的电子邮件。&lt;/p>
&lt;p>为了识别用户，认证者使用 OAuth2 &lt;a href="https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse" target="_blank" rel="noopener">token 响应&lt;/a> 中的 &lt;code>id_token&lt;/code>（而不是 &lt;code>access_token&lt;/code>）作为 bearer token。请参阅上面的关于将 token 置于请求中。&lt;/p>
&lt;p>
&lt;figure id="figure-kubernetes-openid-connect-flow">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/kubernetes-oidc-login.jpg" alt="Kubernetes OpenID Connect Flow" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Kubernetes OpenID Connect Flow
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>登陆到您的身份提供商&lt;/li>
&lt;li>您的身份提供商将为您提供一个 &lt;code>access_token&lt;/code>，一个 &lt;code>id_token&lt;/code> 和一个 &lt;code>refresh_token&lt;/code>&lt;/li>
&lt;li>当使用 &lt;code>kubectl&lt;/code> 时，使用 &lt;code>--token&lt;/code> 标志和 &lt;code>id_token&lt;/code> ，或者直接加入到您的 &lt;code>kubeconfig&lt;/code> 文件中&lt;/li>
&lt;li>&lt;code>kubectl&lt;/code> 在调用 API server 时将 &lt;code>id_token&lt;/code> 置于 HTTP header 中&lt;/li>
&lt;li>API server 将通过检查配置中指定的证书来确保 JWT 签名有效&lt;/li>
&lt;li>检查以确保 &lt;code>id_token&lt;/code> 没有过期&lt;/li>
&lt;li>确保用户已授权&lt;/li>
&lt;li>授权 API server 后向 &lt;code>kubectl&lt;/code>&lt;/li>
&lt;li>&lt;code>kubectl&lt;/code> 向用户提供反馈&lt;/li>
&lt;/ol>
&lt;p>由于所有需要验证您身份的数据都在 &lt;code>id_token&lt;/code> 中，Kubernetes 不需要向身份提供商 “phone home”。在每个请求都是无状态的模型中，这为认证提供了非常可扩展的解决方案。它确实提供了一些挑战：&lt;/p>
&lt;ol>
&lt;li>Kubernetes 没有 ”web 接口“ 来出发验证进程。没有浏览器或界面来收集凭据，这就是为什么您需要首先认证您的身份提供商。&lt;/li>
&lt;li>&lt;code>id_token&lt;/code> 无法撤销，就像一个证书，所以它应该是短暂的（只有几分钟），所以每隔几分钟就得到一个新的令牌是非常烦人的。&lt;/li>
&lt;li>没有使用 &lt;code>kubectl proxy&lt;/code> 命令或注入 &lt;code>id_token&lt;/code> 的反向代理，无法简单地对 Kubernetes dashboard 进行身份验证。&lt;/li>
&lt;/ol>
&lt;h4 id="配置-api-server">配置 API Server&lt;/h4>
&lt;p>要启用该插件，需要在 API server 中配置如下标志：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>示例&lt;/th>
&lt;th>是否必需&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>--oidc-issuer-url&lt;/code>&lt;/td>
&lt;td>允许 API server 发现公共签名密钥的提供者的 URL。只接受使用 &lt;code>https://&lt;/code> 的方案。通常是提供商的 URL 地址，不包含路径，例如“&lt;a href="https://accounts.google.com" target="_blank" rel="noopener">https://accounts.google.com&lt;/a>” 或者 “&lt;a href="https://login.salesforce.com" target="_blank" rel="noopener">https://login.salesforce.com&lt;/a>”。这个 URL 应该指向下面的 .well-known/openid-configuration&lt;/td>
&lt;td>如果发现 URL 是 &lt;code>https://accounts.google.com/.well-known/openid-configuration&lt;/code>，值应该是&lt;code>https://accounts.google.com&lt;/code>&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--oidc-client-id&lt;/code>&lt;/td>
&lt;td>所有的 token 必须为其颁发的客户端 ID&lt;/td>
&lt;td>kubernetes&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--oidc-username-claim&lt;/code>&lt;/td>
&lt;td>JWT 声明使用的用户名。默认情况下，&lt;code>sub&lt;/code> 是最终用户的唯一标识符。管理员可以选择其他声明，如&lt;code> email&lt;/code> 或 &lt;code>name&lt;/code>，具体取决于他们的提供者。不过，&lt;code>email&lt;/code> 以外的其他声明将以发行者的 URL 作为前缀，以防止与其他插件命名冲突。&lt;/td>
&lt;td>sub&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--oidc-groups-claim&lt;/code>&lt;/td>
&lt;td>JWT 声明使用的用户组。如果生命存在，它必须是一个字符串数组。&lt;/td>
&lt;td>groups&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--oidc-ca-file&lt;/code>&lt;/td>
&lt;td>用来签名您的身份提供商的网络 CA 证书的路径。默认为主机的跟 CA。&lt;/td>
&lt;td>&lt;code>/etc/kubernetes/ssl/kc-ca.pem&lt;/code>&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果为 &lt;code>--oidc-username-claim&lt;/code> 选择了除 &lt;code>email&lt;/code> 以外的其他声明，则该值将以 &lt;code>--oidc-issuer-url&lt;/code> 作为前缀，以防止与现有 Kubernetes 名称（例如 &lt;code>system:users&lt;/code>）冲突。例如，如果提供商网址是 &lt;a href="https://accounts.google.com" target="_blank" rel="noopener">https://accounts.google.com&lt;/a>，而用户名声明映射到 &lt;code>jane&lt;/code>，则插件会将用户身份验证为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">https://accounts.google.com#jane
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重要的是，API server 不是 OAuth2 客户端，而只能配置为信任单个发行者。这允许使用 Google 等公共提供者，而不必信任第三方发行的凭据。希望利用多个 OAuth 客户端的管理员应该探索支持 &lt;code>azp&lt;/code>（授权方）声明的提供者，这是允许一个客户端代表另一个客户端发放令牌的机制。&lt;/p>
&lt;p>Kubernetes 不提供 OpenID Connect 身份提供商。您可以使用现有的公共 OpenID Connect 标识提供程序（例如 Google 或 &lt;a href="http://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers" target="_blank" rel="noopener">其他&lt;/a>）。或者，您可以运行自己的身份提供程序，例如 CoreOS &lt;a href="https://github.com/coreos/dex" target="_blank" rel="noopener">dex&lt;/a>、&lt;a href="https://github.com/keycloak/keycloak" target="_blank" rel="noopener">Keycloak&lt;/a>、CloudFoundry &lt;a href="https://github.com/cloudfoundry/uaa" target="_blank" rel="noopener">UAA&lt;/a> 或 Tremolo Security 的 &lt;a href="https://github.com/tremolosecurity/openunison" target="_blank" rel="noopener">OpenUnison&lt;/a>。&lt;/p>
&lt;p>对于身份提供商能够适用于 Kubernetes，必须满足如下条件：Kubernetes it must:&lt;/p>
&lt;ol>
&lt;li>支持 &lt;a href="https://openid.net/specs/openid-connect-discovery-1_0.html" target="_blank" rel="noopener">OpenID connect 发现&lt;/a>；不必是全部。&lt;/li>
&lt;li>使用非过时密码在 TLS 中运行&lt;/li>
&lt;li>拥有 CA 签名证书（即使 CA 不是商业 CA 或自签名）&lt;/li>
&lt;/ol>
&lt;p>有关上述要求 3 的说明，需要 CA 签名证书。如果您部署自己的身份提供商（而不是像 Google 或 Microsoft 之类的云提供商），则必须让您的身份提供商的 Web 服务器证书由 CA 标志设置为 TRUE 的证书签名，即使是自签名的。这是由于 GoLang 的 TLS 客户端实现对证书验证的标准非常严格。如果您没有 &lt;code>CA&lt;/code>，可以使用 &lt;code>CoreOS&lt;/code> 团队的 &lt;a href="https://github.com/coreos/dex/blob/1ee5920c54f5926d6468d2607c728b71cfe98092/examples/k8s/gencert.sh" target="_blank" rel="noopener">这个脚本&lt;/a> 创建一个简单的 CA 和一个签名的证书和密钥对。&lt;/p>
&lt;p>针对特定系统的安装说明：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://apigee.com/about/blog/engineering/kubernetes-authentication-enterprise" target="_blank" rel="noopener">UAA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://speakerdeck.com/ericchiang/kubernetes-access-control-with-dex" target="_blank" rel="noopener">Dex&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/TremoloSecurity/openunison-qs-kubernetes" target="_blank" rel="noopener">OpenUnison&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="使用-kubectl">使用 kubectl&lt;/h4>
&lt;h5 id="选项-1---oidc-身份验证器">选项 1 - OIDC 身份验证器&lt;/h5>
&lt;p>第一个选项是使用 &lt;code>oidc&lt;/code> 身份验证器。此身份验证程序将您的 &lt;code>id_token&lt;/code>、&lt;code>refresh_token&lt;/code> 和您的 OIDC &lt;code>client_secret&lt;/code> 自动刷新您的 token。一旦您对身份提供者进行了身份验证：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl config set-credentials USER_NAME &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider&lt;span class="o">=&lt;/span>oidc &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>idp-issuer-url&lt;span class="o">=(&lt;/span> issuer url &lt;span class="o">)&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>client-id&lt;span class="o">=(&lt;/span> your client id &lt;span class="o">)&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>client-secret&lt;span class="o">=(&lt;/span> your client secret &lt;span class="o">)&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>refresh-token&lt;span class="o">=(&lt;/span> your refresh token &lt;span class="o">)&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>idp-certificate-authority&lt;span class="o">=(&lt;/span> path to your ca certificate &lt;span class="o">)&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>id-token&lt;span class="o">=(&lt;/span> your id_token &lt;span class="o">)&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>extra-scopes&lt;span class="o">=(&lt;/span> comma separated list of scopes to add to &lt;span class="s2">&amp;#34;openid email profile&amp;#34;&lt;/span>, optional &lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如，在向身份提供者进行身份验证之后运行以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl config set-credentials mmosley &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider&lt;span class="o">=&lt;/span>oidc &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>idp-issuer-url&lt;span class="o">=&lt;/span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>client-id&lt;span class="o">=&lt;/span>kubernetes &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>client-secret&lt;span class="o">=&lt;/span>1db158f6-177d-4d9c-8a8b-d36869918ec5 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>refresh-token&lt;span class="o">=&lt;/span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA&lt;span class="o">=&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>idp-certificate-authority&lt;span class="o">=&lt;/span>/root/ca.pem &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>extra-scopes&lt;span class="o">=&lt;/span>groups &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --auth-provider-arg&lt;span class="o">=&lt;/span>id-token&lt;span class="o">=&lt;/span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将产生下面的配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">users&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mmosley&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">user&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">auth-provider&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">client-id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kubernetes&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">client-secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">1db158f6-177d-4d9c-8a8b-d36869918ec5&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">extra-scopes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">groups&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">id-token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">idp-certificate-authority&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/root/ca.pem&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">idp-issuer-url&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">refresh-token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">oidc&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一旦您的 &lt;code>id_token&lt;/code> 过期，&lt;code>kubectl&lt;/code> 将使用 &lt;code>refresh_token&lt;/code> 刷新 &lt;code>id_token&lt;/code>，然后在 &lt;code>kube/.config&lt;/code> 文件的&lt;code>client_secret&lt;/code> 中存储 &lt;code>id_token&lt;/code> 的值和&lt;code>refresh_token&lt;/code> 的新值。&lt;/p>
&lt;h5 id="选项-2---使用---token-选项">选项 2 - 使用 &lt;code>--token&lt;/code> 选项&lt;/h5>
&lt;p>可以在 &lt;code>kubectl&lt;/code> 命令的 &lt;code>--token&lt;/code> 选项中传入 token。简单的拷贝和复制 &lt;code>id_token&lt;/code> 到该选项中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl --token&lt;span class="o">=&lt;/span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="webhook-token-认证">Webhook Token 认证&lt;/h3>
&lt;p>Webhook 认证是用来认证 bearer token 的 hook。&lt;/p>
&lt;ul>
&lt;li>&lt;code>--authentication-token-webhook-config-file&lt;/code> 是一个用来描述如何访问远程 webhook 服务的 kubeconfig 文件。&lt;/li>
&lt;li>&lt;code>--authentication-token-webhook-cache-ttl&lt;/code> 缓存身份验证策略的时间。默认为两分钟。&lt;/li>
&lt;/ul>
&lt;p>配置文件使用 &lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/authenticate-across-clusters-kubeconfig/" target="_blank" rel="noopener">kubeconfig&lt;/a> 文件格式。文件中的 ”user“ 指的是 API server 的 webhook，”clusters“ 是指远程服务。见下面的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># clusters refers to the remote service.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">clusters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">name-of-remote-authn-service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">cluster&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">certificate-authority&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/path/to/ca.pem&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># CA for verifying the remote service.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://authn.example.com/authenticate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># URL of remote service to query. Must use &amp;#39;https&amp;#39;.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># users refers to the API server&amp;#39;s webhook configuration.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">users&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">name-of-api-server&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">user&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">client-certificate&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/path/to/cert.pem&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># cert for the webhook plugin to use&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">client-key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/path/to/key.pem&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># key matching the cert&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># kubeconfig files require a context. Provide one for the API server.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">current-context&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">webhook&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">contexts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">context&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">cluster&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">name-of-remote-authn-service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">user&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">name-of-api-sever&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">webhook&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当客户端尝试使用 bearer token 与 API server 进行认证是，如上论述，认证 webhook 用饱含该 token 的对象查询远程服务。Kubernetes 不会挑战缺少该 header 的请求。&lt;/p>
&lt;p>请注意，webhook API 对象与其他 Kubernetes API 对象具有相同的 &lt;a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="noopener">版本控制兼容性规则&lt;/a>。实现者应该意识到 Beta 对象的宽松兼容性承诺，并检查请求的 “apiVersion” 字段以确保正确的反序列化。此外，API server 必须启用 &lt;code>authentication.k8s.io/v1beta1&lt;/code> API 扩展组（&lt;code>--runtime config =authentication.k8s.io/v1beta1=true&lt;/code>）。&lt;/p>
&lt;p>The request body will be of the following format:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;apiVersion&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;authentication.k8s.io/v1beta1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;kind&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;TokenReview&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;spec&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;token&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;(BEARERTOKEN)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>预计远程服务将填写请求的 &lt;code>status&lt;/code> 字段以指示登录成功。响应主体的 &lt;code>spec&lt;/code> 字段被忽略，可以省略。成功验证后的 bearer token 将返回：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;apiVersion&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;authentication.k8s.io/v1beta1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;kind&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;TokenReview&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;status&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;authenticated&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;username&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;janedoe@example.com&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;uid&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;42&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;groups&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;developers&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;qa&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;extra&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;extrafield1&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;extravalue1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;extravalue2&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>未成功的请求将返回：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;apiVersion&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;authentication.k8s.io/v1beta1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;kind&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;TokenReview&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;status&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;authenticated&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>HTTP 状态代码可以用来提供额外的错误上下文。&lt;/p>
&lt;h3 id="认证代理">认证代理&lt;/h3>
&lt;p>可以配置 API server 从请求 header 的值中识别用户，例如 &lt;code>X-Remote-User&lt;/code>。这样的设计是用来与请求 header 值的验证代理结合使用。&lt;/p>
&lt;ul>
&lt;li>&lt;code>--requestheader-username-headers&lt;/code> 必需，大小写敏感。按 header 名称和顺序检查用户标识。包含值的第一个 header 将被作为用户名。&lt;/li>
&lt;li>&lt;code>--requestheader-group-headers&lt;/code> 1.6 以上版本。可选。大小写敏感。建议为 “X-Remote-Group”。按 header 名称和顺序检查用户组。所有指定的 header 中的所有值都将作为组名。&lt;/li>
&lt;li>&lt;code>--requestheader-extra-headers-prefix&lt;/code> 1.6 以上版本。可选，大小写敏感。建议为 “X-Remote-Extra-”。标题前缀可用于查找有关用户的额外信息（通常由配置的授权插件使用）。以任何指定的前缀开头的 header 都会删除前缀，header 名称的其余部分将成为额外的键值，而 header 值则是额外的值。&lt;/li>
&lt;/ul>
&lt;p>例如下面的配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">--requestheader-username-headers&lt;span class="o">=&lt;/span>X-Remote-User
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--requestheader-group-headers&lt;span class="o">=&lt;/span>X-Remote-Group
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--requestheader-extra-headers-prefix&lt;span class="o">=&lt;/span>X-Remote-Extra-
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该请求：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">GET&lt;/span> &lt;span class="nn">/&lt;/span> &lt;span class="kr">HTTP&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="m">1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">X-Remote-User&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="l">fido&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">X-Remote-Group&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="l">dogs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">X-Remote-Group&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="l">dachshunds&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">X-Remote-Extra-Scopes&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="l">openid&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">X-Remote-Extra-Scopes&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="l">profile&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将产生如下的用户信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fido&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">groups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">dogs&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">dachshunds&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">extra&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">scopes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">openid&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">profile&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了防止 header 欺骗，验证代理需要在验证请求 header 之前向 API server 提供有效的客户端证书，以对照指定的 CA 进行验证。&lt;/p>
&lt;ul>
&lt;li>&lt;code>--requestheader-client-ca-file&lt;/code> 必需。PEM 编码的证书包。在检查用户名的请求 header 之前，必须针对指定文件中的证书颁发机构提交并验证有效的客户端证书。&lt;/li>
&lt;li>&lt;code>--requestheader-allowed-names&lt;/code> 可选。Common Name （cn）列表。如果设置了，则在检查用户名的请求 header 之前， 必须提供指定列表中 Common Name（cn）的有效客户端证书。如果为空，则允许使用任何 Common Name。&lt;/li>
&lt;/ul>
&lt;h3 id="keystone-密码">Keystone 密码&lt;/h3>
&lt;p>通过在启动过程中将 &lt;code>--experimental-keystone-url=&amp;lt;AuthURL&amp;gt;&lt;/code> 选项传递给 API server 来启用 Keystone 认证。该插件在 &lt;code>plugin/pkg/auth/authenticator/password/keystone/keystone.go&lt;/code> 中实现，目前使用基本身份验证通过用户名和密码验证用户。&lt;/p>
&lt;p>如果您为 Keystone 服务器配置了自签名证书，则在启动 Kubernetes API server 时可能需要设置 &lt;code>--experimental-keystone-ca-file=SOMEFILE&lt;/code> 选项。如果您设置了该选项，Keystone 服务器的证书将由&lt;code>experimental-keystone-ca-file&lt;/code> 中的某个权威机构验证。否则，证书由主机的根证书颁发机构验证。&lt;/p>
&lt;p>有关如何使用 keystone 来管理项目和用户的详细信息，请参阅 &lt;a href="http://docs.openstack.org/developer/keystone/" target="_blank" rel="noopener">Keystone 文档&lt;/a>。请注意，这个插件仍处于试验阶段，正在积极开发之中，并可能在后续版本中进行更改。&lt;/p>
&lt;p>请参考 &lt;a href="https://github.com/kubernetes/kubernetes/pull/11798#issuecomment-129655212" target="_blank" rel="noopener">讨论&lt;/a>、&lt;a href="https://github.com/kubernetes/kubernetes/issues/11626" target="_blank" rel="noopener">蓝图&lt;/a> 和 &lt;a href="https://github.com/kubernetes/kubernetes/pull/25536" target="_blank" rel="noopener">提出的改变&lt;/a> 获取更多信息。&lt;/p>
&lt;h2 id="匿名请求">匿名请求&lt;/h2>
&lt;p>启用时，未被其他已配置身份验证方法拒绝的请求将被视为匿名请求，并给予 &lt;code>system:anonymous&lt;/code> 的用户名和&lt;code> system:unuthenticated&lt;/code> 的组名。&lt;/p>
&lt;p>例如，在配置了令牌认证和启用了匿名访问的服务器上，提供无效的 bearer token 的请求将收到 &lt;code>401 Unauthorized&lt;/code> 错误。提供 bearer token 的请求将被视为匿名请求。&lt;/p>
&lt;p>在 1.5.1 - 1.5.x 版本中，默认情况下命名访问是被禁用的，可以通过传递 &lt;code>--anonymous-auth=false&lt;/code> 选项给 API server 来启用。&lt;/p>
&lt;p>在 1.6+ 版本中，如果使用 &lt;code>AlwaysAllow&lt;/code> 以外的授权模式，则默认启用匿名访问，并且可以通过将 &lt;code>--anonymous-auth=false&lt;/code>选项传递给 API 服务器来禁用。从 1.6 开始，ABAC 和 RBAC 授权人需要明确授权 &lt;code>system:annoymous&lt;/code> 或 &lt;code>system:unauthenticated&lt;/code> 组，因此授予对 &lt;code>*&lt;/code> 用户或 &lt;code>*&lt;/code> 组访问权的传统策略规则不包括匿名用户。&lt;/p>
&lt;h2 id="用户模拟">用户模拟&lt;/h2>
&lt;p>用户可以通过模拟 header 充当另一个用户。该请求会覆盖请求认证的用户信息。例如，管理员可以使用此功能通过暂时模拟其他用户并查看请求是否被拒绝来调试授权策略。&lt;/p>
&lt;p>模拟请求首先认证为请求用户，然后切换到模拟的用户信息。&lt;/p>
&lt;ul>
&lt;li>用户使用他们的凭证&lt;em>和&lt;/em>模拟 header 进行 API 调用。&lt;/li>
&lt;li>API server 认证用户&lt;/li>
&lt;li>API server 确保经过身份验证的用户具有模拟权限。&lt;/li>
&lt;li>请求用户的信息被替换为模拟值&lt;/li>
&lt;li>请求被评估，授权作用于模拟的用户信息。&lt;/li>
&lt;/ul>
&lt;p>以下 HTTP header 可用户执行模拟请求：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Impersonate-User&lt;/code>：充当的用户名&lt;/li>
&lt;li>&lt;code>Impersonate-Group&lt;/code>：作为组名。可以多次使用来设置多个组。可选的，需要 “Impersonate-User”&lt;/li>
&lt;li>&lt;code>Impersonate-Extra-( extra name )&lt;/code>：用于将额外字段与用户关联的动态 header。可选。需要 “Impersonate-User”&lt;/li>
&lt;/ul>
&lt;p>一组示例 header：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">Impersonate-User: jane.doe@example.com
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">Impersonate-Group: developers
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">Impersonate-Group: admins
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">Impersonate-Extra-scopes: view
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">Impersonate-Extra-scopes: development
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当使用 &lt;code>kubectl&lt;/code> 的 &lt;code>--as&lt;/code> 标志来配置 &lt;code>Impersonate-User&lt;/code> header 时，可以使用 &lt;code>--as-group&lt;/code> 标志来配置 &lt;code>Impersonate-Group&lt;/code> header。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl drain mynode
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Error from server &lt;span class="o">(&lt;/span>Forbidden&lt;span class="o">)&lt;/span>: User &lt;span class="s2">&amp;#34;clark&amp;#34;&lt;/span> cannot get nodes at the cluster scope. &lt;span class="o">(&lt;/span>get nodes mynode&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl drain mynode --as&lt;span class="o">=&lt;/span>superman --as-group&lt;span class="o">=&lt;/span>system:masters
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">node &lt;span class="s2">&amp;#34;mynode&amp;#34;&lt;/span> cordoned
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">node &lt;span class="s2">&amp;#34;mynode&amp;#34;&lt;/span> draine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为模仿用户、组或设置额外字段，模拟用户必须能够对正在模拟的属性的种类（“用户”，“组”等）执行“模拟”动词。对于启用了 RBAC 授权插件的集群，以下 ClusterRole 包含设置用户和组模拟 header 所需的规则：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">impersonator&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;users&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;groups&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;serviceaccounts&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;impersonate&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>额外的字段被评估为资源 “userextras” 的子资源。为了允许用户使用额外字段 “scope” 的模拟 header，应授予用户以下角色：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">scopes-impersonator&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># Can set &amp;#34;Impersonate-Extra-scopes&amp;#34; header.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;authentication.k8s.io&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;userextras/scopes&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;impersonate&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>模拟 header 的可用值可以通过设置 &lt;code>resourceNames&lt;/code> 可以使用的资源来限制。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">limited-impersonator&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># Can impersonate the user &amp;#34;jane.doe@example.com&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;users&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;impersonate&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceNames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;jane.doe@example.com&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># Can impersonate the groups &amp;#34;developers&amp;#34; and &amp;#34;admins&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;groups&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;impersonate&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceNames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;developers&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;admins&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># Can impersonate the extras field &amp;#34;scopes&amp;#34; with the values &amp;#34;view&amp;#34; and &amp;#34;development&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;authentication.k8s.io&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;userextras/scopes&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;impersonate&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceNames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;view&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;development&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="创建证书">创建证书&lt;/h3>
&lt;p>使用客户端证书进行身份验证时，可以使用现有的部署脚本或通过 &lt;code>easyrsa&lt;/code> 或 &lt;code>openssl&lt;/code> 手动生成证书。&lt;/p>
&lt;h4 id="使用已有的部署脚本">使用已有的部署脚本&lt;/h4>
&lt;p>&lt;strong>已有的部署脚本&lt;/strong> 在 &lt;code>cluster/saltbase/salt/generate-cert/make-ca-cert.sh&lt;/code>。&lt;/p>
&lt;p>执行该脚本时需要传递两个参数。第一个参数是 API server 的 IP 地址。第二个参数是 IP 形式的主题备用名称列表： &lt;code>IP:&amp;lt;ip-address&amp;gt;&lt;/code> 或 &lt;code>DNS:&amp;lt;dns-name&amp;gt;&lt;/code>。&lt;/p>
&lt;p>该脚本将生成三个文件： &lt;code>ca.crt&lt;/code>、&lt;code>server.crt&lt;/code> 和 &lt;code>server.key&lt;/code>。&lt;/p>
&lt;p>最后，将一下参数添加到 API server 的启动参数中：&lt;/p>
&lt;ul>
&lt;li>&lt;code>--client-ca-file=/srv/kubernetes/ca.crt&lt;/code>&lt;/li>
&lt;li>&lt;code>--tls-cert-file=/srv/kubernetes/server.crt&lt;/code>&lt;/li>
&lt;li>&lt;code>--tls-private-key-file=/srv/kubernetes/server.key&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="easyrsa">easyrsa&lt;/h4>
&lt;p>&lt;strong>easyrsa&lt;/strong> 可以用来手动为集群生成证书。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>下载，解压，并初始化修补版本的 easyrsa3。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl -L -O https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar xzf easy-rsa.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> easy-rsa-master/easyrsa3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./easyrsa init-pki
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>生成 CA（使用 &lt;code>--batch&lt;/code> 设置为自动模式。使用 &lt;code>--req-cn&lt;/code> 设置默认的 CN）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">./easyrsa --batch &lt;span class="s2">&amp;#34;--req-cn=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MASTER_IP&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">@`date +%s`&amp;#34;&lt;/span> build-ca nopass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>生成服务器证书和密钥。（build-server-full [文件名]：生成一个键值对，在本地为客户端和服务器签名。）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">./easyrsa --subject-alt-name&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;IP:&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MASTER_IP&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> build-server-full server nopass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>复制 &lt;code>pki/ca.crt&lt;/code>, &lt;code>pki/issued/server.crt&lt;/code> 和 &lt;code>pki/private/server.key&lt;/code> 到您的目录下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将以下参数添加到 API server 的启动参数中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">--client-ca-file&lt;span class="o">=&lt;/span>/yourdirectory/ca.crt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--tls-cert-file&lt;span class="o">=&lt;/span>/yourdirectory/server.crt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--tls-private-key-file&lt;span class="o">=&lt;/span>/yourdirectory/server.key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h4 id="openssl">openssl&lt;/h4>
&lt;p>&lt;strong>openssl&lt;/strong> 可以用来手动为集群生成证书。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>生成一个 2048 bit 的 ca.key：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">openssl genrsa -out ca.key &lt;span class="m">2048&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>根据 ca.key 生成一个 ca.crt（使用 -days 设置证书的有效时间）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">openssl req -x509 -new -nodes -key ca.key -subj &lt;span class="s2">&amp;#34;/CN=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MASTER_IP&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> -days &lt;span class="m">10000&lt;/span> -out ca.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>生成一个 2048 bit 的 server.key：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">openssl genrsa -out server.key &lt;span class="m">2048&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>根据 server.key 生成一个 server.csr：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">openssl req -new -key server.key -subj &lt;span class="s2">&amp;#34;/CN=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">MASTER_IP&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> -out server.csr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>根据 ca.key、ca.crt 和 server.csr 生成 server.crt：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days &lt;span class="m">10000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查看证书：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">openssl x509 -noout -text -in ./server.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>最后，不要忘了向 API server 的启动参数中增加配置。&lt;/p>
&lt;h4 id="认证-api">认证 API&lt;/h4>
&lt;p>您可以使用 &lt;code>certificates.k8s.io&lt;/code> API 将 x509 证书配置为用于身份验证，如 &lt;a href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster" target="_blank" rel="noopener">此处&lt;/a> 所述。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">Authenticating - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>ip-masq-agent</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/ip-masq-agent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/ip-masq-agent/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 87
title: IP 伪装代理
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>本文将讲述如何配置和启用 ip-masq-agent。&lt;/p>
&lt;h2 id="创建-ip-masq-agent">创建 ip-masq-agent&lt;/h2>
&lt;p>要创建 ip-masq-agent，运行下面的 kubectl 命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create -f https://raw.githubusercontent.com/kubernetes-incubator/ip-masq-agent/master/ip-masq-agent.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于 ip-masq-agent 的更多信息请参考 &lt;a href="https://github.com/kubernetes-incubator/ip-masq-agent" target="_blank" rel="noopener">该文档&lt;/a>。&lt;/p>
&lt;p>在大多数情况下，默认的一套规则应该是足够的；但是，如果内置的规则不适用于您的集群，您可以创建并应用 ConfigMap 来自定义受影响的 IP 范围。例如，为了仅允许 ip-masq-agent 考虑 10.0.0.0/8，您可以在名为 “config” 的文件中创建以下 ConfigMap。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">nonMasqueradeCIDRs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">10.0.0.0&lt;/span>&lt;span class="l">/8&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">resyncInterval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">60s&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意&lt;/strong>：重要的是，该文件被命名为 config，因为默认情况下，该文件将被用作 ip-masq-agent 查找的关键字。&lt;/p>
&lt;p>运行下列命令将 ConfigMap 添加到您的集群中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create configmap ip-masq-agent --from-file&lt;span class="o">=&lt;/span>config --namespace&lt;span class="o">=&lt;/span>kube-system
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将会更新 &lt;em>/etc/config/ip-masq-agent&lt;/em> 文件，并每隔 &lt;em>resyscInterval&lt;/em> 时间段检查一遍该文件，将配置应用到集群的节点中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">iptables -t nat -L IP-MASQ-AGENT
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">Chain IP-MASQ-AGENT (1 references)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">target prot opt source destination
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">RETURN all -- anywhere 169.254.0.0/16 /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">RETURN all -- anywhere 10.0.0.0/8 /* ip-masq-agent: cluster-local
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">MASQUERADE all -- anywhere anywhere /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，本地链路范围（169.254.0.0/16）也由 ip-masq 代理处理，该代理设置相应的 iptables 规则。想要让 ip-masq-agent 忽略本地链路，您可以在 ConfigMap 中将 masqLinkLocal 设置为 true。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">nonMasqueradeCIDRs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">10.0.0.0&lt;/span>&lt;span class="l">/8&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">resyncInterval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">60s&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">masqLinkLocal&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ip-伪装代理用户指南">IP 伪装代理用户指南&lt;/h2>
&lt;p>ip-masq-agent 用户配置 iptables 规则将 Pod 的 IP 地址隐藏在集群 node 节点的 IP 地址后面。这通常在将流量发送到集群的 pod &lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="noopener">CIDR&lt;/a> 范围之外的目的地时执行。&lt;/p>
&lt;h2 id="关键术语">关键术语&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>NAT（网络地址转换）&lt;/strong>&lt;/p>
&lt;p>是一种通过修改 IP 头中的源和/或目标地址信息来将一个 IP 地址重映射到另一个 IP 地址的方法。通常由执行 IP 路由的设备完成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Masquerading（伪装）&lt;/strong>&lt;/p>
&lt;p>NAT 的一种形式，通常用于执行多个地址转换，其中多个源 IP 地址被掩盖在单个地址之后，通常是由某设备进行 IP 路由。在 kubernetes 中，这是 Node 的 IP 地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>CIDR（无类域内路由选择）&lt;/strong>&lt;/p>
&lt;p>基于可变长度子网掩码，允许指定任意长度的前缀。CIDR 引入了一种新的 IP 地址表示方法，现在通常被称为 &lt;strong>CIDR 表示法&lt;/strong>，将地址或路由前缀的比特位数作为后缀，例如 192.168.2.0/24。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>本地链路&lt;/strong>&lt;/p>
&lt;p>本地链路地址是仅能在主机连接的网段或广播域内进行有效通信的网络地址。IPv4 的链路本地地址在 CIDR 表示法定义的地址块是 169.254.0.0/16。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Ip-masq-agent 在将流量发送到集群 node 节点的 IP 和 Cluster IP 范围之外的目的地时，会配置 iptables 规则来处理伪装的 node/pod IP 地址。这基本上将 pod 的 IP 地址隐藏在了集群 node 节点的 IP 地址后面。在某些环境中，到 “外部” 地址的流量必须来自已知的机器地址。例如，在 Google Cloud 中，到互联网的任何流量必须来自虚拟机的 IP。当使用容器时，如在 GKE 中，Pod IP 将被拒绝作为出口。为了避免这种情况，我们必须将 Pod IP 隐藏在 VM 自己的 IP 地址之后——通常被称为 “伪装”。默认情况下，配置代理将指定的三个专用 IP 范围视为非伪装 &lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="noopener">CIDR&lt;/a>。范围包括 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16。默认情况下，代理还将本地链路（169.254.0.0/16）视为非伪装 CIDR。代理配置为每隔 60 秒从 &lt;em>/etc/config/ip-masq-agent&lt;/em> 位置重新加载其配置，这也是可配置的。&lt;/p>
&lt;p>
&lt;figure id="figure-ip伪装代理示意图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/ip-masq.png" alt="IP伪装代理示意图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
IP伪装代理示意图
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>代理的配置文件必须使用 yaml 或 json 语法，并且包含以下三个可选的 key：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>nonMasqueradeCIDRs&lt;/strong>：使用 &lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="noopener">CIDR&lt;/a> 表示法指定的非伪装范围的字符串列表。&lt;/li>
&lt;li>&lt;strong>masqLinkLocal&lt;/strong>：一个布尔值（true/false），表示是否将流量伪装成本地链路前缀 169.254.0.0/16。默认为 false。&lt;/li>
&lt;li>&lt;strong>resyncInterval&lt;/strong>：代理尝试从磁盘重新加载配置的时间间隔。例如 ’30s’ 其中 ‘s’ 是秒，’ms’ 是毫秒等…&lt;/li>
&lt;/ul>
&lt;p>到 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 范围的流量将不会被伪装。任何其他流量（假定是互联网）将被伪装。这里有个例子，来自 pod 的本地目的地址可以是其节点的 IP 地址、其他节点的地址或 Cluster IP 范围中的一个 IP 地址。其他任何流量都将默认伪装。以下条目显示 ip-masq-agent 应用的默认规则集：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-http" data-lang="http">&lt;span class="line">&lt;span class="cl">&lt;span class="err">iptables -t nat -L IP-MASQ-AGENT
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">RETURN all -- anywhere 169.254.0.0/16 /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">RETURN all -- anywhere 10.0.0.0/8 /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">RETURN all -- anywhere 172.16.0.0/12 /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">RETURN all -- anywhere 192.168.0.0/16 /* ip-masq-agent: cluster-local traffic should not be subject to MASQUERADE */ ADDRTYPE match dst-type !LOCAL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">MASQUERADE all -- anywhere anywhere /* ip-masq-agent: outbound traffic should be subject to MASQUERADE (this match must come after cluster-local CIDR matches) */ ADDRTYPE match dst-type !LOCAL
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，在 GCE/GKE 中将启动 kubernetes 1.7.0 版本，ip-masq-agent 已经在集群中运行。如果您在其他环境中运行 kubernetes，那么您可以将 ip-masq-agent 以 &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSet&lt;/a> 的方式在集群中运行。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/ip-masq-agent/" target="_blank" rel="noopener">IP Masquerade Agent User Guide - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>kubectl-user-authentication-authorization</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/kubectl-user-authentication-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/kubectl-user-authentication-authorization/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 87
title: 创建用户认证授权的 kubeconfig 文件
date: &amp;lsquo;2022-05-21T00:00:00+08:00&amp;rsquo;
type: book&lt;/h2>
&lt;p>当我们安装好集群后，如果想要把 kubectl 命令交给用户使用，就不得不对用户的身份进行认证和对其权限做出限制。&lt;/p>
&lt;p>下面以创建一个 devuser 用户并将其绑定到 dev 和 test 两个 namespace 为例说明。&lt;/p>
&lt;h2 id="创建-ca-证书和秘钥">创建 CA 证书和秘钥&lt;/h2>
&lt;p>&lt;strong>创建 &lt;code>devuser-csr.json&lt;/code> 文件&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;CN&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;devuser&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;hosts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;key&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;algo&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;rsa&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;size&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2048&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;names&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;C&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;CN&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;ST&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;BeiJing&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;L&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;BeiJing&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;O&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;k8s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;OU&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;System&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>生成 CA 证书和私钥&lt;/strong>&lt;/p>
&lt;p>下面我们在 master 节点上为 devuser 创建证书和秘钥，在 &lt;code>/etc/kubernetes/ssl&lt;/code> 目录下执行以下命令：&lt;/p>
&lt;p>执行该命令前请先确保该目录下已经包含如下文件：&lt;/p>
&lt;pre tabindex="0">&lt;code>ca-key.pem ca.pem ca-config.json devuser-csr.json
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cfssl gencert -ca&lt;span class="o">=&lt;/span>ca.pem -ca-key&lt;span class="o">=&lt;/span>ca-key.pem -config&lt;span class="o">=&lt;/span>ca-config.json -profile&lt;span class="o">=&lt;/span>kubernetes devuser-csr.json &lt;span class="p">|&lt;/span> cfssljson -bare devuser
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2017/08/31 13:31:54 &lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> generate received request
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2017/08/31 13:31:54 &lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> received CSR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2017/08/31 13:31:54 &lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> generating key: rsa-2048
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2017/08/31 13:31:55 &lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> encoded CSR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2017/08/31 13:31:55 &lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> signed certificate with serial number &lt;span class="m">43372632012323103879829229080989286813242051309&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2017/08/31 13:31:55 &lt;span class="o">[&lt;/span>WARNING&lt;span class="o">]&lt;/span> This certificate lacks a &lt;span class="s2">&amp;#34;hosts&amp;#34;&lt;/span> field. This makes it unsuitable &lt;span class="k">for&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">websites. For more information see the Baseline Requirements &lt;span class="k">for&lt;/span> the Issuance and Management
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">of Publicly-Trusted Certificates, v.1.1.6, from the CA/Browser Forum &lt;span class="o">(&lt;/span>https://cabforum.org&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">specifically, section 10.2.3 &lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;Information Requirements&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将生成如下文件：&lt;/p>
&lt;pre tabindex="0">&lt;code>devuser.csr devuser-key.pem devuser.pem
&lt;/code>&lt;/pre>&lt;h2 id="创建-kubeconfig-文件">创建 kubeconfig 文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置集群参数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBE_APISERVER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;https://172.20.0.113:6443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl config set-cluster kubernetes &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--certificate-authority&lt;span class="o">=&lt;/span>/etc/kubernetes/ssl/ca.pem &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--embed-certs&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--server&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">KUBE_APISERVER&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--kubeconfig&lt;span class="o">=&lt;/span>devuser.kubeconfig
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置客户端认证参数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl config set-credentials devuser &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--client-certificate&lt;span class="o">=&lt;/span>/etc/kubernetes/ssl/devuser.pem &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--client-key&lt;span class="o">=&lt;/span>/etc/kubernetes/ssl/devuser-key.pem &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--embed-certs&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--kubeconfig&lt;span class="o">=&lt;/span>devuser.kubeconfig
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置上下文参数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl config set-context kubernetes &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--cluster&lt;span class="o">=&lt;/span>kubernetes &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--user&lt;span class="o">=&lt;/span>devuser &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--namespace&lt;span class="o">=&lt;/span>dev &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--kubeconfig&lt;span class="o">=&lt;/span>devuser.kubeconfig
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置默认上下文&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl config use-context kubernetes --kubeconfig&lt;span class="o">=&lt;/span>devuser.kubeconfig
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们现在查看 kubectl 的 context：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl config get-contexts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CURRENT NAME CLUSTER AUTHINFO NAMESPACE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">* kubernetes kubernetes admin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> default-context default-cluster default-admin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>显示的用户仍然是 admin，这是因为 kubectl 使用了 &lt;code>$HOME/.kube/config&lt;/code> 文件作为了默认的 context 配置，我们只需要将其用刚生成的 &lt;code>devuser.kubeconfig&lt;/code> 文件替换即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cp -f ./devuser.kubeconfig /root/.kube/config
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="rolebinding">RoleBinding&lt;/h2>
&lt;p>如果我们想限制 devuser 用户的行为，需要使用 RBAC创建角色绑定以将该用户的行为限制在某个或某几个 namespace 空间范围内，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create rolebinding devuser-admin-binding --clusterrole&lt;span class="o">=&lt;/span>admin --user&lt;span class="o">=&lt;/span>devuser --namespace&lt;span class="o">=&lt;/span>dev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl create rolebinding devuser-admin-binding --clusterrole&lt;span class="o">=&lt;/span>admin --user&lt;span class="o">=&lt;/span>devuser --namespace&lt;span class="o">=&lt;/span>&lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样 devuser 用户对 dev 和 test 两个 namespace 具有完全访问权限。&lt;/p>
&lt;p>让我们来验证以下，现在我们在执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取当前的 context&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl config get-contexts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CURRENT NAME CLUSTER AUTHINFO NAMESPACE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">* kubernetes kubernetes devuser dev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">* kubernetes kubernetes devuser &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 无法访问 default namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pods --namespace default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Error from server &lt;span class="o">(&lt;/span>Forbidden&lt;span class="o">)&lt;/span>: User &lt;span class="s2">&amp;#34;devuser&amp;#34;&lt;/span> cannot list pods in the namespace &lt;span class="s2">&amp;#34;default&amp;#34;&lt;/span>. &lt;span class="o">(&lt;/span>get pods&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 默认访问的是 dev namespace，您也可以重新设置 context 让其默认访问 test namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pods
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">No resources found.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在 kubectl 命令默认使用的 context 就是 devuser 了，且该用户只能操作 dev 和 test 这两个 namespace，并拥有完全的访问权限。&lt;/p>
&lt;p>关于角色绑定的更多信息请参考 &lt;a href="../../concepts/rbac">基于角色的访问控制&lt;/a>。&lt;/p></description></item><item><title>kubelet-authentication-authorization</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/kubelet-authentication-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/kubelet-authentication-authorization/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 85
title: Kublet 的认证授权
date: &amp;lsquo;2022-05-21T00:00:00+08:00&amp;rsquo;
type: book&lt;/h2>
&lt;p>Kubelet 的 HTTPS 端点对外暴露了用于访问不同敏感程度数据的 API，并允许您在节点或者容器内执行不同权限级别的操作。&lt;/p>
&lt;p>本文档向您描述如何通过认证授权来访问 kubelet 的 HTTPS 端点。&lt;/p>
&lt;h2 id="kubelet-认证">Kubelet 认证&lt;/h2>
&lt;p>默认情况下，所有未被配置的其他身份验证方法拒绝的，对 kubelet 的 HTTPS 端点的请求将被视为匿名请求，并被授予 &lt;code>system:anonymous&lt;/code> 用户名和 &lt;code>system:unauthenticated&lt;/code> 组。&lt;/p>
&lt;p>如果要禁用匿名访问并发送 &lt;code>401 Unauthorized&lt;/code> 的未经身份验证的请求的响应：&lt;/p>
&lt;ul>
&lt;li>启动 kubelet 时指定 &lt;code>--anonymous-auth=false&lt;/code> 标志&lt;/li>
&lt;/ul>
&lt;p>如果要对 kubelet 的 HTTPS 端点启用 X509 客户端证书身份验证：&lt;/p>
&lt;ul>
&lt;li>启动 kubelet 时指定 &lt;code>--client-ca-file&lt;/code> 标志，提供 CA bundle 以验证客户端证书&lt;/li>
&lt;li>启动 apiserver 时指定 &lt;code>--kubelet-client-certificate&lt;/code> 和 &lt;code>--kubelet-client-key&lt;/code> 标志&lt;/li>
&lt;li>参阅 &lt;a href="https://kubernetes.io/docs/admin/authentication/#x509-client-certs" target="_blank" rel="noopener">apiserver 认证文档&lt;/a> 获取更多详细信息。&lt;/li>
&lt;/ul>
&lt;p>启用 API bearer token（包括 service account token）用于向 kubelet 的 HTTPS 端点进行身份验证：&lt;/p>
&lt;ul>
&lt;li>确保在 API server 中开启了 &lt;code>authentication.k8s.io/v1beta1&lt;/code> API 组。&lt;/li>
&lt;li>启动 kubelet 时指定 &lt;code>--authentication-token-webhook&lt;/code>， &lt;code>--kubeconfig&lt;/code> 和 &lt;code>--require-kubeconfig&lt;/code> 标志&lt;/li>
&lt;li>Kubelet 在配置的 API server 上调用 &lt;code>TokenReview&lt;/code> API 以确定来自 bearer token 的用户信息&lt;/li>
&lt;/ul>
&lt;h2 id="kubelet-授权">Kubelet 授权&lt;/h2>
&lt;p>接着对任何成功验证的请求（包括匿名请求）授权。默认授权模式为 &lt;code>AlwaysAllow&lt;/code>，允许所有请求。&lt;/p>
&lt;p>细分访问 kubelet API 有很多原因：&lt;/p>
&lt;ul>
&lt;li>启用匿名认证，但匿名用户调用 kubelet API 的能力应受到限制&lt;/li>
&lt;li>启动 bearer token 认证，但是 API 用户（如 service account）调用 kubelet API 的能力应受到限制&lt;/li>
&lt;li>客户端证书身份验证已启用，但只有那些配置了 CA 签名的客户端证书的用户才可以使用 kubelet API&lt;/li>
&lt;/ul>
&lt;p>如果要细分访问 kubelet API，将授权委托给 API server：&lt;/p>
&lt;ul>
&lt;li>确保 API server 中启用了 &lt;code>authorization.k8s.io/v1beta1&lt;/code> API 组&lt;/li>
&lt;li>启动 kubelet 时指定 &lt;code>--authorization-mode=Webhook&lt;/code>、 &lt;code>--kubeconfig&lt;/code> 和 &lt;code>--require-kubeconfig&lt;/code> 标志&lt;/li>
&lt;li>kubelet 在配置的 API server 上调用 &lt;code>SubjectAccessReview&lt;/code> API，以确定每个请求是否被授权&lt;/li>
&lt;/ul>
&lt;p>kubelet 使用与 apiserver 相同的 &lt;a href="https://kubernetes.io/docs/admin/authorization/#request-attributes" target="_blank" rel="noopener">请求属性&lt;/a> 方法来授权 API 请求。&lt;/p>
&lt;p>Verb（动词）是根据传入的请求的 HTTP 动词确定的：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>HTTP 动词&lt;/th>
&lt;th>request 动词&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>POST&lt;/td>
&lt;td>create&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GET, HEAD&lt;/td>
&lt;td>get&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT&lt;/td>
&lt;td>update&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PATCH&lt;/td>
&lt;td>patch&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE&lt;/td>
&lt;td>delete&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>资源和子资源根据传入请求的路径确定：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Kubelet API&lt;/th>
&lt;th>资源&lt;/th>
&lt;th>子资源&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>/stats/*&lt;/td>
&lt;td>nodes&lt;/td>
&lt;td>stats&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/metrics/*&lt;/td>
&lt;td>nodes&lt;/td>
&lt;td>metrics&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/logs/*&lt;/td>
&lt;td>nodes&lt;/td>
&lt;td>log&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/spec/*&lt;/td>
&lt;td>nodes&lt;/td>
&lt;td>spec&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;em>all others&lt;/em>&lt;/td>
&lt;td>nodes&lt;/td>
&lt;td>proxy&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Namespace 和 API 组属性总是空字符串，资源的名字总是 kubelet 的 &lt;code>Node&lt;/code> API 对象的名字。&lt;/p>
&lt;p>当以该模式运行时，请确保用户为 apiserver 指定了 &lt;code>--kubelet-client-certificate&lt;/code> 和 &lt;code>--kubelet-client-key&lt;/code> 标志并授权了如下属性：&lt;/p>
&lt;ul>
&lt;li>verb=*, resource=nodes, subresource=proxy&lt;/li>
&lt;li>verb=*, resource=nodes, subresource=stats&lt;/li>
&lt;li>verb=*, resource=nodes, subresource=log&lt;/li>
&lt;li>verb=*, resource=nodes, subresource=spec&lt;/li>
&lt;li>verb=*, resource=nodes, subresource=metrics&lt;/li>
&lt;/ul></description></item><item><title>kubernetes-security-best-practice</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/kubernetes-security-best-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/kubernetes-security-best-practice/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 90
title: Kubernetes 集群安全性配置最佳实践
date: &amp;lsquo;2022-05-21T00:00:00+08:00&amp;rsquo;
type: book&lt;/h2>
&lt;p>本文是对 Kubernetes 集群安全性管理的最佳实践。&lt;/p>
&lt;h2 id="端口">端口&lt;/h2>
&lt;p>请注意管理好以下端口。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>端口&lt;/th>
&lt;th>进程&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>4149/TCP&lt;/td>
&lt;td>kubelet&lt;/td>
&lt;td>用于查询容器监控指标的 cAdvisor 端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10250/TCP&lt;/td>
&lt;td>kubelet&lt;/td>
&lt;td>访问节点的 API 端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10255/TCP&lt;/td>
&lt;td>kubelet&lt;/td>
&lt;td>未认证的只读端口，允许访问节点状态&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10256/TCP&lt;/td>
&lt;td>kube-proxy&lt;/td>
&lt;td>kube-proxy 的健康检查服务端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9099/TCP&lt;/td>
&lt;td>calico-felix&lt;/td>
&lt;td>calico 的健康检查服务端口（如果使用 calico/canal）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6443/TCP&lt;/td>
&lt;td>kube-apiserver&lt;/td>
&lt;td>Kubernetes API 端口&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="kubernetes-安全扫描工具-kube-bench">Kubernetes 安全扫描工具 kube-bench&lt;/h2>
&lt;p>&lt;a href="https://github.com/aquasecurity/kube-bench" target="_blank" rel="noopener">kube-bench&lt;/a> 可以消除大约 kubernetes 集群中 95％的配置缺陷。通过应用 CIS Kubernetes Benchmark 来检查 master 节点、node 节点及其控制平面组件，从而确保集群设置了特定安全准则。在经历特定的 Kubernetes 安全问题或安全增强功能之前，这应该是第一步。&lt;/p>
&lt;h2 id="api-设置">API 设置&lt;/h2>
&lt;p>&lt;strong>授权模式和匿名认证&lt;/strong>&lt;/p>
&lt;p>像 kops 这样的一些安装程序会为集群使用 &lt;code>AlwaysAllow&lt;/code> 授权模式。这将授予任何经过身份验证的实体拥有完全访问集群的权限。应该使用 RBAC 基于角色的访问控制。检查您的 kube-apiserver 进程的 &lt;code>--authorization-mode&lt;/code> 参数。有关该主题的更多信息，请访问&lt;a href="https://kubernetes.io/docs/admin/authorization/" target="_blank" rel="noopener">认证概览&lt;/a>。要强制进行身份验证，请确保通过设置 &lt;code>--anonymous-auth = false&lt;/code> 禁用匿名身份验证。&lt;/p>
&lt;p>注意这不影响 Kubelet 授权模式。kubelet 本身公开了一个 API 来执行命令，通过它可以完全绕过 Kubernetes API。&lt;/p>
&lt;p>更多关于使用 kops 等工具自动安装 Kubernetes 集群的安全配置注意事项请参考 &lt;a href="https://github.com/freach/kubernetes-security-best-practice" target="_blank" rel="noopener">Kubernetes Security - Best Practice Guide&lt;/a>。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/freach/kubernetes-security-best-practice" target="_blank" rel="noopener">Kubernetes Security - Best Practice Guide - github.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://acotten.com/post/kube17-security" target="_blank" rel="noopener">Kubernetes v1.7 security in practice - acotten.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/engine/security/userns-remap/" target="_blank" rel="noopener">Isolate containers with a user namespace - docs.docker.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://logz.io/blog/docker-security/" target="_blank" rel="noopener">Docker Security – It’s a Layered Approach - logz.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.kubernetes.io/2017/09/kubernetes-18-security-workloads-and.html" target="_blank" rel="noopener">Kubernetes 1.8: Security, Workloads and Feature Depth - blog.kubernetes.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.heptio.com/security-matters-rbac-in-kubernetes-e369b483c8d8" target="_blank" rel="noopener">Security Matters: RBAC in Kubernetes - blog.heptio.co&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>managing-tls-in-a-cluster</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/managing-tls-in-a-cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/managing-tls-in-a-cluster/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 84
title: 管理集群中的 TLS
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>在使用二进制文件部署 Kubernetes 集群的时候，很多人在进行到部署证书时遇到各种各样千奇百怪的问题，这一步是创建集群的基础，我们有必要详细了解一下其背后的流程和原理。&lt;/p>
&lt;h2 id="概览">概览&lt;/h2>
&lt;p>每个 Kubernetes 集群都有一个集群根证书颁发机构（CA）。集群中的组件通常使用 CA 来验证 API server 的证书，由 API 服务器验证 kubelet 客户端证书等。为了支持这一点，CA 证书包被分发到集群中的每个节点，并作为一个 secret 附加分发到默认 service account 上。或者，你的 workload 可以使用此 CA 建立信任。你的应用程序可以使用类似于 &lt;a href="https://github.com/ietf-wg-acme/acme/" target="_blank" rel="noopener">ACME 草案&lt;/a>的协议，使用 &lt;code>certificates.k8s.io&lt;/code> API 请求证书签名。&lt;/p>
&lt;h2 id="集群中的-tls-信任">集群中的 TLS 信任&lt;/h2>
&lt;p>让 Pod 中运行的应用程序信任集群根 CA 通常需要一些额外的应用程序配置。您将需要将 CA 证书包添加到 TLS 客户端或服务器信任的 CA 证书列表中。例如，您可以使用 golang TLS 配置通过解析证书链并将解析的证书添加到 &lt;a href="https://godoc.org/crypto/tls#Config" target="_blank" rel="noopener">&lt;code>tls.Config&lt;/code>&lt;/a>结构中的 &lt;code>Certificates&lt;/code> 字段中，CA 证书捆绑包将使用默认服务账户自动加载到 pod 中，路径为 &lt;code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&lt;/code>。如果您没有使用默认服务账户，请请求集群管理员构建包含您有权访问使用的证书包的 configmap。&lt;/p>
&lt;h2 id="请求认证">请求认证&lt;/h2>
&lt;p>以下部分演示如何为通过 DNS 访问的 Kubernetes 服务创建 TLS 证书。&lt;/p>
&lt;h3 id="下载安装-ssl">下载安装 SSL&lt;/h3>
&lt;p>&lt;a href="https://pkg.cfssl.org/" target="_blank" rel="noopener">下载 cfssl 工具&lt;/a>。&lt;/p>
&lt;h3 id="创建证书签名请求">创建证书签名请求&lt;/h3>
&lt;p>通过运行以下命令生成私钥和证书签名请求（或 CSR）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cat &lt;span class="s">&amp;lt;&amp;lt;EOF | cfssl genkey - | cfssljson -bare server
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">{
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;hosts&amp;#34;: [
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;my-svc.my-namespace.svc.cluster.local&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;my-pod.my-namespace.pod.cluster.local&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;172.168.0.24&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;10.0.34.2&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> ],
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;CN&amp;#34;: &amp;#34;my-pod.my-namespace.pod.cluster.local&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;key&amp;#34;: {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;algo&amp;#34;: &amp;#34;ecdsa&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;size&amp;#34;: 256
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>172.168.0.24&lt;/code> 是 service 的 cluster IP，&lt;code>my-svc.my-namespace.svc.cluster.local&lt;/code> 是 service 的 DNS 名称， &lt;code>10.0.34.2&lt;/code> 是 Pod 的 IP， &lt;code>my-pod.my-namespace.pod.cluster.local&lt;/code> 是 pod 的 DNS 名称，你可以看到以下输出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">2017/03/21 06:48:17 [INFO] generate received request&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">2017/03/21 06:48:17 [INFO] received CSR&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">2017/03/21 06:48:17 [INFO] generating key: ecdsa-256&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">2017/03/21 06:48:17 [INFO] encoded CSR&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此命令生成两个文件；它生成包含 PEM 编码的 &lt;a href="https://datatracker.ietf.org/doc/html/rfc2986" target="_blank" rel="noopener">pkcs #10&lt;/a> 认证请求的 &lt;code>server.csr&lt;/code>，以及包含仍然要创建的证书的 PEM 编码密钥的 &lt;code>server-key.pem&lt;/code>。&lt;/p>
&lt;h3 id="创建证书签名请求对象以发送到-kubernetes-api">创建证书签名请求对象以发送到 Kubernetes API&lt;/h3>
&lt;p>使用以下命令创建 CSR yaml 文件，并发送到 API server：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cat &lt;span class="s">&amp;lt;&amp;lt;EOF | kubectl create -f -
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">apiVersion: certificates.k8s.io/v1beta1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">kind: CertificateSigningRequest
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">metadata:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> name: my-svc.my-namespace
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">spec:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> groups:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> - system:authenticated
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> request: $(cat server.csr | base64 | tr -d &amp;#39;\n&amp;#39;)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> usages:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> - digital signature
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> - key encipherment
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> - server auth
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意，在步骤 1 中创建的 &lt;code>server.csr&lt;/code> 文件是 base64 编码并存储在&lt;code>.spec.request&lt;/code> 字段中。我们还要求提供 “数字签名”，“密钥加密” 和 “服务器身份验证” 密钥用途的证书。&lt;/p>
&lt;p>在 API server 中可以看到这些 CSR 处于 pending 状态。执行下面的命令你将可以看到：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl describe csr my-svc.my-namespace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Name: my-svc.my-namespace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Labels: &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Annotations: &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CreationTimestamp: Tue, &lt;span class="m">21&lt;/span> Mar &lt;span class="m">2017&lt;/span> 07:03:51 -0700
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Requesting User: yourname@example.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Status: Pending
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Subject:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Common Name: my-svc.my-namespace.svc.cluster.local
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Serial Number:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Subject Alternative Names:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> DNS Names: my-svc.my-namespace.svc.cluster.local
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> IP Addresses: 172.168.0.24
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 10.0.34.2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Events: &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="获取证书签名请求">获取证书签名请求&lt;/h3>
&lt;p>批准证书签名请求是通过自动批准过程完成的，或由集群管理员一次完成。有关这方面涉及的更多信息，请参见下文。&lt;/p>
&lt;h3 id="下载签名并使用">下载签名并使用&lt;/h3>
&lt;p>一旦 CSR 被签署并获得批准，您应该看到以下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get csr
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NAME AGE REQUESTOR CONDITION
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">my-svc.my-namespace 10m yourname@example.com Approved,Issued
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以通过运行以下命令下载颁发的证书并将其保存到 &lt;code>server.crt&lt;/code> 文件中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get csr my-svc.my-namespace -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.status.certificate}&amp;#39;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="p">|&lt;/span> base64 -d &amp;gt; server.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在你可以用 &lt;code>server.crt&lt;/code> 和 &lt;code>server-key.pem&lt;/code> 来做为 keypair 来启动 HTTPS server。&lt;/p>
&lt;h2 id="批准证书签名请求">批准证书签名请求&lt;/h2>
&lt;p>Kubernetes 管理员（具有适当权限）可以使用 &lt;code>kubectl certificate approve&lt;/code> 和 &lt;code>kubectl certificate deny&lt;/code> 命令手动批准（或拒绝）证书签名请求。但是，如果您打算大量使用此 API，则可以考虑编写自动化的证书控制器。&lt;/p>
&lt;p>如果上述机器或人类使用 kubectl，批准者的作用是验证 CSR 满足如下两个要求：&lt;/p>
&lt;ol>
&lt;li>CSR 的主体控制用于签署 CSR 的私钥。这解决了伪装成授权主体的第三方的威胁。在上述示例中，此步骤将验证该 pod 控制了用于生成 CSR 的私钥。&lt;/li>
&lt;li>CSR 的主体被授权在请求的上下文中执行。这解决了我们加入集群的我们不期望的主体的威胁。在上述示例中，此步骤将是验证该 pod 是否被允许加入到所请求的服务中。&lt;/li>
&lt;/ol>
&lt;p>当且仅当满足这两个要求时，审批者应该批准 CSR，否则拒绝 CSR。&lt;/p>
&lt;h2 id="给集群管理员的一个建议">给集群管理员的一个建议&lt;/h2>
&lt;p>本教程假设将 signer 设置为服务证书 API。Kubernetes controller manager 提供了一个 signer 的默认实现。要启用它，请将 &lt;code>--cluster-signing-cert-file&lt;/code> 和 &lt;code>--cluster-signing-key-file&lt;/code> 参数传递给 controller manager，并配置具有证书颁发机构的密钥对的路径。&lt;/p></description></item><item><title>tls-bootstrapping</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/tls-bootstrapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/13.%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%A1%E7%90%86/tls-bootstrapping/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 86
title: TLS Bootstrap
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>本文档介绍如何为 kubelet 设置 TLS 客户端证书引导（bootstrap）。&lt;/p>
&lt;p>Kubernetes 1.4 引入了一个用于从集群级证书颁发机构（CA）请求证书的 API。此 API 的原始目的是为 kubelet 提供 TLS 客户端证书。可以在 &lt;a href="https://github.com/kubernetes/kubernetes/pull/20439" target="_blank" rel="noopener">这里&lt;/a> 找到该提议，在 &lt;a href="https://github.com/kubernetes/features/issues/43" target="_blank" rel="noopener">feature #43&lt;/a> 追踪该功能的进度。&lt;/p>
&lt;h2 id="kube-apiserver-配置">kube-apiserver 配置&lt;/h2>
&lt;p>您必须提供一个 token 文件，该文件中指定了至少一个分配给 kubelet 特定 bootstrap 组的 “bootstrap token”。&lt;/p>
&lt;p>该组将作为 controller manager 配置中的默认批准控制器而用于审批。随着此功能的成熟，您应该确保 token 被绑定到基于角色的访问控制（RBAC）策略上，该策略严格限制了与证书配置相关的客户端请求（使用 bootstrap token）。使用 RBAC，将 token 范围划分为组可以带来很大的灵活性（例如，当您配置完成节点后，您可以禁用特定引导组的访问）。&lt;/p>
&lt;h3 id="token-认证文件">Token 认证文件&lt;/h3>
&lt;p>Token 可以是任意的，但应该可以表示为从安全随机数生成器（例如大多数现代操作系统中的 /dev/urandom）导出的至少 128 位熵。生成 token 有很多中方式。例如：&lt;/p>
&lt;p>&lt;code>head -c 16 /dev/urandom | od -An -t x | tr -d ' '&lt;/code>&lt;/p>
&lt;p>产生的 token 类似于这样： &lt;code>02b50b05283e98dd0fd71db496ef01e8&lt;/code>。&lt;/p>
&lt;p>Token 文件应该类似于以下示例，其中前三个值可以是任何值，引用的组名称应如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,system:kubelet-bootstrap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：&lt;code>system:kubelet-bootstrap&lt;/code> 的配置，当只有一个组时，不需要加引号。&lt;/p>
&lt;p>在 kube-apiserver 命令中添加 &lt;code>--token-auth-file=FILENAME&lt;/code> 标志（可能在您的 systemd unit 文件中）来启用 token 文件。&lt;/p>
&lt;p>查看 &lt;a href="https://kubernetes.io/docs/admin/authentication/#static-token-file" target="_blank" rel="noopener">该文档&lt;/a> 获取更多详细信息。&lt;/p>
&lt;h3 id="客户端证书-ca-包">客户端证书 CA 包&lt;/h3>
&lt;p>在 kube-apiserver 命令中添加 &lt;code>--client-ca-file=FILENAME&lt;/code> 标志启用客户端证书认证，指定包含签名证书的证书颁发机构包（例如 &lt;code>--client-ca-file=/var/lib/kubernetes/ca.pem&lt;/code>）。&lt;/p>
&lt;h3 id="kube-controller-manager-配置">kube-controller-manager 配置&lt;/h3>
&lt;p>请求证书的 API 向 Kubernetes controller manager 中添加证书颁发控制循环。使用磁盘上的 &lt;a href="https://blog.cloudflare.com/introducing-cfssl/" target="_blank" rel="noopener">cfssl&lt;/a> 本地签名文件的形式。目前，所有发型的证书均为一年有效期和并具有一系列关键用途。&lt;/p>
&lt;h3 id="签名文件">签名文件&lt;/h3>
&lt;p>您必须提供证书颁发机构，这样才能提供颁发证书所需的密码资料。&lt;/p>
&lt;p>kube-apiserver 通过指定的 &lt;code>--client-ca-file=FILENAME&lt;/code> 标志来认证和采信该 CA。CA 的管理超出了本文档的范围，但建议您为 Kubernetes 生成专用的 CA。&lt;/p>
&lt;p>假定证书和密钥都是 PEM 编码的。&lt;/p>
&lt;p>Kube-controller-manager 标志为：&lt;/p>
&lt;pre tabindex="0">&lt;code>--cluster-signing-cert-file=&amp;#34;/etc/path/to/kubernetes/ca/ca.crt&amp;#34; --cluster-signing-key-file=&amp;#34;/etc/path/to/kubernetes/ca/ca.key&amp;#34;
&lt;/code>&lt;/pre>&lt;h3 id="审批控制器">审批控制器&lt;/h3>
&lt;p>在 kubernetes 1.7 版本中，实验性的 “组自动批准” 控制器被弃用，新的 &lt;code>csrapproving&lt;/code> 控制器将作为 &lt;a href="https://kubernetes.io/docs/admin/kube-controller-manager" target="_blank" rel="noopener">kube-controller-manager&lt;/a> 的一部分，被默认启用。&lt;/p>
&lt;p>控制器使用 &lt;a href="https://kubernetes.io/docs/admin/authorization/#checking-api-access" target="_blank" rel="noopener">&lt;code>SubjectAccessReview&lt;/code> API&lt;/a> 来确定给定用户是否已被授权允许请求 CSR，然后根据授权结果进行批准。为了防止与其他批准者冲突，内置审批者没有明确地拒绝 CSR，只是忽略未经授权的请求。&lt;/p>
&lt;p>控制器将 CSR 分为三个子资源：&lt;/p>
&lt;ol>
&lt;li>&lt;code>nodeclient&lt;/code> ：用户的客户端认证请求 &lt;code>O=system:nodes&lt;/code>， &lt;code>CN=system:node:(node name)&lt;/code>。&lt;/li>
&lt;li>&lt;code>selfnodeclient&lt;/code>：更新具有相同 &lt;code>O&lt;/code> 和 &lt;code>CN&lt;/code> 的客户端证书的节点。&lt;/li>
&lt;li>&lt;code>selfnodeserver&lt;/code>：更新服务证书的节点（ALPHA，需要 feature gate）。&lt;/li>
&lt;/ol>
&lt;p>当前，确定 CSR 是否为 &lt;code>selfnodeserver&lt;/code> 请求的检查与 kubelet 的凭据轮换实现（Alpha 功能）相关联。因此，&lt;code>selfnodeserver&lt;/code> 的定义将来可能会改变，并且需要 Controller Manager 上的&lt;code>RotateKubeletServerCertificate&lt;/code> feature gate。该功能的进展可以在 &lt;a href="https://github.com/kubernetes/features/issues/267" target="_blank" rel="noopener">kubernetes/feature/#267&lt;/a> 上追踪。&lt;/p>
&lt;pre tabindex="0">&lt;code>--feature-gates=RotateKubeletServerCertificate=true
&lt;/code>&lt;/pre>&lt;p>以下 RBAC &lt;code>ClusterRoles&lt;/code> 代表 &lt;code>nodeClient&lt;/code>、&lt;code>selfnodeclient&lt;/code> 和 &lt;code>selfnodeserver&lt;/code> 功能。在以后的版本中可能会自动创建类似的角色。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># A ClusterRole which instructs the CSR approver to approve a user requesting&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># node client credentials.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">approve-node-client-csr&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;certificates.k8s.io&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;certificatesigningrequests/nodeclient&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># A ClusterRole which instructs the CSR approver to approve a node renewing its&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># own client credentials.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">approve-node-client-renewal-csr&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;certificates.k8s.io&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;certificatesigningrequests/selfnodeclient&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># A ClusterRole which instructs the CSR approver to approve a node requesting a&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># serving cert matching its client cert.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">approve-node-server-renewal-csr&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;certificates.k8s.io&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;certificatesigningrequests/selfnodeserver&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些权力可以授予给凭证，如 bootstrap token。例如，要复制由已被移除的自动批准标志提供的行为，由单个组批准所有的 CSR：&lt;/p>
&lt;pre tabindex="0">&lt;code># REMOVED: This flag no longer works as of 1.7.
--insecure-experimental-approve-all-kubelet-csrs-for-group=&amp;#34;kubelet-bootstrap-token&amp;#34;
&lt;/code>&lt;/pre>&lt;p>管理员将创建一个 &lt;code>ClusterRoleBinding&lt;/code> 来定位该组。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># Approve all CSRs for the group &amp;#34;kubelet-bootstrap-token&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">auto-approve-csrs-for-group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kubelet-bootstrap-token&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">approve-node-client-csr&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要让节点更新自己的凭据，管理员可以构造一个 &lt;code>ClusterRoleBinding&lt;/code> 来定位该节点的凭据。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node1-client-cert-renewal&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">User&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">system:node:node-1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Let &amp;#34;node-1&amp;#34; renew its client certificate.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">approve-node-client-renewal-csr&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除该绑定将会阻止节点更新客户端凭据，一旦其证书到期，实际上就会将其从集群中删除。&lt;/p>
&lt;h2 id="kubelet-配置">kubelet 配置&lt;/h2>
&lt;p>要向 kube-apiserver 请求客户端证书，kubelet 首先需要一个包含 bootstrap 身份验证 token 的 kubeconfig 文件路径。您可以使用 &lt;code>kubectl config set-cluster&lt;/code>，&lt;code>set-credentials&lt;/code> 和 &lt;code>set-context&lt;/code> 来构建此 kubeconfig 文件。为 &lt;code>kubectl config set-credentials&lt;/code> 提供 &lt;code>kubelet-bootstrap&lt;/code> 的名称，并包含 &lt;code>--token = &amp;lt;token-value&amp;gt;&lt;/code>，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl config set-credentials kubelet-bootstrap --token&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">BOOTSTRAP_TOKEN&lt;/span>&lt;span class="si">}&lt;/span> --kubeconfig&lt;span class="o">=&lt;/span>bootstrap.kubeconfig
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动 kubelet 时，如果 &lt;code>--kubeconfig&lt;/code> 指定的文件不存在，则使用 bootstrap kubeconfig 向 API server 请求客户端证书。在批准 &lt;code>kubelet&lt;/code> 的证书请求和回执时，将包含了生成的密钥和证书的 kubeconfig 文件写入由 &lt;code>-kubeconfig&lt;/code> 指定的路径。证书和密钥文件将被放置在由 &lt;code>--cert-dir&lt;/code> 指定的目录中。&lt;/p>
&lt;p>启动 kubelet 时启用 bootstrap 用到的标志：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">--experimental-bootstrap-kubeconfig&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/path/to/bootstrap/kubeconfig&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，在 1.7 中，kubelet 实现了 &lt;strong>Alpha&lt;/strong> 功能，使其客户端和/或服务器都能轮转提供证书。&lt;/p>
&lt;p>可以分别通过 kubelet 中的 &lt;code>RotateKubeletClientCertificate&lt;/code> 和 &lt;code>RotateKubeletServerCertificate&lt;/code> 功能标志启用此功能，但在未来版本中可能会以向后兼容的方式发生变化。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">--feature-gates&lt;span class="o">=&lt;/span>&lt;span class="nv">RotateKubeletClientCertificate&lt;/span>&lt;span class="o">=&lt;/span>true,RotateKubeletServerCertificate&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>RotateKubeletClientCertificate&lt;/code> 可以让 kubelet 在其现有凭据到期时通过创建新的 CSR 来轮换其客户端证书。&lt;code>RotateKubeletServerCertificate&lt;/code> 可以让 kubelet 在其引导客户端凭据后还可以请求服务证书，并轮换该证书。服务证书目前不要求 DNS 或 IP SANs。&lt;/p>
&lt;h2 id="kubectl-审批">kubectl 审批&lt;/h2>
&lt;p>签名控制器不会立即签署所有证书请求。相反，它会一直等待直到适当特权的用户被标记为 “已批准” 状态。这最终将是由外部审批控制器来处理的自动化过程，但是对于 alpha 版本的 API 来说，可以由集群管理员通过 kubectl 命令手动完成。&lt;/p>
&lt;p>管理员可以使用 &lt;code>kubectl get csr&lt;/code> 命令列出所有的 CSR，使用 &lt;code>kubectl describe csr &amp;lt;name&amp;gt;&lt;/code> 命令描述某个 CSR 的详细信息。在 1.6 版本以前，&lt;a href="https://github.com/kubernetes/kubernetes/issues/30163" target="_blank" rel="noopener">没有直接的批准/拒绝命令&lt;/a> ，因此审批者需要直接更新 Status 信息（&lt;a href="https://github.com/gtank/csrctl" target="_blank" rel="noopener">查看如何实现&lt;/a>）。此后的 Kubernetes 版本中提供了 &lt;code>kubectl certificate approve &amp;lt;name&amp;gt;&lt;/code> 和 &lt;code>kubectl certificate deny &amp;lt;name&amp;gt;&lt;/code> 命令。&lt;/p></description></item></channel></rss>