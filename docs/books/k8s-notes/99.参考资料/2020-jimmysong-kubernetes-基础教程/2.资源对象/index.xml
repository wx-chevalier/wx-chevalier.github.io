<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>_index | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/</link><atom:link href="https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/index.xml" rel="self" type="application/rss+xml"/><description>_index</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>_index</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/</link></image><item><title>14.Init 容器</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/14.init-%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/14.init-%E5%AE%B9%E5%99%A8/</guid><description>&lt;h1 id="init-容器">Init 容器&lt;/h1>
&lt;p>该特性在自 Kubernetes 1.6 版本推出 beta 版本。Init 容器可以在 PodSpec 中同应用程序的 &lt;code>containers&lt;/code> 数组一起来指定。此前 beta 注解的值仍将保留，并覆盖 PodSpec 字段值。&lt;/p>
&lt;p>本文讲解 Init 容器的基本概念，这是一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。&lt;/p>
&lt;h2 id="理解-init-容器">理解 Init 容器&lt;/h2>
&lt;p>&lt;a href="https://kubernetes.io/docs/concepts/abstractions/pod/" target="_blank" rel="noopener">Pod&lt;/a> 能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的 Init 容器。&lt;/p>
&lt;p>Init 容器与普通的容器非常像，除了如下两点：&lt;/p>
&lt;ul>
&lt;li>Init 容器总是运行到成功完成为止。&lt;/li>
&lt;li>每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。&lt;/li>
&lt;/ul>
&lt;p>如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 &lt;code>restartPolicy&lt;/code> 为 Never，它不会重新启动。&lt;/p>
&lt;p>指定容器为 Init 容器，在 PodSpec 中添加 &lt;code>initContainers&lt;/code> 字段，以 v1.Container 类型对象的 JSON 数组的形式，还有 app 的 &lt;code>containers&lt;/code> 数组。Init 容器的状态在 &lt;code>status.initContainerStatuses&lt;/code> 字段中以容器状态数组的格式返回（类似 &lt;code>status.containerStatuses&lt;/code> 字段）。&lt;/p>
&lt;h3 id="与普通容器的不同之处">与普通容器的不同之处&lt;/h3>
&lt;p>Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。然而，Init 容器对资源请求和限制的处理稍有不同，在下面 &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#resources" target="_blank" rel="noopener">资源&lt;/a> 处有说明。而且 Init 容器不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。&lt;/p>
&lt;p>如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。&lt;/p>
&lt;h2 id="init-容器能做什么">Init 容器能做什么？&lt;/h2>
&lt;p>因为 Init 容器具有与应用程序容器分离的单独镜像，所以它们的启动相关代码具有如下优势：&lt;/p>
&lt;ul>
&lt;li>它们可以包含并运行实用工具，但是出于安全考虑，是不建议在应用程序容器镜像中包含这些实用工具的。&lt;/li>
&lt;li>它们可以包含使用工具和定制化代码来安装，但是不能出现在应用程序镜像中。例如，创建镜像没必要 &lt;code>FROM&lt;/code> 另一个镜像，只需要在安装过程中使用类似 &lt;code>sed&lt;/code>、 &lt;code>awk&lt;/code>、 &lt;code>python&lt;/code> 或 &lt;code>dig&lt;/code> 这样的工具。&lt;/li>
&lt;li>应用程序镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。&lt;/li>
&lt;li>Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。&lt;/li>
&lt;li>它们必须在应用程序容器启动之前运行完成，而应用程序容器是并行运行的，所以 Init 容器能够提供了一种简单的阻塞或延迟应用容器的启动的方法，直到满足了一组先决条件。&lt;/li>
&lt;/ul>
&lt;h3 id="示例">示例&lt;/h3>
&lt;p>下面列举了 Init 容器的一些用途：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>等待一个 Service 创建完成，通过类似如下 shell 命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> i in &lt;span class="o">{&lt;/span>1..100&lt;span class="o">}&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> sleep 1&lt;span class="p">;&lt;/span> &lt;span class="k">if&lt;/span> dig myservice&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="nb">exit&lt;/span> 0&lt;span class="p">;&lt;/span> &lt;span class="k">fi&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nb">exit&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>将 Pod 注册到远程服务器，通过在命令中调用 API，类似如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl -X POST http://&lt;span class="nv">$MANAGEMENT_SERVICE_HOST&lt;/span>:&lt;span class="nv">$MANAGEMENT_SERVICE_PORT&lt;/span>/register -d &lt;span class="s1">&amp;#39;instance=$(&amp;lt;POD_NAME&amp;gt;)&amp;amp;ip=$(&amp;lt;POD_IP&amp;gt;)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>在启动应用容器之前等一段时间，使用类似 &lt;code>sleep 60&lt;/code> 的命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>克隆 Git 仓库到数据卷。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将配置值放到配置文件中，运行模板工具为主应用容器动态地生成配置文件。例如，在配置文件中存放 POD_IP 值，并使用 Jinja 生成主应用配置文件。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多详细用法示例，可以在 &lt;a href="https://kubernetes.io/docs/concepts/abstractions/controllers/statefulsets/" target="_blank" rel="noopener">StatefulSet 文档&lt;/a> 和 &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" target="_blank" rel="noopener">生产环境 Pod 指南&lt;/a> 中找到。&lt;/p>
&lt;h3 id="使用-init-容器">使用 Init 容器&lt;/h3>
&lt;p>下面是 Kubernetes 1.5 版本 yaml 文件，展示了一个具有 2 个 Init 容器的简单 Pod。第一个等待 &lt;code>myservice&lt;/code> 启动，第二个等待 &lt;code>mydb&lt;/code> 启动。一旦这两个 Service 都启动完成，Pod 将开始启动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">pod.beta.kubernetes.io/init-containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;[
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#34;name&amp;#34;: &amp;#34;init-myservice&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#34;image&amp;#34;: &amp;#34;busybox&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#34;command&amp;#34;: [&amp;#34;sh&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> },
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#34;name&amp;#34;: &amp;#34;init-mydb&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#34;image&amp;#34;: &amp;#34;busybox&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#34;command&amp;#34;: [&amp;#34;sh&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> ]&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;sh&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;-c&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;echo The app is running! &amp;amp;&amp;amp; sleep 3600&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是 Kubernetes 1.6 版本的新语法，尽管老的 annotation 语法仍然可以使用。我们已经把 Init 容器的声明移到 &lt;code>spec&lt;/code> 中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;echo The app is running! &amp;amp;&amp;amp; sleep 3600&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">initContainers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">init-myservice&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">init-mydb&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>注意：版本兼容性问题&lt;/strong>&lt;/p>
&lt;p>1.5 版本的语法在 1.6 和 1.7 版本中仍然可以使用，但是我们推荐使用 1.6 版本的新语法。Kubernetes 1.8 以后的版本只支持新语法。在 Kubernetes 1.6 版本中，Init 容器在 API 中新建了一个字段。虽然期望使用 beta 版本的 annotation，但在未来发行版将会被废弃掉。&lt;/p>
&lt;/blockquote>
&lt;p>下面的 YAML 文件展示了 &lt;code>mydb&lt;/code> 和 &lt;code>myservice&lt;/code> 两个 Service：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myservice&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">9376&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mydb&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">9377&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 Pod 可以使用下面的命令进行启动和调试：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl create -f myapp.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pod &lt;span class="s2">&amp;#34;myapp-pod&amp;#34;&lt;/span> created
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl get -f myapp.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NAME READY STATUS RESTARTS AGE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">myapp-pod 0/1 Init:0/2 &lt;span class="m">0&lt;/span> 6m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl describe -f myapp.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Name: myapp-pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Namespace: default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Labels: &lt;span class="nv">app&lt;/span>&lt;span class="o">=&lt;/span>myapp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Status: Pending
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Init Containers:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> init-myservice:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> State: Running
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> init-mydb:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> State: Waiting
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Reason: PodInitializing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Ready: False
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Containers:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> myapp-container:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> State: Waiting
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Reason: PodInitializing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Ready: False
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Events:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FirstSeen LastSeen Count From SubObjectPath Type Reason Message
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --------- -------- ----- ---- ------------- -------- ------ -------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 16s 16s &lt;span class="m">1&lt;/span> &lt;span class="o">{&lt;/span>default-scheduler &lt;span class="o">}&lt;/span> Normal Scheduled Successfully assigned myapp-pod to 172.17.4.201
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 16s 16s &lt;span class="m">1&lt;/span> &lt;span class="o">{&lt;/span>kubelet 172.17.4.201&lt;span class="o">}&lt;/span> spec.initContainers&lt;span class="o">{&lt;/span>init-myservice&lt;span class="o">}&lt;/span> Normal Pulling pulling image &lt;span class="s2">&amp;#34;busybox&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 13s 13s &lt;span class="m">1&lt;/span> &lt;span class="o">{&lt;/span>kubelet 172.17.4.201&lt;span class="o">}&lt;/span> spec.initContainers&lt;span class="o">{&lt;/span>init-myservice&lt;span class="o">}&lt;/span> Normal Pulled Successfully pulled image &lt;span class="s2">&amp;#34;busybox&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 13s 13s &lt;span class="m">1&lt;/span> &lt;span class="o">{&lt;/span>kubelet 172.17.4.201&lt;span class="o">}&lt;/span> spec.initContainers&lt;span class="o">{&lt;/span>init-myservice&lt;span class="o">}&lt;/span> Normal Created Created container with docker id 5ced34a04634&lt;span class="p">;&lt;/span> Security:&lt;span class="o">[&lt;/span>&lt;span class="nv">seccomp&lt;/span>&lt;span class="o">=&lt;/span>unconfined&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 13s 13s &lt;span class="m">1&lt;/span> &lt;span class="o">{&lt;/span>kubelet 172.17.4.201&lt;span class="o">}&lt;/span> spec.initContainers&lt;span class="o">{&lt;/span>init-myservice&lt;span class="o">}&lt;/span> Normal Started Started container with docker id 5ced34a04634
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl logs myapp-pod -c init-myservice &lt;span class="c1"># Inspect the first init container&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl logs myapp-pod -c init-mydb &lt;span class="c1"># Inspect the second init container&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一旦我们启动了 &lt;code>mydb&lt;/code> 和 &lt;code>myservice&lt;/code> 这两个 Service，我们能够看到 Init 容器完成，并且 &lt;code>myapp-pod&lt;/code> 被创建：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl create -f services.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">service &lt;span class="s2">&amp;#34;myservice&amp;#34;&lt;/span> created
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">service &lt;span class="s2">&amp;#34;mydb&amp;#34;&lt;/span> created
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl get -f myapp.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NAME READY STATUS RESTARTS AGE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">myapp-pod 1/1 Running &lt;span class="m">0&lt;/span> 9m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子非常简单，但是应该能够为我们创建自己的 Init 容器提供一些启发。&lt;/p>
&lt;h2 id="具体行为">具体行为&lt;/h2>
&lt;p>在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 &lt;code>restartPolicy&lt;/code> 指定的策略进行重试。然而，如果 Pod 的 &lt;code>restartPolicy&lt;/code> 设置为 Always，Init 容器失败时会使用 &lt;code>RestartPolicy&lt;/code> 策略。&lt;/p>
&lt;p>在所有的 Init 容器没有成功之前，Pod 将不会变成 &lt;code>Ready&lt;/code> 状态。Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 &lt;code>Pending&lt;/code> 状态，但应该会将 &lt;code>Initializing&lt;/code> 状态设置为 true。&lt;/p>
&lt;p>如果 Pod &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#pod-restart-reasons" target="_blank" rel="noopener">重启&lt;/a>，所有 Init 容器必须重新执行。&lt;/p>
&lt;p>对 Init 容器 spec 的修改被限制在容器 image 字段，修改其他字段都不会生效。更改 Init 容器的 image 字段，等价于重启该 Pod。&lt;/p>
&lt;p>因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。特别地当写到 &lt;code>EmptyDirs&lt;/code> 文件中的代码，应该对输出文件可能已经存在做好准备。&lt;/p>
&lt;p>Init 容器具有应用容器的所有字段。除了 &lt;code>readinessProbe&lt;/code>，因为 Init 容器无法定义不同于完成（completion）的就绪（readiness）之外的其他状态。这会在验证过程中强制执行。&lt;/p>
&lt;p>在 Pod 上使用 &lt;code>activeDeadlineSeconds&lt;/code>，在容器上使用 &lt;code>livenessProbe&lt;/code>，这样能够避免 Init 容器一直失败。这就为 Init 容器活跃设置了一个期限。&lt;/p>
&lt;p>在 Pod 中的每个 app 和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证时抛出错误。&lt;/p>
&lt;h3 id="资源">资源&lt;/h3>
&lt;p>为 Init 容器指定顺序和执行逻辑，下面对资源使用的规则将被应用：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在所有 Init 容器上定义的，任何特殊资源请求或限制的最大值，是 &lt;em>有效初始请求/限制&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pod 对资源的有效请求/限制要高于：&lt;/p>
&lt;ul>
&lt;li>所有应用容器对某个资源的请求/限制之和&lt;/li>
&lt;li>对某个资源的有效初始请求/限制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>基于有效请求/限制完成调度，这意味着 Init 容器能够为初始化预留资源，这些资源在 Pod 生命周期过程中并没有被使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pod 的 &lt;em>有效 QoS 层&lt;/em>，是 Init 容器和应用容器相同的 QoS 层。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>基于有效 Pod 请求和限制来应用配额和限制。Pod 级别的 cgroups 是基于有效 Pod 请求和限制，和调度器相同。&lt;/p>
&lt;h3 id="pod-重启的原因">Pod 重启的原因&lt;/h3>
&lt;p>Pod 重启，会导致 Init 容器重新执行，主要有如下几个原因：&lt;/p>
&lt;ul>
&lt;li>用户更新 PodSpec 导致 Init 容器镜像发生改变。应用容器镜像的变更只会重启应用容器。&lt;/li>
&lt;li>Pod 基础设施容器被重启。这不多见，但某些具有 root 权限可访问 Node 的人可能会这样做。&lt;/li>
&lt;li>当 &lt;code>restartPolicy&lt;/code> 设置为 Always，Pod 中所有容器会终止，强制重启，由于垃圾收集导致 Init 容器完整的记录丢失。&lt;/li>
&lt;/ul>
&lt;h2 id="支持与兼容性">支持与兼容性&lt;/h2>
&lt;p>API Server 版本为 1.6 或更高版本的集群，通过使用 &lt;code>spec.initContainers&lt;/code> 字段来支持 Init 容器。之前的版本可以使用 alpha 和 beta 注解支持 Init 容器。&lt;code>spec.initContainers&lt;/code> 字段也被加入到 alpha 和 beta 注解中，所以 Kubernetes 1.3.0 版本或更高版本可以执行 Init 容器，并且 1.6 版本的 API Server 能够安全地回退到 1.5.x 版本，而不会使已创建的 Pod 失去 Init 容器的功能。&lt;/p></description></item><item><title>pause-container</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pause-container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pause-container/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 15
title: Pause 容器
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>Pause 容器，又叫 Infra 容器，本文将探究该容器的作用与原理。&lt;/p>
&lt;p>我们知道在 kubelet 的配置中有这样一个参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">KUBELET_POD_INFRA_CONTAINER&lt;/span>&lt;span class="o">=&lt;/span>--pod-infra-container-image&lt;span class="o">=&lt;/span>registry.access.redhat.com/rhel7/pod-infrastructure:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面是 openshift 中的配置参数，kubernetes 中默认的配置参数是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">KUBELET_POD_INFRA_CONTAINER&lt;/span>&lt;span class="o">=&lt;/span>--pod-infra-container-image&lt;span class="o">=&lt;/span>gcr.io/google_containers/pause-amd64:3.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pause 容器，是可以自己来定义，官方使用的 &lt;code>gcr.io/google_containers/pause-amd64:3.0&lt;/code> 容器的代码见 &lt;a href="https://github.com/kubernetes/kubernetes/tree/master/build/pause" target="_blank" rel="noopener">Github&lt;/a>，使用 C 语言编写。&lt;/p>
&lt;h2 id="pause-容器特点">Pause 容器特点&lt;/h2>
&lt;ul>
&lt;li>镜像非常小，目前在 700KB 左右&lt;/li>
&lt;li>永远处于 Pause (暂停) 状态&lt;/li>
&lt;/ul>
&lt;h2 id="pause-容器背景">Pause 容器背景&lt;/h2>
&lt;p>像 Pod 这样一个东西，本身是一个逻辑概念。那在机器上，它究竟是怎么实现的呢？这就是我们要解释的一个问题。&lt;/p>
&lt;p>既然说 Pod 要解决这个问题，核心就在于如何让一个 Pod 里的多个容器之间最高效的共享某些资源和数据。&lt;/p>
&lt;p>因为容器之间原本是被 Linux Namespace 和 cgroups 隔开的，所以现在实际要解决的是怎么去打破这个隔离，然后共享某些事情和某些信息。这就是 Pod 的设计要解决的核心问题所在。&lt;/p>
&lt;p>所以说具体的解法分为两个部分：网络和存储。&lt;/p>
&lt;p>Pause 容器就是为解决 Pod 中的网络问题而生的。&lt;/p>
&lt;h2 id="pause-容器实现">Pause 容器实现&lt;/h2>
&lt;p>Pod 里的多个容器怎么去共享网络？下面是个例子：&lt;/p>
&lt;p>比如说现在有一个 Pod，其中包含了一个容器 A 和一个容器 B，它们两个就要共享 Network Namespace。在 Kubernetes 里的解法是这样的：它会在每个 Pod 里，额外起一个 Infra container 小容器来共享整个 Pod 的 Network Namespace。&lt;/p>
&lt;p>Infra container 是一个非常小的镜像，大概 700KB 左右，是一个 C 语言写的、永远处于 “暂停” 状态的容器。由于有了这样一个 Infra container 之后，其他所有容器都会通过 Join Namespace 的方式加入到 Infra container 的 Network Namespace 中。&lt;/p>
&lt;p>所以说一个 Pod 里面的所有容器，它们看到的网络视图是完全一样的。即：它们看到的网络设备、IP 地址、Mac 地址等等，跟网络相关的信息，其实全是一份，这一份都来自于 Pod 第一次创建的这个 Infra container。这就是 Pod 解决网络共享的一个解法。&lt;/p>
&lt;p>在 Pod 里面，一定有一个 IP 地址，是这个 Pod 的 Network Namespace 对应的地址，也是这个 Infra container 的 IP 地址。所以大家看到的都是一份，而其他所有网络资源，都是一个 Pod 一份，并且被 Pod 中的所有容器共享。这就是 Pod 的网络实现方式。&lt;/p>
&lt;p>由于需要有一个相当于说中间的容器存在，所以整个 Pod 里面，必然是 Infra container 第一个启动。并且整个 Pod 的生命周期是等同于 Infra container 的生命周期的，与容器 A 和 B 是无关的。这也是为什么在 Kubernetes 里面，它是允许去单独更新 Pod 里的某一个镜像的，即：做这个操作，整个 Pod 不会重建，也不会重启，这是非常重要的一个设计。&lt;/p>
&lt;h2 id="pause-容器的作用">Pause 容器的作用&lt;/h2>
&lt;p>我们检查 node 节点的时候会发现每个 node 上都运行了很多的 pause 容器，例如如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ docker ps
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2c7d50f1a7be docker.io/jimmysong/heapster-grafana-amd64@sha256:d663759b3de86cf62e64a43b021f133c383e8f7b0dc2bdd78115bc95db371c9a &lt;span class="s2">&amp;#34;/run.sh&amp;#34;&lt;/span> &lt;span class="m">3&lt;/span> hours ago Up &lt;span class="m">3&lt;/span> hours k8s_grafana_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5df93dea877a docker.io/jimmysong/heapster-influxdb-amd64@sha256:a217008b68cb49e8f038c4eeb6029261f02adca81d8eae8c5c01d030361274b8 &lt;span class="s2">&amp;#34;influxd --config ...&amp;#34;&lt;/span> &lt;span class="m">3&lt;/span> hours ago Up &lt;span class="m">3&lt;/span> hours k8s_influxdb_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9cec6c0ef583 jimmysong/pause-amd64:3.0 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> &lt;span class="m">3&lt;/span> hours ago Up &lt;span class="m">3&lt;/span> hours k8s_POD_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">54d06e30a4c7 docker.io/jimmysong/kubernetes-dashboard-amd64@sha256:668710d034c4209f8fa9a342db6d8be72b6cb5f1f3f696cee2379b8512330be4 &lt;span class="s2">&amp;#34;/dashboard --inse...&amp;#34;&lt;/span> &lt;span class="m">3&lt;/span> hours ago Up &lt;span class="m">3&lt;/span> hours k8s_kubernetes-dashboard_kubernetes-dashboard-65486f5fdf-lshl7_kube-system_27c414a1-29c0-11e8-9e88-525400005732_0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5a5ef33b0d58 jimmysong/pause-amd64:3.0 &lt;span class="s2">&amp;#34;/pause&amp;#34;&lt;/span> &lt;span class="m">3&lt;/span> hours ago Up &lt;span class="m">3&lt;/span> hours k8s_POD_kubernetes-dashboard-65486f5fdf-lshl7_kube-system_27c414a1-29c0-11e8-9e88-525400005732_0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>kubernetes 中的 pause 容器主要为每个业务容器提供以下功能：&lt;/p>
&lt;ul>
&lt;li>在 pod 中担任 Linux 命名空间共享的基础；&lt;/li>
&lt;li>启用 pid 命名空间，开启 init 进程。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">这篇文章&lt;/a>做出了详细的说明，pause 容器的作用可以从这个例子中看出，首先见下图：&lt;/p>
&lt;p>
&lt;figure id="figure-pause-容器示意图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/pause-container.png" alt="Pause容器" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Pause 容器示意图
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>我们首先在节点上运行一个 pause 容器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker run -d --name pause -p 8880:80 --ipc&lt;span class="o">=&lt;/span>shareable jimmysong/pause-amd64:3.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后再运行一个 nginx 容器，nginx 将为 &lt;code>localhost:2368&lt;/code> 创建一个代理。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cat &lt;span class="s">&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt; nginx.conf
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">error_log stderr;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">events { worker_connections 1024; }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">http {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> access_log /dev/stdout combined;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> server {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> listen 80 default_server;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> server_name example.com www.example.com;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> location / {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> proxy_pass http://127.0.0.1:2368;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -d --name nginx -v &lt;span class="sb">`&lt;/span>&lt;span class="nb">pwd&lt;/span>&lt;span class="sb">`&lt;/span>/nginx.conf:/etc/nginx/nginx.conf --net&lt;span class="o">=&lt;/span>container:pause --ipc&lt;span class="o">=&lt;/span>container:pause --pid&lt;span class="o">=&lt;/span>container:pause nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后再为 &lt;a href="https://github.com/TryGhost/Ghost" target="_blank" rel="noopener">ghost&lt;/a> 创建一个应用容器，这是一款博客软件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ docker run -d --name ghost --net&lt;span class="o">=&lt;/span>container:pause --ipc&lt;span class="o">=&lt;/span>container:pause --pid&lt;span class="o">=&lt;/span>container:pause ghost
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在访问 http://localhost:8880/ 就可以看到 ghost 博客的界面了。&lt;/p>
&lt;p>&lt;strong>解析&lt;/strong>&lt;/p>
&lt;p>pause 容器将内部的 80 端口映射到宿主机的 8880 端口，pause 容器在宿主机上设置好了网络 namespace 后，nginx 容器加入到该网络 namespace 中，我们看到 nginx 容器启动的时候指定了 &lt;code>--net=container:pause&lt;/code>，ghost 容器同样加入到了该网络 namespace 中，这样三个容器就共享了网络，互相之间就可以使用 &lt;code>localhost&lt;/code> 直接通信，&lt;code>--ipc=contianer:pause --pid=container:pause&lt;/code> 就是三个容器处于同一个 namespace 中，init 进程为 &lt;code>pause&lt;/code>，这时我们进入到 ghost 容器中查看进程情况。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ps aux&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root &lt;span class="m">1&lt;/span> 0.0 0.0 &lt;span class="m">1024&lt;/span> &lt;span class="m">4&lt;/span> ? Ss 13:49 0:00 /pause
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root &lt;span class="m">5&lt;/span> 0.0 0.1 &lt;span class="m">32432&lt;/span> &lt;span class="m">5736&lt;/span> ? Ss 13:51 0:00 nginx: master p
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">systemd+ &lt;span class="m">9&lt;/span> 0.0 0.0 &lt;span class="m">32980&lt;/span> &lt;span class="m">3304&lt;/span> ? S 13:51 0:00 nginx: worker p
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">node &lt;span class="m">10&lt;/span> 0.3 2.0 &lt;span class="m">1254200&lt;/span> &lt;span class="m">83788&lt;/span> ? Ssl 13:53 0:03 node current/in
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root &lt;span class="m">79&lt;/span> 0.1 0.0 &lt;span class="m">4336&lt;/span> &lt;span class="m">812&lt;/span> pts/0 Ss 14:09 0:00 sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root &lt;span class="m">87&lt;/span> 0.0 0.0 &lt;span class="m">17500&lt;/span> &lt;span class="m">2080&lt;/span> pts/0 R+ 14:10 0:00 ps aux
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 ghost 容器中同时可以看到 pause 和 nginx 容器的进程，并且 pause 容器的 PID 是 1。而在 Kubernetes 中容器的 PID=1 的进程即为容器本身的业务进程。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="noopener">The Almighty Pause Container - ianlewis.org&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://o-my-chenjian.com/2017/10/17/The-Pause-Container-Of-Kubernetes/" target="_blank" rel="noopener">Kubernetes 之 Pause 容器 - o-my-chenjian.com&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>pod</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 13
title: Pod 解析
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>Pod 是 Kubernetes 中可以创建的最小部署单元，也是 Kubernetes REST API 中的顶级资源类型。&lt;/p>
&lt;p>在 Kuberentes V1 core API 版本中的 Pod 的数据结构如下图所示：&lt;/p>
&lt;p>
&lt;figure id="figure-pod-cheatsheet">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/kubernetes-pod-cheatsheet.png" alt="Pod Cheatsheet" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Pod Cheatsheet
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h2 id="什么是-pod">什么是 Pod？&lt;/h2>
&lt;p>Pod 就像是豌豆荚一样，它由一个或者多个容器组成（例如 Docker 容器），它们共享容器存储、网络和容器运行配置项。Pod 中的容器总是被同时调度，有共同的运行环境。你可以把单个 Pod 想象成是运行独立应用的 “逻辑主机”—— 其中运行着一个或者多个紧密耦合的应用容器 —— 在有容器之前，这些应用都是运行在几个相同的物理机或者虚拟机上。&lt;/p>
&lt;p>尽管 kubernetes 支持多种容器运行时，但是 Docker 依然是最常用的运行时环境，我们可以使用 Docker 的术语和规则来定义 Pod。&lt;/p>
&lt;p>Pod 中共享的环境包括 Linux 的 namespace、cgroup 和其他可能的隔绝环境，这一点跟 Docker 容器一致。在 Pod 的环境中，每个容器中可能还有更小的子隔离环境。&lt;/p>
&lt;p>Pod 中的容器共享 IP 地址和端口号，它们之间可以通过 &lt;code>localhost&lt;/code> 互相发现。它们之间可以通过进程间通信，例如 &lt;a href="https://en.wikipedia.org/wiki/UNIX_System_V" target="_blank" rel="noopener">SystemV&lt;/a> 信号或者 POSIX 共享内存。不同 Pod 之间的容器具有不同的 IP 地址，不能直接通过 IPC 通信。&lt;/p>
&lt;p>Pod 中的容器也有访问共享 volume 的权限，这些 volume 会被定义成 pod 的一部分并挂载到应用容器的文件系统中。&lt;/p>
&lt;p>根据 Docker 的结构，Pod 中的容器共享 namespace 和 volume，不支持共享 PID 的 namespace。&lt;/p>
&lt;p>就像每个应用容器，pod 被认为是临时（非持久的）实体。在 Pod 的生命周期中讨论过，pod 被创建后，被分配一个唯一的 ID（UID），调度到节点上，并一致维持期望的状态直到被终结（根据重启策略）或者被删除。如果 node 死掉了，分配到了这个 node 上的 pod，在经过一个超时时间后会被重新调度到其他 node 节点上。一个给定的 pod（如 UID 定义的）不会被 “重新调度” 到新的节点上，而是被一个同样的 pod 取代，如果期望的话甚至可以是相同的名字，但是会有一个新的 UID。&lt;/p>
&lt;p>临时卷的生命周期跟 pod 相同，当 Pod 因为某种原因被删除或者被新创建的相同的 pod 取代时，pod 的附属物（例如 volume）也会被销毁和重新创建。Kubernetes 中提供了众多的卷类型，关于卷（Volume）的详细介绍请参考 &lt;a href="https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/" target="_blank" rel="noopener">Kubernetes 文档&lt;/a>。&lt;/p>
&lt;p>
&lt;figure id="figure-pod-示意图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/pod-overview.png" alt="Pod 示意图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Pod 示意图
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>说明：一个多容器 Pod，包含文件提取程序和 Web 服务器，该服务器使用持久卷在容器之间共享存储。&lt;/p>
&lt;h2 id="pod-的动机">Pod 的动机&lt;/h2>
&lt;h3 id="管理">管理&lt;/h3>
&lt;p>Pod 是一个服务的多个进程的聚合单位，pod 提供这种模型能够简化应用部署管理，通过提供一个更高级别的抽象的方式。Pod 作为一个独立的部署单位，支持横向扩展和复制。共生（协同调度），命运共同体（例如被终结），协同复制，资源共享，依赖管理，pod 都会自动的为容器处理这些问题。&lt;/p>
&lt;h3 id="资源共享和通信">资源共享和通信&lt;/h3>
&lt;p>Pod 中的应用可以共享网络空间（IP 地址和端口），因此可以通过 &lt;code>localhost&lt;/code> 互相发现。因此，pod 中的应用必须协调端口占用。每个 pod 都有一个唯一的 IP 地址，跟物理机和其他 pod 都处于一个扁平的网络空间中，它们之间可以直接连通。&lt;/p>
&lt;p>Pod 中应用容器的 hostname 被设置成 Pod 的名字。&lt;/p>
&lt;p>Pod 中的应用容器可以共享卷。持久化卷能够保证 pod 重启时使用的数据不丢失。&lt;/p>
&lt;h2 id="pod-的使用">Pod 的使用&lt;/h2>
&lt;p>Pod 也可以用于垂直应用栈（例如 LAMP），这样使用的主要动机是为了支持共同调度和协调管理应用程序，例如：&lt;/p>
&lt;ul>
&lt;li>内容管理系统、文件和数据加载器、本地换群管理器等。&lt;/li>
&lt;li>日志和检查点备份、压缩、旋转、快照等。&lt;/li>
&lt;li>数据变更观察者、日志和监控适配器、活动发布者等。&lt;/li>
&lt;li>代理、桥接和适配器等。&lt;/li>
&lt;li>控制器、管理器、配置器、更新器等。&lt;/li>
&lt;/ul>
&lt;p>通常单个 pod 中不会同时运行一个应用的多个实例。&lt;/p>
&lt;p>详细说明请看： &lt;a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/" target="_blank" rel="noopener">The Distributed System ToolKit: Patterns for Composite Containers&lt;/a>。&lt;/p>
&lt;h2 id="其他替代选择">其他替代选择&lt;/h2>
&lt;p>&lt;strong>为什么不直接在一个容器中运行多个应用程序呢？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>透明。让 pod 中的容器对基础设施可见，以便基础设施能够为这些容器提供服务，例如进程管理和资源监控。这可以为用户带来极大的便利。&lt;/li>
&lt;li>解耦软件依赖。每个容器都可以进行版本管理，独立的编译和发布。未来 kubernetes 甚至可能支持单个容器的在线升级。&lt;/li>
&lt;li>使用方便。用户不必运行自己的进程管理器，还要担心错误信号传播等。&lt;/li>
&lt;li>效率。因为由基础架构提供更多的职责，所以容器可以变得更加轻量级。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>为什么不支持容器的亲和性的协同调度？&lt;/strong>&lt;/p>
&lt;p>这种方法可以提供容器的协同定位，能够根据容器的亲和性进行调度，但是无法实现使用 pod 带来的大部分好处，例如资源共享，IPC，保持状态一致性和简化管理等。&lt;/p>
&lt;h2 id="pod-的持久性或者说缺乏持久性">Pod 的持久性（或者说缺乏持久性）&lt;/h2>
&lt;p>Pod 在设计支持就不是作为持久化实体的。在调度失败、节点故障、缺少资源或者节点维护的状态下都会死掉会被驱逐。&lt;/p>
&lt;p>通常，用户不需要手动直接创建 Pod，而是应该使用 controller（例如 &lt;a href="../deployment">Deployments&lt;/a>），即使是在创建单个 Pod 的情况下。Controller 可以提供集群级别的自愈功能、复制和升级管理。&lt;/p>
&lt;p>使用集合 API 作为主要的面向用户的原语在集群调度系统中相对常见，包括 &lt;a href="https://research.google.com/pubs/pub43438.html" target="_blank" rel="noopener">Borg&lt;/a>、&lt;a href="https://mesosphere.github.io/marathon/docs/rest-api.html" target="_blank" rel="noopener">Marathon&lt;/a>、&lt;a href="https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema" target="_blank" rel="noopener">Aurora&lt;/a> 和 &lt;a href="https://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997" target="_blank" rel="noopener">Tupperware&lt;/a>。&lt;/p>
&lt;p>Pod 原语有利于：&lt;/p>
&lt;ul>
&lt;li>调度程序和控制器可插拔性&lt;/li>
&lt;li>支持 pod 级操作，无需通过控制器 API “代理” 它们&lt;/li>
&lt;li>将 pod 生命周期与控制器生命周期分离，例如用于自举（bootstrap）&lt;/li>
&lt;li>控制器和服务的分离 —— 端点控制器只是监视 pod&lt;/li>
&lt;li>将集群级功能与 Kubelet 级功能的清晰组合 ——Kubelet 实际上是 “pod 控制器”&lt;/li>
&lt;li>高可用性应用程序，它们可以在终止之前及在删除之前更换 pod，例如在计划驱逐、镜像预拉取或实时 pod 迁移的情况下，详见&lt;a href="https://github.com/kubernetes/kubernetes/issues/3949" target="_blank" rel="noopener">Issue #3949&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="../statefulset">StatefulSet&lt;/a> 控制器支持有状态的 Pod。在 1.4 版本中被称为 PetSet。在 kubernetes 之前的版本中创建有状态 pod 的最佳方式是创建一个 replica 为 1 的 replication controller。&lt;/p>
&lt;h2 id="pod-的终止">Pod 的终止&lt;/h2>
&lt;p>因为 pod 作为在集群的节点上运行的进程，所以在不再需要的时候能够优雅的终止掉是十分必要的（比起使用发送 KILL 信号这种暴力的方式）。用户需要能够发起一个删除 Pod 的请求，并且知道它们何时会被终止，是否被正确的删除。用户想终止程序时发送删除 pod 的请求，在 pod 可以被强制删除前会有一个宽限期，会发送一个 TERM 请求到每个容器的主进程。一旦超时，将向主进程发送 KILL 信号并从 API server 中删除。如果 kubelet 或者 container manager 在等待进程终止的过程中重启，在重启后仍然会重试完整的宽限期。&lt;/p>
&lt;p>示例流程如下：&lt;/p>
&lt;ol>
&lt;li>用户发送删除 pod 的命令，默认宽限期是 30 秒；&lt;/li>
&lt;li>在 Pod 超过该宽限期后 API server 就会更新 Pod 的状态为 “dead”；&lt;/li>
&lt;li>在客户端命令行上显示的 Pod 状态为 “terminating”；&lt;/li>
&lt;li>跟第三步同时，当 kubelet 发现 pod 被标记为 “terminating” 状态时，开始停止 pod 进程：
&lt;ol>
&lt;li>如果在 pod 中定义了 preStop hook，在停止 pod 前会被调用。如果在宽限期过后，preStop hook 依然在运行，第二步会再增加 2 秒的宽限期；&lt;/li>
&lt;li>向 Pod 中的进程发送 TERM 信号；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>跟第三步同时，该 Pod 将从该 service 的端点列表中删除，不再是 replication controller 的一部分。关闭的慢的 pod 将继续处理 load balancer 转发的流量；&lt;/li>
&lt;li>过了宽限期后，将向 Pod 中依然运行的进程发送 SIGKILL 信号而杀掉进程。&lt;/li>
&lt;li>Kubelet 会在 API server 中完成 Pod 的的删除，通过将优雅周期设置为 0（立即删除）。Pod 在 API 中消失，并且在客户端也不可见。&lt;/li>
&lt;/ol>
&lt;p>删除宽限期默认是 30 秒。&lt;code>kubectl delete&lt;/code> 命令支持 &lt;code>—grace-period=&amp;lt;seconds&amp;gt;&lt;/code> 选项，允许用户设置自己的宽限期。如果设置为 0 将强制删除 pod。在 kubectl&amp;gt;=1.5 版本的命令中，你必须同时使用 &lt;code>--force&lt;/code> 和 &lt;code>--grace-period=0&lt;/code> 来强制删除 pod。在 yaml 文件中可以通过 &lt;code>{{ .spec.spec.terminationGracePeriodSeconds }}&lt;/code> 来修改此值。&lt;/p>
&lt;h3 id="强制删除-pod">强制删除 Pod&lt;/h3>
&lt;p>Pod 的强制删除是通过在集群和 etcd 中将其定义为删除状态。当执行强制删除命令时，API server 不会等待该 pod 所运行在节点上的 kubelet 确认，就会立即将该 pod 从 API server 中移除，这时就可以创建跟原 pod 同名的 pod 了。这时，在节点上的 pod 会被立即设置为 terminating 状态，不过在被强制删除之前依然有一小段优雅删除周期。&lt;/p>
&lt;p>强制删除对于某些 pod 具有潜在危险性，请谨慎使用。使用 StatefulSet pod 的情况下，请参考删除 StatefulSet 中的 pod 文章。&lt;/p>
&lt;h2 id="pod-中容器的特权模式">Pod 中容器的特权模式&lt;/h2>
&lt;p>从 Kubernetes1.1 版本开始，pod 中的容器就可以开启 privileged 模式，在容器定义文件的 &lt;code>SecurityContext&lt;/code> 下使用 &lt;code>privileged&lt;/code> flag。这在使用 Linux 的网络操作和访问设备的能力时是很有用的。容器内进程可获得近乎等同于容器外进程的权限。在不需要修改和重新编译 kubelet 的情况下就可以使用 pod 来开发节点的网络和存储插件。&lt;/p>
&lt;p>如果 master 节点运行的是 kuberentes1.1 或更高版本，而 node 节点的版本低于 1.1 版本，则 API server 将也可以接受新的特权模式的 pod，但是无法启动，pod 将处于 pending 状态。&lt;/p>
&lt;p>执行 &lt;code>kubectl describe pod FooPodName&lt;/code>，可以看到为什么 pod 处于 pending 状态。输出的 event 列表中将显示： &lt;code>Error validating pod &amp;quot;FooPodName&amp;quot;.&amp;quot;FooPodNamespace&amp;quot; from api, ignoring: spec.containers[0].securityContext.privileged: forbidden '&amp;lt;*&amp;gt;(0xc2089d3248)true'&lt;/code>&lt;/p>
&lt;p>如果 master 节点的版本低于 1.1，无法创建特权模式的 pod。如果你仍然试图去创建的话，你得到如下错误：&lt;/p>
&lt;pre tabindex="0">&lt;code>The Pod &amp;#34;FooPodName&amp;#34; is invalid. spec.containers[0].securityContext.privileged: forbidden &amp;#39;&amp;lt;*&amp;gt;(0xc20b222db0)true&amp;#39;
&lt;/code>&lt;/pre></description></item><item><title>pod-disruption-budget</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-disruption-budget/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-disruption-budget/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 20
title: Pod 中断与 PDB（Pod 中断预算）
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>这篇文档适用于要构建高可用应用程序的所有者，因此他们需要了解 Pod 可能发生什么类型的中断。也适用于要执行自动集群操作的集群管理员，如升级和集群自动扩容。&lt;/p>
&lt;h2 id="自愿中断和非自愿中断">自愿中断和非自愿中断&lt;/h2>
&lt;p>Pod 不会消失，直到有人（人类或控制器）将其销毁，或者当出现不可避免的硬件或系统软件错误。&lt;/p>
&lt;p>我们把这些不可避免的情况称为应用的非自愿性中断。例如：&lt;/p>
&lt;ul>
&lt;li>后端节点物理机的硬件故障&lt;/li>
&lt;li>集群管理员错误地删除虚拟机（实例）&lt;/li>
&lt;li>云提供商或管理程序故障使虚拟机消失&lt;/li>
&lt;li>内核恐慌（kernel panic）&lt;/li>
&lt;li>节点由于集群网络分区而从集群中消失&lt;/li>
&lt;li>由于节点&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource" target="_blank" rel="noopener">资源不足&lt;/a>而将容器逐出&lt;/li>
&lt;/ul>
&lt;p>除资源不足的情况外，大多数用户应该都熟悉以下这些情况；它们不是特定于 Kubernetes 的。&lt;/p>
&lt;p>我们称这些情况为”自愿中断“。包括由应用程序所有者发起的操作和由集群管理员发起的操作。典型的应用程序所有者操作包括：&lt;/p>
&lt;ul>
&lt;li>删除管理该 pod 的 Deployment 或其他控制器&lt;/li>
&lt;li>更新了 Deployment 的 pod 模板导致 pod 重启&lt;/li>
&lt;li>直接删除 pod（意外删除）&lt;/li>
&lt;/ul>
&lt;p>集群管理员操作包括：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs//tasks/administer-cluster/safely-drain-node" target="_blank" rel="noopener">排空（drain）节点&lt;/a>进行修复或升级。&lt;/li>
&lt;li>从集群中排空节点以缩小集群。&lt;/li>
&lt;li>从节点中移除一个 pod，以允许其他 pod 使用该节点。&lt;/li>
&lt;/ul>
&lt;p>这些操作可能由集群管理员直接执行，也可能由集群管理员或集群托管提供商自动执行。&lt;/p>
&lt;p>询问您的集群管理员或咨询您的云提供商或发行文档，以确定是否为您的集群启用了任何自动中断源。如果没有启用，您可以跳过创建 Pod Disruption Budget（Pod 中断预算）。&lt;/p>
&lt;h2 id="处理中断">处理中断&lt;/h2>
&lt;p>以下是一些减轻非自愿性中断的方法：&lt;/p>
&lt;ul>
&lt;li>确保您的 pod &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-ram-container" target="_blank" rel="noopener">请求所需的资源&lt;/a>。&lt;/li>
&lt;li>如果您需要更高的可用性，请复制您的应用程序。（了解有关运行复制的&lt;a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment" target="_blank" rel="noopener">无状态&lt;/a>和&lt;a href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application" target="_blank" rel="noopener">有状态&lt;/a>应用程序的信息。）&lt;/li>
&lt;li>为了在运行复制应用程序时获得更高的可用性，请跨机架（使用&lt;a href="https://kubernetes.io/docs/user-guide/node-selection/#inter-pod-affinity-and-anti-affinity-beta-feature" target="_blank" rel="noopener">反亲和性&lt;/a>）或跨区域（如果使用多区域集群）分布应用程序。&lt;/li>
&lt;/ul>
&lt;p>自愿中断的频率各不相同。在 Kubernetes 集群上，根本没有自愿的中断。但是，您的集群管理员或托管提供商可能会运行一些导致自愿中断的附加服务。例如，节点软件更新可能导致自愿更新。另外，集群（节点）自动缩放的某些实现可能会导致碎片整理和紧缩节点的自愿中断。您的集群管理员或主机提供商应该已经记录了期望的自愿中断级别（如果有的话）。&lt;/p>
&lt;p>Kubernetes 提供的功能可以满足在频繁地自动中断的同时运行高可用的应用程序。我们称之为“中断预算”。&lt;/p>
&lt;h2 id="中断预算的工作原理">中断预算的工作原理&lt;/h2>
&lt;p>应用程序所有者可以为每个应用程序创建一个 &lt;code>PodDisruptionBudget&lt;/code> 对象（PDB）。PDB 将限制在同一时间自愿中断的复制应用程序中宕机的 Pod 的数量。例如，基于定额的应用程序希望确保运行的副本数量永远不会低于仲裁所需的数量。Web 前端可能希望确保提供负载的副本的数量永远不会低于总数的某个百分比。&lt;/p>
&lt;p>集群管理器和托管提供商应使用遵循 &lt;code>Pod Disruption Budgets&lt;/code> 的工具，方法是调用&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api" target="_blank" rel="noopener">Eviction API&lt;/a>而不是直接删除 Pod。例如 &lt;code>kubectl drain&lt;/code> 命令和 Kubernetes-on-GCE 集群升级脚本（&lt;code>cluster/gce/upgrade.sh&lt;/code>）。&lt;/p>
&lt;p>当集群管理员想要排空节点时，可以使用 &lt;code>kubectl drain&lt;/code> 命令。该命令会试图驱逐机器上的所有 pod。驱逐请求可能会暂时被拒绝，并且该工具会定期重试所有失败的请求，直到所有的 pod 都被终止，或者直到达到配置的超时时间。&lt;/p>
&lt;p>PDB 指定应用程序可以容忍的副本的数量，相对于应该有多少副本。例如，具有 &lt;code>spec.replicas：5&lt;/code> 的 Deployment 在任何给定的时间都应该有 5 个 Pod。如果其 PDB 允许在某一时刻有 4 个副本，那么驱逐 API 将只允许仅有一个而不是两个 Pod 自愿中断。&lt;/p>
&lt;p>使用标签选择器来指定应用程序的一组 pod，这与应用程序的控制器（Deployment、StatefulSet 等）使用的相同。&lt;/p>
&lt;p>Pod 控制器的 &lt;code>.spec.replicas&lt;/code> 计算“预期的” pod 数量。使用对象的 &lt;code>.metadata.ownerReferences&lt;/code> 值从控制器获取。&lt;/p>
&lt;p>PDB 不能阻止&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#voluntary-and-involuntary-disruptions" target="_blank" rel="noopener">非自愿中断&lt;/a>的发生，但是它们确实会影响预算。&lt;/p>
&lt;p>由于应用程序的滚动升级而被删除或不可用的 Pod 确实会计入中断预算，但控制器（如 Deployment 和 StatefulSet）在进行滚动升级时不受 PDB 的限制——在应用程序更新期间的故障处理是在控制器的规格（spec）中配置（了解&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#updating-your-application-without-a-service-outage" target="_blank" rel="noopener">更新 Deployment&lt;/a>）。&lt;/p>
&lt;p>使用驱逐 API 驱逐 pod 时，pod 会被优雅地终止（请参阅 PodSpec 中的 &lt;code>terminationGracePeriodSeconds&lt;/code>）。&lt;/p>
&lt;h2 id="pdb-示例">PDB 示例&lt;/h2>
&lt;p>假设集群有 3 个节点，&lt;code>node-1&lt;/code> 到 &lt;code>node-3&lt;/code>。集群中运行了一些应用，其中一个应用有 3 个副本，分别是 &lt;code>pod-a&lt;/code>、&lt;code>pod-b&lt;/code> 和 &lt;code>pod-c&lt;/code>。另外，还有一个与它相关的不具有 PDB 的 pod，我们称为之为 &lt;code>pod-x&lt;/code>。最初，所有 Pod 的分布如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">node-1&lt;/th>
&lt;th style="text-align:center">node-2&lt;/th>
&lt;th style="text-align:center">node-3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">pod-a &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-b &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-c &lt;em>available&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">pod-x &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>所有的 3 个 pod 都是 Deployment 中的一部分，并且它们共同拥有一个 PDB，要求至少有 3 个 pod 中的 2 个始终处于可用状态。&lt;/p>
&lt;p>例如，假设集群管理员想要重启系统，升级内核版本来修复内核中的错误。集群管理员首先使用 &lt;code>kubectl drain&lt;/code> 命令尝试排除 &lt;code>node-1&lt;/code>。该工具试图驱逐 &lt;code>pod-a&lt;/code> 和 &lt;code>pod-x&lt;/code>。这立即成功。两个 Pod 同时进入终止状态。这时的集群处于这种状态：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">node-1 &lt;em>draining&lt;/em>&lt;/th>
&lt;th style="text-align:center">node-2&lt;/th>
&lt;th style="text-align:center">node-3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">pod-a &lt;em>terminating&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-b &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-c &lt;em>available&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">pod-x &lt;em>terminating&lt;/em>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Deployment 注意到其中有一个 pod 处于正在终止，因此会创建了一个 &lt;code>pod-d&lt;/code> 来替换。由于 &lt;code>node-1&lt;/code> 被封锁（cordon），它落在另一个节点上。同时其它控制器也创建了 &lt;code>pod-y&lt;/code> 作为 &lt;code>pod-x&lt;/code> 的替代品。&lt;/p>
&lt;p>（注意：对于 &lt;code>StatefulSet&lt;/code>，&lt;code>pod-a&lt;/code> 将被称为 &lt;code>pod-1&lt;/code>，需要在替换之前完全终止，替代它的也称为 &lt;code>pod-1&lt;/code>，但是具有不同的 UID，可以创建。否则，示例也适用于 StatefulSet。）&lt;/p>
&lt;p>当前集群的状态如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">node-1 &lt;em>draining&lt;/em>&lt;/th>
&lt;th style="text-align:center">node-2&lt;/th>
&lt;th style="text-align:center">node-3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">pod-a &lt;em>terminating&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-b &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-c &lt;em>available&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">pod-x &lt;em>terminating&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-d &lt;em>starting&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在某一时刻，pod 被终止，集群看起来像下面这样子：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">node-1 &lt;em>drained&lt;/em>&lt;/th>
&lt;th style="text-align:center">node-2&lt;/th>
&lt;th style="text-align:center">node-3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">pod-b &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-c &lt;em>available&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">pod-d &lt;em>starting&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>此时，如果一个急躁的集群管理员试图排空（drain）&lt;code>node-2&lt;/code> 或 &lt;code>node-3&lt;/code>，drain 命令将被阻塞，因为对于 Deployment 只有 2 个可用的 pod，并且其 PDB 至少需要 2 个。经过一段时间，&lt;code>pod-d&lt;/code> 变得可用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">node-1 &lt;em>drained&lt;/em>&lt;/th>
&lt;th style="text-align:center">node-2&lt;/th>
&lt;th style="text-align:center">node-3&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">pod-b &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-c &lt;em>available&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">pod-d &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>现在，集群管理员尝试排空 &lt;code>node-2&lt;/code>。drain 命令将尝试按照某种顺序驱逐两个 pod，假设先是 &lt;code>pod-b&lt;/code>，然后再 &lt;code>pod-d&lt;/code>。它将成功驱逐 &lt;code>pod-b&lt;/code>。但是，当它试图驱逐 &lt;code>pod-d&lt;/code> 时，将被拒绝，因为这样对 Deployment 来说将只剩下一个可用的 pod。&lt;/p>
&lt;p>Deployment 将创建一个名为 &lt;code>pod-e&lt;/code> 的 &lt;code>pod-b&lt;/code> 的替代品。但是，集群中没有足够的资源来安排 &lt;code>pod-e&lt;/code>。那么，drain 命令就会被阻塞。集群最终可能是这种状态：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">node-1 &lt;em>drained&lt;/em>&lt;/th>
&lt;th style="text-align:center">node-2 &lt;em>drained&lt;/em>&lt;/th>
&lt;th style="text-align:center">node-3&lt;/th>
&lt;th style="text-align:center">&lt;em>no node&lt;/em>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">pod-c &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-e &lt;em>pending&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">pod-d &lt;em>available&lt;/em>&lt;/td>
&lt;td style="text-align:center">pod-y&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>此时，集群管理员需要向集群中添加回一个节点以继续升级操作。&lt;/p>
&lt;p>您可以看到 Kubernetes 如何改变中断发生的速率，根据：&lt;/p>
&lt;ul>
&lt;li>应用程序需要多少副本&lt;/li>
&lt;li>正常关闭实例需要多长时间&lt;/li>
&lt;li>启动新实例需要多长时间&lt;/li>
&lt;li>控制器的类型&lt;/li>
&lt;li>集群的资源能力&lt;/li>
&lt;/ul>
&lt;h2 id="分离集群所有者和应用程序所有者角色">分离集群所有者和应用程序所有者角色&lt;/h2>
&lt;p>将集群管理者和应用程序所有者视为彼此知识有限的独立角色通常是很有用的。这种责任分离在这些情况下可能是有意义的：&lt;/p>
&lt;ul>
&lt;li>当有许多应用程序团队共享一个 Kubernetes 集群，并且有自然的专业角色&lt;/li>
&lt;li>使用第三方工具或服务来自动化集群管理&lt;/li>
&lt;/ul>
&lt;p>Pod Disruption Budget（Pod 中断预算） 通过在角色之间提供接口来支持这种角色分离。&lt;/p>
&lt;p>如果您的组织中没有这样的职责分离，则可能不需要使用 Pod 中断预算。&lt;/p>
&lt;h2 id="如何在集群上执行中断操作">如何在集群上执行中断操作&lt;/h2>
&lt;p>如果您是集群管理员，要对集群的所有节点执行中断操作，例如节点或系统软件升级，则可以使用以下选择：&lt;/p>
&lt;ul>
&lt;li>在升级期间接受停机时间。&lt;/li>
&lt;li>故障转移到另一个完整的副本集群。
&lt;ul>
&lt;li>没有停机时间，但是对于重复的节点和人工协调成本可能是昂贵的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>编写可容忍中断的应用程序和使用 PDB。
&lt;ul>
&lt;li>没有停机时间。&lt;/li>
&lt;li>最小的资源重复。&lt;/li>
&lt;li>允许更多的集群管理自动化。&lt;/li>
&lt;li>编写可容忍中断的应用程序是很棘手的，但对于可容忍自愿中断，和支持自动调整以容忍非自愿中断，两者在工作上有大量的重叠。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" target="_blank" rel="noopener">Disruptions - kubernetes.io&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过配置&lt;a href="https://kubernetes.io/docs/tasks/run-application//configure-pdb" target="_blank" rel="noopener">Pod Disruption Budget（Pod 中断预算）&lt;/a>来执行保护应用程序的步骤。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>了解更多关于&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster//safely-drain-node" target="_blank" rel="noopener">排空节点&lt;/a>的信息。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>pod-hook</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-hook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-hook/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 18
title: Pod Hook
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>Pod Hook（钩子）是由 Kubernetes 管理的 kubelet 发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。可以同时为 Pod 中的所有容器都配置 hook。&lt;/p>
&lt;p>Hook 的类型包括两种：&lt;/p>
&lt;ul>
&lt;li>exec：执行一段命令&lt;/li>
&lt;li>HTTP：发送 HTTP 请求。&lt;/li>
&lt;/ul>
&lt;p>参考下面的配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">lifecycle-demo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">lifecycle-demo-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">lifecycle&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">postStart&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;echo Hello from the postStart handler&amp;gt; /usr/share/message&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">preStop&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/usr/sbin/nginx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;quit&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kubernetes 在容器创建后立即发送 postStart 事件。但是，不能保证在调用容器的入口点之前调用 postStart 处理程序。postStart 处理程序相对于容器的代码异步运行，但 Kubernetes 对容器的管理将被阻止，直到 postStart 处理程序完成。在 postStart 处理程序完成之前，容器的状态不会设置为 RUNNING。&lt;/p>
&lt;p>PreStop 在容器终止之前被同步阻塞调用，常用于在容器结束前优雅的释放资源。&lt;/p>
&lt;p>如果 postStart 或者 preStop hook 失败，将会终止容器。&lt;/p>
&lt;h2 id="调试-hook">调试 hook&lt;/h2>
&lt;p>Hook 调用的日志没有暴露给 Pod 的 event，所以只能通过 &lt;code>describe&lt;/code> 命令来获取，如果有错误将可以看到 &lt;code>FailedPostStartHook&lt;/code> 或 &lt;code>FailedPreStopHook&lt;/code> 这样的 event。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" target="_blank" rel="noopener">Attach Handlers to Container Lifecycle Events - kuberentes.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noopener">Container Lifecycle Hooks - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>pod-lifecycle</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-lifecycle/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 17
title: Pod 的生命周期
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>本文讲解的是 Kubernetes 中 Pod 的生命周期，包括生命周期的不同阶段、存活和就绪探针、重启策略等。&lt;/p>
&lt;h2 id="pod-phase">Pod phase&lt;/h2>
&lt;p>Pod 的 &lt;code>status&lt;/code> 字段是一个 PodStatus 对象，PodStatus 中有一个 &lt;code>phase&lt;/code> 字段。&lt;/p>
&lt;p>Pod 的相位（phase）是 Pod 在其生命周期中的简单宏观概述。该字段并不是对容器或 Pod 的综合汇总，也不是为了做为综合状态机。&lt;/p>
&lt;p>Pod 相位的数量和含义是严格指定的。除了本文档中列举的状态外，不应该再假定 Pod 有其他的 &lt;code>phase&lt;/code> 值。&lt;/p>
&lt;p>下面是 &lt;code>phase&lt;/code> 可能的值：&lt;/p>
&lt;ul>
&lt;li>挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。&lt;/li>
&lt;li>运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。&lt;/li>
&lt;li>成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。&lt;/li>
&lt;li>失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。&lt;/li>
&lt;li>未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。&lt;/li>
&lt;/ul>
&lt;p>下图是 Pod 的生命周期示意图，从图中可以看到 Pod 状态的变化。&lt;/p>
&lt;p>
&lt;figure id="figure-pod的生命周期示意图图片来自网络">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/kubernetes-pod-life-cycle.jpg" alt="Pod 的生命周期示意图（图片来自网络）" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Pod的生命周期示意图（图片来自网络）
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h2 id="pod-状态">Pod 状态&lt;/h2>
&lt;p>Pod 有一个 PodStatus 对象，其中包含一个 PodCondition 数组。PodCondition 数组的每个元素都有一个 &lt;code>type&lt;/code> 字段和一个 &lt;code>status&lt;/code> 字段。&lt;code>type&lt;/code> 字段是字符串，可能的值有 PodScheduled、Ready、Initialized、Unschedulable 和 ContainersReady。&lt;code>status&lt;/code> 字段是一个字符串，可能的值有 True、False 和 Unknown。&lt;/p>
&lt;h2 id="容器探针">容器探针&lt;/h2>
&lt;p>探针是由 &lt;a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener">kubelet&lt;/a> 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 &lt;a href="https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler" target="_blank" rel="noopener">Handler&lt;/a>。有三种类型的处理程序：&lt;/p>
&lt;ul>
&lt;li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。&lt;/li>
&lt;li>TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。&lt;/li>
&lt;li>HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。&lt;/li>
&lt;/ul>
&lt;p>每次探测都将获得以下三种结果之一：&lt;/p>
&lt;ul>
&lt;li>成功：容器通过了诊断。&lt;/li>
&lt;li>失败：容器未通过诊断。&lt;/li>
&lt;li>未知：诊断失败，因此不会采取任何行动。&lt;/li>
&lt;/ul>
&lt;p>Kubelet 可以选择是否执行在容器上运行的两种探针执行和做出反应：&lt;/p>
&lt;ul>
&lt;li>&lt;code>livenessProbe&lt;/code>：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 &lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener">重启策略&lt;/a> 的影响。如果容器不提供存活探针，则默认状态为 &lt;code>Success&lt;/code>。&lt;/li>
&lt;li>&lt;code>readinessProbe&lt;/code>：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 &lt;code>Failure&lt;/code>。如果容器不提供就绪探针，则默认状态为 &lt;code>Success&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h3 id="该什么时候使用存活liveness和就绪readiness探针">该什么时候使用存活（liveness）和就绪（readiness）探针?&lt;/h3>
&lt;p>如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活探针; kubelet 将根据 Pod 的&lt;code>restartPolicy&lt;/code> 自动执行正确的操作。&lt;/p>
&lt;p>如果您希望容器在探测失败时被杀死并重新启动，那么请指定一个存活探针，并指定&lt;code>restartPolicy&lt;/code> 为 Always 或 OnFailure。&lt;/p>
&lt;p>如果要仅在探测成功时才开始向 Pod 发送流量，请指定就绪探针。在这种情况下，就绪探针可能与存活探针相同，但是 spec 中的就绪探针的存在意味着 Pod 将在没有接收到任何流量的情况下启动，并且只有在探针探测成功后才开始接收流量。&lt;/p>
&lt;p>如果您希望容器能够自行维护，您可以指定一个就绪探针，该探针检查与存活探针不同的端点。&lt;/p>
&lt;p>请注意，如果您只想在 Pod 被删除时能够排除请求，则不一定需要使用就绪探针；在删除 Pod 时，Pod 会自动将自身置于未完成状态，无论就绪探针是否存在。当等待 Pod 中的容器停止时，Pod 仍处于未完成状态。&lt;/p>
&lt;h3 id="readinessgates">readinessGates&lt;/h3>
&lt;p>自 Kubernetes 1.14（该版本 &lt;code>readinessGates&lt;/code> GA，在 1.11 版本是为 alpha）起默认支持 Pod 就绪检测机制扩展。&lt;/p>
&lt;p>应用程序可以向 PodStatus 注入额外的反馈或信号：Pod readiness。要使用这个功能，请在 PodSpec 中设置 &lt;code>readinessGates&lt;/code> 来指定 kubelet 评估 Pod readiness 的附加条件列表。&lt;/p>
&lt;p>Readiness gates 由 Pod 的 &lt;code>status.condition&lt;/code> 字段的当前状态决定。如果 Kubernetes 在 Pod 的 &lt;code>status.conditions&lt;/code> 字段中找不到这样的条件，则该条件的状态默认为 &amp;ldquo;False&amp;rdquo;。&lt;/p>
&lt;p>下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">readinessGates&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">conditionType&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;www.example.com/feature-1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">conditions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ready&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 内置的 Pod 状态&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;False&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">lastProbeTime&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">lastTransitionTime&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="ld">2018-01-01T00:00:00Z&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;www.example.com/feature-1&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 附加的额外的 Pod 状态&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;False&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">lastProbeTime&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">lastTransitionTime&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="ld">2018-01-01T00:00:00Z&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containerStatuses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerID&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker://abcd...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ready&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>您添加的 Pod 条件的名称必须符合 Kubernetes 的 &lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set" target="_blank" rel="noopener">label key 格式&lt;/a>。&lt;/p>
&lt;p>只有到 Pod 中的所有容器状态都是 Ready，且 Pod 附加的额外状态检测的 &lt;code>readinessGates&lt;/code> 条件也是 Ready 的时候，Pod 的状态才是 Ready。&lt;/p>
&lt;h2 id="pod-和容器状态">Pod 和容器状态&lt;/h2>
&lt;p>有关 Pod 容器状态的详细信息，请参阅 PodStatus 和 ContainerStatus。请注意，报告的 Pod 状态信息取决于当前的 ContainerState。&lt;/p>
&lt;h2 id="重启策略">重启策略&lt;/h2>
&lt;p>PodSpec 中有一个 &lt;code>restartPolicy&lt;/code> 字段，可能的值为 Always、OnFailure 和 Never。默认为 Always。&lt;code>restartPolicy&lt;/code> 适用于 Pod 中的所有容器。&lt;code>restartPolicy&lt;/code> 仅指通过同一节点上的 kubelet 重新启动容器。失败的容器由 kubelet 以五分钟为上限的指数退避延迟（10 秒，20 秒，40 秒&amp;hellip;）重新启动，并在成功执行十分钟后重置。如 &lt;a href="https://kubernetes.io/docs/user-guide/pods/#durability-of-pods-or-lack-thereof" target="_blank" rel="noopener">Pod 文档&lt;/a> 中所述，一旦绑定到一个节点，Pod 将永远不会重新绑定到另一个节点。&lt;/p>
&lt;h2 id="pod-的生命">Pod 的生命&lt;/h2>
&lt;p>一般来说，Pod 不会消失，直到人为销毁他们。这可能是一个人或控制器。这个规则的唯一例外是成功或失败的 &lt;code>phase&lt;/code> 超过一段时间（由 master 确定）的 Pod 将过期并被自动销毁。&lt;/p>
&lt;p>有三种可用的控制器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用 &lt;a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener">Job&lt;/a> 运行预期会终止的 Pod，例如批量计算。Job 仅适用于重启策略为 &lt;code>OnFailure&lt;/code> 或 &lt;code>Never&lt;/code> 的 Pod。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对预期不会终止的 Pod 使用 &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">ReplicationController&lt;/a>、&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSet&lt;/a> 和 &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment&lt;/a> ，例如 Web 服务器。ReplicationController 仅适用于具有 &lt;code>restartPolicy&lt;/code> 为 Always 的 Pod。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提供特定于机器的系统服务，使用 &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSet&lt;/a> 为每台机器运行一个 Pod 。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所有这三种类型的控制器都包含一个 PodTemplate。建议创建适当的控制器，让它们来创建 Pod，而不是直接自己创建 Pod。这是因为单独的 Pod 在机器故障的情况下没有办法自动复原，而控制器却可以。&lt;/p>
&lt;p>如果节点死亡或与集群的其余部分断开连接，则 Kubernetes 将应用一个策略将丢失节点上的所有 Pod 的 &lt;code>phase&lt;/code> 设置为 Failed。&lt;/p>
&lt;h2 id="示例">示例&lt;/h2>
&lt;h3 id="高级-liveness-探针示例">高级 liveness 探针示例&lt;/h3>
&lt;p>存活探针由 kubelet 来执行，因此所有的请求都在 kubelet 的网络命名空间中进行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">test&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">liveness&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">liveness-http&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">/server&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.gcr.io/liveness&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">livenessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">httpGet&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># when &amp;#34;host&amp;#34; is not defined, &amp;#34;PodIP&amp;#34; will be used&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># host: my-host&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># when &amp;#34;scheme&amp;#34; is not defined, &amp;#34;HTTP&amp;#34; scheme will be used. Only &amp;#34;HTTP&amp;#34; and &amp;#34;HTTPS&amp;#34; are allowed&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># scheme: HTTPS&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/healthz&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">httpHeaders&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">X-Custom-Header&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Awesome&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">initialDelaySeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">15&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">timeoutSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">liveness&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="状态示例">状态示例&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Pod 中只有一个容器并且正在运行。容器成功退出。&lt;/p>
&lt;ul>
&lt;li>记录完成事件。&lt;/li>
&lt;li>如果 &lt;code>restartPolicy&lt;/code> 为：
&lt;ul>
&lt;li>Always：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>OnFailure：Pod &lt;code>phase&lt;/code> 变成 Succeeded。&lt;/li>
&lt;li>Never：Pod &lt;code>phase&lt;/code> 变成 Succeeded。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Pod 中只有一个容器并且正在运行。容器退出失败。&lt;/p>
&lt;ul>
&lt;li>记录失败事件。&lt;/li>
&lt;li>如果 &lt;code>restartPolicy&lt;/code> 为：
&lt;ul>
&lt;li>Always：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>OnFailure：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>Never：Pod &lt;code>phase&lt;/code> 变成 Failed。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Pod 中有两个容器并且正在运行。容器 1 退出失败。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>记录失败事件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 restartPolicy 为：&lt;/p>
&lt;ul>
&lt;li>Always：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>OnFailure：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>Never：不重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如果有容器 1 没有处于运行状态，并且容器 2 退出：&lt;/p>
&lt;ul>
&lt;li>记录失败事件。&lt;/li>
&lt;li>如果 &lt;code>restartPolicy&lt;/code> 为：
&lt;ul>
&lt;li>Always：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>OnFailure：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>Never：Pod &lt;code>phase&lt;/code> 变成 Failed。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Pod 中只有一个容器并处于运行状态。容器运行时内存超出限制：&lt;/p>
&lt;ul>
&lt;li>容器以失败状态终止。&lt;/li>
&lt;li>记录 OOM 事件。&lt;/li>
&lt;li>如果 &lt;code>restartPolicy&lt;/code> 为：
&lt;ul>
&lt;li>Always：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>OnFailure：重启容器；Pod &lt;code>phase&lt;/code> 仍为 Running。&lt;/li>
&lt;li>Never: 记录失败事件；Pod &lt;code>phase&lt;/code> 仍为 Failed。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Pod 正在运行，磁盘故障：&lt;/p>
&lt;ul>
&lt;li>杀掉所有容器。&lt;/li>
&lt;li>记录适当事件。&lt;/li>
&lt;li>Pod &lt;code>phase&lt;/code> 变成 Failed。&lt;/li>
&lt;li>如果使用控制器来运行，Pod 将在别处重建。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Pod 正在运行，其节点被分段。&lt;/p>
&lt;ul>
&lt;li>节点控制器等待直到超时。&lt;/li>
&lt;li>节点控制器将 Pod &lt;code>phase&lt;/code> 设置为 Failed。&lt;/li>
&lt;li>如果是用控制器来运行，Pod 将在别处重建。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">Pod lifecycle - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>pod-overview</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-overview/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 12
title: Pod 概览
date: &amp;ldquo;2017-03-10T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>本文将为您讲解 Pod 的基础概念。&lt;/p>
&lt;h2 id="理解-pod">理解 Pod&lt;/h2>
&lt;p>Pod 是 kubernetes 中你可以创建和部署的最小也是最简的单位。Pod 代表着集群中运行的进程。&lt;/p>
&lt;p>Pod 中封装着应用的容器（有的情况下是好几个容器），存储、独立的网络 IP，管理容器如何运行的策略选项。Pod 代表着部署的一个单位：kubernetes 中应用的一个实例，可能由一个或者多个容器组合在一起共享资源。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://www.docker.com" target="_blank" rel="noopener">Docker&lt;/a> 是 kubernetes 中最常用的容器运行时，但是 Pod 也支持其他容器运行时。&lt;/p>
&lt;/blockquote>
&lt;p>在 Kubernetes 集群中 Pod 有如下两种使用方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>一个 Pod 中运行一个容器&lt;/strong>。“每个 Pod 中一个容器” 的模式是最常见的用法；在这种使用方式中，你可以把 Pod 想象成是单个容器的封装，kuberentes 管理的是 Pod 而不是直接管理容器。&lt;/li>
&lt;li>&lt;strong>在一个 Pod 中同时运行多个容器&lt;/strong>。一个 Pod 中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个 Pod 中的容器可以互相协作成为一个 service 单位 —— 一个容器共享文件，另一个 “sidecar” 容器来更新这些文件。Pod 将这些容器的存储资源作为一个实体来管理。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://kubernetes.io/blog" target="_blank" rel="noopener">Kubernetes Blog&lt;/a> 有关于 Pod 用例的详细信息，查看：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/" target="_blank" rel="noopener">The Distributed System Toolkit: Patterns for Composite Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/blog/2016/06/container-design-patterns/" target="_blank" rel="noopener">Container Design Patterns&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>每个 Pod 都是应用的一个实例。如果你想平行扩展应用的话（运行多个实例），你应该运行多个 Pod，每个 Pod 都是一个应用实例。在 Kubernetes 中，这通常被称为 replication。&lt;/p>
&lt;h3 id="pod-中如何管理多个容器">Pod 中如何管理多个容器&lt;/h3>
&lt;p>Pod 中可以同时运行多个进程（作为容器运行）协同工作。同一个 Pod 中的容器会自动的分配到同一个 node 上。同一个 Pod 中的容器共享资源、网络环境和依赖，它们总是被同时调度。&lt;/p>
&lt;p>注意在一个 Pod 中同时运行多个容器是一种比较高级的用法。只有当你的容器需要紧密配合协作的时候才考虑用这种模式。例如，你有一个容器作为 web 服务器运行，需要用到共享的 volume，有另一个 “sidecar” 容器来从远端获取资源更新这些文件，如下图所示：&lt;/p>
&lt;p>
&lt;figure id="figure-pod-示意图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/pod-overview.png" alt="pod 示意图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Pod 示意图
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>Pod 中可以共享两种资源：网络和存储。&lt;/p>
&lt;h4 id="网络">网络&lt;/h4>
&lt;p>每个 Pod 都会被分配一个唯一的 IP 地址。Pod 中的所有容器共享网络空间，包括 IP 地址和端口。Pod 内部的容器可以使用 &lt;code>localhost&lt;/code> 互相通信。Pod 中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。&lt;/p>
&lt;h4 id="存储">存储&lt;/h4>
&lt;p>可以为一个 Pod 指定多个共享的 Volume。Pod 中的所有容器都可以访问共享的 volume。Volume 也可以用来持久化 Pod 中的存储资源，以防容器重启后文件丢失。&lt;/p>
&lt;h2 id="使用-pod">使用 Pod&lt;/h2>
&lt;p>你很少会直接在 kubernetes 中创建单个 Pod。因为 Pod 的生命周期是短暂的，用后即焚的实体。当 Pod 被创建后（不论是由你直接创建还是被其他 Controller），都会被 Kubernetes 调度到集群的 Node 上。直到 Pod 的进程终止、被删掉、因为缺少资源而被驱逐、或者 Node 故障之前这个 Pod 都会一直保持在那个 Node 上。&lt;/p>
&lt;blockquote>
&lt;p>注意：重启 Pod 中的容器跟重启 Pod 不是一回事。Pod 只提供容器的运行环境并保持容器的运行状态，重启容器不会造成 Pod 重启。&lt;/p>
&lt;/blockquote>
&lt;p>Pod 不会自愈。如果 Pod 运行的 Node 故障，或者是调度器本身故障，这个 Pod 就会被删除。同样的，如果 Pod 所在 Node 缺少资源或者 Pod 处于维护状态，Pod 也会被驱逐。Kubernetes 使用更高级的称为 Controller 的抽象层，来管理 Pod 实例。虽然可以直接使用 Pod，但是在 Kubernetes 中通常是使用 Controller 来管理 Pod 的。&lt;/p>
&lt;h3 id="pod-和-controller">Pod 和 Controller&lt;/h3>
&lt;p>Controller 可以创建和管理多个 Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个 Node 故障，Controller 就能自动将该节点上的 Pod 调度到其他健康的 Node 上。&lt;/p>
&lt;p>包含一个或者多个 Pod 的 Controller 示例：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../controllers/deployment">Deployment&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../controllers/statefulset">StatefulSet&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../controllers/daemonset">DaemonSet&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>通常，Controller 会用你提供的 Pod Template 来创建相应的 Pod。&lt;/p>
&lt;h2 id="pod-templates">Pod Templates&lt;/h2>
&lt;p>Pod 模版是包含了其他 object 的 Pod 定义，例如 &lt;a href="../replicaset">Replication Controllers&lt;/a>，&lt;a href="../job">Jobs&lt;/a> 和 &lt;a href="../daemonset">DaemonSets&lt;/a>。Controller 根据 Pod 模板来创建实际的 Pod。&lt;/p></description></item><item><title>pod-preset</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-preset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-preset/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 19
title: Pod Preset
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>Preset 就是预设，有时候想要让一批容器在启动的时候就注入一些信息，比如 secret、volume、volume mount 和环境变量，而又不想一个一个的改这些 Pod 的 template，这时候就可以用到 PodPreset 这个资源对象了。&lt;/p>
&lt;p>本页是关于 PodPreset 的概述，该对象用来在 Pod 创建的时候向 Pod 中注入某些特定信息。该信息可以包括 secret、volume、volume mount 和环境变量。&lt;/p>
&lt;h2 id="理解-pod-preset">理解 Pod Preset&lt;/h2>
&lt;p>&lt;code>Pod Preset&lt;/code> 是用来在 Pod 被创建的时候向其中注入额外的运行时需求的 API 资源。&lt;/p>
&lt;p>您可以使用 &lt;a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">label selector&lt;/a> 来指定为哪些 Pod 应用 Pod Preset。&lt;/p>
&lt;p>使用 Pod Preset 使得 pod 模板的作者可以不必为每个 Pod 明确提供所有信息。这样一来，pod 模板的作者就不需要知道关于该服务的所有细节。&lt;/p>
&lt;p>关于该背景的更多信息，请参阅 &lt;a href="https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md" target="_blank" rel="noopener">PodPreset 的设计方案&lt;/a>。&lt;/p>
&lt;h2 id="如何工作">如何工作&lt;/h2>
&lt;p>Kubernetes 提供了一个准入控制器（&lt;code>PodPreset&lt;/code>），当其启用时，Pod Preset 会将应用创建请求传入到该控制器上。当有 Pod 创建请求发生时，系统将执行以下操作：&lt;/p>
&lt;ol>
&lt;li>检索所有可用的 &lt;code>PodPresets&lt;/code>。&lt;/li>
&lt;li>检查 PodPreset 标签选择器上的标签，看看其是否能够匹配正在创建的 Pod 上的标签。&lt;/li>
&lt;li>尝试将由 &lt;code>PodPreset&lt;/code> 定义的各种资源合并到正在创建的 Pod 中。&lt;/li>
&lt;li>出现错误时，在该 Pod 上引发记录合并错误的事件，PodPreset &lt;em>不会&lt;/em>注入任何资源到创建的 Pod 中。&lt;/li>
&lt;li>注释刚生成的修改过的 Pod spec，以表明它已被 PodPreset 修改过。注释的格式为 &lt;code>podpreset.admission.kubernetes.io/podpreset-&amp;lt;pod-preset name&amp;gt;&amp;quot;: &amp;quot;&amp;lt;resource version&amp;gt;&amp;quot;&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>每个 Pod 可以匹配零个或多个 Pod Prestet；并且每个 &lt;code>PodPreset&lt;/code> 可以应用于零个或多个 Pod。&lt;code>PodPreset&lt;/code> 应用于一个或多个 Pod 时，Kubernetes 会修改 Pod Spec。对于 &lt;code>Env&lt;/code>、&lt;code>EnvFrom&lt;/code> 和 &lt;code>VolumeMounts&lt;/code> 的更改，Kubernetes 修改 Pod 中所有容器的容器 spec；对于 &lt;code>Volume&lt;/code> 的更改，Kubernetes 修改 Pod Spec。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意&lt;/strong>：Pod Preset 可以在适当的时候修改 Pod spec 中的 &lt;code>spec.containers&lt;/code> 字段。Pod Preset 中的资源定义将&lt;em>不会&lt;/em>应用于 &lt;code>initContainers&lt;/code> 字段。&lt;/p>
&lt;/blockquote>
&lt;h3 id="禁用特定-pod-的-pod-preset">禁用特定 Pod 的 Pod Preset&lt;/h3>
&lt;p>在某些情况下，您可能不希望 Pod 被任何 Pod Preset 所改变。在这些情况下，您可以在 Pod 的 Pod Spec 中添加注释：&lt;code>podpreset.admission.kubernetes.io/exclude：&amp;quot;true&amp;quot;&lt;/code>。&lt;/p>
&lt;h2 id="启用-pod-preset">启用 Pod Preset&lt;/h2>
&lt;p>为了在集群中使用 Pod Preset，您必须确保以下内容：&lt;/p>
&lt;ol>
&lt;li>您已启用 &lt;code>settings.k8s.io/v1alpha1/podpreset&lt;/code> API 类型。例如，可以通过在 API server 的 &lt;code>--runtime-config&lt;/code> 选项中包含 &lt;code>settings.k8s.io/v1alpha1=true&lt;/code> 来完成此操作。&lt;/li>
&lt;li>您已启用 &lt;code>PodPreset&lt;/code> 准入控制器。一种方法是将 &lt;code>PodPreset&lt;/code> 包含在为 API server 指定的 &lt;code>--admission-control&lt;/code> 选项值中。&lt;/li>
&lt;li>您已经在要使用的命名空间中通过创建 &lt;code>PodPreset&lt;/code> 对象来定义 &lt;code>PodPreset&lt;/code>。&lt;/li>
&lt;/ol></description></item><item><title>pod-security-policy</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-security-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/2.%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/pod-security-policy/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 16
title: Pod 安全策略
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>&lt;code>PodSecurityPolicy&lt;/code> 类型的对象能够控制，是否可以向 Pod 发送请求，该 Pod 能够影响被应用到 Pod 和容器的 &lt;code>SecurityContext&lt;/code>。&lt;/p>
&lt;h2 id="什么是-pod-安全策略">什么是 Pod 安全策略？&lt;/h2>
&lt;p>&lt;em>Pod 安全策略&lt;/em> 是集群级别的资源，它能够控制 Pod 运行的行为，以及它具有访问什么的能力。&lt;code>PodSecurityPolicy&lt;/code>对象定义了一组条件，指示 Pod 必须按系统所能接受的顺序运行。它们允许管理员控制如下方面：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制面&lt;/th>
&lt;th>字段名称&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>已授权容器的运行&lt;/td>
&lt;td>&lt;code>privileged&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>为容器添加默认的一组能力&lt;/td>
&lt;td>&lt;code>defaultAddCapabilities&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>为容器去掉某些能力&lt;/td>
&lt;td>&lt;code>requiredDropCapabilities&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>容器能够请求添加某些能力&lt;/td>
&lt;td>&lt;code>allowedCapabilities&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>控制卷类型的使用&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#controlling-volumes" target="_blank" rel="noopener">&lt;code>volumes&lt;/code>&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>主机网络的使用&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-network" target="_blank" rel="noopener">&lt;code>hostNetwork&lt;/code>&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>主机端口的使用&lt;/td>
&lt;td>&lt;code>hostPorts&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>主机 PID namespace 的使用&lt;/td>
&lt;td>&lt;code>hostPID&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>主机 IPC namespace 的使用&lt;/td>
&lt;td>&lt;code>hostIPC&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>主机路径的使用&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowed-host-paths" target="_blank" rel="noopener">&lt;code>allowedHostPaths&lt;/code>&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>容器的 SELinux 上下文&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux" target="_blank" rel="noopener">&lt;code>seLinux&lt;/code>&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>用户 ID&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#runasuser" target="_blank" rel="noopener">&lt;code>runAsUser&lt;/code>&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>配置允许的补充组&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#supplementalgroups" target="_blank" rel="noopener">&lt;code>supplementalGroups&lt;/code>&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>分配拥有 Pod 数据卷的 FSGroup&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#fsgroup" target="_blank" rel="noopener">&lt;code>fsGroup&lt;/code>&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>必须使用一个只读的 root 文件系统&lt;/td>
&lt;td>&lt;code>readOnlyRootFilesystem&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Pod 安全策略&lt;/em> 由设置和策略组成，它们能够控制 Pod 访问的安全特征。这些设置分为如下三类：&lt;/p>
&lt;ul>
&lt;li>&lt;em>基于布尔值控制&lt;/em>：这种类型的字段默认为最严格限制的值。&lt;/li>
&lt;li>&lt;em>基于被允许的值集合控制&lt;/em>：这种类型的字段会与这组值进行对比，以确认值被允许。&lt;/li>
&lt;li>&lt;em>基于策略控制&lt;/em>：设置项通过一种策略提供的机制来生成该值，这种机制能够确保指定的值落在被允许的这组值中。&lt;/li>
&lt;/ul>
&lt;h3 id="runasuser">RunAsUser&lt;/h3>
&lt;ul>
&lt;li>&lt;em>MustRunAs&lt;/em> - 必须配置一个 &lt;code>range&lt;/code>。使用该范围内的第一个值作为默认值。验证是否不在配置的该范围内。&lt;/li>
&lt;li>&lt;em>MustRunAsNonRoot&lt;/em> - 要求提交的 Pod 具有非零 &lt;code>runAsUser&lt;/code> 值，或在镜像中定义了 &lt;code>USER&lt;/code> 环境变量。不提供默认值。&lt;/li>
&lt;li>&lt;em>RunAsAny&lt;/em> - 没有提供默认值。允许指定任何 &lt;code>runAsUser&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;h3 id="selinux">SELinux&lt;/h3>
&lt;ul>
&lt;li>&lt;em>MustRunAs&lt;/em> - 如果没有使用预分配的值，必须配置 &lt;code>seLinuxOptions&lt;/code>。默认使用 &lt;code>seLinuxOptions&lt;/code>。验证 &lt;code>seLinuxOptions&lt;/code>。&lt;/li>
&lt;li>&lt;em>RunAsAny&lt;/em> - 没有提供默认值。允许任意指定的 &lt;code>seLinuxOptions&lt;/code> ID。&lt;/li>
&lt;/ul>
&lt;h3 id="supplementalgroups">SupplementalGroups&lt;/h3>
&lt;ul>
&lt;li>&lt;em>MustRunAs&lt;/em> - 至少需要指定一个范围。默认使用第一个范围的最小值。验证所有范围的值。&lt;/li>
&lt;li>&lt;em>RunAsAny&lt;/em> - 没有提供默认值。允许任意指定的 &lt;code>supplementalGroups&lt;/code> ID。&lt;/li>
&lt;/ul>
&lt;h3 id="fsgroup">FSGroup&lt;/h3>
&lt;ul>
&lt;li>&lt;em>MustRunAs&lt;/em> - 至少需要指定一个范围。默认使用第一个范围的最小值。验证在第一个范围内的第一个 ID。&lt;/li>
&lt;li>&lt;em>RunAsAny&lt;/em> - 没有提供默认值。允许任意指定的 &lt;code>fsGroup&lt;/code> ID。&lt;/li>
&lt;/ul>
&lt;h3 id="控制卷">控制卷&lt;/h3>
&lt;p>通过设置 PSP 卷字段，能够控制具体卷类型的使用。当创建一个卷的时候，与该字段相关的已定义卷可以允许设置如下值：&lt;/p>
&lt;ol>
&lt;li>azureFile&lt;/li>
&lt;li>azureDisk&lt;/li>
&lt;li>flocker&lt;/li>
&lt;li>flexVolume&lt;/li>
&lt;li>hostPath&lt;/li>
&lt;li>emptyDir&lt;/li>
&lt;li>gcePersistentDisk&lt;/li>
&lt;li>awsElasticBlockStore&lt;/li>
&lt;li>gitRepo&lt;/li>
&lt;li>secret&lt;/li>
&lt;li>nfs&lt;/li>
&lt;li>iscsi&lt;/li>
&lt;li>glusterfs&lt;/li>
&lt;li>persistentVolumeClaim&lt;/li>
&lt;li>rbd&lt;/li>
&lt;li>cinder&lt;/li>
&lt;li>cephFS&lt;/li>
&lt;li>downwardAPI&lt;/li>
&lt;li>fc&lt;/li>
&lt;li>configMap&lt;/li>
&lt;li>vsphereVolume&lt;/li>
&lt;li>quobyte&lt;/li>
&lt;li>photonPersistentDisk&lt;/li>
&lt;li>projected&lt;/li>
&lt;li>portworxVolume&lt;/li>
&lt;li>scaleIO&lt;/li>
&lt;li>storageos&lt;/li>
&lt;li>* (allow all volumes)&lt;/li>
&lt;/ol>
&lt;p>对新的 PSP，推荐允许的卷的最小集合包括：configMap、downwardAPI、emptyDir、persistentVolumeClaim、secret 和 projected。&lt;/p>
&lt;h3 id="主机网络">主机网络&lt;/h3>
&lt;ul>
&lt;li>&lt;em>HostPorts&lt;/em>， 默认为 &lt;code>empty&lt;/code>。&lt;code>HostPortRange&lt;/code> 列表通过 &lt;code>min&lt;/code>(包含) and &lt;code>max&lt;/code>(包含) 来定义，指定了被允许的主机端口。&lt;/li>
&lt;/ul>
&lt;h3 id="允许的主机路径">允许的主机路径&lt;/h3>
&lt;ul>
&lt;li>&lt;em>AllowedHostPaths&lt;/em> 是一个被允许的主机路径前缀的白名单。空值表示所有的主机路径都可以使用。&lt;/li>
&lt;/ul>
&lt;h2 id="许可">许可&lt;/h2>
&lt;p>包含 &lt;code>PodSecurityPolicy&lt;/code> 的 &lt;em>许可控制&lt;/em>，允许控制集群资源的创建和修改，基于这些资源在集群范围内被许可的能力。&lt;/p>
&lt;p>许可使用如下的方式为 Pod 创建最终的安全上下文：&lt;/p>
&lt;ol>
&lt;li>检索所有可用的 PSP。&lt;/li>
&lt;li>生成在请求中没有指定的安全上下文设置的字段值。&lt;/li>
&lt;li>基于可用的策略，验证最终的设置。&lt;/li>
&lt;/ol>
&lt;p>如果某个策略能够匹配上，该 Pod 就被接受。如果请求与 PSP 不匹配，则 Pod 被拒绝。&lt;/p>
&lt;p>Pod 必须基于 PSP 验证每个字段。&lt;/p>
&lt;h2 id="创建-pod-安全策略">创建 Pod 安全策略&lt;/h2>
&lt;p>下面是一个 Pod 安全策略的例子，所有字段的设置都被允许：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">extensions/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PodSecurityPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">permissive&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">seLinux&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RunAsAny&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">supplementalGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RunAsAny&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runAsUser&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RunAsAny&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fsGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RunAsAny&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPorts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">min&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8000&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">max&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;*&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下载示例文件可以创建该策略，然后执行如下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl create -f ./psp.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">podsecuritypolicy &lt;span class="s2">&amp;#34;permissive&amp;#34;&lt;/span> created
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取-pod-安全策略列表">获取 Pod 安全策略列表&lt;/h2>
&lt;p>获取已存在策略列表，使用 &lt;code>kubectl get&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get psp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NAME PRIV CAPS SELINUX RUNASUSER FSGROUP SUPGROUP READONLYROOTFS VOLUMES
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">permissive &lt;span class="nb">false&lt;/span> &lt;span class="o">[]&lt;/span> RunAsAny RunAsAny RunAsAny RunAsAny &lt;span class="nb">false&lt;/span> &lt;span class="o">[&lt;/span>*&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">privileged &lt;span class="nb">true&lt;/span> &lt;span class="o">[]&lt;/span> RunAsAny RunAsAny RunAsAny RunAsAny &lt;span class="nb">false&lt;/span> &lt;span class="o">[&lt;/span>*&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">restricted &lt;span class="nb">false&lt;/span> &lt;span class="o">[]&lt;/span> RunAsAny MustRunAsNonRoot RunAsAny RunAsAny &lt;span class="nb">false&lt;/span> &lt;span class="o">[&lt;/span>emptyDir secret downwardAPI configMap persistentVolumeClaim projected&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改-pod-安全策略">修改 Pod 安全策略&lt;/h2>
&lt;p>通过交互方式修改策略，使用 &lt;code>kubectl edit&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl edit psp permissive
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该命令将打开一个默认文本编辑器，在这里能够修改策略。&lt;/p>
&lt;h2 id="删除-pod-安全策略">删除 Pod 安全策略&lt;/h2>
&lt;p>一旦不再需要一个策略，很容易通过 &lt;code>kubectl&lt;/code> 删除它：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl delete psp permissive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">podsecuritypolicy &lt;span class="s2">&amp;#34;permissive&amp;#34;&lt;/span> deleted
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启用-pod-安全策略">启用 Pod 安全策略&lt;/h2>
&lt;p>为了能够在集群中使用 Pod 安全策略，必须确保如下：&lt;/p>
&lt;ol>
&lt;li>启用 API 类型 &lt;code>extensions/v1beta1/podsecuritypolicy&lt;/code>（仅对 1.6 之前的版本）&lt;/li>
&lt;li>启用许可控制器 &lt;code>PodSecurityPolicy&lt;/code>&lt;/li>
&lt;li>定义自己的策略&lt;/li>
&lt;/ol>
&lt;h2 id="使用-rbac">使用 RBAC&lt;/h2>
&lt;p>在 Kubernetes 1.5 或更新版本，可以使用 PodSecurityPolicy 来控制，对基于用户角色和组的已授权容器的访问。访问不同的 PodSecurityPolicy 对象，可以基于认证来控制。基于 Deployment、ReplicaSet 等创建的 Pod，限制访问 PodSecurityPolicy 对象，&lt;a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="noopener">Controller Manager&lt;/a> 必须基于安全 API 端口运行，并且不能够具有超级用户权限。&lt;/p>
&lt;p>PodSecurityPolicy 认证使用所有可用的策略，包括创建 Pod 的用户，Pod 上指定的服务账户（service acount）。当 Pod 基于 Deployment、ReplicaSet 创建时，它是创建 Pod 的 Controller Manager，所以如果基于非安全 API 端口运行，允许所有的 PodSecurityPolicy 对象，并且不能够有效地实现细分权限。用户访问给定的 PSP 策略有效，仅当是直接部署 Pod 的情况。当直接部署 Pod 时，应用 PodSecurityPolicy 控制基于角色和组的已授权容器的访问 。&lt;/p></description></item></channel></rss>