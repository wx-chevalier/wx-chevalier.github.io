<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>6.身份与权限认证 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/</link><atom:link href="https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/index.xml" rel="self" type="application/rss+xml"/><description>6.身份与权限认证</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>6.身份与权限认证</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/</link></image><item><title>network-policy</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/network-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/network-policy/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 46
title: NetworkPolicy
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>网络策略说明一组 &lt;code>Pod&lt;/code> 之间是如何被允许互相通信，以及如何与其它网络 Endpoint 进行通信。&lt;code>NetworkPolicy&lt;/code> 资源使用标签来选择 &lt;code>Pod&lt;/code>，并定义了一些规则，这些规则指明允许什么流量进入到选中的 &lt;code>Pod&lt;/code> 上。关于 Network Policy 的详细用法请参考 &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">Kubernetes 官网&lt;/a>。&lt;/p>
&lt;p>Network Policy 的作用对象是 Pod，也可以应用到 Namespace 和集群的 Ingress、Egress 流量。Network Policy 是作用在 L3/4 层的，即限制的是对 IP 地址和端口的访问，如果需要对应用层做访问限制需要使用如 &lt;a href="https://istio.io" target="_blank" rel="noopener">Istio&lt;/a> 这类 Service Mesh。&lt;/p>
&lt;h2 id="前提条件">前提条件&lt;/h2>
&lt;p>网络策略通过网络插件来实现，所以必须使用一种支持 &lt;code>NetworkPolicy&lt;/code> 的网络方案（如 &lt;a href="https://www.projectcalico.org/" target="_blank" rel="noopener">calico&lt;/a>）—— 非 Controller 创建的资源，是不起作用的。&lt;/p>
&lt;h2 id="隔离的与未隔离的-pod">隔离的与未隔离的 Pod&lt;/h2>
&lt;p>默认 Pod 是未隔离的，它们可以从任何的源接收请求。具有一个可以选择 Pod 的网络策略后，Pod 就会变成隔离的。一旦 Namespace 中配置的网络策略能够选择一个特定的 Pod，这个 Pod 将拒绝任何该网络策略不允许的连接。（Namespace 中其它未被网络策略选中的 Pod 将继续接收所有流量）&lt;/p>
&lt;h2 id="networkpolicy-资源">&lt;code>NetworkPolicy&lt;/code> 资源&lt;/h2>
&lt;p>下面是一个 &lt;code>NetworkPolicy&lt;/code> 的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-network-policy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">db&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">policyTypes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">Egress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ingress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">from&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">ipBlock&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">cidr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">172.17.0.0&lt;/span>&lt;span class="l">/16&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">except&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">172.17.1.0&lt;/span>&lt;span class="l">/24&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">namespaceSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">project&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myproject&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">frontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6379&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">egress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">to&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">ipBlock&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">cidr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10.0.0.0&lt;/span>&lt;span class="l">/24&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5978&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>将上面配置 POST 到 API Server 将不起任何作用，除非选择的网络方案支持网络策略。&lt;/em>&lt;/p>
&lt;p>&lt;strong>必选字段&lt;/strong>：像所有其它 Kubernetes 配置一样， &lt;code>NetworkPolicy&lt;/code> 需要 &lt;code>apiVersion&lt;/code>、&lt;code>kind&lt;/code> 和 &lt;code>metadata&lt;/code> 这三个字段，关于如何使用配置文件的基本信息，可以查看 &lt;a href="https://kubernetes.io/docs/user-guide/configuring-containers" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;p>&lt;strong>spec&lt;/strong>：&lt;code>NetworkPolicy&lt;/code> spec 具有在给定 Namespace 中定义特定网络的全部信息。&lt;/p>
&lt;p>&lt;strong>podSelector&lt;/strong>：每个 &lt;code>NetworkPolicy&lt;/code> 包含一个 &lt;code>podSelector&lt;/code>，它可以选择一组应用了网络策略的 Pod。由于 &lt;code>NetworkPolicy&lt;/code> 当前只支持定义 &lt;code>ingress&lt;/code> 规则，这个 &lt;code>podSelector&lt;/code> 实际上为该策略定义了一组 “目标 Pod”。示例中的策略选择了标签为 “role=db” 的 Pod。一个空的 &lt;code>podSelector&lt;/code> 选择了该 Namespace 中的所有 Pod。&lt;/p>
&lt;p>&lt;strong>ingress&lt;/strong>：每个&lt;code>NetworkPolicy&lt;/code> 包含了一个白名单 &lt;code>ingress&lt;/code> 规则列表。每个规则只允许能够匹配上 &lt;code>from&lt;/code> 和 &lt;code>ports&lt;/code>配置段的流量。示例策略包含了单个规则，它从这两个源中匹配在单个端口上的流量，第一个是通过&lt;code>namespaceSelector&lt;/code> 指定的，第二个是通过 &lt;code>podSelector&lt;/code> 指定的。&lt;/p>
&lt;p>&lt;strong>egress&lt;/strong>：每个&lt;code>NetworkPolicy&lt;/code> 包含了一个白名单 &lt;code>ingress&lt;/code> 规则列表。每个规则只允许能够匹配上 &lt;code>to&lt;/code> 和 &lt;code>ports&lt;/code>配置段的流量。示例策略包含了单个规则，它匹配目的地 &lt;code>10.0.0.0/24&lt;/code> 单个端口的流量。&lt;/p>
&lt;p>因此，上面示例的 NetworkPolicy：&lt;/p>
&lt;ol>
&lt;li>在 “default” Namespace 中 隔离了标签 “role=db” 的 Pod（如果他们还没有被隔离）&lt;/li>
&lt;li>在 “default” Namespace 中，允许任何具有 “role=frontend” 的 Pod，IP 范围在 172.17.0.0–172.17.0.255 和 172.17.2.0–172.17.255.255（整个 172.17.0.0/16 段， 172.17.1.0/24 除外）连接到标签为 “role=db” 的 Pod 的 TCP 端口 6379&lt;/li>
&lt;li>允许在 Namespace 中任何具有标签 “project=myproject” ，IP 范围在 10.0.0.0/24 段的 Pod，连接到 “default” Namespace 中标签为 “role=db” 的 Pod 的 TCP 端口 5978&lt;/li>
&lt;/ol>
&lt;p>查看 &lt;a href="https://kubernetes.io/docs/getting-started-guides/network-policy/walkthrough" target="_blank" rel="noopener">NetworkPolicy 入门指南&lt;/a>给出的更进一步的例子。&lt;/p>
&lt;h2 id="默认策略">默认策略&lt;/h2>
&lt;p>通过创建一个可以选择所有 Pod 但不允许任何流量的 NetworkPolicy，你可以为一个 Namespace 创建一个 “默认的” 隔离策略，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default-deny&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这确保了即使是没有被任何 NetworkPolicy 选中的 Pod，将仍然是被隔离的。&lt;/p>
&lt;p>可选地，在 Namespace 中，如果你想允许所有的流量进入到所有的 Pod（即使已经添加了某些策略，使一些 Pod 被处理为 “隔离的”），你可以通过创建一个策略来显式地指定允许所有流量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">allow-all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ingress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- {}&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">Network Policies - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>rbac</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/rbac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/rbac/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 45
title: 基于角色的访问控制（RBAC）
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book&lt;/h2>
&lt;p>&lt;strong>注意：本文基于 Kubernetes 1.6 撰写，当时 RBAC 模式处于 beta 版本。&lt;/strong>&lt;/p>
&lt;p>基于角色的访问控制（Role-Based Access Control，即”RBAC”）使用 &lt;code>rbac.authorization.k8s.io&lt;/code> API Group 实现授权决策，允许管理员通过 Kubernetes API 动态配置策略。&lt;/p>
&lt;p>要启用 RBAC，请使用 &lt;code>--authorization-mode=RBAC&lt;/code> 启动 API Server。&lt;/p>
&lt;h2 id="api-概述">API 概述&lt;/h2>
&lt;p>本节将介绍 RBAC API 所定义的四种顶级类型。用户可以像使用其他 Kubernetes API 资源一样 （例如通过 &lt;code>kubectl&lt;/code>、API 调用等）与这些资源进行交互。例如，命令 &lt;code>kubectl create -f (resource).yml&lt;/code> 可以被用于以下所有的例子，当然，读者在尝试前可能需要先阅读以下相关章节的内容。&lt;/p>
&lt;h3 id="role-与-clusterrole">Role 与 ClusterRole&lt;/h3>
&lt;p>在 RBAC API 中，一个角色包含了一套表示一组权限的规则。权限以纯粹的累加形式累积（没有” 否定” 的规则）。角色可以由命名空间（namespace）内的 &lt;code>Role&lt;/code> 对象定义，而整个 Kubernetes 集群范围内有效的角色则通过 &lt;code>ClusterRole&lt;/code> 对象实现。&lt;/p>
&lt;p>一个 &lt;code>Role&lt;/code> 对象只能用于授予对某一单一命名空间中资源的访问权限。以下示例描述了”default” 命名空间中的一个 &lt;code>Role&lt;/code> 对象的定义，用于授予对 pod 的读访问权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Role&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-reader&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 空字符串&amp;#34;&amp;#34; 表明使用 core API group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;pods&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ClusterRole&lt;/code> 对象可以授予与 &lt;code>Role&lt;/code> 对象相同的权限，但由于它们属于集群范围对象， 也可以使用它们授予对以下几种资源的访问权限：&lt;/p>
&lt;ul>
&lt;li>集群范围资源（例如节点，即 node）&lt;/li>
&lt;li>非资源类型 endpoint（例如”/healthz”）&lt;/li>
&lt;li>跨所有命名空间的命名空间范围资源（例如 pod，需要运行命令 &lt;code>kubectl get pods --all-namespaces&lt;/code> 来查询集群中所有的 pod）&lt;/li>
&lt;/ul>
&lt;p>下面示例中的 &lt;code>ClusterRole&lt;/code> 定义可用于授予用户对某一特定命名空间，或者所有命名空间中的 secret（取决于其 &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding" target="_blank" rel="noopener">绑定&lt;/a> 方式）的读访问权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 鉴于 ClusterRole 是集群范围对象，所以这里不需要定义 &amp;#34;namespace&amp;#34; 字段&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-reader&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;secrets&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rolebinding-与-clusterrolebinding">RoleBinding 与 ClusterRoleBinding&lt;/h3>
&lt;p>角色绑定将一个角色中定义的各种权限授予一个或者一组用户。角色绑定包含了一组相关主体（即 subject，包括用户 ——User、用户组 ——Group、或者服务账户 ——Service Account）以及对被授予角色的引用。在命名空间中可以通过 &lt;code>RoleBinding&lt;/code> 对象授予权限，而集群范围的权限授予则通过 &lt;code>ClusterRoleBinding&lt;/code> 对象完成。&lt;/p>
&lt;p>&lt;code>RoleBinding&lt;/code> 可以引用在同一命名空间内定义的 &lt;code>Role&lt;/code> 对象。下面示例中定义的 &lt;code>RoleBinding&lt;/code> 对象在”default” 命名空间中将”pod-reader” 角色授予用户”jane”。这一授权将允许用户”jane” 从”default” 命名空间中读取 pod。&lt;/p>
&lt;p>以下角色绑定定义将允许用户 &amp;ldquo;jane&amp;rdquo; 从 &amp;ldquo;default&amp;rdquo; 命名空间中读取 pod。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">read-pods&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">User&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">jane&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Role&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-reader&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>RoleBinding&lt;/code> 对象也可以引用一个 &lt;code>ClusterRole&lt;/code> 对象用于在 &lt;code>RoleBinding&lt;/code> 所在的命名空间内授予用户对所引用的 &lt;code>ClusterRole&lt;/code> 中 定义的命名空间资源的访问权限。这一点允许管理员在整个集群范围内首先定义一组通用的角色，然后再在不同的命名空间中复用这些角色。&lt;/p>
&lt;p>例如，尽管下面示例中的 &lt;code>RoleBinding&lt;/code> 引用的是一个 &lt;code>ClusterRole&lt;/code> 对象，但是用户”dave”（即角色绑定主体）还是只能读取”development” 命名空间中的 secret（即 &lt;code>RoleBinding&lt;/code> 所在的命名空间）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 以下角色绑定允许用户 &amp;#34;dave&amp;#34; 读取 &amp;#34;development&amp;#34; 命名空间中的 secret。&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">read-secrets&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">development&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 这里表明仅授权读取 &amp;#34;development&amp;#34; 命名空间中的资源。&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">User&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dave&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-reader&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，可以使用&lt;code>ClusterRoleBinding&lt;/code>在集群级别和所有命名空间中授予权限。下面示例中所定义的&lt;code>ClusterRoleBinding&lt;/code>允许在用户组”manager” 中的任何用户都可以读取集群中任何命名空间中的 secret。&lt;/p>
&lt;p>以下 &lt;code>ClusterRoleBinding&lt;/code> 对象允许在用户组 &amp;ldquo;manager&amp;rdquo; 中的任何用户都可以读取集群中任何命名空间中的 secret。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">read-secrets-global&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">manager&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">secret-reader&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="对资源的引用">对资源的引用&lt;/h3>
&lt;p>大多数资源由代表其名字的字符串表示，例如”pods”，就像它们出现在相关 API endpoint 的 URL 中一样。然而，有一些 Kubernetes API 还 包含了” 子资源”，比如 pod 的 logs。在 Kubernetes 中，pod logs endpoint 的 URL 格式为：&lt;/p>
&lt;p>&lt;code>GET /api/v1/namespaces/{namespace}/pods/{name}/log&lt;/code>&lt;/p>
&lt;p>在这种情况下，”pods” 是命名空间资源，而”log” 是 pods 的子资源。为了在 RBAC 角色中表示出这一点，我们需要使用斜线来划分资源 与子资源。如果需要角色绑定主体读取 pods 以及 pod log，您需要定义以下角色：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Role&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-and-pod-logs-reader&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;pods&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;pods/log&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过&lt;code>resourceNames&lt;/code>列表，角色可以针对不同种类的请求根据资源名引用资源实例。当指定了&lt;code>resourceNames&lt;/code>列表时，不同动作 种类的请求的权限，如使用”get”、”delete”、”update” 以及”patch” 等动词的请求，将被限定到资源列表中所包含的资源实例上。例如，如果需要限定一个角色绑定主体只能”get” 或者”update” 一个 configmap 时，您可以定义以下角色：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Role&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">configmap-updater&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;configmap&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceNames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;my-configmap&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;update&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>值得注意的是，如果设置了&lt;code>resourceNames&lt;/code>，则请求所使用的动词不能是 list、watch、create 或者 deletecollection。由于资源名不会出现在 create、list、watch 和 deletecollection 等 API 请求的 URL 中，所以这些请求动词不会被设置了&lt;code>resourceNames&lt;/code>的规则所允许，因为规则中的&lt;code>resourceNames&lt;/code> 部分不会匹配这些请求。&lt;/p>
&lt;h4 id="一些角色定义的例子">一些角色定义的例子&lt;/h4>
&lt;p>在以下示例中，我们仅截取展示了 &lt;code>rules&lt;/code> 部分的定义。&lt;/p>
&lt;p>允许读取 core API Group 中定义的资源”pods”：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;pods&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>允许读写在”extensions” 和”apps” API Group 中定义的”deployments”：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;extensions&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;apps&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;deployments&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;update&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;patch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;delete&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>允许读取”pods” 以及读写”jobs”：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;pods&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;batch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;extensions&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;jobs&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;update&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;patch&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;delete&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>允许读取一个名为”my-config” 的&lt;code>ConfigMap&lt;/code>实例（需要将其通过&lt;code>RoleBinding&lt;/code>绑定从而限制针对某一个命名空间中定义的一个&lt;code>ConfigMap&lt;/code>实例的访问）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;configmaps&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceNames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;my-config&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>允许读取 core API Group 中的”nodes” 资源（由于&lt;code>Node&lt;/code>是集群级别资源，所以此&lt;code>ClusterRole&lt;/code>定义需要与一个&lt;code>ClusterRoleBinding&lt;/code>绑定才能有效）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;nodes&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>允许对非资源 endpoint “/healthz” 及其所有子路径的”GET” 和”POST” 请求（此&lt;code>ClusterRole&lt;/code>定义需要与一个&lt;code>ClusterRoleBinding&lt;/code>绑定才能有效）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">nonResourceURLs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/healthz&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/healthz/*&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 在非资源 URL 中，&amp;#39;*&amp;#39; 代表后缀通配符&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对角色绑定主体（Subject）的引用&lt;code>RoleBinding&lt;/code>或者&lt;code>ClusterRoleBinding&lt;/code> 将角色绑定到 &lt;em>角色绑定主体&lt;/em>（Subject）。角色绑定主体可以是用户组（Group）、用户（User）或者服务账户（Service Accounts）。&lt;/p>
&lt;p>用户由字符串表示。可以是纯粹的用户名，例如”alice”、电子邮件风格的名字，如 “bob@example.com” 或者是用字符串表示的数字 id。由 Kubernetes 管理员配置 &lt;a href="https://kubernetes.io/docs/admin/authentication/" target="_blank" rel="noopener">认证模块&lt;/a> 以产生所需格式的用户名。对于用户名，RBAC 授权系统不要求任何特定的格式。然而，前缀 &lt;code>system:&lt;/code> 是 为 Kubernetes 系统使用而保留的，所以管理员应该确保用户名不会意外地包含这个前缀。&lt;/p>
&lt;p>Kubernetes 中的用户组信息由授权模块提供。用户组与用户一样由字符串表示。Kubernetes 对用户组 字符串没有格式要求，但前缀 &lt;code>system:&lt;/code> 同样是被系统保留的。&lt;/p>
&lt;p>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" rel="noopener">服务账户&lt;/a> 拥有包含 &lt;code>system:serviceaccount:&lt;/code> 前缀的用户名，并属于拥有 &lt;code>system:serviceaccounts:&lt;/code> 前缀的用户组。&lt;/p>
&lt;h4 id="角色绑定的一些例子">角色绑定的一些例子&lt;/h4>
&lt;p>以下示例中，仅截取展示了 &lt;code>RoleBinding&lt;/code> 的 &lt;code>subjects&lt;/code> 字段。&lt;/p>
&lt;p>一个名为”alice@example.com” 的用户：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">User&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;alice@example.com&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个名为”frontend-admins” 的用户组：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;frontend-admins&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>kube-system 命名空间中的默认服务账户：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>名为”qa” 命名空间中的所有服务账户：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">system:serviceaccounts:qa&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在集群中的所有服务账户：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">system:serviceaccounts&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有认证过的用户（version 1.5+）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">system:authenticated&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有未认证的用户（version 1.5+）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">system:unauthenticated&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有用户（version 1.5+）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">system:authenticated&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">system:unauthenticated&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="默认角色与默认角色绑定">默认角色与默认角色绑定&lt;/h2>
&lt;p>API Server 会创建一组默认的 &lt;code>ClusterRole&lt;/code> 和 &lt;code>ClusterRoleBinding&lt;/code> 对象。这些默认对象中有许多包含 &lt;code>system:&lt;/code> 前缀，表明这些资源由 Kubernetes 基础组件” 拥有”。对这些资源的修改可能导致非功能性集群（non-functional cluster）。一个例子是 &lt;code>system:node&lt;/code> ClusterRole 对象。这个角色定义了 kubelets 的权限。如果这个角色被修改，可能会导致 kubelets 无法正常工作。&lt;/p>
&lt;p>所有默认的 ClusterRole 和 ClusterRoleBinding 对象都会被标记为 &lt;code>kubernetes.io/bootstrapping=rbac-defaults&lt;/code>。&lt;/p>
&lt;h3 id="自动更新">自动更新&lt;/h3>
&lt;p>每次启动时，API Server 都会更新默认 ClusterRole 所缺乏的各种权限，并更新默认 ClusterRoleBinding 所缺乏的各个角色绑定主体。这种自动更新机制允许集群修复一些意外的修改。由于权限和角色绑定主体在新的 Kubernetes 释出版本中可能变化，这也能够保证角色和角色 绑定始终保持是最新的。&lt;/p>
&lt;p>如果需要禁用自动更新，请将默认 ClusterRole 以及 ClusterRoleBinding 的 &lt;code>rbac.authorization.kubernetes.io/autoupdate&lt;/code> 设置成为 &lt;code>false&lt;/code>。请注意，缺乏默认权限和角色绑定主体可能会导致非功能性集群问题。&lt;/p>
&lt;p>自 Kubernetes 1.6 + 起，当集群 RBAC 授权器（RBAC Authorizer）处于开启状态时，可以启用自动更新功能.&lt;/p>
&lt;h3 id="发现类角色">发现类角色&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>默认 ClusterRole&lt;/th>
&lt;th>默认 ClusterRoleBinding&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>system:basic-user&lt;/strong>&lt;/td>
&lt;td>&lt;strong>system:authenticated&lt;/strong> and &lt;strong>system:unauthenticated&lt;/strong>groups&lt;/td>
&lt;td>允许用户只读访问有关自己的基本信息。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:discovery&lt;/strong>&lt;/td>
&lt;td>&lt;strong>system:authenticated&lt;/strong> and &lt;strong>system:unauthenticated&lt;/strong>groups&lt;/td>
&lt;td>允许只读访问 API discovery endpoints, 用于在 API 级别进行发现和协商。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="面向用户的角色">面向用户的角色&lt;/h3>
&lt;p>一些默认角色并不包含 &lt;code>system:&lt;/code> 前缀，它们是面向用户的角色。这些角色包含超级用户角色（&lt;code>cluster-admin&lt;/code>），即旨在利用 ClusterRoleBinding（&lt;code>cluster-status&lt;/code>）在集群范围内授权的角色， 以及那些使用 RoleBinding（&lt;code>admin&lt;/code>、&lt;code>edit&lt;/code> 和 &lt;code>view&lt;/code>）在特定命名空间中授权的角色。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>默认 ClusterRole&lt;/th>
&lt;th>默认 ClusterRoleBinding&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>cluster-admin&lt;/strong>&lt;/td>
&lt;td>&lt;strong>system:masters&lt;/strong> group&lt;/td>
&lt;td>超级用户权限，允许对任何资源执行任何操作。在 &lt;strong>ClusterRoleBinding&lt;/strong> 中使用时，可以完全控制集群和所有命名空间中的所有资源。在 &lt;strong>RoleBinding&lt;/strong> 中使用时，可以完全控制 RoleBinding 所在命名空间中的所有资源，包括命名空间自己。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>admin&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>管理员权限，利用 &lt;strong>RoleBinding&lt;/strong> 在某一命名空间内部授予。在 &lt;strong>RoleBinding&lt;/strong> 中使用时，允许针对命名空间内大部分资源的读写访问， 包括在命名空间内创建角色与角色绑定的能力。但不允许对资源配额（resource quota）或者命名空间本身的写访问。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>edit&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>允许对某一个命名空间内大部分对象的读写访问，但不允许查看或者修改角色或者角色绑定。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>view&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>允许对某一个命名空间内大部分对象的只读访问。不允许查看角色或者角色绑定。由于可扩散性等原因，不允许查看 secret 资源。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="core-component-roles">Core Component Roles&lt;/h3>
&lt;h3 id="核心组件角色">核心组件角色&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>默认 ClusterRole&lt;/th>
&lt;th>默认 ClusterRoleBinding&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>system:kube-scheduler&lt;/strong>&lt;/td>
&lt;td>&lt;strong>system:kube-scheduler&lt;/strong> user&lt;/td>
&lt;td>允许访问 kube-scheduler 组件所需要的资源。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:kube-controller-manager&lt;/strong>&lt;/td>
&lt;td>&lt;strong>system:kube-controller-manager&lt;/strong> user&lt;/td>
&lt;td>允许访问 kube-controller-manager 组件所需要的资源。单个控制循环所需要的权限请参阅 &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#controller-roles" target="_blank" rel="noopener">控制器（controller）角色&lt;/a>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:node&lt;/strong>&lt;/td>
&lt;td>&lt;strong>system:nodes&lt;/strong> group (deprecated in 1.7)&lt;/td>
&lt;td>允许对 kubelet 组件所需要的资源的访问，&lt;strong>包括读取所有 secret 和对所有 pod 的写访问&lt;/strong>。自 Kubernetes 1.7 开始，相比较于这个角色，更推荐使用 &lt;a href="https://kubernetes.io/docs/admin/authorization/node/" target="_blank" rel="noopener">Node authorizer&lt;/a> 以及 &lt;a href="https://kubernetes.io/docs/admin/admission-controllers#NodeRestriction" target="_blank" rel="noopener">NodeRestriction admission plugin&lt;/a>， 并允许根据调度运行在节点上的 pod 授予 kubelets API 访问的权限。自 Kubernetes 1.7 开始，当启用 &lt;code>Node&lt;/code> 授权模式时，对 &lt;code>system:nodes&lt;/code> 用户组的绑定将不会被自动创建。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:node-proxier&lt;/strong>&lt;/td>
&lt;td>&lt;strong>system:kube-proxy&lt;/strong> user&lt;/td>
&lt;td>允许对 kube-proxy 组件所需要资源的访问。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="其它组件角色">其它组件角色&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>默认 ClusterRole&lt;/th>
&lt;th>默认 ClusterRoleBinding&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>system:auth-delegator&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>允许委托认证和授权检查。通常由附加 API Server 用于统一认证和授权。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:heapster&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>&lt;a href="https://github.com/kubernetes/heapster" target="_blank" rel="noopener">Heapster&lt;/a> 组件的角色。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:kube-aggregator&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>&lt;a href="https://github.com/kubernetes/kube-aggregator" target="_blank" rel="noopener">kube-aggregator&lt;/a> 组件的角色。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:kube-dns&lt;/strong>&lt;/td>
&lt;td>&lt;strong>kube-dns&lt;/strong> service account in the &lt;strong>kube-system&lt;/strong>namespace&lt;/td>
&lt;td>&lt;a href="https://kubernetes.io/docs/admin/dns/" target="_blank" rel="noopener">kube-dns&lt;/a> 组件的角色。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:node-bootstrapper&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>允许对执行 &lt;a href="https://kubernetes.io/docs/admin/kubelet-tls-bootstrapping/" target="_blank" rel="noopener">Kubelet TLS 引导（Kubelet TLS bootstrapping）&lt;/a> 所需要资源的访问.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:node-problem-detector&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>&lt;a href="https://github.com/kubernetes/node-problem-detector" target="_blank" rel="noopener">node-problem-detector&lt;/a> 组件的角色。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>system:persistent-volume-provisioner&lt;/strong>&lt;/td>
&lt;td>None&lt;/td>
&lt;td>允许对大部分动态存储卷创建组件（dynamic volume provisioner）所需要资源的访问。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="控制器controller角色">控制器（Controller）角色&lt;/h3>
&lt;p>&lt;a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="noopener">Kubernetes controller manager&lt;/a> 负责运行核心控制循环。当使用 &lt;code>--use-service-account-credentials&lt;/code> 选项运行 controller manager 时，每个控制循环都将使用单独的服务账户启动。而每个控制循环都存在对应的角色，前缀名为 &lt;code>system:controller:&lt;/code>。如果不使用 &lt;code>--use-service-account-credentials&lt;/code> 选项时，controller manager 将会使用自己的凭证运行所有控制循环，而这些凭证必须被授予相关的角色。这些角色包括：&lt;/p>
&lt;ul>
&lt;li>system:controller:attachdetach-controller&lt;/li>
&lt;li>system:controller:certificate-controller&lt;/li>
&lt;li>system:controller:cronjob-controller&lt;/li>
&lt;li>system:controller:daemon-set-controller&lt;/li>
&lt;li>system:controller:deployment-controller&lt;/li>
&lt;li>system:controller:disruption-controller&lt;/li>
&lt;li>system:controller:endpoint-controller&lt;/li>
&lt;li>system:controller:generic-garbage-collector&lt;/li>
&lt;li>system:controller:horizontal-pod-autoscaler&lt;/li>
&lt;li>system:controller:job-controller&lt;/li>
&lt;li>system:controller:namespace-controller&lt;/li>
&lt;li>system:controller:node-controller&lt;/li>
&lt;li>system:controller:persistent-volume-binder&lt;/li>
&lt;li>system:controller:pod-garbage-collector&lt;/li>
&lt;li>system:controller:replicaset-controller&lt;/li>
&lt;li>system:controller:replication-controller&lt;/li>
&lt;li>system:controller:resourcequota-controller&lt;/li>
&lt;li>system:controller:route-controller&lt;/li>
&lt;li>system:controller:service-account-controller&lt;/li>
&lt;li>system:controller:service-controller&lt;/li>
&lt;li>system:controller:statefulset-controller&lt;/li>
&lt;li>system:controller:ttl-controller&lt;/li>
&lt;/ul>
&lt;h2 id="初始化与预防权限升级">初始化与预防权限升级&lt;/h2>
&lt;p>RBAC API 会阻止用户通过编辑角色或者角色绑定来升级权限。由于这一点是在 API 级别实现的，所以在 RBAC 授权器（RBAC authorizer）未启用的状态下依然可以正常工作。&lt;/p>
&lt;p>用户只有在拥有了角色所包含的所有权限的条件下才能创建／更新一个角色，这些操作还必须在角色所处的相同范围内进行（对于 &lt;code>ClusterRole&lt;/code> 来说是集群范围，对于 &lt;code>Role&lt;/code> 来说是在与角色相同的命名空间或者集群范围）。例如，如果用户”user-1” 没有权限读取集群范围内的 secret 列表，那么他也不能创建包含这种权限的 &lt;code>ClusterRole&lt;/code>。为了能够让用户创建／更新角色，需要：&lt;/p>
&lt;ol>
&lt;li>授予用户一个角色以允许他们根据需要创建／更新 &lt;code>Role&lt;/code> 或者 &lt;code>ClusterRole&lt;/code> 对象。&lt;/li>
&lt;li>授予用户一个角色包含他们在 &lt;code>Role&lt;/code> 或者 &lt;code>ClusterRole&lt;/code> 中所能够设置的所有权限。如果用户尝试创建或者修改 &lt;code>Role&lt;/code> 或者 &lt;code>ClusterRole&lt;/code> 以设置那些他们未被授权的权限时，这些 API 请求将被禁止。&lt;/li>
&lt;/ol>
&lt;p>用户只有在拥有所引用的角色中包含的所有权限时才可以创建／更新角色绑定（这些操作也必须在角色绑定所处的相同范围内进行）_ 或者 _ 用户被明确授权可以在所引用的角色上执行绑定操作。例如，如果用户”user-1” 没有权限读取集群范围内的 secret 列表，那么他将不能创建 &lt;code>ClusterRole&lt;/code> 来引用那些授予了此项权限的角色。为了能够让用户创建／更新角色绑定，需要：&lt;/p>
&lt;ol>
&lt;li>授予用户一个角色以允许他们根据需要创建／更新 &lt;code>RoleBinding&lt;/code> 或者 &lt;code>ClusterRoleBinding&lt;/code> 对象。&lt;/li>
&lt;li>授予用户绑定某一特定角色所需要的权限：
&lt;ul>
&lt;li>隐式地，通过授予用户所有所引用的角色中所包含的权限&lt;/li>
&lt;li>显式地，通过授予用户在特定 Role（或者 ClusterRole）对象上执行 &lt;code>bind&lt;/code> 操作的权限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>例如，下面例子中的 ClusterRole 和 RoleBinding 将允许用户”user-1” 授予其它用户”user-1-namespace” 命名空间内的 &lt;code>admin&lt;/code>、&lt;code>edit&lt;/code> 和 &lt;code>view&lt;/code> 等角色和角色绑定。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">role-grantor&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;rbac.authorization.k8s.io&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;rolebindings&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;rbac.authorization.k8s.io&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;clusterroles&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">verbs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;bind&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceNames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;admin&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;edit&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;view&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">RoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">role-grantor-binding&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">user-1-namespace&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">role-grantor&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">User&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">user-1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当初始化第一个角色和角色绑定时，初始用户需要能够授予他们尚未拥有的权限。初始化初始角色和角色绑定时需要：&lt;/p>
&lt;ul>
&lt;li>使用包含 &lt;code>system：masters&lt;/code> 用户组的凭证，该用户组通过默认绑定绑定到 &lt;code>cluster-admin&lt;/code> 超级用户角色。&lt;/li>
&lt;li>如果您的 API Server 在运行时启用了非安全端口（&lt;code>--insecure-port&lt;/code>），您也可以通过这个没有施行认证或者授权的端口发送角色或者角色绑定请求。&lt;/li>
&lt;/ul>
&lt;h2 id="一些命令行工具">一些命令行工具&lt;/h2>
&lt;p>有两个 &lt;code>kubectl&lt;/code> 命令可以用于在命名空间内或者整个集群内授予角色。&lt;/p>
&lt;h3 id="kubectl-create-rolebinding">&lt;code>kubectl create rolebinding&lt;/code>&lt;/h3>
&lt;p>在某一特定命名空间内授予 &lt;code>Role&lt;/code> 或者 &lt;code>ClusterRole&lt;/code>。示例如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在名为”acme” 的命名空间中将 &lt;code>admin&lt;/code> &lt;code>ClusterRole&lt;/code> 授予用户”bob”：&lt;/p>
&lt;p>&lt;code>kubectl create rolebinding bob-admin-binding --clusterrole=admin --user=bob --namespace=acme&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在名为”acme” 的命名空间中将 &lt;code>view&lt;/code> &lt;code>ClusterRole&lt;/code> 授予服务账户”myapp”：&lt;/p>
&lt;p>&lt;code>kubectl create rolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp --namespace=acme&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="kubectl-create-clusterrolebinding">&lt;code>kubectl create clusterrolebinding&lt;/code>&lt;/h3>
&lt;p>在整个集群中授予 &lt;code>ClusterRole&lt;/code>，包括所有命名空间。示例如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在整个集群范围内将 &lt;code>cluster-admin&lt;/code> &lt;code>ClusterRole&lt;/code> 授予用户”root”：&lt;/p>
&lt;p>&lt;code>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --user=root&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在整个集群范围内将 &lt;code>system:node&lt;/code> &lt;code>ClusterRole&lt;/code> 授予用户”kubelet”：&lt;/p>
&lt;p>&lt;code>kubectl create clusterrolebinding kubelet-node-binding --clusterrole=system:node --user=kubelet&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在整个集群范围内将 &lt;code>view&lt;/code> &lt;code>ClusterRole&lt;/code> 授予命名空间”acme” 内的服务账户”myapp”：&lt;/p>
&lt;p>&lt;code>kubectl create clusterrolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>请参阅 CLI 帮助文档以获得上述命令的详细用法&lt;/p>
&lt;h2 id="服务账户service-account权限">服务账户（Service Account）权限&lt;/h2>
&lt;p>默认的 RBAC 策略将授予控制平面组件（control-plane component）、节点（node）和控制器（controller）一组范围受限的权限， 但对于”kube-system” 命名空间以外的服务账户，则 &lt;strong>不授予任何权限&lt;/strong>（超出授予所有认证用户的发现权限）。&lt;/p>
&lt;p>这一点允许您根据需要向特定服务账户授予特定权限。细粒度的角色绑定将提供更好的安全性，但需要更多精力管理。更粗粒度的授权可能授予服务账户不需要的 API 访问权限（甚至导致潜在授权扩散），但更易于管理。&lt;/p>
&lt;p>从最安全到最不安全可以排序以下方法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对某一特定应用程序的服务账户授予角色（最佳实践）&lt;/p>
&lt;p>要求应用程序在其 pod 规范（pod spec）中指定 &lt;code>serviceAccountName&lt;/code> 字段，并且要创建相应服务账户（例如通过 API、应用程序清单或者命令 &lt;code>kubectl create serviceaccount&lt;/code> 等）。&lt;/p>
&lt;p>例如，在”my-namespace” 命名空间中授予服务账户”my-sa” 只读权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create rolebinding my-sa-view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --serviceaccount&lt;span class="o">=&lt;/span>my-namespace:my-sa &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --namespace&lt;span class="o">=&lt;/span>my-namespace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>在某一命名空间中授予”default” 服务账户一个角色&lt;/p>
&lt;p>如果一个应用程序没有在其 pod 规范中指定 &lt;code>serviceAccountName&lt;/code>，它将默认使用”default” 服务账户。&lt;/p>
&lt;p>注意：授予”default” 服务账户的权限将可用于命名空间内任何没有指定 &lt;code>serviceAccountName&lt;/code> 的 pod。&lt;/p>
&lt;p>下面的例子将在”my-namespace” 命名空间内授予”default” 服务账户只读权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create rolebinding default-view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --serviceaccount&lt;span class="o">=&lt;/span>my-namespace:default &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --namespace&lt;span class="o">=&lt;/span>my-namespace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>目前，许多 &lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">加载项（addon）&lt;/a> 作为”kube-system” 命名空间中的”default” 服务账户运行。要允许这些加载项使用超级用户访问权限，请将 cluster-admin 权限授予”kube-system” 命名空间中的”default” 服务账户。注意：启用上述操作意味着”kube-system” 命名空间将包含允许超级用户访问 API 的秘钥。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create clusterrolebinding add-on-cluster-admin &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>cluster-admin &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --serviceaccount&lt;span class="o">=&lt;/span>kube-system:default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>为命名空间中所有的服务账户授予角色&lt;/p>
&lt;p>如果您希望命名空间内的所有应用程序都拥有同一个角色，无论它们使用什么服务账户，您可以为该命名空间的服务账户用户组授予角色。&lt;/p>
&lt;p>下面的例子将授予”my-namespace” 命名空间中的所有服务账户只读权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create rolebinding serviceaccounts-view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --group&lt;span class="o">=&lt;/span>system:serviceaccounts:my-namespace &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --namespace&lt;span class="o">=&lt;/span>my-namespace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>对集群范围内的所有服务账户授予一个受限角色（不鼓励）&lt;/p>
&lt;p>如果您不想管理每个命名空间的权限，则可以将集群范围角色授予所有服务账户。&lt;/p>
&lt;p>下面的例子将所有命名空间中的只读权限授予集群中的所有服务账户：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create clusterrolebinding serviceaccounts-view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>view &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --group&lt;span class="o">=&lt;/span>system:serviceaccounts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>授予超级用户访问权限给集群范围内的所有服务账户（强烈不鼓励）&lt;/p>
&lt;p>如果您根本不关心权限分块，您可以对所有服务账户授予超级用户访问权限。&lt;/p>
&lt;p>警告：这种做法将允许任何具有读取权限的用户访问 secret 或者通过创建一个容器的方式来访问超级用户的凭据。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create clusterrolebinding serviceaccounts-cluster-admin &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>cluster-admin &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --group&lt;span class="o">=&lt;/span>system:serviceaccounts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="从版本-15-升级">从版本 1.5 升级&lt;/h2>
&lt;p>在 Kubernetes 1.6 之前，许多部署使用非常宽泛的 ABAC 策略，包括授予对所有服务账户的完整 API 访问权限。&lt;/p>
&lt;p>默认的 RBAC 策略将授予控制平面组件（control-plane components）、节点（nodes）和控制器（controller）一组范围受限的权限， 但对于”kube-system” 命名空间以外的服务账户，则 &lt;em>不授予任何权限&lt;/em>（超出授予所有认证用户的发现权限）。&lt;/p>
&lt;p>虽然安全性更高，但这可能会影响到期望自动接收 API 权限的现有工作负载。以下是管理此转换的两种方法：&lt;/p>
&lt;h3 id="并行授权器authorizer">并行授权器（authorizer）&lt;/h3>
&lt;p>同时运行 RBAC 和 ABAC 授权器，并包括旧版 ABAC 策略：&lt;/p>
&lt;p>&lt;code>--authorization-mode=RBAC,ABAC --authorization-policy-file=mypolicy.jsonl&lt;/code>&lt;/p>
&lt;p>RBAC 授权器将尝试首先授权请求。如果 RBAC 授权器拒绝 API 请求，则 ABAC 授权器将被运行。这意味着 RBAC 策略 &lt;em>或者&lt;/em> ABAC 策略所允许的任何请求都是可通过的。&lt;/p>
&lt;p>当以日志级别为 2 或更高（&lt;code>--v = 2&lt;/code>）运行时，您可以在 API Server 日志中看到 RBAC 拒绝请求信息（以 &lt;code>RBAC DENY:&lt;/code> 为前缀）。您可以使用该信息来确定哪些角色需要授予哪些用户，用户组或服务账户。一旦 &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions" target="_blank" rel="noopener">授予服务账户角色&lt;/a>，并且服务器日志中没有 RBAC 拒绝消息的工作负载正在运行，您可以删除 ABAC 授权器。&lt;/p>
&lt;h3 id="宽泛的-rbac-权限">宽泛的 RBAC 权限&lt;/h3>
&lt;p>您可以使用 RBAC 角色绑定来复制一个宽泛的策略。&lt;/p>
&lt;p>&lt;strong>警告：以下政策略允许所有服务账户作为集群管理员。运行在容器中的任何应用程序都会自动接收服务账户凭据，并且可以对 API 执行任何操作，包括查看 secret 和修改权限。因此，并不推荐使用这种策略。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl create clusterrolebinding permissive-binding &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --clusterrole&lt;span class="o">=&lt;/span>cluster-admin &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --user&lt;span class="o">=&lt;/span>admin &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --user&lt;span class="o">=&lt;/span>kubelet &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --group&lt;span class="o">=&lt;/span>system:serviceaccounts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">使用 RBAC 鉴权 - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>serviceaccount</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/serviceaccount/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/serviceaccount/</guid><description>&lt;hr>
&lt;h2 id="summary-serviceaccount-为-pod-中的进程提供身份信息">weight: 44
title: ServiceAccount
date: &amp;ldquo;2022-05-21T00:00:00+08:00&amp;rdquo;
type: book
summary: &amp;ldquo;ServiceAccount 为 Pod 中的进程提供身份信息。&amp;rdquo;&lt;/h2>
&lt;p>ServiceAccount 为 Pod 中的进程提供身份信息。&lt;/p>
&lt;div class="alert-note-title">
&lt;p>注意&lt;/p>
&lt;/div>
&lt;div class="alert alert-note">
本文档描述的关于 ServiceAccount 的行为只有当你按照 Kubernetes 项目建议的方式搭建集群的情况下才有效。集群管理员可能在你的集群中进行了自定义配置，这种情况下该文档可能并不适用。
&lt;/div>
&lt;p>当你（真人用户）访问集群（例如使用 &lt;code>kubectl&lt;/code> 命令）时，API 服务器会将你认证为一个特定的 User Account（目前通常是 &lt;code>admin&lt;/code>，除非你的系统管理员自定义了集群配置）。Pod 容器中的进程也可以与 API 服务器联系。当它们在联系 API 服务器的时候，它们会被认证为一个特定的 ServiceAccount（例如&lt;code>default&lt;/code>）。&lt;/p>
&lt;h2 id="使用默认的-serviceaccount-访问-api-服务器">使用默认的 ServiceAccount 访问 API 服务器&lt;/h2>
&lt;p>当你创建 pod 的时候，如果你没有指定一个 ServiceAccount，系统会自动得在与该 pod 相同的 namespace 下为其指派一个 &lt;code>default&lt;/code> ServiceAccount。如果你获取刚创建的 pod 的原始 json 或 yaml 信息（例如使用&lt;code>kubectl get pods/podename -o yaml&lt;/code>命令），你将看到&lt;code>spec.serviceAccountName&lt;/code>字段已经被设置为 &lt;code>default&lt;/code>。&lt;/p>
&lt;p>你可以在 pod 中使用自动挂载的 ServiceAccount 凭证来访问 API，如 &lt;a href="https://kubernetes.io/docs/user-guide/accessing-the-cluster/#accessing-the-api-from-a-pod" target="_blank" rel="noopener">Accessing the Cluster&lt;/a> 中所描述。&lt;/p>
&lt;p>ServiceAccount 是否能够取得访问 API 的许可取决于你使用的 &lt;a href="https://kubernetes.io/docs/admin/authorization/#a-quick-note-on-service-accounts" target="_blank" rel="noopener">授权插件和策略&lt;/a>。&lt;/p>
&lt;p>在 1.6 以上版本中，你可以选择取消为 ServiceAccount 自动挂载 API 凭证，只需在 ServiceAccount 中设置 &lt;code>automountServiceAccountToken: false&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">build-robot&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">automountServiceAccountToken&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 1.6 以上版本中，你也可以选择只取消单个 pod 的 API 凭证自动挂载：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceAccountName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">build-robot&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">automountServiceAccountToken&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="l">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在 pod 和 ServiceAccount 中同时设置了 &lt;code>automountServiceAccountToken&lt;/code>, pod 设置中的优先级更高。&lt;/p>
&lt;h2 id="使用多个-serviceaccount">使用多个 ServiceAccount&lt;/h2>
&lt;p>每个 namespace 中都有一个默认的叫做 &lt;code>default&lt;/code> 的 ServiceAccount 资源。&lt;/p>
&lt;p>你可以使用以下命令列出 namespace 下的所有 serviceAccount 资源。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get serviceaccounts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NAME SECRETS AGE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">default &lt;span class="m">1&lt;/span> 1d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以像这样创建一个 ServiceAccount 对象：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cat &amp;gt; /tmp/serviceaccount.yaml &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">apiVersion: v1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">kind: ServiceAccount
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">metadata:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> name: build-robot
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl create -f /tmp/serviceaccount.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">serviceaccount &lt;span class="s2">&amp;#34;build-robot&amp;#34;&lt;/span> created
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你看到如下的 ServiceAccount 对象的完整输出信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get serviceaccounts/build-robot -o yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apiVersion: v1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kind: ServiceAccount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">metadata:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> creationTimestamp: 2015-06-16T00:12:59Z
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name: build-robot
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> namespace: default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> resourceVersion: &lt;span class="s2">&amp;#34;272500&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> selfLink: /api/v1/namespaces/default/serviceaccounts/build-robot
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uid: 721ab723-13bc-11e5-aec2-42010af0021e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">secrets:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- name: build-robot-token-bvbk5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后你将看到有一个 token 已经被自动创建，并被 ServiceAccount 引用。&lt;/p>
&lt;p>你可以使用授权插件来 &lt;a href="https://kubernetes.io/docs/admin/authorization/#a-quick-note-on-service-accounts" target="_blank" rel="noopener">设置 ServiceAccount 的权限&lt;/a> 。&lt;/p>
&lt;p>设置非默认的 ServiceAccount，只需要在 pod 的 &lt;code>spec.serviceAccountName&lt;/code> 字段中将 name 设置为你想要用的 ServiceAccount 名字即可。&lt;/p>
&lt;p>在 pod 创建之初 ServiceAccount 就必须已经存在，否则创建将被拒绝。&lt;/p>
&lt;p>你不能更新已创建的 pod 的 ServiceAccount。&lt;/p>
&lt;p>你可以清理 ServiceAccount，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl delete serviceaccount/build-robot
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="手动创建-serviceaccount-的-api-token">手动创建 ServiceAccount 的 API token&lt;/h2>
&lt;p>假设我们已经有了一个如上文提到的名为 ”build-robot“ 的 ServiceAccount，我们手动创建一个新的 secret。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cat &amp;gt; /tmp/build-robot-secret.yaml &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">apiVersion: v1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">kind: Secret
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">metadata:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> name: build-robot-secret
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> annotations:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> kubernetes.io/service-account.name: build-robot
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">type: kubernetes.io/service-account-token
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl create -f /tmp/build-robot-secret.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">secret &lt;span class="s2">&amp;#34;build-robot-secret&amp;#34;&lt;/span> created
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在你可以确认下新创建的 secret 取代了 “build-robot” 这个 ServiceAccount 原来的 API token。&lt;/p>
&lt;p>所有已不存在的 ServiceAccount 的 token 将被 token controller 清理掉。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl describe secrets/build-robot-secret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Name: build-robot-secret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Namespace: default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Labels: &amp;lt;none&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Annotations: kubernetes.io/service-account.name&lt;span class="o">=&lt;/span>build-robot,kubernetes.io/service-account.uid&lt;span class="o">=&lt;/span>870ef2a5-35cf-11e5-8d06-005056b45392
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Type: kubernetes.io/service-account-token
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">====&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ca.crt: &lt;span class="m">1220&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">token: ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">namespace: &lt;span class="m">7&lt;/span> bytes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="alert-note-title">
&lt;p>注意&lt;/p>
&lt;/div>
&lt;div class="alert alert-note">
该内容中的&lt;code>token&lt;/code>被省略了。
&lt;/div>
&lt;h2 id="为-serviceaccount-添加-imagepullsecret">为 ServiceAccount 添加 ImagePullSecret&lt;/h2>
&lt;p>首先，创建一个 imagePullSecret，详见&lt;a href="https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;p>然后，确认已创建。如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get secrets myregistrykey
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NAME TYPE DATA AGE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">myregistrykey kubernetes.io/.dockerconfigjson &lt;span class="m">1&lt;/span> 1d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，修改 namespace 中的默认 ServiceAccount 使用该 secret 作为 imagePullSecret。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl patch serviceaccount default -p &lt;span class="s1">&amp;#39;{&amp;#34;imagePullSecrets&amp;#34;: [{&amp;#34;name&amp;#34;: &amp;#34;myregistrykey&amp;#34;}]}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Vi 交互过程中需要手动编辑：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ kubectl get serviceaccounts default -o yaml &amp;gt; ./sa.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cat sa.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apiVersion: v1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kind: ServiceAccount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">metadata:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> creationTimestamp: 2015-08-07T22:02:39Z
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name: default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> namespace: default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> resourceVersion: &lt;span class="s2">&amp;#34;243024&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> selfLink: /api/v1/namespaces/default/serviceaccounts/default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uid: 052fb0f4-3d50-11e5-b066-42010af0d7b6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">secrets:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- name: default-token-uudge
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vi sa.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>editor session not shown&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>delete line with key &lt;span class="s2">&amp;#34;resourceVersion&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>add lines with &lt;span class="s2">&amp;#34;imagePullSecret:&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cat sa.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apiVersion: v1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kind: ServiceAccount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">metadata:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> creationTimestamp: 2015-08-07T22:02:39Z
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name: default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> namespace: default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> selfLink: /api/v1/namespaces/default/serviceaccounts/default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uid: 052fb0f4-3d50-11e5-b066-42010af0d7b6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">secrets:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- name: default-token-uudge
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">imagePullSecrets:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- name: myregistrykey
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ kubectl replace serviceaccount default -f ./sa.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">serviceaccounts/default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，所有当前 namespace 中新创建的 pod 的 spec 中都会增加如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullSecrets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myregistrykey&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" rel="noopener">Configure Service Accounts for Pods - kubernetes.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>spiffe</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/spiffe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/spiffe/</guid><description>&lt;hr>
&lt;h2 id="type-book">weight: 47
title: SPIFFE
date: &amp;lsquo;2022-05-21T00:00:00+08:00&amp;rsquo;
type: book&lt;/h2>
&lt;p>SPIFFE，即普适安全生产身份框架（Secure Production Identity Framework for Everyone），是一套开源标准，用于在动态和异构环境中安全地进行身份识别。采用 SPIFFE 的系统无论在哪里运行，都可以轻松可靠地相互认证。&lt;/p>
&lt;p>SPIFFE 开源规范的核心是——通过简单 API 定义了一个短期的加密身份文件 SVID。然后，工作负载进行认证时可以使用该身份文件，例如建立 TLS 连接或签署和验证 JWT 令牌等。&lt;/p>
&lt;p>SPIFFE 已经在云原生应用中得到了大量的应用，尤其是在 Istio 和 Envoy 中。下面将向你介绍 SPIFFE 的一些基本概念。&lt;/p>
&lt;h2 id="工作负载">工作负载&lt;/h2>
&lt;p>工作负载是个单一的软件，以特定的配置部署，用于单一目的；它可能包括软件的多个运行实例，所有这些实例执行相同的任务。工作负载这个术语可以包含一系列不同的软件系统定义，包括：&lt;/p>
&lt;ul>
&lt;li>一个运行 Python 网络应用程序的网络服务器，在一个虚拟机集群上运行，前面有一个负载均衡器。&lt;/li>
&lt;li>一个 MySQL 数据库的实例。&lt;/li>
&lt;li>一个处理队列中项目的 worker 程序。&lt;/li>
&lt;li>独立部署的系统的集合，它们一起工作，例如一个使用数据库服务的网络应用程序。网络应用程序和数据库也可以单独被视为工作负载。&lt;/li>
&lt;/ul>
&lt;p>就 SPIFFE 而言，工作负载往往比物理或虚拟节点更加细化——通常细化到节点上的单个进程。这对工作负载来说至关重要，例如，在容器编排器中托管的工作负载，几个工作负载可能在同一个节点上（但彼此隔离）。&lt;/p>
&lt;p>就 SPIFFE 而言，一个工作负载也可能跨越许多节点。例如，一个可弹性扩展的网络服务器可能同时运行在许多机器上。&lt;/p>
&lt;p>虽然工作负载的粒度会因环境而异，但就 SPIFFE 而言，我们&lt;strong>假设&lt;/strong>工作负载之间有足够好的隔离，这样恶意的工作负载就不能窃取他人的凭证。这种隔离的稳健性和实现的机制超出了 SPIFFE 的范围。&lt;/p>
&lt;h2 id="spiffe-id">SPIFFE ID&lt;/h2>
&lt;p>SPIFFE ID 是一个字符串，可以唯一地、具体地标识一个工作负载。SPIFFE ID 也可以分配给工作负载所运行的中间系统（如一组虚拟机）。例如，&lt;code>spiffe://acme.com/billing/payments&lt;/code> 是一个有效的SPIFFE ID。&lt;/p>
&lt;p>SPIFFE ID 是一个&lt;a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">统一资源标识符（URI&lt;/a>），其格式如下：&lt;code>spiffe://信任域/工作负载标识符&lt;/code>。&lt;/p>
&lt;p>&lt;strong>工作负载标识符&lt;/strong>是一个&lt;a href="https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-domain" target="_blank" rel="noopener">信任域&lt;/a>内的特定工作负载的唯一标识。&lt;/p>
&lt;p>&lt;a href="https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE.md" target="_blank" rel="noopener">SPIFFE 规范&lt;/a>详细描述了 SPIFFE ID 的格式和使用。&lt;/p>
&lt;h2 id="信任域">信任域&lt;/h2>
&lt;p>信任域对应于系统的信任根。信任域可以代表个人、组织、环境或部门，运行他们自己独立的 SPIFFE 基础设施。在同一信任域中确定的所有工作负载都会被颁发身份文件，它们可以根据信任域的根密钥进行验证。&lt;/p>
&lt;p>通常建议将处于不同物理位置（如不同的数据中心或云区域）或应用不同安全实践的环境（如与生产环境相比的暂存或实验环境）的工作负载放在不同的信任域中。&lt;/p>
&lt;h2 id="svid">SPIFFE 可验证的身份文件（SVID）&lt;/h2>
&lt;p>SVID（SPIFFE Verifiable Identity Document） 是工作负载向资源或调用者证明其身份的文件。如果 SVID 是由 SPIFFE ID 的信任域内的机构签发的，则被认为是有效的。&lt;/p>
&lt;p>SVID 包含一个 SPIFFE ID，代表了服务的身份。它将 SPIFFE ID 编码在一个可加密验证的文件中，目前支持两种格式：X.509 证书或 JWT 令牌。&lt;/p>
&lt;p>由于令牌容易受到&lt;strong>重放攻击（replay attack）&lt;/strong>，即在传输过程中获得令牌的攻击者可以使用它来冒充工作负载，因此建议尽可能使用 &lt;code>X.509-SVID&lt;/code>。然而，在某些情况下，JWT令牌格式是唯一的选择，例如，当你的架构在两个工作负载之间有一个L7代理或负载均衡器。&lt;/p>
&lt;p>关于 SVID 的详细信息，请参阅 &lt;a href="https://github.com/spiffe/spiffe/blob/main/standards/X509-SVID.md" target="_blank" rel="noopener">SVID 规范&lt;/a>。&lt;/p>
&lt;h2 id="spiffe-工作负载-api">SPIFFE 工作负载 API&lt;/h2>
&lt;p>工作负载 API 提供以下内容。&lt;/p>
&lt;p>对于&lt;code>X.509&lt;/code>格式的身份文件（&lt;code>X.509-SVID&lt;/code>）:&lt;/p>
&lt;ul>
&lt;li>其身份，描述为 SPIFFE ID。&lt;/li>
&lt;li>一个与该 ID 绑定的私钥，可用于代表工作负载签署数据。一个相应的短期 X.509 证书也将被创建，即 &lt;code>X509-SVID&lt;/code>。这可以用来建立 TLS 或以其他方式对其他工作负载进行认证。&lt;/li>
&lt;li>一组证书——被称为&lt;a href="https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-bundle" target="_blank" rel="noopener">信任包&lt;/a>。一个工作负载用来验证另一个工作负载提出的&lt;code>X.509-SVID&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>对于 JWT 格式的身份文件（JWT-SVID）：&lt;/p>
&lt;ul>
&lt;li>其身份，描述为 SPIFFE ID&lt;/li>
&lt;li>JWT 令牌&lt;/li>
&lt;li>一组证书——被称为&lt;a href="https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-bundle" target="_blank" rel="noopener">信任包&lt;/a>，一个工作负载用来验证其他工作负载的身份。&lt;/li>
&lt;/ul>
&lt;p>与 &lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html" target="_blank" rel="noopener">AWS EC2 实例元数据 API&lt;/a>和 &lt;a href="https://cloud.google.com/compute/docs/storing-retrieving-metadata" target="_blank" rel="noopener">Google GCE 实例元数据 API&lt;/a> 类似，工作负载 API 不要求调用的工作负载对自己的身份有任何了解，也不要求调用 API 时拥有任何认证令牌。这意味着你的应用程序不需要与工作负载共同部署任何认证密钥。&lt;/p>
&lt;p>然而，与这些其他 API 不同的是，Workload API 与平台无关，可以在进程级和内核级识别正在运行的服务，这使得它适合与 Kubernetes 等容器调度器一起使用。&lt;/p>
&lt;p>为了最大限度地减少密钥泄露的风险，所有私钥（和相应的证书）都是短期的，经常自动轮换。工作负载可以在相应的密钥过期前从工作负载API请求新的密钥和信任包。&lt;/p>
&lt;h2 id="信任包">信任包&lt;/h2>
&lt;p>当使用 &lt;code>X.509-SVID&lt;/code> 时，目标工作负载使用信任包（Trust Bundle）来验证源工作负载的身份。信任包是一个或多个证书机构（CA）根证书的集合，工作负载认为这些证书是可信的。信任包包含 X.509 和 JWT SVID 的公钥材料。&lt;/p>
&lt;p>用来验证 X.509 SVID 的公钥材料是一组证书。用于验证 JWT 的公钥材料是一个原始公钥。信任包的内容是经常轮换的。工作负载在调用工作负载 API 时检索信任包。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://spiffe.io" target="_blank" rel="noopener">SPIFFE 官网 - spiffe.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>spire</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/spire/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/spire/</guid><description>&lt;hr>
&lt;h2 id="summary-这篇文章将向你介绍-spire-的架构基本概念及原理">weight: 48
title: SPIRE
date: &amp;ldquo;2022-06-10T00:00:00+08:00&amp;rdquo;
type: book
summary: 这篇文章将向你介绍 SPIRE 的架构、基本概念及原理。&lt;/h2>
&lt;p>这篇文章将向你介绍 SPIRE 的架构、基本概念及原理。&lt;/p>
&lt;p>SPIRE 是 &lt;a href="../spiffe">SPIFFE API&lt;/a> 的一个生产就绪的实现，它执行节点和工作负载认证，以便根据一组预先定义的条件，安全地向工作负载发出 SVID，并验证其他工作负载的 SVID。&lt;/p>
&lt;h2 id="spire-架构和组件">SPIRE 架构和组件&lt;/h2>
&lt;p>SPIRE 部署由一个 SPIRE 服务器和一个或多个 SPIRE 代理组成。服务器充当通过代理向一组工作负载发放身份的签名机构。它还维护一个工作负载身份的注册表，以及为签发这些身份而必须验证的条件。代理在本地向工作负载公开 SPIFFE 工作负载 API，必须安装在工作负载运行的每个节点上。&lt;/p>
&lt;figure id="figure-spire-架构图">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/spire-arch.svg" alt="SPIRE 架构图" loading="lazy" data-zoomable width="30%" />&lt;/div>
&lt;/div>&lt;figcaption>
SPIRE 架构图
&lt;/figcaption>&lt;/figure>
&lt;h2 id="服务器">服务器&lt;/h2>
&lt;p>SPIRE 服务器负责管理和发布其配置的 SPIFFE 信任域中的所有身份。它存储注册条目（指定决定特定 SPIFFE ID 应被签发的条件的选择器）和签名密钥，使用节点证明来自动验证代理的身份，并在被验证的代理请求时为工作负载创建 SVID。&lt;/p>
&lt;p>
&lt;figure id="figure-spire-服务器">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/spire-server.svg" alt="SPIRE 服务器" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
SPIRE 服务器
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>服务器的行为是通过一系列的插件决定的。SPIRE 包含几个插件，你可以建立额外的插件来扩展 SPIRE 以满足特定的使用情况。插件的类型包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>节点证明器插件&lt;/strong>：与代理节点证明器一起，验证代理运行的节点的身份。&lt;/li>
&lt;li>&lt;strong>节点解析器插件&lt;/strong>：它通过验证关于节点的额外属性来扩展服务器可以用来识别节点的选择器集合。&lt;/li>
&lt;li>&lt;strong>数据存储插件&lt;/strong>：服务器用它来存储、查询和更新各种信息，如注册条目、哪些节点已认证、这些节点的选择器是什么。有一个内置的数据存储插件，可以使用 MySQL、SQLite3 或 PostgresSQL 数据库来存储必要的数据。默认情况下，使用 SQLite 3。&lt;/li>
&lt;li>&lt;strong>密钥管理器插件&lt;/strong>：控制服务器如何存储用于签署 X.509-SVID 和 JWT-SVID 的私钥。&lt;/li>
&lt;li>&lt;strong>上游权威机构插件&lt;/strong>：默认情况下，SPIRE 服务器充当其自身的证书授权机构。但是，你可以使用上游权威机构插件来使用来自不同 PKI 系统的不同 CA。&lt;/li>
&lt;/ul>
&lt;p>你可以通过配置插件和其他各种配置变量来定制服务器的行为。详见 &lt;a href="https://spiffe.io/docs/latest/deploying/spire_server/" target="_blank" rel="noopener">SPIRE 服务器配置参考&lt;/a>。&lt;/p>
&lt;h2 id="代理">代理&lt;/h2>
&lt;p>SPIRE 代理在已识别的工作负载所运行的每个节点上运行。该代理：&lt;/p>
&lt;ul>
&lt;li>从服务器上请求 SVID，并将其缓存起来，直到工作负载请求其 SVID 为止。&lt;/li>
&lt;li>向节点上的工作负载公开 SPIFFE 工作负载 API，并证明调用它的工作负载的身份&lt;/li>
&lt;li>为已识别的工作负载提供其 SVID&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure id="figure-spire-代理">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/spire-agent.svg" alt="SPIRE 代理" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
SPIRE 代理
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;p>该代理的主要组成部分包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>节点证明器插件&lt;/strong>：与服务器节点证明器一起，验证代理运行的节点的身份。&lt;/li>
&lt;li>&lt;strong>工作负载证明器插件&lt;/strong>：通过从节点操作系统中查询有关工作负载进程的信息，并将其与你在使用选择器注册工作负载属性时提供给服务器的信息进行比较，来验证节点上工作负载进程的身份。&lt;/li>
&lt;li>&lt;strong>密钥管理器插件&lt;/strong>：代理用来生成和使用颁发给工作负载的 X.509-SVID 的私钥。&lt;/li>
&lt;/ul>
&lt;p>你可以通过配置插件和其他配置变量来定制代理的行为。详见《&lt;a href="https://spiffe.io/docs/latest/deploying/spire_agent/" target="_blank" rel="noopener">SPIRE 代理配置参考》&lt;/a>。&lt;/p>
&lt;h2 id="自定义服务器和代理插件">自定义服务器和代理插件&lt;/h2>
&lt;p>你可以为特定的平台和架构创建自定义的服务器和代理插件，而 SPIRE 并不包括这些插件。例如，你可以为一个架构创建服务器和代理节点验证器，而不是在节点验证下总结的那些。或者你可以创建一个自定义密钥管理器插件，以 SPIRE 目前不支持的方式处理私钥。因为 SPIRE 在运行时加载自定义插件，你不需要重新编译 SPIRE 来启用它们。&lt;/p>
&lt;h2 id="工作负载注册">工作负载注册&lt;/h2>
&lt;p>为了让 SPIRE 识别工作负载，你必须通过注册条目向 SPIRE 服务器注册工作负载。工作负载注册告诉 SPIRE 如何识别工作负载以及为其提供哪个 SPIFFE ID。&lt;/p>
&lt;p>注册条目将身份（以 SPIFFE ID 的形式）映射到一组称为选择器的属性，工作负载必须拥有这些属性才能获得特定身份。在工作负载证明期间，代理使用这些选择器值来验证工作负载的身份。&lt;/p>
&lt;p>&lt;a href="https://spiffe.io/docs/latest/spire/using/registering/" target="_blank" rel="noopener">SPIRE 文档&lt;/a>中详细介绍了工作负载注册。&lt;/p>
&lt;h2 id="证明">证明&lt;/h2>
&lt;p>SPIRE 上下文中的证明（attestation）是断言工作负载的身份。SPIRE 通过从受信任的第三方收集工作负载进程本身和运行 SPIRE 代理的节点的属性并将它们与工作负载注册时定义的一组选择器进行比较来实现这一点。&lt;/p>
&lt;p>用于执行证明的可信第三方 SPIRE 查询是特定于平台的。&lt;/p>
&lt;p>SPIRE 分两个阶段执行证明：首先是节点证明（其中验证工作负载正在运行的节点的身份），然后是工作负载证明（其中验证节点上的工作负载）。&lt;/p>
&lt;p>SPIRE 有一个灵活的架构，允许它根据工作负载运行的环境，使用许多不同的受信第三方进行节点和工作负载验证。你通过代理和服务器配置文件中的条目告诉 SPIRE 使用哪些受信任的第三方，并通过你在注册工作负载时指定的选择器值告诉 SPIRE 使用哪些类型的信息进行验证。&lt;/p>
&lt;h3 id="节点证明">节点证明&lt;/h3>
&lt;p>SPIRE 要求每个代理在首次连接到服务器时进行身份验证和自我验证；这个过程称为节点证明（Node Attestation）。在节点证明期间，代理和服务器一起验证运行代理的节点的身份。他们通过称为节点证明器的插件来做到这一点。所有节点证明器都向节点及其环境询问只有该节点拥有的信息片段，以证明该节点的身份。&lt;/p>
&lt;p>节点证明的成功后，代理收到唯一的 SPIFFE ID。然后，代理的 SPIFFE ID 充当其负责的工作负载的 “父级”。&lt;/p>
&lt;p>节点身份证明的示例包括：&lt;/p>
&lt;ul>
&lt;li>通过云平台交付给节点的身份证明文件（例如 AWS Instance 身份证明文件）&lt;/li>
&lt;li>验证存储在连接到节点的硬件安全模块或可信平台模块上的私钥&lt;/li>
&lt;li>安装代理时通过加入令牌提供的手动验证&lt;/li>
&lt;li>多节点软件系统安装在节点上时提供的标识凭据（例如 Kubernetes 服务账户令牌）&lt;/li>
&lt;li>其他机器身份证明（例如部署的服务器证书）&lt;/li>
&lt;/ul>
&lt;p>节点证明器向服务器返回一组（可选）节点选择器，用于标识特定机器（例如 Amazon 实例 ID）。由于在定义工作负载的身份时，单个机器的特定身份通常没有用处，因此 SPIRE 会查询&lt;a href="https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-resolution" target="_blank" rel="noopener">节点解析器&lt;/a>（如果有）以查看可以验证被证明节点的哪些附加属性（例如，如果节点是 AWS 安全组的成员）。来自证明器和解析者的选择器集成为与代理节点的 SPIFFE ID 关联的选择器集。&lt;/p>
&lt;div class="alert-note-title">
&lt;p>注意&lt;/p>
&lt;/div>
&lt;div class="alert alert-note">
节点证明不需要节点选择器，除非你&lt;a href="https://spiffe.io/docs/latest/spire/using/registering/#mapping-workloads-to-multiple-nodes" target="_blank" rel="noopener">将工作负载映射到多个节点&lt;/a>。
&lt;/div>
&lt;p>下图说明了节点证明中的步骤。在此图中，底层平台是 AWS：&lt;/p>
&lt;p>
&lt;figure id="figure-spire-节点证明步骤">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/spire-node-attestor.svg" alt="SPIRE 节点证明步骤" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
SPIRE 节点证明步骤
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h4 id="步骤总结节点证明">步骤总结：节点证明&lt;/h4>
&lt;ol>
&lt;li>代理 AWS 节点证明器插件向 AWS 查询节点身份证明，并将该信息提供给代理。&lt;/li>
&lt;li>代理将此身份证明传递给服务器。服务器将此数据传递给其 AWS 节点证明器。&lt;/li>
&lt;li>服务器 AWS 节点证明器独立验证身份证明，或者通过调用 AWS API，使用它在步骤 2 中获得的信息。节点证明器还为代理创建一个 SPIFFE ID，并将其传递回服务器进程，以及它发现的任何节点选择器。&lt;/li>
&lt;li>服务器发回代理节点的 SVID。&lt;/li>
&lt;/ol>
&lt;h4 id="节点证明器">节点证明器&lt;/h4>
&lt;p>代理和服务器通过它们各自的节点证明器询问底层平台。SPIRE 支持节点证明器在各种环境中证明节点身份，包括：&lt;/p>
&lt;ul>
&lt;li>AWS 上的 EC2 实例（使用 EC2 实例身份文档）&lt;/li>
&lt;li>Microsoft Azure 上的 VM（使用 Azure 托管服务标识）&lt;/li>
&lt;li>Google Cloud Platform 上的 Google Compute Engine 实例（使用 GCE 实例身份令牌）&lt;/li>
&lt;li>作为 Kubernetes 集群成员的节点（使用 Kubernetes 服务账户令牌）&lt;/li>
&lt;/ul>
&lt;p>对于没有平台可以直接识别节点的情况，SPIRE 包括用于证明的节点证明器：&lt;/p>
&lt;p>&lt;strong>使用服务器生成的加入令牌&lt;/strong>—— 加入令牌（join token）是 SPIRE 服务器和代理之间的预共享密钥。服务器可以在安装后生成加入令牌，该令牌可用于在代理启动时对其进行验证。为帮助防止滥用，加入令牌在使用后立即过期。&lt;/p>
&lt;p>&lt;strong>使用现有的 X.509 证书&lt;/strong>—— 有关配置节点证明器的信息，请参阅 &lt;a href="https://spiffe.io/docs/latest/deploying/spire_server/" target="_blank" rel="noopener">SPIRE 服务器配置参考&lt;/a>和 &lt;a href="https://spiffe.io/docs/latest/deploying/spire_agent/" target="_blank" rel="noopener">SPIRE 代理配置参考&lt;/a>。&lt;/p>
&lt;h4 id="节点解析">节点解析&lt;/h4>
&lt;p>一旦验证了单个节点的身份，“节点解析器” 插件就会扩展一组选择器，这些选择器可用于通过验证节点的其他属性来识别节点（例如，如果节点是特定 AWS 安全组的成员） ，或具有与之关联的特定标签）。只有服务器参与节点解析。SPIRE 在证明之后直接运行一次节点解析器。&lt;/p>
&lt;h4 id="节点解析器">节点解析器&lt;/h4>
&lt;p>服务器支持以下平台的节点解析器插件：&lt;/p>
&lt;ul>
&lt;li>亚马逊网络服务（AWS）&lt;/li>
&lt;li>微软 Azure&lt;/li>
&lt;/ul>
&lt;h3 id="工作负载证明">工作负载证明&lt;/h3>
&lt;p>工作负载证明提出了一个问题：“这是谁的进程？” 代理通过询问本地可用的权限（例如节点的操作系统内核，或在同一节点上运行的本地 kubelet）来回答这个问题，以确定调用工作负载 API 的进程的属性。&lt;/p>
&lt;p>然后，当你使用选择器注册工作负载的属性时，将这些属性与提供给服务器的信息进行比较。&lt;/p>
&lt;p>这些类型的信息可能包括：&lt;/p>
&lt;ul>
&lt;li>底层操作系统如何调度进程。在基于 Unix 的系统上，这可能是用户 ID (uid)、组 ID (gid)、文件系统路径等。）&lt;/li>
&lt;li>进程是如何由 Kubernetes 等编排系统调度的。在这种情况下，工作负载可能由运行它的 Kubernetes 服务账户或命名空间来描述。&lt;/li>
&lt;/ul>
&lt;p>虽然代理和服务器都在节点证明中发挥作用，但只有代理参与工作负载证明。&lt;/p>
&lt;p>下图说明了工作负载证明的步骤：&lt;/p>
&lt;p>
&lt;figure id="figure-工作负载证明">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/kubernetes-handbook/workload-attestation.svg" alt="工作负载证明" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
工作负载证明
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h4 id="步骤摘要工作负载证明">步骤摘要：工作负载证明&lt;/h4>
&lt;ol>
&lt;li>工作负载调用工作负载 API 以请求 SVID。在 Unix 系统上，这被暴露为 Unix 域套接字。&lt;/li>
&lt;li>代理询问节点的内核以识别调用者的进程 ID。然后，它调用任何已配置的工作负载证明器插件，为它们提供工作负载的进程 ID。&lt;/li>
&lt;li>工作负载证明者使用进程 ID 来发现有关工作负载的其他信息，并根据需要查询相邻平台特定的组件，例如 Kubernetes kubelet。通常，这些组件也与代理驻留在同一节点上。&lt;/li>
&lt;li>证明者将发现的信息以选择器的形式返回给代理。&lt;/li>
&lt;li>代理通过将发现的选择器与注册条目进行比较来确定工作负载的身份，并将正确的缓存 SVID 返回给工作负载。&lt;/li>
&lt;/ol>
&lt;h4 id="工作负载证明者">工作负载证明者&lt;/h4>
&lt;p>SPIRE 包括适用于 Unix、Kubernetes 和 Docker 的工作负载证明器插件。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://spiffe.io/docs/latest/spire-about/spire-concepts/" target="_blank" rel="noopener">SPIRE Concepts - spiffe.io&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>spire-k8s-workload-registar</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/spire-k8s-workload-registar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/spire-k8s-workload-registar/</guid><description>&lt;hr>
&lt;h2 id="summary-本文介绍了如何在-kubernetes-中使用-spire-工作负载注册器包括工作负载注册器部署的方式注册模式等">weight: 49
title: SPIRE Kubernetes 工作负载注册器
date: &amp;ldquo;2022-06-08T16:00:00+08:00&amp;rdquo;
type: book
summary: 本文介绍了如何在 Kubernetes 中使用 SPIRE 工作负载注册器，包括工作负载注册器部署的方式，注册模式等。&lt;/h2>
&lt;p>SPIRE Kubernetes 工作负载注册器实现了一个 Kubernetes &lt;code>ValidatingAdmissionWebhook&lt;/code>，便于在 Kubernetes 内自动注册工作负载。&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;h3 id="命令行配置">命令行配置&lt;/h3>
&lt;p>注册器有以下命令行选项：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">标志&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">默认值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;code>-config&lt;/code>&lt;/td>
&lt;td style="text-align:left">磁盘上 HCL 配置文件的路径&lt;/td>
&lt;td style="text-align:left">&lt;code>k8s-workload-registrar.conf&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="hcl-配置">HCL 配置&lt;/h3>
&lt;p>配置文件是注册器所必需的。它包含 &lt;a href="https://github.com/hashicorp/hcl" target="_blank" rel="noopener">HCL&lt;/a> 编码的配置项。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">键&lt;/th>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">必需的？&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">默认&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;code>log_level&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">日志级别（&lt;code>panic&lt;/code>、 &lt;code>fatal&lt;/code>、 &lt;code>error&lt;/code>、 &lt;code>warn&lt;/code>、 &lt;code>warning&lt;/code>、 &lt;code>info&lt;/code>、 &lt;code>debug&lt;/code>、&lt;code>trace&lt;/code> 之一）&lt;/td>
&lt;td style="text-align:left">&lt;code>info&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>log_path&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">写入日志的磁盘路径&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>trust_domain&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">SPIRE 服务器的信任域&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>agent_socket_path&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">SPIRE 代理的 Unix 域套接字的路径。如果 &lt;code>server_address&lt;/code> 不是 unix 域套接字地址，则为必需。&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>server_address&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">SPIRE 服务器的地址。可以使用 &lt;code>unix:///path/to/socket&lt;/code> 指定本地套接字。这与代理套接字不同。&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>server_socket_path&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">SPIRE 服务器的 Unix 域套接字的路径，相当于指定带有 &lt;code>unix://&lt;/code> 前缀的 &lt;code>server_address&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>cluster&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">用于在其下注册节点 / 工作负载的逻辑集群。必须与 SPIRE SERVER PSAT 节点证明者配置相匹配。&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>pod_label&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">pod 标签，用于基于标签的工作负载注册&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>pod_annotation&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">pod 注解，用于基于注解的工作负载注册&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>mode&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">如何使用 &lt;code>webhook&lt;/code>、 &lt;code>reconcile&lt;/code> 或运行注册器 &lt;code>crd&lt;/code>。&lt;/td>
&lt;td style="text-align:left">&lt;code>webhook&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>disabled_namespaces&lt;/code>&lt;/td>
&lt;td style="text-align:left">[]string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">逗号分隔的命名空间列表，用于禁用自动 SVID 生成&lt;/td>
&lt;td style="text-align:left">&lt;code>kube-system&lt;/code>、 &lt;code>kube-public&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以下配置指令是针对 &lt;code>webhook&lt;/code> 模式的：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">键&lt;/th>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">必需的？&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">默认&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;code>addr&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">将 HTTPS 监听器绑定到的地址&lt;/td>
&lt;td style="text-align:left">&lt;code>:8443&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>cert_path&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">PEM 编码的服务器 TLS 证书的磁盘路径&lt;/td>
&lt;td style="text-align:left">&lt;code>cert.pem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>key_path&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">PEM 编码的服务器 TLS 密钥的磁盘路径&lt;/td>
&lt;td style="text-align:left">&lt;code>key.pem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>cacert_path&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">用于验证客户端（即 API 服务器）的 CA 证书的磁盘路径&lt;/td>
&lt;td style="text-align:left">&lt;code>cacert.pem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>insecure_skip_client_verification&lt;/code>&lt;/td>
&lt;td style="text-align:left">boolean&lt;/td>
&lt;td style="text-align:left">必需的&lt;/td>
&lt;td style="text-align:left">如果为 true，则跳过客户端证书验证（在这种情况下 &lt;code>cacert_path&lt;/code> 被忽略）。&lt;/td>
&lt;td style="text-align:left">&lt;code>false&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以下配置是针对 &lt;code>reconcile&lt;/code> 模式的：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">键&lt;/th>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">必需的？&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">默认&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;code>leader_election&lt;/code>&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">启用 / 禁用领导者选举。如果你有多个注册器副本正在运行，请启用&lt;/td>
&lt;td style="text-align:left">false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>leader_election_resource_lock&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">配置用于领导选举锁的资源类型&lt;/td>
&lt;td style="text-align:left">&lt;code>configmaps&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>metrics_addr&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">公开指标的地址，&lt;code>0&lt;/code> 用于禁用&lt;/td>
&lt;td style="text-align:left">&lt;code>:8080&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>controller_name&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">构成用于父 ID 的 spiffe ID 的一部分&lt;/td>
&lt;td style="text-align:left">&lt;code>spire-k8s-registrar&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>add_pod_dns_names&lt;/code>&lt;/td>
&lt;td style="text-align:left">bool&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">启用 / 禁用将 k8s DNS 名称添加到 pod SVID。&lt;/td>
&lt;td style="text-align:left">错误的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>cluster_dns_zone&lt;/code>&lt;/td>
&lt;td style="text-align:left">string&lt;/td>
&lt;td style="text-align:left">可选的&lt;/td>
&lt;td style="text-align:left">k8s 集群中用于服务的 DNS 区域。&lt;/td>
&lt;td style="text-align:left">&lt;code>cluster.local&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>关于 CRD 配置指令，见 &lt;a href="https://github.com/spiffe/spire/blob/main/support/k8s/k8s-workload-registrar/mode-crd/README.md#configuration" target="_blank" rel="noopener">CRD 模式配置&lt;/a>。&lt;/p>
&lt;h3 id="示例">示例&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">log_level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;debug&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">trust_domain&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;domain.test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">server_socket_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;/tmp/spire-server/private/api.sock&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">cluster&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;production&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="工作负载注册">工作负载注册&lt;/h2>
&lt;p>当在 webhook、reconcile 或 crd 模式下运行时，&lt;code>pod_controller=true&lt;/code> 的条目将被自动创建为 Pod。可用的工作负载注册模式包括：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>注册模式&lt;/th>
&lt;th>pod_label&lt;/th>
&lt;th>pod_annotation&lt;/th>
&lt;th>identity_template&lt;/th>
&lt;th>基于服务账户&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>webhook&lt;/code>&lt;/td>
&lt;td>由 pod_label 指定&lt;/td>
&lt;td>由 pod_annotation 指定&lt;/td>
&lt;td>&lt;em>不可用&lt;/em>&lt;/td>
&lt;td>服务账户&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>reconcile&lt;/code>&lt;/td>
&lt;td>由 pod_label 指定&lt;/td>
&lt;td>由 pod_annotation 指定&lt;/td>
&lt;td>&lt;em>不可用&lt;/em>&lt;/td>
&lt;td>服务账户&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>crd&lt;/code>&lt;/td>
&lt;td>由 pod_label 指定&lt;/td>
&lt;td>由 pod_annotation 指定&lt;/td>
&lt;td>由 identity_template 指定&lt;/td>
&lt;td>&lt;em>不可用&lt;/em>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果对 &lt;a href="#service-account-based-workload-registration">基于服务账户的 SPIFFE ID&lt;/a> &lt;code>webhook&lt;/code> 使用和 &lt;code>reconcile&lt;/code> 模式，请不要指定 &lt;code>pod_label&lt;/code> 或 &lt;code>pod_annotation&lt;/code>。如果你使用基于标签的 SPIFFE ID，请仅指定 &lt;code>pod_label&lt;/code>。如果你使用基于注解的 SPIFFE ID，请仅指定 &lt;code>pod_annotation&lt;/code>&lt;/p>
&lt;p>对于 &lt;code>crd&lt;/code> 模式，如果既不选择 &lt;code>pod_label&lt;/code> 也不选择 &lt;code>pod_annotation&lt;/code> 工作负载注册模式， &lt;code>identity_template&lt;/code> 则作为默认配置： &lt;code>ns/{{.Pod.Namespace}}/sa/{{.Pod.ServiceAccount}}&lt;/code>&lt;/p>
&lt;p>新创建的 SVID 可能需要几秒钟才能对工作负载可用。&lt;/p>
&lt;h3 id="联合条目注册">联合条目注册&lt;/h3>
&lt;p>pod 注解 &lt;code>spiffe.io/federatesWith&lt;/code> 可用于创建与其他信任域联合的 SPIFFE ID。&lt;/p>
&lt;p>要指定多个信任域，请用逗号分隔它们。&lt;/p>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">spiffe.io/federatesWith&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">example.com,example.io,example.ai&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="l">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="service-account-based-workload-registration">基于服务账户的工作负载注册&lt;/h3>
&lt;p>授予工作负载的 SPIFFE ID 源自：&lt;/p>
&lt;ol>
&lt;li>服务账户&lt;/li>
&lt;li>可配置的 pod 标签&lt;/li>
&lt;li>可配置的 pod 注解&lt;/li>
&lt;/ol>
&lt;p>服务账户派生的工作负载注册将服务账户映射到表单的 SPIFFE ID &lt;code>spiffe://&amp;lt;TRUSTDOMAIN&amp;gt;/ns/&amp;lt;NAMESPACE&amp;gt;/sa/&amp;lt;SERVICEACCOUNT&amp;gt;&lt;/code>。例如，如果一个 pod 使用命名空间中的服务账户 &lt;code>blog&lt;/code> 进入 &lt;code>production&lt;/code>，则将创建以下注册条目：&lt;/p>
&lt;pre tabindex="0">&lt;code>Entry ID : 200d8b19-8334-443d-9494-f65d0ad64eb5
SPIFFE ID : spiffe://example.org/ns/production/sa/blog
Parent ID : ...
TTL : default
Selector : k8s:ns:production
Selector : k8s:pod-name:example-workload-98b6b79fd-jnv5m
&lt;/code>&lt;/pre>&lt;h3 id="基于标签的工作负载注册">基于标签的工作负载注册&lt;/h3>
&lt;p>基于标签的工作负载注册将 pod 标签值映射到表单的 SPIFFE ID &lt;code>spiffe://&amp;lt;TRUSTDOMAIN&amp;gt;/&amp;lt;LABELVALUE&amp;gt;&lt;/code>。例如，如果注册器配置了 &lt;code>spire-workload&lt;/code> 标签，并且 pod 带有 &lt;code>spire-workload=example-workload&lt;/code>，则将创建以下注册条目：&lt;/p>
&lt;pre tabindex="0">&lt;code>Entry ID : 200d8b19-8334-443d-9494-f65d0ad64eb5
SPIFFE ID : spiffe://example.org/example-workload
Parent ID : ...
TTL : default
Selector : k8s:ns:production
Selector : k8s:pod-name:example-workload-98b6b79fd-jnv5m
&lt;/code>&lt;/pre>&lt;p>不包含 pod 标签的 pod 将被忽略。&lt;/p>
&lt;h3 id="基于注解的工作负载注册">基于注解的工作负载注册&lt;/h3>
&lt;p>基于注解的工作负载注册将 pod 注解值映射到表单的 SPIFFE ID &lt;code>spiffe://&amp;lt;TRUSTDOMAIN&amp;gt;/&amp;lt;ANNOTATIONVALUE&amp;gt;&lt;/code>。通过使用该模式，可以自由设置 SPIFFE ID 路径。例如，如果注册器配置了 &lt;code>spiffe.io/spiffe-id&lt;/code> 注解并且 pod 带有 &lt;code>spiffe.io/spiffe-id: production/example-workload&lt;/code>，则将创建以下注册条目：&lt;/p>
&lt;pre tabindex="0">&lt;code>Entry ID : 200d8b19-8334-443d-9494-f65d0ad64eb5
SPIFFE ID : spiffe://example.org/production/example-workload
Parent ID : ...
TTL : default
Selector : k8s:ns:production
Selector : k8s:pod-name:example-workload-98b6b79fd-jnv5m
&lt;/code>&lt;/pre>&lt;p>不包含 pod 注解的 pod 将被忽略。&lt;/p>
&lt;h3 id="基于身份模板的工作负载注册">基于身份模板的工作负载注册&lt;/h3>
&lt;p>这是特定于 &lt;code>crd&lt;/code> 模式的。请参阅 &lt;code>crd&lt;/code> 模式文档中的&lt;a href="https://github.com/spiffe/spire/blob/main/support/k8s/k8s-workload-registrar/mode-crd/README.md#identity-template-based-workload-registration" target="_blank" rel="noopener">基于身份模板的工作负载注册&lt;/a>。&lt;/p>
&lt;h2 id="部署">部署&lt;/h2>
&lt;p>注册器既可以作为独立 Deployment 部署，也可以作为 SPIRE 服务器 pod 中的容器部署。如果它是独立部署的，则需要手动创建与注册器部署相匹配的管理员注册条目。&lt;/p>
&lt;p>如果它被部署为 SPIRE 服务器 pod 中的容器，那么它会通过 Unix 域套接字与 SPIRE 服务器通信。它将需要访问包含套接字文件的共享卷。&lt;/p>
&lt;h3 id="协调模式配置">协调模式配置&lt;/h3>
&lt;p>要使用协调模式（Reconcile Mode），你需要创建适当的角色并将它们绑定到你打算运行控制器的 ServiceAccount。&lt;/p>
&lt;h3 id="crd-模式配置">CRD 模式配置&lt;/h3>
&lt;p>请参阅 &lt;a href="https://github.com/spiffe/spire/blob/main/support/k8s/k8s-workload-registrar/mode-crd/README.md#quick-start" target="_blank" rel="noopener">CRD Kubernetes Workload Registrar 快速入门&lt;/a>。&lt;/p>
&lt;h3 id="webhook-模式配置">Webhook 模式配置&lt;/h3>
&lt;p>注册器将需要访问其服务器密钥对和用于验证客户端的 CA 证书。&lt;/p>
&lt;p>设置验证准入控制器需要以下 K8s 对象：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Service&lt;/code> 指向 spire-server 容器中的注册端口&lt;/li>
&lt;li>&lt;code>ValidatingWebhookConfiguration&lt;/code> 将注册器配置为验证准入控制器&lt;/li>
&lt;/ul>
&lt;p>此外，除非你禁用客户端身份验证 ( &lt;code>insecure_skip_client_verification&lt;/code>)，否则你将需要：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Config&lt;/code> 注册器服务客户端的用户条目包含 API 服务器应用于向注册器进行身份验证的客户端证书 / 密钥。&lt;/li>
&lt;li>&lt;code>AdmissionConfiguration&lt;/code> 描述 API 服务器可以在哪里找到包含 &lt;code>Config&lt;/code>。该文件通过 &lt;code>--admission-control-config-file&lt;/code> 标志传递给 API 服务器。&lt;/li>
&lt;/ul>
&lt;h4 id="webhook-模式安全注意事项">Webhook 模式安全注意事项&lt;/h4>
&lt;p>注册器默认对客户端进行身份验证。这是注册器整体安全性的一个非常重要的方面，因为注册器可用于提供对 SPIRE 服务器 API 的间接访问，尽管范围有限。除非你完全了解风险，否则不建议跳过客户端验证（通过 &lt;code>insecure_skip_client_verification&lt;/code> 配置）。&lt;/p>
&lt;h4 id="从-webhook-迁移">从 webhook 迁移&lt;/h4>
&lt;p>需要移除 k8s &lt;code>ValidatingWebhookConfiguration&lt;/code>，否则 pod 可能无法准入。如果你使用默认配置，则可以通过以下方式完成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl validatingwebhookconfiguration delete k8s-workload-registrar-webhook
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dns-名称">DNS 名称&lt;/h2>
&lt;p>&lt;code>reconcile&lt;/code> 和 &lt;code>crd&lt;/code> 模式都提供了将 DNS 名称添加到 pod 的注册条目的能力。它们目前对应该添加哪些名称有不同的想法，&lt;code>reconcile&lt;/code> 添加可用于访问 pod 的所有可能名称（通过服务或直接），并将 &lt;code>crd&lt;/code> 模式限制为 &lt;code>&amp;lt;service&amp;gt;.&amp;lt;namespace&amp;gt;.svc&lt;/code> 。该功能默认为关闭 &lt;code>reconcile&lt;/code> 模式和打开 &lt;code>crd&lt;/code> 模式。&lt;/p>
&lt;div class="alert-warning-title">
&lt;p>注意&lt;/p>
&lt;/div>
&lt;div class="alert alert-warning">
已知某些软件会使用反向 DNS “验证” 客户端证书中提供的 DNS 和 IP SAN。不能保证 Kubernetes 客户端会从一个具有有效反向 DNS 的 IP 地址进行连接，该地址与这些 DNS 名称实现所创建的名称之一相匹配，在这种情况下验证会失败。如果你打算使用 X509-SVID 对此类服务的客户端进行身份验证，则需要禁用将 DNS 名称添加到条目中。众所周知，这会影响 etcd。
&lt;/div>
&lt;h2 id="模式之间的差异">模式之间的差异&lt;/h2>
&lt;p>&lt;code>webhook&lt;/code> 模式使用验证准入 Webhook 在准入时捕获 pod 创建 / 删除事件。它是注册器实现中的第一个，但存在以下问题：&lt;/p>
&lt;ul>
&lt;li>StatefulSet 的 add 和 delete 之间的竞争条件会经常导致 StatefulSet 没有条目；&lt;/li>
&lt;li>Webhook 的不可用要么必须完全阻止准入，要么你最终会得到没有条目的 pod；&lt;/li>
&lt;li>SPIRE 服务器错误必须完全阻止准入，否则你最终会得到没有条目的 pod；&lt;/li>
&lt;li>当 &lt;code>webhook/spire-server&lt;/code> 不可用时，它不会清理删除的 pod 的遗留条目；&lt;/li>
&lt;li>条目不是单个节点的父节点，所有 SVID 都被泛洪到集群中的所有代理，这严重限制了可扩展性。因此，强烈建议不要使用 &lt;code>webhook&lt;/code> 模式，但出于向后兼容的原因，它仍然是默认设置。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>reconcile&lt;/code> 模式和 &lt;code>crd&lt;/code> 模式都使用协调控制器而不是 webhook。&lt;code>reconcile&lt;/code> 模式和启用了 &lt;code>pod_controller&lt;/code> 的 &lt;code>crd&lt;/code> 模式具有与 webhook 类似的自动工作负载创建功能，但它们不会遭受相同的竞争条件，能够从注册器故障中恢复（并在之后清理），并且两者都还确保为 Pod 自动创建的条目仅限于适当的节点，以防止 SVID 泛滥。以这种方式使用时，&lt;code>reconcile&lt;/code> 创建新条目可能比 &lt;code>crd&lt;/code> 模式稍快，并且需要较少的配置。&lt;/p>
&lt;p>&lt;code>crd&lt;/code> 模式还提供了一个命名空间的 SpiffeID 自定义资源。这些资源供注册器内部使用，但也可以手动创建以允许创建任意 Spire 条目。如果你打算直接管理 SpiffeID 自定义资源，那么强烈建议你在运行控制器时启用 &lt;code>crd&lt;/code> 模式的 webhook。&lt;/p>
&lt;h3 id="平台支持">平台支持&lt;/h3>
&lt;p>该工具仅支持 UNIX 系统。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/spiffe/spire/blob/main/support/k8s/k8s-workload-registrar/README.md" target="_blank" rel="noopener">SPIRE Kubernetes Workload Registar - github.com&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>svid</title><link>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/svid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/k8s-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-jimmysong-kubernetes-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/6.%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/svid/</guid><description>&lt;hr>
&lt;h2 id="summary-本文介绍了为工作负载颁发-x509-svid-身份的详细步骤">weight: 49
title: SVID 身份颁发过程
date: &amp;lsquo;2022-05-21T00:00:00+08:00&amp;rsquo;
type: book
summary: 本文介绍了为工作负载颁发 X.509 SVID 身份的详细步骤。&lt;/h2>
&lt;p>本文介绍 SPIRE 如何向工作负载颁发身份的详细步骤，叙述了从代理在节点上启动到同一节点上的工作负载收到 X.509 SVID 形式的有效身份的全过程。请注意，JWT 格式的 SVID 的处理方式是不同的。为了简单演示的目的，工作负载在 AWS EC2 上运行。&lt;/p>
&lt;ol>
&lt;li>SPIRE 服务器启动。&lt;/li>
&lt;li>除非用户配置了 &lt;code>UpstreamAuthority&lt;/code> 插件，否则服务器会生成自签名证书（使用自己的私钥签名的证书）；服务器将使用此证书为该服务器信任域中的所有工作负载签署 SVID。&lt;/li>
&lt;li>如果是第一次启动，服务器会自动生成一个信任包（trust bundle），其内容存储在你指定的 sql 数据存储中 —— 在&lt;a href="https://github.com/spiffe/spire/blob/v1.3.0/doc/plugin_server_datastore_sql.md" target="_blank" rel="noopener">服务器插件：DataStore sql&lt;/a> 的 “内置插件” 部分中描述。&lt;/li>
&lt;li>服务器打开其注册 API，以允许你注册工作负载。&lt;/li>
&lt;li>工作负载节点上的 SPIRE 代理启动。&lt;/li>
&lt;li>代理执行节点证明，向服务器证明它正在运行的节点的身份。例如，在 AWS EC2 实例上运行时，它通常会通过向服务器提供 &lt;a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html" target="_blank" rel="noopener">AWS 实例身份文档&lt;/a>来执行节点证明。&lt;/li>
&lt;li>代理通过 TLS 连接向服务器提供此身份证明，该 TLS 连接通过代理配置的引导程序包进行身份验证。&lt;/li>
&lt;/ol>
&lt;div class="alert-note-title">
&lt;p>注意&lt;/p>
&lt;/div>
&lt;div class="alert alert-note">
此引导程序包是默认配置，应在生产中替换为客户提供的凭据。
&lt;/div>
&lt;ol start="8">
&lt;li>服务器调用 AWS API 来验证证明。&lt;/li>
&lt;li>AWS 承认该文件是有效的。&lt;/li>
&lt;li>服务器执行节点解析，以验证有关代理节点的其他属性并相应地更新其注册条目。例如，如果节点已使用 Microsoft Azure 托管服务标识 (MSI) 进行了证明。解析器从代理 SPIFFE ID 中提取租户 ID 和主体 ID，并使用各种 Azure 服务获取信息以构建一组额外的选择器。&lt;/li>
&lt;li>服务器向代理发出一个 SVID，代表代理本身的身份。&lt;/li>
&lt;li>代理联系服务器（使用其 SVID 作为其 TLS 客户端证书）以获取它被授权的注册条目。&lt;/li>
&lt;li>服务器使用代理的 SVID 对代理进行身份验证。代理依次完成 mTLS 握手并使用引导程序包对服务器进行身份验证。&lt;/li>
&lt;li>然后，服务器从其数据存储中获取所有&lt;a href="https://spiffe.io/docs/latest/spire-about/spire-concepts/#authorized-registration-entries" target="_blank" rel="noopener">授权的注册条目&lt;/a>并将它们发送给代理。&lt;/li>
&lt;li>然后，代理将工作负载 CSR 发送到服务器，服务器对其进行签名并作为工作负载 SVID 返回给客户端。客户端将它们放入缓存中。&lt;/li>
&lt;li>现在引导完成，代理开始监听 Workload API 套接字。&lt;/li>
&lt;li>工作负载调用工作负载 API 来请求 SVID。&lt;/li>
&lt;li>代理通过调用其工作负载证明器来启动工作负载证明过程，并向他们提供工作负载进程的进程 ID。&lt;/li>
&lt;li>证明器使用内核和用户空间调用来发现有关工作负载的其他信息。&lt;/li>
&lt;li>证明器以工作负载选择器的形式将发现的信息返回给代理。&lt;/li>
&lt;li>代理通过将发现的工作负载选择器与注册条目进行比较来确定工作负载的身份，并返回正确的 SVID（已在其缓存中）。&lt;/li>
&lt;/ol>
&lt;h2 id="授权注册条目">授权注册条目&lt;/h2>
&lt;p>服务器只向代理发送授权的注册条目。服务器执行以下操作来获取这些授权条目：&lt;/p>
&lt;ol>
&lt;li>查询数据库以查找将代理的 SPIFFE ID 列为其 “父 SPIFFE ID” 的任何注册条目。&lt;/li>
&lt;li>在数据库中查询特定代理与哪些附加属性相关联（“节点选择器”）。&lt;/li>
&lt;li>查询数据库以获取在任何这些节点选择器上声明选择的至少一个注册条目。&lt;/li>
&lt;li>递归地查询数据库中的任何注册条目，这些条目声明了迄今为止获得的任何条目作为它们的 “父 SPIFFE ID”（下降到所有子节点）。&lt;/li>
&lt;/ol>
&lt;p>另请参阅&lt;a href="https://spiffe.io/docs/latest/spire/using/registering/#mapping-workloads-to-multiple-nodes" target="_blank" rel="noopener">将工作负载映射到多个节点&lt;/a>。&lt;/p>
&lt;p>服务器将生成授权的注册条目集发送给代理。&lt;/p></description></item></channel></rss>