<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>1.数据系统基础 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/dataengineering-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/designing-data-intensive-application/1.%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link><atom:link href="https://ng-tech.icu/books/dataengineering-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/designing-data-intensive-application/1.%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml"/><description>1.数据系统基础</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>1.数据系统基础</title><link>https://ng-tech.icu/books/dataengineering-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/designing-data-intensive-application/1.%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link></image><item><title>第二章：数据模型与查询语言</title><link>https://ng-tech.icu/books/dataengineering-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/designing-data-intensive-application/1.%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/dataengineering-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/designing-data-intensive-application/1.%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</guid><description>&lt;h1 id="第二章数据模型与查询语言httpsvonnggithubioddiach2id第二章数据模型与查询语言">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e7%ac%ac%e4%ba%8c%e7%ab%a0%ef%bc%9a%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e4%b8%8e%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80" target="_blank" rel="noopener">第二章：数据模型与查询语言&lt;/a>&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/ch2.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>语言的边界就是思想的边界。&lt;/p>
&lt;p>—— 路德维奇・维特根斯坦，《逻辑哲学》（1922）&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>[TOC]&lt;/p>
&lt;p>数据模型可能是软件开发中最重要的部分了，因为它们的影响如此深远：不仅仅影响着软件的编写方式，而且影响着我们的 &lt;strong>解题思路&lt;/strong>。&lt;/p>
&lt;p>多数应用使用层层叠加的数据模型构建。对于每层数据模型的关键问题是：它是如何用低一层数据模型来 &lt;strong>表示&lt;/strong> 的？例如：&lt;/p>
&lt;ol>
&lt;li>作为一名应用开发人员，你观察现实世界（里面有人员、组织、货物、行为、资金流向、传感器等），并采用对象或数据结构，以及操控那些数据结构的 API 来进行建模。那些结构通常是特定于应用程序的。&lt;/li>
&lt;li>当要存储那些数据结构时，你可以利用通用数据模型来表示它们，如 JSON 或 XML 文档、关系数据库中的表或图模型。&lt;/li>
&lt;li>数据库软件的工程师选定如何以内存、磁盘或网络上的字节来表示 JSON / XML/ 关系 / 图数据。这类表示形式使数据有可能以各种方式来查询，搜索，操纵和处理。&lt;/li>
&lt;li>在更低的层次上，硬件工程师已经想出了使用电流、光脉冲、磁场或者其他东西来表示字节的方法。&lt;/li>
&lt;/ol>
&lt;p>一个复杂的应用程序可能会有更多的中间层次，比如基于 API 的 API，不过基本思想仍然是一样的：每个层都通过提供一个明确的数据模型来隐藏更低层次中的复杂性。这些抽象允许不同的人群有效地协作（例如数据库厂商的工程师和使用数据库的应用程序开发人员）。&lt;/p>
&lt;p>数据模型种类繁多，每个数据模型都带有如何使用的设想。有些用法很容易，有些则不支持如此；有些操作运行很快，有些则表现很差；有些数据转换非常自然，有些则很麻烦。&lt;/p>
&lt;p>掌握一个数据模型需要花费很多精力（想想关系数据建模有多少本书）。即便只使用一个数据模型，不用操心其内部工作机制，构建软件也是非常困难的。然而，因为数据模型对上层软件的功能（能做什么，不能做什么）有着至深的影响，所以选择一个适合的数据模型是非常重要的。&lt;/p>
&lt;p>在本章中，我们将研究一系列用于数据存储和查询的通用数据模型（前面列表中的第 2 点）。特别地，我们将比较关系模型，文档模型和少量基于图形的数据模型。我们还将查看各种查询语言并比较它们的用例。在 &lt;a href="https://vonng.github.io/ddia/#/ch3" target="_blank" rel="noopener">第三章&lt;/a> 中，我们将讨论存储引擎是如何工作的。也就是说，这些数据模型实际上是如何实现的（列表中的第 3 点）。&lt;/p>
&lt;h2 id="关系模型与文档模型httpsvonnggithubioddiach2id关系模型与文档模型">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%85%b3%e7%b3%bb%e6%a8%a1%e5%9e%8b%e4%b8%8e%e6%96%87%e6%a1%a3%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">关系模型与文档模型&lt;/a>&lt;/h2>
&lt;p>现在最著名的数据模型可能是 SQL。它基于 Edgar Codd 在 1970 年提出的关系模型【1】：数据被组织成 &lt;strong>关系&lt;/strong>（SQL 中称作 &lt;strong>表&lt;/strong>），其中每个关系是 &lt;strong>元组&lt;/strong>（SQL 中称作 &lt;strong>行&lt;/strong>) 的无序集合。&lt;/p>
&lt;p>关系模型曾是一个理论性的提议，当时很多人都怀疑是否能够有效实现它。然而到了 20 世纪 80 年代中期，关系数据库管理系统（RDBMSes）和 SQL 已成为大多数人们存储和查询某些常规结构的数据的首选工具。关系数据库已经持续称霸了大约 25~30 年 —— 这对计算机史来说是极其漫长的时间。&lt;/p>
&lt;p>关系数据库起源于商业数据处理，在 20 世纪 60 年代和 70 年代用大型计算机来执行。从今天的角度来看，那些用例显得很平常：典型的 &lt;strong>事务处理&lt;/strong>（将销售或银行交易，航空公司预订，库存管理信息记录在库）和 &lt;strong>批处理&lt;/strong>（客户发票，工资单，报告）。&lt;/p>
&lt;p>当时的其他数据库迫使应用程序开发人员必须考虑数据库内部的数据表示形式。关系模型致力于将上述实现细节隐藏在更简洁的接口之后。&lt;/p>
&lt;p>多年来，在数据存储和查询方面存在着许多相互竞争的方法。在 20 世纪 70 年代和 80 年代初，网状模型（network model）和层次模型（hierarchical model）曾是主要的选择，但关系模型（relational model）随后占据了主导地位。对象数据库在 20 世纪 80 年代末和 90 年代初来了又去。XML 数据库在二十一世纪初出现，但只有小众采用过。关系模型的每个竞争者都在其时代产生了大量的炒作，但从来没有持续【2】。&lt;/p>
&lt;p>随着电脑越来越强大和互联，它们开始用于日益多样化的目的。关系数据库非常成功地被推广到业务数据处理的原始范围之外更为广泛的用例上。你今天在网上看到的大部分内容依旧是由关系数据库来提供支持，无论是在线发布，讨论，社交网络，电子商务，游戏，软件即服务生产力应用程序等等内容。&lt;/p>
&lt;h3 id="nosql-的诞生httpsvonnggithubioddiach2idnosql-的诞生">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=nosql-%e7%9a%84%e8%af%9e%e7%94%9f" target="_blank" rel="noopener">NoSQL 的诞生&lt;/a>&lt;/h3>
&lt;p>现在 - 2010 年代，NoSQL 开始了最新一轮尝试，试图推翻关系模型的统治地位。“NoSQL” 这个名字让人遗憾，因为实际上它并没有涉及到任何特定的技术。最初它只是作为一个醒目的 Twitter 标签，用在 2009 年一个关于分布式，非关系数据库上的开源聚会上。无论如何，这个术语触动了某些神经，并迅速在网络创业社区内外传播开来。好些有趣的数据库系统现在都与 &lt;em>#NoSQL&lt;/em> 标签相关联，并且 NoSQL 被追溯性地重新解释为 &lt;strong>不仅是 SQL（Not Only SQL）&lt;/strong> 【4】。&lt;/p>
&lt;p>采用 NoSQL 数据库的背后有几个驱动因素，其中包括：&lt;/p>
&lt;ul>
&lt;li>需要比关系数据库更好的可伸缩性，包括非常大的数据集或非常高的写入吞吐量&lt;/li>
&lt;li>相比商业数据库产品，免费和开源软件更受偏爱&lt;/li>
&lt;li>关系模型不能很好地支持一些特殊的查询操作&lt;/li>
&lt;li>受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型【5】&lt;/li>
&lt;/ul>
&lt;p>不同的应用程序有不同的需求，一个用例的最佳技术选择可能不同于另一个用例的最佳技术选择。因此，在可预见的未来，关系数据库似乎可能会继续与各种非关系数据库一起使用 - 这种想法有时也被称为 &lt;strong>混合持久化（polyglot persistence）&lt;/strong>。&lt;/p>
&lt;h3 id="对象关系不匹配httpsvonnggithubioddiach2id对象关系不匹配">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%af%b9%e8%b1%a1%e5%85%b3%e7%b3%bb%e4%b8%8d%e5%8c%b9%e9%85%8d" target="_blank" rel="noopener">对象关系不匹配&lt;/a>&lt;/h3>
&lt;p>目前大多数应用程序开发都使用面向对象的编程语言来开发，这导致了对 SQL 数据模型的普遍批评：如果数据存储在关系表中，那么需要一个笨拙的转换层，处于应用程序代码中的对象和表，行，列的数据库模型之间。模型之间的不连贯有时被称为 &lt;strong>阻抗不匹配（impedance mismatch）&lt;/strong>&lt;a href="https://vonng.github.io/ddia/#/%e4%b8%80%e4%b8%aa%e4%bb%8e%e7%94%b5%e5%ad%90%e5%ad%a6%e5%80%9f%e7%94%a8%e7%9a%84%e6%9c%af%e8%af%ad%e3%80%82%e6%af%8f%e4%b8%aa%e7%94%b5%e8%b7%af%e7%9a%84%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%ba%e9%83%bd%e6%9c%89%e4%b8%80%e5%ae%9a%e7%9a%84%e9%98%bb%e6%8a%97%ef%bc%88%e4%ba%a4%e6%b5%81%e7%94%b5%e9%98%bb%ef%bc%89%e3%80%82%e5%bd%93%e4%bd%a0%e5%b0%86%e4%b8%80%e4%b8%aa%e7%94%b5%e8%b7%af%e7%9a%84%e8%be%93%e5%87%ba%e8%bf%9e%e6%8e%a5%e5%88%b0%e5%8f%a6%e4%b8%80%e4%b8%aa%e7%94%b5%e8%b7%af%e7%9a%84%e8%be%93%e5%85%a5%e6%97%b6%ef%bc%8c%e5%a6%82%e6%9e%9c%e4%b8%a4%e4%b8%aa%e7%94%b5%e8%b7%af%e7%9a%84%e8%be%93%e5%87%ba%e5%92%8c%e8%be%93%e5%85%a5%e9%98%bb%e6%8a%97%e5%8c%b9%e9%85%8d%ef%bc%8c%e5%88%99%e8%bf%9e%e6%8e%a5%e4%b8%8a%e7%9a%84%e5%8a%9f%e7%8e%87%e4%bc%a0%e8%be%93%e5%b0%86%e8%a2%ab%e6%9c%80%e5%a4%a7%e5%8c%96%e3%80%82%e9%98%bb%e6%8a%97%e4%b8%8d%e5%8c%b9%e9%85%8d%e4%bc%9a%e5%af%bc%e8%87%b4%e4%bf%a1%e5%8f%b7%e5%8f%8d%e5%b0%84%e5%8f%8a%e5%85%b6%e4%bb%96%e9%97%ae%e9%a2%98%e3%80%82" target="_blank" rel="noopener">^i&lt;/a>。&lt;/p>
&lt;p>像 ActiveRecord 和 Hibernate 这样的 &lt;strong>对象关系映射（ORM object-relational mapping）&lt;/strong> 框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig2-1.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 2-1 使用关系型模式来表示领英简介&lt;/strong>&lt;/p>
&lt;p>例如，&lt;a href="https://vonng.github.io/ddia/#/img/fig2-1.png" target="_blank" rel="noopener">图 2-1&lt;/a> 展示了如何在关系模式中表示简历（一个 LinkedIn 简介）。整个简介可以通过一个唯一的标识符 &lt;code>user_id&lt;/code> 来标识。像 &lt;code>first_name&lt;/code> 和 &lt;code>last_name&lt;/code> 这样的字段每个用户只出现一次，所以可以在 User 表上将其建模为列。但是，大多数人在职业生涯中拥有多于一份的工作，人们可能有不同样的教育阶段和任意数量的联系信息。从用户到这些项目之间存在一对多的关系，可以用多种方式来表示：&lt;/p>
&lt;ul>
&lt;li>传统 SQL 模型（SQL：1999 之前）中，最常见的规范化表示形式是将职位，教育和联系信息放在单独的表中，对 User 表提供外键引用，如 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-1.png" target="_blank" rel="noopener">图 2-1&lt;/a> 所示。&lt;/li>
&lt;li>后续的 SQL 标准增加了对结构化数据类型和 XML 数据的支持；这允许将多值数据存储在单行内，并支持在这些文档内查询和索引。这些功能在 Oracle，IBM DB2，MS SQL Server 和 PostgreSQL 中都有不同程度的支持【6,7】。JSON 数据类型也得到多个数据库的支持，包括 IBM DB2，MySQL 和 PostgreSQL 【8】。&lt;/li>
&lt;li>第三种选择是将职业，教育和联系信息编码为 JSON 或 XML 文档，将其存储在数据库的文本列中，并让应用程序解析其结构和内容。这种配置下，通常不能使用数据库来查询该编码列中的值。&lt;/li>
&lt;/ul>
&lt;p>对于一个像简历这样自包含文档的数据结构而言，JSON 表示是非常合适的：请参阅 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-1&lt;/a>。JSON 比 XML 更简单。面向文档的数据库（如 MongoDB 【9】，RethinkDB 【10】，CouchDB 【11】和 Espresso【12】）支持这种数据模型。&lt;/p>
&lt;p>&lt;strong>例 2-1. 用 JSON 文档表示一个 LinkedIn 简介&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;user_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">251&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;first_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;last_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Gates&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;summary&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair of the Bill &amp;amp; Melinda Gates... Active blogger.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;region_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;us:91&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;industry_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">131&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;photo_url&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/p/7/000/253/05b/308dd6e.jpg&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;positions&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-chair&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bill &amp;amp; Melinda Gates Foundation&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;job_title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Co-founder, Chairman&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;organization&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Microsoft&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;education&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Harvard University&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1973&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1975&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;school_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Lakeside School, Seattle&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;end&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;contact_info&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;blog&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://thegatesnotes.com&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;twitter&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://twitter.com/BillGates&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有一些开发人员认为 JSON 模型减少了应用程序代码和存储层之间的阻抗不匹配。不过，正如我们将在 &lt;a href="https://vonng.github.io/ddia/#/ch4" target="_blank" rel="noopener">第四章&lt;/a> 中看到的那样，JSON 作为数据编码格式也存在问题。缺乏一个模式往往被认为是一个优势；我们将在 “&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%96%87%e6%a1%a3%e6%a8%a1%e5%9e%8b%e4%b8%ad%e7%9a%84%e6%a8%a1%e5%bc%8f%e7%81%b5%e6%b4%bb%e6%80%a7" target="_blank" rel="noopener">文档模型中的模式灵活性&lt;/a>” 中讨论这个问题。&lt;/p>
&lt;p>JSON 表示比 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-1.png" target="_blank" rel="noopener">图 2-1&lt;/a> 中的多表模式具有更好的 &lt;strong>局部性（locality）&lt;/strong>。如果在前面的关系型示例中获取简介，那需要执行多个查询（通过 &lt;code>user_id&lt;/code> 查询每个表），或者在 User 表与其下属表之间混乱地执行多路连接。而在 JSON 表示中，所有相关信息都在同一个地方，一个查询就足够了。&lt;/p>
&lt;p>从用户简介文件到用户职位，教育历史和联系信息，这种一对多关系隐含了数据中的一个树状结构，而 JSON 表示使得这个树状结构变得明确（见 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-2.png" target="_blank" rel="noopener">图 2-2&lt;/a>）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig2-2.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 2-2 一对多关系构建了一个树结构&lt;/strong>&lt;/p>
&lt;h3 id="多对一和多对多的关系httpsvonnggithubioddiach2id多对一和多对多的关系">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%a4%9a%e5%af%b9%e4%b8%80%e5%92%8c%e5%a4%9a%e5%af%b9%e5%a4%9a%e7%9a%84%e5%85%b3%e7%b3%bb" target="_blank" rel="noopener">多对一和多对多的关系&lt;/a>&lt;/h3>
&lt;p>在上一节的 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-1&lt;/a> 中，&lt;code>region_id&lt;/code> 和 &lt;code>industry_id&lt;/code> 是以 ID，而不是纯字符串 “Greater Seattle Area” 和 “Philanthropy” 的形式给出的。为什么？&lt;/p>
&lt;p>如果用户界面用一个自由文本字段来输入区域和行业，那么将他们存储为纯文本字符串是合理的。另一方式是给出地理区域和行业的标准化的列表，并让用户从下拉列表或自动填充器中进行选择，其优势如下：&lt;/p>
&lt;ul>
&lt;li>各个简介之间样式和拼写统一&lt;/li>
&lt;li>避免歧义（例如，如果有几个同名的城市）&lt;/li>
&lt;li>易于更新 —— 名称只存储在一个地方，如果需要更改（例如，由于政治事件而改变城市名称），很容易进行全面更新。&lt;/li>
&lt;li>本地化支持 —— 当网站翻译成其他语言时，标准化的列表可以被本地化，使得地区和行业可以使用用户的语言来显示&lt;/li>
&lt;li>更好的搜索 —— 例如，搜索华盛顿州的慈善家就会匹配这份简介，因为地区列表可以编码记录西雅图在华盛顿这一事实（从 “Greater Seattle Area” 这个字符串中看不出来）&lt;/li>
&lt;/ul>
&lt;p>存储 ID 还是文本字符串，这是个 &lt;strong>副本（duplication）&lt;/strong> 问题。当使用 ID 时，对人类有意义的信息（比如单词：Philanthropy）只存储在一处，所有引用它的地方使用 ID（ID 只在数据库中有意义）。当直接存储文本时，对人类有意义的信息会复制在每处使用记录中。&lt;/p>
&lt;p>使用 ID 的好处是，ID 对人类没有任何意义，因而永远不需要改变：ID 可以保持不变，即使它标识的信息发生变化。任何对人类有意义的东西都可能需要在将来某个时候改变 —— 如果这些信息被复制，所有的冗余副本都需要更新。这会导致写入开销，也存在不一致的风险（一些副本被更新了，还有些副本没有被更新）。去除此类重复是数据库 &lt;strong>规范化（normalization）&lt;/strong> 的关键思想。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;blockquote>
&lt;p>数据库管理员和开发人员喜欢争论规范化和非规范化，让我们暂时保留判断吧。在本书的 &lt;a href="https://vonng.github.io/ddia/#/part-iii" target="_blank" rel="noopener">第三部分&lt;/a>，我们将回到这个话题，探讨系统的方法用以处理缓存，非规范化和衍生数据。&lt;/p>
&lt;/blockquote>
&lt;p>不幸的是，对这些数据进行规范化需要多对一的关系（许多人生活在一个特定的地区，许多人在一个特定的行业工作），这与文档模型不太吻合。在关系数据库中，通过 ID 来引用其他表中的行是正常的，因为连接很容易。在文档数据库中，一对多树结构没有必要用连接，对连接的支持通常很弱 &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>如果数据库本身不支持连接，则必须在应用程序代码中通过对数据库进行多个查询来模拟连接。（在这种情况中，地区和行业的列表可能很小，改动很少，应用程序可以简单地将其保存在内存中。不过，执行连接的工作从数据库被转移到应用程序代码上。&lt;/p>
&lt;p>此外，即便应用程序的最初版本适合无连接的文档模型，随着功能添加到应用程序中，数据会变得更加互联。例如，考虑一下对简历例子进行的一些修改：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>组织和学校作为实体&lt;/p>
&lt;p>在前面的描述中，&lt;code>organization&lt;/code>（用户工作的公司）和 &lt;code>school_name&lt;/code>（他们学习的地方）只是字符串。也许他们应该是对实体的引用呢？然后，每个组织、学校或大学都可以拥有自己的网页（标识，新闻提要等）。每个简历可以链接到它所提到的组织和学校，并且包括他们的图标和其他信息（请参阅 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-3.png" target="_blank" rel="noopener">图 2-3&lt;/a>，来自 LinkedIn 的一个例子）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>推荐&lt;/p>
&lt;p>假设你想添加一个新的功能：一个用户可以为另一个用户写一个推荐。在用户的简历上显示推荐，并附上推荐用户的姓名和照片。如果推荐人更新他们的照片，那他们写的任何推荐都需要显示新的照片。因此，推荐应该拥有作者个人简介的引用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig2-3.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 2-3 公司名不仅是字符串，还是一个指向公司实体的链接（LinkedIn 截图）&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://vonng.github.io/ddia/#/img/fig2-4.png" target="_blank" rel="noopener">图 2-4&lt;/a> 阐明了这些新功能需要如何使用多对多关系。每个虚线矩形内的数据可以分组成一个文档，但是对单位，学校和其他用户的引用需要表示成引用，并且在查询时需要连接。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig2-4.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 2-4 使用多对多关系扩展简历&lt;/strong>&lt;/p>
&lt;h3 id="文档数据库是否在重蹈覆辙httpsvonnggithubioddiach2id文档数据库是否在重蹈覆辙">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%96%87%e6%a1%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e6%98%af%e5%90%a6%e5%9c%a8%e9%87%8d%e8%b9%88%e8%a6%86%e8%be%99%ef%bc%9f" target="_blank" rel="noopener">文档数据库是否在重蹈覆辙？&lt;/a>&lt;/h3>
&lt;p>在多对多的关系和连接已常规用在关系数据库时，文档数据库和 NoSQL 重启了辩论：如何以最佳方式在数据库中表示多对多关系。那场辩论可比 NoSQL 古老得多，事实上，最早可以追溯到计算机化数据库系统。&lt;/p>
&lt;p>20 世纪 70 年代最受欢迎的业务数据处理数据库是 IBM 的信息管理系统（IMS），最初是为了阿波罗太空计划的库存管理而开发的，并于 1968 年有了首次商业发布【13】。目前它仍在使用和维护，运行在 IBM 大型机的 OS/390 上【14】。&lt;/p>
&lt;p>IMS 的设计中使用了一个相当简单的数据模型，称为 &lt;strong>层次模型（hierarchical model）&lt;/strong>，它与文档数据库使用的 JSON 模型有一些惊人的相似之处【2】。它将所有数据表示为嵌套在记录中的记录树，这很像 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-2.png" target="_blank" rel="noopener">图 2-2&lt;/a> 的 JSON 结构。&lt;/p>
&lt;p>同文档数据库一样，IMS 能良好处理一对多的关系，但是很难应对多对多的关系，并且不支持连接。开发人员必须决定是否复制（非规范化）数据或手动解决从一个记录到另一个记录的引用。这些二十世纪六七十年代的问题与现在开发人员遇到的文档数据库问题非常相似【15】。&lt;/p>
&lt;p>那时人们提出了各种不同的解决方案来解决层次模型的局限性。其中最突出的两个是 &lt;strong>关系模型&lt;/strong>（relational model，它变成了 SQL，并统治了世界）和 &lt;strong>网状模型&lt;/strong>（network model，最初很受关注，但最终变得冷门）。这两个阵营之间的 “大辩论” 在 70 年代持续了很久时间【2】。&lt;/p>
&lt;p>那两个模式解决的问题与当前的问题相关，因此值得简要回顾一下那场辩论。&lt;/p>
&lt;h4 id="网状模型httpsvonnggithubioddiach2id网状模型">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e7%bd%91%e7%8a%b6%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">网状模型&lt;/a>&lt;/h4>
&lt;p>网状模型由一个称为数据系统语言会议（CODASYL）的委员会进行了标准化，并被数个不同的数据库厂商实现；它也被称为 CODASYL 模型【16】。&lt;/p>
&lt;p>CODASYL 模型是层次模型的推广。在层次模型的树结构中，每条记录只有一个父节点；在网络模式中，每条记录可能有多个父节点。例如，“Greater Seattle Area” 地区可能是一条记录，每个居住在该地区的用户都可以与之相关联。这允许对多对一和多对多的关系进行建模。&lt;/p>
&lt;p>网状模型中记录之间的链接不是外键，而更像编程语言中的指针（同时仍然存储在磁盘上）。访问记录的唯一方法是跟随从根记录起沿这些链路所形成的路径。这被称为 &lt;strong>访问路径（access path）&lt;/strong>。&lt;/p>
&lt;p>最简单的情况下，访问路径类似遍历链表：从列表头开始，每次查看一条记录，直到找到所需的记录。但在多对多关系的情况中，数条不同的路径可以到达相同的记录，网状模型的程序员必须跟踪这些不同的访问路径。&lt;/p>
&lt;p>CODASYL 中的查询是通过利用遍历记录列和跟随访问路径表在数据库中移动游标来执行的。如果记录有多个父结点（即多个来自其他记录的传入指针），则应用程序代码必须跟踪所有的各种关系。甚至 CODASYL 委员会成员也承认，这就像在 n 维数据空间中进行导航【17】。&lt;/p>
&lt;p>尽管手动选择访问路径能够最有效地利用 20 世纪 70 年代非常有限的硬件功能（如磁带驱动器，其搜索速度非常慢），但这使得查询和更新数据库的代码变得复杂不灵活。无论是分层还是网状模型，如果你没有所需数据的路径，就会陷入困境。你可以改变访问路径，但是必须浏览大量手写数据库查询代码，并重写来处理新的访问路径。更改应用程序的数据模型是很难的。&lt;/p>
&lt;h4 id="关系模型httpsvonnggithubioddiach2id关系模型">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%85%b3%e7%b3%bb%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">关系模型&lt;/a>&lt;/h4>
&lt;p>相比之下，关系模型做的就是将所有的数据放在光天化日之下：一个 &lt;strong>关系（表）&lt;/strong> 只是一个 &lt;strong>元组（行）&lt;/strong> 的集合，仅此而已。如果你想读取数据，它没有迷宫似的嵌套结构，也没有复杂的访问路径。你可以选中符合任意条件的行，读取表中的任何或所有行。你可以通过指定某些列作为匹配关键字来读取特定行。你可以在任何表中插入一个新的行，而不必担心与其他表的外键关系 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>在关系数据库中，查询优化器自动决定查询的哪些部分以哪个顺序执行，以及使用哪些索引。这些选择实际上是 “访问路径”，但最大的区别在于它们是由查询优化器自动生成的，而不是由程序员生成，所以我们很少需要考虑它们。&lt;/p>
&lt;p>如果想按新的方式查询数据，你可以声明一个新的索引，查询会自动使用最合适的那些索引。无需更改查询来利用新的索引（请参阅 “&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%95%b0%e6%8d%ae%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80" target="_blank" rel="noopener">数据查询语言&lt;/a>”）。关系模型因此使添加应用程序新功能变得更加容易。&lt;/p>
&lt;p>关系数据库的查询优化器是复杂的，已耗费了多年的研究和开发精力【18】。关系模型的一个关键洞察是：只需构建一次查询优化器，随后使用该数据库的所有应用程序都可以从中受益。如果你没有查询优化器的话，那么为特定查询手动编写访问路径比编写通用优化器更容易 —— 不过从长期看通用解决方案更好。&lt;/p>
&lt;h4 id="与文档数据库相比httpsvonnggithubioddiach2id与文档数据库相比">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e4%b8%8e%e6%96%87%e6%a1%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9b%b8%e6%af%94" target="_blank" rel="noopener">与文档数据库相比&lt;/a>&lt;/h4>
&lt;p>在一个方面，文档数据库还原为层次模型：在其父记录中存储嵌套记录（&lt;a href="https://vonng.github.io/ddia/#/img/fig2-1.png" target="_blank" rel="noopener">图 2-1&lt;/a> 中的一对多关系，如 &lt;code>positions&lt;/code>，&lt;code>education&lt;/code> 和 &lt;code>contact_info&lt;/code>），而不是在单独的表中。&lt;/p>
&lt;p>但是，在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同：在这两种情况下，相关项目都被一个唯一的标识符引用，这个标识符在关系模型中被称为 &lt;strong>外键&lt;/strong>，在文档模型中称为 &lt;strong>文档引用&lt;/strong>【9】。该标识符在读取时通过连接或后续查询来解析。迄今为止，文档数据库没有走 CODASYL 的老路。&lt;/p>
&lt;h3 id="关系型数据库与文档数据库在今日的对比httpsvonnggithubioddiach2id关系型数据库与文档数据库在今日的对比">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%8e%e6%96%87%e6%a1%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9c%a8%e4%bb%8a%e6%97%a5%e7%9a%84%e5%af%b9%e6%af%94" target="_blank" rel="noopener">关系型数据库与文档数据库在今日的对比&lt;/a>&lt;/h3>
&lt;p>将关系数据库与文档数据库进行比较时，可以考虑许多方面的差异，包括它们的容错属性（请参阅 &lt;a href="https://vonng.github.io/ddia/#/ch5" target="_blank" rel="noopener">第五章&lt;/a>）和处理并发性（请参阅 &lt;a href="https://vonng.github.io/ddia/#/ch7" target="_blank" rel="noopener">第七章&lt;/a>）。本章将只关注数据模型中的差异。&lt;/p>
&lt;p>支持文档数据模型的主要论据是架构灵活性，因局部性而拥有更好的性能，以及对于某些应用程序而言更接近于应用程序使用的数据结构。关系模型通过为连接提供更好的支持以及支持多对一和多对多的关系来反击。&lt;/p>
&lt;h4 id="哪种数据模型更有助于简化应用代码httpsvonnggithubioddiach2id哪种数据模型更有助于简化应用代码">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%93%aa%e7%a7%8d%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e6%9b%b4%e6%9c%89%e5%8a%a9%e4%ba%8e%e7%ae%80%e5%8c%96%e5%ba%94%e7%94%a8%e4%bb%a3%e7%a0%81%ef%bc%9f" target="_blank" rel="noopener">哪种数据模型更有助于简化应用代码？&lt;/a>&lt;/h4>
&lt;p>如果应用程序中的数据具有类似文档的结构（即，一对多关系树，通常一次性加载整个树），那么使用文档模型可能是一个好主意。将类似文档的结构分解成多个表（如 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-1.png" target="_blank" rel="noopener">图 2-1&lt;/a> 中的 &lt;code>positions&lt;/code>、&lt;code>education&lt;/code> 和 &lt;code>contact_info&lt;/code>）的关系技术可能导致繁琐的模式和不必要的复杂的应用程序代码。&lt;/p>
&lt;p>文档模型有一定的局限性：例如，不能直接引用文档中的嵌套的项目，而是需要说 “用户 251 的位置列表中的第二项”（很像层次模型中的访问路径）。但是，只要文件嵌套不太深，这通常不是问题。&lt;/p>
&lt;p>文档数据库对连接的糟糕支持可能是个问题，也可能不是问题，这取决于应用程序。例如，如果某分析型应用程序使用一个文档数据库来记录何时何地发生了何事，那么多对多关系可能永远也用不上。【19】。&lt;/p>
&lt;p>但如果你的应用程序确实会用到多对多关系，那么文档模型就没有那么诱人了。尽管可以通过反规范化来消除对连接的需求，但这需要应用程序代码来做额外的工作以确保数据一致性。尽管应用程序代码可以通过向数据库发出多个请求的方式来模拟连接，但这也将复杂性转移到应用程序中，而且通常也会比由数据库内的专用代码更慢。在这种情况下，使用文档模型可能会导致更复杂的应用代码与更差的性能【15】。&lt;/p>
&lt;p>我们没有办法说哪种数据模型更有助于简化应用代码，因为它取决于数据项之间的关系种类。对高度关联的数据而言，文档模型是极其糟糕的，关系模型是可以接受的，而选用图形模型（请参阅 “&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%9b%be%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">图数据模型&lt;/a>”）是最自然的。&lt;/p>
&lt;h4 id="文档模型中的模式灵活性httpsvonnggithubioddiach2id文档模型中的模式灵活性">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%96%87%e6%a1%a3%e6%a8%a1%e5%9e%8b%e4%b8%ad%e7%9a%84%e6%a8%a1%e5%bc%8f%e7%81%b5%e6%b4%bb%e6%80%a7" target="_blank" rel="noopener">文档模型中的模式灵活性&lt;/a>&lt;/h4>
&lt;p>大多数文档数据库以及关系数据库中的 JSON 支持都不会强制文档中的数据采用何种模式。关系数据库的 XML 支持通常带有可选的模式验证。没有模式意味着可以将任意的键和值添加到文档中，并且当读取时，客户端无法保证文档可能包含的字段。&lt;/p>
&lt;p>文档数据库有时称为 &lt;strong>无模式（schemaless）&lt;/strong>，但这具有误导性，因为读取数据的代码通常假定某种结构 —— 即存在隐式模式，但不由数据库强制执行【20】。一个更精确的术语是 &lt;strong>读时模式&lt;/strong>（即 schema-on-read，数据的结构是隐含的，只有在数据被读取时才被解释），相应的是 &lt;strong>写时模式&lt;/strong>（即 schema-on-write，传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）【21】。&lt;/p>
&lt;p>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大的争议性一样【22】，数据库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案。&lt;/p>
&lt;p>在应用程序想要改变其数据格式的情况下，这些方法之间的区别尤其明显。例如，假设你把每个用户的全名存储在一个字段中，而现在想分别存储名字和姓氏【23】。在文档数据库中，只需开始写入具有新字段的新文档，并在应用程序中使用代码来处理读取旧文档的情况。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">user&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">first_name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Documents written before Dec 8, 2013 don&amp;#39;t have first_name
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">first_name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另一方面，在 “静态类型” 数据库模式中，通常会执行以下 &lt;strong>迁移（migration）&lt;/strong> 操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLUMN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">split_part&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- PostgreSQL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">substring_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">-- MySQL
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行 &lt;code>ALTER TABLE&lt;/code> 语句。MySQL 是一个值得注意的例外，它执行 &lt;code>ALTER TABLE&lt;/code> 时会复制整个表，这可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机时间，尽管存在各种工具来解决这个限制【24,25,26】。&lt;/p>
&lt;p>大型表上运行 &lt;code>UPDATE&lt;/code> 语句在任何数据库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程序可以将 &lt;code>first_name&lt;/code> 设置为默认值 &lt;code>NULL&lt;/code>，并在读取时再填充，就像使用文档数据库一样。&lt;/p>
&lt;p>当由于某种原因（例如，数据是异构的）集合中的项目并不都具有相同的结构时，读时模式更具优势。例如，如果：&lt;/p>
&lt;ul>
&lt;li>存在许多不同类型的对象，将每种类型的对象放在自己的表中是不现实的。&lt;/li>
&lt;li>数据的结构由外部系统决定。你无法控制外部系统且它随时可能变化。&lt;/li>
&lt;/ul>
&lt;p>在上述情况下，模式的坏处远大于它的帮助，无模式文档可能是一个更加自然的数据模型。但是，要是所有记录都具有相同的结构，那么模式是记录并强制这种结构的有效机制。第四章将更详细地讨论模式和模式演化。&lt;/p>
&lt;h4 id="查询的数据局部性httpsvonnggithubioddiach2id查询的数据局部性">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%9f%a5%e8%af%a2%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b1%80%e9%83%a8%e6%80%a7" target="_blank" rel="noopener">查询的数据局部性&lt;/a>&lt;/h4>
&lt;p>文档通常以单个连续字符串形式进行存储，编码为 JSON、XML 或其二进制变体（如 MongoDB 的 BSON）。如果应用程序经常需要访问整个文档（例如，将其渲染至网页），那么存储局部性会带来性能优势。如果将数据分割到多个表中（如 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-1.png" target="_blank" rel="noopener">图 2-1&lt;/a> 所示），则需要进行多次索引查找才能将其全部检索出来，这可能需要更多的磁盘查找并花费更多的时间。&lt;/p>
&lt;p>局部性仅仅适用于同时需要文档绝大部分内容的情况。数据库通常需要加载整个文档，即使只访问其中的一小部分，这对于大型文档来说是很浪费的。更新文档时，通常需要整个重写。只有不改变文档大小的修改才可以容易地原地执行。因此，通常建议保持相对小的文档，并避免增加文档大小的写入【9】。这些性能限制大大减少了文档数据库的实用场景。&lt;/p>
&lt;p>值得指出的是，为了局部性而分组集合相关数据的想法并不局限于文档模型。例如，Google 的 Spanner 数据库在关系数据模型中提供了同样的局部性属性，允许模式声明一个表的行应该交错（嵌套）在父表内【27】。Oracle 类似地允许使用一个称为 &lt;strong>多表索引集群表（multi-table index cluster tables）&lt;/strong> 的类似特性【28】。Bigtable 数据模型（用于 Cassandra 和 HBase）中的 &lt;strong>列族（column-family）&lt;/strong> 概念与管理局部性的目的类似【29】。&lt;/p>
&lt;p>在 &lt;a href="https://vonng.github.io/ddia/#/ch3" target="_blank" rel="noopener">第三章&lt;/a> 将还会看到更多关于局部性的内容。&lt;/p>
&lt;h4 id="文档和关系数据库的融合httpsvonnggithubioddiach2id文档和关系数据库的融合">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%96%87%e6%a1%a3%e5%92%8c%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%9e%8d%e5%90%88" target="_blank" rel="noopener">文档和关系数据库的融合&lt;/a>&lt;/h4>
&lt;p>自 2000 年代中期以来，大多数关系数据库系统（MySQL 除外）都已支持 XML。这包括对 XML 文档进行本地修改的功能，以及在 XML 文档中进行索引和查询的功能。这允许应用程序使用那种与文档数据库应当使用的非常类似的数据模型。&lt;/p>
&lt;p>从 9.3 版本开始的 PostgreSQL 【8】，从 5.7 版本开始的 MySQL 以及从版本 10.5 开始的 IBM DB2【30】也对 JSON 文档提供了类似的支持级别。鉴于用在 Web APIs 的 JSON 流行趋势，其他关系数据库很可能会跟随他们的脚步并添加 JSON 支持。&lt;/p>
&lt;p>在文档数据库中，RethinkDB 在其查询语言中支持类似关系的连接，一些 MongoDB 驱动程序可以自动解析数据库引用（有效地执行客户端连接，尽管这可能比在数据库中执行的连接慢，需要额外的网络往返，并且优化更少）。&lt;/p>
&lt;p>随着时间的推移，关系数据库和文档数据库似乎变得越来越相似，这是一件好事：数据模型相互补充 &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>，如果一个数据库能够处理类似文档的数据，并能够对其执行关系查询，那么应用程序就可以使用最符合其需求的功能组合。&lt;/p>
&lt;p>关系模型和文档模型的混合是未来数据库一条很好的路线。&lt;/p>
&lt;h2 id="数据查询语言httpsvonnggithubioddiach2id数据查询语言">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%95%b0%e6%8d%ae%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80" target="_blank" rel="noopener">数据查询语言&lt;/a>&lt;/h2>
&lt;p>当引入关系模型时，关系模型包含了一种查询数据的新方法：SQL 是一种 &lt;strong>声明式&lt;/strong> 查询语言，而 IMS 和 CODASYL 使用 &lt;strong>命令式&lt;/strong> 代码来查询数据库。那是什么意思？&lt;/p>
&lt;p>许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，返回列表中的鲨鱼可以这样写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">getSharks&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">sharks&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">animals&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">animals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">family&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sharks&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">animals&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">sharks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在关系代数中：&lt;/p>
&lt;p>�ℎ����=�������=&amp;ldquo;�ℎ����&amp;rdquo;(�������)sharks=σfamily=&amp;ldquo;sharks&amp;rdquo;(animals)&lt;/p>
&lt;p>σ（希腊字母西格玛）是选择操作符，只返回符合条件的动物，&lt;code>family=&amp;quot;shark&amp;quot;&lt;/code>。&lt;/p>
&lt;p>定义 SQL 时，它紧密地遵循关系代数的结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">animals&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">family&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Sharks&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条件，更新变量，并决定是否再循环一遍。&lt;/p>
&lt;p>在声明式查询语言（如 SQL 或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些条件，以及如何将数据转换（例如，排序，分组和集合） - 但不是如何实现这一目标。数据库系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。&lt;/p>
&lt;p>声明式查询语言是迷人的，因为它通常比命令式 API 更加简洁和容易。但更重要的是，它还隐藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行性能提升。&lt;/p>
&lt;p>例如，在本节开头所示的命令代码中，动物列表以特定顺序出现。如果数据库想要在后台回收未使用的磁盘空间，则可能需要移动记录，这会改变动物出现的顺序。数据库能否安全地执行，而不会中断查询？&lt;/p>
&lt;p>SQL 示例不确保任何特定的顺序，因此不在意顺序是否改变。但是如果查询用命令式的代码来写的话，那么数据库就永远不可能确定代码是否依赖于排序。SQL 相当有限的功能性为数据库提供了更多自动优化的空间。&lt;/p>
&lt;p>最后，声明式语言往往适合并行执行。现在，CPU 的速度通过核心（core）的增加变得更快，而不是以比以前更高的时钟速度运行【31】。命令代码很难在多个核心和多个机器之间并行化，因为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言的并行实现【32】。&lt;/p>
&lt;h3 id="web-上的声明式查询httpsvonnggithubioddiach2idweb-上的声明式查询">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=web-%e4%b8%8a%e7%9a%84%e5%a3%b0%e6%98%8e%e5%bc%8f%e6%9f%a5%e8%af%a2" target="_blank" rel="noopener">Web 上的声明式查询&lt;/a>&lt;/h3>
&lt;p>声明式查询语言的优势不仅限于数据库。为了说明这一点，让我们在一个完全不同的环境中比较声明式和命令式方法：一个 Web 浏览器。&lt;/p>
&lt;p>假设你有一个关于海洋动物的网站。用户当前正在查看鲨鱼页面，因此你将当前所选的导航项目 “鲨鱼” 标记为当前选中项目。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span> &lt;span class="na">class&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;selected&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Sharks&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Great White Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Tiger Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Hammerhead Shark&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Whales&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Blue Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Humpback Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Fin Whale&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">li&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">ul&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在想让当前所选页面的标题具有一个蓝色的背景，以便在视觉上突出显示。使用 CSS 实现起来非常简单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">li&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">selected&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nt">p&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">background-color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">blue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 CSS 选择器 &lt;code>li.selected &amp;gt; p&lt;/code> 声明了我们想要应用蓝色样式的元素的模式：即其直接父元素是具有 CSS 类 &lt;code>selected&lt;/code> 的 &lt;code>&amp;lt;li&amp;gt;&lt;/code> 元素的所有 &lt;code>&amp;lt;p&amp;gt;&lt;/code> 元素。示例中的元素 &lt;code>&amp;lt;p&amp;gt;Sharks&amp;lt;/p&amp;gt;&lt;/code> 匹配此模式，但 &lt;code>&amp;lt;p&amp;gt;Whales&amp;lt;/p&amp;gt;&lt;/code> 不匹配，因为其 &lt;code>&amp;lt;li&amp;gt;&lt;/code> 父元素缺少 &lt;code>class=&amp;quot;selected&amp;quot;&lt;/code>。&lt;/p>
&lt;p>如果使用 XSL 而不是 CSS，你可以做类似的事情：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;xsl:template&lt;/span> &lt;span class="na">match=&lt;/span>&lt;span class="s">&amp;#34;li[@class=&amp;#39;selected&amp;#39;]/p&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;fo:block&lt;/span> &lt;span class="na">background-color=&lt;/span>&lt;span class="s">&amp;#34;blue&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;xsl:apply-templates/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/fo:block&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/xsl:template&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 XPath 表达式 &lt;code>li[@class='selected']/p&lt;/code> 相当于上例中的 CSS 选择器 &lt;code>li.selected &amp;gt; p&lt;/code>。CSS 和 XSL 的共同之处在于，它们都是用于指定文档样式的声明式语言。&lt;/p>
&lt;p>想象一下，必须使用命令式方法的情况会是如何。在 Javascript 中，使用 &lt;strong>文档对象模型（DOM）&lt;/strong> API，其结果可能如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">liElements&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getElementsByTagName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;li&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">liElements&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">liElements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">className&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;selected&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">children&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">liElements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">childNodes&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nodeType&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">Node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ELEMENT_NODE&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tagName&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;P&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setAttribute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;style&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;background-color: blue&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段 JavaScript 代码命令式地将元素设置为蓝色背景，但是代码看起来很糟糕。不仅比 CSS 和 XSL 等价物更长，更难理解，而且还有一些严重的问题：&lt;/p>
&lt;ul>
&lt;li>如果选定的类被移除（例如，因为用户点击了不同的页面），即使代码重新运行，蓝色背景也不会被移除 - 因此该项目将保持突出显示，直到整个页面被重新加载。使用 CSS，浏览器会自动检测 &lt;code>li.selected &amp;gt; p&lt;/code> 规则何时不再适用，并在选定的类被移除后立即移除蓝色背景。&lt;/li>
&lt;li>如果你想要利用新的 API（例如 &lt;code>document.getElementsByClassName(&amp;quot;selected&amp;quot;)&lt;/code> 甚至 &lt;code>document.evaluate()&lt;/code>）来提高性能，则必须重写代码。另一方面，浏览器供应商可以在不破坏兼容性的情况下提高 CSS 和 XPath 的性能。&lt;/li>
&lt;/ul>
&lt;p>在 Web 浏览器中，使用声明式 CSS 样式比使用 JavaScript 命令式地操作样式要好得多。类似地，在数据库中，使用像 SQL 这样的声明式查询语言比使用命令式查询 API 要好得多 &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>。&lt;/p>
&lt;h3 id="mapreduce查询httpsvonnggithubioddiach2idmapreduce查询">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=mapreduce%e6%9f%a5%e8%af%a2" target="_blank" rel="noopener">MapReduce查询&lt;/a>&lt;/h3>
&lt;p>MapReduce 是一个由 Google 推广的编程模型，用于在多台机器上批量处理大规模的数据【33】。一些 NoSQL 数据存储（包括 MongoDB 和 CouchDB）支持有限形式的 MapReduce，作为在多个文档中执行只读查询的机制。&lt;/p>
&lt;p>关于 MapReduce 更详细的介绍在 &lt;a href="https://vonng.github.io/ddia/#/ch10" target="_blank" rel="noopener">第十章&lt;/a>。现在我们只简要讨论一下 MongoDB 使用的模型。&lt;/p>
&lt;p>MapReduce 既不是一个声明式的查询语言，也不是一个完全命令式的查询 API，而是处于两者之间：查询的逻辑用代码片段来表示，这些代码片段会被处理框架重复性调用。它基于 &lt;code>map&lt;/code>（也称为 &lt;code>collect&lt;/code>）和 &lt;code>reduce&lt;/code>（也称为 &lt;code>fold&lt;/code> 或 &lt;code>inject&lt;/code>）函数，两个函数存在于许多函数式编程语言中。&lt;/p>
&lt;p>最好举例来解释 MapReduce 模型。假设你是一名海洋生物学家，每当你看到海洋中的动物时，你都会在数据库中添加一条观察记录。现在你想生成一个报告，说明你每月看到多少鲨鱼。&lt;/p>
&lt;p>在 PostgreSQL 中，你可以像这样表述这个查询：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">date_trunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;month&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_timestamp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_month&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_animals&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">total_animals&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observations&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">family&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sharks&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">GROUP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">observation_month&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>date_trunc('month'，timestamp)&lt;/code> 函数用于确定包含 &lt;code>timestamp&lt;/code> 的日历月份，并返回代表该月份开始的另一个时间戳。换句话说，它将时间戳舍入成最近的月份。&lt;/p>
&lt;p>这个查询首先过滤观察记录，以只显示鲨鱼家族的物种，然后根据它们发生的日历月份对观察记录果进行分组，最后将在该月的所有观察记录中看到的动物数目加起来。&lt;/p>
&lt;p>同样的查询用 MongoDB 的 MapReduce 功能可以按如下来表述：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observations&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mapReduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="nx">map&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">year&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observationTimestamp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getFullYear&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">month&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observationTimestamp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getMonth&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">year&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s2">&amp;#34;-&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">month&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">numAnimals&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">reduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">values&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">values&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">query&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">family&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">out&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;monthlySharkReport&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>可以声明式地指定一个只考虑鲨鱼种类的过滤器（这是 MongoDB 特定的 MapReduce 扩展）。&lt;/li>
&lt;li>每个匹配查询的文档都会调用一次 JavaScript 函数 &lt;code>map&lt;/code>，将 &lt;code>this&lt;/code> 设置为文档对象。&lt;/li>
&lt;li>&lt;code>map&lt;/code> 函数发出一个键（包括年份和月份的字符串，如 &lt;code>&amp;quot;2013-12&amp;quot;&lt;/code> 或 &lt;code>&amp;quot;2014-1&amp;quot;&lt;/code>）和一个值（该观察记录中的动物数量）。&lt;/li>
&lt;li>&lt;code>map&lt;/code> 发出的键值对按键来分组。对于具有相同键（即，相同的月份和年份）的所有键值对，调用一次 &lt;code>reduce&lt;/code> 函数。&lt;/li>
&lt;li>&lt;code>reduce&lt;/code> 函数将特定月份内所有观测记录中的动物数量相加。&lt;/li>
&lt;li>将最终的输出写入到 &lt;code>monthlySharkReport&lt;/code> 集合中。&lt;/li>
&lt;/ul>
&lt;p>例如，假设 &lt;code>observations&lt;/code> 集合包含这两个文档：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">observationTimestamp:&lt;/span> &lt;span class="err">Date.parse(&lt;/span> &lt;span class="nt">&amp;#34;Mon, 25 Dec 1995 12:34:56 GMT&amp;#34;&lt;/span>&lt;span class="err">)&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">family:&lt;/span> &lt;span class="nt">&amp;#34;Sharks&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">species:&lt;/span> &lt;span class="nt">&amp;#34;Carcharodon carcharias&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">numAnimals:&lt;/span> &lt;span class="err">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">observationTimestamp:&lt;/span> &lt;span class="err">Date.parse(&lt;/span>&lt;span class="nt">&amp;#34;Tue, 12 Dec 1995 16:17:18 GMT&amp;#34;&lt;/span>&lt;span class="err">)&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">family:&lt;/span> &lt;span class="nt">&amp;#34;Sharks&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">species:&lt;/span> &lt;span class="nt">&amp;#34;Carcharias taurus&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">numAnimals:&lt;/span> &lt;span class="err">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对每个文档都会调用一次 &lt;code>map&lt;/code> 函数，结果将是 &lt;code>emit(&amp;quot;1995-12&amp;quot;,3)&lt;/code> 和 &lt;code>emit(&amp;quot;1995-12&amp;quot;,4)&lt;/code>。随后，以 &lt;code>reduce(&amp;quot;1995-12&amp;quot;,[3,4])&lt;/code> 调用 &lt;code>reduce&lt;/code> 函数，将返回 &lt;code>7&lt;/code>。&lt;/p>
&lt;p>map 和 reduce 函数在功能上有所限制：它们必须是 &lt;strong>纯&lt;/strong> 函数，这意味着它们只使用传递给它们的数据作为输入，它们不能执行额外的数据库查询，也不能有任何副作用。这些限制允许数据库以任何顺序运行任何功能，并在失败时重新运行它们。然而，map 和 reduce 函数仍然是强大的：它们可以解析字符串，调用库函数，执行计算等等。&lt;/p>
&lt;p>MapReduce 是一个相当底层的编程模型，用于计算机集群上的分布式执行。像 SQL 这样的更高级的查询语言可以用一系列的 MapReduce 操作来实现（见 &lt;a href="https://vonng.github.io/ddia/#/ch10" target="_blank" rel="noopener">第十章&lt;/a>），但是也有很多不使用 MapReduce 的分布式 SQL 实现。请注意，SQL 中没有任何内容限制它在单个机器上运行，而 MapReduce 在分布式查询执行上没有垄断权。&lt;/p>
&lt;p>能够在查询中使用 JavaScript 代码是高级查询的一个重要特性，但这不限于 MapReduce，一些 SQL 数据库也可以用 JavaScript 函数进行扩展【34】。&lt;/p>
&lt;p>MapReduce 的一个可用性问题是，必须编写两个密切合作的 JavaScript 函数，这通常比编写单个查询更困难。此外，声明式查询语言为查询优化器提供了更多机会来提高查询的性能。基于这些原因，MongoDB 2.2 添加了一种叫做 &lt;strong>聚合管道&lt;/strong> 的声明式查询语言的支持【9】。用这种语言表述鲨鱼计数查询如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">observations&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">aggregate&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="nx">$match&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">family&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;Sharks&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="nx">$group&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_id&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">year&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$year&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$observationTimestamp&amp;#34;&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">month&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$month&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$observationTimestamp&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">totalAnimals&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">$sum&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;$numAnimals&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="p">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>聚合管道语言的表现力与（前述 PostgreSQL 例子的）SQL 子集相当，但是它使用基于 JSON 的语法而不是 SQL 那种接近英文句式的语法；这种差异也许只是口味问题。这个故事的寓意是：NoSQL 系统可能会意外发现自己只是重新发明了一套经过乔装改扮的 SQL。&lt;/p>
&lt;h2 id="图数据模型httpsvonnggithubioddiach2id图数据模型">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%9b%be%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">图数据模型&lt;/a>&lt;/h2>
&lt;p>如我们之前所见，多对多关系是不同数据模型之间具有区别性的重要特征。如果你的应用程序大多数的关系是一对多关系（树状结构化数据），或者大多数记录之间不存在关系，那么使用文档模型是合适的。&lt;/p>
&lt;p>但是，要是多对多关系在你的数据中很常见呢？关系模型可以处理多对多关系的简单情况，但是随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然。&lt;/p>
&lt;p>一个图由两种对象组成：&lt;strong>顶点&lt;/strong>（vertices，也称为 &lt;strong>节点&lt;/strong>，即 nodes，或 &lt;strong>实体&lt;/strong>，即 entities），和 &lt;strong>边&lt;/strong>（edges，也称为 &lt;strong>关系&lt;/strong>，即 relationships，或 &lt;strong>弧&lt;/strong>，即 arcs）。多种数据可以被建模为一个图形。典型的例子包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>社交图谱&lt;/p>
&lt;p>顶点是人，边指示哪些人彼此认识。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网络图谱&lt;/p>
&lt;p>顶点是网页，边缘表示指向其他页面的 HTML 链接。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>公路或铁路网络&lt;/p>
&lt;p>顶点是交叉路口，边线代表它们之间的道路或铁路线。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可以将那些众所周知的算法运用到这些图上：例如，汽车导航系统搜索道路网络中两点之间的最短路径，PageRank 可以用在网络图上来确定网页的流行程度，从而确定该网页在搜索结果中的排名。&lt;/p>
&lt;p>在刚刚给出的例子中，图中的所有顶点代表了相同类型的事物（人、网页或交叉路口）。不过，图并不局限于这样的同类数据：同样强大地是，图提供了一种一致的方式，用来在单个数据存储中存储完全不同类型的对象。例如，Facebook 维护一个包含许多不同类型的顶点和边的单个图：顶点表示人，地点，事件，签到和用户的评论；边缘表示哪些人是彼此的朋友，哪个签到发生在何处，谁评论了哪条消息，谁参与了哪个事件，等等【35】。&lt;/p>
&lt;p>在本节中，我们将使用 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-5.png" target="_blank" rel="noopener">图 2-5&lt;/a> 所示的示例。它可以从社交网络或系谱数据库中获得：它显示了两个人，来自爱达荷州的 Lucy 和来自法国 Beaune 的 Alain。他们已婚，住在伦敦。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig2-5.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 2-5 图数据结构示例（框代表顶点，箭头代表边）&lt;/strong>&lt;/p>
&lt;p>有几种不同但相关的方法用来构建和查询图表中的数据。在本节中，我们将讨论属性图模型（由 Neo4j，Titan 和 InfiniteGraph 实现）和三元组存储（triple-store）模型（由 Datomic，AllegroGraph 等实现）。我们将查看图的三种声明式查询语言：Cypher，SPARQL 和 Datalog。除此之外，还有像 Gremlin 【36】这样的图形查询语言和像 Pregel 这样的图形处理框架（见 &lt;a href="https://vonng.github.io/ddia/#/ch10" target="_blank" rel="noopener">第十章&lt;/a>）。&lt;/p>
&lt;h3 id="属性图httpsvonnggithubioddiach2id属性图">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%b1%9e%e6%80%a7%e5%9b%be" target="_blank" rel="noopener">属性图&lt;/a>&lt;/h3>
&lt;p>在属性图模型中，每个顶点（vertex）包括：&lt;/p>
&lt;ul>
&lt;li>唯一的标识符&lt;/li>
&lt;li>一组出边（outgoing edges）&lt;/li>
&lt;li>一组入边（ingoing edges）&lt;/li>
&lt;li>一组属性（键值对）&lt;/li>
&lt;/ul>
&lt;p>每条边（edge）包括：&lt;/p>
&lt;ul>
&lt;li>唯一标识符&lt;/li>
&lt;li>边的起点（&lt;strong>尾部顶点&lt;/strong>，即 tail vertex）&lt;/li>
&lt;li>边的终点（&lt;strong>头部顶点&lt;/strong>，即 head vertex）&lt;/li>
&lt;li>描述两个顶点之间关系类型的标签&lt;/li>
&lt;li>一组属性（键值对）&lt;/li>
&lt;/ul>
&lt;p>可以将图存储看作由两个关系表组成：一个存储顶点，另一个存储边，如 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-2&lt;/a> 所示（该模式使用 PostgreSQL JSON 数据类型来存储每个顶点或每条边的属性）。头部和尾部顶点用来存储每条边；如果你想要一组顶点的输入或输出边，你可以分别通过 &lt;code>head_vertex&lt;/code> 或 &lt;code>tail_vertex&lt;/code> 来查询 &lt;code>edges&lt;/code> 表。&lt;/p>
&lt;p>&lt;strong>例 2-2 使用关系模式来表示属性图&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INTEGER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">JSON&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">edge_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INTEGER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INTEGER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INTEGER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">TEXT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">JSON&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges_tails&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INDEX&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges_heads&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于这个模型的一些重要方面是：&lt;/p>
&lt;ol>
&lt;li>任何顶点都可以有一条边连接到任何其他顶点。没有模式限制哪种事物可不可以关联。&lt;/li>
&lt;li>给定任何顶点，可以高效地找到它的入边和出边，从而遍历图，即沿着一系列顶点的路径前后移动（这就是为什么 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-2&lt;/a> 在 &lt;code>tail_vertex&lt;/code> 和 &lt;code>head_vertex&lt;/code> 列上都有索引的原因）。&lt;/li>
&lt;li>通过对不同类型的关系使用不同的标签，可以在一个图中存储几种不同的信息，同时仍然保持一个清晰的数据模型。&lt;/li>
&lt;/ol>
&lt;p>这些特性为数据建模提供了很大的灵活性，如 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-5.png" target="_blank" rel="noopener">图 2-5&lt;/a> 所示。图中显示了一些传统关系模式难以表达的事情，例如不同国家的不同地区结构（法国有省和大区，美国有县和州），国中国的怪事（先忽略主权国家和民族错综复杂的烂摊子），不同的数据粒度（Lucy 现在的住所记录具体到城市，而她的出生地点只是在一个州的级别）。&lt;/p>
&lt;p>你可以想象该图还能延伸出许多关于 Lucy 和 Alain 的事实，或其他人的其他更多的事实。例如，你可以用它来表示食物过敏（为每个过敏源增加一个顶点，并增加人与过敏源之间的一条边来指示一种过敏情况），并链接到过敏源，每个过敏源具有一组顶点用来显示哪些食物含有哪些物质。然后，你可以写一个查询，找出每个人吃什么是安全的。图在可演化性方面是富有优势的：当你向应用程序添加功能时，可以轻松扩展图以适应程序数据结构的变化。&lt;/p>
&lt;h3 id="cypher-查询语言httpsvonnggithubioddiach2idcypher-查询语言">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=cypher-%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80" target="_blank" rel="noopener">Cypher 查询语言&lt;/a>&lt;/h3>
&lt;p>Cypher 是属性图的声明式查询语言，为 Neo4j 图形数据库而发明【37】（它是以电影 “黑客帝国” 中的一个角色来命名的，而与密码学中的加密算法无关【38】）。&lt;/p>
&lt;p>&lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-3&lt;/a> 显示了将 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-5.png" target="_blank" rel="noopener">图 2-5&lt;/a> 的左边部分插入图形数据库的 Cypher 查询。可以类似地添加图的其余部分，为了便于阅读而省略。每个顶点都有一个像 &lt;code>USA&lt;/code> 或 &lt;code>Idaho&lt;/code> 这样的符号名称，查询的其他部分可以使用这些名称在顶点之间创建边，使用箭头符号：&lt;code>（Idaho） - [：WITHIN] -&amp;gt;（USA）&lt;/code> 创建一条标记为 &lt;code>WITHIN&lt;/code> 的边，&lt;code>Idaho&lt;/code> 为尾节点，&lt;code>USA&lt;/code> 为头节点。&lt;/p>
&lt;p>&lt;strong>例 2-3 将图 2-5 中的数据子集表示为 Cypher 查询&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-cypher" data-lang="cypher">CREATE
(NAmerica:Location {name:&amp;#39;North America&amp;#39;, type:&amp;#39;continent&amp;#39;}),
(USA:Location {name:&amp;#39;United States&amp;#39;, type:&amp;#39;country&amp;#39; }),
(Idaho:Location {name:&amp;#39;Idaho&amp;#39;, type:&amp;#39;state&amp;#39; }),
(Lucy:Person {name:&amp;#39;Lucy&amp;#39; }),
(Idaho) -[:WITHIN]-&amp;gt; (USA) -[:WITHIN]-&amp;gt; (NAmerica),
(Lucy) -[:BORN_IN]-&amp;gt; (Idaho)
&lt;/code>&lt;/pre>&lt;p>当 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-5.png" target="_blank" rel="noopener">图 2-5&lt;/a> 的所有顶点和边被添加到数据库后，让我们提些有趣的问题：例如，找到所有从美国移民到欧洲的人的名字。更确切地说，这里我们想要找到符合下面条件的所有顶点，并且返回这些顶点的 &lt;code>name&lt;/code> 属性：该顶点拥有一条连到美国任一位置的 &lt;code>BORN_IN&lt;/code> 边，和一条连到欧洲的任一位置的 &lt;code>LIVING_IN&lt;/code> 边。&lt;/p>
&lt;p>&lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-4&lt;/a> 展示了如何在 Cypher 中表达这个查询。在 MATCH 子句中使用相同的箭头符号来查找图中的模式：&lt;code>(person) -[:BORN_IN]-&amp;gt; ()&lt;/code> 可以匹配 &lt;code>BORN_IN&lt;/code> 边的任意两个顶点。该边的尾节点被绑定了变量 &lt;code>person&lt;/code>，头节点则未被绑定。&lt;/p>
&lt;p>&lt;strong>例 2-4 查找所有从美国移民到欧洲的人的 Cypher 查询：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-cypher" data-lang="cypher">MATCH
(person) -[:BORN_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (us:Location {name:&amp;#39;United States&amp;#39;}),
(person) -[:LIVES_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (eu:Location {name:&amp;#39;Europe&amp;#39;})
RETURN person.name
&lt;/code>&lt;/pre>&lt;p>查询按如下来解读：&lt;/p>
&lt;blockquote>
&lt;p>找到满足以下两个条件的所有顶点（称之为 person 顶点）：&lt;/p>
&lt;ol>
&lt;li>&lt;code>person&lt;/code> 顶点拥有一条到某个顶点的 &lt;code>BORN_IN&lt;/code> 出边。从那个顶点开始，沿着一系列 &lt;code>WITHIN&lt;/code> 出边最终到达一个类型为 &lt;code>Location&lt;/code>，&lt;code>name&lt;/code> 属性为 &lt;code>United States&lt;/code> 的顶点。&lt;/li>
&lt;li>&lt;code>person&lt;/code> 顶点还拥有一条 &lt;code>LIVES_IN&lt;/code> 出边。沿着这条边，可以通过一系列 &lt;code>WITHIN&lt;/code> 出边最终到达一个类型为 &lt;code>Location&lt;/code>，&lt;code>name&lt;/code> 属性为 &lt;code>Europe&lt;/code> 的顶点。&lt;/li>
&lt;/ol>
&lt;p>对于这样的 &lt;code>Person&lt;/code> 顶点，返回其 &lt;code>name&lt;/code> 属性。&lt;/p>
&lt;/blockquote>
&lt;p>执行这条查询可能会有几种可行的查询路径。这里给出的描述建议首先扫描数据库中的所有人，检查每个人的出生地和居住地，然后只返回符合条件的那些人。&lt;/p>
&lt;p>等价地，也可以从两个 &lt;code>Location&lt;/code> 顶点开始反向地查找。假如 &lt;code>name&lt;/code> 属性上有索引，则可以高效地找到代表美国和欧洲的两个顶点。然后，沿着所有 &lt;code>WITHIN&lt;/code> 入边，可以继续查找出所有在美国和欧洲的位置（州，地区，城市等）。最后，查找出那些可以由 &lt;code>BORN_IN&lt;/code> 或 &lt;code>LIVES_IN&lt;/code> 入边到那些位置顶点的人。&lt;/p>
&lt;p>通常对于声明式查询语言来说，在编写查询语句时，不需要指定执行细节：查询优化程序会自动选择预测效率最高的策略，因此你可以专注于编写应用程序的其他部分。&lt;/p>
&lt;h3 id="sql-中的图查询httpsvonnggithubioddiach2idsql-中的图查询">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=sql-%e4%b8%ad%e7%9a%84%e5%9b%be%e6%9f%a5%e8%af%a2" target="_blank" rel="noopener">SQL 中的图查询&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-2&lt;/a> 指出，可以在关系数据库中表示图数据。但是，如果图数据已经以关系结构存储，我们是否也可以使用 SQL 查询它？&lt;/p>
&lt;p>答案是肯定的，但有些困难。在关系数据库中，你通常会事先知道在查询中需要哪些连接。在图查询中，你可能需要在找到待查找的顶点之前，遍历可变数量的边。也就是说，连接的数量事先并不确定。&lt;/p>
&lt;p>在我们的例子中，这发生在 Cypher 查询中的 &lt;code>() -[:WITHIN*0..]-&amp;gt; ()&lt;/code> 规则中。一个人的 &lt;code>LIVES_IN&lt;/code> 边可以指向任何类型的位置：街道、城市、地区、国家等。一个城市可以在（WITHIN）一个地区内，一个地区可以在（WITHIN）在一个州内，一个州可以在（WITHIN）一个国家内，等等。&lt;code>LIVES_IN&lt;/code> 边可以直接指向正在查找的位置，或者一个在位置层次结构中隔了数层的位置。&lt;/p>
&lt;p>在 Cypher 中，用 &lt;code>WITHIN*0..&lt;/code> 非常简洁地表述了上述事实：“沿着 &lt;code>WITHIN&lt;/code> 边，零次或多次”。它很像正则表达式中的 &lt;code>*&lt;/code> 运算符。&lt;/p>
&lt;p>自 SQL:1999，查询可变长度遍历路径的思想可以使用称为 &lt;strong>递归公用表表达式&lt;/strong>（&lt;code>WITH RECURSIVE&lt;/code> 语法）的东西来表示。&lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-5&lt;/a> 显示了同样的查询 - 查找从美国移民到欧洲的人的姓名 - 在 SQL 使用这种技术（PostgreSQL、IBM DB2、Oracle 和 SQL Server 均支持）来表述。但是，与 Cypher 相比，其语法非常笨拙。&lt;/p>
&lt;p>&lt;strong>例 2-5 与示例 2-4 同样的查询，在 SQL 中使用递归公用表表达式表示&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">WITH&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">RECURSIVE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- in_usa 包含所有的美国境内的位置 ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;United States&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">UNION&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;within&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- in_europe 包含所有的欧洲境内的位置 ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Europe&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">UNION&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;within&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- born_in_usa 包含了所有类型为 Person，且出生在美国的顶点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;born_in&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">-- lives_in_europe 包含了所有类型为 Person，且居住在欧洲的顶点。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tail_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">head_vertex&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">edges&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;lives_in&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">properties&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">born_in_usa&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">vertices&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lives_in_europe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">vertex_id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>首先，查找 &lt;code>name&lt;/code> 属性为 &lt;code>United States&lt;/code> 的顶点，将其作为 &lt;code>in_usa&lt;/code> 顶点的集合的第一个元素。&lt;/li>
&lt;li>从 &lt;code>in_usa&lt;/code> 集合的顶点出发，沿着所有的 &lt;code>with_in&lt;/code> 入边，将其尾顶点加入同一集合，不断递归直到所有 &lt;code>with_in&lt;/code> 入边都被访问完毕。&lt;/li>
&lt;li>同理，从 &lt;code>name&lt;/code> 属性为 &lt;code>Europe&lt;/code> 的顶点出发，建立 &lt;code>in_europe&lt;/code> 顶点的集合。&lt;/li>
&lt;li>对于 &lt;code>in_usa&lt;/code> 集合中的每个顶点，根据 &lt;code>born_in&lt;/code> 入边来查找出生在美国某个地方的人。&lt;/li>
&lt;li>同样，对于 &lt;code>in_europe&lt;/code> 集合中的每个顶点，根据 &lt;code>lives_in&lt;/code> 入边来查找居住在欧洲的人。&lt;/li>
&lt;li>最后，把在美国出生的人的集合与在欧洲居住的人的集合相交。&lt;/li>
&lt;/ul>
&lt;p>同一个查询，用某一个查询语言可以写成 4 行，而用另一个查询语言需要 29 行，这恰恰说明了不同的数据模型是为不同的应用场景而设计的。选择适合应用程序的数据模型非常重要。&lt;/p>
&lt;h3 id="三元组存储和-sparqlhttpsvonnggithubioddiach2id三元组存储和-sparql">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e4%b8%89%e5%85%83%e7%bb%84%e5%ad%98%e5%82%a8%e5%92%8c-sparql" target="_blank" rel="noopener">三元组存储和 SPARQL&lt;/a>&lt;/h3>
&lt;p>三元组存储模式大体上与属性图模型相同，用不同的词来描述相同的想法。不过仍然值得讨论，因为三元组存储有很多现成的工具和语言，这些工具和语言对于构建应用程序的工具箱可能是宝贵的补充。&lt;/p>
&lt;p>在三元组存储中，所有信息都以非常简单的三部分表示形式存储（&lt;strong>主语&lt;/strong>，&lt;strong>谓语&lt;/strong>，&lt;strong>宾语&lt;/strong>）。例如，三元组 &lt;strong>(吉姆, 喜欢, 香蕉)&lt;/strong> 中，&lt;strong>吉姆&lt;/strong> 是主语，&lt;strong>喜欢&lt;/strong> 是谓语（动词），&lt;strong>香蕉&lt;/strong> 是对象。&lt;/p>
&lt;p>三元组的主语相当于图中的一个顶点。而宾语是下面两者之一：&lt;/p>
&lt;ol>
&lt;li>原始数据类型中的值，例如字符串或数字。在这种情况下，三元组的谓语和宾语相当于主语顶点上的属性的键和值。例如，&lt;code>(lucy, age, 33)&lt;/code> 就像属性 &lt;code>{“age”：33}&lt;/code> 的顶点 lucy。&lt;/li>
&lt;li>图中的另一个顶点。在这种情况下，谓语是图中的一条边，主语是其尾部顶点，而宾语是其头部顶点。例如，在 &lt;code>(lucy, marriedTo, alain)&lt;/code> 中主语和宾语 &lt;code>lucy&lt;/code> 和 &lt;code>alain&lt;/code> 都是顶点，并且谓语 &lt;code>marriedTo&lt;/code> 是连接他们的边的标签。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-6&lt;/a> 展示了与 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-3&lt;/a> 相同的数据，以称为 Turtle 的格式（Notation3（N3）【39】的一个子集）写成三元组。&lt;/p>
&lt;p>&lt;strong>例 2-6 图 2-5 中的数据子集，表示为 Turtle 三元组&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-reStructuredText" data-lang="reStructuredText">&lt;span class="line">&lt;span class="cl">@prefix : &amp;lt;urn:example:&amp;gt;.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:lucy a :Person.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:lucy :name &amp;#34;Lucy&amp;#34;.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:lucy :bornIn _:idaho.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:idaho a :Location.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:idaho :name &amp;#34;Idaho&amp;#34;.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:idaho :type &amp;#34;state&amp;#34;.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:idaho :within _:usa.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:usa a :Location&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:usa :name &amp;#34;United States&amp;#34;&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:usa :type &amp;#34;country&amp;#34;.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:usa :within _:namerica.&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:namerica a :Location&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:namerica :name &amp;#34;North America&amp;#34;&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>_:namerica :type :&amp;#34;continent&amp;#34;&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中，图的顶点被写为：&lt;code>_：someName&lt;/code>。这个名字并不意味着这个文件以外的任何东西。它的存在只是帮助我们明确哪些三元组引用了同一顶点。当谓语表示边时，该宾语是一个顶点，如 &lt;code>_:idaho :within _:usa.&lt;/code>。当谓语是一个属性时，该宾语是一个字符串，如 &lt;code>_:usa :name&amp;quot;United States&amp;quot;&lt;/code>&lt;/p>
&lt;p>一遍又一遍地重复相同的主语看起来相当重复，但幸运的是，可以使用分号来说明关于同一主语的多个事情。这使得 Turtle 格式相当不错，可读性强：请参阅 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-7&lt;/a>。&lt;/p>
&lt;p>&lt;strong>例 2-7 一种相对例 2-6 写入数据的更为简洁的方法。&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>@prefix : &amp;lt;urn:example:&amp;gt;.
_:lucy a :Person; :name &amp;#34;Lucy&amp;#34;; :bornIn _:idaho.
_:idaho a :Location; :name &amp;#34;Idaho&amp;#34;; :type &amp;#34;state&amp;#34;; :within _:usa
_:usa a :Loaction; :name &amp;#34;United States&amp;#34;; :type &amp;#34;country&amp;#34;; :within _:namerica.
_:namerica a :Location; :name &amp;#34;North America&amp;#34;; :type &amp;#34;continent&amp;#34;.
&lt;/code>&lt;/pre>&lt;h4 id="语义网httpsvonnggithubioddiach2id语义网">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e8%af%ad%e4%b9%89%e7%bd%91" target="_blank" rel="noopener">语义网&lt;/a>&lt;/h4>
&lt;p>如果你深入了解关于三元组存储的信息，可能会陷入关于&lt;strong>语义网&lt;/strong>的讨论漩涡中。三元组存储模型其实是完全独立于语义网存在的，例如，Datomic【40】作为一种三元组存储数据库 &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>，从未被用于语义网中。但是，由于在很多人眼中这两者紧密相连，我们应该简要地讨论一下。&lt;/p>
&lt;p>从本质上讲，语义网是一个简单且合理的想法：网站已经将信息发布为文字和图片供人类阅读，为什么不将信息作为机器可读的数据也发布给计算机呢？（基于三元组模型的）&lt;strong>资源描述框架&lt;/strong>（&lt;strong>RDF&lt;/strong>）【41】，被用作不同网站以统一的格式发布数据的一种机制，允许来自不同网站的数据自动合并成 &lt;strong>一个数据网络&lt;/strong> —— 成为一种互联网范围内的 “通用语义网数据库”。&lt;/p>
&lt;p>不幸的是，语义网在二十一世纪初被过度炒作，但到目前为止没有任何迹象表明已在实践中应用，这使得许多人嗤之以鼻。它还饱受眼花缭乱的缩略词、过于复杂的标准提案和狂妄自大的困扰。&lt;/p>
&lt;p>然而，如果从过去的失败中汲取教训，语义网项目还是拥有很多优秀的成果。即使你没有兴趣在语义网上发布 RDF 数据，三元组这种模型也是一种好的应用程序内部数据模型。&lt;/p>
&lt;h4 id="rdf-数据模型httpsvonnggithubioddiach2idrdf-数据模型">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=rdf-%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">RDF 数据模型&lt;/a>&lt;/h4>
&lt;p>&lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-7&lt;/a> 中使用的 Turtle 语言是一种用于 RDF 数据的人类可读格式。有时候，RDF 也可以以 XML 格式编写，不过完成同样的事情会相对啰嗦，请参阅 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-8&lt;/a>。Turtle/N3 是更可取的，因为它更容易阅读，像 Apache Jena 【42】这样的工具可以根据需要在不同的 RDF 格式之间进行自动转换。&lt;/p>
&lt;p>&lt;strong>例 2-8 用 RDF/XML 语法表示例 2-7 的数据&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;rdf:RDF&lt;/span> &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">&amp;#34;urn:example:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">xmlns:rdf=&lt;/span>&lt;span class="s">&amp;#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;idaho&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>Idaho&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>state&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;usa&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>United States&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>country&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Location&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;namerica&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>North America&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>continent&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/within&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Location&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Person&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;lucy&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>Lucy&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;bornIn&lt;/span> &lt;span class="na">rdf:nodeID=&lt;/span>&lt;span class="s">&amp;#34;idaho&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Person&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/rdf:RDF&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RDF 有一些奇怪之处，因为它是为了在互联网上交换数据而设计的。三元组的主语，谓语和宾语通常是 URI。例如，谓语可能是一个 URI，如 &lt;code>&amp;lt;http://my-company.com/namespace#within&amp;gt;&lt;/code> 或 &lt;code>&amp;lt;http://my-company.com/namespace#lives_in&amp;gt;&lt;/code>，而不仅仅是 &lt;code>WITHIN&lt;/code> 或 &lt;code>LIVES_IN&lt;/code>。这个设计背后的原因为了让你能够把你的数据和其他人的数据结合起来，如果他们赋予单词 &lt;code>within&lt;/code> 或者 &lt;code>lives_in&lt;/code> 不同的含义，两者也不会冲突，因为它们的谓语实际上是 &lt;code>&amp;lt;http://other.org/foo#within&amp;gt;&lt;/code> 和 &lt;code>&amp;lt;http://other.org/foo#lives_in&amp;gt;&lt;/code>。&lt;/p>
&lt;p>从 RDF 的角度来看，URL &lt;code>&amp;lt;http://my-company.com/namespace&amp;gt;&lt;/code> 不一定需要能解析成什么东西，它只是一个命名空间。为避免与 &lt;code>http://URL&lt;/code> 混淆，本节中的示例使用不可解析的 URI，如 &lt;code>urn：example：within&lt;/code>。幸运的是，你只需在文件顶部对这个前缀做一次声明，后续就不用再管了。&lt;/p>
&lt;h3 id="sparql-查询语言httpsvonnggithubioddiach2idsparql-查询语言">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=sparql-%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80" target="_blank" rel="noopener">SPARQL 查询语言&lt;/a>&lt;/h3>
&lt;p>&lt;strong>SPARQL&lt;/strong> 是一种用于三元组存储的面向 RDF 数据模型的查询语言【43】（它是 SPARQL 协议和 RDF 查询语言的缩写，发音为 “sparkle”）。SPARQL 早于 Cypher，并且由于 Cypher 的模式匹配借鉴于 SPARQL，这使得它们看起来非常相似【37】。&lt;/p>
&lt;p>与之前相同的查询 —— 查找从美国移民到欧洲的人 —— 使用 SPARQL 比使用 Cypher 甚至更为简洁（请参阅 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-9&lt;/a>）。&lt;/p>
&lt;p>&lt;strong>例 2-9 与示例 2-4 相同的查询，用 SPARQL 表示&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sparql" data-lang="sparql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">PREFIX&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="nl">&amp;lt;urn:example:&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span> &lt;span class="nv">?personName&lt;/span> &lt;span class="k">WHERE&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">?person&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="nt">name&lt;/span> &lt;span class="nv">?personName&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">?person&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="nt">bornIn&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="nt">name&lt;/span> &lt;span class="s">&amp;#34;United States&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">?person&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="nt">livesIn&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="nt">within&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="nt">name&lt;/span> &lt;span class="s">&amp;#34;Europe&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结构非常相似。以下两个表达式是等价的（SPARQL 中的变量以问号开头）：&lt;/p>
&lt;pre tabindex="0">&lt;code>(person) -[:BORN_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (location) # Cypher
?person :bornIn / :within* ?location. # SPARQL
&lt;/code>&lt;/pre>&lt;p>因为 RDF 不区分属性和边，而只是将它们作为谓语，所以可以使用相同的语法来匹配属性。在下面的表达式中，变量 &lt;code>usa&lt;/code> 被绑定到任意 &lt;code>name&lt;/code> 属性为字符串值 &lt;code>&amp;quot;United States&amp;quot;&lt;/code> 的顶点：&lt;/p>
&lt;pre tabindex="0">&lt;code>(usa {name:&amp;#39;United States&amp;#39;}) # Cypher
?usa :name &amp;#34;United States&amp;#34;. # SPARQL
&lt;/code>&lt;/pre>&lt;p>SPARQL 是一种很好的查询语言 —— 尽管它构想的语义网从未实现，但它仍然是一种可用于应用程序内部的强大工具。&lt;/p>
&lt;blockquote>
&lt;h4 id="图形数据库与网状模型相比较httpsvonnggithubioddiach2id图形数据库与网状模型相比较">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%9b%be%e5%bd%a2%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%8e%e7%bd%91%e7%8a%b6%e6%a8%a1%e5%9e%8b%e7%9b%b8%e6%af%94%e8%be%83" target="_blank" rel="noopener">图形数据库与网状模型相比较&lt;/a>&lt;/h4>
&lt;p>在 “&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%96%87%e6%a1%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e6%98%af%e5%90%a6%e5%9c%a8%e9%87%8d%e8%b9%88%e8%a6%86%e8%be%99%ef%bc%9f" target="_blank" rel="noopener">文档数据库是否在重蹈覆辙？&lt;/a>” 中，我们讨论了 CODASYL 和关系模型如何竞相解决 IMS 中的多对多关系问题。乍一看，CODASYL 的网状模型看起来与图模型相似。CODASYL 是否是图形数据库的第二个变种？&lt;/p>
&lt;p>不，他们在几个重要方面有所不同：&lt;/p>
&lt;ul>
&lt;li>在 CODASYL 中，数据库有一个模式，用于指定哪种记录类型可以嵌套在其他记录类型中。在图形数据库中，不存在这样的限制：任何顶点都可以具有到其他任何顶点的边。这为应用程序适应不断变化的需求提供了更大的灵活性。&lt;/li>
&lt;li>在 CODASYL 中，达到特定记录的唯一方法是遍历其中的一个访问路径。在图形数据库中，可以通过其唯一 ID 直接引用任何顶点，也可以使用索引来查找具有特定值的顶点。&lt;/li>
&lt;li>在 CODASYL 中，记录的子项目是一个有序集合，所以数据库必须去管理它们的次序（这会影响存储布局），并且应用程序在插入新记录到数据库时必须关注新记录在这些集合中的位置。在图形数据库中，顶点和边是无序的（只能在查询时对结果进行排序）。&lt;/li>
&lt;li>在 CODASYL 中，所有查询都是命令式的，难以编写，并且很容易因架构变化而受到破坏。在图形数据库中，你可以在命令式代码中手写遍历过程，但大多数图形数据库都支持高级声明式查询，如 Cypher 或 SPARQL。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="基础dataloghttpsvonnggithubioddiach2id基础datalog">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%9f%ba%e7%a1%80%ef%bc%9adatalog" target="_blank" rel="noopener">基础：Datalog&lt;/a>&lt;/h3>
&lt;p>&lt;strong>Datalog&lt;/strong> 是比 SPARQL、Cypher 更古老的语言，在 20 世纪 80 年代被学者广泛研究【44,45,46】。它在软件工程师中不太知名，但是它是重要的，因为它为以后的查询语言提供了基础。&lt;/p>
&lt;p>实践中，Datalog 在有限的几个数据系统中使用：例如，它是 Datomic 【40】的查询语言，Cascalog 【47】是一种用于查询 Hadoop 大数据集的 Datalog 实现 &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>Datalog 的数据模型类似于三元组模式，但进行了一点泛化。把三元组写成 &lt;strong>谓语&lt;/strong>（&lt;strong>主语，宾语&lt;/strong>），而不是写三元语（&lt;strong>主语，谓语，宾语&lt;/strong>）。&lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-10&lt;/a> 显示了如何用 Datalog 写入我们的例子中的数据。&lt;/p>
&lt;p>&lt;strong>例 2-10 用 Datalog 来表示图 2-5 中的数据子集&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-prolog" data-lang="prolog">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">namerica&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#39;North America&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">namerica&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">continent&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">usa&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#39;United States&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">usa&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">country&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">within&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">usa&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">namerica&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">idaho&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#39;Idaho&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">idaho&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">state&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">within&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">idaho&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">usa&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">lucy&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#39;Lucy&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">born_in&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">lucy&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">idaho&lt;/span>&lt;span class="p">).&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>既然已经定义了数据，我们可以像之前一样编写相同的查询，如 &lt;a href="https://vonng.github.io/ddia/#/" target="_blank" rel="noopener">例 2-11&lt;/a> 所示。它看起来与 Cypher 或 SPARQL 的语法差异较大，但请不要抗拒它。Datalog 是 Prolog 的一个子集，如果你是计算机科学专业的学生，可能已经见过 Prolog。&lt;/p>
&lt;p>&lt;strong>例 2-11 与示例 2-4 相同的查询，用 Datalog 表示&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>within_recursive(Location, Name) :- name(Location, Name). /* Rule 1 */
within_recursive(Location, Name) :- within(Location, Via), /* Rule 2 */
within_recursive(Via, Name).
migrated(Name, BornIn, LivingIn) :- name(Person, Name), /* Rule 3 */
born_in(Person, BornLoc),
within_recursive(BornLoc, BornIn),
lives_in(Person, LivingLoc),
within_recursive(LivingLoc, LivingIn).
?- migrated(Who, &amp;#39;United States&amp;#39;, &amp;#39;Europe&amp;#39;). /* Who = &amp;#39;Lucy&amp;#39;. */
&lt;/code>&lt;/pre>&lt;p>Cypher 和 SPARQL 使用 SELECT 立即跳转，但是 Datalog 一次只进行一小步。我们定义 &lt;strong>规则&lt;/strong>，以将新谓语告诉数据库：在这里，我们定义了两个新的谓语，&lt;code>within_recursive&lt;/code> 和 &lt;code>migrated&lt;/code>。这些谓语不是存储在数据库中的三元组中，而是从数据或其他规则派生而来的。规则可以引用其他规则，就像函数可以调用其他函数或者递归地调用自己一样。像这样，复杂的查询可以借由小的砖瓦构建起来。&lt;/p>
&lt;p>在规则中，以大写字母开头的单词是变量，谓语则用 Cypher 和 SPARQL 的方式一样来匹配。例如，&lt;code>name(Location, Name)&lt;/code> 通过变量绑定 &lt;code>Location = namerica&lt;/code> 和 &lt;code>Name ='North America'&lt;/code> 可以匹配三元组 &lt;code>name(namerica, 'North America')&lt;/code>。&lt;/p>
&lt;p>要是系统可以在 &lt;code>:-&lt;/code> 操作符的右侧找到与所有谓语的一个匹配，就运用该规则。当规则运用时，就好像通过 &lt;code>:-&lt;/code> 的左侧将其添加到数据库（将变量替换成它们匹配的值）。&lt;/p>
&lt;p>因此，一种可能的应用规则的方式是：&lt;/p>
&lt;ol>
&lt;li>数据库存在 &lt;code>name (namerica, 'North America')&lt;/code>，故运用规则 1。它生成 &lt;code>within_recursive (namerica, 'North America')&lt;/code>。&lt;/li>
&lt;li>数据库存在 &lt;code>within (usa, namerica)&lt;/code>，在上一步骤中生成 &lt;code>within_recursive (namerica, 'North America')&lt;/code>，故运用规则 2。它会产生 &lt;code>within_recursive (usa, 'North America')&lt;/code>。&lt;/li>
&lt;li>数据库存在 &lt;code>within (idaho, usa)&lt;/code>，在上一步生成 &lt;code>within_recursive (usa, 'North America')&lt;/code>，故运用规则 2。它产生 &lt;code>within_recursive (idaho, 'North America')&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>通过重复应用规则 1 和 2，&lt;code>within_recursive&lt;/code> 谓语可以告诉我们在数据库中包含北美（或任何其他位置名称）的所有位置。这个过程如 &lt;a href="https://vonng.github.io/ddia/#/img/fig2-6.png" target="_blank" rel="noopener">图 2-6&lt;/a> 所示。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig2-6.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 2-6 使用示例 2-11 中的 Datalog 规则来确定爱达荷州在北美。&lt;/strong>&lt;/p>
&lt;p>现在规则 3 可以找到出生在某个地方 &lt;code>BornIn&lt;/code> 的人，并住在某个地方 &lt;code>LivingIn&lt;/code>。通过查询 &lt;code>BornIn ='United States'&lt;/code> 和 &lt;code>LivingIn ='Europe'&lt;/code>，并将此人作为变量 &lt;code>Who&lt;/code>，让 Datalog 系统找出变量 &lt;code>Who&lt;/code> 会出现哪些值。因此，最后得到了与早先的 Cypher 和 SPARQL 查询相同的答案。&lt;/p>
&lt;p>相对于本章讨论的其他查询语言，我们需要采取不同的思维方式来思考 Datalog 方法，但这是一种非常强大的方法，因为规则可以在不同的查询中进行组合和重用。虽然对于简单的一次性查询，显得不太方便，但是它可以更好地处理数据很复杂的情况。&lt;/p>
&lt;h2 id="本章小结httpsvonnggithubioddiach2id本章小结">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" target="_blank" rel="noopener">本章小结&lt;/a>&lt;/h2>
&lt;p>数据模型是一个巨大的课题，在本章中，我们快速浏览了各种不同的模型。我们没有足够的篇幅来详述每个模型的细节，但是希望这个概述足以激起你的兴趣，以更多地了解最适合你的应用需求的模型。&lt;/p>
&lt;p>在历史上，数据最开始被表示为一棵大树（层次数据模型），但是这不利于表示多对多的关系，所以发明了关系模型来解决这个问题。最近，开发人员发现一些应用程序也不适合采用关系模型。新的非关系型 “NoSQL” 数据存储分化为两个主要方向：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>文档数据库&lt;/strong> 主要关注自我包含的数据文档，而且文档之间的关系非常稀少。&lt;/li>
&lt;li>&lt;strong>图形数据库&lt;/strong> 用于相反的场景：任意事物之间都可能存在潜在的关联。&lt;/li>
&lt;/ol>
&lt;p>这三种模型（文档，关系和图形）在今天都被广泛使用，并且在各自的领域都发挥很好。一个模型可以用另一个模型来模拟 —— 例如，图数据可以在关系数据库中表示 —— 但结果往往是糟糕的。这就是为什么我们有着针对不同目的的不同系统，而不是一个单一的万能解决方案。&lt;/p>
&lt;p>文档数据库和图数据库有一个共同点，那就是它们通常不会将存储的数据强制约束为特定模式，这可以使应用程序更容易适应不断变化的需求。但是应用程序很可能仍会假定数据具有一定的结构；区别仅在于模式是&lt;strong>明确的&lt;/strong>（写入时强制）还是&lt;strong>隐含的&lt;/strong>（读取时处理）。&lt;/p>
&lt;p>每个数据模型都具有各自的查询语言或框架，我们讨论了几个例子：SQL，MapReduce，MongoDB 的聚合管道，Cypher，SPARQL 和 Datalog。我们也谈到了 CSS 和 XSL/XPath，它们不是数据库查询语言，而包含有趣的相似之处。&lt;/p>
&lt;p>虽然我们已经覆盖了很多层面，但仍然有许多数据模型没有提到。举几个简单的例子：&lt;/p>
&lt;ul>
&lt;li>使用基因组数据的研究人员通常需要执行 &lt;strong>序列相似性搜索&lt;/strong>，这意味着需要一个很长的字符串（代表一个 DNA 序列），并在一个拥有类似但不完全相同的字符串的大型数据库中寻找匹配。这里所描述的数据库都不能处理这种用法，这就是为什么研究人员编写了像 GenBank 这样的专门的基因组数据库软件的原因【48】。&lt;/li>
&lt;li>粒子物理学家数十年来一直在进行大数据类型的大规模数据分析，像大型强子对撞机（LHC）这样的项目现在会处理数百 PB 的数据！在这样的规模下，需要定制解决方案来阻止硬件成本的失控【49】。&lt;/li>
&lt;li>&lt;strong>全文搜索&lt;/strong> 可以说是一种经常与数据库一起使用的数据模型。信息检索是一个很大的专业课题，我们不会在本书中详细介绍，但是我们将在第三章和第三部分中介绍搜索索引。&lt;/li>
&lt;/ul>
&lt;p>让我们暂时将其放在一边。在 &lt;a href="https://vonng.github.io/ddia/#/ch3" target="_blank" rel="noopener">下一章&lt;/a> 中，我们将讨论在 &lt;strong>实现&lt;/strong> 本章描述的数据模型时会遇到的一些权衡。&lt;/p>
&lt;h2 id="参考文献httpsvonnggithubioddiach2id参考文献">&lt;a href="https://vonng.github.io/ddia/#/ch2?id=%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae" target="_blank" rel="noopener">参考文献&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>Edgar F. Codd: “&lt;a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf" target="_blank" rel="noopener">A Relational Model of Data for Large Shared Data Banks&lt;/a>,” &lt;em>Communications of the ACM&lt;/em>, volume 13, number 6, pages 377–387, June 1970. &lt;a href="http://dx.doi.org/10.1145/362384.362685" target="_blank" rel="noopener">doi:10.1145/362384.362685&lt;/a>&lt;/li>
&lt;li>Michael Stonebraker and Joseph M. Hellerstein: “&lt;a href="http://mitpress2.mit.edu/books/chapters/0262693143chapm1.pdf" target="_blank" rel="noopener">What Goes Around Comes Around&lt;/a>,” in &lt;em>Readings in Database Systems&lt;/em>, 4th edition, MIT Press, pages 2–41, 2005. ISBN: 978-0-262-69314-1&lt;/li>
&lt;li>Pramod J. Sadalage and Martin Fowler: &lt;em>NoSQL Distilled&lt;/em>. Addison-Wesley, August 2012. ISBN: 978-0-321-82662-6&lt;/li>
&lt;li>Eric Evans: “&lt;a href="http://blog.sym-link.com/2009/10/30/nosql_whats_in_a_name.html" target="_blank" rel="noopener">NoSQL: What&amp;rsquo;s in a Name?&lt;/a>,” &lt;em>blog.sym-link.com&lt;/em>, October 30, 2009.&lt;/li>
&lt;li>James Phillips: “&lt;a href="http://blog.couchbase.com/nosql-adoption-survey-surprises" target="_blank" rel="noopener">Surprises in Our NoSQL Adoption Survey&lt;/a>,” &lt;em>blog.couchbase.com&lt;/em>, February 8, 2012.&lt;/li>
&lt;li>Michael Wagner: &lt;em>SQL/XML:2006 – Evaluierung der Standardkonformität ausgewählter Datenbanksysteme&lt;/em>. Diplomica Verlag, Hamburg, 2010. ISBN: 978-3-836-64609-3&lt;/li>
&lt;li>“&lt;a href="http://technet.microsoft.com/en-us/library/bb522446.aspx" target="_blank" rel="noopener">XML Data in SQL Server&lt;/a>,” SQL Server 2012 documentation, &lt;em>technet.microsoft.com&lt;/em>, 2013.&lt;/li>
&lt;li>“&lt;a href="http://www.postgresql.org/docs/9.3/static/index.html" target="_blank" rel="noopener">PostgreSQL 9.3.1 Documentation&lt;/a>,” The PostgreSQL Global Development Group, 2013.&lt;/li>
&lt;li>“&lt;a href="http://docs.mongodb.org/manual/" target="_blank" rel="noopener">The MongoDB 2.4 Manual&lt;/a>,” MongoDB, Inc., 2013.&lt;/li>
&lt;li>“&lt;a href="http://www.rethinkdb.com/docs/" target="_blank" rel="noopener">RethinkDB 1.11 Documentation&lt;/a>,” &lt;em>rethinkdb.com&lt;/em>, 2013.&lt;/li>
&lt;li>“&lt;a href="http://docs.couchdb.org/en/latest/" target="_blank" rel="noopener">Apache CouchDB 1.6 Documentation&lt;/a>,” &lt;em>docs.couchdb.org&lt;/em>, 2014.&lt;/li>
&lt;li>Lin Qiao, Kapil Surlaker, Shirshanka Das, et al.: “&lt;a href="http://www.slideshare.net/amywtang/espresso-20952131" target="_blank" rel="noopener">On Brewing Fresh Espresso: LinkedIn’s Distributed Data Serving Platform&lt;/a>,” at &lt;em>ACM International Conference on Management of Data&lt;/em> (SIGMOD), June 2013.&lt;/li>
&lt;li>Rick Long, Mark Harrington, Robert Hain, and Geoff Nicholls: &lt;a href="http://www.redbooks.ibm.com/redbooks/pdfs/sg245352.pdf" target="_blank" rel="noopener">&lt;em>IMS Primer&lt;/em>&lt;/a>. IBM Redbook SG24-5352-00, IBM International Technical Support Organization, January 2000.&lt;/li>
&lt;li>Stephen D. Bartlett: “&lt;a href="ftp://public.dhe.ibm.com/software/data/ims/pdf/TCG2013015LI.pdf">IBM’s IMS—Myths, Realities, and Opportunities&lt;/a>,” The Clipper Group Navigator, TCG2013015LI, July 2013.&lt;/li>
&lt;li>Sarah Mei: “&lt;a href="http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/" target="_blank" rel="noopener">Why You Should Never Use MongoDB&lt;/a>,” &lt;em>sarahmei.com&lt;/em>, November 11, 2013.&lt;/li>
&lt;li>J. S. Knowles and D. M. R. Bell: “The CODASYL Model,” in &lt;em>Databases—Role and Structure: An Advanced Course&lt;/em>, edited by P. M. Stocker, P. M. D. Gray, and M. P. Atkinson, pages 19–56, Cambridge University Press, 1984. ISBN: 978-0-521-25430-4&lt;/li>
&lt;li>Charles W. Bachman: “&lt;a href="http://dl.acm.org/citation.cfm?id=362534" target="_blank" rel="noopener">The Programmer as Navigator&lt;/a>,” &lt;em>Communications of the ACM&lt;/em>, volume 16, number 11, pages 653–658, November 1973. &lt;a href="http://dx.doi.org/10.1145/355611.362534" target="_blank" rel="noopener">doi:10.1145/355611.362534&lt;/a>&lt;/li>
&lt;li>Joseph M. Hellerstein, Michael Stonebraker, and James Hamilton: “&lt;a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" target="_blank" rel="noopener">Architecture of a Database System&lt;/a>,” &lt;em>Foundations and Trends in Databases&lt;/em>, volume 1, number 2, pages 141–259, November 2007. &lt;a href="http://dx.doi.org/10.1561/1900000002" target="_blank" rel="noopener">doi:10.1561/1900000002&lt;/a>&lt;/li>
&lt;li>Sandeep Parikh and Kelly Stirman: “&lt;a href="http://blog.mongodb.org/post/65517193370/schema-design-for-time-series-data-in-mongodb" target="_blank" rel="noopener">Schema Design for Time Series Data in MongoDB&lt;/a>,” &lt;em>blog.mongodb.org&lt;/em>, October 30, 2013.&lt;/li>
&lt;li>Martin Fowler: “&lt;a href="http://martinfowler.com/articles/schemaless/" target="_blank" rel="noopener">Schemaless Data Structures&lt;/a>,” &lt;em>martinfowler.com&lt;/em>, January 7, 2013.&lt;/li>
&lt;li>Amr Awadallah: “&lt;a href="http://www.slideshare.net/awadallah/schemaonread-vs-schemaonwrite" target="_blank" rel="noopener">Schema-on-Read vs. Schema-on-Write&lt;/a>,” at &lt;em>Berkeley EECS RAD Lab Retreat&lt;/em>, Santa Cruz, CA, May 2009.&lt;/li>
&lt;li>Martin Odersky: “&lt;a href="http://www.infoq.com/presentations/data-types-issues" target="_blank" rel="noopener">The Trouble with Types&lt;/a>,” at &lt;em>Strange Loop&lt;/em>, September 2013.&lt;/li>
&lt;li>Conrad Irwin: “&lt;a href="https://speakerdeck.com/conradirwin/mongodb-confessions-of-a-postgresql-lover" target="_blank" rel="noopener">MongoDB—Confessions of a PostgreSQL Lover&lt;/a>,” at &lt;em>HTML5DevConf&lt;/em>, October 2013.&lt;/li>
&lt;li>“&lt;a href="http://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html" target="_blank" rel="noopener">Percona Toolkit Documentation: pt-online-schema-change&lt;/a>,” Percona Ireland Ltd., 2013.&lt;/li>
&lt;li>Rany Keddo, Tobias Bielohlawek, and Tobias Schmidt: “&lt;a href="https://github.com/soundcloud/lhm" target="_blank" rel="noopener">Large Hadron Migrator&lt;/a>,” SoundCloud, 2013. Shlomi Noach: “&lt;a href="http://githubengineering.com/gh-ost-github-s-online-migration-tool-for-mysql/" target="_blank" rel="noopener">gh-ost: GitHub&amp;rsquo;s Online Schema Migration Tool for MySQL&lt;/a>,” &lt;em>githubengineering.com&lt;/em>, August 1, 2016.&lt;/li>
&lt;li>James C. Corbett, Jeffrey Dean, Michael Epstein, et al.: “&lt;a href="http://research.google.com/archive/spanner.html" target="_blank" rel="noopener">Spanner: Google’s Globally-Distributed Database&lt;/a>,” at &lt;em>10th USENIX Symposium on Operating System Design and Implementation&lt;/em> (OSDI), October 2012.&lt;/li>
&lt;li>Donald K. Burleson: “&lt;a href="http://www.dba-oracle.com/oracle_tip_hash_index_cluster_table.htm" target="_blank" rel="noopener">Reduce I/O with Oracle Cluster Tables&lt;/a>,” &lt;em>dba-oracle.com&lt;/em>.&lt;/li>
&lt;li>Fay Chang, Jeffrey Dean, Sanjay Ghemawat, et al.: “&lt;a href="http://research.google.com/archive/bigtable.html" target="_blank" rel="noopener">Bigtable: A Distributed Storage System for Structured Data&lt;/a>,” at &lt;em>7th USENIX Symposium on Operating System Design and Implementation&lt;/em> (OSDI), November 2006.&lt;/li>
&lt;li>Bobbie J. Cochrane and Kathy A. McKnight: “&lt;a href="http://www.ibm.com/developerworks/data/library/techarticle/dm-1306nosqlforjson1/" target="_blank" rel="noopener">DB2 JSON Capabilities, Part 1: Introduction to DB2 JSON&lt;/a>,” IBM developerWorks, June 20, 2013.&lt;/li>
&lt;li>Herb Sutter: “&lt;a href="http://www.gotw.ca/publications/concurrency-ddj.htm" target="_blank" rel="noopener">The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software&lt;/a>,” &lt;em>Dr. Dobb&amp;rsquo;s Journal&lt;/em>, volume 30, number 3, pages 202-210, March 2005.&lt;/li>
&lt;li>Joseph M. Hellerstein: “&lt;a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf" target="_blank" rel="noopener">The Declarative Imperative: Experiences and Conjectures in Distributed Logic&lt;/a>,” Electrical Engineering and Computer Sciences, University of California at Berkeley, Tech report UCB/EECS-2010-90, June 2010.&lt;/li>
&lt;li>Jeffrey Dean and Sanjay Ghemawat: “&lt;a href="http://research.google.com/archive/mapreduce.html" target="_blank" rel="noopener">MapReduce: Simplified Data Processing on Large Clusters&lt;/a>,” at &lt;em>6th USENIX Symposium on Operating System Design and Implementation&lt;/em> (OSDI), December 2004.&lt;/li>
&lt;li>Craig Kerstiens: “&lt;a href="https://blog.heroku.com/javascript_in_your_postgres" target="_blank" rel="noopener">JavaScript in Your Postgres&lt;/a>,” &lt;em>blog.heroku.com&lt;/em>, June 5, 2013.&lt;/li>
&lt;li>Nathan Bronson, Zach Amsden, George Cabrera, et al.: “&lt;a href="https://www.usenix.org/conference/atc13/technical-sessions/presentation/bronson" target="_blank" rel="noopener">TAO: Facebook’s Distributed Data Store for the Social Graph&lt;/a>,” at &lt;em>USENIX Annual Technical Conference&lt;/em> (USENIX ATC), June 2013.&lt;/li>
&lt;li>“&lt;a href="http://tinkerpop.apache.org/docs/3.2.3/reference/" target="_blank" rel="noopener">Apache TinkerPop3.2.3 Documentation&lt;/a>,” &lt;em>tinkerpop.apache.org&lt;/em>, October 2016.&lt;/li>
&lt;li>“&lt;a href="http://docs.neo4j.org/chunked/2.0.0/index.html" target="_blank" rel="noopener">The Neo4j Manual v2.0.0&lt;/a>,” Neo Technology, 2013. Emil Eifrem: &lt;a href="https://twitter.com/emileifrem/status/419107961512804352" target="_blank" rel="noopener">Twitter correspondence&lt;/a>, January 3, 2014.&lt;/li>
&lt;li>David Beckett and Tim Berners-Lee: “&lt;a href="http://www.w3.org/TeamSubmission/turtle/" target="_blank" rel="noopener">Turtle – Terse RDF Triple Language&lt;/a>,” W3C Team Submission, March 28, 2011.&lt;/li>
&lt;li>“&lt;a href="http://docs.datomic.com/" target="_blank" rel="noopener">Datomic Development Resources&lt;/a>,” Metadata Partners, LLC, 2013. W3C RDF Working Group: “&lt;a href="http://www.w3.org/RDF/" target="_blank" rel="noopener">Resource Description Framework (RDF)&lt;/a>,” &lt;em>w3.org&lt;/em>, 10 February 2004.&lt;/li>
&lt;li>“&lt;a href="http://jena.apache.org/" target="_blank" rel="noopener">Apache Jena&lt;/a>,” Apache Software Foundation.&lt;/li>
&lt;li>Steve Harris, Andy Seaborne, and Eric Prud&amp;rsquo;hommeaux: “&lt;a href="http://www.w3.org/TR/sparql11-query/" target="_blank" rel="noopener">SPARQL 1.1 Query Language&lt;/a>,” W3C Recommendation, March 2013.&lt;/li>
&lt;li>Todd J. Green, Shan Shan Huang, Boon Thau Loo, and Wenchao Zhou: “&lt;a href="http://blogs.evergreen.edu/sosw/files/2014/04/Green-Vol5-DBS-017.pdf" target="_blank" rel="noopener">Datalog and Recursive Query Processing&lt;/a>,” &lt;em>Foundations and Trends in Databases&lt;/em>, volume 5, number 2, pages 105–195, November 2013. &lt;a href="http://dx.doi.org/10.1561/1900000017" target="_blank" rel="noopener">doi:10.1561/1900000017&lt;/a>&lt;/li>
&lt;li>Stefano Ceri, Georg Gottlob, and Letizia Tanca: “&lt;a href="https://www.researchgate.net/profile/Letizia_Tanca/publication/3296132_What_you_always_wanted_to_know_about_Datalog_and_never_dared_to_ask/links/0fcfd50ca2d20473ca000000.pdf" target="_blank" rel="noopener">What You Always Wanted to Know About Datalog (And Never Dared to Ask)&lt;/a>,” &lt;em>IEEE Transactions on Knowledge and Data Engineering&lt;/em>, volume 1, number 1, pages 146–166, March 1989. &lt;a href="http://dx.doi.org/10.1109/69.43410" target="_blank" rel="noopener">doi:10.1109/69.43410&lt;/a>&lt;/li>
&lt;li>Serge Abiteboul, Richard Hull, and Victor Vianu: &lt;a href="http://webdam.inria.fr/Alice/" target="_blank" rel="noopener">&lt;em>Foundations of Databases&lt;/em>&lt;/a>. Addison-Wesley, 1995. ISBN: 978-0-201-53771-0, available online at &lt;em>webdam.inria.fr/Alice&lt;/em>&lt;/li>
&lt;li>Nathan Marz: “&lt;a href="http://cascalog.org/" target="_blank" rel="noopener">Cascalog&lt;/a>,&amp;quot; &lt;em>cascalog.org&lt;/em>. Dennis A. Benson, Ilene Karsch-Mizrachi, David J. Lipman, et al.: “&lt;a href="http://nar.oxfordjournals.org/content/36/suppl_1/D25.full-text-lowres.pdf" target="_blank" rel="noopener">GenBank&lt;/a>,” &lt;em>Nucleic Acids Research&lt;/em>, volume 36, Database issue, pages D25–D30, December 2007. &lt;a href="http://dx.doi.org/10.1093/nar/gkm929" target="_blank" rel="noopener">doi:10.1093/nar/gkm929&lt;/a>&lt;/li>
&lt;li>Fons Rademakers: “&lt;a href="http://indico.cern.ch/getFile.py/access?contribId=13&amp;amp;resId=0&amp;amp;materialId=slides&amp;amp;confId=246453" target="_blank" rel="noopener">ROOT for Big Data Analysis&lt;/a>,” at &lt;em>Workshop on the Future of Big Data Management&lt;/em>, London, UK, June 2013.&lt;/li>
&lt;/ol>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>关于关系模型的文献区分了几种不同的规范形式，但这些区别几乎没有实际意义。一个经验法则是，如果重复存储了可以存储在一个地方的值，则模式就不是 &lt;strong>规范化（normalized）&lt;/strong> 的。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>在撰写本文时，RethinkDB 支持连接，MongoDB 不支持连接，而 CouchDB 只支持预先声明的视图。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>外键约束允许对修改进行限制，但对于关系模型这并不是必选项。即使有约束，外键连接在查询时执行，而在 CODASYL 中，连接在插入时高效完成。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>Codd 对关系模型【1】的原始描述实际上允许在关系模式中与 JSON 文档非常相似。他称之为 &lt;strong>非简单域（nonsimple domains）&lt;/strong>。这个想法是，一行中的值不一定是一个像数字或字符串一样的原始数据类型，也可以是一个嵌套的关系（表），因此可以把一个任意嵌套的树结构作为一个值，这很像 30 年后添加到 SQL 中的 JSON 或 XML 支持。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>IMS 和 CODASYL 都使用命令式 API。应用程序通常使用 COBOL 代码遍历数据库中的记录，一次一条记录【2,16】。&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>从技术上讲，Datomic 使用的是五元组而不是三元组，两个额外的字段是用于版本控制的元数据&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>Datomic 和 Cascalog 使用 Datalog 的 Clojure S 表达式语法。在下面的例子中使用了一个更容易阅读的 Prolog 语法，但两者没有任何功能差异。&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>第一章：可靠性、可伸缩性和可维护性</title><link>https://ng-tech.icu/books/dataengineering-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/designing-data-intensive-application/1.%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E5%92%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/dataengineering-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/designing-data-intensive-application/1.%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E5%92%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7/</guid><description>&lt;h1 id="第一章可靠性可伸缩性和可维护性httpsvonnggithubioddiach1id第一章可靠性可伸缩性和可维护性">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e7%ac%ac%e4%b8%80%e7%ab%a0%ef%bc%9a%e5%8f%af%e9%9d%a0%e6%80%a7%e3%80%81%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7%e5%92%8c%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7" target="_blank" rel="noopener">第一章：可靠性、可伸缩性和可维护性&lt;/a>&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/ch1.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>互联网做得太棒了，以至于大多数人将它看作像太平洋这样的自然资源，而不是什么人工产物。上一次出现这种大规模且无差错的技术， 你还记得是什么时候吗？&lt;/p>
&lt;p>—— &lt;a href="http://www.drdobbs.com/architecture-and-design/interview-with-alan-kay/240003442" target="_blank" rel="noopener">艾伦・凯&lt;/a> 在接受 Dobb 博士杂志采访时说（2012 年）&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>[TOC]&lt;/p>
&lt;p>现今很多应用程序都是 &lt;strong>数据密集型（data-intensive）&lt;/strong> 的，而非 &lt;strong>计算密集型（compute-intensive）&lt;/strong> 的。因此 CPU 很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。&lt;/p>
&lt;p>数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：&lt;/p>
&lt;ul>
&lt;li>存储数据，以便自己或其他应用程序之后能再次找到 （&lt;em>数据库，即 databases&lt;/em>）&lt;/li>
&lt;li>记住开销昂贵操作的结果，加快读取速度（&lt;em>缓存，即 caches&lt;/em>）&lt;/li>
&lt;li>允许用户按关键字搜索数据，或以各种方式对数据进行过滤（&lt;em>搜索索引，即 search indexes&lt;/em>）&lt;/li>
&lt;li>向其他进程发送消息，进行异步处理（&lt;em>流处理，即 stream processing&lt;/em>）&lt;/li>
&lt;li>定期处理累积的大批量数据（&lt;em>批处理，即 batch processing&lt;/em>）&lt;/li>
&lt;/ul>
&lt;p>如果这些功能听上去平淡无奇，那是因为这些 &lt;strong>数据系统（data system）&lt;/strong> 是非常成功的抽象：我们一直不假思索地使用它们并习以为常。绝大多数工程师不会幻想从零开始编写存储引擎，因为在开发应用时，数据库已经是足够完美的工具了。&lt;/p>
&lt;p>但现实没有这么简单。不同的应用有着不同的需求，因而数据库系统也是百花齐放，有着各式各样的特性。实现缓存有很多种手段，创建搜索索引也有好几种方法，诸如此类。因此在开发应用前，我们依然有必要先弄清楚最适合手头工作的工具和方法。而且当单个工具解决不了你的问题时，组合使用这些工具可能还是有些难度的。&lt;/p>
&lt;p>本书将是一趟关于数据系统原理、实践与应用的旅程，并讲述了设计数据密集型应用的方法。我们将探索不同工具之间的共性与特性，以及各自的实现原理。&lt;/p>
&lt;p>本章将从我们所要实现的基础目标开始：可靠、可伸缩、可维护的数据系统。我们将澄清这些词语的含义，概述考量这些目标的方法。并回顾一些后续章节所需的基础知识。在接下来的章节中我们将抽丝剥茧，研究设计数据密集型应用时可能遇到的设计决策。&lt;/p>
&lt;h2 id="关于数据系统的思考httpsvonnggithubioddiach1id关于数据系统的思考">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%85%b3%e4%ba%8e%e6%95%b0%e6%8d%ae%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%80%9d%e8%80%83" target="_blank" rel="noopener">关于数据系统的思考&lt;/a>&lt;/h2>
&lt;p>我们通常认为，数据库、消息队列、缓存等工具分属于几个差异显著的类别。虽然数据库和消息队列表面上有一些相似性 —— 它们都会存储一段时间的数据 —— 但它们有迥然不同的访问模式，这意味着迥异的性能特征和实现手段。&lt;/p>
&lt;p>那我们为什么要把这些东西放在 &lt;strong>数据系统（data system）&lt;/strong> 的总称之下混为一谈呢？&lt;/p>
&lt;p>近些年来，出现了许多新的数据存储工具与数据处理工具。它们针对不同应用场景进行优化，因此不再适合生硬地归入传统类别【1】。类别之间的界限变得越来越模糊，例如：数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）。&lt;/p>
&lt;p>其次，越来越多的应用程序有着各种严格而广泛的要求，单个工具不足以满足所有的数据处理和存储需求。取而代之的是，总体工作被拆分成一系列能被单个工具高效完成的任务，并通过应用代码将它们缝合起来。&lt;/p>
&lt;p>例如，如果将缓存（应用管理的缓存层，Memcached 或同类产品）和全文搜索（全文搜索服务器，例如 Elasticsearch 或 Solr）功能从主数据库剥离出来，那么使缓存 / 索引与主数据库保持同步通常是应用代码的责任。&lt;a href="https://vonng.github.io/ddia/#/img/fig1-1.png" target="_blank" rel="noopener">图 1-1&lt;/a> 给出了这种架构可能的样子（细节将在后面的章节中详细介绍）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig1-1.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 1-1 一个可能的组合使用多个组件的数据系统架构&lt;/strong>&lt;/p>
&lt;p>当你将多个工具组合在一起提供服务时，服务的接口或 &lt;strong>应用程序编程接口（API, Application Programming Interface）&lt;/strong> 通常向客户端隐藏这些实现细节。现在，你基本上已经使用较小的通用组件创建了一个全新的、专用的数据系统。这个新的复合数据系统可能会提供特定的保证，例如：缓存在写入时会作废或更新，以便外部客户端获取一致的结果。现在你不仅是应用程序开发人员，还是数据系统设计人员了。&lt;/p>
&lt;p>设计数据系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保数据的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好性能？当负载增加时，如何扩容应对？什么样的 API 才是好的 API？&lt;/p>
&lt;p>影响数据系统设计的因素很多，包括参与人员的技能和经验、历史遗留问题、系统路径依赖、交付时限、公司的风险容忍度、监管约束等，这些因素都需要具体问题具体分析。&lt;/p>
&lt;p>本书着重讨论三个在大多数软件系统中都很重要的问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可靠性（Reliability）&lt;/p>
&lt;p>系统在 &lt;strong>困境&lt;/strong>（adversity，比如硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。请参阅 “&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e9%9d%a0%e6%80%a7" target="_blank" rel="noopener">可靠性&lt;/a>”。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可伸缩性（Scalability）&lt;/p>
&lt;p>有合理的办法应对系统的增长（数据量、流量、复杂性）。请参阅 “&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7" target="_blank" rel="noopener">可伸缩性&lt;/a>”。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可维护性（Maintainability）&lt;/p>
&lt;p>许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。请参阅 “&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7" target="_blank" rel="noopener">可维护性&lt;/a>”。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>人们经常追求这些词汇，却没有清楚理解它们到底意味着什么。为了工程的严谨性，本章的剩余部分将探讨可靠性、可伸缩性和可维护性的含义。为实现这些目标而使用的各种技术，架构和算法将在后续的章节中研究。&lt;/p>
&lt;h2 id="可靠性httpsvonnggithubioddiach1id可靠性">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e9%9d%a0%e6%80%a7" target="_blank" rel="noopener">可靠性&lt;/a>&lt;/h2>
&lt;p>人们对于一个东西是否可靠，都有一个直观的想法。人们对可靠软件的典型期望包括：&lt;/p>
&lt;ul>
&lt;li>应用程序表现出用户所期望的功能。&lt;/li>
&lt;li>允许用户犯错，允许用户以出乎意料的方式使用软件。&lt;/li>
&lt;li>在预期的负载和数据量下，性能满足要求。&lt;/li>
&lt;li>系统能防止未经授权的访问和滥用。&lt;/li>
&lt;/ul>
&lt;p>如果所有这些在一起意味着 “正确工作”，那么可以把可靠性粗略理解为 “即使出现问题，也能继续正确工作”。&lt;/p>
&lt;p>造成错误的原因叫做 &lt;strong>故障（fault）&lt;/strong>，能预料并应对故障的系统特性可称为 &lt;strong>容错（fault-tolerant）&lt;/strong> 或 &lt;strong>韧性（resilient）&lt;/strong>。“&lt;strong>容错&lt;/strong>” 一词可能会产生误导，因为它暗示着系统可以容忍所有可能的错误，但在实际中这是不可能的。比方说，如果整个地球（及其上的所有服务器）都被黑洞吞噬了，想要容忍这种错误，需要把网络托管到太空中 —— 这种预算能不能批准就祝你好运了。所以在讨论容错时，只有谈论特定类型的错误才有意义。&lt;/p>
&lt;p>注意 &lt;strong>故障（fault）&lt;/strong> 不同于 &lt;strong>失效（failure）&lt;/strong>【2】。&lt;strong>故障&lt;/strong> 通常定义为系统的一部分状态偏离其标准，而 &lt;strong>失效&lt;/strong> 则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因 &lt;strong>故障&lt;/strong> 而导致 &lt;strong>失效&lt;/strong>。本书中我们将介绍几种用不可靠的部件构建可靠系统的技术。&lt;/p>
&lt;p>反直觉的是，在这类容错系统中，通过故意触发来 &lt;strong>提高&lt;/strong> 故障率是有意义的，例如：在没有警告的情况下随机地杀死单个进程。许多高危漏洞实际上是由糟糕的错误处理导致的【3】，因此我们可以通过故意引发故障来确保容错机制不断运行并接受考验，从而提高故障自然发生时系统能正确处理的信心。Netflix 公司的 &lt;em>Chaos Monkey&lt;/em>【4】就是这种方法的一个例子。&lt;/p>
&lt;p>尽管比起 &lt;strong>阻止错误（prevent error）&lt;/strong>，我们通常更倾向于 &lt;strong>容忍错误&lt;/strong>。但也有 &lt;strong>预防胜于治疗&lt;/strong> 的情况（比如不存在治疗方法时）。安全问题就属于这种情况。例如，如果攻击者破坏了系统，并获取了敏感数据，这种事是撤销不了的。但本书主要讨论的是可以恢复的故障种类，正如下面几节所述。&lt;/p>
&lt;h3 id="硬件故障httpsvonnggithubioddiach1id硬件故障">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e7%a1%ac%e4%bb%b6%e6%95%85%e9%9a%9c" target="_blank" rel="noopener">硬件故障&lt;/a>&lt;/h3>
&lt;p>当想到系统失效的原因时，&lt;strong>硬件故障（hardware faults）&lt;/strong> 总会第一个进入脑海。硬盘崩溃、内存出错、机房断电、有人拔错网线…… 任何与大型数据中心打过交道的人都会告诉你：一旦你拥有很多机器，这些事情 &lt;strong>总&lt;/strong> 会发生！&lt;/p>
&lt;p>据报道称，硬盘的 &lt;strong>平均无故障时间（MTTF, mean time to failure）&lt;/strong> 约为 10 到 50 年【5】【6】。因此从数学期望上讲，在拥有 10000 个磁盘的存储集群上，平均每天会有 1 个磁盘出故障。&lt;/p>
&lt;p>为了减少系统的故障率，第一反应通常都是增加单个硬件的冗余度，例如：磁盘可以组建 RAID，服务器可能有双路电源和热插拔 CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。这种方法虽然不能完全防止由硬件问题导致的系统失效，但它简单易懂，通常也足以让机器不间断运行很多年。&lt;/p>
&lt;p>直到最近，硬件冗余对于大多数应用来说已经足够了，它使单台机器完全失效变得相当罕见。只要你能快速地把备份恢复到新机器上，故障停机时间对大多数应用而言都算不上灾难性的。只有少量高可用性至关重要的应用才会要求有多套硬件冗余。&lt;/p>
&lt;p>但是随着数据量和应用计算需求的增加，越来越多的应用开始大量使用机器，这会相应地增加硬件故障率。此外，在类似亚马逊 AWS（Amazon Web Services）的一些云服务平台上，虚拟机实例不可用却没有任何警告也是很常见的【7】，因为云平台的设计就是优先考虑 &lt;strong>灵活性（flexibility）&lt;/strong> 和 &lt;strong>弹性（elasticity）&lt;/strong>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，而不是单机可靠性。&lt;/p>
&lt;p>如果在硬件冗余的基础上进一步引入软件容错机制，那么系统在容忍整个（单台）机器故障的道路上就更进一步了。这样的系统也有运维上的便利，例如：如果需要重启机器（例如应用操作系统安全补丁），单服务器系统就需要计划停机。而允许机器失效的系统则可以一次修复一个节点，无需整个系统停机。&lt;/p>
&lt;h3 id="软件错误httpsvonnggithubioddiach1id软件错误">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e8%bd%af%e4%bb%b6%e9%94%99%e8%af%af" target="_blank" rel="noopener">软件错误&lt;/a>&lt;/h3>
&lt;p>我们通常认为硬件故障是随机的、相互独立的：一台机器的磁盘失效并不意味着另一台机器的磁盘也会失效。虽然大量硬件组件之间可能存在微弱的相关性（例如服务器机架的温度等共同的原因），但同时发生故障也是极为罕见的。&lt;/p>
&lt;p>另一类错误是内部的 &lt;strong>系统性错误（systematic error）&lt;/strong>【8】。这类错误难以预料，而且因为是跨节点相关的，所以比起不相关的硬件故障往往可能造成更多的 &lt;strong>系统失效&lt;/strong>【5】。例子包括：&lt;/p>
&lt;ul>
&lt;li>接受特定的错误输入，便导致所有应用服务器实例崩溃的 BUG。例如 2012 年 6 月 30 日的闰秒，由于 Linux 内核中的一个错误【9】，许多应用同时挂掉了。&lt;/li>
&lt;li>失控进程会用尽一些共享资源，包括 CPU 时间、内存、磁盘空间或网络带宽。&lt;/li>
&lt;li>系统依赖的服务变慢，没有响应，或者开始返回错误的响应。&lt;/li>
&lt;li>级联故障，一个组件中的小故障触发另一个组件中的故障，进而触发更多的故障【10】。&lt;/li>
&lt;/ul>
&lt;p>导致这类软件故障的 BUG 通常会潜伏很长时间，直到被异常情况触发为止。这种情况意味着软件对其环境做出了某种假设 —— 虽然这种假设通常来说是正确的，但由于某种原因最后不再成立了【11】。&lt;/p>
&lt;p>虽然软件中的系统性故障没有速效药，但我们还是有很多小办法，例如：仔细考虑系统中的假设和交互；彻底的测试；进程隔离；允许进程崩溃并重启；测量、监控并分析生产环境中的系统行为。如果系统能够提供一些保证（例如在一个消息队列中，进入与发出的消息数量相等），那么系统就可以在运行时不断自检，并在出现 &lt;strong>差异（discrepancy）&lt;/strong> 时报警【12】。&lt;/p>
&lt;h3 id="人为错误httpsvonnggithubioddiach1id人为错误">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e4%ba%ba%e4%b8%ba%e9%94%99%e8%af%af" target="_blank" rel="noopener">人为错误&lt;/a>&lt;/h3>
&lt;p>设计并构建了软件系统的工程师是人类，维持系统运行的运维也是人类。即使他们怀有最大的善意，人类也是不可靠的。举个例子，一项关于大型互联网服务的研究发现，运维配置错误是导致服务中断的首要原因，而硬件故障（服务器或网络）仅导致了 10-25% 的服务中断【13】。&lt;/p>
&lt;p>尽管人类不可靠，但怎么做才能让系统变得可靠？最好的系统会组合使用以下几种办法：&lt;/p>
&lt;ul>
&lt;li>以最小化犯错机会的方式设计系统。例如，精心设计的抽象、API 和管理后台使做对事情更容易，搞砸事情更困难。但如果接口限制太多，人们就会忽略它们的好处而想办法绕开。很难正确把握这种微妙的平衡。&lt;/li>
&lt;li>将人们最容易犯错的地方与可能导致失效的地方 &lt;strong>解耦（decouple）&lt;/strong>。特别是提供一个功能齐全的非生产环境 &lt;strong>沙箱（sandbox）&lt;/strong>，使人们可以在不影响真实用户的情况下，使用真实数据安全地探索和实验。&lt;/li>
&lt;li>在各个层次进行彻底的测试【3】，从单元测试、全系统集成测试到手动测试。自动化测试易于理解，已经被广泛使用，特别适合用来覆盖正常情况中少见的 &lt;strong>边缘场景（corner case）&lt;/strong>。&lt;/li>
&lt;li>允许从人为错误中简单快速地恢复，以最大限度地减少失效情况带来的影响。 例如，快速回滚配置变更，分批发布新代码（以便任何意外错误只影响一小部分用户），并提供数据重算工具（以备旧的计算出错）。&lt;/li>
&lt;li>配置详细和明确的监控，比如性能指标和错误率。 在其他工程学科中这指的是 &lt;strong>遥测（telemetry）&lt;/strong>（一旦火箭离开了地面，遥测技术对于跟踪发生的事情和理解失败是至关重要的）。监控可以向我们发出预警信号，并允许我们检查是否有任何地方违反了假设和约束。当出现问题时，指标数据对于问题诊断是非常宝贵的。&lt;/li>
&lt;li>良好的管理实践与充分的培训 —— 一个复杂而重要的方面，但超出了本书的范围。&lt;/li>
&lt;/ul>
&lt;h3 id="可靠性有多重要httpsvonnggithubioddiach1id可靠性有多重要">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e9%9d%a0%e6%80%a7%e6%9c%89%e5%a4%9a%e9%87%8d%e8%a6%81%ef%bc%9f" target="_blank" rel="noopener">可靠性有多重要？&lt;/a>&lt;/h3>
&lt;p>可靠性不仅仅是针对核电站和空中交通管制软件而言，我们也期望更多平凡的应用能可靠地运行。商务应用中的错误会导致生产力损失（也许数据报告不完整还会有法律风险），而电商网站的中断则可能会导致收入和声誉的巨大损失。&lt;/p>
&lt;p>即使在 “非关键” 应用中，我们也对用户负有责任。试想一位家长把所有的照片和孩子的视频储存在你的照片应用里【15】。如果数据库突然损坏，他们会感觉如何？他们可能会知道如何从备份恢复吗？&lt;/p>
&lt;p>在某些情况下，我们可能会选择牺牲可靠性来降低开发成本（例如为未经证实的市场开发产品原型）或运营成本（例如利润率极低的服务），但我们偷工减料时，应该清楚意识到自己在做什么。&lt;/p>
&lt;h2 id="可伸缩性httpsvonnggithubioddiach1id可伸缩性">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7" target="_blank" rel="noopener">可伸缩性&lt;/a>&lt;/h2>
&lt;p>系统今天能可靠运行，并不意味未来也能可靠运行。服务 &lt;strong>降级（degradation）&lt;/strong> 的一个常见原因是负载增加，例如：系统负载已经从一万个并发用户增长到十万个并发用户，或者从一百万增长到一千万。也许现在处理的数据量级要比过去大得多。&lt;/p>
&lt;p>&lt;strong>可伸缩性（Scalability）&lt;/strong> 是用来描述系统应对负载增长能力的术语。但是请注意，这不是贴在系统上的一维标签：说 “X 可伸缩” 或 “Y 不可伸缩” 是没有任何意义的。相反，讨论可伸缩性意味着考虑诸如 “如果系统以特定方式增长，有什么选项可以应对增长？” 和 “如何增加计算资源来处理额外的负载？” 等问题。&lt;/p>
&lt;h3 id="描述负载httpsvonnggithubioddiach1id描述负载">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e6%8f%8f%e8%bf%b0%e8%b4%9f%e8%bd%bd" target="_blank" rel="noopener">描述负载&lt;/a>&lt;/h3>
&lt;p>在讨论增长问题（如果负载加倍会发生什么？）前，首先要能简要描述系统的当前负载。负载可以用一些称为 &lt;strong>负载参数（load parameters）&lt;/strong> 的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向 Web 服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况对你很重要，也许你的瓶颈是少数极端场景。&lt;/p>
&lt;p>为了使这个概念更加具体，我们以推特在 2012 年 11 月发布的数据【16】为例。推特的两个主要业务是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>发布推文&lt;/p>
&lt;p>用户可以向其粉丝发布新消息（平均 4.6k 请求 / 秒，峰值超过 12k 请求 / 秒）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主页时间线&lt;/p>
&lt;p>用户可以查阅他们关注的人发布的推文（300k 请求 / 秒）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>处理每秒 12,000 次写入（发推文的速率峰值）还是很简单的。然而推特的伸缩性挑战并不是主要来自推特量，而是来自 &lt;strong>扇出（fan-out）&lt;/strong>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>—— 每个用户关注了很多人，也被很多人关注。&lt;/p>
&lt;p>大体上讲，这一对操作有两种实现方式。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>发布推文时，只需将新推文插入全局推文集合即可。当一个用户请求自己的主页时间线时，首先查找他关注的所有人，查询这些被关注用户发布的推文并按时间顺序合并。在如 &lt;a href="https://vonng.github.io/ddia/#/img/fig1-2.png" target="_blank" rel="noopener">图 1-2&lt;/a> 所示的关系型数据库中，可以编写这样的查询：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tweets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sender_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">followee_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">users&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">follows&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">follower_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">current_user&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig1-2.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 1-2 推特主页时间线的关系型模式简单实现&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为每个用户的主页时间线维护一个缓存，就像每个用户的推文收件箱（&lt;a href="https://vonng.github.io/ddia/#/img/fig1-3.png" target="_blank" rel="noopener">图 1-3&lt;/a>）。 当一个用户发布推文时，查找所有关注该用户的人，并将新的推文插入到每个主页时间线缓存中。 因此读取主页时间线的请求开销很小，因为结果已经提前计算好了。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig1-3.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 1-3 用于分发推特至关注者的数据流水线，2012 年 11 月的负载参数【16】&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>推特的第一个版本使用了方法 1，但系统很难跟上主页时间线查询的负载。所以公司转向了方法 2，方法 2 的效果更好，因为发推频率比查询主页时间线的频率几乎低了两个数量级，所以在这种情况下，最好在写入时做更多的工作，而在读取时做更少的工作。&lt;/p>
&lt;p>然而方法 2 的缺点是，发推现在需要大量的额外工作。平均来说，一条推文会发往约 75 个关注者，所以每秒 4.6k 的发推写入，变成了对主页时间线缓存每秒 345k 的写入。但这个平均值隐藏了用户粉丝数差异巨大这一现实，一些用户有超过 3000 万的粉丝，这意味着一条推文就可能会导致主页时间线缓存的 3000 万次写入！及时完成这种操作是一个巨大的挑战 —— 推特尝试在 5 秒内向粉丝发送推文。&lt;/p>
&lt;p>在推特的例子中，每个用户粉丝数的分布（可能按这些用户的发推频率来加权）是探讨可伸缩性的一个关键负载参数，因为它决定了扇出负载。你的应用程序可能具有非常不同的特征，但可以采用相似的原则来考虑它的负载。&lt;/p>
&lt;p>推特轶事的最终转折：现在已经稳健地实现了方法 2，推特逐步转向了两种方法的混合。大多数用户发的推文会被扇出写入其粉丝主页时间线缓存中。但是少数拥有海量粉丝的用户（即名流）会被排除在外。当用户读取主页时间线时，分别地获取出该用户所关注的每位名流的推文，再与用户的主页时间线缓存合并，如方法 1 所示。这种混合方法能始终如一地提供良好性能。在 &lt;a href="https://vonng.github.io/ddia/#/ch12" target="_blank" rel="noopener">第十二章&lt;/a> 中我们将重新讨论这个例子，这在覆盖更多技术层面之后。&lt;/p>
&lt;h3 id="描述性能httpsvonnggithubioddiach1id描述性能">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e6%8f%8f%e8%bf%b0%e6%80%a7%e8%83%bd" target="_blank" rel="noopener">描述性能&lt;/a>&lt;/h3>
&lt;p>一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：&lt;/p>
&lt;ul>
&lt;li>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？&lt;/li>
&lt;li>增加负载参数并希望保持性能不变时，需要增加多少系统资源？&lt;/li>
&lt;/ul>
&lt;p>这两个问题都需要性能数据，所以让我们简单地看一下如何描述系统性能。&lt;/p>
&lt;p>对于 Hadoop 这样的批处理系统，通常关心的是 &lt;strong>吞吐量（throughput）&lt;/strong>，即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。对于在线系统，通常更重要的是服务的 &lt;strong>响应时间（response time）&lt;/strong>，即客户端发送请求到接收响应之间的时间。&lt;/p>
&lt;blockquote>
&lt;h4 id="延迟和响应时间httpsvonnggithubioddiach1id延迟和响应时间">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%bb%b6%e8%bf%9f%e5%92%8c%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4" target="_blank" rel="noopener">延迟和响应时间&lt;/a>&lt;/h4>
&lt;p>&lt;strong>延迟（latency）&lt;/strong> 和 &lt;strong>响应时间（response time）&lt;/strong> 经常用作同义词，但实际上它们并不一样。响应时间是客户所看到的，除了实际处理请求的时间（ &lt;strong>服务时间（service time）&lt;/strong> ）之外，还包括网络延迟和排队延迟。延迟是某个请求等待处理的 &lt;strong>持续时长&lt;/strong>，在此期间它处于 &lt;strong>休眠（latent）&lt;/strong> 状态，并等待服务【17】。&lt;/p>
&lt;/blockquote>
&lt;p>即使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。现实世界的系统会处理各式各样的请求，响应时间可能会有很大差异。因此我们需要将响应时间视为一个可以测量的数值 &lt;strong>分布（distribution）&lt;/strong>，而不是单个数值。&lt;/p>
&lt;p>在 &lt;a href="https://vonng.github.io/ddia/#/img/fig1-4.png" target="_blank" rel="noopener">图 1-4&lt;/a> 中，每个灰条代表一次对服务的请求，其高度表示请求花费了多长时间。大多数请求是相当快的，但偶尔会出现需要更长的时间的异常值。这也许是因为缓慢的请求实质上开销更大，例如它们可能会处理更多的数据。但即使（你认为）所有请求都花费相同时间的情况下，随机的附加延迟也会导致结果变化，例如：上下文切换到后台进程，网络数据包丢失与 TCP 重传，垃圾收集暂停，强制从磁盘读取的页面错误，服务器机架中的震动【18】，还有很多其他原因。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig1-4.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 1-4 展示了一个服务 100 次请求响应时间的均值与百分位数&lt;/strong>&lt;/p>
&lt;p>通常报表都会展示服务的平均响应时间。 （严格来讲 “平均” 一词并不指代任何特定公式，但实际上它通常被理解为 &lt;strong>算术平均值（arithmetic mean）&lt;/strong>：给定 n 个值，加起来除以 n ）。然而如果你想知道 “&lt;strong>典型（typical）&lt;/strong>” 响应时间，那么平均值并不是一个非常好的指标，因为它不能告诉你有多少用户实际上经历了这个延迟。&lt;/p>
&lt;p>通常使用 &lt;strong>百分位点（percentiles）&lt;/strong> 会更好。如果将响应时间列表按最快到最慢排序，那么 &lt;strong>中位数（median）&lt;/strong> 就在正中间：举个例子，如果你的响应时间中位数是 200 毫秒，这意味着一半请求的返回时间少于 200 毫秒，另一半比这个要长。&lt;/p>
&lt;p>如果想知道典型场景下用户需要等待多长时间，那么中位数是一个好的度量标准：一半用户请求的响应时间少于响应时间的中位数，另一半服务时间比中位数长。中位数也被称为第 50 百分位点，有时缩写为 p50。注意中位数是关于单个请求的；如果用户同时发出几个请求（在一个会话过程中，或者由于一个页面中包含了多个资源），则至少一个请求比中位数慢的概率远大于 50%。&lt;/p>
&lt;p>为了弄清异常值有多糟糕，可以看看更高的百分位点，例如第 95、99 和 99.9 百分位点（缩写为 p95，p99 和 p999）。它们意味着 95%、99% 或 99.9% 的请求响应时间要比该阈值快，例如：如果第 95 百分位点响应时间是 1.5 秒，则意味着 100 个请求中的 95 个响应时间快于 1.5 秒，而 100 个请求中的 5 个响应时间超过 1.5 秒。如 &lt;a href="https://vonng.github.io/ddia/#/img/fig1-4.png" target="_blank" rel="noopener">图 1-4&lt;/a> 所示。&lt;/p>
&lt;p>响应时间的高百分位点（也称为 &lt;strong>尾部延迟&lt;/strong>，即 &lt;strong>tail latencies&lt;/strong>）非常重要，因为它们直接影响用户的服务体验。例如亚马逊在描述内部服务的响应时间要求时是以 99.9 百分位点为准，即使它只影响一千个请求中的一个。这是因为请求响应最慢的客户往往也是数据最多的客户，也可以说是最有价值的客户 —— 因为他们掏钱了【19】。保证网站响应迅速对于保持客户的满意度非常重要，亚马逊观察到：响应时间增加 100 毫秒，销售量就减少 1%【20】；而另一些报告说：慢 1 秒钟会让客户满意度指标减少 16%【21，22】。&lt;/p>
&lt;p>另一方面，优化第 99.99 百分位点（一万个请求中最慢的一个）被认为太昂贵了，不能为亚马逊的目标带来足够好处。减小高百分位点处的响应时间相当困难，因为它很容易受到随机事件的影响，这超出了控制范围，而且效益也很小。&lt;/p>
&lt;p>百分位点通常用于 &lt;strong>服务级别目标（SLO, service level objectives）&lt;/strong> 和 &lt;strong>服务级别协议（SLA, service level agreements）&lt;/strong>，即定义服务预期性能和可用性的合同。 SLA 可能会声明，如果服务响应时间的中位数小于 200 毫秒，且 99.9 百分位点低于 1 秒，则认为服务工作正常（如果响应时间更长，就认为服务不达标）。这些指标为客户设定了期望值，并允许客户在 SLA 未达标的情况下要求退款。&lt;/p>
&lt;p>&lt;strong>排队延迟（queueing delay）&lt;/strong> 通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其 CPU 核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 &lt;strong>头部阻塞（head-of-line blocking）&lt;/strong> 。即使后续请求在服务器上处理的非常迅速，由于需要等待先前请求完成，客户端最终看到的是缓慢的总体响应时间。因为存在这种效应，测量客户端的响应时间非常重要。&lt;/p>
&lt;p>为测试系统的可伸缩性而人为产生负载时，产生负载的客户端要独立于响应时间不断发送请求。如果客户端在发送下一个请求之前等待先前的请求完成，这种行为会产生人为排队的效果，使得测试时的队列比现实情况更短，使测量结果产生偏差【23】。&lt;/p>
&lt;blockquote>
&lt;h4 id="实践中的百分位点httpsvonnggithubioddiach1id实践中的百分位点">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%ae%9e%e8%b7%b5%e4%b8%ad%e7%9a%84%e7%99%be%e5%88%86%e4%bd%8d%e7%82%b9" target="_blank" rel="noopener">实践中的百分位点&lt;/a>&lt;/h4>
&lt;p>在多重调用的后端服务里，高百分位数变得特别重要。即使并行调用，最终用户请求仍然需要等待最慢的并行调用完成。如 &lt;a href="https://vonng.github.io/ddia/#/img/fig1-5.png" target="_blank" rel="noopener">图 1-5&lt;/a> 所示，只需要一个缓慢的调用就可以使整个最终用户请求变慢。即使只有一小部分后端调用速度较慢，如果最终用户请求需要多个后端调用，则获得较慢调用的机会也会增加，因此较高比例的最终用户请求速度会变慢（效果称为尾部延迟放大【24】）。&lt;/p>
&lt;p>如果你想将响应时间百分点添加到你的服务的监视仪表板，则需要持续有效地计算它们。例如，你可能希望在最近 10 分钟内保持请求响应时间的滚动窗口。每一分钟，你都会计算出该窗口中的中值和各种百分数，并将这些度量值绘制在图上。&lt;/p>
&lt;p>简单的实现是在时间窗口内保存所有请求的响应时间列表，并且每分钟对列表进行排序。如果对你来说效率太低，那么有一些算法能够以最小的 CPU 和内存成本（如前向衰减【25】、t-digest【26】或 HdrHistogram 【27】）来计算百分位数的近似值。请注意，平均百分比（例如，减少时间分辨率或合并来自多台机器的数据）在数学上没有意义 - 聚合响应时间数据的正确方法是添加直方图【28】。&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://vonng.github.io/ddia/img/fig1-5.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>图 1-5 当一个请求需要多个后端请求时，单个后端慢请求就会拖慢整个终端用户的请求&lt;/strong>&lt;/p>
&lt;h3 id="应对负载的方法httpsvonnggithubioddiach1id应对负载的方法">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%ba%94%e5%af%b9%e8%b4%9f%e8%bd%bd%e7%9a%84%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">应对负载的方法&lt;/a>&lt;/h3>
&lt;p>现在我们已经讨论了用于描述负载的参数和用于衡量性能的指标。可以开始认真讨论可伸缩性了：当负载参数增加时，如何保持良好的性能？&lt;/p>
&lt;p>适应某个级别负载的架构不太可能应付 10 倍于此的负载。如果你正在开发一个快速增长的服务，那么每次负载发生数量级的增长时，你可能都需要重新考虑架构 —— 或者更频繁。&lt;/p>
&lt;p>人们经常讨论 &lt;strong>纵向伸缩&lt;/strong>（scaling up，也称为垂直伸缩，即 vertical scaling，转向更强大的机器）和 &lt;strong>横向伸缩&lt;/strong>（scaling out，也称为水平伸缩，即 horizontal scaling，将负载分布到多台小机器上）之间的对立。跨多台机器分配负载也称为 “&lt;strong>无共享（shared-nothing）&lt;/strong>” 架构。可以在单台机器上运行的系统通常更简单，但高端机器可能非常贵，所以非常密集的负载通常无法避免地需要横向伸缩。现实世界中的优秀架构需要将这两种方法务实地结合，因为使用几台足够强大的机器可能比使用大量的小型虚拟机更简单也更便宜。&lt;/p>
&lt;p>有些系统是 &lt;strong>弹性（elastic）&lt;/strong> 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动伸缩（人工分析容量并决定向系统添加更多的机器）。如果负载 &lt;strong>极难预测（highly unpredictable）&lt;/strong>，则弹性系统可能很有用，但手动伸缩系统更简单，并且意外操作可能会更少（请参阅 “&lt;a href="https://vonng.github.io/ddia/#/ch6?id=%e5%88%86%e5%8c%ba%e5%86%8d%e5%b9%b3%e8%a1%a1" target="_blank" rel="noopener">分区再平衡&lt;/a>”）。&lt;/p>
&lt;p>跨多台机器部署 &lt;strong>无状态服务（stateless services）&lt;/strong> 非常简单，但将带状态的数据系统从单节点变为分布式配置则可能引入许多额外复杂度。出于这个原因，常识告诉我们应该将数据库放在单个节点上（纵向伸缩），直到伸缩成本或可用性需求迫使其改为分布式。&lt;/p>
&lt;p>随着分布式系统的工具和抽象越来越好，至少对于某些类型的应用而言，这种常识可能会改变。可以预见分布式数据系统将成为未来的默认设置，即使对不处理大量数据或流量的场景也如此。本书的其余部分将介绍多种分布式数据系统，不仅讨论它们在可伸缩性方面的表现，还包括易用性和可维护性。&lt;/p>
&lt;p>大规模的系统架构通常是应用特定的 —— 没有一招鲜吃遍天的通用可伸缩架构（不正式的叫法：&lt;strong>万金油（magic scaling sauce）&lt;/strong> ）。应用的问题可能是读取量、写入量、要存储的数据量、数据的复杂度、响应时间要求、访问模式或者所有问题的大杂烩。&lt;/p>
&lt;p>举个例子，用于处理每秒十万个请求（每个大小为 1 kB）的系统与用于处理每分钟 3 个请求（每个大小为 2GB）的系统看上去会非常不一样，尽管两个系统有同样的数据吞吐量。&lt;/p>
&lt;p>一个良好适配应用的可伸缩架构，是围绕着 &lt;strong>假设（assumption）&lt;/strong> 建立的：哪些操作是常见的？哪些操作是罕见的？这就是所谓负载参数。如果假设最终是错误的，那么为伸缩所做的工程投入就白费了，最糟糕的是适得其反。在早期创业公司或非正式产品中，通常支持产品快速迭代的能力，要比可伸缩至未来的假想负载要重要的多。&lt;/p>
&lt;p>尽管这些架构是应用程序特定的，但可伸缩的架构通常也是从通用的积木块搭建而成的，并以常见的模式排列。在本书中，我们将讨论这些构件和模式。&lt;/p>
&lt;h2 id="可维护性httpsvonnggithubioddiach1id可维护性">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7" target="_blank" rel="noopener">可维护性&lt;/a>&lt;/h2>
&lt;p>众所周知，软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常运行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。&lt;/p>
&lt;p>不幸的是，许多从事软件系统行业的人不喜欢维护所谓的 &lt;strong>遗留（legacy）&lt;/strong> 系统，—— 也许因为涉及修复其他人的错误、和过时的平台打交道，或者系统被迫使用于一些份外工作。每一个遗留系统都以自己的方式让人不爽，所以很难给出一个通用的建议来和它们打交道。&lt;/p>
&lt;p>但是我们可以，也应该以这样一种方式来设计软件：在设计之初就尽量考虑尽可能减少维护期间的痛苦，从而避免自己的软件系统变成遗留系统。为此，我们将特别关注软件系统的三个设计原则：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可操作性（Operability）&lt;/p>
&lt;p>便于运维团队保持系统平稳运行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>简单性（Simplicity）&lt;/p>
&lt;p>从系统中消除尽可能多的 &lt;strong>复杂度（complexity）&lt;/strong>，使新工程师也能轻松理解系统（注意这和用户接口的简单性不一样）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可演化性（evolvability）&lt;/p>
&lt;p>使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为 &lt;strong>可扩展性（extensibility）&lt;/strong>、&lt;strong>可修改性（modifiability）&lt;/strong> 或 &lt;strong>可塑性（plasticity）&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>和之前提到的可靠性、可伸缩性一样，实现这些目标也没有简单的解决方案。不过我们会试着想象具有可操作性，简单性和可演化性的系统会是什么样子。&lt;/p>
&lt;h3 id="可操作性人生苦短关爱运维httpsvonnggithubioddiach1id可操作性人生苦短关爱运维">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e6%93%8d%e4%bd%9c%e6%80%a7%ef%bc%9a%e4%ba%ba%e7%94%9f%e8%8b%a6%e7%9f%ad%ef%bc%8c%e5%85%b3%e7%88%b1%e8%bf%90%e7%bb%b4" target="_blank" rel="noopener">可操作性：人生苦短，关爱运维&lt;/a>&lt;/h3>
&lt;p>有人认为，“良好的运维经常可以绕开垃圾（或不完整）软件的局限性，而再好的软件摊上垃圾运维也没法可靠运行”。尽管运维的某些方面可以，而且应该是自动化的，但在最初建立正确运作的自动化机制仍然取决于人。&lt;/p>
&lt;p>运维团队对于保持软件系统顺利运行至关重要。一个优秀运维团队的典型职责如下（或者更多）【29】：&lt;/p>
&lt;ul>
&lt;li>监控系统的运行状况，并在服务状态不佳时快速恢复服务。&lt;/li>
&lt;li>跟踪问题的原因，例如系统故障或性能下降。&lt;/li>
&lt;li>及时更新软件和平台，比如安全补丁。&lt;/li>
&lt;li>了解系统间的相互作用，以便在异常变更造成损失前进行规避。&lt;/li>
&lt;li>预测未来的问题，并在问题出现之前加以解决（例如，容量规划）。&lt;/li>
&lt;li>建立部署、配置、管理方面的良好实践，编写相应工具。&lt;/li>
&lt;li>执行复杂的维护任务，例如将应用程序从一个平台迁移到另一个平台。&lt;/li>
&lt;li>当配置变更时，维持系统的安全性。&lt;/li>
&lt;li>定义工作流程，使运维操作可预测，并保持生产环境稳定。&lt;/li>
&lt;li>铁打的营盘流水的兵，维持组织对系统的了解。&lt;/li>
&lt;/ul>
&lt;p>良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。数据系统可以通过各种方式使日常任务更轻松：&lt;/p>
&lt;ul>
&lt;li>通过良好的监控，提供对系统内部状态和运行时行为的 &lt;strong>可见性（visibility）&lt;/strong>。&lt;/li>
&lt;li>为自动化提供良好支持，将系统与标准化工具相集成。&lt;/li>
&lt;li>避免依赖单台机器（在整个系统继续不间断运行的情况下允许机器停机维护）。&lt;/li>
&lt;li>提供良好的文档和易于理解的操作模型（“如果做 X，会发生 Y”）。&lt;/li>
&lt;li>提供良好的默认行为，但需要时也允许管理员自由覆盖默认值。&lt;/li>
&lt;li>有条件时进行自我修复，但需要时也允许管理员手动控制系统状态。&lt;/li>
&lt;li>行为可预测，最大限度减少意外。&lt;/li>
&lt;/ul>
&lt;h3 id="简单性管理复杂度httpsvonnggithubioddiach1id简单性管理复杂度">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e7%ae%80%e5%8d%95%e6%80%a7%ef%bc%9a%e7%ae%a1%e7%90%86%e5%a4%8d%e6%9d%82%e5%ba%a6" target="_blank" rel="noopener">简单性：管理复杂度&lt;/a>&lt;/h3>
&lt;p>小型软件项目可以使用简单讨喜的、富表现力的代码，但随着项目越来越大，代码往往变得非常复杂，难以理解。这种复杂度拖慢了所有系统相关人员，进一步增加了维护成本。一个陷入复杂泥潭的软件项目有时被描述为 &lt;strong>烂泥潭（a big ball of mud）&lt;/strong> 【30】。&lt;/p>
&lt;p>&lt;strong>复杂度（complexity）&lt;/strong> 有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的 Hack、需要绕开的特例等等，现在已经有很多关于这个话题的讨论【31,32,33】。&lt;/p>
&lt;p>因为复杂度导致维护困难时，预算和时间安排通常会超支。在复杂的软件中进行变更，引入错误的风险也更大：当开发人员难以理解系统时，隐藏的假设、无意的后果和意外的交互就更容易被忽略。相反，降低复杂度能极大地提高软件的可维护性，因此简单性应该是构建系统的一个关键目标。&lt;/p>
&lt;p>简化系统并不一定意味着减少功能；它也可以意味着消除 &lt;strong>额外的（accidental）&lt;/strong> 的复杂度。 Moseley 和 Marks【32】把 &lt;strong>额外复杂度&lt;/strong> 定义为：由具体实现中涌现，而非（从用户视角看，系统所解决的）问题本身固有的复杂度。&lt;/p>
&lt;p>用于消除 &lt;strong>额外复杂度&lt;/strong> 的最好工具之一是 &lt;strong>抽象（abstraction）&lt;/strong>。一个好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。一个好的抽象也可以广泛用于各类不同应用。比起重复造很多轮子，重用抽象不仅更有效率，而且有助于开发高质量的软件。抽象组件的质量改进将使所有使用它的应用受益。&lt;/p>
&lt;p>例如，高级编程语言是一种抽象，隐藏了机器码、CPU 寄存器和系统调用。 SQL 也是一种抽象，隐藏了复杂的磁盘 / 内存数据结构、来自其他客户端的并发请求、崩溃后的不一致性。当然在用高级语言编程时，我们仍然用到了机器码；只不过没有 &lt;strong>直接（directly）&lt;/strong> 使用罢了，正是因为编程语言的抽象，我们才不必去考虑这些实现细节。&lt;/p>
&lt;p>抽象可以帮助我们将系统的复杂度控制在可管理的水平，不过，找到好的抽象是非常困难的。在分布式系统领域虽然有许多好的算法，但我们并不清楚它们应该打包成什么样抽象。&lt;/p>
&lt;p>本书将紧盯那些允许我们将大型系统的部分提取为定义明确的、可重用的组件的优秀抽象。&lt;/p>
&lt;h3 id="可演化性拥抱变化httpsvonnggithubioddiach1id可演化性拥抱变化">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%af%e6%bc%94%e5%8c%96%e6%80%a7%ef%bc%9a%e6%8b%a5%e6%8a%b1%e5%8f%98%e5%8c%96" target="_blank" rel="noopener">可演化性：拥抱变化&lt;/a>&lt;/h3>
&lt;p>系统的需求永远不变，基本是不可能的。更可能的情况是，它们处于常态的变化中，例如：你了解了新的事实、出现意想不到的应用场景、业务优先级发生变化、用户要求新功能、新平台取代旧平台、法律或监管要求发生变化、系统增长迫使架构变化等。&lt;/p>
&lt;p>在组织流程方面， &lt;strong>敏捷（agile）&lt;/strong> 工作模式为适应变化提供了一个框架。敏捷社区还开发了对在频繁变化的环境中开发软件很有帮助的技术工具和模式，如 &lt;strong>测试驱动开发（TDD, test-driven development）&lt;/strong> 和 &lt;strong>重构（refactoring）&lt;/strong> 。&lt;/p>
&lt;p>这些敏捷技术的大部分讨论都集中在相当小的规模（同一个应用中的几个代码文件）。本书将探索在更大数据系统层面上提高敏捷性的方法，可能由几个不同的应用或服务组成。例如，为了将装配主页时间线的方法从方法 1 变为方法 2，你会如何 “重构” 推特的架构 ？&lt;/p>
&lt;p>修改数据系统并使其适应不断变化需求的容易程度，是与 &lt;strong>简单性&lt;/strong> 和 &lt;strong>抽象性&lt;/strong> 密切相关的：简单易懂的系统通常比复杂系统更容易修改。但由于这是一个非常重要的概念，我们将用一个不同的词来指代数据系统层面的敏捷性： &lt;strong>可演化性（evolvability）&lt;/strong> 【34】。&lt;/p>
&lt;h2 id="本章小结httpsvonnggithubioddiach1id本章小结">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" target="_blank" rel="noopener">本章小结&lt;/a>&lt;/h2>
&lt;p>本章探讨了一些关于数据密集型应用的基本思考方式。这些原则将指导我们阅读本书的其余部分，那里将会深入技术细节。&lt;/p>
&lt;p>一个应用必须满足各种需求才称得上有用。有一些 &lt;strong>功能需求&lt;/strong>（functional requirements，即它应该做什么，比如允许以各种方式存储，检索，搜索和处理数据）以及一些 &lt;strong>非功能性需求&lt;/strong>（nonfunctional，即通用属性，例如安全性、可靠性、合规性、可伸缩性、兼容性和可维护性）。在本章详细讨论了可靠性，可伸缩性和可维护性。&lt;/p>
&lt;p>&lt;strong>可靠性（Reliability）&lt;/strong> 意味着即使发生故障，系统也能正常工作。故障可能发生在硬件（通常是随机的和不相关的）、软件（通常是系统性的 Bug，很难处理）和人类（不可避免地时不时出错）。 &lt;strong>容错技术&lt;/strong> 可以对终端用户隐藏某些类型的故障。&lt;/p>
&lt;p>&lt;strong>可伸缩性（Scalability）&lt;/strong> 意味着即使在负载增加的情况下也有保持性能的策略。为了讨论可伸缩性，我们首先需要定量描述负载和性能的方法。我们简要了解了推特主页时间线的例子，介绍描述负载的方法，并将响应时间百分位点作为衡量性能的一种方式。在可伸缩的系统中可以添加 &lt;strong>处理容量（processing capacity）&lt;/strong> 以在高负载下保持可靠。&lt;/p>
&lt;p>&lt;strong>可维护性（Maintainability）&lt;/strong> 有许多方面，但实质上是关于工程师和运维团队的生活质量的。良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。良好的可操作性意味着对系统的健康状态具有良好的可见性，并拥有有效的管理手段。&lt;/p>
&lt;p>不幸的是，使应用可靠、可伸缩或可维护并不容易。但是某些模式和技术会不断重新出现在不同的应用中。在接下来的几章中，我们将看到一些数据系统的例子，并分析它们如何实现这些目标。&lt;/p>
&lt;p>在本书后面的 &lt;a href="https://vonng.github.io/ddia/#/part-iii" target="_blank" rel="noopener">第三部分&lt;/a> 中，我们将看到一种模式：几个组件协同工作以构成一个完整的系统（如 &lt;a href="https://vonng.github.io/ddia/#/img/fig1-1.png" target="_blank" rel="noopener">图 1-1&lt;/a> 中的例子）&lt;/p>
&lt;h2 id="参考文献httpsvonnggithubioddiach1id参考文献">&lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae" target="_blank" rel="noopener">参考文献&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>Michael Stonebraker and Uğur Çetintemel: “&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.68.9136&amp;amp;rep=rep1&amp;amp;type=pdf" target="_blank" rel="noopener">&amp;lsquo;One Size Fits All&amp;rsquo;: An Idea Whose Time Has Come and Gone&lt;/a>,” at &lt;em>21st International Conference on Data Engineering&lt;/em> (ICDE), April 2005.&lt;/li>
&lt;li>Walter L. Heimerdinger and Charles B. Weinstock: “&lt;a href="http://www.sei.cmu.edu/reports/92tr033.pdf" target="_blank" rel="noopener">A Conceptual Framework for System Fault Tolerance&lt;/a>,” Technical Report CMU/SEI-92-TR-033, Software Engineering Institute, Carnegie Mellon University, October 1992.&lt;/li>
&lt;li>Ding Yuan, Yu Luo, Xin Zhuang, et al.: “&lt;a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf" target="_blank" rel="noopener">Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems&lt;/a>,” at &lt;em>11th USENIX Symposium on Operating Systems Design and Implementation&lt;/em> (OSDI), October 2014.&lt;/li>
&lt;li>Yury Izrailevsky and Ariel Tseitlin: “&lt;a href="http://techblog.netflix.com/2011/07/netflix-simian-army.html" target="_blank" rel="noopener">The Netflix Simian Army&lt;/a>,” &lt;em>techblog.netflix.com&lt;/em>, July 19, 2011.&lt;/li>
&lt;li>Daniel Ford, François Labelle, Florentina I. Popovici, et al.: “&lt;a href="http://research.google.com/pubs/archive/36737.pdf" target="_blank" rel="noopener">Availability in Globally Distributed Storage Systems&lt;/a>,” at &lt;em>9th USENIX Symposium on Operating Systems Design and Implementation&lt;/em> (OSDI), October 2010.&lt;/li>
&lt;li>Brian Beach: “&lt;a href="https://www.backblaze.com/blog/hard-drive-reliability-update-september-2014/" target="_blank" rel="noopener">Hard Drive Reliability Update – Sep 2014&lt;/a>,” &lt;em>backblaze.com&lt;/em>, September 23, 2014.&lt;/li>
&lt;li>Laurie Voss: “&lt;a href="https://web.archive.org/web/20160429075023/http://blog.awe.sm/2012/12/18/aws-the-good-the-bad-and-the-ugly/" target="_blank" rel="noopener">AWS: The Good, the Bad and the Ugly&lt;/a>,” &lt;em>blog.awe.sm&lt;/em>, December 18, 2012.&lt;/li>
&lt;li>Haryadi S. Gunawi, Mingzhe Hao, Tanakorn Leesatapornwongsa, et al.: “&lt;a href="http://ucare.cs.uchicago.edu/pdf/socc14-cbs.pdf" target="_blank" rel="noopener">What Bugs Live in the Cloud?&lt;/a>,” at &lt;em>5th ACM Symposium on Cloud Computing&lt;/em> (SoCC), November 2014. &lt;a href="http://dx.doi.org/10.1145/2670979.2670986" target="_blank" rel="noopener">doi:10.1145/2670979.2670986&lt;/a>&lt;/li>
&lt;li>Nelson Minar: “&lt;a href="http://www.somebits.com/weblog/tech/bad/leap-second-2012.html" target="_blank" rel="noopener">Leap Second Crashes Half the Internet&lt;/a>,” &lt;em>somebits.com&lt;/em>, July 3, 2012.&lt;/li>
&lt;li>Amazon Web Services: “&lt;a href="http://aws.amazon.com/message/65648/" target="_blank" rel="noopener">Summary of the Amazon EC2 and Amazon RDS Service Disruption in the US East Region&lt;/a>,” &lt;em>aws.amazon.com&lt;/em>, April 29, 2011.&lt;/li>
&lt;li>Richard I. Cook: “[How Complex Systems Fail](&lt;a href="http://web.mit.edu/2.75/resources/random/How" target="_blank" rel="noopener">http://web.mit.edu/2.75/resources/random/How&lt;/a> Complex Systems Fail.pdf),” Cognitive Technologies Laboratory, April 2000.&lt;/li>
&lt;li>Jay Kreps: “&lt;a href="http://blog.empathybox.com/post/19574936361/getting-real-about-distributed-system-reliability" target="_blank" rel="noopener">Getting Real About Distributed System Reliability&lt;/a>,” &lt;em>blog.empathybox.com&lt;/em>, March 19, 2012.&lt;/li>
&lt;li>David Oppenheimer, Archana Ganapathi, and David A. Patterson: “&lt;a href="http://static.usenix.org/legacy/events/usits03/tech/full_papers/oppenheimer/oppenheimer.pdf" target="_blank" rel="noopener">Why Do Internet Services Fail, and What Can Be Done About It?&lt;/a>,” at &lt;em>4th USENIX Symposium on Internet Technologies and Systems&lt;/em> (USITS), March 2003.&lt;/li>
&lt;li>Nathan Marz: “&lt;a href="http://nathanmarz.com/blog/principles-of-software-engineering-part-1.html" target="_blank" rel="noopener">Principles of Software Engineering, Part 1&lt;/a>,” &lt;em>nathanmarz.com&lt;/em>, April 2, 2013.&lt;/li>
&lt;li>Michael Jurewitz:“&lt;a href="http://jury.me/blog/2013/3/14/the-human-impact-of-bugs" target="_blank" rel="noopener">The Human Impact of Bugs&lt;/a>,” &lt;em>jury.me&lt;/em>, March 15, 2013.&lt;/li>
&lt;li>Raffi Krikorian: “&lt;a href="http://www.infoq.com/presentations/Twitter-Timeline-Scalability" target="_blank" rel="noopener">Timelines at Scale&lt;/a>,” at &lt;em>QCon San Francisco&lt;/em>, November 2012.&lt;/li>
&lt;li>Martin Fowler: &lt;em>Patterns of Enterprise Application Architecture&lt;/em>. Addison Wesley, 2002. ISBN: 978-0-321-12742-6&lt;/li>
&lt;li>Kelly Sommers: “&lt;a href="https://twitter.com/kellabyte/status/532930540777635840" target="_blank" rel="noopener">After all that run around, what caused 500ms disk latency even when we replaced physical server?&lt;/a>” &lt;em>twitter.com&lt;/em>, November 13, 2014.&lt;/li>
&lt;li>Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, et al.: “&lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">Dynamo: Amazon&amp;rsquo;s Highly Available Key-Value Store&lt;/a>,” at &lt;em>21st ACM Symposium on Operating Systems Principles&lt;/em> (SOSP), October 2007.&lt;/li>
&lt;li>Greg Linden: “&lt;a href="http://glinden.blogspot.co.uk/2006/12/slides-from-my-talk-at-stanford.html" target="_blank" rel="noopener">Make Data Useful&lt;/a>,” slides from presentation at Stanford University Data Mining class (CS345), December 2006.&lt;/li>
&lt;li>Tammy Everts: “&lt;a href="http://www.webperformancetoday.com/2014/11/12/real-cost-slow-time-vs-downtime-slides/" target="_blank" rel="noopener">The Real Cost of Slow Time vs Downtime&lt;/a>,” &lt;em>webperformancetoday.com&lt;/em>, November 12, 2014.&lt;/li>
&lt;li>Jake Brutlag:“&lt;a href="http://googleresearch.blogspot.co.uk/2009/06/speed-matters.html" target="_blank" rel="noopener">Speed Matters for Google Web Search&lt;/a>,” &lt;em>googleresearch.blogspot.co.uk&lt;/em>, June 22, 2009.&lt;/li>
&lt;li>Tyler Treat: “&lt;a href="http://bravenewgeek.com/everything-you-know-about-latency-is-wrong/" target="_blank" rel="noopener">Everything You Know About Latency Is Wrong&lt;/a>,” &lt;em>bravenewgeek.com&lt;/em>, December 12, 2015.&lt;/li>
&lt;li>Jeffrey Dean and Luiz André Barroso: “&lt;a href="http://cacm.acm.org/magazines/2013/2/160173-the-tail-at-scale/fulltext" target="_blank" rel="noopener">The Tail at Scale&lt;/a>,” &lt;em>Communications of the ACM&lt;/em>, volume 56, number 2, pages 74–80, February 2013. &lt;a href="http://dx.doi.org/10.1145/2408776.2408794" target="_blank" rel="noopener">doi:10.1145/2408776.2408794&lt;/a>&lt;/li>
&lt;li>Graham Cormode, Vladislav Shkapenyuk, Divesh Srivastava, and Bojian Xu: “&lt;a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf" target="_blank" rel="noopener">Forward Decay: A Practical Time Decay Model for Streaming Systems&lt;/a>,” at &lt;em>25th IEEE International Conference on Data Engineering&lt;/em> (ICDE), March 2009.&lt;/li>
&lt;li>Ted Dunning and Otmar Ertl: “&lt;a href="https://github.com/tdunning/t-digest" target="_blank" rel="noopener">Computing Extremely Accurate Quantiles Using t-Digests&lt;/a>,” &lt;em>github.com&lt;/em>, March 2014.&lt;/li>
&lt;li>Gil Tene: “&lt;a href="http://www.hdrhistogram.org/" target="_blank" rel="noopener">HdrHistogram&lt;/a>,” &lt;em>hdrhistogram.org&lt;/em>.&lt;/li>
&lt;li>Baron Schwartz: “&lt;a href="https://www.vividcortex.com/blog/why-percentiles-dont-work-the-way-you-think" target="_blank" rel="noopener">Why Percentiles Don’t Work the Way You Think&lt;/a>,” &lt;em>vividcortex.com&lt;/em>, December 7, 2015.&lt;/li>
&lt;li>James Hamilton: “&lt;a href="https://www.usenix.org/legacy/events/lisa07/tech/full_papers/hamilton/hamilton.pdf" target="_blank" rel="noopener">On Designing and Deploying Internet-Scale Services&lt;/a>,” at &lt;em>21st Large Installation System Administration Conference&lt;/em> (LISA), November 2007.&lt;/li>
&lt;li>Brian Foote and Joseph Yoder: “&lt;a href="http://www.laputan.org/pub/foote/mud.pdf" target="_blank" rel="noopener">Big Ball of Mud&lt;/a>,” at &lt;em>4th Conference on Pattern Languages of Programs&lt;/em> (PLoP), September 1997.&lt;/li>
&lt;li>Frederick P Brooks: “No Silver Bullet – Essence and Accident in Software Engineering,” in &lt;em>The Mythical Man-Month&lt;/em>, Anniversary edition, Addison-Wesley, 1995. ISBN: 978-0-201-83595-3&lt;/li>
&lt;li>Ben Moseley and Peter Marks: “&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.93.8928" target="_blank" rel="noopener">Out of the Tar Pit&lt;/a>,” at &lt;em>BCS Software Practice Advancement&lt;/em> (SPA), 2006.&lt;/li>
&lt;li>Rich Hickey: “&lt;a href="http://www.infoq.com/presentations/Simple-Made-Easy" target="_blank" rel="noopener">Simple Made Easy&lt;/a>,” at &lt;em>Strange Loop&lt;/em>, September 2011.&lt;/li>
&lt;li>Hongyu Pei Breivold, Ivica Crnkovic, and Peter J. Eriksson: “&lt;a href="http://www.mrtc.mdh.se/publications/1478.pdf" target="_blank" rel="noopener">Analyzing Software Evolvability&lt;/a>,” at &lt;em>32nd Annual IEEE International Computer Software and Applications Conference&lt;/em> (COMPSAC), July 2008. [doi:10.1109/COMPSAC.2008.50&lt;/li>
&lt;/ol>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>在 &lt;a href="https://vonng.github.io/ddia/#/ch1?id=%e5%ba%94%e5%af%b9%e8%b4%9f%e8%bd%bd%e7%9a%84%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">应对负载的方法&lt;/a> 一节定义&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>扇出：从电子工程学中借用的术语，它描述了输入连接到另一个门输出的逻辑门数量。 输出需要提供足够的电流来驱动所有连接的输入。 在事务处理系统中，我们使用它来描述为了服务一个传入请求而需要执行其他服务的请求数量。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>理想情况下，批量作业的运行时间是数据集的大小除以吞吐量。 在实践中由于数据倾斜（数据不是均匀分布在每个工作进程中），需要等待最慢的任务完成，所以运行时间往往更长。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>