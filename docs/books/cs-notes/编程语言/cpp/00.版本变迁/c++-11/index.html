<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="Next-gen Tech Edu"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c++-11/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.fab3cd1900ae35687457073b2d518207.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=alternate href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c++-11/index.xml type=application/rss+xml title="Next-gen Tech Edu"><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c++-11/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c++-11/"><meta property="og:title" content="C++ 11 | Next-gen Tech Edu"><meta property="og:description" content="Next-gen Tech Edu"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>C++ 11 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=c6e1d6ef165aaa7beb00b332a6fdb416><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">00.版本变迁</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idc5886513539bcfc0206bbb3b9d2be4f1")' href=#idc5886513539bcfc0206bbb3b9d2be4f1 aria-expanded=false aria-controls=idc5886513539bcfc0206bbb3b9d2be4f1 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/>CPP</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idc5886513539bcfc0206bbb3b9d2be4f1 aria-expanded=false aria-controls=idc5886513539bcfc0206bbb3b9d2be4f1><i class="fa-solid fa-angle-down" id=caret-idc5886513539bcfc0206bbb3b9d2be4f1></i></a></div><ul class="nav docs-sidenav collapse show" id=idc5886513539bcfc0206bbb3b9d2be4f1><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idc6bd699b3a57e996e8b4e145c0f5b316")' href=#idc6bd699b3a57e996e8b4e145c0f5b316 aria-expanded=false aria-controls=idc6bd699b3a57e996e8b4e145c0f5b316 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/>00.版本变迁</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idc6bd699b3a57e996e8b4e145c0f5b316 aria-expanded=false aria-controls=idc6bd699b3a57e996e8b4e145c0f5b316><i class="fa-solid fa-angle-down" id=caret-idc6bd699b3a57e996e8b4e145c0f5b316></i></a></div><ul class="nav docs-sidenav collapse show" id=idc6bd699b3a57e996e8b4e145c0f5b316><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id02c4c02945728f4f14815cc44e456e94")' href=#id02c4c02945728f4f14815cc44e456e94 aria-expanded=false aria-controls=id02c4c02945728f4f14815cc44e456e94 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id6a50be2f0f4ec32f883dd5059fe61a4c")' href=#id6a50be2f0f4ec32f883dd5059fe61a4c aria-expanded=false aria-controls=id6a50be2f0f4ec32f883dd5059fe61a4c aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idc56dfd2832472d72d6c201892ebe5769")' href=#idc56dfd2832472d72d6c201892ebe5769 aria-expanded=false aria-controls=idc56dfd2832472d72d6c201892ebe5769 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idebbaaeb0a000097ce7ebe7ec60415648")' href=#idebbaaeb0a000097ce7ebe7ec60415648 aria-expanded=false aria-controls=idebbaaeb0a000097ce7ebe7ec60415648 aria-hidden=false data-toggle=collapse></div></div></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idb560329bd3393872f5457930782ddbbb")' href=#idb560329bd3393872f5457930782ddbbb aria-expanded=false aria-controls=idb560329bd3393872f5457930782ddbbb aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/>01.语法基础</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idb560329bd3393872f5457930782ddbbb aria-expanded=false aria-controls=idb560329bd3393872f5457930782ddbbb><i class="fa-solid fa-angle-right" id=caret-idb560329bd3393872f5457930782ddbbb></i></a></div><ul class="nav docs-sidenav collapse" id=idb560329bd3393872f5457930782ddbbb><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id4bba0c2d6a79e39c4996619194c7c3e7")' href=#id4bba0c2d6a79e39c4996619194c7c3e7 aria-expanded=false aria-controls=id4bba0c2d6a79e39c4996619194c7c3e7 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/>编译与运行</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id4bba0c2d6a79e39c4996619194c7c3e7 aria-expanded=false aria-controls=id4bba0c2d6a79e39c4996619194c7c3e7><i class="fa-solid fa-angle-right" id=caret-id4bba0c2d6a79e39c4996619194c7c3e7></i></a></div><ul class="nav docs-sidenav collapse" id=id4bba0c2d6a79e39c4996619194c7c3e7><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id275db81c8c32f1f1247cc8e211cba475")' href=#id275db81c8c32f1f1247cc8e211cba475 aria-expanded=false aria-controls=id275db81c8c32f1f1247cc8e211cba475 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/01.%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91/>01.程序编译</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id275db81c8c32f1f1247cc8e211cba475 aria-expanded=false aria-controls=id275db81c8c32f1f1247cc8e211cba475><i class="fa-solid fa-angle-right" id=caret-id275db81c8c32f1f1247cc8e211cba475></i></a></div><ul class="nav docs-sidenav collapse" id=id275db81c8c32f1f1247cc8e211cba475><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/01.%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91/%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/>不同的编译工具</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id6bc684231c4aaac52f462c8649fa86b5")' href=#id6bc684231c4aaac52f462c8649fa86b5 aria-expanded=false aria-controls=id6bc684231c4aaac52f462c8649fa86b5 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/clang/>clang</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id6bc684231c4aaac52f462c8649fa86b5 aria-expanded=false aria-controls=id6bc684231c4aaac52f462c8649fa86b5><i class="fa-solid fa-angle-right" id=caret-id6bc684231c4aaac52f462c8649fa86b5></i></a></div><ul class="nav docs-sidenav collapse" id=id6bc684231c4aaac52f462c8649fa86b5><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/clang/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/>常用指令</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id21723428a22c1097beaa8051e45a3314")' href=#id21723428a22c1097beaa8051e45a3314 aria-expanded=false aria-controls=id21723428a22c1097beaa8051e45a3314 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/cmake/>CMake</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id21723428a22c1097beaa8051e45a3314 aria-expanded=false aria-controls=id21723428a22c1097beaa8051e45a3314><i class="fa-solid fa-angle-right" id=caret-id21723428a22c1097beaa8051e45a3314></i></a></div><ul class="nav docs-sidenav collapse" id=id21723428a22c1097beaa8051e45a3314><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/cmake/cmake-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/>CMake 简单示例</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/cmake/cmakelists.txt/>CMakeLists.txt</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/cmake/make/>Make</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id32a4272bb4a37ca2391f2f6abf603147")' href=#id32a4272bb4a37ca2391f2f6abf603147 aria-expanded=false aria-controls=id32a4272bb4a37ca2391f2f6abf603147 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id883150a436d7253fdfed67685d7087ac")' href=#id883150a436d7253fdfed67685d7087ac aria-expanded=false aria-controls=id883150a436d7253fdfed67685d7087ac aria-hidden=false data-toggle=collapse></div></div></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id15c246524d4fc20a53f97d983a0cbe8a")' href=#id15c246524d4fc20a53f97d983a0cbe8a aria-expanded=false aria-controls=id15c246524d4fc20a53f97d983a0cbe8a aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/>函数</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id15c246524d4fc20a53f97d983a0cbe8a aria-expanded=false aria-controls=id15c246524d4fc20a53f97d983a0cbe8a><i class="fa-solid fa-angle-right" id=caret-id15c246524d4fc20a53f97d983a0cbe8a></i></a></div><ul class="nav docs-sidenav collapse" id=id15c246524d4fc20a53f97d983a0cbe8a><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/lambda/>Lambda</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idf21c44d7a983455d8fc7b1a490a3975a")' href=#idf21c44d7a983455d8fc7b1a490a3975a aria-expanded=false aria-controls=idf21c44d7a983455d8fc7b1a490a3975a aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/>快速开始</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idf21c44d7a983455d8fc7b1a490a3975a aria-expanded=false aria-controls=idf21c44d7a983455d8fc7b1a490a3975a><i class="fa-solid fa-angle-right" id=caret-idf21c44d7a983455d8fc7b1a490a3975a></i></a></div><ul class="nav docs-sidenav collapse" id=idf21c44d7a983455d8fc7b1a490a3975a><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/c++-%E7%AE%80%E5%8F%B2/>C++ 简史</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idf46297e2e36fcf321b7acdb29c86fd92")' href=#idf46297e2e36fcf321b7acdb29c86fd92 aria-expanded=false aria-controls=idf46297e2e36fcf321b7acdb29c86fd92 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/>类与对象</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idf46297e2e36fcf321b7acdb29c86fd92 aria-expanded=false aria-controls=idf46297e2e36fcf321b7acdb29c86fd92><i class="fa-solid fa-angle-right" id=caret-idf46297e2e36fcf321b7acdb29c86fd92></i></a></div><ul class="nav docs-sidenav collapse" id=idf46297e2e36fcf321b7acdb29c86fd92><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id2eb2e42ef993b83e59ee7a52140545f8")' href=#id2eb2e42ef993b83e59ee7a52140545f8 aria-expanded=false aria-controls=id2eb2e42ef993b83e59ee7a52140545f8 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/>构造函数</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id2eb2e42ef993b83e59ee7a52140545f8 aria-expanded=false aria-controls=id2eb2e42ef993b83e59ee7a52140545f8><i class="fa-solid fa-angle-right" id=caret-id2eb2e42ef993b83e59ee7a52140545f8></i></a></div><ul class="nav docs-sidenav collapse" id=id2eb2e42ef993b83e59ee7a52140545f8><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/>析构函数</a></li></ul></div><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%87%8D%E8%BD%BD/>继承与重载</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id46a77e02d52b90d41e4c902a0b7a8eb3")' href=#id46a77e02d52b90d41e4c902a0b7a8eb3 aria-expanded=false aria-controls=id46a77e02d52b90d41e4c902a0b7a8eb3 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idd63adc438d6d70c79381ae26a7a22de5")' href=#idd63adc438d6d70c79381ae26a7a22de5 aria-expanded=false aria-controls=idd63adc438d6d70c79381ae26a7a22de5 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idd63adc438d6d70c79381ae26a7a22de5 aria-expanded=false aria-controls=idd63adc438d6d70c79381ae26a7a22de5><i class="fa-solid fa-angle-right" id=caret-idd63adc438d6d70c79381ae26a7a22de5></i></a></div><ul class="nav docs-sidenav collapse" id=idd63adc438d6d70c79381ae26a7a22de5><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F/>向量</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/>序列类型</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id85a2d1184b84fa61a18f7909a6feef4e")' href=#id85a2d1184b84fa61a18f7909a6feef4e aria-expanded=false aria-controls=id85a2d1184b84fa61a18f7909a6feef4e aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/>指针与引用</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id85a2d1184b84fa61a18f7909a6feef4e aria-expanded=false aria-controls=id85a2d1184b84fa61a18f7909a6feef4e><i class="fa-solid fa-angle-right" id=caret-id85a2d1184b84fa61a18f7909a6feef4e></i></a></div><ul class="nav docs-sidenav collapse" id=id85a2d1184b84fa61a18f7909a6feef4e><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-iddd219365bc1a785be337a8558af296af")' href=#iddd219365bc1a785be337a8558af296af aria-expanded=false aria-controls=iddd219365bc1a785be337a8558af296af aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id3727fff674c8715fe6dcf76250edba5a")' href=#id3727fff674c8715fe6dcf76250edba5a aria-expanded=false aria-controls=id3727fff674c8715fe6dcf76250edba5a aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%BC%95%E7%94%A8/>引用</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id3727fff674c8715fe6dcf76250edba5a aria-expanded=false aria-controls=id3727fff674c8715fe6dcf76250edba5a><i class="fa-solid fa-angle-right" id=caret-id3727fff674c8715fe6dcf76250edba5a></i></a></div><ul class="nav docs-sidenav collapse" id=id3727fff674c8715fe6dcf76250edba5a><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ida8f66656cc3b697541145e917aa3184c")' href=#ida8f66656cc3b697541145e917aa3184c aria-expanded=false aria-controls=ida8f66656cc3b697541145e917aa3184c aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%BC%95%E7%94%A8/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/>移动语义</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ida8f66656cc3b697541145e917aa3184c aria-expanded=false aria-controls=ida8f66656cc3b697541145e917aa3184c><i class="fa-solid fa-angle-right" id=caret-ida8f66656cc3b697541145e917aa3184c></i></a></div><ul class="nav docs-sidenav collapse" id=ida8f66656cc3b697541145e917aa3184c><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%BC%95%E7%94%A8/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/move-%E5%87%BD%E6%95%B0/>move 函数</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%BC%95%E7%94%A8/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/>移动构造函数</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id553299b3080f458774a2bfecebc018b4")' href=#id553299b3080f458774a2bfecebc018b4 aria-expanded=false aria-controls=id553299b3080f458774a2bfecebc018b4 aria-hidden=false data-toggle=collapse></div></div><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%BC%95%E7%94%A8/%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8/>左值引用</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id2c910025bcfc1d28f996cfcf13130b2d")' href=#id2c910025bcfc1d28f996cfcf13130b2d aria-expanded=false aria-controls=id2c910025bcfc1d28f996cfcf13130b2d aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/>右值引用</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id2c910025bcfc1d28f996cfcf13130b2d aria-expanded=false aria-controls=id2c910025bcfc1d28f996cfcf13130b2d><i class="fa-solid fa-angle-right" id=caret-id2c910025bcfc1d28f996cfcf13130b2d></i></a></div><ul class="nav docs-sidenav collapse" id=id2c910025bcfc1d28f996cfcf13130b2d><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/%E6%A1%88%E4%BE%8Bactone-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/>案例：ActOne 右值引用</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/>完美转发</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/>移动语义</a></li></ul></div></ul></div></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id903b8a0ee644122103e233966874f331")' href=#id903b8a0ee644122103e233966874f331 aria-expanded=false aria-controls=id903b8a0ee644122103e233966874f331 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id319c9bea9db6121dd608df88a40e802c")' href=#id319c9bea9db6121dd608df88a40e802c aria-expanded=false aria-controls=id319c9bea9db6121dd608df88a40e802c aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ida67faf576497ffbad01e3ccac5565852")' href=#ida67faf576497ffbad01e3ccac5565852 aria-expanded=false aria-controls=ida67faf576497ffbad01e3ccac5565852 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>04.并发编程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ida67faf576497ffbad01e3ccac5565852 aria-expanded=false aria-controls=ida67faf576497ffbad01e3ccac5565852><i class="fa-solid fa-angle-right" id=caret-ida67faf576497ffbad01e3ccac5565852></i></a></div><ul class="nav docs-sidenav collapse" id=ida67faf576497ffbad01e3ccac5565852><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id0cff40632b8a2c36d25def80a4cd7d27")' href=#id0cff40632b8a2c36d25def80a4cd7d27 aria-expanded=false aria-controls=id0cff40632b8a2c36d25def80a4cd7d27 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idd833deeae01ed488e900024da51a0712")' href=#idd833deeae01ed488e900024da51a0712 aria-expanded=false aria-controls=idd833deeae01ed488e900024da51a0712 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/>并发基础</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idd833deeae01ed488e900024da51a0712 aria-expanded=false aria-controls=idd833deeae01ed488e900024da51a0712><i class="fa-solid fa-angle-right" id=caret-idd833deeae01ed488e900024da51a0712></i></a></div><ul class="nav docs-sidenav collapse" id=idd833deeae01ed488e900024da51a0712><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B/>进程</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/>线程</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id11f51adf99f60988ca7e755c0b036579")' href=#id11f51adf99f60988ca7e755c0b036579 aria-expanded=false aria-controls=id11f51adf99f60988ca7e755c0b036579 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/>线程安全</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id11f51adf99f60988ca7e755c0b036579 aria-expanded=false aria-controls=id11f51adf99f60988ca7e755c0b036579><i class="fa-solid fa-angle-right" id=caret-id11f51adf99f60988ca7e755c0b036579></i></a></div><ul class="nav docs-sidenav collapse" id=id11f51adf99f60988ca7e755c0b036579><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/mutex/>Mutex</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/semaphore/>Semaphore</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E8%AF%BB%E5%86%99%E9%94%81/>读写锁</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E6%AD%BB%E9%94%81/>死锁</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/>条件变量</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E8%87%AA%E6%97%8B%E9%94%81/>自旋锁</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id4b913db1e169f4cf735f440b2c4f3b9c")' href=#id4b913db1e169f4cf735f440b2c4f3b9c aria-expanded=false aria-controls=id4b913db1e169f4cf735f440b2c4f3b9c aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/>线程池</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id4b913db1e169f4cf735f440b2c4f3b9c aria-expanded=false aria-controls=id4b913db1e169f4cf735f440b2c4f3b9c><i class="fa-solid fa-angle-right" id=caret-id4b913db1e169f4cf735f440b2c4f3b9c></i></a></div><ul class="nav docs-sidenav collapse" id=id4b913db1e169f4cf735f440b2c4f3b9c><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%9F%BA%E4%BA%8E-c++-11-%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/>基于 C++ 11 简单线程池实现</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id35215a5071a03f1e8999b1e2817e5c91")' href=#id35215a5071a03f1e8999b1e2817e5c91 aria-expanded=false aria-controls=id35215a5071a03f1e8999b1e2817e5c91 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/>线程协作</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id35215a5071a03f1e8999b1e2817e5c91 aria-expanded=false aria-controls=id35215a5071a03f1e8999b1e2817e5c91><i class="fa-solid fa-angle-right" id=caret-id35215a5071a03f1e8999b1e2817e5c91></i></a></div><ul class="nav docs-sidenav collapse" id=id35215a5071a03f1e8999b1e2817e5c91><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/04.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/>共享内存</a></li></ul></div></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idb39c810b4eb22bc131df61d7cf063596")' href=#idb39c810b4eb22bc131df61d7cf063596 aria-expanded=false aria-controls=idb39c810b4eb22bc131df61d7cf063596 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/10.linux-%E7%BC%96%E7%A8%8B/>10.Linux 编程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idb39c810b4eb22bc131df61d7cf063596 aria-expanded=false aria-controls=idb39c810b4eb22bc131df61d7cf063596><i class="fa-solid fa-angle-right" id=caret-idb39c810b4eb22bc131df61d7cf063596></i></a></div><ul class="nav docs-sidenav collapse" id=idb39c810b4eb22bc131df61d7cf063596><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idb550ae2082dffa15a5b96cf0fdf8fcac")' href=#idb550ae2082dffa15a5b96cf0fdf8fcac aria-expanded=false aria-controls=idb550ae2082dffa15a5b96cf0fdf8fcac aria-hidden=false data-toggle=collapse></div></div></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ideb83c4ebe916de05b6ffc334a3fe1b1a")' href=#ideb83c4ebe916de05b6ffc334a3fe1b1a aria-expanded=false aria-controls=ideb83c4ebe916de05b6ffc334a3fe1b1a aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id944dfec1b36f6fdcc9dd84c37536a277")' href=#id944dfec1b36f6fdcc9dd84c37536a277 aria-expanded=false aria-controls=id944dfec1b36f6fdcc9dd84c37536a277 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>99.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id944dfec1b36f6fdcc9dd84c37536a277 aria-expanded=false aria-controls=id944dfec1b36f6fdcc9dd84c37536a277><i class="fa-solid fa-angle-right" id=caret-id944dfec1b36f6fdcc9dd84c37536a277></i></a></div><ul class="nav docs-sidenav collapse" id=id944dfec1b36f6fdcc9dd84c37536a277><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id279e35e9c71e3473b1a5bb33c91c5a9b")' href=#id279e35e9c71e3473b1a5bb33c91c5a9b aria-expanded=false aria-controls=id279e35e9c71e3473b1a5bb33c91c5a9b aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/>C++ Primer</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id279e35e9c71e3473b1a5bb33c91c5a9b aria-expanded=false aria-controls=id279e35e9c71e3473b1a5bb33c91c5a9b><i class="fa-solid fa-angle-right" id=caret-id279e35e9c71e3473b1a5bb33c91c5a9b></i></a></div><ul class="nav docs-sidenav collapse" id=id279e35e9c71e3473b1a5bb33c91c5a9b><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/01.%E5%BC%80%E5%A7%8B/>01.开始</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/02.%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/>02.变量和基本类型</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/>03.字符串、向量和数组</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/04.%E8%A1%A8%E8%BE%BE%E5%BC%8F/>04.表达式</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/05.%E8%AF%AD%E5%8F%A5/>05.语句</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/06.%E5%87%BD%E6%95%B0/>06.函数</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/07.%E7%B1%BB/>07.类</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/08.io-%E5%BA%93/>08.IO 库</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/09.%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/>09.顺序容器</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/10.%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/>10.泛型算法</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/11.%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/>11.关联容器</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/>12.动态内存</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/13.%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/>13.拷贝控制</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/>14.重载运算与类型转换</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/>15.面向对象程序设计</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/16.%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/>16.模板和泛型编程</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/17.%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/>17.标准库特殊设施</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/18.%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/>18.用于大型程序的工具</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c++-primer/19.%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/>19.特殊工具与技术</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idefb47ec0e2e3de3b2cfaecba1b75cbf1")' href=#idefb47ec0e2e3de3b2cfaecba1b75cbf1 aria-expanded=false aria-controls=idefb47ec0e2e3de3b2cfaecba1b75cbf1 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/>Effective C++</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idefb47ec0e2e3de3b2cfaecba1b75cbf1 aria-expanded=false aria-controls=idefb47ec0e2e3de3b2cfaecba1b75cbf1><i class="fa-solid fa-angle-right" id=caret-idefb47ec0e2e3de3b2cfaecba1b75cbf1></i></a></div><ul class="nav docs-sidenav collapse" id=idefb47ec0e2e3de3b2cfaecba1b75cbf1><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/01.accustoming-yourself-to-cpp/>01.accustoming-yourself-to-cpp</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/02.constructors-destructors-and-assignment-operators/>02.constructors-destructors-and-assignment-operators</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/03.resource-management/>03.resource-management</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/04.designs-and-declarations/>04.designs-and-declarations</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/05.implementations/>05.implementations</a></li><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/06.inheritance-and-objected-oriented-design/>06.inheritance-and-objected-oriented-design</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idcb5f53019405e9c5354701d32f2fb6d5")' href=#idcb5f53019405e9c5354701d32f2fb6d5 aria-expanded=false aria-controls=idcb5f53019405e9c5354701d32f2fb6d5 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id6463a53c8713b669c3cb66e4b2debceb")' href=#id6463a53c8713b669c3cb66e4b2debceb aria-expanded=false aria-controls=id6463a53c8713b669c3cb66e4b2debceb aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%AC%A7%E9%95%BF%E5%9D%A4-%E7%8E%B0%E4%BB%A3-c++-%E6%95%99%E7%A8%8B%E9%AB%98%E9%80%9F%E4%B8%8A%E6%89%8B-c++-11141720/>欧长坤-《现代 C++ 教程：高速上手 C++ 11、14、17、20》</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id6463a53c8713b669c3cb66e4b2debceb aria-expanded=false aria-controls=id6463a53c8713b669c3cb66e4b2debceb><i class="fa-solid fa-angle-right" id=caret-id6463a53c8713b669c3cb66e4b2debceb></i></a></div><ul class="nav docs-sidenav collapse" id=id6463a53c8713b669c3cb66e4b2debceb><li class="child level"><a href=/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%AC%A7%E9%95%BF%E5%9D%A4-%E7%8E%B0%E4%BB%A3-c++-%E6%95%99%E7%A8%8B%E9%AB%98%E9%80%9F%E4%B8%8A%E6%89%8B-c++-11141720/01.%E8%BF%88%E5%90%91%E7%8E%B0%E4%BB%A3-c++/>01.迈向现代 C++</a></li></ul></div></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#特性弃用>特性弃用</a></li><li><a href=#c11-language-features>C++11 Language Features</a><ul><li><a href=#move-semantics>Move semantics</a></li><li><a href=#rvalue-references>Rvalue references</a></li><li><a href=#forwarding-references>Forwarding references</a></li><li><a href=#variadic-templates>Variadic templates</a></li><li><a href=#initializer-lists>Initializer lists</a></li><li><a href=#static-assertions>Static assertions</a></li><li><a href=#auto>auto</a></li><li><a href=#lambda-expressions>Lambda expressions</a></li><li><a href=#decltype>decltype</a></li><li><a href=#type-aliases>Type aliases</a></li><li><a href=#nullptr>nullptr</a></li><li><a href=#strongly-typed-enums>Strongly-typed enums</a></li><li><a href=#attributes>Attributes</a></li><li><a href=#constexpr>constexpr</a></li><li><a href=#delegating-constructors>Delegating constructors</a></li><li><a href=#user-defined-literals>User-defined literals</a></li><li><a href=#explicit-virtual-overrides>Explicit virtual overrides</a></li><li><a href=#final-specifier>Final specifier</a></li><li><a href=#default-functions>Default functions</a></li><li><a href=#deleted-functions>Deleted functions</a></li><li><a href=#range-based-for-loops>Range-based for loops</a></li><li><a href=#special-member-functions-for-move-semantics>Special member functions for move semantics</a></li><li><a href=#converting-constructors>Converting constructors</a></li><li><a href=#explicit-conversion-functions>Explicit conversion functions</a></li><li><a href=#inline-namespaces>Inline namespaces</a></li><li><a href=#non-static-data-member-initializers>Non-static data member initializers</a></li><li><a href=#right-angle-brackets>Right angle brackets</a></li><li><a href=#ref-qualified-member-functions>Ref-qualified member functions</a></li><li><a href=#trailing-return-types>Trailing return types</a></li><li><a href=#noexcept-specifier>Noexcept specifier</a></li></ul></li><li><a href=#c11-library-features>C++11 Library Features</a><ul><li><a href=#stdmove>std::move</a></li><li><a href=#stdforward>std::forward</a></li><li><a href=#stdthread>std::thread</a></li><li><a href=#stdto_string>std::to_string</a></li><li><a href=#type-traits>Type traits</a></li><li><a href=#smart-pointers>Smart pointers</a></li><li><a href=#stdchrono>std::chrono</a></li><li><a href=#tuples>Tuples</a></li><li><a href=#stdtie>std::tie</a></li><li><a href=#stdarray>std::array</a></li><li><a href=#unordered-containers>Unordered containers</a></li><li><a href=#stdmake_shared>std::make_shared</a></li><li><a href=#stdref>std::ref</a></li><li><a href=#memory-model>Memory model</a></li><li><a href=#stdasync>std::async</a></li><li><a href=#stdbeginend>std::begin/end</a></li></ul></li><li><a href=#acknowledgements>Acknowledgements</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>C++ 11</h1><div class=article-style><h1 id=c-11>C++ 11</h1><p>C++ 11 包含下面的新语言特性</p><ul><li><a href=#c-11>C++ 11</a><ul><li><a href=#%e7%89%b9%e6%80%a7%e5%bc%83%e7%94%a8>特性弃用</a></li><li><a href=#c11-language-features>C++11 Language Features</a><ul><li><a href=#move-semantics>Move semantics</a></li><li><a href=#rvalue-references>Rvalue references</a></li><li><a href=#forwarding-references>Forwarding references</a></li><li><a href=#variadic-templates>Variadic templates</a></li><li><a href=#initializer-lists>Initializer lists</a></li><li><a href=#static-assertions>Static assertions</a></li><li><a href=#auto>auto</a></li><li><a href=#lambda-expressions>Lambda expressions</a></li><li><a href=#decltype>decltype</a></li><li><a href=#type-aliases>Type aliases</a></li><li><a href=#nullptr>nullptr</a></li><li><a href=#strongly-typed-enums>Strongly-typed enums</a></li><li><a href=#attributes>Attributes</a></li><li><a href=#constexpr>constexpr</a></li><li><a href=#delegating-constructors>Delegating constructors</a></li><li><a href=#user-defined-literals>User-defined literals</a></li><li><a href=#explicit-virtual-overrides>Explicit virtual overrides</a></li><li><a href=#final-specifier>Final specifier</a></li><li><a href=#default-functions>Default functions</a></li><li><a href=#deleted-functions>Deleted functions</a></li><li><a href=#range-based-for-loops>Range-based for loops</a></li><li><a href=#special-member-functions-for-move-semantics>Special member functions for move semantics</a></li><li><a href=#converting-constructors>Converting constructors</a></li><li><a href=#explicit-conversion-functions>Explicit conversion functions</a></li><li><a href=#inline-namespaces>Inline namespaces</a></li><li><a href=#non-static-data-member-initializers>Non-static data member initializers</a></li><li><a href=#right-angle-brackets>Right angle brackets</a></li><li><a href=#ref-qualified-member-functions>Ref-qualified member functions</a></li><li><a href=#trailing-return-types>Trailing return types</a></li><li><a href=#noexcept-specifier>Noexcept specifier</a></li></ul></li><li><a href=#c11-library-features>C++11 Library Features</a><ul><li><a href=#stdmove>std::move</a></li><li><a href=#stdforward>std::forward</a></li><li><a href=#stdthread>std::thread</a></li><li><a href=#stdto_string>std::to_string</a></li><li><a href=#type-traits>Type traits</a></li><li><a href=#smart-pointers>Smart pointers</a></li><li><a href=#stdchrono>std::chrono</a></li><li><a href=#tuples>Tuples</a></li><li><a href=#stdtie>std::tie</a></li><li><a href=#stdarray>std::array</a></li><li><a href=#unordered-containers>Unordered containers</a></li><li><a href=#stdmake_shared>std::make_shared</a></li><li><a href=#stdref>std::ref</a></li><li><a href=#memory-model>Memory model</a></li><li><a href=#stdasync>std::async</a></li><li><a href=#stdbeginend>std::begin/end</a></li></ul></li><li><a href=#acknowledgements>Acknowledgements</a></li></ul></li></ul><p>C++11 包含以下新库特性：</p><ul><li><a href=#stdmove>std::move</a></li><li><a href=#stdforward>std::forward</a></li><li><a href=#stdthread>std::thread</a></li><li><a href=#stdto_string>std::to_string</a></li><li><a href=#type-traits>type traits</a></li><li><a href=#smart-pointers>smart pointers</a></li><li><a href=#stdchrono>std::chrono</a></li><li><a href=#tuples>tuples</a></li><li><a href=#stdtie>std::tie</a></li><li><a href=#stdarray>std::array</a></li><li><a href=#unordered-containers>unordered containers</a></li><li><a href=#stdmake_shared>std::make_shared</a></li><li><a href=#stdref>std::ref</a></li><li><a href=#memory-model>memory model</a></li><li><a href=#stdasync>std::async</a></li><li><a href=#stdbeginend>std::begin/end</a></li></ul><h2 id=特性弃用>特性弃用</h2><p>在学习 C++ 1x 之前，我们先了解一下从 C++ 11 开始，被弃用的主要特性：</p><blockquote><p><strong>注意</strong>：弃用不等于废弃，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，这些特性其实会永久保留。</p></blockquote><ul><li><strong>如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。</strong></li><li><strong>不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。</strong></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=s>&#34;hello world!&#34;</span><span class=p>;</span> <span class=c1>// 将出现弃用警告
</span></span></span></code></pre></div><ul><li><strong>C++98 异常说明、unexcepted_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。</strong></li><li><strong>auto_ptr 被弃用，应使用 unique_ptr。</strong></li><li><strong>register 关键字被弃用。</strong></li><li><strong>bool 类型的 ++ 操作被弃用。</strong></li><li><strong>C 语言风格的类型转换被弃用，应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。</strong></li></ul><p>还有一些其他诸如参数绑定（C++11 提供了 <code>std::bind</code> 和 <code>std::function</code>）、<code>export</code> 等特性也均被弃用。前面提到的这些特性<strong>如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠拢</strong>，直接学习新特性。毕竟，技术是向前发展的。</p><h2 id=c11-language-features>C++11 Language Features</h2><h3 id=move-semantics>Move semantics</h3><p><strong>移动语义</strong></p><p>移动一个对象意味着转移某些资源的所有权给另一个对象去管理。</p><p>移动语义的首个收益就是性能优化。</p><p>当一个对象的生命到达终点时，或临时对象，或显式调用<code>std::move</code>，“移动”是一次更轻量的资源转移方式。举个例子，“移动”一个<code>std::vector</code>仅仅拷贝一些指针和内部状态到新向量，“拷贝”需要拷贝<code>vector</code>中的每一个元素，如果这个被拷贝的<code>vector</code>马上被销毁，那么“拷贝”的代价是很高昂的且不是必要的。</p><p>移动也允许非复制类型如<code>std::unique_ptr</code> (<a href=#smart-pointers>smart pointers</a>) 在语言层面保证一个实例只被一个资源所管理，然而可以在各个作用域之间传递实例。</p><p>查看相关部分: <a href=#rvalue-references>rvalue references</a>, <a href=#special-member-functions-for-move-semantics>special member functions for move semantics</a>, <a href=#stdmove><code>std::move</code></a>, <a href=#stdforward><code>std::forward</code></a>, <a href=#forwarding-references><code>forwarding references</code></a>.</p><h3 id=rvalue-references>Rvalue references</h3><p><strong>右值引用</strong></p><p>C++11 引入了一种新的引用被称为右值引用。使用<code>T&&</code>来创建一个非 template 类型(如<code>int</code>，或用户自定义类型)<code>T</code>的右值引用。右值引用只会绑定右值。</p><p>左值和右值的描述：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// `x` is an lvalue of type `int`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>xl</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// `xl` is an lvalue of type `int&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;&amp;</span> <span class=n>xr</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// compiler error -- `x` is an lvalue
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;&amp;</span> <span class=n>xr2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// `xr2` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`
</span></span></span></code></pre></div><p><strong>注意</strong>：这里要区分好右值和绑定右值的左值(如上述，0 是右值，但是 xr2 是左值。)</p><p>查看: <a href=#stdmove><code>std::move</code></a>, <a href=#stdforward><code>std::forward</code></a>, <a href=#forwarding-references><code>forwarding references</code></a>.</p><h3 id=forwarding-references>Forwarding references</h3><p><strong>转发引用</strong></p><p>也被称为万能引用。转发引用的创建方式有两种：当<code>T</code>是 template 类型参数时，使用<code>T&&</code>语法被创建；或者使用<code>auto&&</code>。这使得<strong>完美转发</strong>成为可能：传递参数同时维护其值类别的能力 (例如 左值还是左值, 临时变量转发为右值)。</p><p>转发引用允许一个引用既可以绑定左值类型又可以绑定右值类型。转发引用遵循<strong>引用坍缩</strong>规则：</p><ul><li><code>T& &</code> 坍缩成 <code>T&</code></li><li><code>T& &&</code> 坍缩成 <code>T&</code></li><li><code>T&& &</code> 坍缩成 <code>T&</code></li><li><code>T&& &&</code> 坍缩成 <code>T&&</code></li></ul><p><code>auto</code> 类型推导左值和右值:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// `x` is an lvalue of type `int`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>al</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// `al` is an lvalue of type `int&amp;` -- binds to the lvalue, `x`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>ar</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// `ar` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`
</span></span></span></code></pre></div><p>template 类型推导左值和右值:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Since C++14 or later:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Since C++11 or later:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp;&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>y</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;&amp;</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// NOTE: `z` is an lvalue with type `int&amp;&amp;`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>z</span><span class=p>);</span> <span class=c1>// deduces as f(int&amp;&amp; &amp;) =&gt; f(int&amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>z</span><span class=p>));</span> <span class=c1>// deduces as f(int&amp;&amp; &amp;&amp;) =&gt; f(int&amp;&amp;)
</span></span></span></code></pre></div><p>查看: <a href=#stdmove><code>std::move</code></a>, <a href=#stdforward><code>std::forward</code></a>, <a href=#rvalue-references><code>rvalue references</code></a>.</p><h3 id=variadic-templates>Variadic templates</h3><p><strong>变参模板</strong></p><p><code>...</code>语法用来创建或展开一个参数包。模板参数包是一个接受 0 个或更多模板参数。 具有至少一个参数包的模板称为可变参数模板。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>arity</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>...(</span><span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>arity</span><span class=o>&lt;&gt;::</span><span class=n>value</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>arity</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>short</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>value</span> <span class=o>==</span> <span class=mi>3</span><span class=p>);</span>
</span></span></code></pre></div><p>一个有趣的用途是从一个参数包创建一个初始化器列表，以便遍历可变参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>First</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>sum</span><span class=p>(</span><span class=k>const</span> <span class=n>First</span> <span class=n>first</span><span class=p>,</span> <span class=k>const</span> <span class=n>Args</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=k>auto</span> <span class=n>values</span> <span class=o>=</span> <span class=p>{</span><span class=n>first</span><span class=p>,</span> <span class=n>args</span><span class=p>...};</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>accumulate</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>First</span><span class=p>{</span><span class=mi>0</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sum</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> <span class=c1>// 15
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sum</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>       <span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sum</span><span class=p>(</span><span class=mf>1.5</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.7</span><span class=p>);</span> <span class=c1>// 7.2
</span></span></span></code></pre></div><p>**注意：**变参模板的用法不只这些，如<code>tuple</code>就是用变参模板实现的，其能存储不同类型的值，这里只是简单介绍它不定长的特点。</p><h3 id=initializer-lists>Initializer lists</h3><p><strong>初始化列表</strong></p><p>使用"初始化列表"语法创建的轻量级类似数组的元素容器。例如<code>{1, 2, 3}</code>创建了一个整数的序列，类型是<code>std::initializer_list&lt;int></code>。用<code>std::initializer_list&lt;int></code>来替换传递给函数的<code>vector</code>(或其他支持初始化列表的容器)的对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>e</span> <span class=p>:</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>+=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>total</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>list</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>sum</span><span class=p>(</span><span class=n>list</span><span class=p>);</span> <span class=c1>// == 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sum</span><span class=p>({</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>});</span> <span class=c1>// == 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sum</span><span class=p>({});</span> <span class=c1>// == 0
</span></span></span></code></pre></div><h3 id=static-assertions>Static assertions</h3><p><strong>静态断言</strong></p><p>静态断言在编译器就会被评估。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=n>y</span><span class=p>,</span> <span class=s>&#34;x != y&#34;</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=auto>auto</h3><p><code>auto</code>-类型的变量是由编译器根据它们初始化器的类型推导出来的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=mf>3.14</span><span class=p>;</span> <span class=c1>// double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;</span> <span class=n>c</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span> <span class=c1>// int&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>d</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span> <span class=c1>// std::initializer_list&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>e</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// int&amp;&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span> <span class=c1>// int&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>g</span> <span class=o>=</span> <span class=k>new</span> <span class=k>auto</span><span class=p>(</span><span class=mi>123</span><span class=p>);</span> <span class=c1>// int*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>h</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// const int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// int, int, int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>=</span> <span class=nb>true</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=mf>1.61</span><span class=p>;</span> <span class=c1>// error -- `l` deduced to be int, `m` is bool
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>o</span><span class=p>;</span> <span class=c1>// error -- `o` requires initializer
</span></span></span></code></pre></div><p><code>auto</code>对可读性及其有益，尤其是特别复杂的类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=p>...;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>const_iterator</span> <span class=n>cit</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>cbegin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// vs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>cit</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>cbegin</span><span class=p>();</span>
</span></span></code></pre></div><p>函数也可以使用<code>auto</code>来进行返回类型的推导。在 C++11 中，返回类型必须显示指定，或者使用<code>decltype</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>X</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Y</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>add</span><span class=p>(</span><span class=n>X</span> <span class=n>x</span><span class=p>,</span> <span class=n>Y</span> <span class=n>y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// == 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>);</span> <span class=c1>// == 3.0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>add</span><span class=p>(</span><span class=mf>1.5</span><span class=p>,</span> <span class=mf>1.5</span><span class=p>);</span> <span class=c1>// == 3.0
</span></span></span></code></pre></div><p>上面例子中的后置返回类型是表达式<code>x + y</code>所声明的类型。举个例子，如果<code>x</code>是个整形，<code>y</code>是 double 类型，<code>decltype(x + y)</code>是 double。因此，上面函数将依据表达式<code>x + y</code>的类型来推导返回类型。</p><p>注意：后置返回类型只能访问函数参数，也可调用参数的<code>this</code>相关功能</p><h3 id=lambda-expressions>Lambda expressions</h3><p><strong>lambda 表达式</strong></p><p><code>lambda</code> 是一个可以在当前作用域中捕捉变量的无名函数对象。</p><p>它由五部分组成：捕捉列表，参数列表，函数属性，后置返回类型，函数体。其中 2，3，4 部分可以省略</p><p>一个完整的例子如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>func</span> <span class=o>=</span> <span class=p>[]()</span><span class=k>mutable</span> <span class=o>-&gt;</span> <span class=kt>int</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// [] 为捕捉列表
</span></span></span><span class=line><span class=cl><span class=c1>// ()为参数列表，当空可省略
</span></span></span><span class=line><span class=cl><span class=c1>// mutable,表示按值传递捕捉列表，可以修改捕捉列表中的变量，但不会影响外部变量,当空可省略。当其存在时，参数列表必须也存在。
</span></span></span><span class=line><span class=cl><span class=c1>// -&gt; int 后置返回类型，如果是 void 可省略。
</span></span></span><span class=line><span class=cl><span class=c1>// { return 1; }; 函数体
</span></span></span></code></pre></div><p>捕捉列表如下:</p><ul><li><code>[]</code> - 什么也不捕捉，表示函数完全用不到当前作用域的其他变量</li><li><code>[=]</code> - 捕捉当前作用域内函数定义之前的所有局部变量(如果当前所处在一个函数中，那么参数也算)，但是以值传递来使用。</li><li><code>[&]</code> - 作用同上，但是捕捉变量以引用形式进行传递。</li><li><code>[this]</code> - 捕获当前 lambda 所在的对象的 this 指针。</li><li><code>[a]</code> - 将 a 按照值进行传递。</li><li><code>[&a]</code> - 将 a 按照引用传递。</li><li><code>[a, &b]</code> - 将 a 按值传递，b 按引用传递</li><li><code>[=，&a，&b]</code> - 除 a 和 b 按引用进行传递外，其他参数都按值进行传递。</li><li><code>[&，a，b]</code> - 除 a 和 b 按值进行传递外，其他参数都按引用进行传递。</li></ul><p>注意：捕捉的范围是当前作用域内 lambda 表达式定义之前所声明的变量。不包括常量和全局变量(这两项不捕捉也可以访问)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>getX</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>]</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>getX</span><span class=p>();</span> <span class=c1>// == 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>addX</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>](</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>addX</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=c1>// == 2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>getXRef</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>]()</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>getXRef</span><span class=p>();</span> <span class=c1>// int&amp; to `x`
</span></span></span></code></pre></div><p>默认情况下，按值捕捉的变量在 lambda 中不可以被修改，因为编译器在生成时将捕捉变量标记成了<code>const</code>，<code>mutable</code>关键字允许修改捕捉变量。关键字被置在参数列表后面(即使参数列表是空也要为<code>mutable</code>而存在)。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>f1</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=n>x</span><span class=p>]</span> <span class=p>{</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=p>};</span> <span class=c1>// OK: x is a reference and modifies the original
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>f2</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=p>{</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=p>};</span> <span class=c1>// ERROR: the lambda can only perform const-operations on the captured value
</span></span></span><span class=line><span class=cl><span class=c1>// vs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>f3</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span><span class=p>]()</span> <span class=k>mutable</span> <span class=p>{</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=p>};</span> <span class=c1>// OK: the lambda can perform any operations on the captured value
</span></span></span></code></pre></div><h3 id=decltype>decltype</h3><p><code>decltype</code>是一个用来返回表达式声明类型的操作，其也会维护表达式中的<strong>cv 限定符</strong>和<strong>引用</strong>。</p><p><code>decltype</code>例子:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// `a` is declared as type `int`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// `decltype(a)` is `int`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>c</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// `c` is declared as type `const int&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=n>d</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// `decltype(c)` is `const int&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=mi>123</span><span class=p>)</span> <span class=n>e</span> <span class=o>=</span> <span class=mi>123</span><span class=p>;</span> <span class=c1>// `decltype(123)` is `int`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>&amp;&amp;</span> <span class=n>f</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// `f` is declared as type `int&amp;&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>f</span><span class=p>)</span> <span class=n>g</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// `decltype(f) is `int&amp;&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>((</span><span class=n>a</span><span class=p>))</span> <span class=n>h</span> <span class=o>=</span> <span class=n>g</span><span class=p>;</span> <span class=c1>// `decltype((a))` is int&amp;
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>X</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Y</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>add</span><span class=p>(</span><span class=n>X</span> <span class=n>x</span><span class=p>,</span> <span class=n>Y</span> <span class=n>y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>);</span> <span class=c1>// `decltype(x + y)` =&gt; `decltype(3.0)` =&gt; `double`
</span></span></span></code></pre></div><p><strong>注意</strong>：decltype 的细节比较多，如上述例子中的<code>decltype(a)</code>和<code>decltype((a))</code>，很容易定义错类型，建议<strong>只在模板函数</strong>的返回值中使用。</p><p>相关查看: <code>decltype(auto)</code> (C++14).</p><h3 id=type-aliases>Type aliases</h3><p><strong>类型别名</strong></p><p>在语义上和<code>typedef</code>相近，但是<code>using</code>更为简洁，且兼容模板。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Vec</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Vec</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span> <span class=c1>// std::vector&lt;int&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>String</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>String</span> <span class=n>s</span> <span class=p>{</span><span class=s>&#34;foo&#34;</span><span class=p>};</span>
</span></span></code></pre></div><h3 id=nullptr>nullptr</h3><p><strong>空指针</strong></p><p>C++11 引入了一种全新的空指针类型用来替代 C 语言中的<code>NUll</code>宏。<code>nullptr</code>的类型是<code>std::nullptr_t</code>,可以隐式的转成指针类型、<code>bool</code>类型。但是<code>nullptr</code>不可以隐式的转成整形，这是<code>nullptr</code>和<code>NULL</code>的最大不同，解决了<code>NULL</code>在特定情况下的调用歧义问题。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span> <span class=c1>// error -- ambiguous
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>foo</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span> <span class=c1>// calls foo(char*)
</span></span></span></code></pre></div><h3 id=strongly-typed-enums>Strongly-typed enums</h3><p><strong>强类型枚举</strong></p><p>类型安全枚举解决了 C 格式枚举中的一系列问题：隐式转换，不能指定基础类型，作用域污染。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Specifying underlying type as `unsigned int`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=k>class</span> <span class=nc>Color</span> <span class=o>:</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=p>{</span> <span class=n>Red</span> <span class=o>=</span> <span class=mh>0xff0000</span><span class=p>,</span> <span class=n>Green</span> <span class=o>=</span> <span class=mh>0xff00</span><span class=p>,</span> <span class=n>Blue</span> <span class=o>=</span> <span class=mh>0xff</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// `Red`/`Green` in `Alert` don&#39;t conflict with `Color`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=k>class</span> <span class=nc>Alert</span> <span class=o>:</span> <span class=kt>bool</span> <span class=p>{</span> <span class=n>Red</span><span class=p>,</span> <span class=n>Green</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Color</span> <span class=n>c</span> <span class=o>=</span> <span class=n>Color</span><span class=o>::</span><span class=n>Red</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=attributes>Attributes</h3><p>Attributes 为 <code>__attribute__(...)</code>, <code>__declspec</code>等属性提供了通用语法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// `noreturn` attribute indicates `f` doesn&#39;t return.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=na>[[ noreturn ]]</span> <span class=kt>void</span> <span class=n>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>throw</span> <span class=s>&#34;error&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>**注意：**个人没咋用过，感觉即使能优化也有限，尽量少用。</p><h3 id=constexpr>constexpr</h3><p><strong>常量表达式</strong></p><p>常量表达式是编译器在编译时计算的表达式。在常量表达式中，只有简单的计算才可以被执行。使用<code>constexpr</code>来将一个变量，函数等指定为常量表达式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>square</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>square2</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>square</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>  <span class=c1>// mov DWORD PTR [rbp-4], 4
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=n>square2</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=c1>// mov edi, 2
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// call square2(int)
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// mov DWORD PTR [rbp-8], eax
</span></span></span></code></pre></div><p>**注意：**当函数被标为 square，但是参数传进来的不是常量表达式(在编译期不能得到值)，那么函数还是会像正常函数一样被初始化，然后调用函数等操作。</p><p><code>constexpr</code> 变量要在编译期就被计算出来:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// error -- constexpr variable `y` must be initialized by a constant expression
</span></span></span></code></pre></div><p>类使用常量表达式:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=nf>Complex</span><span class=p>(</span><span class=kt>double</span> <span class=n>r</span><span class=p>,</span> <span class=kt>double</span> <span class=n>i</span><span class=p>)</span> <span class=o>:</span> <span class=n>re</span><span class=p>{</span><span class=n>r</span><span class=p>},</span> <span class=n>im</span><span class=p>{</span><span class=n>i</span><span class=p>}</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>double</span> <span class=nf>real</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>re</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>double</span> <span class=nf>imag</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>im</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>re</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>im</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>Complex</span> <span class=nf>I</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>**注意：**个人在开发中目前还没见过类对象使用常量表达式，在编译期就能确定的类对象比较少，在一个为了一点优化舍弃可读性，感觉不值当。</p><h3 id=delegating-constructors>Delegating constructors</h3><p><strong>委托构造</strong></p><p>构造函数可以使用初始化列表来调用当前类中其他的构造函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>foo</span><span class=p>)</span> <span class=o>:</span> <span class=n>foo</span><span class=p>{</span><span class=n>foo</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>foo</span><span class=p>.</span><span class=n>foo</span><span class=p>;</span> <span class=c1>// == 0
</span></span></span></code></pre></div><h3 id=user-defined-literals>User-defined literals</h3><p><strong>用户自定义字面值</strong></p><p>用户自定义字面值允许你扩展语言，添加你自己的语法。定义一个<code>T operator "" X(...) { ... }</code>，返回值是<code>T</code>类型，名字是<code>X</code>的函数。名字<code>X</code>就是你要使用的字面值。<code>X</code>要以下划线起始，否则不会被调用。函数的参数类型有以下几个选项：<code>unsigned long long</code>，<code>long double</code>，<code>char</code>，<code>wchar_t</code>，<code>char16_t</code>，<code>char32_t</code>，<code>const char *</code></p><p>例子 1:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// `unsigned long long` parameter required for integer literal.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>long</span> <span class=kt>long</span> <span class=k>operator</span> <span class=s>&#34;&#34;</span> <span class=n>_celsius</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>tempCelsius</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>llround</span><span class=p>(</span><span class=n>tempCelsius</span> <span class=o>*</span> <span class=mf>1.8</span> <span class=o>+</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=mi>24</span><span class=n>_celsius</span><span class=p>;</span> <span class=c1>// == 75
</span></span></span></code></pre></div><p>例子 2:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// `const char*` and `std::size_t` required as parameters.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=k>operator</span> <span class=s>&#34;&#34;</span> <span class=n>_int</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>stoi</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=s>&#34;123&#34;</span><span class=n>_int</span><span class=p>;</span> <span class=c1>// == 123, with type `int`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 作用同上
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=k>operator</span> <span class=s>&#34;&#34;</span> <span class=n>_int</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>stoi</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mi>123</span><span class=n>_int</span><span class=p>;</span> <span class=c1>// == 123, with type `int`
</span></span></span></code></pre></div><h3 id=explicit-virtual-overrides>Explicit virtual overrides</h3><p><strong>显式虚函数重写</strong></p><p>指定一个虚函数重写于另一个虚函数。使用<code>override</code>但是虚函数并没有重写基类虚函数的话，会提示编译错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span> <span class=o>:</span> <span class=n>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// correct -- B::foo overrides A::foo
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>bar</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// error -- A::bar is not virtual
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>baz</span><span class=p>()</span> <span class=k>override</span><span class=p>;</span> <span class=c1>// error -- B::baz does not override A::baz
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h3 id=final-specifier>Final specifier</h3><p><strong>Final 指示符</strong></p><p>指定当前虚函数不可以在派生类中被重写，或指定当前类不可被继承。</p><p>虚函数不可被重写：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span> <span class=o>:</span> <span class=n>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=k>final</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>C</span> <span class=o>:</span> <span class=n>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>();</span> <span class=c1>// error -- declaration of &#39;foo&#39; overrides a &#39;final&#39; function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>类不可被继承：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=k>final</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span> <span class=o>:</span> <span class=n>A</span> <span class=p>{};</span> <span class=c1>// error -- base &#39;A&#39; is marked &#39;final&#39;
</span></span></span></code></pre></div><h3 id=default-functions>Default functions</h3><p><strong>默认函数</strong></p><p>提供一种更优雅，更有效的函数的默认实现方式，比如构造函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>x</span><span class=p>{</span><span class=n>x</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span> <span class=p>{</span><span class=mi>1</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// a.x == 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>a2</span> <span class=p>{</span><span class=mi>123</span><span class=p>};</span> <span class=c1>// a.x == 123
</span></span></span></code></pre></div><p>继承:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>B</span><span class=p>()</span> <span class=o>:</span> <span class=n>x</span><span class=p>{</span><span class=mi>1</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>C</span> <span class=o>:</span> <span class=n>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Calls B::B
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>C</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>C</span> <span class=n>c</span><span class=p>;</span> <span class=c1>// c.x == 1
</span></span></span></code></pre></div><h3 id=deleted-functions>Deleted functions</h3><p><strong>删除函数</strong></p><p>提供一种更优雅，更有效的函数的删除实现方式。如阻止对象的拷贝：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>x</span><span class=p>{</span><span class=n>x</span><span class=p>}</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>x</span> <span class=p>{</span><span class=mi>123</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// error -- call to deleted copy constructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// error -- operator= deleted
</span></span></span></code></pre></div><h3 id=range-based-for-loops>Range-based for loops</h3><p>可迭代容器的循环语法糖。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>a</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>a</span><span class=p>)</span> <span class=n>x</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// a == { 2, 4, 6, 8, 10 }
</span></span></span></code></pre></div><p>注意<code>int</code>和<code>int&</code>的区别。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=o>&gt;</span> <span class=n>a</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>a</span><span class=p>)</span> <span class=n>x</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// a == { 1, 2, 3, 4, 5 }
</span></span></span></code></pre></div><h3 id=special-member-functions-for-move-semantics>Special member functions for move semantics</h3><p><strong>移动构造函数</strong></p><p>当复制操作发生时，拷贝构造函数和拷贝赋值运算符会被调用。C++11 引入了右值语义，所以支持了移动构造和移动赋值运算符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>()</span> <span class=o>:</span> <span class=n>s</span><span class=p>{</span><span class=s>&#34;test&#34;</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span> <span class=n>o</span><span class=p>)</span> <span class=o>:</span> <span class=n>s</span><span class=p>{</span><span class=n>o</span><span class=p>.</span><span class=n>s</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=n>A</span><span class=o>&amp;&amp;</span> <span class=n>o</span><span class=p>)</span> <span class=o>:</span> <span class=n>s</span><span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>o</span><span class=p>.</span><span class=n>s</span><span class=p>)}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>A</span><span class=o>&amp;&amp;</span> <span class=n>o</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>s</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>o</span><span class=p>.</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=nf>f</span><span class=p>(</span><span class=n>A</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a1</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>A</span><span class=p>{});</span> <span class=c1>// move-constructed from rvalue temporary
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a1</span><span class=p>);</span> <span class=c1>// move-constructed using std::move
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>a3</span> <span class=o>=</span> <span class=n>A</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>a2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a3</span><span class=p>);</span> <span class=c1>// move-assignment using std::move
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a1</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>A</span><span class=p>{});</span> <span class=c1>// move-assignment from rvalue temporary
</span></span></span></code></pre></div><p>**注意：**只要注意到确实调用了移动函数就可以，不要细纠结调用顺序，层次等，编译器添加了许多开发者不知的编译优化如 RVO，NRVO，掺在一起，迷糊的很。</p><h3 id=converting-constructors>Converting constructors</h3><p><strong>转换构造</strong>(我觉得叫统一构造比较好)</p><p>C++11 统一了初始化方式，可以用<code>{}</code>来初始化所有对象。</p><p>编译器会构造一个类似<code>tuple</code>的容器，然后看当前类是否带有初始化列表的构造函数，如果有且数据类型能对应上，那么直接调用:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ii&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>il</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;il&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>};</span> <span class=c1>// calls A::A(initializer_list&lt;int&gt; il)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=nf>b</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// calls A::A(int, int)
</span></span></span></code></pre></div><p>如果对应不上的类型都是由精度缺失引起的(如传入的是<code>double</code>但初始化列表类型是<code>int</code>)，那么程序会报错；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;id&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>il</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;il&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>};</span> <span class=c1>// error! &#39;double&#39; cannot be narrowed to &#39;int&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=nf>b</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>);</span> <span class=c1>// calls A::A(int, double)
</span></span></span></code></pre></div><p>如果对应不上的类型完全不一致(如初始化列表是<code>int</code>但传入的<code>string</code>) 或 当前类没有初始化列表构造函数，再调用相应的构造函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=p>,</span> <span class=n>string</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;ids&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;il&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=s>&#34;abc&#34;</span><span class=p>};</span> <span class=c1>// calls A::A(int, double, string)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>b</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span> <span class=c1>// calls A::A(initializer_list&lt;int&gt;)
</span></span></span></code></pre></div><p>**注意：**任何时刻大括号中的参数传入时都不允许精度缺失。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=nf>a</span><span class=p>(</span><span class=mf>1.1</span><span class=p>);</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>b</span> <span class=p>{</span><span class=mf>1.1</span><span class=p>};</span> <span class=c1>// Error narrowing conversion from double to int
</span></span></span></code></pre></div><h3 id=explicit-conversion-functions>Explicit conversion functions</h3><p><strong>显式转换函数</strong></p><p>转换函数可以通过<code>explicit</code>标识符来置位显式声明，禁止隐式转换。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>operator</span> <span class=nf>bool</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=k>operator</span> <span class=nf>bool</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// OK calls A::operator bool()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>ba</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// OK copy-initialization selects A::operator bool()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>);</span> <span class=c1>// OK calls B::operator bool()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>bb</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span> <span class=c1>// error copy-initialization does not consider B::operator bool()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>bbb</span> <span class=o>=</span> <span class=kt>bool</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>	<span class=c1>// OK
</span></span></span></code></pre></div><h3 id=inline-namespaces>Inline namespaces</h3><p><strong>内联命名空间</strong></p><p>将内联名称空间的所有成员视为其父名称空间的一部分，从而允许函数的专门化并简化版本控制过程。 这是一个传递属性，如果 a 包含 b，而 b 又包含 c，而 b 和 c 都是内联名称空间，那么 c 的成员就可以像在 a 上一样使用。</p><p>将内联命名空间的所有成员视为它们是在其父亲的命名空间下，从而使函数专有化(只属于某个作用域)并简化版本控制过程(将当前版本函数的命名空间设置成 inline)。这个属性是可传递的，如果 A 包含 B，B 又包含 C，而 B 和 C 都被声明成了内联，那么 A 可以直接使用 C 中的成员。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Program</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>namespace</span> <span class=n>Version1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>getVersion</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isFirstVersion</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>inline</span> <span class=k>namespace</span> <span class=n>Version2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>getVersion</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>2</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>version</span> <span class=p>{</span><span class=n>Program</span><span class=o>::</span><span class=n>getVersion</span><span class=p>()};</span>              <span class=c1>// Uses getVersion() from Version2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>oldVersion</span> <span class=p>{</span><span class=n>Program</span><span class=o>::</span><span class=n>Version1</span><span class=o>::</span><span class=n>getVersion</span><span class=p>()};</span> <span class=c1>// Uses getVersion() from Version1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>firstVersion</span> <span class=p>{</span><span class=n>Program</span><span class=o>::</span><span class=n>isFirstVersion</span><span class=p>()};</span>    <span class=c1>// Does not compile when Version2 is added
</span></span></span></code></pre></div><h3 id=non-static-data-member-initializers>Non-static data member initializers</h3><p>允许在声明非静态数据成员的地方初始化它们，但构造函数中重复赋值会覆盖他们。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// C++11 之前
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Human</span><span class=p>()</span> <span class=o>:</span> <span class=n>age</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// C++11 及之后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=n>age</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=right-angle-brackets>Right angle brackets</h3><p><strong>右角括号</strong></p><p>从 C++11 开始，允许多个右角括号连在一起，不需要添加空白格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span> <span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span> <span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>cpp98LongTypedef</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span> <span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span> <span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;&gt;</span>   <span class=n>cpp11LongTypedef</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=ref-qualified-member-functions>Ref-qualified member functions</h3><p><strong>引用限定成员函数</strong></p><p>相同的成员函数函数，现在可以根据<code>*this</code>是左值还是右值引用来调用不同的重载。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Bar</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Bar</span> <span class=nf>getBar</span><span class=p>()</span> <span class=o>&amp;</span> <span class=p>{</span> <span class=k>return</span> <span class=n>bar</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>Bar</span> <span class=nf>getBar</span><span class=p>()</span> <span class=k>const</span><span class=o>&amp;</span> <span class=p>{</span> <span class=k>return</span> <span class=n>bar</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>Bar</span> <span class=nf>getBar</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>bar</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>Bar</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>Bar</span> <span class=n>bar</span> <span class=o>=</span> <span class=n>foo</span><span class=p>.</span><span class=n>getBar</span><span class=p>();</span> <span class=c1>// calls `Bar getBar() &amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>Foo</span> <span class=n>foo2</span><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=n>Bar</span> <span class=n>bar2</span> <span class=o>=</span> <span class=n>foo2</span><span class=p>.</span><span class=n>getBar</span><span class=p>();</span> <span class=c1>// calls `Bar Foo::getBar() const&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=p>{}.</span><span class=n>getBar</span><span class=p>();</span> <span class=c1>// calls `Bar Foo::getBar() &amp;&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>foo</span><span class=p>).</span><span class=n>getBar</span><span class=p>();</span> <span class=c1>// calls `Bar Foo::getBar() &amp;&amp;`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>foo2</span><span class=p>).</span><span class=n>getBar</span><span class=p>();</span> <span class=c1>// calls `Bar Foo::getBar() const&amp;&amp;`
</span></span></span></code></pre></div><h3 id=trailing-return-types>Trailing return types</h3><p><strong>后置返回类型</strong></p><p>C++11 中函数或 lambda 表达式定义返回类型的新语法格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// vs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=nf>f</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>g</span> <span class=o>=</span> <span class=p>[]()</span> <span class=o>-&gt;</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>123</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>当返回类型不能被立即确定时，这个特点会非常有用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// NOTE: This does not compile!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>decltype</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>)</span> <span class=n>add</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>U</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Trailing return types allows this:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>add</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>U</span> <span class=n>b</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 C++14 中，可以使用<code>decltype(auto)</code>来替代。</p><h3 id=noexcept-specifier>Noexcept specifier</h3><p><strong>无异常说明符</strong></p><p><code>noexcept</code> 说明符指定一个函数是否会返回异常. 它是 <code>throw()</code>的进阶版。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func1</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>        <span class=c1>// does not throw，一般用这个就够了
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func2</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>  <span class=c1>// does not throw
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>func3</span><span class=p>()</span> <span class=k>throw</span><span class=p>();</span>         <span class=c1>// does not throw
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func4</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span> <span class=c1>// may throw
</span></span></span></code></pre></div><p>Non-throwing 函数被允许去调用存在异常的函数。当一个异常被抛出，寻找处理异常的 handler 时，当递归到一个 Non-throwing 函数时，函数直接回调用<code>std::terminate</code>来结束程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>extern</span> <span class=kt>void</span> <span class=nf>f</span><span class=p>();</span>  <span class=c1>// 可能会有异常
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>g</span><span class=p>()</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>();</span>          <span class=c1>// 合法，即使f可能有异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>throw</span> <span class=mi>42</span><span class=p>;</span>     <span class=c1>// 合法, 调用std::terminate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=c11-library-features>C++11 Library Features</h2><h3 id=stdmove>std::move</h3><p><code>std::move</code>代表对象在传入的时候有可能会有资源传输。当使用调用过<code>std::move</code>的对象的时候应该小心，因为他的某些值可能已经处于一个未知的状态。</p><p><code>std::move</code>定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl><span class=n>move</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// remove_reference 作用是去除T类型的引用
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;&amp;&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>std::unique_ptr</code>中的使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p1</span> <span class=p>{</span><span class=k>new</span> <span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>}};</span>  <span class=c1>// in practice, use std::make_unique
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>p1</span><span class=p>;</span> <span class=c1>// error -- cannot copy unique pointers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p3</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span> <span class=c1>// move `p1` into `p3`
</span></span></span><span class=line><span class=cl><span class=c1></span>                                         <span class=c1>// now unsafe to dereference object held by `p1`
</span></span></span></code></pre></div><h3 id=stdforward>std::forward</h3><p>返回的结果的值和传递给它的参数的值相同，同时维护了参数的值种类(左右值)和<code>cv-限定符</code>。对万能模板引用代码很有用。一般与 <a href=#forwarding-references><code>forwarding references</code></a>连用。</p><p><code>std::forward</code>的定义:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=c1>// 当传入是左值时，调用此函数，但传入的左值可能是具名右值，
</span></span></span><span class=line><span class=cl><span class=c1></span>											<span class=c1>// 所以返回结果要看传入的T的具体类型而定。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>forward</span><span class=p>(</span><span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;</span> <span class=n>arg</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&amp;&amp;&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=c1>// 当传入的是纯右值时，调用此函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>forward</span><span class=p>(</span><span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;&amp;</span> <span class=n>arg</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static_assert</span><span class=p>(</span><span class=o>!</span><span class=n>is_lvalue_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span>	<span class=c1>// 如果T的类型是左值引用，报错
</span></span></span><span class=line><span class=cl><span class=c1></span>                  <span class=s>&#34;can not forward an rvalue as an lvalue&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&amp;&amp;&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>例子： <code>wrapper</code>函数仅用传来的 A 对象通过拷贝或移动的方式生成另一个 A 对象</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span> <span class=n>o</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;copied&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=p>(</span><span class=n>A</span><span class=o>&amp;&amp;</span> <span class=n>o</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;moved&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>wrapper</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>A</span><span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>)};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>wrapper</span><span class=p>(</span><span class=n>A</span><span class=p>{});</span> <span class=c1>// moved
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>wrapper</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// copied
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>wrapper</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a</span><span class=p>));</span> <span class=c1>// moved
</span></span></span></code></pre></div><p><strong>注意：</strong><code>std::forward</code>作用主要有两个，一是将具名右值在传递时继续按照右值传递下去，二是在万能模板引用中自动推导左右值。</p><p>See also: <a href=#forwarding-references><code>forwarding references</code></a>, <a href=#rvalue-references><code>rvalue references</code></a>.</p><h3 id=stdthread>std::thread</h3><p><code>std::thread</code>库提供了一种标准方式去控制线程，如生成线程或杀死线程。下面的例子，生成多个线程去做不同的计算然后程序等待所有线程结束。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>bool</span> <span class=n>clause</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* do something... */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kr>thread</span><span class=o>&gt;</span> <span class=n>threadsVector</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>threadsVector</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>([]()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Lambda function that will be invoked
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=n>threadsVector</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>  <span class=c1>// thread will run foo(true)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=kr>thread</span> <span class=o>:</span> <span class=n>threadsVector</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>thread</span><span class=p>.</span><span class=n>join</span><span class=p>();</span> <span class=c1>// Wait for threads to finish
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=stdto_string>std::to_string</h3><p>转换一个数学类型到字符串</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>to_string</span><span class=p>(</span><span class=mf>1.2</span><span class=p>);</span> <span class=c1>// == &#34;1.2&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>to_string</span><span class=p>(</span><span class=mi>123</span><span class=p>);</span> <span class=c1>// == &#34;123&#34;
</span></span></span></code></pre></div><h3 id=type-traits>Type traits</h3><p>Type traits 定义了一个基于编译时模板的接口，用于查询或修改类型的属性。如类型是否相同，类型是否是左值，右值等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_integral</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_same</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_same</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>conditional</span><span class=o>&lt;</span><span class=nb>true</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>is_lvalue_reference</span><span class=o>&lt;</span><span class=n>_Tp</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>is_rvalue_reference</span><span class=o>&lt;</span><span class=n>_Tp</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=smart-pointers>Smart pointers</h3><p>C++11 引入了新的智能指针：<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>。 <code>std::auto_ptr</code> 在 C++17 中已经被移除。</p><p><code>std::unique_ptr</code>在管理其指向的堆内存对象时，要求对象不可复制，仅可移动。</p><p>**注意：**相对于使用对象的构造函数，我们更倾向于用<code>std::make_X</code>来构造智能指针。</p><p>查看 <a href=#stdmake_unique><code>std::make_unique</code></a> and <a href=#stdmake_shared><code>std::make_shared</code></a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span> <span class=n>p1</span> <span class=p>{</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>{}</span> <span class=p>};</span>  <span class=c1>// `p1` owns `Foo`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>p1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>p1</span><span class=o>-&gt;</span><span class=n>bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>p1</span><span class=p>)};</span>  <span class=c1>// Now `p2` owns `Foo`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>f</span><span class=p>(</span><span class=o>*</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p1</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>  <span class=c1>// Ownership returns to `p1` -- `p2` gets destroyed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>p1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>p1</span><span class=o>-&gt;</span><span class=n>bar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// `Foo` instance is destroyed when `p1` goes out of scope
</span></span></span></code></pre></div><p><code>std::shared_ptr</code>是一个智能指针，它管理跨多个所有者共享的资源。共享指针持有一个控制块，该控制块具有一些组件，如托管对象和引用计数器。 所有控制块访问都是线程安全的，但是操作托管对象本身是非线程安全的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// p1在复制给参数时是线程安全的，保证计数正确，但是在操作对象时不是线程安全的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Do something with `t`...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>bar</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Do something with `t`...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>baz</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Do something with `t`...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>p1</span> <span class=p>{</span><span class=k>new</span> <span class=n>T</span><span class=p>{}};</span>
</span></span><span class=line><span class=cl><span class=c1>// Perhaps these take place in another threads?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>foo</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>bar</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>baz</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=stdchrono>std::chrono</h3><p><code>chrono</code>库包含一组实用函数和类型，用于处理持续时间、时钟和时间点。下面用例是程序运行时间测试代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>time_point</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>steady_clock</span><span class=o>&gt;</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>start</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>steady_clock</span><span class=o>::</span><span class=n>now</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// Some computations...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>end</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>steady_clock</span><span class=o>::</span><span class=n>now</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>duration</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>elapsed_seconds</span> <span class=o>=</span> <span class=n>end</span> <span class=o>-</span> <span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>t</span> <span class=o>=</span> <span class=n>elapsed_seconds</span><span class=p>.</span><span class=n>count</span><span class=p>();</span> <span class=c1>// t number of seconds, represented as a `double`
</span></span></span></code></pre></div><h3 id=tuples>Tuples</h3><p>元组是用来存储不同类型值得集合。解析元组用<code>std::tie</code>或<code>std::get</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// `playerProfile` has type `std::tuple&lt;int, const char*, const char*&gt;`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>playerProfile</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=mi>51</span><span class=p>,</span> <span class=s>&#34;Frans Nielsen&#34;</span><span class=p>,</span> <span class=s>&#34;NYI&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span><span class=p>(</span><span class=n>playerProfile</span><span class=p>);</span> <span class=c1>// 51
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>playerProfile</span><span class=p>);</span> <span class=c1>// &#34;Frans Nielsen&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>(</span><span class=n>playerProfile</span><span class=p>);</span> <span class=c1>// &#34;NYI&#34;
</span></span></span></code></pre></div><p>**个人理解：**tuple 是根据 Variadic templates 生成的，但是这块看的有点蒙，元组用的也比较少，先搁置吧..</p><h3 id=stdtie>std::tie</h3><p>返回一个左值引用的 tuple，对解析<code>std::pair</code>和<code>std::tuple</code>很有用，用<code>std::ignore</code>占位符忽略某个值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// With tuples...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>playerName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tie</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ignore</span><span class=p>,</span> <span class=n>playerName</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ignore</span><span class=p>)</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=mi>91</span><span class=p>,</span> <span class=s>&#34;John Tavares&#34;</span><span class=p>,</span> <span class=s>&#34;NYI&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// With pairs...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>yes</span><span class=p>,</span> <span class=n>no</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tie</span><span class=p>(</span><span class=n>yes</span><span class=p>,</span> <span class=n>no</span><span class=p>)</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_pair</span><span class=p>(</span><span class=s>&#34;yes&#34;</span><span class=p>,</span> <span class=s>&#34;no&#34;</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=stdarray>std::array</h3><p><code>std::array</code>是一个基于 C 样式数组 构建的容器。支持常见的容器操作，如排序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>());</span> <span class=c1>// a == { 1, 2, 3 }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>a</span><span class=p>)</span> <span class=n>x</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// a == { 2, 4, 6 }
</span></span></span></code></pre></div><h3 id=unordered-containers>Unordered containers</h3><p>这些容器操作如插入，删除，查找的平均时间复杂度是常数时间级别。容器为了使操作能达到常数级别的时间复杂度，将元素的存储在桶中，而不是以往的红黑树，所以牺牲了排序的功能。有四种不排序容器：</p><ul><li><code>unordered_set</code></li><li><code>unordered_multiset</code></li><li><code>unordered_map</code></li><li><code>unordered_multimap</code></li></ul><h3 id=stdmake_shared>std::make_shared</h3><p>推荐使用<code>std::make_shared</code>来构建<code>std::shared_ptr</code>的实例的原因如下：</p><ul><li>避免使用<code>new</code>运算符</li><li>Prevents code repetition when specifying the underlying type the pointer shall hold.(译者没懂要表达什么意思，防止代码重复，但我没感觉到有这个意义)</li><li>It provides exception-safety. Suppose we were calling a function <code>foo</code> like so:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>{</span><span class=k>new</span> <span class=n>T</span><span class=p>{}},</span> <span class=n>function_that_throws</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>{</span><span class=k>new</span> <span class=n>T</span><span class=p>{}});</span>
</span></span></code></pre></div><p>The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on&mldr; Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_shared</code>, we are given exception-safety:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>function_that_throws</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>());</span>
</span></span></code></pre></div><p><strong>上述是原文，个人认为描述的跟我理解的有出入，以下是个人理解。</strong></p><p>保证异常安全。假设我们现在在调用<code>foo</code>函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>{</span><span class=k>new</span> <span class=n>T</span><span class=p>{}},</span> <span class=n>function_that_throws</span><span class=p>());</span>
</span></span></code></pre></div><p>编译器在调用函数前会先将参数处理完成。需要处理的参数 1.<code>new T{}</code>，2.<code>std::share_ptr&lt;T></code>构造，3.调用<code>function_that_throws</code>函数。但是编译器的处理顺序不是确定的，当执行顺序为 1，3，2 时，3 函数调用时发生了异常，那么 1 中 new 的内存将泄漏。改成如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>foo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>function_that_throws</span><span class=p>());</span>
</span></span></code></pre></div><ul><li><code>std::shared_ptr{ new T{} }</code>再调用时，除了给<code>T</code>分配内存，还要再给<code>shared_ptr</code>中的控制块分配内存，一共分配了两次，而使用<code>std::make_shared</code>来构造时，会一次性分配好两者的内存。只会进行一次内存动态分配。</li></ul><h3 id=stdref>std::ref</h3><p><code>std::ref(val)</code> 通过生成一个<code>std::reference_wrapper</code>来保证参数传递时按照引用传递。通常用来显式指定传递参数为引用传递，或指定容器中保存的类型是某种类型的引用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// create a container to store reference of objects.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>99</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>_ref</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ref</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>_ref</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>_cref</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>cref</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//_cref++; does not compile
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>reference_wrapper</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span><span class=n>vec</span><span class=p>;</span> <span class=c1>// vector&lt;int&amp;&gt;vec does not compile
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vec</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>_ref</span><span class=p>);</span> <span class=c1>// vec.push_back(&amp;i) does not compile
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// prints 100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>vec</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// prints 100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>_cref</span><span class=p>;</span> <span class=c1>// prints 100
</span></span></span></code></pre></div><h3 id=memory-model>Memory model</h3><p>C++11 引入了一种内存模型，这意味着库支持线程和原子操作。其中一些操作包括(但不限于)<code>atomic loads/stores</code>、<code>compare-and-swap</code>、<code>atomic flags</code>、<code>promises</code>、<code>futures</code>、<code>locks</code>和<code>condition variables</code>。</p><p>查看相关部分: <a href=#stdthread>std::thread</a></p><h3 id=stdasync>std::async</h3><p>创建一个后台异步线程来执行任务，返回一个<code>std::future</code>对象来存储函数调用返回的结果。</p><p>可以手动的选择异步线程的执行方式，将下面执行方式置为<code>std::async</code>的第一个参数即可：</p><ol><li><code>std::launch::async</code> 在后台线程中执行可调用对象。当返回的 future 失效前会强制执行完成可调用对象，即不调用 future.get 也会保证任务的执行。</li><li><code>std::launch::deferred</code> 仅当调用 future.get 时才会执行任务。</li><li><code>std::launch::async | std::launch::deferred</code> 如果创建 async 时不指定 launch policy，他会默认在二者中选一种方式进行执行。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Do something here, then return the result. */</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>handle</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>async</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>launch</span><span class=o>::</span><span class=n>async</span><span class=p>,</span> <span class=n>foo</span><span class=p>);</span>  <span class=c1>// create an async task
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>handle</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>  <span class=c1>// wait for the result
</span></span></span></code></pre></div><h3 id=stdbeginend>std::begin/end</h3><p>一般而言，<code>std::begin</code> and <code>std::end</code> 用来返回容器的首迭代器和尾迭代器，且同样作用于 C 格式数组。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>CountTwos</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>count_if</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>begin</span><span class=p>(</span><span class=n>container</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>end</span><span class=p>(</span><span class=n>container</span><span class=p>),</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>item</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>item</span> <span class=o>==</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>43</span><span class=p>,</span> <span class=mi>435</span><span class=p>,</span> <span class=mi>4543</span><span class=p>,</span> <span class=mi>534</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>43</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>435</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=n>CountTwos</span><span class=p>(</span><span class=n>vec</span><span class=p>);</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>b</span> <span class=o>=</span> <span class=n>CountTwos</span><span class=p>(</span><span class=n>arr</span><span class=p>);</span>  <span class=c1>// 1
</span></span></span></code></pre></div><h2 id=acknowledgements>Acknowledgements</h2><ul><li><a href=http://en.cppreference.com/w/cpp target=_blank rel=noopener>cppreference</a> - 其中有很好的例子，特性和解释。</li><li><a href=http://thbecker.net/articles/rvalue_references/section_01.html target=_blank rel=noopener>C++ Rvalue References Explained</a> - 一系列非常好的右值引用，完美转发， 移动语义文章。</li><li><a href=http://clang.llvm.org/cxx_status.html target=_blank rel=noopener>clang</a> 和 <a href=https://gcc.gnu.org/projects/cxx-status.html target=_blank rel=noopener>gcc</a> 的标准支持标准页面。</li><li><a href=https://godbolt.org/ target=_blank rel=noopener>Compiler explorer</a> 一个由源码转到汇编代码的网页，(译者：<strong>无敌好用</strong>)。</li><li><a href=https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996 target=_blank rel=noopener>Scott Meyers&rsquo; Effective Modern C++</a> - 特别推荐的书籍</li><li><a href=https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw target=_blank rel=noopener>Jason Turner&rsquo;s C++ Weekly</a> - C++相关视频</li><li><a href=http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object target=_blank rel=noopener>What can I do with a moved-from object?</a> 被以右值引用调用过的对象还能用来做什么</li><li><a href=http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto target=_blank rel=noopener>What are some uses of decltype(auto)?</a> decltype(auto)的用途都有啥</li><li>还有很多帖子，但是我忘记了&mldr;</li></ul></div><div class=article-widget><div class="container-xl row post-nav"></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div><script type=text/javascript id=clstr_globe async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>