<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编译原理 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link>
      <atom:link href="https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <description>编译原理</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>编译原理</title>
      <link>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link>
    </image>
    
    <item>
      <title>AST</title>
      <link>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/ast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/ast/</guid>
      <description>&lt;h1 id=&#34;ast--抽象语法树&#34;&gt;AST | 抽象语法树&lt;/h1&gt;
&lt;p&gt;抽象语法树（AST）是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构。抽象语法树中的每一个节点都表示源代码中的一个元素，每一颗子树都表示一个语法元素，例如一个 if else 语句，我们可以从 2 * 3 + 7 这一表达式中解析出下图所示的抽象语法树。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007DFXDhgy1g3v2plef8bj30xj0bymxf.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;作为编译器常用的数据结构，抽象语法树抹去了源代码中不重要的一些字符 - 空格、分号或者括号等等。编译器在执行完语法分析之后会输出一个抽象语法树，这棵树会辅助编译器进行语义分析，我们可以用它来确定结构正确的程序是否存在一些类型不匹配或不一致的问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译原理概述</title>
      <link>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;h1 id=&#34;scope&#34;&gt;Scope&lt;/h1&gt;
&lt;p&gt;已知 IBM 的 PowerPC 是 big-endian 字节序列而 Intel 的 X86 是 little-endian 字节序，如果在地址啊存储的整形值时 0x04030201，那么地址为 a+3 的字节内存储的值在 PowerPC 和 Intel X86 结构下的值分别是:1 4
大端从大地址开始存储，小端相反，两者都是从数据低位开始存起；假设从上至下地址递增，则&lt;/p&gt;
&lt;p&gt;PowerPC(大)：                    Intel X86(小)：&lt;/p&gt;
&lt;p&gt;04                                            01
低
03
02                      |&lt;/p&gt;
&lt;p&gt;02                                            03
|
01
04                     高
a+3 指向最大的地址，所以分别为 1 4&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>中间代码</title>
      <link>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cs-notes/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%90%86%E8%AE%BA/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;h1 id=&#34;静态单赋值&#34;&gt;静态单赋值&lt;/h1&gt;
&lt;p&gt;静态单赋值（SSA）是中间代码的一个特性，如果一个中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次，在实践中我们通常会用添加下标的方式实现每个变量只能被赋值一次的特性，这里以下面的代码举一个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; x
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据分析，我们其实能够发现上述的代码其实并不需要第一个将 1 赋值给 x 的表达式，也就是这一表达式在整个代码片段中是没有作用的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x1 :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x2 :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;y1 :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; x2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从使用 SSA 的中间代码我们就可以非常清晰地看出变量 y1 的值和 x1 是完全没有任何关系的，所以在机器码生成时其实就可以省略第一步，这样就能减少需要执行的指令来优化这一段代码。&lt;/p&gt;
&lt;p&gt;根据 Wikipedia 对 SSA 的介绍来看，在中间代码中使用 SSA 的特性能够为整个程序实现以下的优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常数传播（constant propagation）&lt;/li&gt;
&lt;li&gt;值域传播（value range propagation）&lt;/li&gt;
&lt;li&gt;稀疏有条件的常数传播（sparse conditional constant propagation）&lt;/li&gt;
&lt;li&gt;消除无用的程式码（dead code elimination）&lt;/li&gt;
&lt;li&gt;全域数值编号（global value numbering）&lt;/li&gt;
&lt;li&gt;消除部分的冗余（partial redundancy elimination）&lt;/li&gt;
&lt;li&gt;强度折减（strength reduction）&lt;/li&gt;
&lt;li&gt;寄存器分配（register allocation）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 SSA 的作用我们就能看出，因为它的主要作用就是代码的优化，所以是编译器后端（主要负责目标代码的优化和生成）的一部分；当然，除了 SSA 之外代码编译领域还有非常多的中间代码优化方法，优化编译器生成的代码是一个非常古老并且复杂的领域，这里就不会展开介绍了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
