<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>盒模型与文档流 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/web-notes/01.%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/</link><atom:link href="https://ng-tech.icu/books/web-notes/01.%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/index.xml" rel="self" type="application/rss+xml"/><description>盒模型与文档流</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>盒模型与文档流</title><link>https://ng-tech.icu/books/web-notes/01.%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/</link></image><item><title>盒模型</title><link>https://ng-tech.icu/books/web-notes/01.%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/%E7%9B%92%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-notes/01.%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/%E7%9B%92%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="css-布局盒模型">CSS 布局：盒模型&lt;/h1>
&lt;h1 id="boxmodel">BoxModel&lt;/h1>
&lt;p>在 CSS 中，这些矩形盒子用 标准盒模型 来描述。这个模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与 内容边界 content edge。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://www.w3.org/TR/2011/REC-CSS2-20110607/images/boxdim.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而这些属性我们可以把它转移到我们日常生活中的盒子(箱子)上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。那么内容(CONTENT)就是盒子里装的东西；而填充(PADDING)就是怕盒子里装的东西(贵重的)损坏而添加的泡沫或者其它抗震的辅料；边框(BORDER)就是盒子本身了；至于边界(MARGIN)则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出。在网页设计上，内容常指文字、图片等元素，但是也可以是小盒子(DIV 嵌套)，与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子，否则盒子会被撑坏的，而 CSS 盒子具有弹性，里面的东西大过盒子本身最多把它撑大，但它不会损坏的。填充只有宽度属性，可以理解为生活中盒子里的抗震辅料厚度，而边框有大小和颜色之分，我们又可以理解为生活中所见盒子的厚度以及这个盒子是用什么颜色材料做成的，边界就是该盒子与其它东西要保留多大距离。&lt;/p>
&lt;p>如果 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" rel="noopener">&lt;code>box-sizing&lt;/code>&lt;/a> 为默认值，&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width" target="_blank" rel="noopener">&lt;code>width&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-width" target="_blank" rel="noopener">&lt;code>min-width&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width" target="_blank" rel="noopener">&lt;code>max-width&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height" target="_blank" rel="noopener">&lt;code>height&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height" target="_blank" rel="noopener">&lt;code>min-height&lt;/code>&lt;/a> 与 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-height" target="_blank" rel="noopener">&lt;code>max-height&lt;/code>&lt;/a>控制内容大小。&lt;/p>
&lt;p>&lt;strong>内边距区域 padding area&lt;/strong> 用内容及可能的边框之间的空白区域扩展内容区域。它位于内边距边界内部，通常有背景——颜色或图片(不透明图片盖住背景颜色). 它的大小为 _padding-box _ 宽与*padding-box *高。&lt;/p>
&lt;p>内边距与内容边界之间的空间可以由 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-top" target="_blank" rel="noopener">&lt;code>padding-top&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right" target="_blank" rel="noopener">&lt;code>padding-right&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-bottom" target="_blank" rel="noopener">&lt;code>padding-bottom&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left" target="_blank" rel="noopener">&lt;code>padding-left&lt;/code>&lt;/a> 和简写属性 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding" target="_blank" rel="noopener">&lt;code>padding&lt;/code>&lt;/a> 控制。&lt;/p>
&lt;p>&lt;strong>边框区域 border area&lt;/strong> 是包含边框的区域，扩展了内边距区域。它位于边框边界内部，大小为 _border-box _ 宽和 *border-box *高。由 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width" target="_blank" rel="noopener">&lt;code>border-width&lt;/code>&lt;/a> 及简写属性 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border" target="_blank" rel="noopener">&lt;code>border&lt;/code>&lt;/a>控制。&lt;/p>
&lt;p>**外边距区域****margin area**用空白区域扩展边框区域，以分开相邻的元素。它的大小为 *margin-box *的高宽。&lt;/p>
&lt;p>外边距区域大小由 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top" target="_blank" rel="noopener">&lt;code>margin-top&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right" target="_blank" rel="noopener">&lt;code>margin-right&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom" target="_blank" rel="noopener">&lt;code>margin-bottom&lt;/code>&lt;/a>, &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-left" target="_blank" rel="noopener">&lt;code>margin-left&lt;/code>&lt;/a> 及简写属性 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin" target="_blank" rel="noopener">&lt;code>margin&lt;/code>&lt;/a>控制。&lt;/p>
&lt;p>在 &lt;a href="https://developer.mozilla.org/en/CSS/margin_collapsing" target="_blank" rel="noopener">外边距合并&lt;/a> 的情况下，由于盒之间共享外边距，外边距不容易弄清楚。&lt;/p>
&lt;p>最后，请注意，对于非替换的行内元素来说，尽管内容周围存在内边距与边框，但其占用空间(行高)由 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height" target="_blank" rel="noopener">&lt;code>line-height&lt;/code>&lt;/a> 属性决定。&lt;/p>
&lt;ul>
&lt;li>每个 HTML 标记都可看作一个盒子；&lt;/li>
&lt;li>每个盒子都有：边界、边框、填充、内容四个属性；&lt;/li>
&lt;li>每个属性都包括四个部分：上、右、下、左；这四部分可同时设置，也可分别设置；&lt;/li>
&lt;/ul>
&lt;h3 id="标准文档流与元素分类">标准文档流与元素分类&lt;/h3>
&lt;h3 id="层叠上下文与层叠顺序">层叠上下文与层叠顺序&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解 CSS 中的层叠上下文和层叠顺序&lt;/a> &amp;gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;amp;mid=2651550819&amp;amp;idx=1&amp;amp;sn=7693f3c2a9d925bf069a08de90705682&amp;amp;scene=23&amp;amp;srcid=0505BRzmx9ReolXFyoL1rgTB#rd" target="_blank" rel="noopener">不起眼的 z-index 却能牵扯出这么大的学问&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="height--width">height &amp;amp; width&lt;/h1>
&lt;h2 id="line-height行高">line-height:行高&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">css 行高 line-height 的一些深入理解及应用&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>何为行高？顾名思意指一行文字的高度。具体来说是指两行文字间基线之间的距离。基线实在英文字母中用到的一个概念，我们刚学英语的时使用的那个英语本子每行有四条线，其中底部第二条线就是基线，是 a,c,z,x 等字母的底边线。下图的红色线即为基线。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://image.zhangxinxu.com/image/blog/200911/base_line.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
默认状态，浏览器使用 1.0-1.2 line-height, 这是一个初始值。你可以定义 line-height 属性来覆盖初始值：p｛line-height:140%｝你可以有 5 种方式来定义 line-height。
1.line-height 可以被定义为：body{line-height:normal;}
2.line-height 可以被定义为：body{line-height:inherit;}
3.line-height 可以使用一个百分比的值 body{line-height:120%;}
4.line-height 可以被定义为一个长度值(px,em 等) body{line-height:25px;}
5.line-height 也可以被定义为纯数字，body{line-height:1.2}
上面的描述有点抽象，笔者觉得官方文档中更为贴切：line-height 与 font-size 的计算值之差(在 CSS 中成为“行间距”)分为两半，分别加到一个文本行内容的顶部和底部。可以包含这些内容的最小框就是行框。&lt;/p>
&lt;p>代码：&lt;/p>
&lt;div style="line-height:150%;font-size:16px;">
父元素内容
&lt;div style="font-size:30px;">
Web前端开发&lt;br />
line-height行高问题
&lt;/div>
&lt;/div>
下图是当line-height:150%的效果，父元素的行高为150%时，会根据父元素的字体大小先计算出行高值然后再让子元素继承。所以当line-height:150%时，字元素的行高等于16px * 150% = 24px：
&lt;img data-rawheight="75" data-rawwidth="277" src="https://pic2.zhimg.com/cd8d76c78e80e3183a1c241dfb39f2c5_b.jpg" class="content_image" width="277">![img](https://pic2.zhimg.com/cd8d76c78e80e3183a1c241dfb39f2c5_b.jpg)
下图是当line-height:1.5em的效果，父元素的行高为150%时，会根据父元素的字体大小先计算出行高值然后再让子元素继承。所以当line-height:1.5em时，子元素的行高等于16px * 1.5em = 24px：
&lt;img data-rawheight="75" data-rawwidth="277" src="https://pic2.zhimg.com/cd8d76c78e80e3183a1c241dfb39f2c5_b.jpg" class="content_image" width="277">![img](https://pic2.zhimg.com/cd8d76c78e80e3183a1c241dfb39f2c5_b.jpg)
下图是当line-height:1.5的效果，父元素行高为1.5时，会根据子元素的字体大小动态计算出行高值让子元素继承。所以，当line-height:1.5时，子元素行高等于30px * 1.5 = 45px：
&lt;img data-rawheight="106" data-rawwidth="277" src="https://pic1.zhimg.com/1a56e5fabcf173ae074e0f4ed9e61e3c_b.jpg" class="content_image" width="277">![img](https://pic1.zhimg.com/1a56e5fabcf173ae074e0f4ed9e61e3c_b.jpg)
&lt;h2 id="offsetheight--clientheight--scrollheight">offsetHeight &amp;amp; clientHeight &amp;amp; scrollHeight&lt;/h2>
&lt;ul>
&lt;li>clientHeight:返回以 Pixels 为单位的元素的内部高度，包括内边距但是不包括滚动轴的高度、边以及外边距。&lt;/li>
&lt;li>offsetHeight:包括元素的边宽、内边距以及水平滚动轴的高度。&lt;/li>
&lt;li>scrollHeight:返回整个元素内容的高度，包括没有被容纳在当前屏幕中的部分。&lt;/li>
&lt;/ul>
&lt;p>譬如下面这个 HTML 布局中:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">element&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;gt;&lt;/span>&lt;span class="c">&amp;lt;!-- *content*: child nodes: --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | content A child node as text node | of
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;another_child_node&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | the ... and I am the 4th child node | element
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">element&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>scrollHeight 包括 Entire Content 与 Padding，而 clientHeight 包括 Visible Content 以及 padding，offsetHeight 包括 Visible Content、padding、border 以及 scrollbar，形象地描述可见下图：&lt;/p>
&lt;p>具体的例子可以参考&lt;a href="http://jsfiddle.net/shibualexis/yVhgM/3/" target="_blank" rel="noopener">JSFiddle&lt;/a>，这里形象地对 offset*、client*以及 scroll*进行了比较&lt;/p>
&lt;h2 id="min-_--max-_">min-_ &amp;amp; max-_&lt;/h2>
&lt;h2 id="overflow">overflow&lt;/h2>
&lt;h1 id="margin--padding">margin &amp;amp; padding&lt;/h1>
&lt;h2 id="percentage-value百分比值效果无论垂直还是水平百分比值始终参考宽度">Percentage Value:百分比值效果，无论垂直还是水平，百分比值始终参考宽度&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.uedsc.com/discussion-margin-and-padding-values.html" target="_blank" rel="noopener">浅谈 Margin 和 Padding 值设置成百分数的布局&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>当&lt;code>margin&lt;/code>设置成百分数的时候，其&lt;code>top right bottom left&lt;/code>的值是参照父元素盒子的宽度进行计算，在 w3c 的规范中也是这样描述的: &lt;code>margin&lt;/code> 的百分比值参照其包含块的宽度进行计算，同样的 padding 如果设置成百分数的话，其盒子模型和 margin 是一样的。这只发生在默认的 &lt;code>writing-mode: horizontal-tb;&lt;/code> 和 &lt;code>direction: ltr;&lt;/code> 的情况下，当书写模式变成纵向的时候，其参照将会变成包含块的高度。我们可以以如下的例子进行说明:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;div class=&amp;#34;demo1&amp;#34;&amp;gt;
&amp;lt;div&amp;gt;这个div设置：margin:10% 5%&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
.demo1 {
height: 500px;
width: 980px;
margin: 0 auto;
background: red;
overflow: hidden;
}
.demo1 div {
margin: 10% 5%;
background: white;
}
&lt;/code>&lt;/pre>&lt;p>据以往的理解，&lt;code>.demo1 div&lt;/code>的&lt;code>margin&lt;/code>应该是：&lt;code>50px 49px 50px 49px&lt;/code>，但是运行以后，通过查看盒模型示意图，却发现是：&lt;code>98px 49px 98px 49px&lt;/code>。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://www.uedsc.com/wp-content/uploads/2015/02/4144.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为什么要选择宽度做参照而不是高度呢？这其实更多的要从 CSS 设计意图上去想，因为 CSS 的基础需求是排版，而通常我们所见的横排文字，其水平宽度一定(仔细回想一下，如果没有显式的定义宽度 或者强制一行显示，都会遇到边界换行，而不是水平延展)，垂直方向可以无限延展。但当书写模式为纵向时，其参照就变成了高度而不再是宽度了。官方文档说明如下:&lt;/p>
&lt;blockquote>
&lt;p>The percentage is calculated with respect to the width of the generated box&amp;rsquo;s containing block. Note that this is true for &amp;lsquo;margin-top&amp;rsquo; and &amp;lsquo;margin-bottom&amp;rsquo; as well. If the containing block&amp;rsquo;s width depends on this element, then the resulting layout is undefined in CSS 2.1.&lt;/p>
&lt;/blockquote>
&lt;h1 id="displaybox">display:box&lt;/h1>
&lt;p>Box 是传统的通用的容器属性，我们首先来介绍下 Box 的基本用法。因为在下文讲解 Flex 时候会提及，鉴于部分浏览器并不能支持 Flex 的全部特性，所以很多时候我们需要利用一些工具或者手写的方式将新版的 Flex 的语法转化为旧版的 Box 的语法。如果需要定义一个容器为 Box 的话，只需要做如下声明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="line">&lt;span class="cl">&lt;span class="p">.&lt;/span>&lt;span class="nc">box&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">display&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">-moz-&lt;/span>&lt;span class="n">box&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c">/*Firefox*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">display&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">-webkit-&lt;/span>&lt;span class="n">box&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c">/*Safari,Opera,Chrome*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">display&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">box&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="容器属性">容器属性&lt;/h2>
&lt;h3 id="box-pack子元素主轴对齐">box-pack:子元素主轴对齐&lt;/h3>
&lt;p>box-pack 定义子元素主轴对齐方式。&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
-moz-box-pack: center; /*Firefox*/
-webkit-box-pack: center; /*Safari,Opera,Chrome*/
box-pack: center;
}
&lt;/code>&lt;/pre>&lt;p>box-pack 属性总共有 4 个值：&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
box-pack: start | end | center | justify;
/*主轴对齐：左对齐(默认) | 右对齐 | 居中对齐 | 左右对齐*/
}
&lt;/code>&lt;/pre>&lt;h3 id="box-align子元素交叉轴对齐">box-align:子元素交叉轴对齐&lt;/h3>
&lt;p>box-align 定义子元素交叉轴对齐方式。&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
-moz-box-align: center; /*Firefox*/
-webkit-box-align: center; /*Safari,Opera,Chrome*/
box-align: center;
}
&lt;/code>&lt;/pre>&lt;p>box-align 属性总共有 5 个值：&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
box-align: start | end | center | baseline | stretch;
/*交叉轴对齐：顶部对齐(默认) | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/
}
&lt;/code>&lt;/pre>&lt;h3 id="box-direction子元素显示方向">box-direction:子元素显示方向&lt;/h3>
&lt;p>box-direction 定义子元素的显示方向。&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
-moz-box-direction: reverse; /*Firefox*/
-webkit-box-direction: reverse; /*Safari,Opera,Chrome*/
box-direction: reverse;
}
&lt;/code>&lt;/pre>&lt;p>box-direction 属性总共有 3 个值：&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
box-direction: normal | reverse | inherit;
/*显示方向：默认方向 | 反方向 | 继承子元素的 box-direction*/
}
&lt;/code>&lt;/pre>&lt;h3 id="box-orient子元素行内排列方式">box-orient:子元素行内排列方式&lt;/h3>
&lt;pre tabindex="0">&lt;code>.box{
-moz-box-orient: horizontal; /*Firefox*/
-webkit-box-orient: horizontal; /*Safari,Opera,Chrome*/
box-orient: horizontal;
}
&lt;/code>&lt;/pre>&lt;p>box-orient 属性总共有 5 个值：&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
box-orient: horizontal | vertical | inline-axis | block-axis | inherit;
/*排列方向：水平 | 垂直 | 行内方式排列(默认) | 块方式排列 | 继承父级的box-orient*/
}
&lt;/code>&lt;/pre>&lt;h3 id="box-lines子元素换行">box-lines:子元素换行&lt;/h3>
&lt;pre tabindex="0">&lt;code>.box{
-moz-box-lines: multiple; /*Firefox*/
-webkit-box-lines: multiple; /*Safari,Opera,Chrome*/
box-lines: multiple;
}
&lt;/code>&lt;/pre>&lt;p>box-lines 属性总共有 2 个值：&lt;/p>
&lt;pre tabindex="0">&lt;code>.box{
box-lines: single | multiple;
/*允许换行：不允许(默认) | 允许*/
}
&lt;/code>&lt;/pre>&lt;h2 id="子元素属性">子元素属性&lt;/h2>
&lt;h3 id="box-flex是否允许缩放">box-flex:是否允许缩放&lt;/h3>
&lt;p>box-flex 定义是否允许当前子元素伸缩。&lt;/p>
&lt;pre tabindex="0">&lt;code>.item{
-moz-box-flex: 1.0; /*Firefox*/
-webkit-box-flex: 1.0; /*Safari,Opera,Chrome*/
box-flex: 1.0;
}
&lt;/code>&lt;/pre>&lt;p>box-flex 属性使用一个浮点值：&lt;/p>
&lt;pre tabindex="0">&lt;code>.item{
box-flex: &amp;lt;value&amp;gt;;
/*伸缩：&amp;lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&amp;gt;*/
}
&lt;/code>&lt;/pre>&lt;h3 id="box-ordinal-group子元素显示次序">box-ordinal-group:子元素显示次序&lt;/h3>
&lt;p>box-ordinal-group 定义子元素的显示次序，数值越小越排前。&lt;/p>
&lt;pre tabindex="0">&lt;code>.item{
-moz-box-ordinal-group: 1; /*Firefox*/
-webkit-box-ordinal-group: 1; /*Safari,Opera,Chrome*/
box-ordinal-group: 1;
}
&lt;/code>&lt;/pre>&lt;p>box-direction 属性使用一个整数值：&lt;/p>
&lt;pre tabindex="0">&lt;code>.item{
box-ordinal-group: &amp;lt;integer&amp;gt;;
/*显示次序：&amp;lt;一个整数，默认为1，数值越小越排前&amp;gt;*/
}
&lt;/code>&lt;/pre></description></item><item><title>文档流与元素定位</title><link>https://ng-tech.icu/books/web-notes/01.%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/%E6%96%87%E6%A1%A3%E6%B5%81%E4%B8%8E%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-notes/01.%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/%E6%96%87%E6%A1%A3%E6%B5%81%E4%B8%8E%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/</guid><description>&lt;h1 id="document-flow文档流">Document Flow:文档流&lt;/h1>
&lt;p>将窗体自上而下分成一行行，并在每行中按从左至右的顺序排放元素，即为文档流。HTML 中元素可分为三大类：&lt;/p>
&lt;ul>
&lt;li>块级元素(block level)：总是以一个块的形式表现出来，并且跟同级的兄弟一次竖直排列，左右撑满。&lt;/li>
&lt;li>行内元素(inline)：对于文字这类元素，各个字母之间横向排列，到最右端自动折行，这就是另一种元素，称为“行内元素”。&lt;/li>
&lt;li>浮动元素：浮动元素则按规定浮在行的一端。若当前行容不下，则另起新行再浮动。&lt;/li>
&lt;/ul>
&lt;p>有三种情况将使得元素脱离文档流而存在，分别是浮动，绝对定位(absolute)，固定定位(fixed)。但是在 IE 中浮动元素也存在于文档流中。&lt;/p>
&lt;p>正常流是页面，大部分盒排布于正常流中。正常流中的盒必定位于某一格式化上下文中，正常流中有两种格式化上下文：块级格式化上下文(block formatting context，简称 BFC)和行内格式化上下文(inline formatting context,IFC)。在块级格式化上下文中，盒呈纵向排布，在行内格式化上下文中，盒则呈横向排布。正常流根容器中是块级格式化上下文，不同的盒可能会在内部产生行内格式化上下文或者块级格式化上下文。&lt;/p>
&lt;p>正常流中的盒分为块级与行内级两种，任何一个行内级盒都不能够直接被放入块级格式化上下文中。如果有一个 HTML 元素生成了一个行内盒，而其所在的上下文是块级的话，那么应当为它生成一个匿名块级盒，匿名块级盒会在内部生成行内格式化上下文。元素的 display 属性会决定盒是行内级还是块级：
block, table, flex, grid, list-item 为块级
inline, inline-block, inline-table, inline-flex, inline-grid 为行内级&lt;/p>
&lt;h1 id="bfc-块级格式化上下文">BFC: 块级格式化上下文&lt;/h1>
&lt;p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。&lt;/p>
&lt;ul>
&lt;li>body 根元素&lt;/li>
&lt;li>浮动元素：float 除 none 以外的值&lt;/li>
&lt;li>绝对定位元素：position (absolute、fixed)&lt;/li>
&lt;li>display 为 inline-block、table-cells、flex&lt;/li>
&lt;li>overflow 除了 visible 以外的值 (hidden、auto、scroll)&lt;/li>
&lt;/ul>
&lt;h2 id="定义与触发">定义与触发&lt;/h2>
&lt;h2 id="特性与应用">特性与应用&lt;/h2>
&lt;h1 id="属性详解">属性详解&lt;/h1>
&lt;h2 id="display">display&lt;/h2>
&lt;h2 id="position">position&lt;/h2>
&lt;p>我们先来看看 CSS3 Api 中对 position 属性的相关定义：&lt;/p>
&lt;p>static：无特殊定位，对象遵循正常文档流。top，right，bottom，left 等属性不会被应用。
relative：对象遵循正常文档流，但将依据 top，right，bottom，left 等属性在正常文档流中偏移位置。而其层叠通过 z-index 属性定义。
absolute：对象脱离正常文档流，使用 top，right，bottom，left 等属性进行绝对定位。而其层叠通过 z-index 属性定义。
fixed：对象脱离正常文档流，使用 top，right，bottom，left 等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过 z-index 属性定义。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>静态定位 / static: static，无特殊定位，它是 html 元素默认的定位方式，即我们不设定元素的 position 属性时默认的 position 值就是 static，它遵循正常的文档流对象，对象占用文档空间，该定位方式下，top、right、bottom、left、z-index 等属性是无效的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>相对定位(relative): relative 定位，又称为相对定位，从字面上来解析，我们就可以看出该属性的主要特性：相对。但是它相对的又是相对于什么地方而言的呢？这个是个重点，也是最让我迷糊的一个地方，现在让我们来做个测试，我想大家都会明白的：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="center-元素居中">Center: 元素居中&lt;/h1>
&lt;h2 id="horizonal-centering-水平居中">Horizonal Centering: 水平居中&lt;/h2>
&lt;h2 id="vertical-centering-垂直居中">Vertical Centering: 垂直居中&lt;/h2></description></item></channel></rss>