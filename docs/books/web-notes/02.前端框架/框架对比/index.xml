<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>框架对比 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/web-notes/02.%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</link><atom:link href="https://ng-tech.icu/books/web-notes/02.%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/index.xml" rel="self" type="application/rss+xml"/><description>框架对比</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>框架对比</title><link>https://ng-tech.icu/books/web-notes/02.%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</link></image><item><title>框架对比</title><link>https://ng-tech.icu/books/web-notes/02.%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-notes/02.%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</guid><description>&lt;h1 id="前端框架对比浅议">前端框架对比浅议&lt;/h1>
&lt;p>为什么要用 Angular 1 而不是 jQuery？为什么不用 BackBone？为什么用 React 而不是 Angular1？为什么不用 Elm?&lt;/p>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://medium.com/thothzocial-engineering/rendering-speed-performance-challenge-with-famous-front-end-framework-196c876a68af#.arvqhres6" target="_blank" rel="noopener">2016.9.8 Rendering Speed &amp;amp; Performance challenge with Famous Front-End Framework&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.8okr4h152" target="_blank" rel="noopener">javascript-fatigue&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://medium.com/@matthiasak/state-of-the-union-js-d664bdbffd14#.9agxss2s2" target="_blank" rel="noopener">state-of-the-union-js&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>框架范式</title><link>https://ng-tech.icu/books/web-notes/02.%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/%E6%A1%86%E6%9E%B6%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-notes/02.%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/%E6%A1%86%E6%9E%B6%E8%8C%83%E5%BC%8F/</guid><description>&lt;h1 id="框架范式">框架范式&lt;/h1>
&lt;h1 id="可变与不可变">可变与不可变&lt;/h1>
&lt;p>Svelte 的作者 Rich 认为 React 中最核心的问题是 React 一方面强调函数式渲染，而在 Web 里面，不管是 DOM，BOM，CSS，JavaScript 还是 WebGL，都充满了内部状态和命令式风格的 API，跟 React 函数式风格的抽象方式相差甚远。&lt;/p>
&lt;p>而 React Team 的成员们，还在致力于不断地扩大两者之间的鸿沟。其结果就是，尽管 React Hooks 是一项具有开创性的优秀技术；然而，绝大部分 React 开发者，都难以理解和习惯 React Hooks 的一些机制。在这种情况下，React Team 依然不认为这是 React 的问题，不试图解决困扰开发者们的反直觉事物。他们反而认为，需要教育 React 开发者，逐渐适应 React 的模式和思想，建立新的直觉。&lt;/p>
&lt;p>并且，React Team 对于过去 4 年多的教育成果感到满意：大部分 React 开发者都不会在 render 函数里操作 DOM 了，甚至有些开发者，已经忘记 DOM API 怎么用。React Team 对未来新的教育，也抱有信心。Rich 对此不以为然，他在分享的最后指出，Svelte 框架与 React 不同，它致力于以符合人脑思维习惯的方式去构建 UI。&lt;/p>
&lt;p>函数式编程的根基 Lambda Calculus 是一个跟 Turing machine 计算能力等价的通用计算模型。而当前主流的计算机，是建立在 Turing machine 和冯诺依曼架构上的设备。其中充满了可变的状态和命令式的指令集。&lt;/p>
&lt;p>所有编写的函数式代码，最终都是通过非函数式的方式，运行在我们的电脑上。那么，如果因为底层是有状态的，命令式的，就有了充分的理由去拥抱它。那函数式编程多年的发展，不可能存在。&lt;/p>
&lt;h1 id="reactivity">Reactivity&lt;/h1>
&lt;p>一种是以 Vue 为代表的 mutable + change tracking。即可变的数据结构，配合变更追踪，触发更新函数。另一种是以 React 为代表的 immutability + referential equality testing。即不可变的数据结构，配合反复执行的渲染函数，以及在函数执行过程中，通过数据的引用相等性判断，找出变更部分，只应用变化的部分到 UI 上。&lt;/p>
&lt;p>Sebastian 文章开篇就表示，两种实践方式都有各自的权衡。因为 mutable 的方式，已经有其它框架们很好的研究，所以 React Team 决定专注于挖掘 immutble 的方向，看看最后能引领我们走到哪一步。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/10/25/Kwqun0.jpg" alt="三种 Reactivity 对比" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item></channel></rss>