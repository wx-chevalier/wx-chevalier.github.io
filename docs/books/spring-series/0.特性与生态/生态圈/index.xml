<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>生态圈 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/</link><atom:link href="https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/index.xml" rel="self" type="application/rss+xml"/><description>生态圈</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>生态圈</title><link>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/</link></image><item><title>Spring Boot</title><link>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-boot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-boot/</guid><description>&lt;h1 id="spring-boot">Spring Boot&lt;/h1>
&lt;p>从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在 Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE 使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低。2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求在 Spring 框架中支持无容器 Web 应用程序体系结构。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：&lt;/p>
&lt;blockquote>
&lt;p>我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 main()方法引导的 Spring 容器内嵌入和统一这些常用 Web 容器服务的配置。&lt;/p>
&lt;/blockquote>
&lt;p>这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。它集成了大量常用的第三方库配置，Spring Boot 应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。&lt;/p>
&lt;h1 id="spring-boot-定位">Spring Boot 定位&lt;/h1>
&lt;p>Spring 的官方网站，可以看到下图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s3.ax1x.com/2021/02/07/yt0agU.png" alt="Spring: the source for modern java" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们可以看到图中官方对 Spring Boot 的定位：Build Anything， Build 任何东西。Spring Boot 旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。同时我们也来看一下官方对后面两个的定位：&lt;/p>
&lt;ul>
&lt;li>SpringCloud：Coordinate Anything，协调任何事情；&lt;/li>
&lt;li>SpringCloud Data Flow：Connect everything，连接任何东西。&lt;/li>
&lt;/ul>
&lt;h2 id="spring-boot-与-ssm">Spring Boot 与 SSM&lt;/h2>
&lt;p>SSM 是 Spring IoC、Spring MVC、Mybatis 的组合。SSM 限定死了你只能开发 Java Web 应用，而且 MVC 框架必须用 Spring MVC，持久层必须用 Mybatis。Spring Boot 没有和任何 MVC 框架绑定，没有和任何持久层框架绑定，没有和任何其他业务领域的框架绑定。开发 Web 应用可以用 Spring Boot。用 spring-boot-starter-web 就帮你配置好了 Spring MVC。你不想用 Spring MVC 了，换成 Spring WebFLux(用 spring-boot-starter-webflux)写响应式 Web 应用。数据持久层，你可以用 Spring Data 项目下的任何子项目(JPA\JDBC\MongoDB\Redis\LDAP\Cassandra\Couchbase\Noe4J\Hadoop\Elasticsearch&amp;hellip;.)，当然用非 Spring 官方支持的 Mybatis 也可以。只要用上对应技术或框架的 spring-boot-starter-xxx 就可以了。&lt;/p>
&lt;p>但是必须要知道，Spring Boot 提供的只是这些 starters，这些 Starter 依赖了(maven dependence)对应的框架或技术，但不包含对应的技术或框架本身！&lt;/p>
&lt;h1 id="spring-boot-优点">Spring Boot 优点&lt;/h1>
&lt;h2 id="良好的基因">良好的基因&lt;/h2>
&lt;p>Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot 是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。&lt;/p>
&lt;h2 id="简化编码">简化编码&lt;/h2>
&lt;p>举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-web&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="c">&amp;lt;!-- .....省略其他依赖 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>spring-web&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>5.0.7.RELEASE&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>compile&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>spring-webmvc&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>5.0.7.RELEASE&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>compile&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="简化配置">简化配置&lt;/h2>
&lt;p>Spring 虽然号称 Java EE 轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种 XML、Annotation 配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot 更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子，我新建一个类，但是我不用 @Service 注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要@Configuration 和@Bean 两个注解即可，如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TestService&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">sayHello&lt;/span> &lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Hello Spring Boot!&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">JavaConfig&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">TestService&lt;/span> &lt;span class="nf">getTestService&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TestService&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>@Configuration 表示该类是个配置类，@Bean 表示该方法返回一个 Bean。这样就把 TestService 作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用@Resource 注解注入进来即可使用，非常方便。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Resource&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">TestService&lt;/span> &lt;span class="n">testService&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties 配置，在 Spring Boot 中只需要个 application.yml 即可。&lt;/p>
&lt;h2 id="简化部署">简化部署&lt;/h2>
&lt;p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat 里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar 一键式启动项目。&lt;/p>
&lt;p>另外，也降低对运行环境的基本要求，环境变量中有 JDK 即可。&lt;/p>
&lt;h2 id="简化监控">简化监控&lt;/h2>
&lt;p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。&lt;/p></description></item><item><title>Spring Cloud</title><link>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-cloud/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-cloud/</guid><description>&lt;h1 id="spring-cloud">Spring Cloud&lt;/h1>
&lt;p>我们将 Spring Cloud 与 K8s 中的概念进行协调对比：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/nLfpz5Nw/image.png" alt="Spring Cloud 与 K8s 对比" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Spring Cloud 为我们提供了分布式/版本化配置、服务注册和发现、路由、服务和服务之间的调用、负载均衡、断路器、分布式消息传递等特性。其核心子项目包含了如下模块：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Spring Cloud Config: 配置中心，利用 Git 来集中管理程序的配置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Netflix: 集成众多 Netflix 的开源软件，包括 Eureka、Hystrix、Zuul、Archaius 等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Bus: Bus 即消息总线，消息总线利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化，比如配置更改事件，其可以与 Spring Cloud Config 联合来实现热部署。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Cluster: 基于 Zookeeper、Redis、Hazelcast、Consul 实现的领导选举和平民状态模式的抽象和实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Consul: 基于 Hashicorp Consul 实现的服务发现和配置管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Security: 在 Zuul 代理中 OAuth2 REST 客户端和认证头转发提供负载均衡。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Sleuth: 适用于 Spring Cloud 应用程序的分布式跟踪，与 Zipkin HTrace 和基于日志（例如 ELK）的跟踪相兼容，可以实现日志的收集。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Data Flow: 一种针对现代运行时可组合的微服务应用程序的云本地编排服务，易于使用的 DSL、拖拽式 GUI 和 REST API 一起简化了基于微服务的数据管道的整体编排。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Stream: 一个轻量级的事件驱动的微服务框架，来快速构建可以连接到外部系统的应用程序。使用 Apache Kafka 或者 RabbitMQ 在 Spring Boot 应用程序之间发生和接受消息的简单声明模型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Stream App Starters: 基于 Spring Boot 为外部系统提供 Spring 的集成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Task App Starters: Spring Cloud Task App Starters 是 Spring Boot 应用程序，可以是任意的进程，包括 Spring Batch 作业，并可以在数据处理有限时间内终止。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Connectors: 便于 PaaS 应用在各平台上连接到后端数据库或者消息服务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Starters: 基于 Spring Boot 的项目，用以简化 Spring Cloud 的依赖管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud CLI: Spring Boot CLI 插件用于在 Groovy 中快速创建 Spring Cloud 组件应用程序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Contract: Spring Cloud Contract 是一个总体项目，其中包含帮助用户成功实施消费者驱动契约（Consumer Driven Contracts）的解决方案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud for Cloud Foundry: Cloud Foundry 是 VMware 推出的开源 PaaS 云平台，利用 Pivotal Cloud Foundry 集成你的应用程序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Cloud Foundry Service Broker: 为建立管理云托管服务的服务代理提供一个起点。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Spring Integration</title><link>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-integration/</guid><description>&lt;h1 id="spring-integration">Spring Integration&lt;/h1>
&lt;p>Spring Integration 提供了 Spring 编程模型的扩展用来支持企业集成模式(Enterprise Integration Patterns)，是对 Spring Messaging 的扩展。它提出了不少新的概念，包括消息路由 MessageRoute、消息分发 MessageDispatcher、消息过滤 Filter、消息转换 Transformer、消息聚合 Aggregator、消息分割 Splitter 等等。同时还提供了 MessageChannel 和 MessageHandler 的实现，分别包括 DirectChannel、ExecutorChannel、PublishSubscribeChannel 和 MessageFilter、ServiceActivatingHandler、MethodInvokingSplitter 等内容。&lt;/p>
&lt;h1 id="消息处理">消息处理&lt;/h1>
&lt;p>消息的分割：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/10/19/KnP3wt.png" alt="消息的分割" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>消息的聚合：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/10/19/KnPUSg.png" alt="消息的聚合" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>消息的过滤：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/10/19/KnPDwq.png" alt="消息的过滤" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>消息的分发：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/10/19/KnPrT0.png" alt="消息的分发" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="简单实例">简单实例&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SubscribableChannel&lt;/span> &lt;span class="n">messageChannel&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">DirectChannel&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;receive: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPayload&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MessageBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">withPayload&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;msgfrom alibaba&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">());&lt;/span> &lt;span class="c1">// 3
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>构造一个可订阅的消息通道 &lt;code>messageChannel&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 &lt;code>MessageHandler&lt;/code> 去消费这个消息通道里的消息；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>发送一条消息到这个消息通道，消息最终被消息通道里的 &lt;code>MessageHandler&lt;/code> 所消费。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>最后控制台打印出: &lt;code>receive: msg from alibaba&lt;/code>；&lt;/p>
&lt;p>&lt;code>DirectChannel&lt;/code> 内部有个 &lt;code>UnicastingDispatcher&lt;/code> 类型的消息分发器，会分发到对应的消息通道 &lt;code>MessageChannel&lt;/code> 中，从名字也可以看出来，&lt;code>UnicastingDispatcher&lt;/code> 是个单播的分发器，只能选择一个消息通道。那么如何选择呢? 内部提供了 &lt;code>LoadBalancingStrategy&lt;/code> 负载均衡策略，默认只有轮询的实现，可以进行扩展。&lt;/p>
&lt;p>我们对上段代码做一点修改，使用多个 &lt;code>MessageHandler&lt;/code> 去处理消息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SubscribableChannel&lt;/span> &lt;span class="n">messageChannel&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DirectChannel&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">msg&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;receive1: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPayload&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">msg&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;receive2: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPayload&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MessageBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">withPayload&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;msg from alibaba&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MessageBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">withPayload&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;msg from alibaba&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于 &lt;code>DirectChannel&lt;/code> 内部的消息分发器是 &lt;code>UnicastingDispatcher&lt;/code> 单播的方式，并且采用轮询的负载均衡策略，所以这里两次的消费分别对应这两个 &lt;code>MessageHandler&lt;/code>。控制台打印出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">receive1:&lt;/span> &lt;span class="n">msg&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">alibaba&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">receive2:&lt;/span> &lt;span class="n">msg&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">alibaba&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>既然存在单播的消息分发器 &lt;code>UnicastingDispatcher&lt;/code>，必然也会存在广播的消息分发器，那就是 &lt;code>BroadcastingDispatcher&lt;/code>，它被 &lt;code>PublishSubscribeChannel&lt;/code> 这个消息通道所使用。广播消息分发器会把消息分发给所有的 &lt;code>MessageHandler&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SubscribableChannel&lt;/span> &lt;span class="n">messageChannel&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">PublishSubscribeChannel&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">msg&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;receive1: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPayload&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">msg&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;receive2: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPayload&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MessageBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">withPayload&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;msg from alibaba&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">messageChannel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MessageBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">withPayload&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;msg from alibaba&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>发送两个消息，都被所有的 &lt;code>MessageHandler&lt;/code> 所消费。控制台打印：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">receive1:&lt;/span> &lt;span class="n">msg&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">alibaba&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">receive2:&lt;/span> &lt;span class="n">msg&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">alibaba&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">receive1:&lt;/span> &lt;span class="n">msg&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">alibaba&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">receive2:&lt;/span> &lt;span class="n">msg&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">alibaba&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Spring Messaging</title><link>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-messaging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/0.%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E6%80%81/%E7%94%9F%E6%80%81%E5%9C%88/spring-messaging/</guid><description>&lt;h1 id="spring-messaging">Spring Messaging&lt;/h1>
&lt;p>Spring Messaging 是 Spring Framework 中的一个模块，其作用就是统一消息的编程模型。比如消息 Messaging 对应的模型就包括一个消息体 Payload 和消息头 Header:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/10/19/KnCV2Q.png" alt="消息结构" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nn">org.springframework.messaging&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">Message&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span> &lt;span class="nf">getPayload&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MessageHeaders&lt;/span> &lt;span class="nf">getHeaders&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>消息通道 MessageChannel 用于接收消息，调用 send 方法可以将消息发送至该消息通道中：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/10/19/KnCG24.png" alt="消息传递" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@FunctionalInterface&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">MessageChannel&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="n">INDEFINITE_TIMEOUT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">INDEFINITE_TIMEOUT&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">timeout&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="消息消费">消息消费&lt;/h1>
&lt;p>由消息通道的子接口可订阅的消息通道 SubscribableChannel 实现，被 MessageHandler 消息处理器所订阅:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">SubscribableChannel&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">MessageChannel&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">subscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MessageHandler&lt;/span> &lt;span class="n">handler&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">unsubscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">MessageHandler&lt;/span> &lt;span class="n">handler&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由 MessageHandler 真正地消费/处理消息:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@FunctionalInterface&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">MessageHandler&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">handleMessage&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Message&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">MessagingException&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Spring Messaging 内部在消息模型的基础上衍生出了其它的一些功能，如：&lt;/p>
&lt;ul>
&lt;li>消息接收参数及返回值处理：消息接收参数处理器 HandlerMethodArgumentResolver 配合 @Header, @Payload 等注解使用；消息接收后的返回值处理器 HandlerMethodReturnValueHandler 配合 @SendTo 注解使用；&lt;/li>
&lt;li>消息体内容转换器 MessageConverter；&lt;/li>
&lt;li>统一抽象的消息发送模板 AbstractMessageSendingTemplate；&lt;/li>
&lt;li>消息通道拦截器 ChannelInterceptor；&lt;/li>
&lt;/ul></description></item></channel></rss>