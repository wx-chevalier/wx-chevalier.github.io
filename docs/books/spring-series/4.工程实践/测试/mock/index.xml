<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mock | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/spring-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%B5%8B%E8%AF%95/mock/</link><atom:link href="https://ng-tech.icu/books/spring-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%B5%8B%E8%AF%95/mock/index.xml" rel="self" type="application/rss+xml"/><description>Mock</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Mock</title><link>https://ng-tech.icu/books/spring-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%B5%8B%E8%AF%95/mock/</link></image><item><title>Mockito</title><link>https://ng-tech.icu/books/spring-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%B5%8B%E8%AF%95/mock/mockito/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%B5%8B%E8%AF%95/mock/mockito/</guid><description>&lt;h1 id="mockito">Mockito&lt;/h1>
&lt;p>Mockito 是用于生成模拟对象或者直接点说，就是”假对象“的工具。两者定位不同，所以一般通常的做法就是联合 JUnit 与 Mockito 来进行测试。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">List&lt;/span> &lt;span class="n">mock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mock&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="n">mock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">assertEquals&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="s">&amp;#34;预期返回1&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">)&lt;/span> &lt;span class="o">);&lt;/span>&lt;span class="c1">// mock.get(0) 返回 1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 mock 是模拟 List 的对象，拥有 List 的所有方法和属性。when(xxxx).thenReturn(yyyy); 是指定当执行了这个方法的时候，返回 thenReturn 的值，相当于是对模拟对象的配置过程，为某些条件给定一个预期的返回值。相信通过这个简单的例子你可以明白所谓 Mock 便是这么一回事。&lt;/p>
&lt;p>我们看到 List 为 Java.util.List 是接口，并不是实现类，但这不妨碍我们使用它作为我们的“打桩”对象，——当然你也可以使用实现类，传入 mock(obj) 方法中。这里提到的是&amp;quot;打桩(Stub，也有人称其为“存根”)&amp;ldquo;的概念，是一个形象的说法，就是把所需的测试数据塞进对象中，适用于基于状态的(state-based)测试，关注的是输入和输出。Mockito 中 when(…).thenReturn(…) 这样的语法来定义对象方法和参数(输入)，然后在 thenReturn 中指定结果(输出)。此过程称为 Stub 打桩。一旦这个方法被 stub 了，就会一直返回这个 stub 的值。&lt;/p>
&lt;p>打桩需要&lt;a href="http://qiuguo0205.iteye.com/blog/1443344" target="_blank" rel="noopener">注意以下几点&lt;/a>：&lt;/p>
&lt;ul>
&lt;li>对于 static 和 final 方法，Mockito 无法对其 when(…).thenReturn(…) 操作。&lt;/li>
&lt;li>当我们连续两次为同一个方法使用 stub 的时候，他只会只用最新的一次。&lt;/li>
&lt;/ul>
&lt;p>mock 对象会覆盖整个被 mock 的对象，因此没有 stub 的方法只能返回默认值。又因为，我们 mock 一个接口的时候，很多成员方法只是一个签名，并没有实现，这就要我们手动写出这些实现方法啦。典型地，我们模拟一个 request 请求对象，你被测试的代码中使用了 HttpSerevletRequest 什么方法，就要写出相应的实现方法！&lt;/p>
&lt;pre tabindex="0">&lt;code>HttpServletRequest request = mock(HttpServletRequest.class);
when(request.getParameter(&amp;#34;foo&amp;#34;)).thenReturn(&amp;#34;boo&amp;#34;);
&lt;/code>&lt;/pre>&lt;p>这里“打桩”之后，我们执行 request.getParamter(&amp;ldquo;foo&amp;rdquo;) 就会返回 boo，如果不这样设定，Mockito 就会返回默认的 null，也不会报错说这个方法找不到。mock 实例默认的会给所有的方法添加基本实现：返回 null 或空集合，或者 0 等基本类型的值。这取决于方法返回类型，如 int 会返回 0，布尔值返回 false。对于其他 type 会返回 null。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 第一种方式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 第二种方式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 第三种方式，都是等价的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;World&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一次调用 i.next() 将返回 ”Hello”，第二次的调用会返回 ”World”。
上述我们一直在讨论被测试的方法都有返回值的，那么没有返回值的 void 方法呢？也是测试吗？答案是肯定的。——只不过 Mockito 要求你的写法上有不同，因为都没返回值了，调用 thenReturn(xxx) 肯定不行，取而代之的写法是，&lt;/p>
&lt;pre tabindex="0">&lt;code>doNothing().when(obj).notify();
// 或直接
when(obj).notify();
&lt;/code>&lt;/pre>&lt;p>Mockito 还能对被测试的方法强行抛出异常，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">thenThrow&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">doThrow&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">// void 方法的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 迭代风格
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">doNothing&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">doThrow&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">// 第一次调用 remove 方法什么都不做，第二次调用抛出 RuntimeException 异常。
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="模拟传入参数-argument-matchers">模拟传入参数 argument matchers&lt;/h2>
&lt;pre tabindex="0">&lt;code>when(request.getParameter(&amp;#34;foo&amp;#34;)).thenReturn(&amp;#34;boo&amp;#34;);
&lt;/code>&lt;/pre>&lt;p>这里 getParameter(&amp;ldquo;foo&amp;rdquo;) 这里我们是写死参数 foo 的，但是如果我不关心输入的具体内容，可以吗？可以的，最好能像正则表达式那样，/w+ 表示任意字符串是不是很方便，不用考虑具体什么参数，只要是 字符串 型的参数，就可以打桩。如此方便的想法 Mockito 也考虑到了，提供 argument matchers 机制，例如 anyString() 匹配任何 String 参数，anyInt() 匹配任何 int 参数，anySet() 匹配任何 Set，any() 则意味着参数为任意值。例子如下，&lt;/p>
&lt;pre tabindex="0">&lt;code>when(mockedList.get(anyInt())).thenReturn(&amp;#34;element&amp;#34;);
System.out.println(mockedList.get(999));// 此时打印是 element
&lt;/code>&lt;/pre>&lt;p>再进一步，自定义类型也可以，如 any(User.class)，另，参见&lt;a href="http://hotdog.iteye.com/blog/911584" target="_blank" rel="noopener">《学习 Mockito - 自定义参数匹配器》&lt;/a> 和 &lt;a href="http://blog.sina.com.cn/s/blog_6176c38201014jrk.html" target="_blank" rel="noopener">这里&lt;/a> 和 &lt;a href="http://blog.csdn.net/onlyqi/article/details/6544989" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;h3 id="获取返回的结果">获取返回的结果&lt;/h3>
&lt;p>一个问题，thenReturn 是返回结果是我们写死的。如果要让被测试的方法不写死，返回实际结果并让我们可以获取到的——怎么做呢？有时我们需要自定义方法执行的返回结果，Answer 接口就是满足这样的需求而存在的。
例如模拟常见的 request.getAttribute(key)，由于这本来是个接口，所以连内部实现都要自己写了。此次通过 Answer 接口获取参数内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">final&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HashMap&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Answer&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">aswser&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Answer&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">answer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">InvocationOnMock&lt;/span> &lt;span class="n">invocation&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Object&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">invocation&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getArguments&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">].&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getAttribute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;isRawOutput&amp;#34;&lt;/span>&lt;span class="o">)).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getAttribute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;errMsg&amp;#34;&lt;/span>&lt;span class="o">)).&lt;/span>&lt;span class="na">thenAnswer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">aswser&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getAttribute&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;msg&amp;#34;&lt;/span>&lt;span class="o">)).&lt;/span>&lt;span class="na">thenAnswer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">aswser&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>利用 InvocationOnMock 提供的方法可以获取 mock 方法的调用信息。下面是它提供的方法：&lt;/p>
&lt;ul>
&lt;li>getArguments() 调用后会以 Object 数组的方式返回 mock 方法调用的参数。&lt;/li>
&lt;li>getMethod() 返回 java.lang.reflect.Method 对象&lt;/li>
&lt;li>getMock() 返回 mock 对象&lt;/li>
&lt;li>callRealMethod() 真实方法调用，如果 mock 的是接口它将会抛出异常&lt;/li>
&lt;/ul>
&lt;p>void 方法可以获取参数，只是写法上有区别，&lt;/p>
&lt;pre tabindex="0">&lt;code>doAnswer(new Answer&amp;lt;Object&amp;gt;() {
public Object answer(InvocationOnMock invocation) {
Object[] args = invocation.getArguments();
// Object mock = invocation.getMock();
System.out.println(args[1]);
hash.put(args[0].toString(), args[1]);
return &amp;#34;called with arguments: &amp;#34; + args;
}
}).when(request).setAttribute(anyString(), anyString());
&lt;/code>&lt;/pre>&lt;h2 id="验证-verify">验证 Verify&lt;/h2>
&lt;p>前面提到的 when(……).thenReturn(……) 属于状态测试，某些时候，测试不关心返回结果，而是侧重方法有否被正确的参数调用过，这时候就应该使用 验证方法了。从概念上讲，就是和状态测试所不同的“行为测试”了。
一旦使用 mock() 对模拟对象打桩，意味着 Mockito 会记录着这个模拟对象调用了什么方法，还有调用了多少次。最后由用户决定是否需要进行验证，即 verify() 方法。
verify() 说明其作用的例子，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">mockedList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mockedList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;two&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">verify&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mockedList&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 如果times不传入，则默认是1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>verify 内部跟踪了所有的方法调用和参数的调用情况，然后会返回一个结果，说明是否通过。参见另外一个详细的例子。&lt;/p>
&lt;pre tabindex="0">&lt;code>Map mock = Mockito.mock( Map.class );
when( mock.get( &amp;#34;city&amp;#34; ) ).thenReturn( &amp;#34;广州&amp;#34; );
// 关注参数有否传入
verify(mock).get( Matchers.eq( &amp;#34;city&amp;#34; ) );
// 关注调用的次数
verify(mock, times( 2 ));
&lt;/code>&lt;/pre>&lt;p>也就是说，这是对历史记录作一种回溯校验的处理。&lt;/p>
&lt;p>这里补充一个学究的问题，所谓 Mock 与 Stub 打桩，其实它们之间不能互为其表。但 Mockito 语境中则 &lt;a href="http://stamen.iteye.com/blog/1470066" target="_blank" rel="noopener">Stub 和 Mock 对象同时使用的&lt;/a>。因为它既可以设置方法调用返回值，又可以验证方法的调用。有关 stub 和 mock 的详细论述请见 Martin Fowler 大叔的文章&lt;a href="http://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">《Mocks Aren&amp;rsquo;t Stub》&lt;/a>。&lt;/p>
&lt;p>Mockito 除了提供 times(N) 方法供我们调用外，还提供了很多可选的方法：&lt;/p>
&lt;ul>
&lt;li>never() 没有被调用，相当于 times(0)&lt;/li>
&lt;li>atLeast(N) 至少被调用 N 次&lt;/li>
&lt;li>atLeastOnce() 相当于 atLeast(1)&lt;/li>
&lt;li>atMost(N) 最多被调用 N 次&lt;/li>
&lt;/ul>
&lt;p>verify 也可以像 when 那样使用模拟参数，若方法中的某一个参数使用了 matcher，则所有的参数都必须使用 matcher。&lt;/p>
&lt;pre tabindex="0">&lt;code>// correct
verify(mock).someMethod(anyInt(), anyString(), eq(&amp;#34;third argument&amp;#34;));
// will throw exception
verify(mock).someMethod(anyInt(), anyString(), &amp;#34;third argument&amp;#34;);
&lt;/code>&lt;/pre>&lt;p>在最后的验证时如果只输入字符串”hello”是会报错的，必须使用 Matchers 类内建的 eq 方法。&lt;/p>
&lt;pre tabindex="0">&lt;code>Map mapMock = mock(Map.class);
when(mapMock.put(anyInt(), anyString())).thenReturn(&amp;#34;world&amp;#34;);
mapMock.put(1, &amp;#34;hello&amp;#34;);
verify(mapMock).put(anyInt(), eq(&amp;#34;hello&amp;#34;));
&lt;/code>&lt;/pre>&lt;p>其他高级用法，详见&lt;a href="http://hotdog.iteye.com/blog/908827" target="_blank" rel="noopener">《学习 Mockito - Mock 对象的行为验证》&lt;/a>，主要特性如下，&lt;/p>
&lt;ul>
&lt;li>参数验证，详见&lt;a href="http://hotdog.iteye.com/blog/916364" target="_blank" rel="noopener">《利用 ArgumentCaptor(参数捕获器)捕获方法参数进行验证》&lt;/a>&lt;/li>
&lt;li>超时验证，通过 timeout，并制定毫秒数验证超时。注意，如果被调用多次，times 还是需要的。&lt;/li>
&lt;li>方法调用顺序 通过 InOrder 对象，验证方法的执行顺序，如上例子中，如果 mock 的 get(0) 和 get(1) 方法反过来则测试不通过。这里 mock2 其实没有被调用过。所以不需要些。&lt;/li>
&lt;li>verifyNoMoreInteractions 查询是否存在被调用，但未被验证的方法，如果存在则抛出异常。这里因为验证了 get(anyInt())，相当于所有的 get 方法被验证，所以通过。&lt;/li>
&lt;li>verifyZeroInteractions 查询对象是否未产生交互，如果传入 的 mock 对象的方法被调用过，则抛出异常。这里 mock2 的方法没有被调用过，所有通过。&lt;/li>
&lt;/ul>
&lt;p>参见&lt;a href="http://blog.sina.com.cn/s/blog_6176c38201014lzc.html" target="_blank" rel="noopener">《用 mockito 的 verify 来验证 mock 的方法是否被调用》&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>看 mockito 的 api 时，一直都不清楚 veriry()这个方法的作用，因为如果我 mock 了某个方法，肯定是为了调用的啊。直到今天在回归接口测试用例的时候，发现有两个用例，用例 2 比用例 1 多了一个 mock 的步骤，不过最后的结果输出是一样的。由于代码做了修改，我重新 mock 后，其实用例 2 中对于的步骤是不会执行的，可测试还是通过了。仔细查看后，发现 mock 的方法没有被调用，所以用例 2 和用例 1 就变成一样的了。于是，就产生了这么个需求：单单通过结果来判断正确与否还是不够的，我还要判断是否按我指定的路径执行的用例。到这里，终于领略到了 mockito 的 verify 的强大威力，以下是示例代码：&lt;/p>
&lt;p>若调用成功，则程序正常运行，反之则会报告: Wanted but not invoked:verify(mockedList).add(&amp;ldquo;one&amp;rdquo;); 错误。&lt;/p>
&lt;/blockquote>
&lt;p>感觉 verify 会用的比较少。&lt;/p>
&lt;h2 id="spy">Spy&lt;/h2>
&lt;p>spy 的意思是你可以修改某个真实对象的某些方法的行为特征，而不改变他的基本行为特征，这种策略的使用跟 AOP 有点类似。下面举官方的例子来说明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">List&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LinkedList&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">List&lt;/span> &lt;span class="n">spy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">spy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//optionally, you can stub out some methods:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">spy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//using the spy calls &amp;lt;b&amp;gt;real&amp;lt;/b&amp;gt; methods
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">spy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">spy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;two&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//prints &amp;#34;one&amp;#34; - the first element of a list
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">spy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//size() method was stubbed - 100 is printed
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">spy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//optionally, you can verify
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">verify&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">spy&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">verify&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">spy&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;two&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 spy 保留了 list 的大部分功能，只是将它的 size() 方法改写了。不过 spy 在使用的时候有很多地方需要注意，一不小心就会导致问题，所以不到万不得已还是不要用 spy。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">save&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">User&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">User&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setLoginName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;admin&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 第一次调用findUserByLoginName返回user 第二次调用返回null
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mockUserDao&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">findUserByLoginName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">anyString&lt;/span>&lt;span class="o">())).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">thenReturn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 测试如果重名会抛出异常
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">userService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果没有抛出异常测试不通过
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">failBecauseExceptionWasNotThrown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ServiceException&lt;/span> &lt;span class="n">se&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">verify&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mockUserDao&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">findUserByLoginName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;admin&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// userService.save(user);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setPassword&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;123456&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">userId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">userService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 断言返回结果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">assertThat&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">userId&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">isNotEmpty&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">hasSize&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">32&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">verify&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mockUserDao&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">times&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">)).&lt;/span>&lt;span class="na">findUserByLoginName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">anyString&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">verify&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mockUserDao&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">any&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">save2&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">User&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">User&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setLoginName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;admin&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setPassword&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;123456&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">userService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通过ArgumentCaptor(参数捕获器) 对传入参数进行验证
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">ArgumentCaptor&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">argument&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ArgumentCaptor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">forClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">verify&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mockUserDao&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">argument&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">capture&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assertThat&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;admin&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">isEqualTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">argument&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getValue&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getLoginName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// stub 调用save方法时抛出异常
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">doThrow&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">ServiceException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;测试抛出异常&amp;#34;&lt;/span>&lt;span class="o">)).&lt;/span>&lt;span class="na">when&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mockUserDao&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">any&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">userService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">failBecauseExceptionWasNotThrown&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ServiceException&lt;/span> &lt;span class="n">se&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="模拟-servlet">模拟 Servlet&lt;/h2>
&lt;p>&lt;a href="http://blog.csdn.net/zhangxin09/article/details/42487319" target="_blank" rel="noopener">JUnit + Mockito 单元测试(三)&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>FEATURE&lt;/th>
&lt;th>JUNIT 4&lt;/th>
&lt;th>JUNIT 5&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Declare a test method&lt;/td>
&lt;td>&lt;code>@Test&lt;/code>&lt;/td>
&lt;td>&lt;code>@Test&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Execute before all test methods in the current class&lt;/td>
&lt;td>&lt;code>@BeforeClass&lt;/code>&lt;/td>
&lt;td>&lt;code>@BeforeAll&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Execute after all test methods in the current class&lt;/td>
&lt;td>&lt;code>@AfterClass&lt;/code>&lt;/td>
&lt;td>&lt;code>@AfterAll&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Execute before each test method&lt;/td>
&lt;td>&lt;code>@Before&lt;/code>&lt;/td>
&lt;td>&lt;code>@BeforeEach&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Execute after each test method&lt;/td>
&lt;td>&lt;code>@After&lt;/code>&lt;/td>
&lt;td>&lt;code>@AfterEach&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Disable a test method / class&lt;/td>
&lt;td>&lt;code>@Ignore&lt;/code>&lt;/td>
&lt;td>&lt;code>@Disabled&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Test factory for dynamic tests&lt;/td>
&lt;td>NA&lt;/td>
&lt;td>&lt;code>@TestFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Nested tests&lt;/td>
&lt;td>NA&lt;/td>
&lt;td>&lt;code>@Nested&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tagging and filtering&lt;/td>
&lt;td>&lt;code>@Category&lt;/code>&lt;/td>
&lt;td>&lt;code>@Tag&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Register custom extensions&lt;/td>
&lt;td>NA&lt;/td>
&lt;td>&lt;code>@ExtendWith&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>TestableMock</title><link>https://ng-tech.icu/books/spring-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%B5%8B%E8%AF%95/mock/testablemock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%B5%8B%E8%AF%95/mock/testablemock/</guid><description>&lt;h1 id="testablemock">TestableMock&lt;/h1>
&lt;p>TestableMock 是基于源码和字节码增强的 Java 单元测试辅助工具，包含以下功能：&lt;/p>
&lt;ul>
&lt;li>快速 Mock 任意调用：使被测类的任意方法调用快速替换为 Mock 方法，实现&amp;quot;指哪换哪&amp;quot;，解决传统 Mock 工具使用繁琐的问题。&lt;/li>
&lt;li>访问被测类私有成员：使单元测试能直接调用和访问被测类的私有成员，解决私有成员初始化和私有方法测试的问题。&lt;/li>
&lt;li>辅助测试 void 方法：利用 Mock 校验器对方法的内部逻辑进行检查，解决无返回值方法难以实施单元测试的问题。&lt;/li>
&lt;li>快速构造参数对象：生成任意多层嵌套的对象实例，并简化其内部成员赋值方式，解决被测方法参数初始化代码冗长的问题。&lt;/li>
&lt;/ul>
&lt;h1 id="hello-world">Hello World&lt;/h1>
&lt;h2 id="依赖配置">依赖配置&lt;/h2>
&lt;p>在 &lt;code>build.gradle&lt;/code> 文件中添加 &lt;code>TestableMock&lt;/code> 依赖：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">dependencies&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">testImplementation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;com.alibaba.testable:testable-all:0.5.2&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">testAnnotationProcessor&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;com.alibaba.testable:testable-processor:0.5.2&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在测试配置中添加 javaagent：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">test&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">jvmArgs&lt;/span> &lt;span class="s2">&amp;#34;-javaagent:${classpath.find { it.name.contains(&amp;#34;&lt;/span>&lt;span class="n">testable&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">agent&lt;/span>&lt;span class="s2">&amp;#34;) }.absolutePath}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后相比以往 Mock 工具以类为粒度的 Mock 方式，TestableMock 允许用户直接定义需要 Mock 的单个方法，并遵循约定优于配置的原则，按照规则自动在测试运行时替换被测方法中的指定方法调用。&lt;/p>
&lt;ul>
&lt;li>Mock 非构造方法，拷贝原方法定义到 Mock 容器类，加 @MockMethod 注解&lt;/li>
&lt;li>Mock 构造方法，拷贝原方法定义到 Mock 容器类，返回值换成构造的类型，方法名随意，加@MockContructor 注解&lt;/li>
&lt;/ul>
&lt;h2 id="覆写任意类的方法调用">覆写任意类的方法调用&lt;/h2>
&lt;p>首先为测试类添加一个关联的 Mock 类型，作为承载其 Mock 方法的容器，最简单的做法是在测试类里添加一个名称为 Mock 的静态内部类。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DemoTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Mock&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 放置 Mock 方法的地方
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Mock 容器类中定义一个有@MockMethod 注解的普通方法，使它与需覆写的方法名称、参数、返回值类型完全一致，并在注解的 targetClass 参数指定该方法原本所属对象类型。此时被测类中所有对该需覆写方法的调用，将在单元测试运行时，将自动被替换为对上述自定义 Mock 方法的调用。例如，被测类中有一处&amp;quot;anything&amp;quot;.substring(1, 2)调用，我们希望在运行测试的时候将它换成一个固定字符串，则只需在 Mock 容器类定义如下方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 原方法签名为`String substring(int, int)`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 调用此方法的对象`&amp;#34;anything&amp;#34;`类型为`String`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nd">@MockMethod&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">targetClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">substring&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;sub_string&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当遇到待覆写方法有重名时，可以将需覆写的方法名写到 @MockMethod 注解的 targetMethod 参数里，这样 Mock 方法自身就可以随意命名了。下面这个例子展示了 targetMethod 参数的用法，其效果与上述示例相同：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 使用`targetMethod`指定需Mock的方法名
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 此方法本身现在可以随意命名，但方法参数依然需要遵循相同的匹配规则
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nd">@MockMethod&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">targetClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">targetMethod&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;substring&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">use_any_mock_method_name&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;sub_string&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有时，在 Mock 方法里会需要访问发起调用的原始对象中的成员变量，或是调用原始对象的其他方法。此时，可以将 @MockMethod 注解中的 targetClass 参数去除，然后在方法参数列表首位增加一个类型为该方法原本所属对象类型的参数。TestableMock 约定，当@MockMethod 注解的 targetClass 参数值为空时，Mock 方法的首位参数即为目标方法所属类型，参数名称随意。通常为了便于代码阅读，建议将此参数统一命名为 self 或 src。举例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Mock方法在参数列表首位增加一个类型为`String`的参数（名字随意）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 此参数可用于获得当时的实际调用者的值和上下文
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nd">@MockMethod&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">substring&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">self&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 可以直接调用原方法，此时Mock方法仅用于记录调用，常见于对void方法的测试
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">substring&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="覆写被测类自身的成员方法">覆写被测类自身的成员方法&lt;/h2>
&lt;p>有时候，在对某些方法进行测试时，希望将被测类自身的另外一些成员方法 Mock 掉（比如这个方法里有许多外部依赖或耗时操作）。做法与前一种情况完全相同，只需将 targetClass 参数赋值为被测类，即可实现对被测类自身（不论是公有或私有）成员方法的覆写。例如，被测类中有一个签名为 String innerFunc(String)的私有方法，我们希望在测试的时候将它替换掉，则只需在 Mock 容器类定义如下方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 被测类型是`DemoMock`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nd">@MockMethod&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">targetClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DemoMock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">innerFunc&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;mock_&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样的，上述示例中的方法如需访问发起调用的原始被测对象，也可不使用 targetClass 参数，而是在定义 Mock 方法时，在方法参数列表首位加一个类型为 DemoMock 的参数（名字随意）。&lt;/p>
&lt;h2 id="覆写任意类的静态方法">覆写任意类的静态方法&lt;/h2>
&lt;p>对于静态方法的 Mock 与普通方法相同。例如，在被测类中调用了&lt;code>BlackBox&lt;/code>类型中的静态方法&lt;code>secretBox()&lt;/code>，该方法签名为&lt;code>BlackBox secretBox()&lt;/code>，则 Mock 方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@MockMethod&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">targetClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BlackBox&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">BlackBox&lt;/span> &lt;span class="nf">secretBox&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">BlackBox&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;not_secret_box&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于静态方法的 Mock，通常不使用方法参数列表的首位加参数来表示目标类型。但这种方法也依然适用，只是实际传入的第一个参数值将始终是&lt;code>null&lt;/code>。&lt;/p>
&lt;h2 id="覆写任意类的-new-操作">覆写任意类的 new 操作&lt;/h2>
&lt;p>在 Mock 容器类里定义一个返回值类型为要被创建的对象类型，且方法参数与要 Mock 的构造函数参数完全一致的方法，名称随意，然后加上&lt;code>@MockContructor&lt;/code>注解。此时被测类中所有用&lt;code>new&lt;/code>创建指定类的操作（并使用了与 Mock 方法参数一致的构造函数）将被替换为对该自定义方法的调用。&lt;/p>
&lt;p>例如，在被测类中有一处&lt;code>new BlackBox(&amp;quot;something&amp;quot;)&lt;/code>调用，希望在测试时将它换掉（通常是换成 Mock 对象，或换成使用测试参数创建的临时对象），则只需定义如下 Mock 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 要覆写的构造函数签名为`BlackBox(String)`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Mock方法返回`BlackBox`类型对象，方法的名称随意起
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nd">@MockContructor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">BlackBox&lt;/span> &lt;span class="nf">createBlackBox&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">BlackBox&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;mock_&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="在-mock-方法中区分调用来源">在 Mock 方法中区分调用来源&lt;/h2>
&lt;p>在 Mock 方法中通过 TestableTool.SOURCE_METHOD 变量可以识别进入该 Mock 方法前的被测类方法名称；此外，还可以借助 TestableTool.MOCK_CONTEXT 变量为 Mock 方法注入“额外的上下文参数”，从而区分处理不同的调用场景。例如，在测试用例中验证当被 Mock 方法返回不同结果时，对被测目标方法的影响：
例如，在测试用例中验证当被 Mock 方法返回不同结果时，对被测目标方法的影响：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">testDemo&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MOCK_CONTEXT&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;case&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;data-ready&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assertEquals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">demo&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MOCK_CONTEXT&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;case&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;has-error&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assertEquals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">demo&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Mock 方法中取出注入的参数，根据情况返回不同结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@MockMethod&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="n">Data&lt;/span> &lt;span class="nf">mockDemo&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">switch&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="n">MOCK_CONTEXT&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;case&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;data-ready&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Data&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;has-error&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">NetworkException&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>