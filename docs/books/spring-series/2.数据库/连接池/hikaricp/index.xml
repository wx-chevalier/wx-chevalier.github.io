<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HikariCP | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/spring-series/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%B1%A0/hikaricp/</link><atom:link href="https://ng-tech.icu/books/spring-series/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%B1%A0/hikaricp/index.xml" rel="self" type="application/rss+xml"/><description>HikariCP</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>HikariCP</title><link>https://ng-tech.icu/books/spring-series/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%B1%A0/hikaricp/</link></image><item><title>HikariCP 实现中的优化技巧</title><link>https://ng-tech.icu/books/spring-series/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%B1%A0/hikaricp/hikaricp-%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%B1%A0/hikaricp/hikaricp-%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</guid><description>&lt;h1 id="性能之道">性能之道&lt;/h1>
&lt;h2 id="优化并精简字节码">优化并精简字节码&lt;/h2>
&lt;p>HikariCP 利用了一个第三方的 Java 字节码修改类库 Javassist 来生成委托实现动态代理。动态代理的实现在 ProxyFactory 类，源码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">static&lt;/span> &lt;span class="n">ProxyConnection&lt;/span> &lt;span class="nf">getProxyConnection&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kd">final&lt;/span> &lt;span class="n">PoolEntry&lt;/span> &lt;span class="n">poolEntry&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Connection&lt;/span> &lt;span class="n">connection&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">FastList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Statement&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">openStatements&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">ProxyLeakTask&lt;/span> &lt;span class="n">leakTask&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">isReadOnly&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">isAutoCommit&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Body is replaced (injected) by JavassistProxyFactory
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IllegalStateException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;You need to run the CLI build and you need target/classes in your classpath to run.&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现这些代理方法中只有一行直接抛异常的代码，注释写着“Body is replaced (injected) by JavassistProxyFactory”，其实方法 body 中的代码是在编译时调用 JavassistProxyFactory 才生成的，主要代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">...&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">Exception&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">classPool&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ClassPool&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">classPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">importPackage&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;java.sql&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">classPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">appendClassPath&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">LoaderClassPath&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">JavassistProxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClassLoader&lt;/span>&lt;span class="o">()));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">genDirectory&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Cast is not needed for these
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">methodBody&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;{ try { return delegate.method($$); } catch (SQLException e) { throw checkException(e); } }&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">generateProxyClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Connection&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ProxyConnection&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">methodBody&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">generateProxyClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Statement&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ProxyStatement&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">methodBody&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">generateProxyClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ResultSet&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ProxyResultSet&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">methodBody&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// For these we have to cast the delegate
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">methodBody&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;{ try { return ((cast) delegate).method($$); } catch (SQLException e) { throw checkException(e); } }&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">generateProxyClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">PreparedStatement&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ProxyPreparedStatement&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">methodBody&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">generateProxyClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">CallableStatement&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ProxyCallableStatement&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">methodBody&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">modifyProxyFactory&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">modifyProxyFactory&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">NotFoundException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">CannotCompileException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Generating method bodies for com.zaxxer.hikari.proxy.ProxyFactory&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">packageName&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ProxyConnection&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPackage&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CtClass&lt;/span> &lt;span class="n">proxyCt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">classPool&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getCtClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;com.zaxxer.hikari.pool.ProxyFactory&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">CtMethod&lt;/span> &lt;span class="n">method&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">proxyCt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getMethods&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">switch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;getProxyConnection&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">method&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setBody&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;{return new &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">packageName&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;.HikariProxyConnection($$);}&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;getProxyStatement&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">method&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setBody&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;{return new &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">packageName&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;.HikariProxyStatement($$);}&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;getProxyPreparedStatement&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">method&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setBody&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;{return new &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">packageName&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;.HikariProxyPreparedStatement($$);}&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;getProxyCallableStatement&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">method&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setBody&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;{return new &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">packageName&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;.HikariProxyCallableStatement($$);}&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;getProxyResultSet&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">method&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setBody&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;{return new &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">packageName&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;.HikariProxyResultSet($$);}&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// unhandled method
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">proxyCt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">writeFile&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">genDirectory&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;target/classes&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之所以使用 Javassist 生成动态代理，是因为其速度更快，相比于 JDK Proxy 生成的字节码更少，精简了很多不必要的字节码。&lt;/p>
&lt;h2 id="concurrentbag">ConcurrentBag&lt;/h2>
&lt;p>ConcurrentBag 的实现借鉴于 C#中的同名类，是一个专门为连接池设计的 lock-less 集合，实现了比 LinkedBlockingQueue、LinkedTransferQueue 更好的并发性能。ConcurrentBag 内部同时使用了 ThreadLocal 和 CopyOnWriteArrayList 来存储元素，其中 CopyOnWriteArrayList 是线程共享的。&lt;/p>
&lt;p>ConcurrentBag 采用了 queue-stealing 的机制获取元素：首先尝试从 ThreadLocal 中获取属于当前线程的元素来避免锁竞争，如果没有可用元素则再次从共享的 CopyOnWriteArrayList 中获取，进而减少伪共享的发生。&lt;/p>
&lt;h2 id="fastlist">FastList&lt;/h2>
&lt;p>FastList 是一个 List 接口的精简实现，只实现了接口中必要的几个方法。JDK ArrayList 每次调用 get()方法时都会进行 rangeCheck 检查索引是否越界，FastList 的实现中去除了这一检查，只要保证索引合法那么 rangeCheck 就成为了不必要的计算开销。&lt;/p>
&lt;p>此外，HikariCP 使用 List 来保存打开的 Statement，当 Statement 关闭或 Connection 关闭时需要将对应的 Statement 从 List 中移除。通常情况下，同一个 Connection 创建了多个 Statement 时，后打开的 Statement 会先关闭。ArrayList 的 remove(Object)方法是从头开始遍历数组，而 FastList 是从数组的尾部开始遍历，因此更为高效。&lt;/p></description></item><item><title>配置详解</title><link>https://ng-tech.icu/books/spring-series/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%B1%A0/hikaricp/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-series/2.%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BF%9E%E6%8E%A5%E6%B1%A0/hikaricp/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>&lt;h1 id="hikaricp-配置详解">HikariCP 配置详解&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;strong>name&lt;/strong>&lt;/th>
&lt;th style="text-align:left">&lt;strong>描述&lt;/strong>&lt;/th>
&lt;th style="text-align:left">&lt;strong>构造器默认值&lt;/strong>&lt;/th>
&lt;th style="text-align:left">&lt;strong>默认配置 validate 之后的值&lt;/strong>&lt;/th>
&lt;th style="text-align:left">&lt;strong>validate 重置&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">autoCommit&lt;/td>
&lt;td style="text-align:left">自动提交从池中返回的连接&lt;/td>
&lt;td style="text-align:left">TRUE&lt;/td>
&lt;td style="text-align:left">TRUE&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">connectionTimeout&lt;/td>
&lt;td style="text-align:left">等待来自池的连接的最大毫秒数&lt;/td>
&lt;td style="text-align:left">SECONDS.toMillis(30) = 30000&lt;/td>
&lt;td style="text-align:left">30000&lt;/td>
&lt;td style="text-align:left">如果小于 250 毫秒，则被重置回 30 秒&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">idleTimeout&lt;/td>
&lt;td style="text-align:left">连接允许在池中闲置的最长时间&lt;/td>
&lt;td style="text-align:left">MINUTES.toMillis(10) = 600000&lt;/td>
&lt;td style="text-align:left">600000&lt;/td>
&lt;td style="text-align:left">如果 idleTimeout+1 秒&amp;gt;maxLifetime 且 maxLifetime&amp;gt;0，则会被重置为 0（代表永远不会退出）；如果 idleTimeout!=0 且小于 10 秒，则会被重置为 10 秒&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">maxLifetime&lt;/td>
&lt;td style="text-align:left">池中连接最长生命周期&lt;/td>
&lt;td style="text-align:left">MINUTES.toMillis(30) = 1800000&lt;/td>
&lt;td style="text-align:left">1800000&lt;/td>
&lt;td style="text-align:left">如果不等于 0 且小于 30 秒则会被重置回 30 分钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">connectionTestQuery&lt;/td>
&lt;td style="text-align:left">如果您的驱动程序支持 JDBC4，我们强烈建议您不要设置此属性&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">minimumIdle&lt;/td>
&lt;td style="text-align:left">池中维护的最小空闲连接数&lt;/td>
&lt;td style="text-align:left">-1&lt;/td>
&lt;td style="text-align:left">10&lt;/td>
&lt;td style="text-align:left">minIdle&amp;lt;0 或者 minIdle&amp;gt;maxPoolSize,则被重置为 maxPoolSize&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">maximumPoolSize&lt;/td>
&lt;td style="text-align:left">池中最大连接数，包括闲置和使用中的连接&lt;/td>
&lt;td style="text-align:left">-1&lt;/td>
&lt;td style="text-align:left">10&lt;/td>
&lt;td style="text-align:left">如果 maxPoolSize 小于 1，则会被重置。当 minIdle&amp;lt;=0 被重置为 DEFAULT_POOL_SIZE 则为 10;如果 minIdle&amp;gt;0 则重置为 minIdle 的值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">metricRegistry&lt;/td>
&lt;td style="text-align:left">该属性允许您指定一个 Codahale / Dropwizard MetricRegistry 的实例，供池使用以记录各种指标&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">healthCheckRegistry&lt;/td>
&lt;td style="text-align:left">该属性允许您指定池使用的 Codahale / Dropwizard HealthCheckRegistry 的实例来报告当前健康信息&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">poolName&lt;/td>
&lt;td style="text-align:left">连接池的用户定义名称，主要出现在日志记录和 JMX 管理控制台中以识别池和池配置&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">HikariPool-1&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">initializationFailTimeout&lt;/td>
&lt;td style="text-align:left">如果池无法成功初始化连接，则此属性控制池是否将 fail fast&lt;/td>
&lt;td style="text-align:left">1&lt;/td>
&lt;td style="text-align:left">1&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">isolateInternalQueries&lt;/td>
&lt;td style="text-align:left">是否在其自己的事务中隔离内部池查询，例如连接活动测试&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">allowPoolSuspension&lt;/td>
&lt;td style="text-align:left">控制池是否可以通过 JMX 暂停和恢复&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">readOnly&lt;/td>
&lt;td style="text-align:left">从池中获取的连接是否默认处于只读模式&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">registerMbeans&lt;/td>
&lt;td style="text-align:left">是否注册 JMX 管理 Bean（MBeans）&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">FALSE&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">catalog&lt;/td>
&lt;td style="text-align:left">为支持 catalog 概念的数据库设置默认 catalog&lt;/td>
&lt;td style="text-align:left">driver default&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">connectionInitSql&lt;/td>
&lt;td style="text-align:left">该属性设置一个 SQL 语句，在将每个新连接创建后，将其添加到池中之前执行该语句。&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">driverClassName&lt;/td>
&lt;td style="text-align:left">HikariCP 将尝试通过仅基于 jdbcUrl 的 DriverManager 解析驱动程序，但对于一些较旧的驱动程序，还必须指定 driverClassName&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">transactionIsolation&lt;/td>
&lt;td style="text-align:left">控制从池返回的连接的默认事务隔离级别&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">validationTimeout&lt;/td>
&lt;td style="text-align:left">连接将被测试活动的最大时间量&lt;/td>
&lt;td style="text-align:left">SECONDS.toMillis(5) = 5000&lt;/td>
&lt;td style="text-align:left">5000&lt;/td>
&lt;td style="text-align:left">如果小于 250 毫秒，则会被重置回 5 秒&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">leakDetectionThreshold&lt;/td>
&lt;td style="text-align:left">记录消息之前连接可能离开池的时间量，表示可能的连接泄漏&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;td style="text-align:left">如果大于 0 且不是单元测试，则进一步判断：(leakDetectionThreshold &amp;lt; SECONDS.toMillis(2) or (leakDetectionThreshold &amp;gt; maxLifetime &amp;amp;&amp;amp; maxLifetime &amp;gt; 0)，会被重置为 0 . 即如果要生效则必须&amp;gt;0，而且不能小于 2 秒，而且当 maxLifetime &amp;gt; 0 时不能大于 maxLifetime&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">dataSource&lt;/td>
&lt;td style="text-align:left">这个属性允许你直接设置数据源的实例被池包装，而不是让 HikariCP 通过反射来构造它&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">schema&lt;/td>
&lt;td style="text-align:left">该属性为支持模式概念的数据库设置默认模式&lt;/td>
&lt;td style="text-align:left">driver default&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">threadFactory&lt;/td>
&lt;td style="text-align:left">此属性允许您设置将用于创建池使用的所有线程的 java.util.concurrent.ThreadFactory 的实例。&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">scheduledExecutor&lt;/td>
&lt;td style="text-align:left">此属性允许您设置将用于各种内部计划任务的 java.util.concurrent.ScheduledExecutorService 实例&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">null&lt;/td>
&lt;td style="text-align:left">–&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>