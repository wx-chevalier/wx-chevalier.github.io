<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cordova | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/frontend-notes/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/webview/cordova/</link><atom:link href="https://ng-tech.icu/books/frontend-notes/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/webview/cordova/index.xml" rel="self" type="application/rss+xml"/><description>Cordova</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Cordova</title><link>https://ng-tech.icu/books/frontend-notes/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/webview/cordova/</link></image><item><title>iOS</title><link>https://ng-tech.icu/books/frontend-notes/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/webview/cordova/ios/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/frontend-notes/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/webview/cordova/ios/</guid><description>&lt;h1 id="cordova">Cordova&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://cordova.apache.org/docs/en/latest/guide/platforms/ios/plugin.html" target="_blank" rel="noopener">iOS Plugin Development Guide&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在 iOS 的 WebView 开发中，经常会把 Cordova 作为增强版的 WebView 使用。关于本部分的实例可以参考笔者的&lt;a href="https://github.com/wx-chevalier/iOS-Boilerplate/tree/master/UI-Components/Widgets/WebView/Cordova" target="_blank" rel="noopener">iOSBoilerplate&lt;/a>，可以在 REAME.md 中查看使用说明，也可以&lt;code>git clone&lt;/code>之后直接运行，按照指导进入相关页面。&lt;/p>
&lt;h2 id="installation">Installation&lt;/h2>
&lt;p>引入 Cordova 主要包含三个步骤(怎么感觉有点像把大象塞到冰箱)：(1)在 Podfile 中加入依赖项可以使用&lt;code>pod search Cordova&lt;/code>命令来搜索可用的 Cordova 版本，笔者是使用的 4.0.1 版本：&lt;/p>
&lt;pre tabindex="0">&lt;code>pod &amp;#39;Cordova&amp;#39;, &amp;#39;~&amp;gt; 4.0.1&amp;#39; # 支持Cordova WebView容器
&lt;/code>&lt;/pre>&lt;p>添加完毕然后使用&lt;code>pod install&lt;/code>命令下载即可。(2)添加 config.xml config.xml 即是主要的配置文件，在 iOS 中其需要放置到&lt;code>/AppName/config.xml&lt;/code>这种样式。笔者的 config.xml 文件的示范为：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?xml version=&amp;#39;1.0&amp;#39; encoding=&amp;#39;utf-8&amp;#39;?&amp;gt;
&amp;lt;widget id=&amp;#34;io.cordova.hellocordova&amp;#34; version=&amp;#34;0.0.1&amp;#34; xmlns=&amp;#34;http://www.w3.org/ns/widgets&amp;#34; xmlns:cdv=&amp;#34;http://cordova.apache.org/ns/1.0&amp;#34;&amp;gt;
&amp;lt;name&amp;gt;iOSBoilerplate&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;
Cordova Demo in iOS Boilerplate
&amp;lt;/description&amp;gt;
&amp;lt;author email=&amp;#34;dev@cordova.apache.org&amp;#34; href=&amp;#34;http://cordova.io&amp;#34;&amp;gt;
Chevalier
&amp;lt;/author&amp;gt;
&amp;lt;content src=&amp;#34;index.html&amp;#34; /&amp;gt;
&amp;lt;preference name=&amp;#34;BackupWebStorage&amp;#34; value=&amp;#34;local&amp;#34;/&amp;gt;
&amp;lt;plugin name=&amp;#34;cordova-plugin-whitelist&amp;#34; version=&amp;#34;1&amp;#34; /&amp;gt;
&amp;lt;access origin=&amp;#34;*&amp;#34; /&amp;gt;
&amp;lt;access origin=&amp;#34;*.baidu.*&amp;#34; /&amp;gt;
&amp;lt;allow-intent href=&amp;#34;http://*/*&amp;#34; /&amp;gt;
&amp;lt;allow-intent href=&amp;#34;https://*/*&amp;#34; /&amp;gt;
&amp;lt;allow-intent href=&amp;#34;tel:*&amp;#34; /&amp;gt;
&amp;lt;allow-intent href=&amp;#34;sms:*&amp;#34; /&amp;gt;
&amp;lt;allow-intent href=&amp;#34;mailto:*&amp;#34; /&amp;gt;
&amp;lt;allow-intent href=&amp;#34;geo:*&amp;#34; /&amp;gt;
&amp;lt;platform name=&amp;#34;android&amp;#34;&amp;gt;
&amp;lt;allow-intent href=&amp;#34;market:*&amp;#34; /&amp;gt;
&amp;lt;/platform&amp;gt;
&amp;lt;platform name=&amp;#34;ios&amp;#34;&amp;gt;
&amp;lt;allow-intent href=&amp;#34;itms:*&amp;#34; /&amp;gt;
&amp;lt;allow-intent href=&amp;#34;itms-apps:*&amp;#34; /&amp;gt;
&amp;lt;/platform&amp;gt;
&amp;lt;!--Cordova插件声明--&amp;gt;
&amp;lt;feature name=&amp;#34;CordovaPluginsBridge&amp;#34;&amp;gt;
&amp;lt;param name=&amp;#34;ios-package&amp;#34; value=&amp;#34;CordovaPluginsBridge&amp;#34; /&amp;gt;
&amp;lt;param name=&amp;#34;onload&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt;
&amp;lt;/feature&amp;gt;
&amp;lt;/widget&amp;gt;
&lt;/code>&lt;/pre>&lt;p>(3)添加 www 文件夹一般来说会把静态资源文件放置到 www 目录下，这边有一个小点需要注意下(不知道是不是笔者搞错了)，就是将 www 文件夹引入到 XCode 中的时候，注意不要选择 Copy 而是 File Reference，即最终的文件夹应该是如下图所示的蓝色而不是黄色。&lt;/p>
&lt;h3 id="network-configuration">Network Configuration&lt;/h3>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="http://moduscreate.com/cordova-5-ios-9-security-policy-changes/" target="_blank" rel="noopener">cordova-5-ios-9-security-policy-changes&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>有时候在 iOS 中进行配置的时候会发现部分网络请求被 Ban，可以根据以下几个步骤进行排查。(1)判断 config.xml 中是否设置了网络请求的白名单，老实说现在 cordova-plugin-whitelist 这个插件都没有了 iOS 端，不确定这个是不是需要的。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!-- Allow images, xhrs, etc. to google.com --&amp;gt; &amp;lt;access origin=&amp;#34;http://google.com&amp;#34; /&amp;gt; &amp;lt;access origin=&amp;#34;https://google.com&amp;#34; /&amp;gt; &amp;lt;!-- Access to the subdomain maps.google.com --&amp;gt; &amp;lt;access origin=&amp;#34;http://maps.google.com&amp;#34; /&amp;gt; &amp;lt;!-- Access to all the subdomains on google.com --&amp;gt; &amp;lt;access origin=&amp;#34;http://*.google.com&amp;#34; /&amp;gt; &amp;lt;!-- Enable requests to content: URLs --&amp;gt; &amp;lt;access origin=&amp;#34;content:///*&amp;#34; /&amp;gt; &amp;lt;!-- Don&amp;#39;t block any requests --&amp;gt; &amp;lt;access origin=&amp;#34;*&amp;#34; /&amp;gt;
&lt;/code>&lt;/pre>&lt;p>(2)在 iOS 9 之后默认是不允许非 HTTPs 的请求发出，所以要修改下配置允许发起 HTTP 请求。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://i.stack.imgur.com/nGw3j.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;key&amp;gt;NSAppTransportSecurity&amp;lt;/key&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;NSAllowsArbitraryLoads&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt;
&lt;/code>&lt;/pre>&lt;p>(3)检查下 Content Security Policy Content Security Policy 一般用于对于网页内容的控制，不过这东西如果禁止了你访问网络，那么在浏览器内也是看得出来的。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!-- Good default declaration: * gap: is required only on iOS (when using UIWebView) and is needed for JS-&amp;gt;native communication * https://ssl.gstatic.com is required only on Android and is needed for TalkBack to function properly * Disables use of eval() and inline scripts in order to mitigate risk of XSS vulnerabilities. To change this: * Enable inline JS: add &amp;#39;unsafe-inline&amp;#39; to default-src * Enable eval(): add &amp;#39;unsafe-eval&amp;#39; to default-src --&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Security-Policy&amp;#34; content=&amp;#34;default-src &amp;#39;self&amp;#39; data: gap: https://ssl.gstatic.com; style-src &amp;#39;self&amp;#39; &amp;#39;unsafe-inline&amp;#39;; media-src *&amp;#34;&amp;gt; &amp;lt;!-- Allow everything but only from the same origin and foo.com --&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Security-Policy&amp;#34; content=&amp;#34;default-src &amp;#39;self&amp;#39; foo.com&amp;#34;&amp;gt; &amp;lt;!-- This policy allows everything (eg CSS, AJAX, object, frame, media, etc) except that * CSS only from the same origin and inline styles, * scripts only from the same origin and inline styles, and eval() --&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Security-Policy&amp;#34; content=&amp;#34;default-src *; style-src &amp;#39;self&amp;#39; &amp;#39;unsafe-inline&amp;#39;; script-src &amp;#39;self&amp;#39; &amp;#39;unsafe-inline&amp;#39; &amp;#39;unsafe-eval&amp;#39;&amp;#34;&amp;gt; &amp;lt;!-- Allows XHRs only over HTTPS on the same domain. --&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Security-Policy&amp;#34; content=&amp;#34;default-src &amp;#39;self&amp;#39; https:&amp;#34;&amp;gt; &amp;lt;!-- Allow iframe to https://cordova.apache.org/ --&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Security-Policy&amp;#34; content=&amp;#34;default-src &amp;#39;self&amp;#39;; frame-src &amp;#39;self&amp;#39; https://cordova.apache.org&amp;#34;&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="plugins">Plugins&lt;/h2>
&lt;h3 id="config">Config&lt;/h3>
&lt;p>任何一个插件首先需要在 config.xml 中进行注册：&lt;/p>
&lt;pre tabindex="0">&lt;code> &amp;lt;feature name=&amp;#34;CordovaPluginsBridge&amp;#34;&amp;gt; &amp;lt;param name=&amp;#34;ios-package&amp;#34; value=&amp;#34;Echo&amp;#34; /&amp;gt; &amp;lt;param name=&amp;#34;onload&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/feature&amp;gt;
&lt;/code>&lt;/pre>&lt;p>有沒有指定插件的初始值設定項。相反，應使用插件 pluginInitialize 為其啟動邏輯方法。插件需要長時間運行的請求，如媒體重播、聽眾，保持內部狀態應執行的背景活動 onReset 方法來清理這些活動。在方法運行時 UIWebView 定位到新的一頁或刷新，重新載入 JavaScript。&lt;/p>
&lt;h3 id="js-modules">JS Modules&lt;/h3>
&lt;p>关于 JS 部分的详细配置可以参考官方的 JS Modules 部分，这里不做赘述，仅展示下基本的用法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">echo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">callback&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">cordova&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exec&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">callback&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">callback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Nothing to echo.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;CordovaPluginsBridge&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;echo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nx">str&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">echo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;echome&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">echoValue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">alert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">echoValue&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;echome&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// should alert true.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要注意，一般对于 Cordova 的调用要放到 jQuery 的&lt;code>$(document).ready()&lt;/code>中。&lt;/p>
&lt;h3 id="ios-本地方法">iOS 本地方法&lt;/h3>
&lt;p>JavaScript 調用觸發插件請求到本機的一邊，和相應的 iOS 目標 C 插件映射正確地在 config.xml 檔中，但最後 iOS 目標 C 插件類看起來像什麼？ 無論派往與 JavaScript 的插件 exec 函數傳遞到相應的插件類的 action 方法。插件的方法有此簽名：&lt;/p>
&lt;pre tabindex="0">&lt;code> - (void)myMethod:(CDVInvokedUrlCommand*)command { CDVPluginResult* pluginResult = nil; NSString* myarg = [command.arguments objectAtIndex:0]; if (myarg != nil) { pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK]; } else { pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@&amp;#34;Arg was null&amp;#34;]; } [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId]; }
&lt;/code>&lt;/pre>&lt;h4 id="ios-cdvpluginresult-訊息類型">iOS CDVPluginResult 訊息類型&lt;/h4>
&lt;p>您可以使用 &lt;code>CDVPluginResult&lt;/code> 來返回結果的多種類型回 JavaScript 回呼函數，使用類的方法，它們遵循這種模式：&lt;/p>
&lt;pre tabindex="0">&lt;code> + (CDVPluginResult*)resultWithStatus:(CDVCommandStatus)statusOrdinal messageAs...
&lt;/code>&lt;/pre>&lt;p>您可以創建 &lt;code>String&lt;/code>，&lt;code>Int&lt;/code>，&lt;code>Double&lt;/code>，&lt;code>Bool&lt;/code>，&lt;code>Array&lt;/code>，&lt;code>Dictionary&lt;/code>，&lt;code>ArrayBuffer&lt;/code>，和 &lt;code>Multipart&lt;/code> 類型。你可以也離開了任何參數來發送狀態，或返回錯誤，或甚至選擇不發送任何外掛程式的結果，在這種情況下既不回撥火。&lt;/p>
&lt;p>請注意以下複雜的傳回值為：&lt;/p>
&lt;ul>
&lt;li>&lt;code>messageAsArrayBuffer&lt;/code>預計 &lt;code>NSData*&lt;/code> 並將轉換為 &lt;code>ArrayBuffer&lt;/code> 在 JavaScript 回檔。同樣，任何 &lt;code>ArrayBuffer&lt;/code> JavaScript 發送到一個外掛程式都將轉換為&lt;code>NSData*&lt;/code>.&lt;/li>
&lt;li>&lt;code>messageAsMultipart&lt;/code>預計，&lt;code>NSArray*&lt;/code> 包含任何其他支援類型，並將發送整個陣列作為 &lt;code>arguments&lt;/code> 給您的 JavaScript 回檔。這種方式，所有參數在序列化或反序列化作為必要的所以它是能夠安全返回 &lt;code>NSData*&lt;/code> 作為多部分，但不是 &lt;code>Array&lt;/code> /&lt;code>Dictionary&lt;/code>.
&lt;h4 id="异步执行">异步执行&lt;/h4>
如果对于部分执行时间较长的代码，可以放在后台进程中执行。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code> - (void)myPluginMethod:(CDVInvokedUrlCommand*)command
{
// Check command.arguments here.
[self.commandDelegate runInBackground:^{
NSString* payload = nil;
// Some blocking logic...
CDVPluginResult* pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:payload];
// The sendPluginResult method is thread-safe.
[self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];
}];
}
&lt;/code>&lt;/pre></description></item></channel></rss>