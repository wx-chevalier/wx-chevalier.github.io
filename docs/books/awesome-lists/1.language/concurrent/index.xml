<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concurrent | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/</link><atom:link href="https://ng-tech.icu/books/awesome-lists/1.language/concurrent/index.xml" rel="self" type="application/rss+xml"/><description>Concurrent</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Concurrent</title><link>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/</link></image><item><title>ConcurrentIO-List</title><link>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/concurrentio-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/concurrentio-list/</guid><description>&lt;h1 id="concurrent-io">Concurrent IO&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://www.importnew.com/24794.html" target="_blank" rel="noopener">2017-epoll 浅析以及 nio 中的 Selector&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://eli.thegreenplace.net/2017/concurrent-servers-part-1-introduction/" target="_blank" rel="noopener">2017-Concurrent Servers #Series#&lt;/a>: This is the first post in a series about concurrent network servers. My plan is to examine several popular concurrency models for network servers that handle multiple clients simultaneously, and judge those models on scalability and ease of implementation. All servers will listen for socket connections and implement a simple protocol to interact with clients.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>ConcurrentModel-List</title><link>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/concurrentmodel-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/concurrentmodel-list/</guid><description>&lt;h1 id="concurrent-model-list">Concurrent Model List&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/s-hironobu/AlgorithmCollection" target="_blank" rel="noopener">AlgorithmCollection
&lt;img src="https://martrix-usa.oss-accelerate.aliyuncs.com/logo/code.svg" style="max-width: 100px;display: inline-flex;"/>&lt;/a>: An Educational parallel Algorithm collection&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/atemerev/skynet" target="_blank" rel="noopener">Skynet
&lt;img src="https://martrix-usa.oss-accelerate.aliyuncs.com/logo/code.svg" style="max-width: 100px;display: inline-flex;"/>&lt;/a>: Skynet 1M concurrency microbenchmark&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="message-queue">Message Queue&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="http://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">Disruptor&lt;/a>: The Disruptor is the result of our research and testing. We found that cache misses at the CPU-level, and locks requiring kernel arbitration are both extremely costly, so we created a framework which has &amp;ldquo;mechanical sympathy&amp;rdquo; for the hardware it&amp;rsquo;s running on, and that&amp;rsquo;s lock-free.&lt;/li>
&lt;/ul>
&lt;h1 id="actor">Actor&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/vlingo/vlingo-actors" target="_blank" rel="noopener">2019-vlingo-actors
&lt;img src="https://martrix-usa.oss-accelerate.aliyuncs.com/logo/code.svg" style="max-width: 100px;display: inline-flex;"/>&lt;/a>: The vlingo/PLATFORM type safe Actor Model toolkit for reactive concurrency and resiliency using Java and other JVM languages.&lt;/li>
&lt;/ul></description></item><item><title>ConcurrentProgramming-List</title><link>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/concurrentprogramming-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-lists/1.language/concurrent/concurrentprogramming-list/</guid><description>&lt;h1 id="concurrent-learning--practices-list">Concurrent Learning &amp;amp; Practices List&lt;/h1>
&lt;h1 id="overview">Overview&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://tutorials.jenkov.com/java-concurrency/amdahls-law.html" target="_blank" rel="noopener">2015-Amdahl&amp;rsquo;s Law&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.risingstack.com/concurrency-and-parallelism-understanding-i-o/" target="_blank" rel="noopener">2016-Concurrency and Parallelism: Understanding IO&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://yq.aliyun.com/articles/72365" target="_blank" rel="noopener">2017-Go 语言并发机制初探&lt;/a>：Go 语言一个很大的优势就是可以方便地编写并发程序。Go 语言内置了 goroutine 机制，使用 goroutine 可以快速地开发并发程序，Go 语言的并发机制有很多值得探讨的，比如 Go 语言和 Scala 并发实现的不同，Golang CSP 和 Actor 模型的对比等，了解并发机制的这些实现，可以帮助我们更好的进行并发程序的开发，实现性能的最优化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/BRpngTEFHjzpGv8tkdqmPQ" target="_blank" rel="noopener">2017-工作线程数究竟要设置为多少&lt;/a>：Web Server 通常有个配置，最大工作线程数，后端服务一般也有个配置，工作线程池的线程数量，这个线程数的配置不同的业务架构师有不同的经验值，有些业务设置为 CPU 核数的 2 倍，有些业务设置为 CPU 核数的 8 倍，有些业务设置为 CPU 核数的 32 倍。“工作线程数”的设置依据是什么，到底设置为多少能够最大化 CPU 性能，是本文要讨论的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.csdn.net/article/2015-03-16/2824221" target="_blank" rel="noopener">夏俊：深入网站服务端技术(一)——网站并发的问题&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;amp;mid=2659598379&amp;amp;idx=1&amp;amp;sn=39d432e1d2f2c07254157e621bc50f01&amp;amp;chksm=8be99539bc9e1c2f892fcc89089c939d70361d1ba1fb584ce69ab68240eb35e6846f3c14bd6b&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1028Z0atSJuHV9dRSZdjogqo#rd" target="_blank" rel="noopener">抛开语言和技术栈不谈，我们应该如何选择线程模型？ &lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f" target="_blank" rel="noopener">2018-Why goroutines are not lightweight threads?&lt;/a>: Concurrency has existed since long ago in the form of Threads which are used in almost all the applications these days.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="concurrent-primitive">Concurrent Primitive&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/" target="_blank" rel="noopener">2018-Why you can have millions of goroutines but only thousands of Java threads&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="asynchronous-pattern">Asynchronous Pattern&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="http://cs.brown.edu/courses/cs168/s12/handouts/async.pdf" target="_blank" rel="noopener">CS168-Introduction to Asynchronous Programming&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>