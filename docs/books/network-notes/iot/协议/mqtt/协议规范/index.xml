<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>协议规范 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/</link><atom:link href="https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/index.xml" rel="self" type="application/rss+xml"/><description>协议规范</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>协议规范</title><link>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/</link></image><item><title>01.基本概念</title><link>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;h1 id="基本概念">基本概念&lt;/h1>
&lt;h1 id="mqtt-协议的通信模型">MQTT 协议的通信模型&lt;/h1>
&lt;p>MQTT 的通信是通过发布/订阅的方式来实现的，订阅和发布又是基于主题（Topic）的。发布方和订阅方通过这种方式来进行解耦，它们没有直接地连接，它们需要一个中间方。在 MQTT 里面我们称之为 Broker，用来进行消息的存储和转发。一次典型的 MQTT 消息通信流程如下所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/63a3c3feb1fccdcd3652e2a3.jpg" alt="MQTT 通信模型" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>发布方（Publisher）连接到 Broker；&lt;/li>
&lt;li>订阅方（Subscriber）连接到 Broker，并订阅主题 Topic1；&lt;/li>
&lt;li>发布方（Publisher）发送给 Broker 一条消息，主题为 Topic1；&lt;/li>
&lt;li>Broker 收到了发布方的消息，发现订阅方（Subscriber）订阅了 Topic1，然后将消息转发给订阅方（Subscriber）；&lt;/li>
&lt;li>订阅方从 Broker 接收该消息；&lt;/li>
&lt;/ul>
&lt;p>MQTT 通过订阅与发布模型对消息的发布方和订阅方进行解耦后，发布方在发布消息时并不需要订阅方也连接到 Broker，只要订阅方之前订阅过相应主题，那么它在连接到 Broker 之后就可以收到发布方在它离线期间发布的消息。我们可以称这种消息为离线消息。&lt;/p>
&lt;p>在该通信模型中，有两组身份需要区别：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一组是发布方 Publisher 和订阅方 Subscriber：publisher 和 subscriber 是相对于 Topic 来说的身份，如果一个 Client 向某个 Topic 发布消息，那么这个 Client 就是 publisher；如果一个 Client 订阅了某个 Topic，那么它就是 Subscriber。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一组是发送方 Sender 和接收方 Receiver：Sender 和 Receiver 则是相对于消息传输方向的身份。当 publisher 向 Broker 发送消息时，那么此时 publisher 是 sender，Broker 是 receiver；当 Broker 转发消息给 subscriber 时，此时 Broker 是 sender，subscriber 是 receiver。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="mqtt-客户端">MQTT 客户端&lt;/h2>
&lt;p>一个使用 MQTT 协议的设备、应用程序等，它总是建立到服务器的网络连接。&lt;/p>
&lt;ul>
&lt;li>可以发布信息，其他客户端可以订阅该信息&lt;/li>
&lt;li>订阅其它客户端发布的消息&lt;/li>
&lt;li>退订或删除应用程序的消息&lt;/li>
&lt;li>断开与服务器连接&lt;/li>
&lt;/ul>
&lt;p>Publisher 和 Subscriber 都属于 Client，Pushlisher 或者 Subscriber 只取决于该 Client 当前的状态——是在发布消息还是在订阅消息。当然，一个 Client 可以同时是 Publisher 和 Subscriber。client 的范围很广，任何终端、嵌入式设备、服务器只要运行了 MQTT 的库或者代码，都可以称为 MQTT Client。MQTT Client 库很多语言都有实现，可以在这个网址中找到：MQTT Client 库大全&lt;/p>
&lt;h2 id="mqtt-服务器">MQTT 服务器&lt;/h2>
&lt;p>MQTT 服务器以称为 Broker（消息代理），是一个应用程序或一台设备。它是位于消息发布者 和订阅者之间。&lt;/p>
&lt;ul>
&lt;li>接受来自客户端的网络连接&lt;/li>
&lt;li>接受客户端发布的应用信息&lt;/li>
&lt;li>处理来自客户端的订阅和退订请求&lt;/li>
&lt;li>向订阅的客户转发应用程序消息&lt;/li>
&lt;/ul>
&lt;h2 id="主题topic">主题（Topic）&lt;/h2>
&lt;p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。&lt;/p>
&lt;ul>
&lt;li>要订阅的主题。一个主题可以有多个级别，级别之间用斜杠字符分隔。例如/world 和 emq/emqtt/emqx 是有效的主题。&lt;/li>
&lt;li>订阅者的 Topic name 支持通配符 &lt;code>#&lt;/code> 和 &lt;code>+&lt;/code>：&lt;code>#&lt;/code> 支持一个主题内任意级别话题，&lt;code>+&lt;/code> 只匹配一个主题级别的通配符。&lt;/li>
&lt;li>客户端成功订阅某个主题后，代理会返回一条 SUBACK 消息，其中包含一个或多个 returnCode 参数。&lt;/li>
&lt;/ul>
&lt;p>MQTT 还支持主题筛选器（Topic Filter），一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。&lt;/p>
&lt;h2 id="qos消息传递的服务质量水平">QoS（消息传递的服务质量水平）&lt;/h2>
&lt;p>服务质量，标志表明此主题范围内的消息传送到客户端所需的一致程度。&lt;/p>
&lt;ul>
&lt;li>值 0：不可靠，消息基本上仅传送一次，如果当时客户端不可用，则会丢失该消息。&lt;/li>
&lt;li>值 1：消息应传送至少 1 次。&lt;/li>
&lt;li>值 2：消息仅传送一次。&lt;/li>
&lt;/ul>
&lt;h2 id="会话session">会话（Session）&lt;/h2>
&lt;p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。&lt;/p>
&lt;h2 id="订阅subscription">订阅（Subscription）&lt;/h2>
&lt;p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>客户端在成功建立 TCP 连接之后，发送 CONNECT 消息，在得到服务器端授权允许建立彼此连接的 CONNACK 消息之后，客户端会发送 SUBSCRIBE 消息，订阅感兴趣的 Topic 主题列表（至少一个主题）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>订阅的主题名称采用 UTF-8 编码，然后紧跟着对应的 QoS 值&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="发布publish">发布（publish）&lt;/h2>
&lt;p>控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息，MQTT 客户端发送消息请求，发送完成后返回应用程序线程。比如安卓的推送服务，还有一些即时通信软件如微信等也是采用的推送技术。&lt;/p></description></item><item><title>02.报文协议</title><link>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/02.%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/02.%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/</guid><description>&lt;h1 id="mqtt-协议原理">MQTT 协议原理&lt;/h1>
&lt;p>MQTT 3（当前版本 3.1.1）是目前使用的最为广泛的 MQTT 协议标准。尽管 MQTT5 标准已经发布，并且带来了一些令人振奋的新特性，但是在整个应用场景上，从后台服务到消息中间件再到客户端 SDK 等环节上的产品升级并没有都完成，再加上既有部署的维护，业界从版本 3 到 5 的过渡可能会持续相当长一段时间。&lt;/p>
&lt;p>在一个 MQTT 协议中有三个角色会参与到整个通信过程，发布者（publisher）、代理（broker）和订阅者（subscriber）。有别于传统的客户端/服务器通讯协议，MQTT 协议并不是端到端的，消息传递通过代理，包括会话（session）也不是建立在发布者和订阅者之间，而是建立在端和代理之间。代理解除了发布者和订阅者之间的耦合。除了发布者和订阅者之间传递普通消息，代理还可以为发布者处理保留消息和遗愿消息，并可以更改服务质量（QoS）等级。&lt;/p>
&lt;h1 id="mqtt-控制报文">MQTT 控制报文&lt;/h1>
&lt;p>MQTT 协议工作在 TCP 之上，端和代理之间通过交换预先定义的控制报文来完成通信。MQTT 报文有 3 个部分组成，并按下表顺序出现：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">固定报头（fixed header）&lt;/th>
&lt;th style="text-align:left">可变报头（variable header）&lt;/th>
&lt;th style="text-align:left">荷载（payload）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">所有报文都包含&lt;/td>
&lt;td style="text-align:left">部分报文包含&lt;/td>
&lt;td style="text-align:left">部分报文包含&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>固定头（Fixed header）：存在于所有的 MQTT 数据包中，用于表示数据包类型及对应标志、数据包大小等；&lt;/li>
&lt;li>可变头（Variable header）：存在于部分类型的 MQTT 数据包中，具体内容是由相应类型的数据包决定的；&lt;/li>
&lt;li>消息体（Payload）：存在于部分的 MQTT 数据包中，存储消息的具体数据。&lt;/li>
&lt;/ul>
&lt;h1 id="固定头">固定头&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/63a3c6c0b1fccdcd36573f0f.jpg" alt="固定头格式" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>固定头的第一个字节的高 4 位 Bit 用于表示该数据包的类型。MQTT 的数据包有以下一些类型：&lt;/p>
&lt;p>名称值方向描述 Reserved0 不可用保留位 CONNECT1Client 到 BrokerClient 请求连接到 BrokerCONNACK2Broker 到 Client 连接确认 PUBLISH3 双向发布消息 PUBACK4 双向发布确认 PUBREC5 双向发布收到 PUBREL6 双向发布释放 PUBCOMP7 双向发布完成 SUBSCRIBE8Client 到 BrokerClient 请求订阅 SUBACK9Broker 到 Client 订阅确认 UNSUBSCRIBE10Client 到 BrokerClient 请求取消订阅 UNSUBACK11Broker 到 Client 取消订阅确认 PINGREQ12Client 到 BrokerPING 请求 PINGRESP13Broker 到 ClientPING 应答 DISCONNECT14Client 到 BrokerClient 主动中断连接 Reserved15 不可用保留位&lt;/p>
&lt;p>低 4 位 Bit 则用于表示数据包的 Flag，不同的数据包类型，Flag 的定义不同，每种数据包对应的 Flag 如下：&lt;/p>
&lt;p>数据包标识位 Bit 3Bit 2Bit 1Bit 0CONNECT 保留位 0000CONNACK 保留位 0000PUBLISHMQTT 3.1.1 使用 DUPQoSQoSRETAINPUBACK 保留位 0000PUBREC 保留位 0000PUBREL 保留位 0000PUBCOMP 保留位 0000SUBSCRIBE 保留位 0000SUBACK 保留位 0000UNSUBSCRIBE 保留位 0000UNSUBACK 保留位 0000PINGREQ 保留位 0000PINGRESP 保留位 0000DISCONNECT 保留位 0000&lt;/p>
&lt;p>从固定头的第 2 字节开始是用于表示 MQTT 数据包剩余长度的字段，最少一个字节，最大四个字节。每一个字节的低 7 位用于标识值，范围为 0~127。最高的 1 位是标识位，用来说明是否有后续字节来标识长度。标识为 0，代表没有后续字节；标识为 1，代表后续还有一个字节用于标识包的长度。MQTT 协议相应字节数对应的最小、最大包长度如下表所示：&lt;/p>
&lt;p>字节数最小包长度（除固定头外）最大包长度（除固定头外）10 字节（0x00）127 字节（0x7F）2128 字节（0x80,0x01）16 383 字节（0xFF,0x7F）316 384 字节（0x80,0x80,0x01）2 097 151 字节（0xFF,0xFF,0x7F）42 097 152 字节（0x80,0x80,0x80,0x01）268 435 455 字节（0xFF,0xFF,0xFF,0x7F）。可知 MQTT 协议中数据包（除固定头外）的最大长度为 268435455 字节，约 256M。&lt;/p>
&lt;h2 id="报文种类">报文种类&lt;/h2>
&lt;p>1.连接请求（CONNECT）：当一个从客户端到服务器的 TCP/IP 套接字连接被建立时，必须用一个连接流来创建一个协议级别的会话。&lt;/p>
&lt;p>2.连接请求确认（CONNECTACK）：连接请求确认报文（CONNECTACK）是服务器发给客户端，用以确认客户端的连接请求&lt;/p>
&lt;p>3.发布报文（PUBLISH）：客户端发布报文到服务器端，用来提供给有着不同需求的订阅者们。每个发布的报文都有一个主题，这是一个分层的命名空间，他定义了报文来源分类，方便订阅者订阅他们需要的主题。订阅者们可以注册自己的需要的报文类别。&lt;/p>
&lt;p>4.发布确认报文（PUBACK）：发布确认报文（PUBACK）是对服务质量级别为 1 的发布报文的应答。他可以是服务器对发布报文的客户端的报文确认，也可以是报文订阅者对发布报文的服务器的应答。&lt;/p>
&lt;p>5.发布确认报文（PUBREC）：PUBREC 报文是对服务质量级别为 2 的发布报文的应答。这是服务质量级别为 2 的协议流的第二个报文。PUBREC 是由服务器端对发布报文的客户端的应答，或者是报文订阅者对发布报文的服务器的应答。&lt;/p>
&lt;p>6.发布确认报文（PUBREL)：PUBREL 是报文发布者对来自服务器的 PUBREC 报文的确认，或者是服务器对来自报文订阅者的 PUBREC 报文的确认。它是服务质量级别为 2 的协议流的第三个报文。&lt;/p>
&lt;p>7.确定发布完成（PUBCOMP）：PUBCOMP 报文是服务器对报文发布者的 PUBREL 报文的应答，或者是报文订阅者对服务器的 PUBREL 报文的应答。它是服务质量级别为 2 的协议流的第四个也是最后一个报文。&lt;/p>
&lt;p>8.订阅命名的主题（SUBSCRIBE）：订阅报文（SUBSCRIBE）允许一个客户端在服务器上注册一个或多个感兴趣的主题名字。发布给这些主题的报文作为发布报文从服务器端交付给客户端。订阅报文也描述了订阅者想要收到的发布报文的服务质量等级。&lt;/p>
&lt;p>9.订阅报文确认（SUBACK）：当服务器收到客户端发来的订阅报文时，将发送订阅报文的确认报文给客户端。一个这样的确认报文包含一列被授予的服务质量等级。被授予的服务质量等级次序和对应的订阅报文中的主题名称的次序相符。&lt;/p>
&lt;p>10.退订命名的主题(UNSUBSCRIBE)：退订主题的报文是从客户端发往服务器端，用以退订命名的主题。&lt;/p>
&lt;p>11.退订确认（UNSUBACK）：退订确认报文是从服务器发往客户端，用以确认客户端发来的退订请求报文。&lt;/p>
&lt;p>12.Ping 请求（PINGREQ）&lt;/p>
&lt;p>Ping 请求报文是从连接的客户端发往服务器端，用来询问服务器端是否还存在。&lt;/p>
&lt;p>13.Ping 应答（PINGRESP）：Ping 应答报文是从服务器端发往 Ping 请求的客户端，对客户端的 Ping 请求进行确认。&lt;/p>
&lt;p>14.断开通知（DISCONNECT）：断开通知报文是从客户端发往服务器端用来指明将要关闭它的 TCP/IP 连接，他允许彻底地断开，而非只是下线。如果客户端已经和干净会话标志集联系，那么所有先前关于客户端维护的信息将被丢弃。一个服务器在收到断开报文之后，不能依赖客户端关闭 TCP/IP 连接。&lt;/p>
&lt;h1 id="可变头">可变头&lt;/h1>
&lt;p>可变报文头主要包含协议名、协议版本、连接标志（Connect Flags）、心跳间隔时间（Keep Alive timer）、连接返回码（Connect Return Code）、主题名（Topic Name）等，后面会针对此部分进行具体讲解。&lt;/p>
&lt;h1 id="消息体">消息体&lt;/h1>
&lt;p>当 MQTT 发送的消息类型是 CONNECT（连接）、PUBLISH（发布）、SUBSCRIBE（订阅）、SUBACK（订阅确认）、UNSUBSCRIBE（取消订阅）时，则会带有负荷。&lt;/p></description></item><item><title>03.连接与断开</title><link>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/03.%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/03.%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%96%AD%E5%BC%80/</guid><description>&lt;h1 id="mqtt-的连接过程">MQTT 的连接过程&lt;/h1>
&lt;p>Client 建立到 Broker 的连接过程如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/63a3c846b1fccdcd3659f9ed.jpg" alt="Client 连接到 Broker" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>Client 发送 CONNECT 数据包给 Broker&lt;/li>
&lt;li>Broker 在收到 CONNECT 数据包之后，给 Client 返回一个 CONNACK 数据包&lt;/li>
&lt;/ul>
&lt;h2 id="connect-数据包">CONNECT 数据包&lt;/h2>
&lt;p>连接的建立由 Client 发起，Client 端首先向 Broker 发送一个 CONNECT 数据包，CONNECT 数据包包含以下内容。&lt;/p>
&lt;h3 id="可变头">可变头&lt;/h3>
&lt;p>在 CONNECT 数据包可变头中，包含以下信息：&lt;/p>
&lt;ul>
&lt;li>协议名称（Protocol Name）：值固定为字符 “MQTT”。&lt;/li>
&lt;li>协议版本（Protocol Level）：对 MQTT 3.1.1 来说，该值为 4。&lt;/li>
&lt;li>用户名标识（User Name Flag）：消息体中是否有用户名字段，1bit，0 或者 1。&lt;/li>
&lt;li>密码标识（Password Flag）：消息体中是否有密码字段，1bit，0 或者 1。&lt;/li>
&lt;li>遗愿消息 Retain 标识（Will Retain）：标识遗愿消息是否是 Retain 消息，1bit，0 或者 1。&lt;/li>
&lt;li>遗愿消息 QOS 标识（Will QOS）：标识遗愿消息的 QOS，2bit，0、1 或者 2。&lt;/li>
&lt;li>遗愿标识（Will Flag）：标识是否使用遗愿消息，1bit，0 或者 1。&lt;/li>
&lt;li>会话清除标识（Clean Session）：标识 Client 是否建立一个持久化的会话，1bit，0 或者 1。当该标识设为 0 时，代表 Client 希望建立一个持久会话的连接，Broker 将存储该 Client 订阅的主题和未接受的消息，否则 Broker 不会存储这些数据，同时在建立连接时清楚这个 Client 之前存在的持久化会话所保存的数据。&lt;/li>
&lt;li>连接保活（Keep Alive）：设置一个以秒为单位的时间间隔，Client 和 Broker 之间在这个时间间隔之内需要至少一次消息交互，否则 Client 和 Broker 会认为它们之间的连接已经断开。&lt;/li>
&lt;/ul>
&lt;h3 id="消息体">消息体&lt;/h3>
&lt;p>CONNECT 数据包的消息体中包含以下数据：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>客户端标识符（Client Identifier）：Client Identifier 是用来标识 Client 身份的字段，在 MQTT 3.1.1 的版本中，这个字段的长度是 1 到 23 个字节，而且只能包含数字和 26 个字母（包括大小写），Broker 通过这个字段来区分不同的 Client。所以在连接的时候，应该保证 Client Identifier 是唯一的，所以我们可以使用 UUID，唯一的设备硬件标识，或者在 Android 设备中使用的话，可以使用 DEVICE_ID 等作为 Client Identifier 的取值来源。MQTT 协议中要求 Client 连接时必须带上 Client Identifier，但是也允许 Broker 在 Client Identifier 为空时，会为 Client 分配一个内部唯一的 Identifier。如果需要持久化会话的话，那必须为 Client 设定一个唯一的 Identifier。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户名（Username）：如果可变头中的用户名标识设为 1，那么消息体中将包含用户名字段，Broker 可以使用用户名和密码来对接入的 Client 进行验证，只允许已授权的 Client 接入。注意不同的 Client 需要使用不同的 Client Identifier，但它们可以使用同样的用户名和密码进行连接。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>密码（Password）：如果可变头中的密码标识设为 1，那么消息体中将包含密码字段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>遗愿主题（Will Topic）：如果可变头中的遗愿标识设为 1，那么消息体中将包含遗愿主题，当 Client 非正常地中断连接的时候，Broker 将向指定的遗愿主题中发布遗愿消息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>遗愿消息（Will Message）：如果可变头中的遗愿标识设为 1，那么消息体中将包含遗愿消息，当 Client 非正常地中断连接的时候，Broker 将向指定的遗愿主题中发布由该字段指定的内容。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="connack-数据包">CONNACK 数据包&lt;/h2>
&lt;p>当 Broker 收到 Client 的 CONNECT 数据包之后，将检查并检验 CONNECT 数据包的内容，之后回复 Client 一个 CONNACK 数据包。CONNACK 数据包包含以下内容。&lt;/p>
&lt;h3 id="可变头-1">可变头&lt;/h3>
&lt;p>CONNACK 数据包的可变头中，包含以下信息：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>会话存在标识（Session Present Flag）&lt;/strong>：用于标识在 Broker 上是否已存在该 Client（用 Client Identifier 区分）的持久性会话，1bit，0 或者 1。当 Client 在连接时设置&lt;code>Clean Session=1&lt;/code>（会话清除标识见 CONNECT 数据包的可变头），则 CONNACK 中的&lt;code>Session Present Flag&lt;/code>始终为 0；当 Client 在连接时设置 &lt;code>Clean Session=0&lt;/code>，那么存在下面两种情况&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>如果 Broker 上面保留了这个 Client 之前留下的持久性会话，那么 CONNACK 中的&lt;code>Session Present Flag&lt;/code>值为 1；&lt;/li>
&lt;li>如果 Broker 上面没有保存这个 Client 之前留下的会话数据，那么 CONNACK 中的&lt;code>Session Present Flag&lt;/code>值为 0；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Session Present Flag 这个特性是在 MQTT3.1.1 版本中新加入的，之前的版本中没有这个标识&lt;/p>
&lt;ul>
&lt;li>&lt;strong>连接返回码（Connect Return code）&lt;/strong>：用于标识 Client 是 Broker 的连接是否建立成功，连接返回码有以下一些值：
Return code 连接状态 0 连接已经建立 1 连接被拒绝，不允许的协议版本 2 连接被拒绝，Client Identifier 被拒绝 3 连接被拒绝，服务器不可用 4 连接被拒绝，错误的用户名或密码 5 连接被拒绝，未授权&lt;code>Return code=2&lt;/code> 代表的是 Client Identifier 格式不规范，比如长度超过 23 个字符，包含了不允许的字符等（部分 Broker 的实现在协议标准上做了扩展，比如允许超过 23 个字符的 Client Identifer 等）
&lt;code>Return code=4&lt;/code>在 MQTT 协议中的含义是 Username 和 Password 的格式不正确，但是在大部分的 Broker 实现中，使用错误的用户名和密码时返回的也是 4,所以可以认为 4 表示就是错误的用户名或者密码；
&lt;code>Return code=5&lt;/code>一般表示 Broker 不使用用户名和密码验证而是采用 IP 地址或者 Client Identifier 进行认证的时候使用，来标识 Client 没有通过验证。&lt;/li>
&lt;/ul>
&lt;h3 id="消息头">消息头&lt;/h3>
&lt;p>CONNACK 没有消息体。综上所述当 Client 向 Broker 发送了 CONNECT 数据包并获得了 Return code 为 0 的 CONNACK 数据包后，则代表连接建立成功了。之后则可以进行消息的发布和订阅了。&lt;/p>
&lt;h1 id="mqtt-断开过程">MQTT 断开过程&lt;/h1>
&lt;p>MQTT 的断开过程分为以下两种：&lt;/p>
&lt;ul>
&lt;li>一种是 Client 主动关闭连接&lt;/li>
&lt;li>一种是 Broker 主动关闭连接&lt;/li>
&lt;/ul>
&lt;h2 id="client-主动关闭连接">Client 主动关闭连接&lt;/h2>
&lt;p>Client 主动关闭连接的流程非常简单，只需要 Client 向 Broker 发送一个 DISCONNECT 数据包就可以了。DISCONNECT 数据包没有可变头（Variable header）和消息体（Payload）。在 Client 发送完 DISCONNECT 之后，就可以关闭底层的 TCP 连接了，不需要等待 Broker 的回复（Broker 也不会对 DISCONNECT 数据包回复）。&lt;/p>
&lt;p>为什么 Client 关闭 TCP 连接之前，要发送一个和 Broker 没有交互的数据包，而不是关闭底层的 TCP 连接的？因为这涉及到 MQTT 协议的一个特性，在 MQTT 协议中，Broker 需要判断 Client 是否是正常的断开连接。当 Broker 收到 Client 的 DISCONNECT 数据包的时候，Broker 则认为 Client 是正常断开连接的，那么会丢弃当前连接指定的遗愿消息。如果 Broker 检测到 Client 连接丢失，但是又没有收到 DISCONNECT 数据包，则认为 Client 是非正常断开的，就会向在连接的时候指定的遗愿主题发布遗愿消息。&lt;/p>
&lt;h2 id="broker-主动关闭连接">Broker 主动关闭连接&lt;/h2>
&lt;p>MQTT 协议规定 Broker 在没有收到 Client 的 DISCONNECT 数据包之前都应该和 Client 保持连接。只有当 Broker 在 Keep Alive 的时间间隔内，没有收到 Client 的任何 MQTT 数据包的时候会主动关闭连接。一些 Broker 的实现在 MQTT 协议上做了一些拓展，支持 Client 的连接管理，可以主动和某个 Client 断开连接。&lt;/p>
&lt;p>Broker 主动关闭连接之前不会向 Client 发送任何 MQTT 数据包，而是直接关闭底层的 TCP 连接。&lt;/p>
&lt;h2 id="3-代码实践">3. 代码实践&lt;/h2>
&lt;p>下面使用 Python 的 paho mqtt 库来实现 MQTT 的连接，Broker 的话使用自己搭建的 mosquitto。&lt;/p>
&lt;h3 id="31-建立持久会话的连接">3.1. 建立持久会话的连接&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">收到Broker发来的CONNACK消息，就会执行on_connect()回调函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">打印出CONNACK数据包中的Connect Return code、Session Present Flag
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;return code:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;session present:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;session present&amp;#39;&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 通过client_id指定Client Identifier&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置clean_session为False表示要建立一个持久性会话&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">clean_session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将回调函数指派给客户端实例&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Python 代码之后，输出结果如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="k">return&lt;/span> code: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">session present: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>return code 为 0 表示连接已成功建立，因为&lt;code>demo_mqtt&lt;/code>的 Client 第一次建立，所以&lt;code>SessionPresent&lt;/code>为 0。再次运行，输出结果变成如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="k">return&lt;/span> code: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">session present: &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="32-建立非持久会话的连接">3.2. 建立非持久会话的连接&lt;/h3>
&lt;p>相比建立持久会话的连接的代码，只需要将&lt;code>clean_session&lt;/code>指定为了 True 即可建立一个非持久会话的连接了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">收到Broker发来的CONNACK消息，就会执行on_connect()回调函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">打印出CONNACK数据包中的Connect Return code、Session Present Flag
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;return code:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;session present:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;session present&amp;#39;&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 通过client_id指定Client Identifier&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置clean_session为True表示要建立一个非持久性的会话&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">clean_session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将回调函数指派给客户端实例&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行该代码，输出结果为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="k">return&lt;/span> code: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">session present: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且无论运行多少次，&lt;code>SessionPresent&lt;/code>都是为 0&lt;/p>
&lt;blockquote>
&lt;p>paho mqtt 的 Python 版本，默认&lt;code>clean_session&lt;/code>为 True&lt;/p>
&lt;/blockquote>
&lt;h3 id="33-使用相同的-client-identifier-进行连接">3.3. 使用相同的 Client Identifier 进行连接&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;return code:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;session present:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;session present&amp;#39;&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别在两个终端中运行上述同样的代码，那么两个终端中会不停打印如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="k">return&lt;/span> code: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">session present: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">return&lt;/span> code: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">session present: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">......
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为当两个 Client 中使用同样的 Client Identifie 进行连接时，那么第二个 Client 连接成功后，Broker 会关闭和第一个已经连接上的 Client 连接。然而因为我们使用了&lt;code>loop_forever()&lt;/code>函数，这个函数会一直阻塞，直到 Client 调用&lt;code>disconnect()&lt;/code>，并且这个函数会在断开后自动重连。所以当连接被 Broker 关闭时，它又会尝试重新连接，结果就是这两个 Client 交替地把对方顶下线，因此在使用中我们需要&lt;strong>保证每一个设备使用的 Client Identifier 是唯一的。&lt;/strong>&lt;/p></description></item><item><title>QoS</title><link>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/qos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/qos/</guid><description>&lt;h1 id="mqtt-的-qos-介绍">MQTT 的 QoS 介绍&lt;/h1>
&lt;h1 id="mqtt-中的-qos-等级">MQTT 中的 QoS 等级&lt;/h1>
&lt;p>MQTT 设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次 QoS（Quality of Service）：&lt;/p>
&lt;ul>
&lt;li>QoS0，At most once，至多一次；&lt;/li>
&lt;li>QoS1，At least once，至少一次；&lt;/li>
&lt;li>QoS2，Exactly once，确保只有一次。&lt;/li>
&lt;/ul>
&lt;p>QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：&lt;/p>
&lt;ul>
&lt;li>QoS0 代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；&lt;/li>
&lt;li>QoS1 代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息；&lt;/li>
&lt;li>QoS2 代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。&lt;/li>
&lt;/ul>
&lt;p>QoS 是 Sender 和 Receiver 之间的协议，而不是 Publisher 和 Subscriber 之间的协议。换句话说，Publisher 发布了一条 QoS1 的消息，只能保证 Broker 能至少收到一次这个消息；而对于 Subscriber 能否至少收到一次这个消息，还要取决于 Subscriber 在 Subscibe 的时候和 Broker 协商的 QoS 等级。&lt;/p>
&lt;h1 id="qos0">QoS0&lt;/h1>
&lt;p>QoS0 等级下，Sender 和 Receiver 之间一次消息的传递流程如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20221222145706.png" alt="QoS0 消息" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Sender 向 Receiver 发送一个包含消息数据的 PUBLISH 包，然后不管结果如何，丢掉已发送的 PUBLISH 包，一条消息的发送完成。&lt;/p>
&lt;h1 id="qos1">QoS1&lt;/h1>
&lt;p>QoS1 要保证消息至少到达一次，所以有一个应答的机制。Sender 和 Receiver 的一次消息的传递流程如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20221222150050.png" alt="QoS1 应答机制" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>Sender 向 Receiver 发送一个带有数据的 PUBLISH 包，并在本地保存这个 PUBLISH 包；&lt;/li>
&lt;li>Receiver 收到 PUBLISH 包以后，向 Sender 发送一个 PUBACK 数据包，PUBACK 数据包没有消息体（Payload），在可变头中有一个包标识（Packet Identifier），和它收到的 PUBLISH 包中的 Packet Identifier 一致。&lt;/li>
&lt;li>Sender 收到 PUBACK 之后，根据 PUBACK 包中的 Packet Identifier 找到本地保存的 PUBLISH 包，然后丢弃掉，一次消息的发送完成。&lt;/li>
&lt;/ol>
&lt;p>但是消息传递流程中可能会出现问题：&lt;/p>
&lt;ul>
&lt;li>如果 Sender 在一段时间内没有收到 PUBLISH 包对应的 PUBACK，它将该 PUBLISH 包的 DUP 标识设为 1（代表是重新发送的 PUBLISH 包），然后重新发送该 PUBLISH 包。&lt;/li>
&lt;li>Receiver 可能会重复收到消息，需自行去重。&lt;/li>
&lt;/ul>
&lt;h1 id="qos2">QoS2&lt;/h1>
&lt;p>相比 QoS0 和 QoS1,QoS2 不仅要确保 Receiver 能收到 Sender 发送的消息，还需要确保消息不重复。它的重传和应答机制就要复杂一些，同时开销也是最大的。QoS2 下，一次消息的传递流程如下所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20221222150524.png" alt="QoS2" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>Sender 发送 QoS 为 2 的 PUBLISH 数据包，数据包 Packet Identifier 为 P，并在本地保存该 PUBLISH 包；&lt;/li>
&lt;li>Receiver 收到 PUBLISH 数据包后，&lt;strong>在本地保存 PUBLISH 包的 Packet Identifier P&lt;/strong>，并回复 Sender 一个 PUBREC 数据包，PUBREC 数据包可变头中的 Packet Identifier 为 P，没有消息体（Payload）；&lt;/li>
&lt;li>当 Sender 收到 PUBREC，它就可以安全的丢弃掉初始 Packet Identifier 为 P 的 PUBLISH 数据包。同时保存该 PUBREC 数据包，并回复 Receiver 一个 PUBREL 数据包，PUBREL 数据包可变头中的 Packet Identifier 为 P，没有消息体；&lt;/li>
&lt;li>当 Receiver 收到 PUBREL 数据包，它可以丢掉保存的 PUBLISH 包的 Packet Identifier P，并回复 Sender 一个可变头中 Packet Identifier 为 P，没有消息体（Payload）的 PUBCOMP 数据包；&lt;/li>
&lt;li>当 Sender 收到 PUBCOMP 包，那么认为传输已完成，则丢掉对应的 PUBREC 数据包；&lt;/li>
&lt;/ol>
&lt;p>上面是一次完整无误的传输过程，然而传输过程中可能会出现以下情况：&lt;/p>
&lt;ul>
&lt;li>情况 1：Sender 发送 PUBLISH 数据包给 Receiver 的时候，发送失败；&lt;/li>
&lt;li>情况 2：Sender 已经成功发送 PUBLISH 数据包给 Receiver 了，但是 Receiver 发送 PUBREC 数据包失败；&lt;/li>
&lt;li>情况 3：Sender 已经成功收到了 PUBREC 数据包，但是 PUBREL 数据包发送失败；&lt;/li>
&lt;li>情况 4：Receiver 已经收到了 PUBREL 数据包，但是发送 PUBCOMP 数据包时发送失败&lt;/li>
&lt;/ul>
&lt;p>针对上述的问题，较为详细的处理方法如下：&lt;/p>
&lt;ul>
&lt;li>不管是情况 1 还是情况 2，因为 Sender 在一定时间内没有收到 PUBREC，那么它会把 PUBLISH 包的 DUP 标识设为 1，重新发送该 PUBLISH 数据包；&lt;/li>
&lt;li>不管是情况 3 还是情况 4，因为 Sender 在一定时间内没有收到 PUBCOMP 包，那么它会重新发送 PUBREL 数据包；&lt;/li>
&lt;li>针对情况 2，Receiver 可能会收到多个重复的 PUBLISH 包，更加完善的处理如下：
Receiver 在收到 PUBLISH 数据包之后，马上回复一个 PUBREC 数据包。并会在本地保存 PUBLISH 包的 Packet Identifier P，不管之后因为重传多少次这个 Packet Identifier 为 P 的数据包，Receiver 都认为是重复的，丢弃。同时 Receiver 接收到 QoS 为 2 的 PUBLISH 数据包后，**并不马上投递给上层，**而是在本地做持久化，将消息保存起来（这里需要是持久化而不是保存在内存）。&lt;/li>
&lt;li>针对情况 4，更加完善的处理如下：
Receiver 收到 PUBREL 数据包后，正式将消息递交给上层应用层，投递之后销毁 Packet Identifier P，并发送 PUBCOMP 数据包，销毁之前的持久化消息。之后不管接收到多少个 PUBREL 数据包，因为没有 Packet Identifier P，直接回复 PUBCOMP 数据包即可。&lt;/li>
&lt;/ul>
&lt;h1 id="qos-降级">QoS 降级&lt;/h1>
&lt;p>在 MQTT 协议中，从 Broker 到 Subscriber 这段消息传递的实际 QoS 等于：Publisher 发布消息时指定的 QoS 等级和 Subscriber 在订阅时与 Broker 协商的 QoS 等级，这两个 QoS 等级中的最小那一个。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Actual&lt;/span> &lt;span class="n">Subscribe&lt;/span> &lt;span class="n">QoS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">MIN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Publish&lt;/span> &lt;span class="n">QoS&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Subscribe&lt;/span> &lt;span class="n">QoS&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下面代码所示：该 subscriber 订阅消息时指定的 QoS 为 1&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">当代理响应订阅请求时被调用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">granted_qos&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;granted_qos:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">granted_qos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">当收到关于客户订阅的主题的消息时调用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_message&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;message qos&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">qos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;message topic&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">topic&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;message payload&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">payload&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;subscribing&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;connection failed &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt_sub&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">clean_session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_subscribe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_subscribe&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_message&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行上述代码输出的结果为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">subscribing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">granted_qos: &lt;span class="o">(&lt;/span>1,&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后运行下面的 publisher 代码，指定发送的 PUBLISH 数据包的 QoS 等级为 0&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">publish&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">payload&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">qos&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;connection failed &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt_pub&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">clean_session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果上面运行 subscriber 代码的终端输出如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">message qos &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">message topic &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">message payload b&lt;span class="s1">&amp;#39;hello world&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述的结果表示，订阅者收到的消息的 qos 等级为 0。同样如果修改 subscriber 中的订阅主题的 QoS 等级为 0，publisher 中发布的 PUBLISH 包的 QoS 为 1，那么输出结果同上。&lt;/p>
&lt;h1 id="qos-和会话">QoS 和会话&lt;/h1>
&lt;p>如果 Client 想接收离线消息，必须使用持久化的会话（Clean Session = 0）连接到 Broker，这样 Broker 才会存储 Client 在离线期间没有确认接收的 QoS 大于 等于 1 的消息。在发送 QoS 为 1 或 2 的情况，Broker（此时为 Sender）会将发送的 PUBLISH 数据包保存到本地，直到收到一系列回复的数据包，然而 Client（此时为 Receiver）在离线期间无法回复相应的数据包，所以会一直存储。&lt;/p>
&lt;h1 id="qos-等级使用建议">QoS 等级使用建议&lt;/h1>
&lt;p>&lt;strong>在以下情况下你可以选择 QoS0&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>Client 和 Broker 之间的网络连接非常稳定，例如一个通过有线网络连接到 Broker 的测试用 Client；&lt;/li>
&lt;li>可以接受丢失部分消息，比如你有一个传感器以非常短的间隔发布状态数据，所以丢一些也可以接受；&lt;/li>
&lt;li>你不需要离线消息。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在以下情况下你应该选择 QoS1：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>你需要接收所有的消息，而且你的应用可以接受并处理重复的消息；&lt;/li>
&lt;li>你无法接受 QoS2 带来的额外开销，QoS1 发送消息的速度比 QoS2 快很多。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在以下情况下你应该选择 QoS2：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>你的应用必须接收到所有的消息，而且你的应用在重复的消息下无法正常工作，同时你也能接受 QoS2 带来的额外开销。&lt;/li>
&lt;/ul></description></item><item><title>消息的发布和订阅</title><link>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/network-notes/iot/%E5%8D%8F%E8%AE%AE/mqtt/%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83/%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/</guid><description>&lt;h1 id="消息的发布和订阅">消息的发布和订阅&lt;/h1>
&lt;h1 id="mqtt-的发布">MQTT 的发布&lt;/h1>
&lt;p>MQTT 发布中最重要的是 PUBLISH 数据包，PUBLISH 数据包是用于 sender 和 receiver 之间传输消息数据的。当 Publisher 要向某个 Topic 发布一条消息的时候，Publisher 会向 Broker 发送一个 PUBLISH 数据包；当 Broker 要将一条消息转发给订阅了某条主题的 Subscriber 时，Broker 也会向该 Subscriber 发送一个 PUBLISH 数据包。因为 PUBLISH 传输过程中涉及到了 QoS，Recevier 收到 sender 的 PUBLISH 数据包之后会根据 QoS 的不同，还有后续不同的应答流程（只有当 QoS 为 0 时，Receiver 不做任何应答），所以关于这个具体的流程，在 QoS 那一章节进行讲述。下面对 PUBLISH 数据包进行讲解：&lt;/p>
&lt;h2 id="publish-数据包">PUBLISH 数据包&lt;/h2>
&lt;h3 id="固定头">固定头&lt;/h3>
&lt;p>PUBLISH 的固定头包含了一下内容：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>消息重复标识（DUP flag）&lt;/strong>：1bit，0 或者 1，当 DUP flag = 1 的时候，代表该消息是一条重发消息，因 Receiver 没有确认收到之前的消息而重新发送的。这个标识只在 QoS 大于 0 的消息中使用。&lt;/li>
&lt;li>&lt;strong>QoS&lt;/strong>：2bit，0、1 或者 2，代表 PUBLISH 消息的 QoS level。&lt;/li>
&lt;li>&lt;strong>Retain 标识（Retain flag）&lt;/strong>：1bit，0 或者 1。在从 Client 发送到 Broker 的 PUBLISH 消息中被设为 1 的时候，Broker 应该保存该条消息，当之后有任何新的 Subscriber 订阅 PUBLISH 消息中指定的主题时，都会先收到该条消息，这种消息也叫 Retained 消息。在从 Broker 发送到 Client 的 PUBLISH 消息中被设为 1 的时候，代表该条消息是一条 Retained 消息。&lt;/li>
&lt;/ul>
&lt;h3 id="可变头">可变头&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>数据包标识（ Packet Identifier）&lt;/strong>：2 字节，用来标识一个唯一数据包。&lt;strong>数据包标识只需要保证在从 Sender 到 Receiver 的一次消息交互（比如发送、应答为一次交互）中保持唯一就好，只在 QoS 大于 1 的消息中使用&lt;/strong>，因为 QoS 大于 1 的消息有应答流程。&lt;/li>
&lt;li>&lt;strong>主题名称（Topic Name）&lt;/strong>：主题名称是一个 UTF-8 编码的字符串，用来命名该消息发布到哪一个主题，Topic Name 可以是长度大于等于 1 任何一个字符串（可包含空格）。但是在实际项目中，我们最好还是遵循以下一些最优方法。&lt;/li>
&lt;/ul>
&lt;h3 id="消息体">消息体&lt;/h3>
&lt;p>PUBLISH 数据包的消息体中包含的是该消息要发送的具体数据，数据可以是任何格式的：二进制数据、文本、JSON 等都可以。&lt;/p>
&lt;h1 id="mqtt-的订阅">MQTT 的订阅&lt;/h1>
&lt;p>订阅主题的流程如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/63a3d8d1b1fccdcd367a4cf3.jpg" alt="订阅流程" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>Client 向 Broker 发送一个 SUBSCRIBE 数据包，该数据包中含有 Client 想要订阅的主题和其他一些参数；&lt;/li>
&lt;li>Broker 收到 SUBSCRIBE 数据包后，向 Client 发送一个 SUBACK 数据包作为应答。&lt;/li>
&lt;/ul>
&lt;h2 id="subscribe-数据包">SUBSCRIBE 数据包&lt;/h2>
&lt;h3 id="可变头-1">可变头&lt;/h3>
&lt;p>数据包标识（Packet Identifier）：两个字节，用来唯一标识一个数据包，数据包标识只需要保证在从 Sender 到 Receiver 的一次消息交互中保持唯一。&lt;/p>
&lt;h3 id="消息体-1">消息体&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>订阅列表（List of Subscriptions）&lt;/strong>：SUBSCRIBE 的消息体中包含 Client 想要订阅的主题列表，列表中的每一项由订阅主题名和对应的 QoS 组成。
&lt;strong>主题名说明&lt;/strong>
主题名中可以包含通配符，单层通配符“+”和多层通配符“#”。使用包含通配符的主题名可以订阅满足匹配条件的所有主题。为了和 PUBLISH 中的主题区分，我们叫 SUBSCRIBE 中的主题名为主题过滤器（Topic Filter）。&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>单层通配符“+”&lt;/strong>：“+”可以用来指代任意一个层级。
举例：
如“sensor/+/tem”，可以匹配：&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>sensor/data/tem&lt;/li>
&lt;li>sensor/cmd/tem&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>不可以匹配：&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;p>sensor/data/01/tem&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>多层通配符“#”&lt;/strong>：“#”和“+”的区别在于，“#”可以用来指代任意多个层。**但是&amp;quot;#&amp;ldquo;必须是 Topic Filter 的最后一个字符，同时必须跟在“/“后面，除非 Topic Filter 只包含一个”#“这一个字符。**如“#”是一个合法的 Topic Filter，而“sensor#”不是一个合法的 Topic Filter。
举例：
如“sensor/data/#”，可匹配：&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>sensor/data&lt;/li>
&lt;li>sensor/data/tem&lt;/li>
&lt;li>sensor/data/tem/01&lt;/li>
&lt;li>sensor/data/tem/01/02&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>不可以匹配：&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>sensor/cmd/tem&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>SUBSCRIBE 数据包中 QoS 代表针对某一个或着某一组的主题，Client 希望 Broker 在转发来自这些主题的消息给它时，消息使用的 QoS 级别。&lt;/p>
&lt;h2 id="suback-数据包">SUBACK 数据包&lt;/h2>
&lt;p>为确认每一次的订阅，Broker 收到 SUBSCRIBE 之后会回复一个 SUBACK 数据包作为应答。SUBACK 数据包包含以下内容：&lt;/p>
&lt;h3 id="可变头-2">可变头&lt;/h3>
&lt;p>数据包标识（Packet Identifier）：两个字节，用来唯一标识一个数据包，数据包标识只需要保证在从 Sender 到 Receiver 的一次消息交互中保持唯一。&lt;/p>
&lt;h3 id="消息体-2">消息体&lt;/h3>
&lt;p>返回码（return codes）：SUBBACK 数据包包含了一组返回码，返回码的数量和顺序和 SUBSCRIBE 数据包的订阅列表对应，用于标识订阅类别中的每一个订阅项的订阅结果。&lt;/p>
&lt;p>返回码含义 0 订阅成功， 最大可用 QoS 为 01 订阅成功，最大可用 QoS 为 12 订阅成功， 最大可用 QoS 为 2128 订阅失败&lt;/p>
&lt;p>返回码 0~2 表示订阅成功，并且 Broker 授予 Subscriber 不同等级的 QoS，这个等级可能会和 SubScriber 在 SUBSCRIBE 数据包中要求的不一样。128 表示订阅失败，可能是没有权限订阅这个主题，或者订阅主题的格式不对。&lt;/p>
&lt;h1 id="mqtt-的取消订阅">MQTT 的取消订阅&lt;/h1>
&lt;p>Subscriber 也可以取消对某些主题的订阅，取消订阅的流程如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20221222142003.png" alt="MQTT 的取消订阅" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>Subscriber 向 Broker 发送一个 UNSUBSCRIBE 数据包，该数据包包含想要取消订阅的主题；&lt;/li>
&lt;li>Broker 收到 UNSUBSCRIBE 数据包之后，向 subscriber 发送一个 UNSUBACK 数据包作为应答。&lt;/li>
&lt;/ul>
&lt;h2 id="unsubscribe-数据包">UNSUBSCRIBE 数据包&lt;/h2>
&lt;h3 id="可变头-3">可变头&lt;/h3>
&lt;p>数据包标识（Packet Identifier）：两个字节，用来唯一标识一个数据包，数据包标识只需要保证在从 Sender 到 Receiver 的一次消息交互中保持唯一。&lt;/p>
&lt;h3 id="消息体-3">消息体&lt;/h3>
&lt;p>主题列表（List of Topics）：UNSUBSCRIBE 的消息体中包含 Client 想要取消订阅的主题过滤器列表，这些主题过滤器和 SUBSCRIBE 数据包中一样，可以包含通配符。UNSUBSCRIBE 消息体里面不再包含主题过滤器对应的 QoS 了。&lt;/p>
&lt;h2 id="unsuback-数据包">UNSUBACK 数据包&lt;/h2>
&lt;p>Broker 收到 UNSUBSCRIBE 数据包之后会回复一个 UNSUBACK 数据包作为应答。UNSUBACK 数据包内容如下：&lt;/p>
&lt;h3 id="可变头-4">可变头&lt;/h3>
&lt;p>数据包标识（Packet Identifier）：两个字节，用来唯一标识一个数据包，数据包标识只需要保证在从 Sender 到 Receiver 的一次消息交互中保持唯一。&lt;/p>
&lt;h3 id="消息体-4">消息体&lt;/h3>
&lt;p>UNSUBACK 数据包没有消息体。&lt;/p>
&lt;h2 id="4-代码实践">4. 代码实践&lt;/h2>
&lt;h3 id="41-发布消息">4.1. 发布消息&lt;/h3>
&lt;p>向一个主题发布一条 QoS 为 1 的数据包，发送成功之后断开连接：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_publish&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;message ID &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">disconnect&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">publish&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">payload&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">qos&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;connection failed &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt_pub&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">clean_session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_publish&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_publish&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行上述代码，输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">message ID &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相应订阅了&lt;code>test&lt;/code>主题的订阅方输出如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-9ae9789360c82f00077b41232b13f16a_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="42-订阅消息">4.2. 订阅消息&lt;/h3>
&lt;p>通常我们在建立和 Broker 的连接之后就可以开始订阅了，如果你建立的是持久会话的连接，那么有可能 Broker 已经保存你在之前的连接时订阅的主题，你就没有必要再发起 SUBSCRIBE 请求了，这个小优化在网络带宽或者设备处理能力较差的情况尤为重要。相应的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">当代理响应订阅请求时被调用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">granted_qos&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;granted_qos:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">granted_qos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">当收到关于客户订阅的主题的消息时调用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_message&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">topic&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">payload&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;session present&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;subscribing&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;connection failed &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt_sub&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">clean_session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_subscribe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_subscribe&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_message&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行上述代码得到如下输出结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">subscribing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">granted_qos: &lt;span class="o">(&lt;/span>1,&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当运行的发布消息中的代码之后，将输出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">test&lt;/span> b&lt;span class="s1">&amp;#39;hello world&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当终止掉订阅消息中的代码运行之后，再次运行该代码，会发现什么都不输出。因为第一次运行的时候，Broker 上面没有保存这个 Client 的会话，所以需要进行订阅，当重新运行之后，因为 Broker 上面已经保存了这个 Client 的会话，所以就不需要再订阅了，你就不会看到订阅相关的输出了。&lt;/p>
&lt;h3 id="43-取消订阅">4.3. 取消订阅&lt;/h3>
&lt;p>在上述订阅消息中建立连接并订阅了相应主题的基础上，我们取消对之前订阅的主题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">paho.mqtt.client&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">mqtt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">当代理响应取消订阅请求时调用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_unsubscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;message id:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">disconnect&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">on_connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">userdata&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;unsubscribing&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">unsubscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;connection failed &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rc&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mqtt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Client&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;demo_mqtt_sub&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">clean_session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_connect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">on_unsubscribe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">on_unsubscribe&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">connect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;192.168.10.239&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1883&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mqtt_client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">loop_forever&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相应的输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">unsubscribing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">message id: &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后再运行订阅消息中的代码和发布消息中的代码，此时运行订阅消息的终端不再有输出。&lt;/p></description></item></channel></rss>