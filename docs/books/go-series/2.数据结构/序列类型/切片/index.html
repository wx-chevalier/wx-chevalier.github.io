<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="切片 切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。Slice 可以看做更为灵活的引用类型（Reference Type），它并不真实地存放数组值，而是包含数组指针(ptr)，len，c"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/%E5%88%87%E7%89%87/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/%E5%88%87%E7%89%87/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/%E5%88%87%E7%89%87/"><meta property="og:title" content="切片 | Next-gen Tech Edu"><meta property="og:description" content="切片 切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。Slice 可以看做更为灵活的引用类型（Reference Type），它并不真实地存放数组值，而是包含数组指针(ptr)，len，c"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>切片 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=c5153543576ba3c1fb5f2b3f8b336a4e><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">序列类型</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id6a5f2d2e2b2ef4b7fec2d8335344b612")' href=#id6a5f2d2e2b2ef4b7fec2d8335344b612 aria-expanded=false aria-controls=id6a5f2d2e2b2ef4b7fec2d8335344b612 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>2.数据结构</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id6a5f2d2e2b2ef4b7fec2d8335344b612 aria-expanded=false aria-controls=id6a5f2d2e2b2ef4b7fec2d8335344b612><i class="fa-solid fa-angle-down" id=caret-id6a5f2d2e2b2ef4b7fec2d8335344b612></i></a></div><ul class="nav docs-sidenav collapse show" id=id6a5f2d2e2b2ef4b7fec2d8335344b612><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id847ae1e7b8c79cf0b337fbc9f1c850e0")' href=#id847ae1e7b8c79cf0b337fbc9f1c850e0 aria-expanded=false aria-controls=id847ae1e7b8c79cf0b337fbc9f1c850e0 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/>序列类型</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id847ae1e7b8c79cf0b337fbc9f1c850e0 aria-expanded=false aria-controls=id847ae1e7b8c79cf0b337fbc9f1c850e0><i class="fa-solid fa-angle-down" id=caret-id847ae1e7b8c79cf0b337fbc9f1c850e0></i></a></div><ul class="nav docs-sidenav collapse show" id=id847ae1e7b8c79cf0b337fbc9f1c850e0><li class="child level active"><a href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/%E5%88%87%E7%89%87/>切片</a></li><li class="child level"><a href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/%E6%95%B0%E7%BB%84/>数组</a></li><li class="child level"><a href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/>序列类型</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide07e8da3ea7838d5b29f09c61462ba89")' href=#ide07e8da3ea7838d5b29f09c61462ba89 aria-expanded=false aria-controls=ide07e8da3ea7838d5b29f09c61462ba89 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%98%A0%E5%B0%84/>映射</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide07e8da3ea7838d5b29f09c61462ba89 aria-expanded=false aria-controls=ide07e8da3ea7838d5b29f09c61462ba89><i class="fa-solid fa-angle-right" id=caret-ide07e8da3ea7838d5b29f09c61462ba89></i></a></div><ul class="nav docs-sidenav collapse" id=ide07e8da3ea7838d5b29f09c61462ba89><li class="child level"><a href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%98%A0%E5%B0%84/%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%93%8D%E4%BD%9C/>定义与操作</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#遍历>遍历</a></li><li><a href=#切片类型强制转换>切片类型强制转换</a></li></ul><ul><li><a href=#append>append</a></li><li><a href=#copy>copy</a></li><li><a href=#删除切片元素>删除切片元素</a></li></ul><ul><li><a href=#切片内存技巧>切片内存技巧</a></li><li><a href=#避免切片内存泄漏>避免切片内存泄漏</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>切片</h1><div class=article-style><h1 id=切片>切片</h1><p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。Slice 可以看做更为灵活的引用类型（Reference Type），它并不真实地存放数组值，而是包含数组指针(ptr)，len，cap 三个属性的结构体。换言之，Slice 可以看做对于数组中某个段的描述，包含了指向数组的指针，段长度，以及段的最大潜在长度，其结构如下图所示：</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://user-images.githubusercontent.com/5803001/38005668-3f06477e-3274-11e8-85d2-fa78b75f411b.png alt="group 2" loading=lazy data-zoomable></div></div></figure></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 创建 len 为 5，cap 为 5 的 Slice
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 对 Slice 进行二次切片，此时 len 为 2，cap 为 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 恢复 Slice 的长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>)]</span>
</span></span></code></pre></div><p>除了矩阵变换这类需要明确维度的情况外，Go 中的大部分数组编程都是通过切片来完成的。切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见，这可以理解为传递了底层数组的指针。例如 io 包中，File 类型的方法 Read。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>读取的最大字节说被限定在 buf 的长度（len(buf)）和 file 的剩余可读字节数。</p><h1 id=切片定义>切片定义</h1><p>可以使用如下方式创建 Slice:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 使用内置函数创建
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>make</span><span class=p>([]</span><span class=nx>Type</span><span class=p>,</span> <span class=nx>length</span><span class=p>,</span> <span class=nx>capacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>make</span><span class=p>([]</span><span class=nx>Type</span><span class=p>,</span> <span class=nx>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 声明为不定长度切片
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[]</span><span class=nx>Type</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>[]</span><span class=nx>Type</span><span class=p>{</span><span class=nx>value1</span><span class=p>,</span> <span class=nx>value2</span><span class=p>,</span> <span class=o>...</span><span class=p>,</span> <span class=nx>valueN</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span>               <span class=c1>// nil切片, 和 nil 相等, 一般用来表示一个不存在的切片
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>b</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>           <span class=c1>// 空切片, 和 nil 不相等, 一般用来表示一个空的集合
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>c</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>    <span class=c1>// 有3个元素的切片, len和cap都为3
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>d</span> <span class=p>=</span> <span class=nx>c</span><span class=p>[:</span><span class=mi>2</span><span class=p>]</span>             <span class=c1>// 有2个元素的切片, len为2, cap为3
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>e</span> <span class=p>=</span> <span class=nx>c</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>2</span><span class=p>:</span><span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>)]</span>     <span class=c1>// 有2个元素的切片, len为2, cap为3
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>f</span> <span class=p>=</span> <span class=nx>c</span><span class=p>[:</span><span class=mi>0</span><span class=p>]</span>             <span class=c1>// 有0个元素的切片, len为0, cap为3
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>g</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>    <span class=c1>// 有3个元素的切片, len和cap都为3
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>h</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>// 有2个元素的切片, len为2, cap为3
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>i</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>// 有0个元素的切片, len为0, cap为3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 对现有数组进行切片转换
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>array</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl><span class=nx>array</span><span class=p>[:</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>array</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=nx>array</span><span class=p>[</span><span class=mi>2</span><span class=p>:</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 不定类型切片声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=mi>3</span><span class=p>,</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>},</span> <span class=mi>6</span><span class=p>},</span> <span class=mi>7</span><span class=p>,</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=mi>8</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 二维不定类型切片
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>b</span> <span class=o>:=</span> <span class=p>[][]</span><span class=kd>interface</span><span class=p>{}{</span>
</span></span><span class=line><span class=cl>		<span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>和数组一样，内置的 len 函数返回切片中有效元素的长度，内置的 cap 函数返回切片容量大小，容量必须大于或等于切片的长度。也可以通过 reflect.SliceHeader 结构访问切片的信息（只是为了说明切片的结构，并不是推荐的做法）。切片可以和 nil 进行比较，只有当切片底层数据指针为空时切片本身为 nil，这时候切片的长度和容量信息将是无效的。如果有切片的底层数据指针为空，但是长度和容量不为 0 的情况，那么说明切片本身已经被损坏了（比如直接通过 reflect.SliceHeader 或 unsafe 包对切片作了不正确的修改）。</p><p>值得一提的是，当需要声明空 Slice 的时候，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>t</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 优于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>t</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
</span></span></code></pre></div><p>前者是 nil 值，而后者是一个非 nil 切长度为 1 的 slice，通常两者的行为是一样的，但是在一些特殊情况下不同。例如 json 序列化的时候，前者别序列化为 null，而后者则为[]。</p><h2 id=遍历>遍历</h2><p>遍历切片的方式和遍历数组的方式类似：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;a[%d]: %d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>b</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;b[%d]: %d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;c[%d]: %d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>c</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=切片类型强制转换>切片类型强制转换</h2><p>为了安全，当两个切片类型[]T 和[]Y 的底层原始切片类型不同时，Go 语言是无法直接转换类型的。不过安全都是有一定代价的，有时候这种转换是有它的价值的——可以简化编码或者是提升代码的性能。比如在 64 位系统上，需要对一个[]float64 切片进行高速排序，我们可以将它强制转为[]int 整数切片，然后以整数的方式进行排序（因为 float64 遵循 IEEE754 浮点数标准特性，当浮点数有序时对应的整数也必然是有序的）。</p><p>下面的代码通过两种方法将[]float64 类型的切片转换为[]int 类型的切片：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// +build amd64 arm64
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;sort&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>float64</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>88</span><span class=p>,</span> <span class=mi>1</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>SortFloat64FastV1</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>float64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 强制类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>b</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>=</span> <span class=p>((</span><span class=o>*</span><span class=p>[</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>20</span><span class=p>]</span><span class=kt>int</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>])))[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>):</span><span class=nb>cap</span><span class=p>(</span><span class=nx>a</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 以int方式给float64排序
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>SortFloat64FastV2</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>float64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 通过 reflect.SliceHeader 更新切片头部信息实现转换
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>c</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>aHdr</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>reflect</span><span class=p>.</span><span class=nx>SliceHeader</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>a</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>cHdr</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>reflect</span><span class=p>.</span><span class=nx>SliceHeader</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=nx>cHdr</span> <span class=p>=</span> <span class=o>*</span><span class=nx>aHdr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 以int方式给float64排序
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>第一种强制转换是先将切片数据的开始地址转换为一个较大的数组的指针，然后对数组指针对应的数组重新做切片操作。中间需要 unsafe.Pointer 来连接两个不同类型的指针传递。需要注意的是，Go 语言实现中非 0 大小数组的长度不得超过 2GB，因此需要针对数组元素的类型大小计算数组的最大长度范围（[]uint8 最大 2GB，[]uint16 最大 1GB，以此类推，但是[]struct{}数组的长度可以超过 2GB）。</p><p>第二种转换操作是分别取到两个不同类型的切片头信息指针，任何类型的切片头部信息底层都是对应 reflect.SliceHeader 结构，然后通过更新结构体方式来更新切片信息，从而实现 a 对应的[]float64 切片到 c 对应的[]int 类型切片的转换。</p><p>通过基准测试，我们可以发现用 sort.Ints 对转换后的[]int 排序的性能要比用 sort.Float64s 排序的性能好一点。不过需要注意的是，这个方法可行的前提是要保证[]float64 中没有 NaN 和 Inf 等非规范的浮点数（因为浮点数中 NaN 不可排序，正 0 和负 0 相等，但是整数中没有这类情形）。</p><h1 id=切片操作>切片操作</h1><h2 id=append>append</h2><p>Go 提供了内置的 append 函数，来动态为 Slice 添加数据，该函数会返回新的切片对象，包含了原始的 Slice 中值以及新增的值。如果原有的 Slice 的容量不足以存放新增的序列，那么会自动分配新的内存：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// len=0 cap=0 []
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// len=1 cap=2 [0]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// len=2 cap=2 [0 1]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// len=5 cap=8 [0 1 2 3 4]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 使用 ... 来自动展开数组并进行合并
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;John&#34;</span><span class=p>,</span> <span class=s>&#34;Paul&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;George&#34;</span><span class=p>,</span> <span class=s>&#34;Ringo&#34;</span><span class=p>,</span> <span class=s>&#34;Pete&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=o>...</span><span class=p>)</span> <span class=c1>// equivalent to &#34;append(a, b[0], b[1], b[2])&#34;
</span></span></span><span class=line><span class=cl><span class=c1>// a == []string{&#34;John&#34;, &#34;Paul&#34;, &#34;George&#34;, &#34;Ringo&#34;, &#34;Pete&#34;}
</span></span></span></code></pre></div><p>当被追加 slice 有剩余容量时，新增的值，直接赋值到 slice 内部的数组中；反之 slice 将重新申请新的数组以容纳追加的元素，先拷贝原始内容，在添加新元素。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;h&#39;</span><span class=p>,</span> <span class=sc>&#39;e&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;o&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>x2</span> <span class=o>:=</span> <span class=nx>x1</span><span class=p>[:</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>x2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>x2</span><span class=p>,</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;shanexu&#34;</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>x1</span><span class=p>))</span> <span class=c1>// 打印 hello，先拷贝，后追加
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>y1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;h&#39;</span><span class=p>,</span> <span class=sc>&#39;e&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;o&#39;</span><span class=p>,</span> <span class=sc>&#39;w&#39;</span><span class=p>,</span> <span class=sc>&#39;o&#39;</span><span class=p>,</span> <span class=sc>&#39;r&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;d&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>y2</span> <span class=o>:=</span> <span class=nx>y1</span><span class=p>[:</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>y2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>y2</span><span class=p>,</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;shanexu&#34;</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>y1</span><span class=p>))</span> <span class=c1>// 打印 shanexurld
</span></span></span></code></pre></div><p>每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:]的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i]。由于 append 函数返回新的切片，也就是它支持链式操作。我们可以将多个 append 操作组合起来，实现在切片中间插入元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nb>append</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=nx>x</span><span class=p>},</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>     <span class=c1>// 在第i个位置插入x
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nb>append</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>},</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>)</span> <span class=c1>// 在第i个位置插入切片
</span></span></span></code></pre></div><h2 id=copy>copy</h2><p>我们也可以使用内置的 copy 函数，进行 Slice 的复制，该函数支持对于不同长度的 Slice 进行复制，其会自动使用最小的元素数目。同时，copy 函数还能够自动处理使用了相同的底层数组之间的 Slice 复制，以避免额外的空间浪费。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nb>copy</span><span class=p>(</span><span class=nx>dst</span><span class=p>,</span> <span class=nx>src</span> <span class=p>[]</span><span class=nx>T</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 申请较大的空间容量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>t</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=p>(</span><span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>copy</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s</span> <span class=p>=</span> <span class=nx>t</span>
</span></span></code></pre></div><p>用 copy 和 append 组合也可以实现在中间位置插入多个元素(也就是插入一个切片):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>x</span><span class=o>...</span><span class=p>)</span>       <span class=c1>// 为x切片扩展足够的空间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>copy</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=nb>len</span><span class=p>(</span><span class=nx>x</span><span class=p>):],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:])</span> <span class=c1>// a[i:]向后移动len(x)个位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>copy</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:],</span> <span class=nx>x</span><span class=p>)</span>            <span class=c1>// 复制新添加的切片
</span></span></span></code></pre></div><p>稍显不足的是，在第一句扩展切片容量的时候，扩展空间部分的元素复制是没有必要的。没有专门的内置函数用于扩展切片的容量，append 本质是用于追加元素而不是扩展容量，扩展切片容量只是 append 的一个副作用。</p><h2 id=删除切片元素>删除切片元素</h2><p>根据要删除元素的位置有三种情况：从开头位置删除，从中间位置删除，从尾部删除。其中删除切片尾部的元素最快：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>   <span class=c1>// 删除尾部1个元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=o>-</span><span class=nx>N</span><span class=p>]</span>   <span class=c1>// 删除尾部N个元素
</span></span></span></code></pre></div><p>删除开头的元素可以直接移动数据指针：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span> <span class=c1>// 删除开头1个元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=nx>N</span><span class=p>:]</span> <span class=c1>// 删除开头N个元素
</span></span></span></code></pre></div><p>删除开头的元素也可以不移动数据指针，但是将后面的数据向开头移动。可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>[:</span><span class=mi>0</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span> <span class=c1>// 删除开头1个元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>[:</span><span class=mi>0</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>N</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span> <span class=c1>// 删除开头N个元素
</span></span></span></code></pre></div><p>也可以用 copy 完成删除开头的元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nb>copy</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>a</span><span class=p>[</span><span class=mi>1</span><span class=p>:])]</span> <span class=c1>// 删除开头1个元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nb>copy</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>a</span><span class=p>[</span><span class=nx>N</span><span class=p>:])]</span> <span class=c1>// 删除开头N个元素
</span></span></span></code></pre></div><p>对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=o>...</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span> <span class=c1>// 删除中间1个元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=nx>N</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span> <span class=c1>// 删除中间N个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nx>i</span><span class=o>+</span><span class=nb>copy</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:])]</span>  <span class=c1>// 删除中间1个元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nx>i</span><span class=o>+</span><span class=nb>copy</span><span class=p>(</span><span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=nx>N</span><span class=p>:])]</span>  <span class=c1>// 删除中间N个元素
</span></span></span></code></pre></div><p>删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况。</p><h1 id=切片结构>切片结构</h1><p>切片的结构定义，reflect.SliceHeader：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SliceHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Data</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>Len</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>Cap</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看出切片的开头部分和 Go 字符串是一样的，但是切片多了一个 Cap 成员表示切片指向的内存空间的最大容量（对应元素的个数，而不是字节数）。下图是 <code>x := []int{2,3,5,7,11}</code> 和 <code>y := x[1:3]</code> 两个切片对应的内存结构。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://s2.ax1x.com/2019/11/30/QVgLQA.png alt=切片布局 loading=lazy data-zoomable></div></div></figure></p><h2 id=切片内存技巧>切片内存技巧</h2><p>对于切片来说，len 为 0 但是 cap 容量不为 0 的切片则是非常有用的特性。当然，如果 len 和 cap 都为 0 的话，则变成一个真正的空切片，虽然它并不是一个 nil 值的切片。在判断一个切片是否为空时，一般通过 len 获取切片的长度来判断，一般很少将切片和 nil 值做直接的比较。</p><p>比如下面的 TrimSpace 函数用于删除[]byte 中的空格。函数实现利用了 0 长切片的特性，实现高效而且简洁。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[:</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>x</span> <span class=o>!=</span> <span class=sc>&#39; &#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>b</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其实类似的根据过滤条件原地删除切片元素的算法都可以采用类似的方式处理（因为是删除操作不会出现内存不足的情形）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Filter</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>fn</span> <span class=kd>func</span><span class=p>(</span><span class=nx>x</span> <span class=kt>byte</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[:</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>x</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nf>fn</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>b</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>切片高效操作的要点是要降低内存分配的次数，尽量保证 append 操作不会超出 cap 的容量，降低触发内存分配的次数和每次分配内存大小。</p><h2 id=避免切片内存泄漏>避免切片内存泄漏</h2><p>切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。</p><p>例如，FindPhoneNumber 函数加载整个文件到内存，然后搜索第一个出现的电话号码，最后结果以切片方式返回。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FindPhoneNumber</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>regexp</span><span class=p>.</span><span class=nf>MustCompile</span><span class=p>(</span><span class=s>&#34;[0-9]+&#34;</span><span class=p>).</span><span class=nf>Find</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这段代码返回的[]byte 指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。一个小的需求可能导致需要长时间保存整个文件数据。这虽然这并不是传统意义上的内存泄漏，但是可能会拖慢系统的整体性能。</p><p>要修复这个问题，可以将感兴趣的数据复制到一个新的切片中（数据的传值是 Go 语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FindPhoneNumber</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=p>=</span> <span class=nx>regexp</span><span class=p>.</span><span class=nf>MustCompile</span><span class=p>(</span><span class=s>&#34;[0-9]+&#34;</span><span class=p>).</span><span class=nf>Find</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>append</span><span class=p>([]</span><span class=kt>byte</span><span class=p>{},</span> <span class=nx>b</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>类似的问题，在删除切片元素时可能会遇到。假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>[]</span><span class=o>*</span><span class=kt>int</span><span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>    <span class=c1>// 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍
</span></span></span></code></pre></div><p>保险的方式是先将需要自动内存回收的元素设置为<code>nil</code>，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>[]</span><span class=o>*</span><span class=kt>int</span><span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>// GC回收最后一个元素内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>  <span class=c1>// 从切片删除最后一个元素
</span></span></span></code></pre></div><p>当然，如果切片存在的周期很短的话，可以不用刻意处理这个问题。因为如果切片本身已经可以被 GC 回收的话，切片对应的每个元素自然也就是可以被回收的了。</p><h1 id=案例哈希表>案例：哈希表</h1><p>Table 类型是包的基础。它在内部使用切片存储键/值字符串对，其中切片中的哈希表存储桶数由整数 m 确定：</p><ul><li><p>较小的 m 表示将创建更少的存储桶，但是表中存储的每个密钥与其他密钥共享存储桶的可能性更高，从而降低了查找速度</p></li><li><p>较大的 m 表示将创建更多存储桶，因此表中存储的每个密钥与其他密钥共享存储桶的可能性较低，从而加快了查找速度</p></li></ul><p>kv 类型是用于简化存储键/值字符串对的小帮手：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Package hashtable implements a basic hashtable for string key/value pairs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>hashtable</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A Table is a basic hashtable.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Table</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span>     <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>table</span> <span class=p>[][]</span><span class=nx>kv</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A kv stores key/value data in a Table.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>kv</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Key</span><span class=p>,</span> <span class=nx>Value</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// New creates a Table with m internal buckets.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>New</span><span class=p>(</span><span class=nx>m</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Table</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Table</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>m</span><span class=p>:</span>     <span class=nx>m</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>table</span><span class=p>:</span> <span class=nb>make</span><span class=p>([][]</span><span class=nx>kv</span><span class=p>,</span> <span class=nx>m</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>该哈希表支持两种操作：</p><ul><li><p>Get: 确定哈希表中是否存在键，返回值（如果找到）和一个布尔值，指示值是否存在</p></li><li><p>Insert: 将新的键/值对插入哈希表，覆盖同一键的所有先前值</p></li></ul><p>这两个操作都需要一个哈希函数，该函数可以接受输入字符串并返回一个整数，该整数指示存储键值的存储区。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// hash picks a hashtable index to use to store a string with key s.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>Table</span><span class=p>)</span> <span class=nf>hash</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span> <span class=o>:=</span> <span class=nx>fnv</span><span class=p>.</span><span class=nf>New32</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nf>Sum32</span><span class=p>())</span> <span class=o>%</span> <span class=nx>t</span><span class=p>.</span><span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我选择 <code>hash/fnv32</code> 作为简单的非加密哈希函数，该函数返回整数。然后，通过计算模运算 <code>hash % t.m</code>，我们可以确保生成的整数返回我们哈希表存储桶之一的索引。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Get determines if key is present in the hashtable, returning its value and
</span></span></span><span class=line><span class=cl><span class=c1>// whether or not the key was found.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>Table</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Hash key to determine which bucket this key&#39;s value belongs in.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>i</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>hash</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>kv</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>t</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>Key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Found a match, return it!
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>return</span> <span class=nx>t</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>].</span><span class=nx>Value</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// No match.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Table.Get 的实现对输入键进行哈希处理，以确定使用哪个存储区来存储键的值。确定存储桶后，将遍历该存储桶中的所有键/值对：</p><ul><li>如果输入键与该存储桶中的键匹配，则返回存储桶的值，并且布尔值为 true</li><li>如果不匹配，则返回一个空字符串，并返回布尔值 false</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Insert inserts a new key/value pair into the Table.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>Table</span><span class=p>)</span> <span class=nf>Insert</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>i</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>hash</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>kv</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>t</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>key</span> <span class=o>==</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>Key</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Overwrite previous value for the same key.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>t</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>].</span><span class=nx>Value</span> <span class=p>=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Add a new value to the table.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>t</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>kv</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Key</span><span class=p>:</span>   <span class=nx>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Value</span><span class=p>:</span> <span class=nx>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Table.Insert 还必须对输入键进行哈希处理，以确定应使用哪个存储桶来插入键/值对。遍历存储桶中的键/值对时，我们可能发现匹配的键已存在：</p><ul><li>如果输入键与该存储桶中的键匹配，请用输入值覆盖键的值</li><li>如果不匹配，则将新条目添加到存储桶的键/值对片中。</li></ul><p>我们创建了一个非常基本的哈希表，可用于处理键/值字符串对。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 8 buckets ought to be plenty.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>t</span> <span class=o>:=</span> <span class=nx>hashtable</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>t</span><span class=p>.</span><span class=nf>Insert</span><span class=p>(</span><span class=s>&#34;foo&#34;</span><span class=p>,</span> <span class=s>&#34;bar&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>t</span><span class=p>.</span><span class=nf>Insert</span><span class=p>(</span><span class=s>&#34;baz&#34;</span><span class=p>,</span> <span class=s>&#34;qux&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;foo&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;t.Get(%q) = (%q, %t)&#34;</span><span class=p>,</span> <span class=s>&#34;foo&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// t.Get(&#34;foo&#34;) = (&#34;bar&#34;, true)
</span></span></span></code></pre></div><p>在实现通用哈希表时，我在 Gophers Slack 上的#performance 中与一些人进行了讨论，讨论如何访问内置 Go 映射使用的运行时“通用”哈希功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hash</span><span class=p>(</span><span class=kd>type</span> <span class=nx>A</span> <span class=nx>comparable</span><span class=p>)(</span><span class=nx>a</span> <span class=nx>A</span><span class=p>)</span> <span class=kt>uintptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>m</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>A</span><span class=p>]</span><span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=nx>hf</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>mh</span><span class=p>)(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>))).</span><span class=nx>hf</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>hf</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>a</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>hash</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>hash</span><span class=p>(</span><span class=kc>false</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>hash</span><span class=p>(</span><span class=s>&#34;why hello there&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>///////////////////////////
</span></span></span><span class=line><span class=cl><span class=c1>/// stolen from runtime ///
</span></span></span><span class=line><span class=cl><span class=c1>///////////////////////////
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// mh is an inlined combination of runtime._type and runtime.maptype.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>mh</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>uint8</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>uint8</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>uint8</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>uint8</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kd>func</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=o>*</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>int32</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=kt>int32</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span>  <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>	<span class=nx>hf</span> <span class=kd>func</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/go-series/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/%E6%95%B0%E7%BB%84/ rel=prev>数组</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte-website.oss-accelerate.aliyuncs.com/disqus/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte-website.oss-accelerate.aliyuncs.com/disqus/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>