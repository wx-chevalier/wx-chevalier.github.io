<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>系统服务 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</link><atom:link href="https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml"/><description>系统服务</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>系统服务</title><link>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</link></image><item><title>BootLoader</title><link>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/bootloader/</guid><description>&lt;h1 id="bootloader">BootLoader&lt;/h1>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/82357200" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82357200&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Systemd</title><link>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/systemd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/systemd/</guid><description>&lt;h1 id="systemd">Systemd&lt;/h1>
&lt;p>&lt;a href="./Linux-CheatSheet.md">init 进程&lt;/a>是 Linux 系统 Booting 之后的首个进程，其作为守护进程运行直至系统关闭；传统的 Linux 中的服务控制方式也主要依赖于 sysvinit 机制:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ sudo /etc/init.d/apache2 start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 或者&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ service apache2 start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当 sysvinit 系统初始化的时候，它是串行启动，并且会将所有可能用到的后台服务进程全部启动运行；系统必须等待所有的服务都启动就绪之后，才允许用户登录，导致启动时间过长与系统资源浪费。并且 init 进程只是执行启动脚本，不管其他事情，脚本需要自己处理各种情况，使得脚本复杂度增加很多。Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案；Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看 Systemd 的版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemctl --version
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重启系统&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl reboot
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 关闭系统，切断电源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl poweroff
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># CPU 停止工作&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl halt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看启动耗时&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemd-analyze
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看每个服务的启动耗时&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemd-analyze blame
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示瀑布状的启动过程流&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemd-analyze critical-chain
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示指定服务的启动流&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemd-analyze critical-chain atd.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit(单位)，Unit 一共分成 12 种。&lt;/p>
&lt;ul>
&lt;li>Service unit：系统服务&lt;/li>
&lt;li>Target unit：多个 Unit 构成的一个组&lt;/li>
&lt;li>Device Unit：硬件设备&lt;/li>
&lt;li>Mount Unit：文件系统的挂载点&lt;/li>
&lt;li>Automount Unit：自动挂载点&lt;/li>
&lt;li>Path Unit：文件或路径&lt;/li>
&lt;li>Scope Unit：不是由 Systemd 启动的外部进程&lt;/li>
&lt;li>Slice Unit：进程组&lt;/li>
&lt;li>Snapshot Unit：Systemd 快照，可以切回某个快照&lt;/li>
&lt;li>Socket Unit：进程间通信的 socket&lt;/li>
&lt;li>Swap Unit：swap 文件&lt;/li>
&lt;li>Timer Unit：定时器&lt;/li>
&lt;/ul>
&lt;p>systemctl status 命令用于查看系统状态和单个 Unit 的状态。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示系统状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemctl status
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示单个 Unit 的状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sysystemctl status bluetooth.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示远程主机的某个 Unit 的状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemctl -H root@rhel7.example.com status httpd.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们最常用的就是 Unit 管理命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 立即启动一个服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl start apache.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 立即停止一个服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl stop apache.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重启一个服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl restart apache.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 杀死一个服务的所有子进程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl &lt;span class="nb">kill&lt;/span> apache.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重新加载一个服务的配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl reload apache.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重载所有修改过的配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示某个 Unit 的所有底层参数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemctl show httpd.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示某个 Unit 的指定属性的值&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemctl show -p CPUShares httpd.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置某个 Unit 的指定属性&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl set-property httpd.service &lt;span class="nv">CPUShares&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">500&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit。Systemd 默认从目录 &lt;code>/etc/systemd/system/&lt;/code> 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 &lt;code>/usr/lib/systemd/system/&lt;/code>，真正的配置文件存放在那个目录。systemctl enable 命令用于在上面两个目录之间，建立符号链接关系。配置文件的基础格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Unit&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Description&lt;/span>&lt;span class="o">=&lt;/span>ATD daemon
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Service&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Type&lt;/span>&lt;span class="o">=&lt;/span>forking
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">ExecStart&lt;/span>&lt;span class="o">=&lt;/span>/usr/bin/atd
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Install&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">WantedBy&lt;/span>&lt;span class="o">=&lt;/span>multi-user.target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>centos 7 以上是用 Systemd 进行系统初始化的，Systemd 是 Linux 系统中最新的初始化系统(init)，它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度。关于 Systemd 的详情介绍在&lt;a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;p>Systemd 服务文件以.service 结尾，比如现在要建立 nginx 为开机启动，如果用 yum install 命令安装的，yum 命令会自动创建 nginx.service 文件，直接用命令&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemcel enable nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>设置开机启动即可。&lt;/p>
&lt;p>设置开机启动即可。在这里我是用源码编译安装的，所以要手动创建 nginx.service 服务文件。&lt;/p>
&lt;p>设置开机启动即可。在这里我是用源码编译安装的，所以要手动创建 nginx.service 服务文件。开机没有登陆情况下就能运行的程序，存在系统服务(system)里，即：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>/lib/systemd/system/&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>1.在系统服务目录里创建 nginx.service 文件&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>vim /lib/systemd/system/nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>内容如下&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>12345678910111213&lt;/th>
&lt;th>[Unit] Description=nginx After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true [Install] WantedBy=multi-user.target&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;
[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置
Type=forking 是后台运行的形式&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置
Type=forking 是后台运行的形式
ExecStart 为服务的具体运行命令&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置
Type=forking 是后台运行的形式
ExecStart 为服务的具体运行命令
ExecReload 为重启命令&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置
Type=forking 是后台运行的形式
ExecStart 为服务的具体运行命令
ExecReload 为重启命令
ExecStop 为停止命令&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置
Type=forking 是后台运行的形式
ExecStart 为服务的具体运行命令
ExecReload 为重启命令
ExecStop 为停止命令
PrivateTmp=True 表示给服务分配独立的临时空间&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置
Type=forking 是后台运行的形式
ExecStart 为服务的具体运行命令
ExecReload 为重启命令
ExecStop 为停止命令
PrivateTmp=True 表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径&lt;/p>
&lt;p>[]: Unit &amp;ldquo;服务的说明&amp;rdquo;&lt;/p>
&lt;p>Description:描述服务
After:描述服务类别
[Service]服务运行参数的设置
Type=forking 是后台运行的形式
ExecStart 为服务的具体运行命令
ExecReload 为重启命令
ExecStop 为停止命令
PrivateTmp=True 表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径
[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为 3&lt;/p>
&lt;p>保存退出。&lt;/p>
&lt;p>&lt;strong>2.设置开机启动&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemctl enable nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>3.其它命令&lt;/strong>&lt;/p>
&lt;p>&lt;strong>3.其它命令&lt;/strong>
启动 nginx 服务&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemctl start nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>设置开机自启动&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemctl enable nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>停止开机自启动&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemctl disable nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>查看服务当前状态&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemctl status nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>重新启动服务&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemctl restart nginx.service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>查看所有已启动的服务&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>1&lt;/th>
&lt;th>systemctl list-units &amp;ndash;type=service&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>4.Systemd 命令和 sysvinit 命令的对照表&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Sysvinit 命令&lt;/th>
&lt;th>Systemd 命令&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>service foo start&lt;/td>
&lt;td>systemctl start foo.service&lt;/td>
&lt;td>用来启动一个服务 (并不会重启现有的)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>service foo stop&lt;/td>
&lt;td>systemctl stop foo.service&lt;/td>
&lt;td>用来停止一个服务 (并不会重启现有的)，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>service foo restart&lt;/td>
&lt;td>systemctl restart foo.service&lt;/td>
&lt;td>用来停止并启动一个服务，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>service foo reload&lt;/td>
&lt;td>systemctl reload foo.service&lt;/td>
&lt;td>当支持时，重新装载配置文件而不中断等待操作，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>service foo condrestart&lt;/td>
&lt;td>systemctl condrestart foo.service&lt;/td>
&lt;td>如果服务正在运行那么重启它，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>service foo status&lt;/td>
&lt;td>systemctl status foo.service&lt;/td>
&lt;td>汇报服务是否正在运行，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ls /etc/rc.d/init.d/&lt;/td>
&lt;td>systemctl list-unit-files –type=service&lt;/td>
&lt;td>用来列出可以启动或停止的服务列表，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chkconfig foo on&lt;/td>
&lt;td>systemctl enable foo.service&lt;/td>
&lt;td>在下次启动时或满足其他触发条件时设置服务为启用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chkconfig foo off&lt;/td>
&lt;td>systemctl disable foo.service&lt;/td>
&lt;td>在下次启动时或满足其他触发条件时设置服务为禁用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chkconfig foo&lt;/td>
&lt;td>systemctl is-enabled foo.service&lt;/td>
&lt;td>用来检查一个服务在当前环境下被配置为启用还是禁用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chkconfig –list&lt;/td>
&lt;td>systemctl list-unit-files –type=service&lt;/td>
&lt;td>输出在各个运行级别下服务的启用和禁用情况&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chkconfig foo –list&lt;/td>
&lt;td>ls /etc/systemd/system/*.wants/foo.service&lt;/td>
&lt;td>用来列出该服务在哪些运行级别下启用和禁用，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chkconfig foo –add&lt;/td>
&lt;td>systemctl daemon-reload&lt;/td>
&lt;td>当您创建新服务文件或者变更设置时使用，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>telinit 3&lt;/td>
&lt;td>systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3)&lt;/td>
&lt;td>改变至多用户运行级别，&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>5.Sysvinit 运行级别和 systemd 目标的对应表&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Sysvinit 运行级别&lt;/th>
&lt;th>Systemd 目标&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>runlevel0.target, poweroff.target&lt;/td>
&lt;td>关闭系统，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1, s, single&lt;/td>
&lt;td>runlevel1.target, rescue.target&lt;/td>
&lt;td>单用户模式，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2, 4&lt;/td>
&lt;td>runlevel2.target, runlevel4.target, multi-user.target&lt;/td>
&lt;td>用户定义/域特定运行级别。默认等同于 3，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>runlevel3.target, multi-user.target&lt;/td>
&lt;td>多用户，非图形化。用户可以通过多个控制台或网络登录，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>runlevel5.target, graphical.target&lt;/td>
&lt;td>多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>runlevel6.target, reboot.target&lt;/td>
&lt;td>重启&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>emergency&lt;/td>
&lt;td>emergency.target&lt;/td>
&lt;td>紧急 Shell&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.linuxeye.com/400.html" target="_blank" rel="noopener">Systemd 详解&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>服务与初始化</title><link>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/linux-notes/01.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>&lt;h1 id="linux-系统中的服务与初始化">Linux 系统中的服务与初始化&lt;/h1>
&lt;p>自启动服务非常重要，例如&lt;/p>
&lt;p>(1)需要手动添加希望自启的服务，如安装 svn 后没有自动添加，就需要我们手动加入&lt;/p>
&lt;p>(2)安装某些程序后，自动加到自启动了，但我们不需要，需要手动移除&lt;/p>
&lt;p>(3)很多恶意程序都会把自己加入自启动，需要我们排查删除&lt;/p>
&lt;p>运行级别的原理&lt;/p>
&lt;p>涉及到自启动操作时，就会接触到 /etc/rc.d/rc[0-6].d 这 7 个目录&lt;/p>
&lt;p>这几个目录代表着 linux 的 7 个运行级别&lt;/p>
&lt;p>在 /etc/inittab 文件中指定了系统启动时默认进入哪个级别&lt;/p>
&lt;p>Linux 进入运行级别后，就会进入对应的 rcN.d 目录，按照文件名顺序检索目录下的文件&lt;/p>
&lt;p>rcN.d 目录下都是一些链接文件，这些链接文件都指向 /etc/init.d 目录下的 service 脚本文件，例如&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://static.webhek.com/techug-res/uploads/2016/08/640.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>命名规则为:
K+nn+服务名，或 S+nn+服务名&lt;/p>
&lt;p>K – 系统将终止对应的服务&lt;/p>
&lt;p>S – 系统将启动对应的服务&lt;/p>
&lt;p>nn – 两位数字，执行顺序&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://static.webhek.com/techug-res/uploads/2016/08/640-1.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
7 个运行级别是什么？&lt;/p>
&lt;p>0 – 停机&lt;/p>
&lt;p>1 – 单用户模式，root 权限，用于系统维护，禁止远程登陆
2 – 多用户状态，没有 NFS&lt;/p>
&lt;p>3 – 标准多用户模式，登陆后进入命令行模式&lt;/p>
&lt;p>4 – 系统未使用，保留&lt;/p>
&lt;p>5 – 多用户图形模式，登陆后进入图形 GUI 模式&lt;/p>
&lt;p>6 – 重新启动&lt;/p>
&lt;p>服务器一般都是命令行模式，所以默认运行级别为 3&lt;/p>
&lt;p>如何添加自启程序？&lt;/p>
&lt;p>(1)/etc/init.d 目录中添加&lt;/p>
&lt;p>以启动 SVN 为例&lt;/p>
&lt;p>1)在 /etc/init.d 目录下创建启动服务的脚本&lt;/p>
&lt;p>vim /etc/init.d/svn&lt;/p>
&lt;p>内容&lt;/p>
&lt;p>#!/bin/bash
svnserve -d -r /svn 仓库路径&lt;/p>
&lt;p>设置执行权限&lt;/p>
&lt;p>chmod 755 /etc/init.d/svn&lt;/p>
&lt;p>2)把这个脚本软链接到 /etc/rc.d/rc3.d&lt;/p>
&lt;p>ln -s /etc/init.d/svn /etc/rc.d/rc3.d/S101svn&lt;/p>
&lt;p>S 代表是要执行这个脚本，101 是执行顺序，通常要大于 60，这样可以保证基础服务都已经启动完成&lt;/p>
&lt;p>重启 linux 测试&lt;/p>
&lt;p>(2)/etc/rc.local 文件中添加&lt;/p>
&lt;p>直接修改 /etc/rc.local&lt;/p>
&lt;p>该脚本是在系统初始化级别脚本运行之后再执行的，因此可以在里面添加想在系统启动之后执行的脚本&lt;/p>
&lt;p>(3)chkconfig 命令添加&lt;/p>
&lt;p>如何禁止自启程序？&lt;/p>
&lt;p>(1)直接删除 /etc/rc.d/rcN.d 目录的目标链接文件&lt;/p>
&lt;p>(2)删除 /etc/rc.local 文件中定义的启动脚本&lt;/p>
&lt;p>(3)查看自启动服务列表，从中选择目标服务执行禁止操作&lt;/p>
&lt;p>chkconfig –list&lt;/p>
&lt;p>chkconfig –del 服务名&lt;/p></description></item></channel></rss>