<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>99.参考资料 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link>
      <atom:link href="https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml" />
    <description>99.参考资料</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>99.参考资料</title>
      <link>https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link>
    </image>
    
    <item>
      <title>2023-从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史</title>
      <link>https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E4%BB%8E%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A3%E5%88%B0%E6%88%90%E4%B8%BA%E7%A5%9E%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-ebpf-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E6%BC%94%E8%BF%9B%E5%8F%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E4%BB%8E%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A3%E5%88%B0%E6%88%90%E4%B8%BA%E7%A5%9E%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-ebpf-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E6%BC%94%E8%BF%9B%E5%8F%B2/</guid>
      <description>&lt;h1 id=&#34;从石器时代到成为神一文讲透-ebpf-技术发展演进史&#34;&gt;从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史&lt;/h1&gt;
&lt;h2 id=&#34;1前言&#34;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;技术的发展往往是积跬步而至千里的。Linux 从 1992 年诞生，发展至今已经覆盖大小各类的信息基础设施。是什么样的力量让 Linux 能够始终保持发展活力？又该如何看待 Linux 之上出现的新的技术趋势？&lt;/p&gt;
&lt;p&gt;本文试图通过梳理&lt;a href=&#34;https://www.infoq.cn/theme/181&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt;的演进过程，探索 Linux 内核的发展动力来源与发展轨迹，与大家一同畅想 eBPF 给内核技术、Linux 生态带来的全新变局。&lt;/p&gt;
&lt;h2 id=&#34;2ebpf-技术概览&#34;&gt;2.eBPF 技术概览&lt;/h2&gt;
&lt;h3 id=&#34;21实现原理&#34;&gt;2.1.实现原理&lt;/h3&gt;
&lt;p&gt;大家可能都知道图灵机，这是一个可计算理论模型，可以用来判断计算机的计算能力。图灵机是目前有可能实现的计算能力最强的理论模型，目前我们常用的计算机，理论上都是等价于图灵机的。&lt;/p&gt;
&lt;p&gt;BPF 的出现是对计算能力的渴求，其原理就是通过 IR 模拟一台 RISC 指令集的计算机嵌入到内核中，将内核内部的静态编译逻辑转变为更加灵活的动态编译逻辑，使内核获得近似于图灵机的动态逻辑定制能力。而从 classic BPF 到 extended BPF 的发展，是将这一计算方式进一步夯实和通用化。&lt;/p&gt;
&lt;p&gt;BPF 的出现乃至到 eBPF 的进一步发展，为内核带来了巨大的改变，使内核具备了更加强大、可编程的动态变化的能力。&lt;strong&gt;这种能力在各种需要定制化的应用场景中，将发挥巨大的价值，既可以用于扩展功能，也可以用于优化性能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实现上，为适应不同业务场景的需求，使 eBPF 具备等价于一台 RISC 指令集计算机的计算能力，通过输入参数、Map 数据存储、Helper 帮助函数，构成了 eBPF 程序与内核交互的运行环境。eBPF 指令集的计算和控制能力、运行环境与内核的交互能力，两者叠加构成了 eBPF 程序强大的处理能力。&lt;/p&gt;
&lt;p&gt;在安全方面，通过 Verifier 严格检查 eBPF 程序的可完成性、数据访问的合法性等，保证了 eBPF 程序与内核交互过程中内核不被挂起、核心数据不会被破坏。&lt;/p&gt;
&lt;p&gt;在 BPF 发展过程中，由 cBPF 发展成为 eBPF 是一次大的技术升级。eBPF 在 cBPF 的基础上重新设计了指令集、引入了 JIT、增加了辅助函数，大大扩展了复杂逻辑的设计能力。虽然 eBPF 有巨大的进步，但是基本的底层设计还是一致的，因此两者统称为 BPF。&lt;/p&gt;
&lt;p&gt;由于 eBPF 兼容 cBPF，在未指定时，BPF 更多指 eBPF 所定义的内涵。后文用 BPF 泛指整个 BPF 相关的基础机制，eBPF 特指最新的 BPF 标准。&lt;/p&gt;
&lt;h3 id=&#34;22技术特点&#34;&gt;2.2.技术特点&lt;/h3&gt;
&lt;p&gt;BPF 还在快速发展，它的计算能力和完备性也在迅速提高，前景无限。但就具体的版本而言，却又呈现具体技术特点，主要是其支持的能力和受到的约束两个方面。下面以最新的 BPF 技术标准(v6.1)为蓝本，介绍 BPF 的主要技术特点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RISC 指令集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BPF 的核心是一个虚拟计算机，它采用类 RISC 指令集，支持跳转、算数运算、尾调用等基本操作。在运行 BPF 程序的计算机上，BPF 指令会被内核的 JIT 编译器动态编译为物理机原生指令，实现运行效率的“零”损耗。在支持 BPF 卸载的设备上，BPF 程序也可以卸载到设备上执行。在 BPF 的指令集中还支持伪调用指令，可以调用到内核帮助函数。&lt;/p&gt;
&lt;p&gt;同时，BPF 的指令的编码空间中还有大量的储备，未来根据需要一定还会继续增加指令，提升 BPF 实现复杂逻辑的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于键值对的数据存储机制，可用于实现内核、用户态的数据存储和交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Helper 函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专用于 BPF 程序调用的函数接口，用于封装内核中的功能，使 BPF 程序可以和内核互操作，同时保持 BPF 程序和内核的安全隔离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BPF 子程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现了 BPF 程序之间的调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BPF 程序的语境和运行上下文，是一种内部透明的数据结构。只有在明确 BPF 程序的类型时，上下文的定义和内部数据结构才是确定的。不同的 BPF 程序类型，上下文也各不相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CO-RE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过运行时类型支持，实现一次编译、随处运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持特权和非特权级两类运行模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为特权级（百万 ins）和非特权级（4096ins）两类运行方式。特权级模式下 BPF 程序可以获得更宽的权限，实现更复杂的逻辑功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保证向后兼容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一原则对于 BPF 的推广应用非常重要，可以保证旧标准的 BPF 程序在新标准下也可以正确执行。但同时，也对未来 BPF 发展带来了约束，只有把握好 BPF 的发展方向，做好底层设计，才能两者得到兼顾。&lt;/p&gt;
&lt;p&gt;比如，从老版本遗留下来的 cBPF 程序在 eBPF 中都会被 JIT 正确翻译和执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;稳定的 ABI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BPF 稳定的 ABI 包括，BPF 程序类型对应的输入参数定义，可调用的内核帮助函数定义，返回值定义等。使用稳定的 ABI 的 BPF 程序，可保证与不同版本的内核都是兼容的。&lt;/p&gt;
&lt;p&gt;另外，BPF 还在快速发展中，它的功能特性需要逐步释放，因此目前还有诸多限制，其中有些是基于安全、可靠性考虑，有些是没有超出范围的应用需求的保守设计等等。随着安全机制的完善、应用程序的扩展、生态体系的成熟，相应的限制也会逐步的改变。&lt;/p&gt;
&lt;p&gt;目前的实现中，有如下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总运行时间有界：有界性这是基本原则，应该在比较长的时间内都不会改变。但是，在不改变有界性的前提下，根据具体需要适当调整更合理的上限，这是存在极大可能的。&lt;/li&gt;
&lt;li&gt;指令总数限制：非特权用户最大指令数 4096，特权用户最大指令数 1 百万。&lt;/li&gt;
&lt;li&gt;分支数限制。&lt;/li&gt;
&lt;li&gt;BPF 调用嵌套层次限制。&lt;/li&gt;
&lt;li&gt;Map 实例数限制。&lt;/li&gt;
&lt;li&gt;验证状态数限制。&lt;/li&gt;
&lt;li&gt;最大分支数限制。&lt;/li&gt;
&lt;li&gt;堆栈长度限制：目前支持的堆栈最大长度为 512 字节。&lt;/li&gt;
&lt;li&gt;上下文限制：每一种类型的 BPF 程序，都有其对应输入参数定义，彼此不同。也就是说，BPF 程序只能接受特定的输入并进行处理，不能访问内核的全部状态空间。&lt;/li&gt;
&lt;li&gt;辅助函数限制：每一个 BPF 程序类，都有其对应的辅助函数集合。这些辅助函数，由内核各子系统提供，是 BPF 程序类上下文的一部分。它们帮助 BPF 程序与内核各子系统交互，同时又保护内核不会被破坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面赘述了很多特性，大家可能会有很多疑问，比如：为什么采用精简指令集呢？因为这是目前最主流的指令集类型，相对于复杂指令集，精简指令集更有利于实现更高密度、更高吞吐量、更高主频的处理器。因此 x86 之后出现的新型指令集系统，绝大多数都是精简指令集，包括现在的开源指令集 RISC-V。另外也有人会问，为什么不采用原生的指令集呢？为什么 5 个参数寄存器呢？本篇暂不深入讨论，后续主题涉及到的时候再详细讲解。&lt;/p&gt;
&lt;h3 id=&#34;23应用价值&#34;&gt;2.3.应用价值&lt;/h3&gt;
&lt;p&gt;BPF 的应用价值与其动态和可定制特性强相关。内核研发中一直坚守的原则是：“机制与策略分离”，即：内核负责提供机制，将策略开放给上层。在机制与策略之间需要一层界面来进行交互。系统调用是最初方案。它是单向发起的，缺少事件模型。虚拟文件系统，提供了双向的交互方式，但难以灵活定制复杂的逻辑。&lt;/p&gt;
&lt;p&gt;由于软件功能越来越复杂，无法用简单规则来表达，软件的基础功能设施与业务逻辑，需要进行解偶。而业务逻辑部分，需要根据业务定制，因此很适合用 BPF 实现。比如：过滤器、权限检查、模糊测试等类型的功能，比较适合用 BPF 实现。另外，视具体问题，也可以应用于调度算法、用户态交互（替代系统调用，实现更加可变的服务逻辑）、加载器、模拟器、兼容层、轻量化内核、多态内核、启动方式。&lt;/p&gt;
&lt;p&gt;每一种业务类型都有其独具特征的逻辑模型，通过更形式化地定义这些业务模型，可以更好地理解它们和 BPF 的结合性，找到更好的实现方案，充分发挥 BPF 带来的强大能力。后续篇章，我们会对典型的应用模型进行更深入的讨论，以及 BPF 在这些应用场景中，应该在哪些特性方面进行加强或改进。&lt;/p&gt;
&lt;h2 id=&#34;3ebpf-技术发展溯源&#34;&gt;3.eBPF 技术发展溯源&lt;/h2&gt;
&lt;p&gt;回顾技术的发展过程，就像观看非洲大草原日出日落一样，宏大的过程让人感动，细节部分引人深思。每天循环不辍，却又每天不同。&lt;/p&gt;
&lt;p&gt;BPF 的应用早已超越了它最初的设计，但如果要追溯 BPF 最初的来源，则必须回归到它最初的应用领域，再进行理解分析。BPF 最初的用途在于观测，最初用于网络报文的抓取和分析。因此 BPF 的最初、最根本的来源，是作为一种观测手段出现的。而在这个领域中，技术的演进迭代，是一个很长的过程，体现了内核技术发展的艰辛、也同时充满了趣味。&lt;/p&gt;
&lt;p&gt;如果把内核看作一个世界，在这个广袤的土地上，观测技术的发展，也同样经历了从蒙昧到现代的发展过程。每个时代都有其独具特色的观测技术，它决定了当时的开发人员需要具备什么样的功底，什么样的开发方式，这构成了一个时代特色，也谱写了时代的故事。&lt;/p&gt;
&lt;p&gt;而每次时代的更迭，总是在某些方面颠覆了或者突破了传统的思维，从而引发了观测方式的巨大进步，促进了效率和可观测性的提升。对现有技术的深入研究与颠覆性的思想所构成的创新，是技术领域演进的基本形式。而其创新的动力又是什么呢？我们在后文逐步揭示。&lt;/p&gt;
&lt;h3 id=&#34;31石器时代&#34;&gt;3.1.石器时代&lt;/h3&gt;
&lt;p&gt;曾几何时，内核的开发还在初始阶段，由于内核的原理复杂、所处的位置特殊，开发方式和用户态有很大不同。内核开发难度远远大于用户态的应用开发，尤其调试比较困难。犹记得那时对于内核是否引入 GDB 调试机制，有过一些争论。其分歧点就在于，引入过于复杂的机制会改变内核的行为特性，影响问题的稳定性，反而不利于问题的分析定位。&lt;/p&gt;
&lt;p&gt;那时最值得信赖的工具就是 Printk。这是一种低介入的观测工具，使用简单，几乎可以用于任何地方，帮助开发人员观测内核的运行状态。但显著的缺点是不够灵活，如果问题涉及的逻辑路径比较长、分支比较复杂的话，需要反复多次才能定位问题的根源。因此，那时候对内核开发人员的一个必不可少的要求，就是对所负责子系统的实现原理和代码逻辑的熟悉程度需要非常高，能够根据比较少的观测信息，准确定位问题的根源。&lt;/p&gt;
&lt;p&gt;事物总是存在两面性，就像当初产生的那场争论一样，Printk 除了基本的信息输出机制外，几乎没有提供任何强有力的特性。这固然体现了当时的技术水平还在比较原始的阶段（没错，就像是石器时代），但同时也倒逼当时的内核开发人员超强的代码理解和分析能力，以便弥补简陋的工具对效率的掣肘，更快地解决程序中的 BUG。&lt;/p&gt;
&lt;p&gt;另一方面，客观地讲，Printk 固然简单，卓尔无往不利。它可以使用在任何地方，具有完全的上下文访问能力，不受约束的表达能力。它的观测能力和程序本身完全相等，程序本身能看到什么，它就能看到什么，可以说是强大到巅峰。这种强大也是其无法被取代的根本原因，尽管内核的调测技术不断在发展，这一点始终未被超越。它可以用任何线性的文本形式，输出开发人员关注的上下文信息。在后来，这种表达能力得到了进一步发展，支持了部分正则文法。&lt;/p&gt;
&lt;p&gt;它的缺点在于缺乏交互性，任何一点改变都需要修改程序。另一方面，不管上层流程是否被关注，它的信息都会被输出，大大影响了性能。&lt;/p&gt;
&lt;p&gt;Printk 可以说是最强大的工具，至今我也是这样认为。但它同时也是最粗糙的工具。就像石头一样，prink 随处可见，随处可用，用了就一定有所得。简单、强大、直接。但是同样像石头一样，如果用得多了，就会成为垃圾。&lt;/p&gt;
&lt;p&gt;Printk 相比于 BPF，拥有完全不受限制的上下文访问能力，使用的地方几乎没有限制，仅从观测的角度，强大之处有过之而无不及。但是使用方式过于原始，缺乏工业化的扩展能力，因此如果在更长的时间尺度、更广的应用领域来看的话，Printk 无法和 BPF 相提并论。&lt;/p&gt;
&lt;h3 id=&#34;32铁器时代&#34;&gt;3.2.铁器时代&lt;/h3&gt;
&lt;p&gt;在石器时代，人们使用石头磨制的工具进行生产，这些工具粗糙、非标准化、材质原始容易损坏，笨重、使用寿命短。Printk 也是一样，每次执行时都会输出信息，但大多数时候是不需要的；寿命短，每次改变需要修改代码。&lt;/p&gt;
&lt;p&gt;随着内核越来越成熟，架构设计、模块划分、内部功能等等都越来越规范合理。内核的特性，由各个子系统分别负责，内核的整体表现是各个子系统行为表现的综合。而子系统内部的关键路径，决定了子系统主要的行为表现，比如：调度系统中的 CPU 时间统计、上下文切换，迁移等等；内存管理系统中的内存分配、NUMA 平衡；虚拟内存中的页面错误、交换次数等等。&lt;/p&gt;
&lt;p&gt;随着内核设计的规范化，其内部的关键节点和呈现在外部的语义都越来越清晰和标准化。要掌握内核的运行状态，其实并不需要随处观察，只需要掌握几个关键节点、关键信息就可以了。&lt;/p&gt;
&lt;p&gt;以关键变量为基础，工具得以升级；以语义规范化为基础，为交互式的观测机制提供了基础。至此，观测手段不再是单纯的信息输出，它也可以反过来影响系统行为实现多维度的观测。&lt;/p&gt;
&lt;p&gt;虚拟文件系统 Proc 首先打通了用户态和内核态的交互通道，从原来只能控制日志级别，到可以控制数据本身，可以控制的范围更广、更深了；从文本交互，转换为二进制交互，内核性能受到的影响进一步降低。提供了标准化的 API、类型的支持，降低了开发难度，便于推广使用。提炼出关键参数，通过虚拟文件系统进行交互式的系统观测，反过来有利于内核的规范化。&lt;/p&gt;
&lt;h3 id=&#34;33蒸汽时代&#34;&gt;3.3.蒸汽时代&lt;/h3&gt;
&lt;p&gt;Proc 的定义很大一部分还是与具体的上下文相关，并不适合大批量的使用。而 Trace 定义了协议规范，抽象层次更高，可以批量使用。&lt;/p&gt;
&lt;p&gt;Trace 是一个更加纯粹的观测机制，给用户提供了通用简单的接口，底层实现了很丰富的机制。可以支持大量使用，对于可观测性的提升起到了根本性的推动。可以批量重复使用，这是它和其他观测方式的区别。&lt;/p&gt;
&lt;p&gt;如果说 Proc 采用了代码数据化的思想，那么 Trace 采用很多元编程的思想，极大简化了外部接口，减少了重复代码。&lt;/p&gt;
&lt;h3 id=&#34;34电气时代&#34;&gt;3.4.电气时代&lt;/h3&gt;
&lt;p&gt;Trace 机制固然好用，只要预先铺设了基础设施，运行时就可以随时开启观测。但缺点是，对于没有铺设铁轨的地方，火车的承载能力再强也是无法到达的。&lt;/p&gt;
&lt;p&gt;Trace 的机制很通用，但另一方面，它无法深入业务层面进行更进一步的调测。要实现这一点，需要完整的上下文能力和可编程能力，因此 kprobe 出现了。只要由函数的地方，就像通了电一样，随时可以点亮，这是 Kprobe 强于 Trace 的覆盖能力。能够完整访问函数上下文，这是 Kprobe 强于 Trace 的业务理解能力。&lt;/p&gt;
&lt;h3 id=&#34;35智能时代&#34;&gt;3.5.智能时代&lt;/h3&gt;
&lt;p&gt;Kprobe 是动态性的萌芽，但是存在很多不足。它在内核态运行需要对内核编程有一定了解，编程门槛较高。此外，它还存在安全性问题、可扩展性问题，等等。&lt;/p&gt;
&lt;p&gt;从计算能力来说，所有图灵机的计算能力是相等的，要解决能力问题，最终是要实现一个虚拟机的。而在内核态实现一个虚拟机，所涉及到的安全问题是必须考虑的，通过 Verifier 和运行时 Helper 函数，做到了逻辑约束和上下文隔离。虚拟机、Verifier 和 Helper 函数，是 BPF 和 Kprobe 的根本区别。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;工具&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;观测能力&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;交互性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;使用范围&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;修改内核&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;可编程&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Printk&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可见上下文&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单向&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;任意&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;proc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;预定义&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;双向&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关键参数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不可以&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;固定观察窗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;trace&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;预定义&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单向&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关键流程&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不可以&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;动态观察窗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;kprobe&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;函数边界&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;双向&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;任意函数&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;动态逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;BPF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;trace+kprobe+预定义&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;双向&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;任意函数+预定义&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;虚拟机&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;4内在驱动&#34;&gt;4.内在驱动&lt;/h2&gt;
&lt;p&gt;由以上简要的回顾和梳理可见，内核开发者们所不断寻找的是一种充分表达能力的动态机制，进而打破内核和用户态的壁垒（至少在逻辑层面），从而实现一种自由、直接的需求实现。技术成为内核开发者们锋利的工具，不断突破限制，揭示事物的本质。&lt;/p&gt;
&lt;p&gt;BPF 技术的出现和发展，从时间尺度来说并不长，但是从其内在的驱动来说，有着复杂的动因，是很多因素就和在一起的必然结果。由于其复杂性，从任何一个孤立的角度进行分析都是不充分，只有从各个不同的角度分析，才可以体会出不同的趣味。&lt;/p&gt;
&lt;p&gt;通过探寻其深层次的原因，可以梳理出更加清晰的发展脉络，从而可以更好地展望 BPF 及其相关技术领域的未来发展，为我们学习、研究和加入 BPF 的发展打下基础。&lt;/p&gt;
&lt;p&gt;下面，我们试着从复杂性、微内核化两个方面，分析 BPF 发展的内在动力。&lt;/p&gt;
&lt;p&gt;内核的发展历史就是一个复杂性不断递增的历史，内核的发展也是不断控制复杂性、维持内核代码的可理解性的过程。因此，内核的开发始终坚持一个原则，就是机制与策略的分离。&lt;/p&gt;
&lt;p&gt;在不同时期，如何进行机制与策略的分离，有着不同的答案。随着技术和应用的不断发展，维持这一原则的的难度是不断增加的，需要更新的思想、更先进的技术才能支撑。或者也可以说，正因为内核的发展过程中，始终坚持了这个原则，所以才不断有影响深远的基础技术的出现。&lt;/p&gt;
&lt;p&gt;我相信，要实现定制与动态，有很多不同的方案。但我认为 BPF 的出现是最佳的选择，使内核的发展有了应对未来变局的基础。&lt;/p&gt;
&lt;p&gt;这是 BPF 出现的契机，也是其未来快速发展的动力。&lt;/p&gt;
&lt;h3 id=&#34;41代码规模问题&#34;&gt;4.1.代码规模问题&lt;/h3&gt;
&lt;p&gt;Linux 项目发展至今，其代码总量早已超过千万，是一个非常庞大的项目。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/18/18002074940e509d0b2338938e35909e.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：来源&lt;/em&gt;&lt;a href=&#34;https://www.phoronix.com/misc/linux-eoy2019/lines.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;https://www.phoronix.com/misc/linux-eoy2019/lines.html&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由统计数据可以看出，Linux 项目的复杂度（从代码量角度）一直在不断增长。&lt;/p&gt;
&lt;h3 id=&#34;42软件结构的复杂&#34;&gt;4.2.软件结构的复杂&lt;/h3&gt;
&lt;p&gt;整个软件系统，从应用程序到内核是一个繁杂的层次结构，又由于模块之间的交叉，实际的运行流程是一个复杂的有向图结构。&lt;/p&gt;
&lt;p&gt;以完成一次简单的文件操作为例，首先应用程序需要 open 一个文件，这首先会运行到某种运行时库，完成资源分配、接口转换等等处理。然后，流程才会到系统调用这一层。系统调用中，由 VFS 解析文件路径信息，找到对应的文件系统信息。再由具体的文件系统完成文件打开的操作。&lt;/p&gt;
&lt;p&gt;这其中至少涉及到了应用程序、运行时库、系统调用、VFS、文件系统等多个层次。如果再细分的话，还涉及到用户态内存管理，内核态内存管理、权限管理、命名空间管理、句柄管理、缓存管理、锁、钩子等次级模块。&lt;/p&gt;
&lt;p&gt;目前 Linux 支持的文件系统至少已经达到七十多种，有基于本地存储设备的、基于网络的、分布式的、基于内存的、虚拟的等等。有的文件系统在内核态实现，有的在用户态实现。&lt;/p&gt;
&lt;p&gt;另外，C 语言的条件编译，可以针对使用场景选择适合的代码编译。每一个条件编译选项就是对现实条件的一个考量。从 Linux 整个源码树中使用的条件编译选项的数量，也可以反映出 Linux 整个源码的复杂度。对 Linux 5.10 的源代码粗略统计，条件编译选项已经多达 18000 多个；而在 6.1 版本中，已经达到了 19000 多个。&lt;/p&gt;
&lt;h3 id=&#34;43业务系统的复杂&#34;&gt;4.3.业务系统的复杂&lt;/h3&gt;
&lt;p&gt;在虚拟化技术以前，不同应用场景的业务系统的结构差异，主要表现为平面性的拓扑结构的差异，比如：对等式的、分布式的、客户&lt;a href=&#34;https://cloud.tencent.com/product/cvm?from=20067&amp;amp;from_column=20067&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务器&lt;/a&gt;模式的等等，由于网络拓扑结构的不同、节点承担的业务角色的不同，形成了各种各样的业务系统。&lt;/p&gt;
&lt;p&gt;在虚拟化技术出现后，云计算迅猛发展，云成为了信息系统的基础设施。业务系统的差异不仅仅体现在横向拓扑结构上，其自身逻辑的深层组成也是非常复杂。它可以运行在真实计算机上也可能在虚拟机上，可能在一个独立的命名空间，也可能和别的业务共享。不同业务模块之间的联系有可能是直接的，也可能在无法感知的情况下被层层嵌套。&lt;/p&gt;
&lt;p&gt;**业务系统的复杂性，体现在业务的复杂性与业务系统的复杂性两个方面。**业务的复杂，导致我们需要对业务系统进行分层设计，需要有定制化的能力，需要有运营与持续开发并行的能力。上线前的产品级的开发很重要，但是上线后的业务级的持续定制和开发同样重要。复杂的业务必然导致复杂业务系统的产生，如何以一个统一的、足够强大的方式来解决复杂性问题，使复杂业务系统的复杂性是可以拆解的、可管理的，就非常重要。&lt;/p&gt;
&lt;h3 id=&#34;44维护限制的要求&#34;&gt;4.4.维护限制的要求&lt;/h3&gt;
&lt;p&gt;Linux 系统已经规模化运行在各种类型的设备上，每一个商业系统，在其运行期间都是需要进行维护的。&lt;/p&gt;
&lt;p&gt;于大型的服务器系统，承载在成千上万的在线业务，是不能中断服务的，需要在线的定制能力。对于个人终端，每个人的使用习惯不同，如何使每个用户都能获得最佳的使用体验，需要数据分析和个性化的定制能力。对于散布在各处角落的边缘节点乃至物联网设备，需要内核提供更智能的介入方法，使维护人员能够远程完成对大量设备的维护工作。&lt;/p&gt;
&lt;h2 id=&#34;5ebpf-技术的意义&#34;&gt;5.eBPF 技术的意义&lt;/h2&gt;
&lt;p&gt;BPF 最初来源于解决网络报文过滤的问题，实现灵活的过滤规则。网络报文的过滤规则，最初只需要正则语言就能表达，但后来就不够了。而 BPF 提供了更强大的表达能力，BPF 具有近似图灵完备性，必将成为问题分解、解决复杂问题的神级工具。&lt;/p&gt;
&lt;h3 id=&#34;51图灵完备性&#34;&gt;5.1.图灵完备性&lt;/h3&gt;
&lt;p&gt;讨论 BPF 的计算能力，涉及到图灵完备。BPF 目前的基本设计中，有限性是基本设计原则，这是保证内核不被扩展逻辑挂死的基本要求。而有限性，是 BPF 和图灵机的根本差异，因此它不是图灵完备的。这个结论固然没错，但如果讨论仅止于此的话，那么这一论断过于粗糙，换个有趣一点的说法，这样的讨论不是图灵完备的，因此还需要具体分析。&lt;/p&gt;
&lt;p&gt;完备性，不是评价工具优劣的完全准则。一般认为，C 语言是图灵完备的。但 C 语言的所有数据类型都是有界的，其实是弱于图灵机的。但不妨碍人们认为 C 是图灵完备的，因为它的能力边界距离实际应用的需求很远，我们感受不到。虽然 C 语言图灵不完备，但是不妨碍它的发展潜力，在它的成长过程中，也在不断的改版、丰富。这是因为它的完备性不足吗？显然不是。一种工具，在工程实践中，完备性是次要的，因为他被选择，就说明它是够用的。其他方面才是当下更应该关注的问题。&lt;/p&gt;
&lt;p&gt;图灵机是一种无限的自动机，人们穷尽办法也只能逼近，即使全世界所有计算机加在一起的总和，也弱于图灵机。所以图灵完备现实中根本不存在，讨论逼近图灵机的能力可能更现实。在实际的语境中，人们实际上把无限接近图灵机的逼近能力，等同于图灵完备性。一个很好的例子就是 C 语言，它显然不是图灵完备的，但人们一般认为它是图灵完备。从这点说，BPF 语言同样是图灵完备的。&lt;/p&gt;
&lt;p&gt;排除语言的问题，那么 BPF 是图灵完备的吗？仍然不是，**BPF 的图灵不完备，并不主要来源于 BPF 语言本身，而是来源于运行环境。从这点说，BPF 语言是图灵完备的，BPF 虚拟机不是。**从这点也可以说，只要有需要，通过改造运行环境，BPF 可以无限逼近图灵机的计算能力。&lt;/p&gt;
&lt;p&gt;因此，从图灵完备这一点，我们既不能过度的否定 BPF，认为它的能力有限。但同时，也不能认为它的能力可以无限扩张，因为需要满足特定的条件。总之，BPF 还在快速发展过程中，一切可能性皆在其中，任何定论皆言之过早。&lt;/p&gt;
&lt;p&gt;从另一个角度来看，就 BPF 目前的应用领域而言，输入和状态空间是有限的，因此在有限的输入下，图灵完备并不是必须。这是从现实的需求来说，BPF 足以完成指定语境下的任何计算。&lt;/p&gt;
&lt;p&gt;但显然 BPF 的计算能力还有很大的提升空间。&lt;/p&gt;
&lt;p&gt;语言方面，BPF 的指令集的提出，在计算能力上，它就是超配的。现在的问题是，如何安全地释放他的能力。运行时系统和工具链的设计，是目前的焦点问题。已经呈现出思想分歧，基于运行时环境的思路和直接开放的思路同时存在。未来这两个思路应该都会有一定程度的发展，形成面向不同领域的高低搭配的解决方案。&lt;/p&gt;
&lt;p&gt;因此，我认为运行时的改进可能更加迫切。这需要我们及早确定问题边界，提供面向问题的运行环境，才能更有效的提出平衡安全和可计算性的问题的方案，即：&lt;strong&gt;运行环境+必要的计算能力，构成完备的面向问题域的解决方案&lt;/strong&gt;。定义一个安全的虚拟机，保证操作不逃逸，一个安全的运行时库，导出或者链接内核对象（Helper），在这个集合上，定义安全的操作，这样语言本身就可以不再受具体逻辑和访问对象的限制，做到语言本身的图灵完备。&lt;/p&gt;
&lt;h3 id=&#34;52编程模型的发展&#34;&gt;5.2.编程模型的发展&lt;/h3&gt;
&lt;p&gt;在 BPF 之前，Linux 开发的编程模型，可以分为内核编程和用户态编程两种。分别使用不同的编程接口和编程规范，是两者最大的区别。BPF 出现之后，出现了新的编程模型，既不能称之为内核编程，也不能称之为用户态编程。&lt;/p&gt;
&lt;p&gt;这是一种全新的编程模型。它运行于内核态，但是不使用任何传统的内核接口（5.13 可以调用经过筛选和处理的内核函数。至今，它仍然受限于特定函数和指定的上下文，还不是一种通用的机制。且这种机制进一步通用化之前，它的安全性仍然值得先进一步的讨论），不通过符号与内核进行链接。它使用应用编程逻辑和范式，但是不使用应用编程传统的接口，而是使用 BPF 提供的帮助函数。它所能访问的数据对象还在不断发展过程中，远未定型。&lt;/p&gt;
&lt;p&gt;因此，笔者称这种编程模型为：&lt;strong&gt;临界编程&lt;/strong&gt;。也许它未来会有更好的名字，但这个名字一方面，表明它的跨界特性，一方面表面它日新月异的发展。也表明对它未来的期待。&lt;/p&gt;
&lt;h3 id=&#34;53用户态比重的加大&#34;&gt;5.3.用户态比重的加大&lt;/h3&gt;
&lt;p&gt;由于虚拟化和软件工程的原因，网络报文处理和文件系统，呈现出往用户态迁移的趋势。BPF 和用户态化的共通点和差异点在于，都将更多的内核扩展性放在了用户态，但 BPF 的逻辑仍然从属于内核。&lt;/p&gt;
&lt;p&gt;他们都和传统内核通过一层良好定义的接口进行了隔离。用户态驱动和文件系统，使内核的功能更容易扩展。而 BPF 则是对内核本身的扩展。两者存在根本差异，因此也存在相互结合的可能，从而形成更加强大的软件架构。&lt;/p&gt;
&lt;p&gt;而这种架构会用于什么地方呢？我们已经做了初步尝试，FUSE 和 BPF 进行结合。可以实现用户态文件系统和内核更加高效的交互（这一话题，我们在后续的篇章中再详细讨论）。推而广之，内核的网络、安全、文件系统、驱动，都可以放在用户态来实现，通过 BPF 来优化交互。&lt;/p&gt;
&lt;h3 id=&#34;54微内核&#34;&gt;5.4.微内核&lt;/h3&gt;
&lt;p&gt;BPF 的运行基础是运行时环境，随着 BPF 应用的增加，一定会促使内核子系统的更进一步的抽象和解偶，这在逻辑上为微内核化准备了条件。&lt;/p&gt;
&lt;p&gt;BPF 真正避免了纯粹用户态编程的性能问题，为应用开发人员开发特色功能提供了一种临界编程工具。这或许是微内核的另一种实现路径。&lt;/p&gt;
&lt;h3 id=&#34;55观测代码与业务代码合一&#34;&gt;5.5.观测代码与业务代码合一&lt;/h3&gt;
&lt;p&gt;BPF 出现的时候，最初是观测工具，但后来它也能用于实现更复杂的功能，影响网络子系统的报文转发逻辑。BPF 计算能力的强大、性能的优势，使它不仅能用于观测还可以做更多复杂的事情。&lt;/p&gt;
&lt;p&gt;通过高度抽象化的设计，我们可以设计出复杂、通用的业务系统，但是我们设计不出“最佳”的业务系统。最佳的业务系统一定是在真实的应用场景中，通过不断的观测、分析、优化，才能达成的。&lt;/p&gt;
&lt;p&gt;将一个复杂系统优化到“最佳”同样是一个复杂问题，多目标的一致性、动态系统的不稳定性、巨大的状态空间等等，都可能导致这个问题没有最终答案，只有采用动态反馈机制。因此，将观测代码和优化代码（业务代码的策略优化部分）合一，是使这一优化模式能够更加准确、高效、稳定的必然选择。&lt;/p&gt;
&lt;h3 id=&#34;56编译器和内核合一&#34;&gt;5.6.编译器和内核合一&lt;/h3&gt;
&lt;p&gt;从本质上讲，计算问题、语言问题其实是一个问题。最初我们解决计算问题，是在纸带上打孔，后来有了编译器。解决计算问题的效率大大提升，但是解决计算问题的能力其实没有变化。&lt;/p&gt;
&lt;p&gt;后来有了操作系统，软件的分层模型逐渐成型，开发应用程序的效率大大提升，但其实通过编程解决计算问题的能力并没有提升，反而是在下降。因为软件的每一个分层，在带来工程化效率的同时，也导致了能力的损耗。API 的设计是一个大命题，但是没有完美的 API 设计。&lt;/p&gt;
&lt;p&gt;开发效率的提升，带来了应用的高度发展，现在计算能力的问题出现了。回归本原，将编译器和内核合一，构建更加强大的计算能力，是未来发展的基础。&lt;/p&gt;
&lt;h2 id=&#34;6走向未来&#34;&gt;6.走向未来&lt;/h2&gt;
&lt;p&gt;未来 BPF 将如何发展呢？&lt;/p&gt;
&lt;p&gt;它已经具备图灵机的雏形，拥有巨大的计算能力潜能。它目前的计算能力仍然受到约束，但是已经足够改变现有应用开发的基础，必将引发应用的蓬勃发展，会衍生出开发工具、测试方法等等的发展，使业务逻辑的开发与 BPF 的开发统一在一个开发模型当中，甚至引发新的开发语言出现。当在应用领域中生根后，就会继续发芽壮大，需要吸收计算能力作为养料才能抽枝散叶。BPF 应用与 BPF 技术内涵的发展就像两面相对的镜子，相互映照，形成斑斓的德罗斯特效应图景。&lt;/p&gt;
&lt;p&gt;随着近几年云计算、人工智能、智能设备的蓬勃发展，信息系统基础设施结构、设备类型、业务复杂度都迎来再一次的变革。&lt;/p&gt;
&lt;p&gt;Linux 系统作为现今最为广泛使用的操作系统，其自身也在发展变化。初期，沿着原有的技术路线，通过量的积累，足以应对时代的演进，这一点从代码增长就可以看出来，其背后是 Linux 支持的设备、驱动、特性、机制也来越多。产品构型也越来也复杂，Web 服务器、&lt;a href=&#34;https://cloud.tencent.com/product/gpu?from=20067&amp;amp;from_column=20067&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;并行计算&lt;/a&gt;、&lt;a href=&#34;https://cloud.tencent.com/product/gpu?from=20067&amp;amp;from_column=20067&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;异构计算&lt;/a&gt;、桌面、智能终端、嵌入式系统。Linux 的技术设施，需要面对不同的应用场景和问题。量的积累，可以解决一段时间的问题。但是，当这种变化积累到一定程度时，需要新的手段，才能支持上层结构的灵活度。&lt;/p&gt;
&lt;p&gt;需要指出的是，现有的文档中，大多将 BPF 定位为网络和安全工具的利器。但是 BPF 作为一种通用的动态逻辑机制，绝不仅仅可以应用这两个地方。&lt;/p&gt;
&lt;h3 id=&#34;61通用性&#34;&gt;6.1.通用性&lt;/h3&gt;
&lt;p&gt;BPF 已经从最初网络报文分析技术，扩展到了很多应用领域，以后必然成为一种通用的内核开发技术，在定制化和功能扩展两方面推动内核发展。目前 BPF 的核心组件基本轮廓已经确定，由运行上下文、帮助函数、Map、指令集、Verifier、JIT、系统调用等关键模块构成 BPF 的核心运行机制。&lt;/p&gt;
&lt;p&gt;运行上下文是 BPF 程序运行的语境，目前除了网络语境发展比较快速之外，其他程序类型的运行上下文发展相对落后，文件系统目前甚至还没有。对于运行上下文应该设计成什么样子，达到什么要求，有怎样的约束，还没有统一的范式，主要由各程序类型根据实际应用需要进行定义。彼此间缺乏共通性，发展比较随意，还处于比较原始的阶段。&lt;/p&gt;
&lt;p&gt;帮助函数还不完备，各个程序类型存在差异。程序类型的定义，缺乏逻辑基础，其设计元语还需澄清。语境相关部分和通用部分划分不清楚，影响到安全机制也无法针对性设计，安全性无法验证。&lt;/p&gt;
&lt;p&gt;Map 担负的角色过于宽泛，既是通讯机制，也是存储机制，既是 Local 的也是 Global 的。是对 BPF 核心机制补全的过渡手段。随着，远程调用、间接调用、跳转表、全局变量等的实现，Map 的作用和使用方式也将改变。&lt;/p&gt;
&lt;h3 id=&#34;62表达能力&#34;&gt;6.2.表达能力&lt;/h3&gt;
&lt;p&gt;内核已经在扩展性方面在不断改进，但是这些始终还是不能根本解决问题，引入更多编译器技术特别是动态编译技术、可信编译技术才是解决问题的根本。&lt;/p&gt;
&lt;p&gt;目前 BPF 的程序的表达能力相当于弱化的 C 语言，这显然是不够的。实现一种和传统应用开发相同的开发体验，让程序员专注于理解业务逻辑，自由地表达，需要编译器填补通用语言与 BPF 自身限制之间的沟壑，需要语言层面的扩展，也需要运行时和工具链的支持。&lt;/p&gt;
&lt;h3 id=&#34;63开发工具&#34;&gt;6.3.开发工具&lt;/h3&gt;
&lt;p&gt;目前还没有在前端支持 BPF 的开发工具，只是实现了后端的支持，这显然还远远不够。这种情况，正说明了 BPF 的发展急需编译器的支持，在前端支持 BPF，通过语言特性的扩展和新的开发支持库，实现 BPF 与通用编程语言的融合，将大大缩减包含 BPF 特性的应用程序的开发、测试和维护难度。对于 BPF 作为一项应用开发技术大力推广至关重要。&lt;/p&gt;
&lt;h3 id=&#34;64开发流程&#34;&gt;6.4.开发流程&lt;/h3&gt;
&lt;p&gt;目前，在设计阶段，需要将 BPF 的逻辑部分和一般编程逻辑部分分离出来，这增加了设计的开销，同时对于设计人员的要求加大。原本的应用设计人员，只了解业务逻辑，这显然不够，还需要了解内核的基本原理，才能够做好逻辑划分工作。既了解内核又懂应用开发和业务逻辑的人员，是交叉性人才，这样的人员往往少且难以培养。如果让原本的应用开发人员，学习掌握内核相关的知识，以便可以满足 BPF 应用开发的需要，显然费时费力不说，费效比更是难以达到商业决策的最低门槛。&lt;/p&gt;
&lt;p&gt;而在开发阶段，BPF 和应用需要分开编码，这无疑增加了联调联试的开销。特别是，出现问题的时候需要频繁的跨组跨部门沟通，效率实在太低。如果能把 BPF 的开发完全应用化，让一个程序员承担所有工作，成本、效率都可以得到优化。在测试阶段，还缺少专用的高效率的工具。&lt;/p&gt;
&lt;p&gt;因此，以开发工具的进步为基础，目前采用的开发流程也一定会同步地被改进。可以预想，未来的开发流程一定是融合和简化的。&lt;/p&gt;
&lt;h2 id=&#34;7结束语&#34;&gt;7.结束语&lt;/h2&gt;
&lt;p&gt;Linux 内核的发展，将技术发展与创新演绎得淋漓尽致。源自于用户和开发者的需求，始终是推动技术不断进步的根本动力。在需求的推动下，Linux 内核始终在快速的发展，保持着强劲的动力。同时，热爱与坚持，还有最重要的开发原则的坚守，是 Linux 能够将源源不断的需求转化为创新动力的基础，而不至于被爆炸的需求摧毁。基本原则体系的维护，使 Linux 内核始终保持如一的设计框架。&lt;/p&gt;
&lt;p&gt;在 Linux 的发展过程中，一些很小的需求，最终也可以发展成为复杂的架构。坚持与打破壁垒，是创新的范式。&lt;/p&gt;
&lt;p&gt;在不断寻求问题的最终答案的过程中，有很多优秀的思想启发我们的认知，但限于技术发展阶段、条件是否成熟，这些优秀的思想有的潜入水底，有的浮现水面独领一段风骚。历史会有所偏好，作出它的选择，但不可否认的是这些优秀的思想，都一直在发挥着它们的作用。当历史的拐点到来的时候，它们又会重新融合，以一种全新的方式继续推动技术的进步。&lt;/p&gt;
&lt;p&gt;BPF 是内核交互问题不断挖掘、迭代后的最新答案。内核的交互问题，本质上是内核结构问题。BPF 的强大计算能力，将推动更好地实现内核与用户态的动态交互，使内核能够更加灵活满足各种应用场景的需要，使整个系统的性能不因为这种能力而遭受损失。保持软件良好分层的基础上，减小分层对信息交互、资源共享的阻碍。而围绕 BPF 的基础设施的发展，也必定会为内核结构带来巨大改变，将安全性、规范性更加深入地融入到内核的细微层次。&lt;/p&gt;
&lt;p&gt;安全可靠是 BPF 持续发展的原则的，在 BPF 的功能性不断扩展、计算能力不断释放的过程中，安全检查、可信编译的加持是可持续性的基础。而作为一种全新的编程方式，BPF 的开发和传统编程范式具有同样的地位和发展前景。从语言的支持到代码的生成乃至 JIT 的优化等等，是必不可少的一环。&lt;/p&gt;
&lt;p&gt;BPF 来源于 Linux 内核发展过程中，众多优秀的开发者在效率、能力方面的不断改进，以及对技术本源的孜孜以求。它是内核发展中，众多优秀思想的集大成者，但同时，它也仅仅是新时代的开始。新的方法、新的语言、新的架构都在不断出现，催生着巨大的变革，如汹涌的波涛。而 BPF 将成为乘波之舟，它存在很多可能性，相信以此为起点，开发者们将会谱写更华丽的篇章。这是包括作者在内的众多开发者，所期待的广阔未来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2023-无声的平台革命：eBPF 是如何从根本上改造云原生平台的</title>
      <link>https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E6%97%A0%E5%A3%B0%E7%9A%84%E5%B9%B3%E5%8F%B0%E9%9D%A9%E5%91%BDebpf-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E6%A0%B9%E6%9C%AC%E4%B8%8A%E6%94%B9%E9%80%A0%E4%BA%91%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0%E7%9A%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E6%97%A0%E5%A3%B0%E7%9A%84%E5%B9%B3%E5%8F%B0%E9%9D%A9%E5%91%BDebpf-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E6%A0%B9%E6%9C%AC%E4%B8%8A%E6%94%B9%E9%80%A0%E4%BA%91%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0%E7%9A%84/</guid>
      <description>&lt;h1 id=&#34;无声的平台革命ebpf-是如何从根本上改造云原生平台的&#34;&gt;无声的平台革命：eBPF 是如何从根本上改造云原生平台的&lt;/h1&gt;
&lt;h3 id=&#34;摘要&#34;&gt;摘要&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;eBPF 已在云原生生态环境中众多项目和产品中的底层使用，通过实现丰富的云原生上下文，eBPF 使内核具备进入云原生条件。eBPF 所创造的悄无声息的基础设施运动，使其随处可见，且实现了许多先前不可能实现的新用例。&lt;/li&gt;
&lt;li&gt;eBPF 已经在互联网规模的生产环境与生产验证中，于全球数百万服务器和设备上全天候运行超过五年。&lt;/li&gt;
&lt;li&gt;eBPF 在操作系统层实现了新的抽象，为平台团队提供了云原生网络、安全和可观测性的高级能力，以安全地定制操作系统，满足其工作负载的需求。&lt;/li&gt;
&lt;li&gt;扩展操作系统内核是一个艰难而漫长的过程，应用一个变化可能需要数年时间才能完成。但现在随着 eBPF 的应用，这种开发者-消费者的反馈循环几乎是即时可用的，变化可以优雅地推送到生产中，而不必重新启动或改变应用程序或其配置。&lt;/li&gt;
&lt;li&gt;未来十年的基础设施软件将由平台工程师来定义，他们可以使用 eBPF 和基于 eBPF 的项目来为更高层次的平台创建合适的抽象概念。以 eBPF 为驱动的 Cilium 等开源项目，在网络、可观测性和安全性上，已经开创并将这种基础设施运动带入到了 Kubernetes 和云原生中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 和云原生的出现至今已经将近十年了，在这段时间内，我们见证了软件基础设计领域的项目与创新的寒武纪大爆发。在实验与深夜努力中，我们认识到了生产中大规模运行这些系统时，有什么是可行的，又有什么是不可行的。在这些基础项目和关键经验的帮助下，平台团队开始将创新带向了堆栈，但堆栈能跟得上他们的速度吗？&lt;/p&gt;
&lt;p&gt;随着应用设计开始向以 API 为驱动的微服务转变，以及基于 Kubernetes 的平台工程、网络、安全的兴起，Kubernetes 对传统网络和安全模式的打破，让团队追赶的步伐变得吃力。上云的转变至少让我们见证了相似技术的海量变化，但 Linux 将“云上”打包，开启世上最为流行的服务，则是完全改写了数据中心基础设施和开发者工作流程的规则。我们如今所处的境况也是类似，云原生领域基础设施的出现如雨后春笋，不是人人都清楚这股潮流前进的方向，看看 &lt;a href=&#34;https://landscape.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 的情况&lt;/a&gt;就知道了；我们的服务通过 Linux 内核上的分布式系统与彼此通信，但其中许多功能和子系统在设计之初就没有考虑到云原生。&lt;/p&gt;
&lt;p&gt;基础设施软件的未来十年将由平台工程师来定义，他们将利用这些基础设施构件，正确地为更为高层的平台搭建抽象。建筑工程师利用水电、建筑材料搭建供人类使用的建筑，而平台工程师则利用硬件和软件基础设施，搭建可用开发者安全可靠地部署软件，在大规模下仍能以最小劳动量频繁且可预测地进行高影响力改动的平台。对于云原生年代的下一步发展，平台工程师团队必要能提供、连接且可观察的可扩展、动态、可用且高性能的环境，让开发者能全心全意集中于业务代码逻辑。许多支撑这类工作负载的 Linux 内核构件都已经有十多年的历史了，它们需要新的抽象才能跟得上云原生世界的需求。但好消息是，这些构件已经能满足上诉的诉求，并也已经在最大规模的生产环境中经过了多年的验证。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 通过允许开发者们以安全、高性能、可扩展的方式动态编程内核，从而创建了云原生抽象和云原生世界所需的新构件。在不修改内核源码或加载内核模块的前提下，eBPF 可安全且高效地扩展云原生和内核的其他功能，将内核本体从单体应用转换至具备丰富云原生环境的多模块化架构，从而解锁了创新。这些能力允许我们安全地抽象 &lt;a href=&#34;https://kernel.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 内核&lt;/a&gt;，并以紧密的反馈循环对这一层进行迭代和创新，从而准备好进入云原生的世界。随着 Linux 内核新能力的加入，平台团队已经具备进入云原生世界后的第二步，他们或许也在不知不觉中在项目里采用了 eBPF。这四一场无声的 eBPF 革命，重塑着平台与云原生世界的形象，而在本文中，我们将讲述它的故事。&lt;/p&gt;
&lt;h2 id=&#34;出于兴趣和利润的数据包过滤扩展&#34;&gt;出于兴趣和利润的数据包过滤扩展&lt;/h2&gt;
&lt;p&gt;自从&lt;a href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1992&lt;/a&gt;年的 BSD 数据包过滤（BPF）起，eBPF 这项技术已经有了数十年了历史。在当时，Van Jacobson 试图对网络问题进行诊断，但当年现有的网络过滤都过于缓慢，为此，他的实验室设计并创建了 libpcap、tcpdump。以及 BPF 为所需功能提供后端。BPF 的设计使其能快速、高效，且易于验证地在内核中运行，但其功能仅仅包含对 IP 地址和端口号等简单数据包的头字段进行只读过滤。随着时间的推移和网络技术的发展，“经典”BPF（cBPF）的局限性更为突出，具体来说，它的无状态性导致其在复杂数据包操作上束手束脚，对开发者而言也是难于扩展。&lt;/p&gt;
&lt;p&gt;尽管限制重重，这种围绕 cBPF 的高层级概念仍是为将来的创新提供了灵感和平台，即通过一个最小可验证指令集允许内核证明用户所提的应用程序安全性，并能够在内核中运行这些程序。在 2014 年，一项新技术&lt;a href=&#34;https://lore.kernel.org/netdev/1396029506-16776-1-git-send-email-dborkman@redhat.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;加入&lt;/a&gt; Linux 内核，极大地扩展了 BPF（“eBPF”因此得名）的指令集，为我们带来了一个更为灵活且更为强大的版本。在最初，取代内核中的 cBPF 引擎并不是目标，因为 eBPF 是通用的概念，可被用于网络之外的许多地方。但在当时，将这项新技术融入主流内核的确是一条可行的道路，这也是 &lt;a href=&#34;https://lore.kernel.org/lkml/alpine.LFD.2.00.1001251002430.3574@localhost.localdomain/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linus Torvalds 这段话&lt;/a&gt;的背景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;和疯子们一起工作对我来说不是问题，他们只需要用不那么疯狂的论点短小精悍地向我推销他们的疯狂想法。在我问他们要杀手级功能时，我希望他们能说服我这些推销的东西首先要对主流来说的确有用。换句话说，任何疯狂的新功能都应该被牢牢包裹在一个“特洛伊木马”中，第一眼看上去至少要明显觉得不错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，这段话是对 Linux 内核开发模式中“根本”机制的描述，与 eBPF 融入 Linux 的方式不谋而合。为实现增量形式的优化，第一步自然是取代内核中 cBPF 的基础设施以提高其 i 性能，随后再一步步地在其基础上暴露并改进全新的 eBPF 技术。自此之后，早期的 eBPF 发展有了两条并行前进的路线，即网络与跟踪。以 eBPF 为中心的每一个被合并至内核的新功能都解决了这类用例下的切实生产需求，这一需求至今仍然适用。而 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt;、&lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt;,、&lt;a href=&#34;https://github.com/cilium/cilium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt; 等项目则是早在 eBPF 生态系统搭建成功并成为主流之前，变开始协助塑造了 eBPF 基础设施的核心构件。如今的 eBPF 是一项通用技术，可在内核等特权环境中运行沙盒程序，这与“BSD”、“数据包”，或“过滤器”已经没有什么共同点了，如今的 eBPF 只是个缩写的，代指操作系统内核根据用户需求安全地扩展和定制的技术革命。&lt;/p&gt;
&lt;p&gt;具备运行复杂但安全程序能力的 eBPF 已经是一个极为强大的平台，可用堆栈更为高层的云原生环境丰富 Linux 内核，从而执行更优的策略决策、更有效地处理数据、让操作与其源头更为接近，也更为迅速地进行迭代和创新。简言之，我们将不再是修补、重构，或是推出新内核变动，而是削减基础设施工程师们的反馈循环，让 eBPF 程序可以在无需重启服务或中断数据处理的情况下进行即时更新。eBPF 的多功能性也使其在网络之外的其他领域也有应用，在安全、可观察性、跟踪等方面，eBPF 可被用于实时监测并分析系统事件。&lt;/p&gt;
&lt;h2 id=&#34;加速中的内核实验与进化&#34;&gt;加速中的内核实验与进化&lt;/h2&gt;
&lt;p&gt;从 cBPF 向 eBPF 不仅改变了我们的现状，也影响了我们即将构建的。从简单的数据包过滤发展到通用沙盒运行时，eBPF 在网络、可观察性、安全性、跟踪和剖析方面开创了许多新用例。作为 Linux 内核中的通过计算引擎，eBPF 允许我们对内核中发生的任何事情挂钩、观察，并采取行动，与网页浏览器中的插件很是类似。其中的一些关键功能设计允许了 eBPF 对创新能力的加速，从而为云原生世界创建性能更强的可定制系统。&lt;/p&gt;
&lt;p&gt;首先，eBPF 能够挂钩在内核中任何地方，并修改功能和自定义行为的是不需要对内核源码修改的，这意味着从用户提出需求到具体实施的时间将从以年为单位缩减为几天。由于 Linux 内核被数十亿的设备所广泛采用，导致上游的改动并不轻松。举例来说，假设我们想要一个观察应用的新方式，并能够从内核中提取指标，那么我们首先要做的是说服整个内核社群这个主意不错，并且是对所有运行 Linux 的人而言都不错，然后才能开始实施，并最终在几年后才能真正用得上这个功能。但随着 eBPF 的出现，我们能直接不重启机器就把这个观察功能写成代码，并在不影响其他人的前提下根据自身特定的工作负载需求对内核定制化。“eBPF 非常有用，其真正强大的点在于它能让人们自行定制化代码，除非特地要求否则这些代码是不会被启用的，”&lt;a href=&#34;https://www.zdnet.com/article/linus-torvalds-talks-about-coming-back-to-work-on-linux/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linus Torvalds&lt;/a&gt; 说。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/3f/3fc8f67cf709d9fa309bdb4f249eb8ea.jpeg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;图配文：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序开发者：我想要这个功能观察我的应用&lt;/li&gt;
&lt;li&gt;—— 哈喽，内核开发者！请把这个新功能加到 Linux 内核中！—— 好啊，给我一年时间让我说服整个社群这是个对所有人都好的功能&lt;/li&gt;
&lt;li&gt;一年后…… 完事了，主流内核已经可以支持了&lt;/li&gt;
&lt;li&gt;但我想把这个加到我的 Linux 版本里……&lt;/li&gt;
&lt;li&gt;五年后…… —— 好消息，我们的 Linux 版本已经可以提供带有你需要功能的内核了—— 但我的需求已经变了啊……&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://static001.geekbang.org/infoq/e5/e5856205f7a256e699f255c35561d2ac.jpeg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;图配文：&lt;/p&gt;
&lt;p&gt;应用开发者：我想要这个新功能观察我的应用&lt;/p&gt;
&lt;p&gt;eBPF 开发者：行！内核现在没有这个功能，让我拿 eBPF 快速搞定&lt;/p&gt;
&lt;p&gt;几天后……&lt;/p&gt;
&lt;p&gt;这个是我们包含这个功能的 eBPF 项目版本，顺带一提，你还不用重启机器&lt;/p&gt;
&lt;p&gt;其次，由于对程序执行的安全性验证，eBPF 的开发者们可以在无需担忧内核崩溃或其他不稳定因素而继续进行创新。开发者和最终用户都能更自信地说自己送上生产的代码是稳定且可用的。对平台团队和 SRE 而言，使用 eBPF 也是安全地在生产环境中排障的关键因素。&lt;/p&gt;
&lt;p&gt;在应用程序准备投产时，eBPF 程序无需中断工作负载或重启节点便可添加至运行时，从而极大地减轻了平台更新维护所需的工作量，也减少了因版本更新出错导致工作负载中断的风险，这对大规模项目而言是个极大的好处。JIT 编译让 eBPF 程序具备了接近本地的执行速度，将上下文从用户空间转移到内核空间则允许用户跳过不需要或未使用的内核部分，进而提升其性能。然而，与用户空间中的完全跳过内核不同，eBPF 仍可利用全部的内核基础设施和构件而不用重新发明轮子。eBPF 可以挑选内核中的最优部分，结合自定义业务逻辑，从而解决特定问题。最后，运行时可修改内核行为以及跳过部分堆栈的能力，为开发者创建了一个极短的反馈循环，进而允许在网络堵塞控制和内核中进程调度等方面进行试验。&lt;/p&gt;
&lt;p&gt;eBPF 从经典的数据包过滤中成长，并在传统用例中进行的的大飞跃，解锁了内核中资源使用优化、添加自定义业务逻辑等许多新的可能性。eBPF 让我们可加速内核创新、创建新抽象、大幅提升性能，不仅缩短了在生产负载中新增功能的时间、风险、开销，甚至在某些情况下让不可能[成为可能](&lt;a href=&#34;https://sessionize.com/download/syahfej~KQRCkDB3zgNUj5nhrujno9.pdf~Borkmann&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://sessionize.com/download/syahfej~KQRCkDB3zgNUj5nhrujno9.pdf~Borkmann&lt;/a&gt; - eBPF innovations in cloud native.pdf)。&lt;/p&gt;
&lt;h2 id=&#34;数据包与日常ebpf-在谷歌meta-和-netflix-的应用&#34;&gt;数据包与日常：eBPF 在谷歌、Meta 和 Netflix 的应用&lt;/h2&gt;
&lt;p&gt;在见识到 eBPF 如此之多的优点后，人们不禁要问了，eBPF 是否能在现实世界中实现？答案是肯定的。Meta 和谷歌坐拥部分世界上最大的数据中心、Netflix 占据互联网流量中的 15%，这些公司都已在生产中使用 eBPF 多年，其结果不言而喻。&lt;/p&gt;
&lt;p&gt;Meta 是第一家将 eBPF 及其负载均衡项目 &lt;a href=&#34;https://engineering.fb.com/2018/05/22/open-source/open-sourcing-katran-a-scalable-network-load-balancer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katran&lt;/a&gt; 大规模投产的公司。自 2017 年起，所有进入 Meta 数据中心的包都是通过 eBPF 处理的，那可是不少猫猫图片呢。Meta 也将 eBPF 用于许多更高级的用例，如最近的调度器效率优化，可将&lt;a href=&#34;https://lore.kernel.org/bpf/20230128001639.3510083-1-tj@kernel.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;吞吐量提升 15%&lt;/a&gt;，对该公司的规模而言这是个极大的提升和资源节约。谷歌也利用 eBPF 的&lt;a href=&#34;https://www.youtube.com/watch?v=XFJw37Vwzcc&amp;amp;t=38s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;运行时安全性和可观测性&lt;/a&gt;处理其多数的数据中心流量，谷歌云的用户也是默认使用基于 eBPF 的数据平面进行联网。安卓操作系统支持了 70%的移动设备，拥有遍布 190 多国家的 25 亿活跃用户，其中&lt;a href=&#34;https://twitter.com/breakawaybilly/status/1640292221772595201&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;几乎所有的网络数据包都接触过 eBPF&lt;/a&gt;。&lt;a href=&#34;https://www.brendangregg.com/Slides/reInvent2019_BPF_Performance_Analysis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix 在很大程度上依赖于 eBPF 对其机群进行性能监控和分析&lt;/a&gt;，而 Netflix 的工程师也创造了 bpftrace 等 eBPF 工具，绘制基于 eBPF 收集器的 On-CPU 和 Off-CPU 火焰图，为生产服务器排障的可见性方面带来了重大飞跃，&lt;/p&gt;
&lt;p&gt;eBPF 的有效性的显而易见的，在过去的十年中一直为“互联网规模”的公司带来大量收益，这些收益也应该转换为其他人所用。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-的演变让云原生速度和规模成为可能&#34;&gt;eBPF 的演变：让云原生速度和规模成为可能&lt;/h2&gt;
&lt;p&gt;在云原生时代初期，GIFEE（谷歌为其他所有人提供的基础设施）是个流行词，但因为不是所有人都在用谷歌或谷歌的基础设施，这个词已经不再热门。人们希望能用简单的解决方案解决问题，这也是 eBPF 脱颖而出的原因。云原生环境是为“在现代且动态的环境中运行可扩展应用程序”，其中可扩展和动态是 eBPF 成为云原生革命所需的内核演变关键。&lt;/p&gt;
&lt;p&gt;Linux 内核一如既往地是云原生平台构建的基础，应用现在只需使用套接字作为数据源和接收器，网络作为通信总线。但云原生所需的是目前 Linux 内核中所无法提供的新抽象，cgroups（CPU、内存处理）、命名空间（net、mount、pid）、SELinux、seccomp、netfiler、netlink、AppArmor、auditd、perf 等等这些构件远比云原生这个名字的出现早诞生了数十年，这些构件不总是在一起使用，有些也不甚灵活，缺乏对 Pod 或任何更高级别服务抽象的认知，且完全依赖 iptables 联网。&lt;/p&gt;
&lt;p&gt;对于平台团队而言，为云原生环境提供的开发者工具，很可能还被囿于这个云原生环境无法被有效表达的盒子里。在未来，没有合适的工具平台团队也将无从下手。eBPF 则是允许工具从无到有地重建 Linux 内核中的抽象概念，而这些新抽象则会解锁下一次云原生创新的潮流，为云原生的革命奠定方向。&lt;/p&gt;
&lt;p&gt;举例来说，传统的网络下，数据包是由内核处理的，经过数层网络堆栈对所有数据包的检查后方能到达目的地。这一过程无疑会带来极高的开销和处理时长，对含有大量数据包的大规模云环境而言则更是如此。与之相反，eBPF 允许在内核中插入自定义代码，并在每个数据包经过网络堆栈时执行，带来了更为有效且更具针对性的网络流量处理，减少开销并提升性能。Cilium 的基准测试表明，从 iptables 切换至 eBPF &lt;a href=&#34;https://cilium.io/blog/2018/04/17/why-is-the-kernel-community-replacing-iptables/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;提升了六倍吞吐量&lt;/a&gt;，从基于 IPVS 的负载均衡器切换至以 eBPF 为驱动，不仅使 &lt;a href=&#34;https://cilium.io/blog/2022/04/12/cilium-standalone-L4LB-XDP/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Seznam.cz&lt;/a&gt; 的吞吐量增加了一倍，CPU 使用率也减少 72 倍。eBPF 不是在旧的抽象概念上缝缝补补，而是实现了巨大优化改进。&lt;/p&gt;
&lt;p&gt;与其前身不同，eBPF 的优化没有仅仅停留在网络层面。作为通用计算环境且可挂载到内核的任何位置，eBPF 的优化也扩展到了可观测性、安全等更多领域。“我认为云原生中安全性的未来将会是基于 eBPF 技术的，这是一种全新且强大的获取内核可见性的方式，过去想做到这一点是很难的，”云原生计算基金会的 CTO &lt;a href=&#34;https://www.infoq.com/news/2023/02/cloudnative-securitycon-na-2023/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Aniszczyk&lt;/a&gt; 说过，“在应用和基础设施监控的交界处，（eBPF）可以为团队提供一个检测、缓解和问题解决的，更为全面的方式。”&lt;/p&gt;
&lt;p&gt;eBPF 以云原生的速度和规模，让人们可以连接、观察并保护应用程序。“随着应用程序逐渐向着以云原生模式为驱动的基于 API 的服务集合，所有应用的安全性、可靠性、可观测性、性能都将从根本上依赖于以 eBPF 为驱动的全新连接层”，Isovalent 的联合创始人 Dan Wendlandt 说，“它将成为新云原生基础设施堆栈中的一个关键层。”&lt;/p&gt;
&lt;p&gt;eBPF 的革命正在改变云原生，而其中最好的部分已经得到了实现。&lt;/p&gt;
&lt;h2 id=&#34;无声的-ebpf-革命已经成为平台的一部分了&#34;&gt;无声的 eBPF 革命已经成为平台的一部分了&lt;/h2&gt;
&lt;p&gt;虽然 eBPF 的好处显而易见，但这种过于底层的形式意味着缺乏 Linux 内核开发经验的平台团队还需要一个更为友好的接口。这也是 eBPF 的魔力所在，eBPF 如今已经在多个运行云原生平台的工具中存在，或许你已经在不知不觉中用过它了。通过任何主流云供应商的 Kubernetes 集群启动，都是通过 Cilium 用到了 eBPF；通过 Pixie 的观测性实施或 Parca 的连续分析，也都用到了 eBPF。&lt;/p&gt;
&lt;p&gt;eBPF 这股强有力的浪潮正在改变软件行业。Marc Andreessen 那句著名的“软件正在吞噬世界”已经被 &lt;a href=&#34;https://blog.cloudflare.com/cloudflare-architecture-and-how-bpf-eats-the-world/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloudflare&lt;/a&gt; 玩笑似地改成了“eBPF 正在吞噬世界”。然而，eBPF 的成功不在于让所有开发者得知其存在，而是在当开发者们对更快的网络、毫不费力的监控及可观测性，以及更易使用且安全的解决方案之中。曾用过 eBPF 编程的开发者可能不足 1%，但却能让其他 99%的人受益。在各类项目和产品通过 Linux 内核上游代码或 Linux 内核模块编写，从而为开发者们提供大幅度的体验优化时，eBPF 将完全占领世界。我们已经踏上了这条通往现实的大路。&lt;/p&gt;
&lt;p&gt;eBPF 彻底改变了现在与将来基础设施平台的构建方式，实现了许多全新的云原生用例，这些用例在过去很难或根本不可能实现。平台工程师能在 eBPF 的帮助下安全且高效地扩展 Linux 内核能力，让快速创新成为可能。为适应云原生世界的需求，新的抽象和构件得以创建，开发人员也能更轻松地大规模部署软件。&lt;/p&gt;
&lt;p&gt;eBPF 的大规模投产已有半个世纪之久，也已被证明是一种安全、高性能、可扩展的动态内核编程方式。悄无声息的 eBPF 革命已经扎根，并在云原生生态系统及其他领域的产品和项目中得到应用。随着 eBPF 的出现，平台团队已做好进入云原生时代下一阶段的准备，他们可以配置、连接、观察并保护可扩展的、动态可用高性能环境，从而使开发人员将精力集中于业务逻辑的编程。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
