<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
    <meta name="google-site-verification" content="google69a5cccb61297807" />
    <meta name="baidu-site-verification" content="cqmZHEleVh" />
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史 1.前言 技术的发展往往是积跬步而至千里的。Linux 从 1992 年诞生，发展至今已经覆盖大小各类的信息基础设施。是什么样的力量让 Linux 能够始终保持发展活力？又该如何" />

  
  <link rel="alternate" hreflang="zh" href="https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E4%BB%8E%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A3%E5%88%B0%E6%88%90%E4%B8%BA%E7%A5%9E%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-ebpf-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E6%BC%94%E8%BF%9B%E5%8F%B2/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css" integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin="anonymous">
    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.0d97305106da5efa530e28b021b4c580.css" />

  




<script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', "G-40NYXJ8823");
</script>


  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E4%BB%8E%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A3%E5%88%B0%E6%88%90%E4%B8%BA%E7%A5%9E%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-ebpf-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E6%BC%94%E8%BF%9B%E5%8F%B2/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@wx-chevalier" />
    <meta property="twitter:creator" content="@wx-chevalier" />
  
  <meta property="og:site_name" content="Next-gen Tech Edu" />
  <meta property="og:url" content="https://ng-tech.icu/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E4%BB%8E%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A3%E5%88%B0%E6%88%90%E4%B8%BA%E7%A5%9E%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-ebpf-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E6%BC%94%E8%BF%9B%E5%8F%B2/" />
  <meta property="og:title" content="2023-从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史 | Next-gen Tech Edu" />
  <meta property="og:description" content="从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史 1.前言 技术的发展往往是积跬步而至千里的。Linux 从 1992 年诞生，发展至今已经覆盖大小各类的信息基础设施。是什么样的力量让 Linux 能够始终保持发展活力？又该如何" /><meta property="og:image" content="https://ng-tech.icu/media/sharing.png" />
    <meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
    
  

  



  

  

  





  <title>2023-从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史 | Next-gen Tech Edu</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="083907457e6e3a1b3a58eb738a0bc3e3" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">Next-gen Tech Edu</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">Next-gen Tech Edu</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/books-gallery"><span>笔记（万篇）</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#knowledge-map"><span>知识图谱</span></a>
          </li>

          
          

          
          <style>
            .dropdown-item{
              display: inline-flex;
            }
          </style>
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>实验室</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/galaxy-home/gh-craft"><span>Craft 方块世界</span></a>
              
                <a class="dropdown-item" href="/galaxy-home/glossary-cards"><span>3D 知识卡牌</span></a>
              
            </div>
          </li>

          
          

          
          <style>
            .dropdown-item{
              display: inline-flex;
            }
          </style>
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>其他阅读渠道</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="https://zhuanlan.zhihu.com/wxyyxc1992"><img style="width:16px;height:16px;display:inline-block;margin-right:8px" src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png"></img><span>知乎</span></a>
              
                <a class="dropdown-item" href="https://segmentfault.com/blog/wxyyxc1992"><img style="width:16px;height:16px;display:inline-block;margin-right:8px" src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png"></img><span>SegmentFault</span></a>
              
                <a class="dropdown-item" href="https://zhuanlan.zhihu.com/wxyyxc1992"><img style="width:16px;height:16px;display:inline-block;margin-right:8px" src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png"></img><span>掘金</span></a>
              
            </div>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        
        
        <li class="nav-item">
          <a class="nav-link js-search" href="#" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link" href="https://github.com/wx-chevalier" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        

        
        
        
        <div></div>
        
        <style>
        @media only screen and (max-width: 600px) {
          .jimmysong-template {
            display: none!important;
          }
        }
        </style>
        
        <li class="jimmysong-template" style="color: white;font-size: 12px;">
          <a href="https://jimmysong.io" style="color: white">By Jimmy Song's Template</a>
        </li>
      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    




<link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css">
<div class="container-xl docs">
  <div class="row flex-xl-nowrap">
    <div class="docs-sidebar">
      <form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <div class="d-flex">
      <span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">
        
          99.参考资料
        
      </span>
      <span><i class="fas fa-chevron-down"></i></span>
    </div>
  </button>

  
  <button class="form-control sidebar-search js-search d-none d-md-flex">
    <i class="fas fa-search pr-2"></i>
    <span class="sidebar-search-text">搜索...</span>
    <span class="sidebar-search-shortcut">/</span>
  </button>
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  
  
  
  

  
  
    

    
      

      <ul class="nav docs-sidenav">
        <li style="display: inline-flex">
          <a style="cursor: pointer;" onclick="window.history.back()">
            <i class="fas fa-arrow-left pr-1"></i>
            Back
          </a>
          <span>|</span>
          <a href="/books/">
            <i class="fa-solid fa-house" style="margin-right: 4px"></i>
            Books
          </a>
        </li>
      </ul>

      
      
        
          
        
      



  
    
    
    
    
      
    
    

    
    
    
    
    
    <div class="docs-toc-item has-child">
    <div class="parent-node d-flex justify-content-between" onClick="Collapse(&#34;caret-id19acbd953816cbc14016660921997130&#34;)" href="#id19acbd953816cbc14016660921997130" aria-expanded="false" aria-controls="id19acbd953816cbc14016660921997130" aria-hidden="false" data-toggle="collapse">
    
    <a class="d-inline docs-toc-link " href="/books/linux-notes/04.ebpf/">04.eBPF</a>
    <a class="nav-toogle d-inline level" aria-hidden="false" data-toggle="collapse" href="#id19acbd953816cbc14016660921997130" aria-expanded="false" aria-controls="id19acbd953816cbc14016660921997130">
    
    <i class="fa-solid fa-angle-down" id="caret-id19acbd953816cbc14016660921997130"></i>
    
    </a>
    
    </div>
    
      
      <ul class="nav docs-sidenav collapse  show " id="id19acbd953816cbc14016660921997130">
      



  
    
    
    
    
      
    
    

    
    
    
    
    
    <div class="docs-toc-item has-child">
    <div class="parent-node d-flex justify-content-between" onClick="Collapse(&#34;caret-id0d91602dee77ae89e93b3b87613b8760&#34;)" href="#id0d91602dee77ae89e93b3b87613b8760" aria-expanded="false" aria-controls="id0d91602dee77ae89e93b3b87613b8760" aria-hidden="false" data-toggle="collapse">
    
    <a class="d-inline docs-toc-link " href="/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">99.参考资料</a>
    <a class="nav-toogle d-inline level" aria-hidden="false" data-toggle="collapse" href="#id0d91602dee77ae89e93b3b87613b8760" aria-expanded="false" aria-controls="id0d91602dee77ae89e93b3b87613b8760">
    
    <i class="fa-solid fa-angle-down" id="caret-id0d91602dee77ae89e93b3b87613b8760"></i>
    
    </a>
    
    </div>
    
      
      <ul class="nav docs-sidenav collapse  show " id="id0d91602dee77ae89e93b3b87613b8760">
      



  <li class="child level active"><a href="/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E4%BB%8E%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A3%E5%88%B0%E6%88%90%E4%B8%BA%E7%A5%9E%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-ebpf-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E6%BC%94%E8%BF%9B%E5%8F%B2/">2023-从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史</a></li>




  <li class="child level "><a href="/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E6%97%A0%E5%A3%B0%E7%9A%84%E5%B9%B3%E5%8F%B0%E9%9D%A9%E5%91%BDebpf-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E6%A0%B9%E6%9C%AC%E4%B8%8A%E6%94%B9%E9%80%A0%E4%BA%91%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0%E7%9A%84/">2023-无声的平台革命：eBPF 是如何从根本上改造云原生平台的</a></li>

      
        </ul>
      
    

    
      </div>
    

      
        </ul>
      
    

    
      </div>
    

    
  
</nav>

    </div>

    
    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      
     
      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">目录</a></li>
      </ul>
     

      <nav id="TableOfContents">
  <ul>
    <li><a href="#1前言">1.前言</a></li>
    <li><a href="#2ebpf-技术概览">2.eBPF 技术概览</a>
      <ul>
        <li><a href="#21实现原理">2.1.实现原理</a></li>
        <li><a href="#22技术特点">2.2.技术特点</a></li>
        <li><a href="#23应用价值">2.3.应用价值</a></li>
      </ul>
    </li>
    <li><a href="#3ebpf-技术发展溯源">3.eBPF 技术发展溯源</a>
      <ul>
        <li><a href="#31石器时代">3.1.石器时代</a></li>
        <li><a href="#32铁器时代">3.2.铁器时代</a></li>
        <li><a href="#33蒸汽时代">3.3.蒸汽时代</a></li>
        <li><a href="#34电气时代">3.4.电气时代</a></li>
        <li><a href="#35智能时代">3.5.智能时代</a></li>
      </ul>
    </li>
    <li><a href="#4内在驱动">4.内在驱动</a>
      <ul>
        <li><a href="#41代码规模问题">4.1.代码规模问题</a></li>
        <li><a href="#42软件结构的复杂">4.2.软件结构的复杂</a></li>
        <li><a href="#43业务系统的复杂">4.3.业务系统的复杂</a></li>
        <li><a href="#44维护限制的要求">4.4.维护限制的要求</a></li>
      </ul>
    </li>
    <li><a href="#5ebpf-技术的意义">5.eBPF 技术的意义</a>
      <ul>
        <li><a href="#51图灵完备性">5.1.图灵完备性</a></li>
        <li><a href="#52编程模型的发展">5.2.编程模型的发展</a></li>
        <li><a href="#53用户态比重的加大">5.3.用户态比重的加大</a></li>
        <li><a href="#54微内核">5.4.微内核</a></li>
        <li><a href="#55观测代码与业务代码合一">5.5.观测代码与业务代码合一</a></li>
        <li><a href="#56编译器和内核合一">5.6.编译器和内核合一</a></li>
      </ul>
    </li>
    <li><a href="#6走向未来">6.走向未来</a>
      <ul>
        <li><a href="#61通用性">6.1.通用性</a></li>
        <li><a href="#62表达能力">6.2.表达能力</a></li>
        <li><a href="#63开发工具">6.3.开发工具</a></li>
        <li><a href="#64开发流程">6.4.开发流程</a></li>
      </ul>
    </li>
    <li><a href="#7结束语">7.结束语</a></li>
  </ul>
</nav>

      
<div class="subscribe-module col-24 mt-1">
    <img src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png" alt="image" title="王下邀月熊的微信公众号"/>
</div>



    </div>
    

    <main class="py-md-3 pl-md-3 docs-content col-xl-8" role="main">

      <article class="article">

          

          <h1>2023-从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史</h1>

          <div class="article-style">
            <h1 id="从石器时代到成为神一文讲透-ebpf-技术发展演进史">从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史</h1>
<h2 id="1前言">1.前言</h2>
<p>技术的发展往往是积跬步而至千里的。Linux 从 1992 年诞生，发展至今已经覆盖大小各类的信息基础设施。是什么样的力量让 Linux 能够始终保持发展活力？又该如何看待 Linux 之上出现的新的技术趋势？</p>
<p>本文试图通过梳理<a href="https://www.infoq.cn/theme/181" target="_blank" rel="noopener">eBPF</a>的演进过程，探索 Linux 内核的发展动力来源与发展轨迹，与大家一同畅想 eBPF 给内核技术、Linux 生态带来的全新变局。</p>
<h2 id="2ebpf-技术概览">2.eBPF 技术概览</h2>
<h3 id="21实现原理">2.1.实现原理</h3>
<p>大家可能都知道图灵机，这是一个可计算理论模型，可以用来判断计算机的计算能力。图灵机是目前有可能实现的计算能力最强的理论模型，目前我们常用的计算机，理论上都是等价于图灵机的。</p>
<p>BPF 的出现是对计算能力的渴求，其原理就是通过 IR 模拟一台 RISC 指令集的计算机嵌入到内核中，将内核内部的静态编译逻辑转变为更加灵活的动态编译逻辑，使内核获得近似于图灵机的动态逻辑定制能力。而从 classic BPF 到 extended BPF 的发展，是将这一计算方式进一步夯实和通用化。</p>
<p>BPF 的出现乃至到 eBPF 的进一步发展，为内核带来了巨大的改变，使内核具备了更加强大、可编程的动态变化的能力。<strong>这种能力在各种需要定制化的应用场景中，将发挥巨大的价值，既可以用于扩展功能，也可以用于优化性能。</strong></p>
<p>在实现上，为适应不同业务场景的需求，使 eBPF 具备等价于一台 RISC 指令集计算机的计算能力，通过输入参数、Map 数据存储、Helper 帮助函数，构成了 eBPF 程序与内核交互的运行环境。eBPF 指令集的计算和控制能力、运行环境与内核的交互能力，两者叠加构成了 eBPF 程序强大的处理能力。</p>
<p>在安全方面，通过 Verifier 严格检查 eBPF 程序的可完成性、数据访问的合法性等，保证了 eBPF 程序与内核交互过程中内核不被挂起、核心数据不会被破坏。</p>
<p>在 BPF 发展过程中，由 cBPF 发展成为 eBPF 是一次大的技术升级。eBPF 在 cBPF 的基础上重新设计了指令集、引入了 JIT、增加了辅助函数，大大扩展了复杂逻辑的设计能力。虽然 eBPF 有巨大的进步，但是基本的底层设计还是一致的，因此两者统称为 BPF。</p>
<p>由于 eBPF 兼容 cBPF，在未指定时，BPF 更多指 eBPF 所定义的内涵。后文用 BPF 泛指整个 BPF 相关的基础机制，eBPF 特指最新的 BPF 标准。</p>
<h3 id="22技术特点">2.2.技术特点</h3>
<p>BPF 还在快速发展，它的计算能力和完备性也在迅速提高，前景无限。但就具体的版本而言，却又呈现具体技术特点，主要是其支持的能力和受到的约束两个方面。下面以最新的 BPF 技术标准(v6.1)为蓝本，介绍 BPF 的主要技术特点。</p>
<p><strong>RISC 指令集</strong></p>
<p>BPF 的核心是一个虚拟计算机，它采用类 RISC 指令集，支持跳转、算数运算、尾调用等基本操作。在运行 BPF 程序的计算机上，BPF 指令会被内核的 JIT 编译器动态编译为物理机原生指令，实现运行效率的“零”损耗。在支持 BPF 卸载的设备上，BPF 程序也可以卸载到设备上执行。在 BPF 的指令集中还支持伪调用指令，可以调用到内核帮助函数。</p>
<p>同时，BPF 的指令的编码空间中还有大量的储备，未来根据需要一定还会继续增加指令，提升 BPF 实现复杂逻辑的能力。</p>
<p><strong>Map</strong></p>
<p>基于键值对的数据存储机制，可用于实现内核、用户态的数据存储和交换。</p>
<p><strong>Helper 函数</strong></p>
<p>专用于 BPF 程序调用的函数接口，用于封装内核中的功能，使 BPF 程序可以和内核互操作，同时保持 BPF 程序和内核的安全隔离。</p>
<p><strong>BPF 子程序</strong></p>
<p>实现了 BPF 程序之间的调用。</p>
<p><strong>上下文</strong></p>
<p>BPF 程序的语境和运行上下文，是一种内部透明的数据结构。只有在明确 BPF 程序的类型时，上下文的定义和内部数据结构才是确定的。不同的 BPF 程序类型，上下文也各不相同。</p>
<p><strong>CO-RE</strong></p>
<p>通过运行时类型支持，实现一次编译、随处运行。</p>
<p><strong>支持特权和非特权级两类运行模式</strong></p>
<p>分为特权级（百万 ins）和非特权级（4096ins）两类运行方式。特权级模式下 BPF 程序可以获得更宽的权限，实现更复杂的逻辑功能。</p>
<p><strong>保证向后兼容</strong></p>
<p>这一原则对于 BPF 的推广应用非常重要，可以保证旧标准的 BPF 程序在新标准下也可以正确执行。但同时，也对未来 BPF 发展带来了约束，只有把握好 BPF 的发展方向，做好底层设计，才能两者得到兼顾。</p>
<p>比如，从老版本遗留下来的 cBPF 程序在 eBPF 中都会被 JIT 正确翻译和执行。</p>
<p><strong>稳定的 ABI</strong></p>
<p>BPF 稳定的 ABI 包括，BPF 程序类型对应的输入参数定义，可调用的内核帮助函数定义，返回值定义等。使用稳定的 ABI 的 BPF 程序，可保证与不同版本的内核都是兼容的。</p>
<p>另外，BPF 还在快速发展中，它的功能特性需要逐步释放，因此目前还有诸多限制，其中有些是基于安全、可靠性考虑，有些是没有超出范围的应用需求的保守设计等等。随着安全机制的完善、应用程序的扩展、生态体系的成熟，相应的限制也会逐步的改变。</p>
<p>目前的实现中，有如下限制：</p>
<ul>
<li>总运行时间有界：有界性这是基本原则，应该在比较长的时间内都不会改变。但是，在不改变有界性的前提下，根据具体需要适当调整更合理的上限，这是存在极大可能的。</li>
<li>指令总数限制：非特权用户最大指令数 4096，特权用户最大指令数 1 百万。</li>
<li>分支数限制。</li>
<li>BPF 调用嵌套层次限制。</li>
<li>Map 实例数限制。</li>
<li>验证状态数限制。</li>
<li>最大分支数限制。</li>
<li>堆栈长度限制：目前支持的堆栈最大长度为 512 字节。</li>
<li>上下文限制：每一种类型的 BPF 程序，都有其对应输入参数定义，彼此不同。也就是说，BPF 程序只能接受特定的输入并进行处理，不能访问内核的全部状态空间。</li>
<li>辅助函数限制：每一个 BPF 程序类，都有其对应的辅助函数集合。这些辅助函数，由内核各子系统提供，是 BPF 程序类上下文的一部分。它们帮助 BPF 程序与内核各子系统交互，同时又保护内核不会被破坏。</li>
</ul>
<p>上面赘述了很多特性，大家可能会有很多疑问，比如：为什么采用精简指令集呢？因为这是目前最主流的指令集类型，相对于复杂指令集，精简指令集更有利于实现更高密度、更高吞吐量、更高主频的处理器。因此 x86 之后出现的新型指令集系统，绝大多数都是精简指令集，包括现在的开源指令集 RISC-V。另外也有人会问，为什么不采用原生的指令集呢？为什么 5 个参数寄存器呢？本篇暂不深入讨论，后续主题涉及到的时候再详细讲解。</p>
<h3 id="23应用价值">2.3.应用价值</h3>
<p>BPF 的应用价值与其动态和可定制特性强相关。内核研发中一直坚守的原则是：“机制与策略分离”，即：内核负责提供机制，将策略开放给上层。在机制与策略之间需要一层界面来进行交互。系统调用是最初方案。它是单向发起的，缺少事件模型。虚拟文件系统，提供了双向的交互方式，但难以灵活定制复杂的逻辑。</p>
<p>由于软件功能越来越复杂，无法用简单规则来表达，软件的基础功能设施与业务逻辑，需要进行解偶。而业务逻辑部分，需要根据业务定制，因此很适合用 BPF 实现。比如：过滤器、权限检查、模糊测试等类型的功能，比较适合用 BPF 实现。另外，视具体问题，也可以应用于调度算法、用户态交互（替代系统调用，实现更加可变的服务逻辑）、加载器、模拟器、兼容层、轻量化内核、多态内核、启动方式。</p>
<p>每一种业务类型都有其独具特征的逻辑模型，通过更形式化地定义这些业务模型，可以更好地理解它们和 BPF 的结合性，找到更好的实现方案，充分发挥 BPF 带来的强大能力。后续篇章，我们会对典型的应用模型进行更深入的讨论，以及 BPF 在这些应用场景中，应该在哪些特性方面进行加强或改进。</p>
<h2 id="3ebpf-技术发展溯源">3.eBPF 技术发展溯源</h2>
<p>回顾技术的发展过程，就像观看非洲大草原日出日落一样，宏大的过程让人感动，细节部分引人深思。每天循环不辍，却又每天不同。</p>
<p>BPF 的应用早已超越了它最初的设计，但如果要追溯 BPF 最初的来源，则必须回归到它最初的应用领域，再进行理解分析。BPF 最初的用途在于观测，最初用于网络报文的抓取和分析。因此 BPF 的最初、最根本的来源，是作为一种观测手段出现的。而在这个领域中，技术的演进迭代，是一个很长的过程，体现了内核技术发展的艰辛、也同时充满了趣味。</p>
<p>如果把内核看作一个世界，在这个广袤的土地上，观测技术的发展，也同样经历了从蒙昧到现代的发展过程。每个时代都有其独具特色的观测技术，它决定了当时的开发人员需要具备什么样的功底，什么样的开发方式，这构成了一个时代特色，也谱写了时代的故事。</p>
<p>而每次时代的更迭，总是在某些方面颠覆了或者突破了传统的思维，从而引发了观测方式的巨大进步，促进了效率和可观测性的提升。对现有技术的深入研究与颠覆性的思想所构成的创新，是技术领域演进的基本形式。而其创新的动力又是什么呢？我们在后文逐步揭示。</p>
<h3 id="31石器时代">3.1.石器时代</h3>
<p>曾几何时，内核的开发还在初始阶段，由于内核的原理复杂、所处的位置特殊，开发方式和用户态有很大不同。内核开发难度远远大于用户态的应用开发，尤其调试比较困难。犹记得那时对于内核是否引入 GDB 调试机制，有过一些争论。其分歧点就在于，引入过于复杂的机制会改变内核的行为特性，影响问题的稳定性，反而不利于问题的分析定位。</p>
<p>那时最值得信赖的工具就是 Printk。这是一种低介入的观测工具，使用简单，几乎可以用于任何地方，帮助开发人员观测内核的运行状态。但显著的缺点是不够灵活，如果问题涉及的逻辑路径比较长、分支比较复杂的话，需要反复多次才能定位问题的根源。因此，那时候对内核开发人员的一个必不可少的要求，就是对所负责子系统的实现原理和代码逻辑的熟悉程度需要非常高，能够根据比较少的观测信息，准确定位问题的根源。</p>
<p>事物总是存在两面性，就像当初产生的那场争论一样，Printk 除了基本的信息输出机制外，几乎没有提供任何强有力的特性。这固然体现了当时的技术水平还在比较原始的阶段（没错，就像是石器时代），但同时也倒逼当时的内核开发人员超强的代码理解和分析能力，以便弥补简陋的工具对效率的掣肘，更快地解决程序中的 BUG。</p>
<p>另一方面，客观地讲，Printk 固然简单，卓尔无往不利。它可以使用在任何地方，具有完全的上下文访问能力，不受约束的表达能力。它的观测能力和程序本身完全相等，程序本身能看到什么，它就能看到什么，可以说是强大到巅峰。这种强大也是其无法被取代的根本原因，尽管内核的调测技术不断在发展，这一点始终未被超越。它可以用任何线性的文本形式，输出开发人员关注的上下文信息。在后来，这种表达能力得到了进一步发展，支持了部分正则文法。</p>
<p>它的缺点在于缺乏交互性，任何一点改变都需要修改程序。另一方面，不管上层流程是否被关注，它的信息都会被输出，大大影响了性能。</p>
<p>Printk 可以说是最强大的工具，至今我也是这样认为。但它同时也是最粗糙的工具。就像石头一样，prink 随处可见，随处可用，用了就一定有所得。简单、强大、直接。但是同样像石头一样，如果用得多了，就会成为垃圾。</p>
<p>Printk 相比于 BPF，拥有完全不受限制的上下文访问能力，使用的地方几乎没有限制，仅从观测的角度，强大之处有过之而无不及。但是使用方式过于原始，缺乏工业化的扩展能力，因此如果在更长的时间尺度、更广的应用领域来看的话，Printk 无法和 BPF 相提并论。</p>
<h3 id="32铁器时代">3.2.铁器时代</h3>
<p>在石器时代，人们使用石头磨制的工具进行生产，这些工具粗糙、非标准化、材质原始容易损坏，笨重、使用寿命短。Printk 也是一样，每次执行时都会输出信息，但大多数时候是不需要的；寿命短，每次改变需要修改代码。</p>
<p>随着内核越来越成熟，架构设计、模块划分、内部功能等等都越来越规范合理。内核的特性，由各个子系统分别负责，内核的整体表现是各个子系统行为表现的综合。而子系统内部的关键路径，决定了子系统主要的行为表现，比如：调度系统中的 CPU 时间统计、上下文切换，迁移等等；内存管理系统中的内存分配、NUMA 平衡；虚拟内存中的页面错误、交换次数等等。</p>
<p>随着内核设计的规范化，其内部的关键节点和呈现在外部的语义都越来越清晰和标准化。要掌握内核的运行状态，其实并不需要随处观察，只需要掌握几个关键节点、关键信息就可以了。</p>
<p>以关键变量为基础，工具得以升级；以语义规范化为基础，为交互式的观测机制提供了基础。至此，观测手段不再是单纯的信息输出，它也可以反过来影响系统行为实现多维度的观测。</p>
<p>虚拟文件系统 Proc 首先打通了用户态和内核态的交互通道，从原来只能控制日志级别，到可以控制数据本身，可以控制的范围更广、更深了；从文本交互，转换为二进制交互，内核性能受到的影响进一步降低。提供了标准化的 API、类型的支持，降低了开发难度，便于推广使用。提炼出关键参数，通过虚拟文件系统进行交互式的系统观测，反过来有利于内核的规范化。</p>
<h3 id="33蒸汽时代">3.3.蒸汽时代</h3>
<p>Proc 的定义很大一部分还是与具体的上下文相关，并不适合大批量的使用。而 Trace 定义了协议规范，抽象层次更高，可以批量使用。</p>
<p>Trace 是一个更加纯粹的观测机制，给用户提供了通用简单的接口，底层实现了很丰富的机制。可以支持大量使用，对于可观测性的提升起到了根本性的推动。可以批量重复使用，这是它和其他观测方式的区别。</p>
<p>如果说 Proc 采用了代码数据化的思想，那么 Trace 采用很多元编程的思想，极大简化了外部接口，减少了重复代码。</p>
<h3 id="34电气时代">3.4.电气时代</h3>
<p>Trace 机制固然好用，只要预先铺设了基础设施，运行时就可以随时开启观测。但缺点是，对于没有铺设铁轨的地方，火车的承载能力再强也是无法到达的。</p>
<p>Trace 的机制很通用，但另一方面，它无法深入业务层面进行更进一步的调测。要实现这一点，需要完整的上下文能力和可编程能力，因此 kprobe 出现了。只要由函数的地方，就像通了电一样，随时可以点亮，这是 Kprobe 强于 Trace 的覆盖能力。能够完整访问函数上下文，这是 Kprobe 强于 Trace 的业务理解能力。</p>
<h3 id="35智能时代">3.5.智能时代</h3>
<p>Kprobe 是动态性的萌芽，但是存在很多不足。它在内核态运行需要对内核编程有一定了解，编程门槛较高。此外，它还存在安全性问题、可扩展性问题，等等。</p>
<p>从计算能力来说，所有图灵机的计算能力是相等的，要解决能力问题，最终是要实现一个虚拟机的。而在内核态实现一个虚拟机，所涉及到的安全问题是必须考虑的，通过 Verifier 和运行时 Helper 函数，做到了逻辑约束和上下文隔离。虚拟机、Verifier 和 Helper 函数，是 BPF 和 Kprobe 的根本区别。</p>
<table>
<thead>
<tr>
<th style="text-align:left">工具</th>
<th style="text-align:left">观测能力</th>
<th style="text-align:left">交互性</th>
<th style="text-align:left">使用范围</th>
<th style="text-align:left">修改内核</th>
<th style="text-align:left">可编程</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Printk</td>
<td style="text-align:left">可见上下文</td>
<td style="text-align:left">单向</td>
<td style="text-align:left">任意</td>
<td style="text-align:left">需要</td>
<td style="text-align:left">可以</td>
<td style="text-align:left">日志</td>
</tr>
<tr>
<td style="text-align:left">proc</td>
<td style="text-align:left">预定义</td>
<td style="text-align:left">双向</td>
<td style="text-align:left">关键参数</td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">不可以</td>
<td style="text-align:left">固定观察窗</td>
</tr>
<tr>
<td style="text-align:left">trace</td>
<td style="text-align:left">预定义</td>
<td style="text-align:left">单向</td>
<td style="text-align:left">关键流程</td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">不可以</td>
<td style="text-align:left">动态观察窗</td>
</tr>
<tr>
<td style="text-align:left">kprobe</td>
<td style="text-align:left">函数边界</td>
<td style="text-align:left">双向</td>
<td style="text-align:left">任意函数</td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">可以</td>
<td style="text-align:left">动态逻辑</td>
</tr>
<tr>
<td style="text-align:left">BPF</td>
<td style="text-align:left">trace+kprobe+预定义</td>
<td style="text-align:left">双向</td>
<td style="text-align:left">任意函数+预定义</td>
<td style="text-align:left">不需要</td>
<td style="text-align:left">可以</td>
<td style="text-align:left">虚拟机</td>
</tr>
</tbody>
</table>
<h2 id="4内在驱动">4.内在驱动</h2>
<p>由以上简要的回顾和梳理可见，内核开发者们所不断寻找的是一种充分表达能力的动态机制，进而打破内核和用户态的壁垒（至少在逻辑层面），从而实现一种自由、直接的需求实现。技术成为内核开发者们锋利的工具，不断突破限制，揭示事物的本质。</p>
<p>BPF 技术的出现和发展，从时间尺度来说并不长，但是从其内在的驱动来说，有着复杂的动因，是很多因素就和在一起的必然结果。由于其复杂性，从任何一个孤立的角度进行分析都是不充分，只有从各个不同的角度分析，才可以体会出不同的趣味。</p>
<p>通过探寻其深层次的原因，可以梳理出更加清晰的发展脉络，从而可以更好地展望 BPF 及其相关技术领域的未来发展，为我们学习、研究和加入 BPF 的发展打下基础。</p>
<p>下面，我们试着从复杂性、微内核化两个方面，分析 BPF 发展的内在动力。</p>
<p>内核的发展历史就是一个复杂性不断递增的历史，内核的发展也是不断控制复杂性、维持内核代码的可理解性的过程。因此，内核的开发始终坚持一个原则，就是机制与策略的分离。</p>
<p>在不同时期，如何进行机制与策略的分离，有着不同的答案。随着技术和应用的不断发展，维持这一原则的的难度是不断增加的，需要更新的思想、更先进的技术才能支撑。或者也可以说，正因为内核的发展过程中，始终坚持了这个原则，所以才不断有影响深远的基础技术的出现。</p>
<p>我相信，要实现定制与动态，有很多不同的方案。但我认为 BPF 的出现是最佳的选择，使内核的发展有了应对未来变局的基础。</p>
<p>这是 BPF 出现的契机，也是其未来快速发展的动力。</p>
<h3 id="41代码规模问题">4.1.代码规模问题</h3>
<p>Linux 项目发展至今，其代码总量早已超过千万，是一个非常庞大的项目。</p>
<p>
















  <figure  >
    <div class="d-flex justify-content-center">
      <div class="w-100" ><img src="https://static001.geekbang.org/infoq/18/18002074940e509d0b2338938e35909e.png" alt="img" loading="lazy" data-zoomable /></div>
    </div></figure></p>
<p><em>注：来源</em><a href="https://www.phoronix.com/misc/linux-eoy2019/lines.html" target="_blank" rel="noopener"><em>https://www.phoronix.com/misc/linux-eoy2019/lines.html</em></a></p>
<p>由统计数据可以看出，Linux 项目的复杂度（从代码量角度）一直在不断增长。</p>
<h3 id="42软件结构的复杂">4.2.软件结构的复杂</h3>
<p>整个软件系统，从应用程序到内核是一个繁杂的层次结构，又由于模块之间的交叉，实际的运行流程是一个复杂的有向图结构。</p>
<p>以完成一次简单的文件操作为例，首先应用程序需要 open 一个文件，这首先会运行到某种运行时库，完成资源分配、接口转换等等处理。然后，流程才会到系统调用这一层。系统调用中，由 VFS 解析文件路径信息，找到对应的文件系统信息。再由具体的文件系统完成文件打开的操作。</p>
<p>这其中至少涉及到了应用程序、运行时库、系统调用、VFS、文件系统等多个层次。如果再细分的话，还涉及到用户态内存管理，内核态内存管理、权限管理、命名空间管理、句柄管理、缓存管理、锁、钩子等次级模块。</p>
<p>目前 Linux 支持的文件系统至少已经达到七十多种，有基于本地存储设备的、基于网络的、分布式的、基于内存的、虚拟的等等。有的文件系统在内核态实现，有的在用户态实现。</p>
<p>另外，C 语言的条件编译，可以针对使用场景选择适合的代码编译。每一个条件编译选项就是对现实条件的一个考量。从 Linux 整个源码树中使用的条件编译选项的数量，也可以反映出 Linux 整个源码的复杂度。对 Linux 5.10 的源代码粗略统计，条件编译选项已经多达 18000 多个；而在 6.1 版本中，已经达到了 19000 多个。</p>
<h3 id="43业务系统的复杂">4.3.业务系统的复杂</h3>
<p>在虚拟化技术以前，不同应用场景的业务系统的结构差异，主要表现为平面性的拓扑结构的差异，比如：对等式的、分布式的、客户<a href="https://cloud.tencent.com/product/cvm?from=20067&amp;from_column=20067" target="_blank" rel="noopener">服务器</a>模式的等等，由于网络拓扑结构的不同、节点承担的业务角色的不同，形成了各种各样的业务系统。</p>
<p>在虚拟化技术出现后，云计算迅猛发展，云成为了信息系统的基础设施。业务系统的差异不仅仅体现在横向拓扑结构上，其自身逻辑的深层组成也是非常复杂。它可以运行在真实计算机上也可能在虚拟机上，可能在一个独立的命名空间，也可能和别的业务共享。不同业务模块之间的联系有可能是直接的，也可能在无法感知的情况下被层层嵌套。</p>
<p>**业务系统的复杂性，体现在业务的复杂性与业务系统的复杂性两个方面。**业务的复杂，导致我们需要对业务系统进行分层设计，需要有定制化的能力，需要有运营与持续开发并行的能力。上线前的产品级的开发很重要，但是上线后的业务级的持续定制和开发同样重要。复杂的业务必然导致复杂业务系统的产生，如何以一个统一的、足够强大的方式来解决复杂性问题，使复杂业务系统的复杂性是可以拆解的、可管理的，就非常重要。</p>
<h3 id="44维护限制的要求">4.4.维护限制的要求</h3>
<p>Linux 系统已经规模化运行在各种类型的设备上，每一个商业系统，在其运行期间都是需要进行维护的。</p>
<p>于大型的服务器系统，承载在成千上万的在线业务，是不能中断服务的，需要在线的定制能力。对于个人终端，每个人的使用习惯不同，如何使每个用户都能获得最佳的使用体验，需要数据分析和个性化的定制能力。对于散布在各处角落的边缘节点乃至物联网设备，需要内核提供更智能的介入方法，使维护人员能够远程完成对大量设备的维护工作。</p>
<h2 id="5ebpf-技术的意义">5.eBPF 技术的意义</h2>
<p>BPF 最初来源于解决网络报文过滤的问题，实现灵活的过滤规则。网络报文的过滤规则，最初只需要正则语言就能表达，但后来就不够了。而 BPF 提供了更强大的表达能力，BPF 具有近似图灵完备性，必将成为问题分解、解决复杂问题的神级工具。</p>
<h3 id="51图灵完备性">5.1.图灵完备性</h3>
<p>讨论 BPF 的计算能力，涉及到图灵完备。BPF 目前的基本设计中，有限性是基本设计原则，这是保证内核不被扩展逻辑挂死的基本要求。而有限性，是 BPF 和图灵机的根本差异，因此它不是图灵完备的。这个结论固然没错，但如果讨论仅止于此的话，那么这一论断过于粗糙，换个有趣一点的说法，这样的讨论不是图灵完备的，因此还需要具体分析。</p>
<p>完备性，不是评价工具优劣的完全准则。一般认为，C 语言是图灵完备的。但 C 语言的所有数据类型都是有界的，其实是弱于图灵机的。但不妨碍人们认为 C 是图灵完备的，因为它的能力边界距离实际应用的需求很远，我们感受不到。虽然 C 语言图灵不完备，但是不妨碍它的发展潜力，在它的成长过程中，也在不断的改版、丰富。这是因为它的完备性不足吗？显然不是。一种工具，在工程实践中，完备性是次要的，因为他被选择，就说明它是够用的。其他方面才是当下更应该关注的问题。</p>
<p>图灵机是一种无限的自动机，人们穷尽办法也只能逼近，即使全世界所有计算机加在一起的总和，也弱于图灵机。所以图灵完备现实中根本不存在，讨论逼近图灵机的能力可能更现实。在实际的语境中，人们实际上把无限接近图灵机的逼近能力，等同于图灵完备性。一个很好的例子就是 C 语言，它显然不是图灵完备的，但人们一般认为它是图灵完备。从这点说，BPF 语言同样是图灵完备的。</p>
<p>排除语言的问题，那么 BPF 是图灵完备的吗？仍然不是，**BPF 的图灵不完备，并不主要来源于 BPF 语言本身，而是来源于运行环境。从这点说，BPF 语言是图灵完备的，BPF 虚拟机不是。**从这点也可以说，只要有需要，通过改造运行环境，BPF 可以无限逼近图灵机的计算能力。</p>
<p>因此，从图灵完备这一点，我们既不能过度的否定 BPF，认为它的能力有限。但同时，也不能认为它的能力可以无限扩张，因为需要满足特定的条件。总之，BPF 还在快速发展过程中，一切可能性皆在其中，任何定论皆言之过早。</p>
<p>从另一个角度来看，就 BPF 目前的应用领域而言，输入和状态空间是有限的，因此在有限的输入下，图灵完备并不是必须。这是从现实的需求来说，BPF 足以完成指定语境下的任何计算。</p>
<p>但显然 BPF 的计算能力还有很大的提升空间。</p>
<p>语言方面，BPF 的指令集的提出，在计算能力上，它就是超配的。现在的问题是，如何安全地释放他的能力。运行时系统和工具链的设计，是目前的焦点问题。已经呈现出思想分歧，基于运行时环境的思路和直接开放的思路同时存在。未来这两个思路应该都会有一定程度的发展，形成面向不同领域的高低搭配的解决方案。</p>
<p>因此，我认为运行时的改进可能更加迫切。这需要我们及早确定问题边界，提供面向问题的运行环境，才能更有效的提出平衡安全和可计算性的问题的方案，即：<strong>运行环境+必要的计算能力，构成完备的面向问题域的解决方案</strong>。定义一个安全的虚拟机，保证操作不逃逸，一个安全的运行时库，导出或者链接内核对象（Helper），在这个集合上，定义安全的操作，这样语言本身就可以不再受具体逻辑和访问对象的限制，做到语言本身的图灵完备。</p>
<h3 id="52编程模型的发展">5.2.编程模型的发展</h3>
<p>在 BPF 之前，Linux 开发的编程模型，可以分为内核编程和用户态编程两种。分别使用不同的编程接口和编程规范，是两者最大的区别。BPF 出现之后，出现了新的编程模型，既不能称之为内核编程，也不能称之为用户态编程。</p>
<p>这是一种全新的编程模型。它运行于内核态，但是不使用任何传统的内核接口（5.13 可以调用经过筛选和处理的内核函数。至今，它仍然受限于特定函数和指定的上下文，还不是一种通用的机制。且这种机制进一步通用化之前，它的安全性仍然值得先进一步的讨论），不通过符号与内核进行链接。它使用应用编程逻辑和范式，但是不使用应用编程传统的接口，而是使用 BPF 提供的帮助函数。它所能访问的数据对象还在不断发展过程中，远未定型。</p>
<p>因此，笔者称这种编程模型为：<strong>临界编程</strong>。也许它未来会有更好的名字，但这个名字一方面，表明它的跨界特性，一方面表面它日新月异的发展。也表明对它未来的期待。</p>
<h3 id="53用户态比重的加大">5.3.用户态比重的加大</h3>
<p>由于虚拟化和软件工程的原因，网络报文处理和文件系统，呈现出往用户态迁移的趋势。BPF 和用户态化的共通点和差异点在于，都将更多的内核扩展性放在了用户态，但 BPF 的逻辑仍然从属于内核。</p>
<p>他们都和传统内核通过一层良好定义的接口进行了隔离。用户态驱动和文件系统，使内核的功能更容易扩展。而 BPF 则是对内核本身的扩展。两者存在根本差异，因此也存在相互结合的可能，从而形成更加强大的软件架构。</p>
<p>而这种架构会用于什么地方呢？我们已经做了初步尝试，FUSE 和 BPF 进行结合。可以实现用户态文件系统和内核更加高效的交互（这一话题，我们在后续的篇章中再详细讨论）。推而广之，内核的网络、安全、文件系统、驱动，都可以放在用户态来实现，通过 BPF 来优化交互。</p>
<h3 id="54微内核">5.4.微内核</h3>
<p>BPF 的运行基础是运行时环境，随着 BPF 应用的增加，一定会促使内核子系统的更进一步的抽象和解偶，这在逻辑上为微内核化准备了条件。</p>
<p>BPF 真正避免了纯粹用户态编程的性能问题，为应用开发人员开发特色功能提供了一种临界编程工具。这或许是微内核的另一种实现路径。</p>
<h3 id="55观测代码与业务代码合一">5.5.观测代码与业务代码合一</h3>
<p>BPF 出现的时候，最初是观测工具，但后来它也能用于实现更复杂的功能，影响网络子系统的报文转发逻辑。BPF 计算能力的强大、性能的优势，使它不仅能用于观测还可以做更多复杂的事情。</p>
<p>通过高度抽象化的设计，我们可以设计出复杂、通用的业务系统，但是我们设计不出“最佳”的业务系统。最佳的业务系统一定是在真实的应用场景中，通过不断的观测、分析、优化，才能达成的。</p>
<p>将一个复杂系统优化到“最佳”同样是一个复杂问题，多目标的一致性、动态系统的不稳定性、巨大的状态空间等等，都可能导致这个问题没有最终答案，只有采用动态反馈机制。因此，将观测代码和优化代码（业务代码的策略优化部分）合一，是使这一优化模式能够更加准确、高效、稳定的必然选择。</p>
<h3 id="56编译器和内核合一">5.6.编译器和内核合一</h3>
<p>从本质上讲，计算问题、语言问题其实是一个问题。最初我们解决计算问题，是在纸带上打孔，后来有了编译器。解决计算问题的效率大大提升，但是解决计算问题的能力其实没有变化。</p>
<p>后来有了操作系统，软件的分层模型逐渐成型，开发应用程序的效率大大提升，但其实通过编程解决计算问题的能力并没有提升，反而是在下降。因为软件的每一个分层，在带来工程化效率的同时，也导致了能力的损耗。API 的设计是一个大命题，但是没有完美的 API 设计。</p>
<p>开发效率的提升，带来了应用的高度发展，现在计算能力的问题出现了。回归本原，将编译器和内核合一，构建更加强大的计算能力，是未来发展的基础。</p>
<h2 id="6走向未来">6.走向未来</h2>
<p>未来 BPF 将如何发展呢？</p>
<p>它已经具备图灵机的雏形，拥有巨大的计算能力潜能。它目前的计算能力仍然受到约束，但是已经足够改变现有应用开发的基础，必将引发应用的蓬勃发展，会衍生出开发工具、测试方法等等的发展，使业务逻辑的开发与 BPF 的开发统一在一个开发模型当中，甚至引发新的开发语言出现。当在应用领域中生根后，就会继续发芽壮大，需要吸收计算能力作为养料才能抽枝散叶。BPF 应用与 BPF 技术内涵的发展就像两面相对的镜子，相互映照，形成斑斓的德罗斯特效应图景。</p>
<p>随着近几年云计算、人工智能、智能设备的蓬勃发展，信息系统基础设施结构、设备类型、业务复杂度都迎来再一次的变革。</p>
<p>Linux 系统作为现今最为广泛使用的操作系统，其自身也在发展变化。初期，沿着原有的技术路线，通过量的积累，足以应对时代的演进，这一点从代码增长就可以看出来，其背后是 Linux 支持的设备、驱动、特性、机制也来越多。产品构型也越来也复杂，Web 服务器、<a href="https://cloud.tencent.com/product/gpu?from=20067&amp;from_column=20067" target="_blank" rel="noopener">并行计算</a>、<a href="https://cloud.tencent.com/product/gpu?from=20067&amp;from_column=20067" target="_blank" rel="noopener">异构计算</a>、桌面、智能终端、嵌入式系统。Linux 的技术设施，需要面对不同的应用场景和问题。量的积累，可以解决一段时间的问题。但是，当这种变化积累到一定程度时，需要新的手段，才能支持上层结构的灵活度。</p>
<p>需要指出的是，现有的文档中，大多将 BPF 定位为网络和安全工具的利器。但是 BPF 作为一种通用的动态逻辑机制，绝不仅仅可以应用这两个地方。</p>
<h3 id="61通用性">6.1.通用性</h3>
<p>BPF 已经从最初网络报文分析技术，扩展到了很多应用领域，以后必然成为一种通用的内核开发技术，在定制化和功能扩展两方面推动内核发展。目前 BPF 的核心组件基本轮廓已经确定，由运行上下文、帮助函数、Map、指令集、Verifier、JIT、系统调用等关键模块构成 BPF 的核心运行机制。</p>
<p>运行上下文是 BPF 程序运行的语境，目前除了网络语境发展比较快速之外，其他程序类型的运行上下文发展相对落后，文件系统目前甚至还没有。对于运行上下文应该设计成什么样子，达到什么要求，有怎样的约束，还没有统一的范式，主要由各程序类型根据实际应用需要进行定义。彼此间缺乏共通性，发展比较随意，还处于比较原始的阶段。</p>
<p>帮助函数还不完备，各个程序类型存在差异。程序类型的定义，缺乏逻辑基础，其设计元语还需澄清。语境相关部分和通用部分划分不清楚，影响到安全机制也无法针对性设计，安全性无法验证。</p>
<p>Map 担负的角色过于宽泛，既是通讯机制，也是存储机制，既是 Local 的也是 Global 的。是对 BPF 核心机制补全的过渡手段。随着，远程调用、间接调用、跳转表、全局变量等的实现，Map 的作用和使用方式也将改变。</p>
<h3 id="62表达能力">6.2.表达能力</h3>
<p>内核已经在扩展性方面在不断改进，但是这些始终还是不能根本解决问题，引入更多编译器技术特别是动态编译技术、可信编译技术才是解决问题的根本。</p>
<p>目前 BPF 的程序的表达能力相当于弱化的 C 语言，这显然是不够的。实现一种和传统应用开发相同的开发体验，让程序员专注于理解业务逻辑，自由地表达，需要编译器填补通用语言与 BPF 自身限制之间的沟壑，需要语言层面的扩展，也需要运行时和工具链的支持。</p>
<h3 id="63开发工具">6.3.开发工具</h3>
<p>目前还没有在前端支持 BPF 的开发工具，只是实现了后端的支持，这显然还远远不够。这种情况，正说明了 BPF 的发展急需编译器的支持，在前端支持 BPF，通过语言特性的扩展和新的开发支持库，实现 BPF 与通用编程语言的融合，将大大缩减包含 BPF 特性的应用程序的开发、测试和维护难度。对于 BPF 作为一项应用开发技术大力推广至关重要。</p>
<h3 id="64开发流程">6.4.开发流程</h3>
<p>目前，在设计阶段，需要将 BPF 的逻辑部分和一般编程逻辑部分分离出来，这增加了设计的开销，同时对于设计人员的要求加大。原本的应用设计人员，只了解业务逻辑，这显然不够，还需要了解内核的基本原理，才能够做好逻辑划分工作。既了解内核又懂应用开发和业务逻辑的人员，是交叉性人才，这样的人员往往少且难以培养。如果让原本的应用开发人员，学习掌握内核相关的知识，以便可以满足 BPF 应用开发的需要，显然费时费力不说，费效比更是难以达到商业决策的最低门槛。</p>
<p>而在开发阶段，BPF 和应用需要分开编码，这无疑增加了联调联试的开销。特别是，出现问题的时候需要频繁的跨组跨部门沟通，效率实在太低。如果能把 BPF 的开发完全应用化，让一个程序员承担所有工作，成本、效率都可以得到优化。在测试阶段，还缺少专用的高效率的工具。</p>
<p>因此，以开发工具的进步为基础，目前采用的开发流程也一定会同步地被改进。可以预想，未来的开发流程一定是融合和简化的。</p>
<h2 id="7结束语">7.结束语</h2>
<p>Linux 内核的发展，将技术发展与创新演绎得淋漓尽致。源自于用户和开发者的需求，始终是推动技术不断进步的根本动力。在需求的推动下，Linux 内核始终在快速的发展，保持着强劲的动力。同时，热爱与坚持，还有最重要的开发原则的坚守，是 Linux 能够将源源不断的需求转化为创新动力的基础，而不至于被爆炸的需求摧毁。基本原则体系的维护，使 Linux 内核始终保持如一的设计框架。</p>
<p>在 Linux 的发展过程中，一些很小的需求，最终也可以发展成为复杂的架构。坚持与打破壁垒，是创新的范式。</p>
<p>在不断寻求问题的最终答案的过程中，有很多优秀的思想启发我们的认知，但限于技术发展阶段、条件是否成熟，这些优秀的思想有的潜入水底，有的浮现水面独领一段风骚。历史会有所偏好，作出它的选择，但不可否认的是这些优秀的思想，都一直在发挥着它们的作用。当历史的拐点到来的时候，它们又会重新融合，以一种全新的方式继续推动技术的进步。</p>
<p>BPF 是内核交互问题不断挖掘、迭代后的最新答案。内核的交互问题，本质上是内核结构问题。BPF 的强大计算能力，将推动更好地实现内核与用户态的动态交互，使内核能够更加灵活满足各种应用场景的需要，使整个系统的性能不因为这种能力而遭受损失。保持软件良好分层的基础上，减小分层对信息交互、资源共享的阻碍。而围绕 BPF 的基础设施的发展，也必定会为内核结构带来巨大改变，将安全性、规范性更加深入地融入到内核的细微层次。</p>
<p>安全可靠是 BPF 持续发展的原则的，在 BPF 的功能性不断扩展、计算能力不断释放的过程中，安全检查、可信编译的加持是可持续性的基础。而作为一种全新的编程方式，BPF 的开发和传统编程范式具有同样的地位和发展前景。从语言的支持到代码的生成乃至 JIT 的优化等等，是必不可少的一环。</p>
<p>BPF 来源于 Linux 内核发展过程中，众多优秀的开发者在效率、能力方面的不断改进，以及对技术本源的孜孜以求。它是内核发展中，众多优秀思想的集大成者，但同时，它也仅仅是新时代的开始。新的方法、新的语言、新的架构都在不断出现，催生着巨大的变革，如汹涌的波涛。而 BPF 将成为乘波之舟，它存在很多可能性，相信以此为起点，开发者们将会谱写更华丽的篇章。这是包括作者在内的众多开发者，所期待的广阔未来。</p>

          </div>

          



          
          
          <div class="article-widget">
            
<div class="container-xl row post-nav">
  
  
  
  <div class="col-6 post-nav-item">
    <div class="meta-nav">下一页</div>
    <a href="/books/linux-notes/04.ebpf/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2023-%E6%97%A0%E5%A3%B0%E7%9A%84%E5%B9%B3%E5%8F%B0%E9%9D%A9%E5%91%BDebpf-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E6%A0%B9%E6%9C%AC%E4%B8%8A%E6%94%B9%E9%80%A0%E4%BA%91%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0%E7%9A%84/" rel="prev">2023-无声的平台革命：eBPF 是如何从根本上改造云原生平台的</a>
  </div>
  
</div>

          </div>
          

        <div class="body-footer">
          <p>最近更新于 0001-01-01</p>

          



          


  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    
<div id="disqus_thread"></div>
<script>
  var disqus_config = function () {
    
    
    
  };
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
      return;
    }
    var d = document, s = d.createElement('script'); 
    s.async = true;
    s.src = 'https://' + "ngte" + '.disqus.com/embed.js';
    
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
  



          


        </div>

      </article>

      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2017-2022 NGTE all rights reserved</p>
        </div>
    </div>
  </div>

  <script type="text/javascript" id="clstr_globe" async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script>
  
</footer>


    </main>
  </div>
</div>
<script src="//unpkg.com/heti/umd/heti-addon.min.js"></script>
<script>
  const heti = new Heti('.article');
  heti.autoSpacing();
</script>
<script type="text/javascript">
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "12adcc35-9621-4313-8262-62dc654b29d8";
  (function () {
    setTimeout(function() {
      d = document;
      s = d.createElement("script");
      s.src = "https://client.crisp.chat/l.js";
      s.async = 1;
      d.getElementsByTagName("head")[0].appendChild(s);
    }, 2500);
  })();
</script>
  </div>

  <div class="page-footer">
    
    
  </div>

      

    
    <script src="/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js"></script>

    
    
    
      

      
      

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
        
        
      

    

    
    
    

    
    
    
      
      <script id="search-hit-algolia-template" type="text/html">
        <div class="search-hit">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a>
            </div>
            <div class="article-metadata search-hit-type">{{type}}</div>
            <p class="search-hit-description">{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p>
          </div>
        </div>
      </script>
      
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js" crossorigin="anonymous"></script>
      
      
    

    
    

    
    
    
    
      <script id="dsq-count-scr" src="https://ngte.disqus.com/count.js" async></script>
      
    

    
    
      
      
      
      
      
      
      
    

    
    <script src="/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js" type="module"></script>
    

    
    
    
    <script id="page-data" type="application/json">{"use_headroom":false}</script>

    
    
    
    
    
    
    
    
    
    
    <script src="/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js"></script>

    
    
    
    
    
    
    <script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>


    

    
    
    <script src="https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    <script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>

    


</body>
</html>
