<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>图遍历 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/algorithm-notes/03.%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E9%81%8D%E5%8E%86/</link><atom:link href="https://ng-tech.icu/books/algorithm-notes/03.%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E9%81%8D%E5%8E%86/index.xml" rel="self" type="application/rss+xml"/><description>图遍历</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>图遍历</title><link>https://ng-tech.icu/books/algorithm-notes/03.%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E9%81%8D%E5%8E%86/</link></image><item><title>广度优先搜索</title><link>https://ng-tech.icu/books/algorithm-notes/03.%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E9%81%8D%E5%8E%86/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/algorithm-notes/03.%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E9%81%8D%E5%8E%86/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid><description>&lt;h1 id="广度优先搜索">广度优先搜索&lt;/h1>
&lt;p>广度优先搜索算法(Breadth First Search)，又称为&amp;quot;宽度优先搜索&amp;quot;或&amp;quot;横向优先搜索&amp;quot;，简称 BFS。它的思想是：从图中某顶点 v 出发，在访问了 v 之后依次访问 v 的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点“先于”后被访问的顶点的邻接点“被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。&lt;/p>
&lt;p>换句话说，广度优先搜索遍历图的过程是以 v 为起点，由近至远，依次访问和 v 有路径相通且路径长度为 1,2&amp;hellip;的顶点。&lt;/p>
&lt;h2 id="无向图的广度优先搜索">无向图的广度优先搜索&lt;/h2>
&lt;p>下面以&amp;quot;无向图&amp;quot;为例，来对广度优先搜索进行演示。还是以上面的图 G1 为例进行说明。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/VLwYbsF9/image.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>第 1 步：访问 A。&lt;/li>
&lt;li>第 2 步：依次访问 C、D、F。在访问了 A 之后，接下来访问 A 的邻接点。前面已经说过，在本文实现中，顶点 ABCDEFG 按照顺序存储的，C 在&amp;quot;D 和 F&amp;quot;的前面，因此，先访问 C。再访问完 C 之后，再依次访问 D,F。&lt;/li>
&lt;li>第 3 步：依次访问 B,G。在第 2 步访问完 C,D,F 之后，再依次访问它们的邻接点。首先访问 C 的邻接点 B，再访问 F 的邻接点 G。&lt;/li>
&lt;li>第 4 步：访问 E。在第 3 步访问完 B,G 之后，再依次访问它们的邻接点。只有 G 有邻接点 E，因此访问 G 的邻接点 E。&lt;/li>
&lt;/ul>
&lt;p>因此访问顺序是：A -&amp;gt; C -&amp;gt; D -&amp;gt; F -&amp;gt; B -&amp;gt; G -&amp;gt; E&lt;/p>
&lt;h2 id="有向图的广度优先搜索">有向图的广度优先搜索&lt;/h2>
&lt;p>下面以&amp;quot;有向图&amp;quot;为例，来对广度优先搜索进行演示。还是以上面的图 G2 为例进行说明。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/DfrhFkKS/image.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>第 1 步：访问 A。&lt;/li>
&lt;li>第 2 步：访问 B。&lt;/li>
&lt;li>第 3 步：依次访问 C,E,F。在访问了 B 之后，接下来访问 B 的出边的另一个顶点，即 C,E,F。前面已经说过，在本文实现中，顶点 ABCDEFG 按照顺序存储的，因此会先访问 C，再依次访问 E,F。&lt;/li>
&lt;li>第 4 步：依次访问 D,G。在访问完 C,E,F 之后，再依次访问它们的出边的另一个顶点。还是按照 C,E,F 的顺序访问，C 的已经全部访问过了，那么就只剩下 E,F；先访问 E 的邻接点 D，再访问 F 的邻接点 G。&lt;/li>
&lt;/ul>
&lt;p>因此访问顺序是：A -&amp;gt; B -&amp;gt; C -&amp;gt; E -&amp;gt; F -&amp;gt; D -&amp;gt; G&lt;/p>
&lt;h1 id="广度优先遍历">广度优先遍历&lt;/h1>
&lt;p>图的广度优先遍历基于广度优先搜索 BFS (Breadth First Search)，其主要思想是首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点，再访问它们相邻的未被访问过的顶点，直到所有的顶点都被访问过，遍历结束。广度优先搜索是从图中某一顶点 v 出发，在访问顶点 v 后再访问 v 的各个未曾被访问过的邻接顶点 w1、w2、…、wk，然后再依次访问 w1、w2、…、wk 的所有还未被访问过的邻接顶点。再从这些访问过的顶点出发，再访问它们的所有还未被访问过的邻接顶点，……，如此下去，直到图中所有和顶点 v 由路径连通的顶点都被访问到为止。&lt;/p>
&lt;p>下图(a)给出了一个从顶点 A 出发进行广度优先搜索的示例。图(b)给出了由广度优先搜索得到的广度优先生成树，它由搜索时访问过的 n 个顶点和搜索时经历的 n-1 条边组成，各顶点旁边附的数字标明了顶点被访问的顺序。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/fRXjqKdQ/image.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>广度优先搜索是一种分层的搜索过程，它类似于树的层次遍历。从图中可以看出，搜索每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此，广度优先遍历不是一个递归的过程，其算法也不是递归的。为了实现逐层访问，算法中使用了一个队列，以记录刚才访问过的上一层和本层顶点，以便于向下一层访问。从指定的结点 v 开始进行广度优先搜索的算法步骤是：&lt;/p>
&lt;p>（1）访问结点 v，并标记 v 已被访问，同时顶点 v 入队列
（2）当队列空时算法结束，否则继续步骤（3）
（3）队头顶点出队列为 v
（4）取顶点 v 的第一个邻接顶点 w
（5）若顶点 w 不存在，转步骤（3）；否则继续步骤（6）
（6）若顶点 w 未被访问，则访问顶点 w，并标记 w 已被访问，同时顶点 w 入队列；否则继续步骤
（7）使 w 为顶点 v 的在原来 w 之后的下一个邻接顶点，转到步骤（5）&lt;/p>
&lt;h2 id="代码实现">代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 广度优先遍历的算法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="n">Graph&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">::&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">BFTraverse&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="n">visit&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">vertexType&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NumberOfVertexes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="c1">//取图的顶点个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">visited&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">//定义访问标记数组 visited
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//访问标记数组 visited 初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="c1">//对图中的每一个顶点进行判断
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">visited&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="n">BFS&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visit&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="p">]&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//释放 visited
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 广度优先搜索的算法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">Graph&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">::&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">BFS&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">visited&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="p">],&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">visit&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">vertexType&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">linkqueue&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//定义队列q
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">visit&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">GetValue&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">//访问顶点 v
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//顶点 v 作已访问标记
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">EnQueue&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//顶点 v 进队列q
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">IsEmpty&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">DeQueue&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">);&lt;/span> &lt;span class="c1">//否则, 队头元素出队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetFirstNeighbor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//若邻接顶点 w 存在
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//若该邻接顶点未访问过
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">visit&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">GetValue&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">//访问顶点 w
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//顶点 w 作已访问标记
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">EnQueue&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//顶点 w 进队列q
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">w&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetNextNeighbor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">w&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="c1">//重复检测 v 的所有邻接顶点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="c1">//外层循环，判队列空否
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在图的广度优先遍历算法中，图中每一个顶点需进队列一次且仅进队列一次，而在遍历过程中是通过边来搜索邻接点的。所以，图的广度优先遍历算法的时间复杂度和图的深度优先遍历算法的时间复杂度类似，如果使用邻接表表示图，则其时间复杂度为 O(n+e)；如果使用邻接矩阵表示图，则其时间复杂度为 $O(n^2)$。&lt;/p></description></item><item><title>深度优先搜索</title><link>https://ng-tech.icu/books/algorithm-notes/03.%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E9%81%8D%E5%8E%86/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/algorithm-notes/03.%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E9%81%8D%E5%8E%86/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid><description>&lt;h1 id="深度优先搜索">深度优先搜索&lt;/h1>
&lt;p>图的深度优先搜索（Depth First Search），和树的先序遍历比较类似。假设初始状态是图中所有顶点均未被访问，则从某个顶点 v 出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。&lt;/p>
&lt;p>显然，深度优先搜索是一个递归的过程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="o">],&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">dfs&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">){&lt;/span> &lt;span class="c1">// cur 当前所在顶点编号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">sum&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 所有顶点都已经访问过就直接退出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">cur&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">book&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 标记顶点i已经访问过
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">dfs&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 从顶点i再出发继续遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="无向图的深度优先搜索">无向图的深度优先搜索&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230418222317.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>第 1 步：访问 A。&lt;/li>
&lt;li>第 2 步：访问(A 的邻接点)C。在第 1 步访问 A 之后，接下来应该访问的是 A 的邻接点，即&amp;quot;C,D,F&amp;quot;中的一个。但在本文的实现中，顶点 ABCDEFG 是按照顺序存储，C 在&amp;quot;D 和 F&amp;quot;的前面，因此，先访问 C。&lt;/li>
&lt;li>第 3 步：访问(C 的邻接点)B。在第 2 步访问 C 之后，接下来应该访问 C 的邻接点，即&amp;quot;B 和 D&amp;quot;中一个(A 已经被访问过，就不算在内)。而由于 B 在 D 之前，先访问 B。&lt;/li>
&lt;li>第 4 步：访问(C 的邻接点)D。在第 3 步访问了 C 的邻接点 B 之后，B 没有未被访问的邻接点；因此，返回到访问 C 的另一个邻接点 D。&lt;/li>
&lt;li>第 5 步：访问(A 的邻接点)F。前面已经访问了 A，并且访问完了&amp;quot;A 的邻接点 B 的所有邻接点(包括递归的邻接点在内)&amp;quot;；因此，此时返回到访问 A 的另一个邻接点 F。&lt;/li>
&lt;li>第 6 步：访问(F 的邻接点)G。&lt;/li>
&lt;li>第 7 步：访问(G 的邻接点)E。&lt;/li>
&lt;/ul>
&lt;p>因此访问顺序是：A -&amp;gt; C -&amp;gt; B -&amp;gt; D -&amp;gt; F -&amp;gt; G -&amp;gt; E&lt;/p>
&lt;h2 id="有向图的深度优先搜索">有向图的深度优先搜索&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/5y8hpvf4/image.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>第 1 步：访问 A。&lt;/li>
&lt;li>第 2 步：访问 B。在访问了 A 之后，接下来应该访问的是 A 的出边的另一个顶点，即顶点 B。&lt;/li>
&lt;li>第 3 步：访问 C。在访问了 B 之后，接下来应该访问的是 B 的出边的另一个顶点，即顶点 C,E,F。在本文实现的图中，顶点 ABCDEFG 按照顺序存储，因此先访问 C。&lt;/li>
&lt;li>第 4 步：访问 E。接下来访问 C 的出边的另一个顶点，即顶点 E。&lt;/li>
&lt;li>第 5 步：访问 D。接下来访问 E 的出边的另一个顶点，即顶点 B,D。顶点 B 已经被访问过，因此访问顶点 D。&lt;/li>
&lt;li>第 6 步：访问 F。接下应该回溯&amp;quot;访问 A 的出边的另一个顶点 F&amp;quot;。&lt;/li>
&lt;li>第 7 步：访问 G。&lt;/li>
&lt;/ul>
&lt;p>因此访问顺序是：A -&amp;gt; B -&amp;gt; C -&amp;gt; E -&amp;gt; D -&amp;gt; F -&amp;gt; G&lt;/p>
&lt;h1 id="深度优先遍历">深度优先遍历&lt;/h1>
&lt;p>图的深度优先遍历基于深度优先搜索 DFS(Depth First Search)，其类似于树的前序遍历。深度优先搜索是从图中某一顶点 v 出发，在访问顶点 v 后，再依次从 v 的任一还没有被访问的邻接顶点 w 出发进行深度优先搜索，直到图中所有与顶点 v 有路径相通的顶点都被访问过为止。这是一个递归定义，所以图的深度优先搜索可以用递归算法实现。&lt;/p>
&lt;p>下图（a）给出了深度优先搜索的示例。由于该图是连通的，所以从顶点 A 出发，通过一次深度优先搜索，就可以访问图中的所有顶点。图的深度优先搜索的访问顺序与树的前序遍历顺序类似。图 (b)给出了在深度优先搜索的过程中，访问的所有顶点和经过的边，图中各顶点旁附加的数字表示各顶点被访问的次序。在图 (b)中，共有 n-1 条边连结了所有 n 个顶点，在此把它称为图（a）的深度优先搜索生成树。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/c4bzYXRR/image.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>从指定的结点 v 开始进行深度优先搜索的算法的步骤是：&lt;/p>
&lt;p>（1）访问结点 v，并标记 v 已被访问
（2）取顶点 v 的第一个邻接顶点 w
（3）若顶点 w 不存在，返回；否则继续步骤（4）
（4）若顶点 w 未被访问，则访问结点 w，并标记 w 已被访问；否则转步骤（5）
（5）使 w 为顶点 v 的在原来 w 之后的下一个邻接顶点，转到步骤（3）&lt;/p>
&lt;p>深度优先遍历的主要思想是：首先以一个未被访问过的顶点作为起始顶点，沿着当前顶点的边走到未被访问过的顶点；当没有未被访问过的顶点时，回到上一个顶点，继续试探访问别的顶点，直到所有的顶点都被访问过。显然，深度优先遍历是沿着图的某一条分支遍历直到末端，然后回溯，再沿着另一条继续遍历，直到所有的顶点都被访问过为止。&lt;/p>
&lt;h2 id="算法实现">算法实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 深度优先遍历的算法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="n">Graph&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">::&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">DFTraverse&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">visit&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">vertexType&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NumberOfVertexes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">;&lt;/span>&lt;span class="c1">//取图的顶点个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">visited&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">//定义访问标记数组 visited
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//访问标记数组 visited 初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="c1">//对图中的每一个顶点进行判断
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">visited&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="n">DFS&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visit&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="p">]&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//释放 visited
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 深度优先搜索
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="kt">void&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Graph&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vertexType&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arcType&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">::&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">DFS&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">visited&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="p">],&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">visit&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">vertexType&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visit&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="n">GetValue&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">//访问顶点 v
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//顶点v 作访问标记
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetFirstNeighbor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//若顶点 w 存在
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="n">DFS&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visited&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">w&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetNextNeighbor&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="c1">//重复检测 v 的所有邻接顶点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最短路径的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">min&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">999999999&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">dis&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dis&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">min&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cur&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">){&lt;/span> &lt;span class="c1">// 判断是否到达目标城市
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dis&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">min&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">min&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dis&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 更新最小值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="err">；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">cur&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">99999999&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">book&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">dis&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">cur&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">book&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>