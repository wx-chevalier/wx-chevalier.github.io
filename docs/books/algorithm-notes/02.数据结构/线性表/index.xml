<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>线性表 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <atom:link href="https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/index.xml" rel="self" type="application/rss+xml" />
    <description>线性表</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>线性表</title>
      <link>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
    </image>
    
    <item>
      <title>SkipList</title>
      <link>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/skiplist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/skiplist/</guid>
      <description>&lt;h1 id=&#34;skiplist--跳表&#34;&gt;SkipList | 跳表&lt;/h1&gt;
&lt;p&gt;Skip List，称之为跳表，它是一种可以替代平衡树的数据结构，其数据元素默认按照 key 值升序，天然有序。Skip list 让已排序的数据分布在多层链表中，以 0-1 随机数决定一个数据的向上攀升与否，通过“空间来换取时间”的一个算法，在每个节点中增加了向前的指针，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。&lt;/p&gt;
&lt;p&gt;SkipList 具备如下特性：&lt;/p&gt;
&lt;p&gt;由很多层结构组成，level 是通过一定的概率随机产生的
每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的 Comparator 进行排序，具体取决于使用的构造方法
最底层(Level 1)的链表包含所有元素
如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现
每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>集合</title>
      <link>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9B%86%E5%90%88/</guid>
      <description>&lt;h1 id=&#34;求交集&#34;&gt;求交集&lt;/h1&gt;
&lt;p&gt;给定两个整数集合 A 和 B，每个集合都包含 20 亿个不同整数，请给出快速计算 A∩B 的算法，算法可使用外存，但是要求占用内存不能超过 4GB。如果这里的整数是 32 位整数，那么每个集合用一个大小 2^32 位的 bitmap 表示，分别遍历集合算出对应 bitmap 后，直接遍历每一字节取交即可。每个 bitmap 的大小是 2^32bit / 2^3(bits per Byte) = 512MB，一共使用 1GB 内存。构造 bitmap 的时候，除去 bitmap 还有 3GB 可以使用，一共可以存储 3 _ 2^30 / 4 = 3 _ 2 ^28 = 8 亿个整数。那每个集合要按每 8 亿个切分到外存中，分成 3 个部分。这样构造的时候每个集合读取 3 次外存，一共读取 6 次。然后如果结果交集很大而且要得到具体整数，也要对结果做切分，最多存储 3 次外存。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>列表</title>
      <link>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%88%97%E8%A1%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>跳表</title>
      <link>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/algorithm-notes/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E8%B7%B3%E8%A1%A8/</guid>
      <description>&lt;h1 id=&#34;skip-list&#34;&gt;Skip List&lt;/h1&gt;
&lt;p&gt;Search‎: ‎O(log n)Delete‎: ‎O(log n)Insert‎: ‎O(log n)Space‎: ‎O(n)&lt;/p&gt;
&lt;p&gt;如果每 2^i 个节点都指向前面 2^i 个节点，寻找一个节点的复杂度变成 logn(类似于二分查找)那么问题来了,为什么随机的层数也能保证 logN 的复杂度? 原因就在于,这里说的随机,并不是完全的随机一个层数出来,而是通过随机的算法,算出一个并不随机的层数来，以 redis 中的随机层数的算法来看&lt;code&gt;int zslRandomLevel(void) { int level = 1; while ((random()&amp;amp;0xFFFF) &amp;lt; (ZSKIPLIST_P * 0xFFFF)) level += 1; return (level&amp;lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;}&lt;/code&gt;这里假设 ZSKIPLIST_P 为 2 (实际为 4,便于理解设置为 2),这段代码我们可以理解为,落到层数为 i + 1 的概率为 0.5^i 而反过来理解,每两个节点出现层数为 2 的期望就是 1,每 4 个节点出现第三层的期望也为 1,每 8 个节点出现第四层(0.5^3)的期望为 1 (期望值 = 单个概率 * 数量)正是基于此,如果我们的数据量越大,越是可以接近期望的值,所以,我们可以认为,我们实现了 &amp;ldquo;如果每 2^i 个节点都指向前面 2^i 个节点&amp;quot;的效果,也就是说,查找的平均复杂度为 O(logN)&lt;/p&gt;
&lt;h1 id=&#34;links&#34;&gt;Links&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.csee.umbc.edu/courses/undergraduate/341/fall01/Lectures/SkipLists/skip_lists/skip_lists.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1999 - Skip List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cppblog.com/mysileng/archive/2013/04/06/199159.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Skip List(跳跃表)原理详解与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跳表 SkipList&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
