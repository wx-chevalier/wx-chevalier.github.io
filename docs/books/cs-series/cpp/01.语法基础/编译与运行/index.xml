<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编译与运行 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/cs-series/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/</link><atom:link href="https://ng-tech.icu/books/cs-series/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/index.xml" rel="self" type="application/rss+xml"/><description>编译与运行</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>编译与运行</title><link>https://ng-tech.icu/books/cs-series/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/</link></image><item><title>gcc</title><link>https://ng-tech.icu/books/cs-series/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/gcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cs-series/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/gcc/</guid><description>&lt;h1 id="gcc">gcc&lt;/h1>
&lt;p>hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">unix&amp;gt; gcc -o hello hello.c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译的过程可分为四个阶段完成：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/52256465-bce93280-2951-11e9-860c-5dba0ae2bcb2.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>预处理阶段。预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的 #include &amp;lt;stdio.h&amp;gt; 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入到程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>编译阶段。编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>汇编阶段。接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。如果我们在文本编辑器中打开 hello.o 文件，看到的将是一堆乱码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>链接阶段。请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都会提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="gcc-的组成">gcc 的组成&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>部分&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>c++&lt;/td>
&lt;td>gcc 的一个版木，默认语言设置为 &lt;a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++&lt;/a>，而且在连接的时候自动包含标准 C++ 库。这和 g++ 一样&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ccl&lt;/td>
&lt;td>实际的 C 编译程序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cclplus&lt;/td>
&lt;td>实际的 C++ 编泽程序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>collect2&lt;/td>
&lt;td>在不使用 GNU 连接程序的系统上，有必要运行 collect2 来产生特定的全局初始化代码（例如 C++ 的构造函数和析构函数）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>configure&lt;/td>
&lt;td>GCC 源代码树根目录中的一个脚木。用于设置配置值和创建 GCC 编译程序必需的 make 程序的描述文件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>crt0.o&lt;/td>
&lt;td>这个初始化和结束代码是为每个系统定制的，而且也被编译进该文件，该文件然后会被连接到每个可执行文件中来执行必要的启动和终止程序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cygwin1.dll&lt;/td>
&lt;td>Windows 的共享库提供的 API，模拟 UNIX 系统调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>f77&lt;/td>
&lt;td>该驱动程序可用于编译 Fortran&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>f771&lt;/td>
&lt;td>实际的 Fortran 编译程序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>g++&lt;/td>
&lt;td>gcc 的一个版木，默认语言设置为 C++，而且在连接的时候自动包含标准 C++ 库。这和 c++ 一样&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>gcc&lt;/td>
&lt;td>该驱动程序等同于执行编译程序和连接程序以产生需要的输出&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>gcj&lt;/td>
&lt;td>该驱动程序用于编译 &lt;a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>gnat1&lt;/td>
&lt;td>实际的 Ada 编译程序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>gnatbind&lt;/td>
&lt;td>一种工具，用于执行 Ada 语言绑定&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>gnatlink&lt;/td>
&lt;td>一种工具，用于执行 Ada 语言连接&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>jc1&lt;/td>
&lt;td>实际的 Java 编译程序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>libgcc&lt;/td>
&lt;td>该库包含的例程被作为编泽程序的一部分，是因为它们可被连接到实际的可执行程序中。它们是特殊的例程，连接到可执行程序，来执行基木的任务，例如浮点运算。这些库中的例程通常都是平台相关的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>libgcj&lt;/td>
&lt;td>运行时库包含所有的核心 Java 类&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>libobjc&lt;/td>
&lt;td>对所有 Objective-C 程序都必须的运行时库&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>libstdc++&lt;/td>
&lt;td>运行时库，包括定义为标准语言一部分的所有的 C++ 类和函数&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>程序编译基础概念</title><link>https://ng-tech.icu/books/cs-series/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cs-series/cpp/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid><description>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic1.imgdb.cn/item/634b9b4e16f2c2beb1e6dfa2.jpg" alt="编译过程概述" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="cmakemakefilemake-理解">cmake/makefile/make 理解&lt;/h1>
&lt;p>make 工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用 makefile 文件中用户指定的命令来进行编译和链接的。&lt;/p>
&lt;ul>
&lt;li>&lt;code>CMake&lt;/code> 是一个跨平台的、开源的构建工具。cmake 是 &lt;code>makefile&lt;/code> 的上层工具，它们的目的正是为了产生可移植的 &lt;code>makefile&lt;/code>，并简化自己动手写 &lt;code>makefile&lt;/code>时的巨大工作量；&lt;/li>
&lt;li>把 &lt;code>make&lt;/code> 命令写在文件中，构成一系列构建规则的文件叫做 &lt;code>Makefile&lt;/code> 文件。&lt;code>Makefile&lt;/code> 文件有一套自己专门的语法，包括 &lt;code>echoing&lt;/code>、通配符、模式匹配、变量和赋值符、自动变量等内容。&lt;/li>
&lt;li>Linux 中 &lt;code>make&lt;/code> 是用来编译的，它从 &lt;code>Makefile中&lt;/code> 读取指令，然后编译。make 的作用是开始进行源代码编译，以及由 Makefile 设置文件提供的一些功能；比如 &lt;code>make install&lt;/code> 表示进行安装（一般需要有 root 权限），&lt;code>make uninstall&lt;/code> 是卸载，不加参数就是默认的进行源代码编译。&lt;/li>
&lt;/ul>
&lt;h2 id="cmake-编译过程">CMake 编译过程&lt;/h2>
&lt;p>CMake 是针对跨平台编译问题，所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步自动生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。&lt;/p>
&lt;p>在 &lt;code>Linux&lt;/code> 平台下使用 &lt;code>CMake&lt;/code> 生成 &lt;code>Makefile&lt;/code> 并编译的流程如下：&lt;/p>
&lt;ol>
&lt;li>编写 &lt;code>CMake&lt;/code> 配置文件 &lt;code>CMakeLists.txt&lt;/code>。&lt;/li>
&lt;li>执行命令 &lt;code>cmake PATH&lt;/code> 或者 &lt;code>ccmake PATH&lt;/code> 生成 &lt;code>Makefile&lt;/code> (ccmake 和 cmake 的区别在于前者提供了一个交互式的界面)。其中， &lt;code>PATH&lt;/code> 是 &lt;code>CMakeLists.txt&lt;/code> 所在的目录。&lt;/li>
&lt;li>使用 &lt;code>make&lt;/code> 命令进行编译得到项目可执行文件。&lt;code>make “-j []”&lt;/code> 指同时运行命令的个数。如果没有这个参数，make 运行命令时能运行多少就运行多少。&lt;/li>
&lt;/ol>
&lt;h1 id="gcc-是什么">GCC 是什么&lt;/h1>
&lt;p>GNU(Gnu&amp;rsquo;s Not Unix)编译器套装(GNU Compiler Collection，GCC)，指一套编程语言编译器，以 GPL 及 LGPL 许可证所发行的自由软件，也是 GNU 项目的关键部分，也是 GNU 工具链的主要组成部分之一。GCC(特别是其中的 C 语言编译器)也常被认为是跨平台编译器的事实标准。1985 年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。GCC 原本用 C 开发，后来因为 LLVM、Clang 的崛起，它更快地将开发语言转换为 C++。GCC 在发布后很快地得到扩展，变得可处理 C++。之后也变得可处理 Fortran、Pascal、Objective-C、Java、Ada，Go 与其他语言。&lt;/p>
&lt;p>许多操作系统，包括许多类 Unix 系统，如 Linux 及 BSD 家族都采用 GCC 作为标准编译器。苹果电脑预装的 Mac OS X 操作系统也采用这个编译器。GCC 目前由世界各地不同的数个程序员小组维护。它是移植到最多中央处理器架构以及最多操作系统的编译器。由于 GCC 已成为 GNU 系统的官方编译器(包括 GNU/Linux 家族)，它也成为编译与创建其他操作系统的主要编译器，包括 BSD 家族、Mac OS X、NeXTSTEP 与 BeOS。GCC 通常是跨平台软件的编译器首选。有别于一般局限于特定系统与运行环境的编译器，GCC 在所有平台上都使用同一个前端处理程序，产生一样的中介码，因此此中介码在各个其他平台上使用 GCC 编译，有很大的机会可得到正确无误的输出程序。&lt;/p>
&lt;p>GCC 原本用 C 开发，后来因为 LLVM、Clang 的崛起，它更快地将开发语言转换为 C++。许多 C 的爱好者在对 C++一知半解的情况下主观认定 C++的性能一定会输给 C，但是 Ian Lance Taylor 给出了不同的意见，并表明 C++不但性能不输给 C，而且能设计出更好，更容易维护的程序。&lt;/p>
&lt;h2 id="gcc-与-g-的区别">gcc 与 g++ 的区别&lt;/h2>
&lt;p>这里的 &lt;code>gcc&lt;/code> （小写）与前文的 &lt;code>GCC&lt;/code> 含义是不同的。简单来说，gcc 指的是 GCC 中的 GNU C Compiler（C 编译器）；&lt;code>g++&lt;/code> 是 G++ 中的 GNU C++ Compiler（C++ 编译器），但实际上 gcc 和 g++ 都不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中的文件类型，调用对应的 GNU 编译器，所以更准确的说法是：&lt;code>gcc&lt;/code> 调用了 C compiler， &lt;code>g++&lt;/code> 调用了 C++ compiler。gcc 和 g++ 的主要区别如下：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>gcc&lt;/code> 编译 &lt;code>cpp&lt;/code> 文件可能会报错，因为 &lt;code>gcc&lt;/code> 编译文件时不会自动链接标准库 &lt;code>STL&lt;/code>，而 &lt;code>g++&lt;/code> 会，为了能够使用 &lt;code>STL&lt;/code>，需要添加参数 &lt;code>-lstdc++&lt;/code>，&lt;code>gcc -lstdc++&lt;/code> 和 &lt;code>g++&lt;/code> 不等价。&lt;/li>
&lt;li>对于 &lt;code>*.c&lt;/code> 和 &lt;code>*.cpp&lt;/code> 文件，&lt;code>gcc&lt;/code> 分别当做 c 和 cpp 文件编译（c 和 cpp 的语法强度是不一样的）。&lt;/li>
&lt;li>对于 &lt;code>*.c&lt;/code> 和 &lt;code>*.cpp&lt;/code> 文件，&lt;code>g++&lt;/code> 则统一当做 &lt;code>cpp&lt;/code> 文件编译。&lt;/li>
&lt;li>gcc 在编译 c 文件时，可使用的预定义宏是比较少的。&lt;/li>
&lt;/ul>
&lt;h1 id="clang-是什么">Clang 是什么&lt;/h1>
&lt;p>Clang 是一个 C、C++、Objective-C 和 Objective-C++ 编程语言的编译器前端。它采用了底层虚拟机(LLVM)作为其后端。它的目标是提供一个 GNU 编译器套装(GCC)的替代品。作者是克里斯·拉特纳(Chris Lattner)，在苹果公司的赞助支持下进行开发，而源代码授权是使用类 BSD 的伊利诺伊大学厄巴纳-香槟分校开源码许可。Clang 主要由 C++编写。Clang 项目包括 Clang 前端和 Clang 静态分析器等。这个软件项目在 2005 年由苹果电脑发起，是 LLVM(Low Level Virtual Machine)编译器工具集的前端(front-end)，目的是输出代码对应的抽象语法树(Abstract Syntax Tree, AST)，并将代码编译成 LLVM Bitcode。接着在后端(back-end)使用 LLVM 编译成平台相关的机器语言。Clang 本身性能优异，其生成的 AST 所耗用掉的内存仅仅是 GCC 的 20%左右。2014 年 1 月发行的 FreeBSD10.0 版将 Clang/LLVM 作为默认编译器。&lt;/p>
&lt;h2 id="clang-与-gcc-对比">Clang 与 GCC 对比&lt;/h2>
&lt;p>二者的优劣对比如下：&lt;/p>
&lt;ul>
&lt;li>GCC 特性：除支持 C/C++/ Objective-C/Objective-C++语言外，还是支持 Java/Ada/Fortran/Go 等；当前的 Clang 的 C++支持落后于 GCC；支持更多平台；更流行，广泛使用，支持完备。&lt;/li>
&lt;li>Clang 特性：编译速度快；内存占用小；兼容 GCC；设计清晰简单、容易理解，易于扩展增强；基于库的模块化设计，易于 IDE 集成；出错提示更友好。&lt;/li>
&lt;/ul>
&lt;h1 id="mingw-是什么">MinGW 是什么&lt;/h1>
&lt;p>MinGW（Minimalist GNU for Windows），又称 mingw32，是将 GCC 编译器和 GNU Binutils 移植到 Win32 平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。另有可用于产生 32 位及 64 位 Windows 可执行文件的 MinGW-w64 项目，是从原本 MinGW 产生的分支。如今已经独立发展。MinGW 是从 Cygwin（1.3.3 版）基础上发展而来。&lt;/p>
&lt;p>GCC 支持的语言大多在 MinGW 也受支持，其中涵盖 C、C++、Objective-C、Fortran 及 Ada。对于 C 语言之外的语言，MinGW 使用标准的 GNU 运行库，如 C++ 使用 GNU libstdc++。但是 MinGW 使用 Windows 中的 C 运行库。因此用 MinGW 开发的程序不需要额外的第三方 DLL 支持就可以直接在 Windows 下运行，而且也不一定必须遵从 GPL 许可证。这同时造成了 MinGW 开发的程序只能使用 Win32API 和跨平台的第三方库，而缺少 POSIX 支持[3]，大多数 GNU 软件无法在不修改源代码的情况下用 MinGW 编译。&lt;/p></description></item></channel></rss>