<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nginx | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/</link><atom:link href="https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/index.xml" rel="self" type="application/rss+xml"/><description>Nginx</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Nginx</title><link>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/</link></image><item><title>HTTP 服务器配置</title><link>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</guid><description>&lt;h1 id="nginx-初窥与部署">Nginx 初窥与部署&lt;/h1>
&lt;h1 id="环境部署">环境部署&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># CentOS&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">yum&lt;/span> &lt;span class="n">install&lt;/span> &lt;span class="n">nginx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sudo&lt;/span> &lt;span class="n">apt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">get&lt;/span> &lt;span class="n">install&lt;/span> &lt;span class="n">nginx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Mac&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">brew&lt;/span> &lt;span class="n">install&lt;/span> &lt;span class="n">nginx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="management">Management&lt;/h2>
&lt;pre tabindex="0">&lt;code># 启动
nginx -s start;
# 重新启动，热启动，修改配置重启不影响线上
nginx -s reload;
# 关闭
nginx -s stop;
# 修改配置后，可以通过下面的命令测试是否有语法错误
nginx -t;
&lt;/code>&lt;/pre>&lt;h3 id="start">Start&lt;/h3>
&lt;pre tabindex="0">&lt;code>cd usr/local/nginx/sbin
./nginx
&lt;/code>&lt;/pre>&lt;h3 id="reload">Reload&lt;/h3>
&lt;pre tabindex="0">&lt;code>更改配置重启nginx
kill -HUP 主进程号或进程号文件路径
或者使用
cd /usr/local/nginx/sbin
./nginx -s reload
判断配置文件是否正确
nginx -t -c /usr/local/nginx/conf/nginx.conf
或者
cd /usr/local/nginx/sbin
./nginx -t
&lt;/code>&lt;/pre>&lt;h3 id="stop">Stop&lt;/h3>
&lt;p>查询 nginx 主进程号　　 ps -ef | grep nginx
　　从容停止 kill -QUIT 主进程号　　快速停止 kill -TERM 主进程号　　强制停止 kill -9 nginx
　　若 nginx.conf 配置了 pid 文件路径，如果没有，则在 logs 目录下　　 kill -信号类型 &amp;lsquo;/usr/local/nginx/logs/nginx.pid&amp;rsquo;&lt;/p>
&lt;h2 id="configuration">Configuration&lt;/h2>
&lt;pre tabindex="0">&lt;code>events {
# 需要保留这一个段落，可以为空
}
http {
server {
listen 127.0.0.1:8888;
location / {
root /home/barret/test/;
}
}
}
&lt;/code>&lt;/pre>&lt;h1 id="basic-configuration基本配置">Basic Configuration(基本配置)&lt;/h1>
&lt;h2 id="运行配置">运行配置&lt;/h2>
&lt;p>`#定义 Nginx 运行的用户和用户组&lt;/p>
&lt;p>user www www; `&lt;/p>
&lt;pre tabindex="0">&lt;code>#nginx进程数，建议设置为等于CPU总核心数。
worker_processes 8;
#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]
error_log /var/log/nginx/error.log info;
#进程文件
pid /var/run/nginx.pid;
#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数(系统的值ulimit -n)与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。
worker_rlimit_nofile 65535;
#工作模式与连接数上限
events
{
#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络IO模型，如果跑在FreeBSD上面，就用kqueue模型。
use epoll;
#单个进程最大连接数(最大连接数=连接数*进程数)
worker_connections 65535;
}
&lt;/code>&lt;/pre>&lt;h2 id="http-服务器配置">HTTP 服务器配置&lt;/h2>
&lt;pre tabindex="0">&lt;code>设定http服务器
http
{
include mime.types; #文件扩展名与文件类型映射表
default_type application/octet-stream; #默认文件类型
#charset utf-8; #默认编码
server_names_hash_bucket_size 128; #服务器名字的hash表大小
client_header_buffer_size 32k; #上传文件大小限制
large_client_header_buffers 4 64k; #设定请求缓
client_max_body_size 8m; #设定请求缓
sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。
tcp_nopush on; #防止网络阻塞
tcp_nodelay on; #防止网络阻塞
keepalive_timeout 120; #长连接超时时间，单位是秒
#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。
fastcgi_connect_timeout 300;
fastcgi_send_timeout 300;
fastcgi_read_timeout 300;
fastcgi_buffer_size 64k;
fastcgi_buffers 4 64k;
fastcgi_busy_buffers_size 128k;
fastcgi_temp_file_write_size 128k;
#gzip模块设置
gzip on; #开启gzip压缩输出
gzip_min_length 1k; #最小压缩文件大小
gzip_buffers 4 16k; #压缩缓冲区
gzip_http_version 1.0; #压缩版本(默认1.1，前端如果是squid2.5请使用1.0)
gzip_comp_level 2; #压缩等级
gzip_types text/plain application/x-javascript text/css application/xml;
#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。
gzip_vary on;
#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用
}
&lt;/code>&lt;/pre>&lt;h2 id="内置全局变量">内置全局变量&lt;/h2>
&lt;p>名称 版本 说明(变量列表来源于文件 ngx_http_variables )&lt;/p>
&lt;p>$args 1.0.8 请求中的参数;&lt;/p>
&lt;p>$binary_remote_addr 1.0.8 远程地址的二进制表示&lt;/p>
&lt;p>$body_bytes_sent 1.0.8 已发送的消息体字节数&lt;/p>
&lt;p>$content_length 1.0.8 HTTP 请求信息里的&amp;quot;Content-Length&amp;quot;;&lt;/p>
&lt;p>$content_type 1.0.8 请求信息里的&amp;quot;Content-Type&amp;quot;;&lt;/p>
&lt;p>$document_root 1.0.8 针对当前请求的根路径设置值;&lt;/p>
&lt;p>$document_uri 1.0.8 与$uri 相同; 比如 /test1/test2/test.php&lt;/p>
&lt;p>$host 1.0.8 请求信息中的&amp;quot;Host&amp;quot;，如果请求中没有 Host 行，则等于设置的服务器名;&lt;/p>
&lt;p>$hostname 1.0.8&lt;/p>
&lt;p>$http_cookie 1.0.8 cookie 信息&lt;/p>
&lt;p>$http_post 1.0.8&lt;/p>
&lt;p>$http_referer 1.0.8 引用地址&lt;/p>
&lt;p>$http_user_agent 1.0.8 客户端代理信息&lt;/p>
&lt;p>$http_via 1.0.8 最后一个访问服务器的 Ip 地址。http://www.cnblogs.com/deng02/archive/2009/02/11/1387911.html&lt;/p>
&lt;p>$http_x_forwarded_for 1.0.8 相当于网络访问路径。http://www.cnblogs.com/craig/archive/2008/11/18/1335809.html&lt;/p>
&lt;p>$is_args 1.0.8&lt;/p>
&lt;p>$limit_rate 1.0.8 对连接速率的限制;&lt;/p>
&lt;p>$nginx_version 1.0.8&lt;/p>
&lt;p>$pid 1.0.8&lt;/p>
&lt;p>$query_string 1.0.8 与$args 相同;&lt;/p>
&lt;p>$realpath_root 1.0.8&lt;/p>
&lt;p>$remote_addr 1.0.8 客户端地址;&lt;/p>
&lt;p>$remote_port 1.0.8 客户端端口号;&lt;/p>
&lt;p>$remote_user 1.0.8 客户端用户名，认证用;&lt;/p>
&lt;p>$request 1.0.8 用户请求&lt;/p>
&lt;p>$request_body 1.0.8&lt;/p>
&lt;p>$request_body_file 1.0.8 发往后端的本地文件名称&lt;/p>
&lt;p>$request_completion 1.0.8&lt;/p>
&lt;p>$request_filename 1.0.8 当前请求的文件路径名，比如$request_filename：D:\nginx/html/test1/test2/test.php&lt;/p>
&lt;p>$request_method 1.0.8 请求的方法，比如&amp;quot;GET&amp;quot;、&amp;ldquo;POST&amp;quot;等;&lt;/p>
&lt;p>$request_uri 1.0.8 请求的 URI，带参数; 比如http://localhost:88/test1/test2/test.php&lt;/p>
&lt;p>$scheme 1.0.8 所用的协议，比如 http 或者是 https，比如 rewrite^(.+)$$scheme://example.com$1redirect;&lt;/p>
&lt;p>$sent_http_cache_control 1.0.8&lt;/p>
&lt;p>$sent_http_connection 1.0.8&lt;/p>
&lt;p>$sent_http_content_length 1.0.8&lt;/p>
&lt;p>$sent_http_content_type 1.0.8&lt;/p>
&lt;p>$sent_http_keep_alive 1.0.8&lt;/p>
&lt;p>$sent_http_last_modified 1.0.8&lt;/p>
&lt;p>$sent_http_location 1.0.8&lt;/p>
&lt;p>$sent_http_transfer_encoding 1.0.8&lt;/p>
&lt;p>$server_addr 1.0.8 服务器地址，如果没有用 listen 指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费);&lt;/p>
&lt;p>$server_name 1.0.8 请求到达的服务器名;&lt;/p>
&lt;p>$server_port 1.0.8 请求到达的服务器端口号;&lt;/p>
&lt;p>$server_protocol 1.0.8 请求的协议版本，&amp;ldquo;HTTP/1.0&amp;quot;或&amp;quot;HTTP/1.1&amp;rdquo;;&lt;/p>
&lt;p>$uri 1.0.8 请求的 URI，可能和最初的值有不同，比如经过重定向之类的。&lt;/p>
&lt;h1 id="虚拟主机与负载均衡">虚拟主机与负载均衡&lt;/h1>
&lt;pre tabindex="0">&lt;code>upstream blog.ha97.com {
#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。
server 192.168.80.121:80 weight=3;
server 192.168.80.122:80 weight=2;
server 192.168.80.123:80 weight=3;
}
# 反向代理
server {
listen 80;
server_name www.001.com;
location / {
proxy_pass http://192.168.84.129; //后端ip地址
proxy_redirect off; //关闭后端返回的header修改
proxy_set_header Host $host; //修改发送到后端的header的host
proxy_set_header X-Real-IP $remote_addr; //设置真实ip
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
server {
listen 80;
server_name www.002.com;
location / {
proxy_pass http://192.168.84.128; //后端ip地址
proxy_redirect off; //关闭后端返回的header修改
proxy_set_header Host $host; //修改发送到后端的header的host
proxy_set_header X-Real-IP $remote_addr; //设置真实ip
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
多个域名可以绑定到一个反向代理中。
#虚拟主机的配置
server
{
#监听端口
listen 80;
#域名可以有多个，用空格隔开
server_name www.ha97.com ha97.com;
index index.html index.htm index.php;
root /data/www/ha97;
location ~ .*\.(php|php5)?$
{
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fastcgi.conf;
}
#图片缓存时间设置
location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
{
expires 10d;
}
#JS和CSS缓存时间设置
location ~ .*\.(js|css)?$
{
expires 1h;
}
#日志格式设定
log_format access &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39;
&amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39;
&amp;#39;&amp;#34;$http_user_agent&amp;#34; $http_x_forwarded_for&amp;#39;;
#定义本虚拟主机的访问日志
access_log /var/log/nginx/ha97access.log access;
#对 &amp;#34;/&amp;#34; 启用反向代理
location / {
proxy_pass http://127.0.0.1:88;
proxy_redirect off;
proxy_set_header X-Real-IP $remote_addr;
#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#以下是一些反向代理的配置，可选。
proxy_set_header Host $host;
client_max_body_size 10m; #允许客户端请求的最大单文件字节数
client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，
proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)
proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)
proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)
proxy_buffer_size 4k; #设置代理服务器(nginx)保存用户头信息的缓冲区大小
proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置
proxy_busy_buffers_size 64k; #高负荷下缓冲大小(proxy_buffers*2)
proxy_temp_file_write_size 64k;
#设定缓存文件夹大小，大于这个值，将从upstream服务器传
}
#设定查看Nginx状态的地址
location /NginxStatus {
stub_status on;
access_log on;
auth_basic &amp;#34;NginxStatus&amp;#34;;
auth_basic_user_file conf/htpasswd;
#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。
}
#本地动静分离反向代理配置
#所有jsp的页面均交由tomcat或resin处理
location ~ .(jsp|jspx|do)?$ {
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_pass http://127.0.0.1:8080;
}
#所有静态文件由nginx直接读取不经过tomcat或resin
location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$
{ expires 15d; }
location ~ .*.(js|css)?$
{ expires 1h; }
}
&lt;/code>&lt;/pre>&lt;h1 id="代理与重定向">代理与重定向&lt;/h1>
&lt;h2 id="rewrite重定向">Rewrite(重定向)&lt;/h2>
&lt;p>&lt;strong>nginx rewrite 正则表达式匹配&lt;/strong>&lt;/p>
&lt;p>**]大小写匹配***&lt;/p>
&lt;p>~ 为区分大小写匹配&lt;/p>
&lt;p>~* 为不区分大小写匹配&lt;/p>
&lt;p>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配&lt;/p>
&lt;p>**]文件及目录匹配***&lt;/p>
&lt;p>-f 和!-f 用来判断是否存在文件&lt;/p>
&lt;p>-d 和!-d 用来判断是否存在目录&lt;/p>
&lt;p>-e 和!-e 用来判断是否存在文件或目录&lt;/p>
&lt;p>-x 和!-x 用来判断文件是否可执行&lt;/p>
&lt;p>**]flag 标记***&lt;/p>
&lt;p>last 相当于 Apache 里的[L]标记，表示完成 rewrite&lt;/p>
&lt;p>break 终止匹配, 不再匹配后面的规则。&lt;/p>
&lt;p>redirect 返回 302 临时重定向 地址栏会显示跳转后的地址。&lt;/p>
&lt;p>permanent 返回 301 永久重定向 地址栏会显示跳转后的地址。&lt;/p>
&lt;p>logcation 的几个使用实例：&lt;/p>
&lt;p>1)location / { }：匹配任何查询，因为所有请求都以 / 开头。但是正则表达式规则将被优先和查询匹配。&lt;/p>
&lt;p>2)location =/ {}：仅仅匹配/&lt;/p>
&lt;p>3)location ~\\\\\* .(gif|jpg|jpeg)$&lt;/p>
&lt;pre>&lt;code> ｛
rewrite \.(gif|jpg)$ /logo.png;
｝：location不区分大小写，匹配任何以gif，jpg，jpeg结尾的文件。
&lt;/code>&lt;/pre>
&lt;p>几个实例：&lt;/p>
&lt;p>**多目录转成参数 **&lt;/p>
&lt;p>要求：abc.domian.com/sort/2 =&amp;gt; abc.domian.com/index.php?act=sort&amp;amp;name=abc&amp;amp;id=2&lt;/p>
&lt;p>规则配置：&lt;/p>
&lt;p>if ($host ~_ (._).domain.com) {&lt;/p>
&lt;pre>&lt;code>set $sub_name $1;
rewrite ^/sort\/(\d+)\/?$ /index.php?act=sort&amp;amp;cid=$sub_name&amp;amp;id=$1 last;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>&lt;strong>目录对换&lt;/strong>&lt;/p>
&lt;p>要求：/123456/xxxx -&amp;gt; /xxxx?id=123456&lt;/p>
&lt;p>规则配置：&lt;/p>
&lt;p>rewrite ^/(\d+)/(.+)/ /$2?id=$1 last;&lt;/p>
&lt;p>再来一个针对浏览器优化的自动 rewrite，这里 rewrite 后的目录可以是存在的；&lt;/p>
&lt;p>例如设定 nginx 在用户使用 ie 的使用重定向到/nginx-ie 目录&lt;/p>
&lt;p>规则如下：&lt;/p>
&lt;p>if ($http_user_agent ~ MSIE) {&lt;/p>
&lt;pre>&lt;code> rewrite ^(.*)$ /nginx-ie/$1 break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>&lt;strong>目录自动加“/”，这个功能一般浏览器自动完成&lt;/strong>&lt;/p>
&lt;p>if (-d $request_filename){&lt;/p>
&lt;p>rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;&lt;/p>
&lt;p>}&lt;/p>
&lt;p>以下这些可能就跟广义的 rewrite 重写无关了&lt;/p>
&lt;p>&lt;strong>禁止 htaccess&lt;/strong>&lt;/p>
&lt;p>location ~/.ht {&lt;/p>
&lt;pre>&lt;code>deny all;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>**禁止多个目录 **&lt;/p>
&lt;p>location ~ ^/(cron|templates)/ {&lt;/p>
&lt;pre>&lt;code>deny all; break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>&lt;strong>禁止以/data 开头的文件，可以禁止/data/下多级目录下.log.txt 等请求&lt;/strong>&lt;/p>
&lt;p>location ~ ^/data {&lt;/p>
&lt;pre>&lt;code>deny all;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>禁止单个文件&lt;/p>
&lt;p>location ~ /data/sql/data.sql {&lt;/p>
&lt;pre>&lt;code>deny all;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>给 favicon.ico 和 robots.txt 设置过期时间; 这里为 favicon.ico 为 99 天,robots.txt 为 7 天并不记录 404 错误日志&lt;/p>
&lt;p>location ~(favicon.ico) {&lt;/p>
&lt;pre>&lt;code>log_not_found off;
expires 99d;
break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>location ~(robots.txt) {&lt;/p>
&lt;pre>&lt;code>log_not_found off;
expires 7d;
break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>设定某个文件的浏览器缓存过期时间;这里为 600 秒，并不记录访问日志&lt;/p>
&lt;p>location ^~ /html/scripts/loadhead_1.js {&lt;/p>
&lt;pre>&lt;code>access_log off;
expires 600;
break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>Nginx 还可以自定义某一类型的文件的保质期时间，具体写法看下文的代码：&lt;/p>
&lt;p>location ~* .(js|css|jpg|jpeg|gif|png|swf)$ {&lt;/p>
&lt;p>if (-f $request_filename) {&lt;/p>
&lt;p>expires 1h;&lt;/p>
&lt;p>break;&lt;/p>
&lt;p>}&lt;/p>
&lt;p>}&lt;/p>
&lt;p>//上段代码就将 js|css|jpg|jpeg|gif|png|swf 这类文件的保质期设置为一小时。&lt;/p>
&lt;p>&lt;strong>防盗链的设置：&lt;/strong>&lt;/p>
&lt;p>防盗链：如果你的网站是个下载网站，下载步骤应该是先经过你的主页找到下载地址，才能下载，为了防止某些网友直接访问下载地址完全不通过主页下载，我们就可以使用防盗链的方式，具体代码如下：&lt;/p>
&lt;p>location ~* .(gif|jpg|swf)$ {&lt;/p>
&lt;p>valid_referers none blocked start.igrow.cn sta.igrow.cn;&lt;/p>
&lt;p>if ($invalid_referer) {&lt;/p>
&lt;p>rewrite ^/ http://$host/logo.png;&lt;/p>
&lt;p>}&lt;/p>
&lt;p>}&lt;/p>
&lt;p>&lt;strong>文件反盗链并设置过期时间&amp;ndash;&amp;lt;盗链多次请求也会打开你的站点的图片啊，所以设置下缓存时间，不会每次盗链都请求并下载这张图片&amp;gt;&lt;/strong>&lt;/p>
&lt;p>location ~* ^.+.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ {&lt;/p>
&lt;pre>&lt;code>valid_referers none blocked *.jjonline.cn *.jjonline.com.cn *.lanwei.org *.jjonline.org localhost 42.121.107.189;
if ($invalid_referer) {
rewrite ^/ http://img.jjonline.cn/forbid.gif;
return 417;
break;
}
access_log off;
break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>说明：&lt;/p>
&lt;p>这里的 return 417 为自定义的 http 状态码，默认为 403，方便通过 nginx 的 log 文件找出正确的盗链的请求地址&lt;/p>
&lt;p>“rewrite ^/ &lt;a href="http://img.jjonline.cn/forbid.gif;" target="_blank" rel="noopener">http://img.jjonline.cn/forbid.gif;&lt;/a>”显示一张防盗链图片&lt;/p>
&lt;p>“access_log off;”不记录访问日志，减轻压力&lt;/p>
&lt;p>“expires 3d”所有文件 3 天的浏览器缓存&lt;/p>
&lt;p>&lt;strong>只充许固定 ip 访问网站，并加上密码；这个对有权限认证的应用比较在行&lt;/strong>&lt;/p>
&lt;p>location \ {&lt;/p>
&lt;pre>&lt;code>allow 22.27.164.25; #允许的ipd
deny all;
auth_basic “KEY”; #认证的一些设置
auth_basic_user_file htpasswd;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>说明：location 的应用也有各种变化，这里的写法就针对了根目录了。&lt;/p>
&lt;p>&lt;strong>文件和目录不存在的时重定向&lt;/strong>&lt;/p>
&lt;p>if (!-e $request_filename) {&lt;/p>
&lt;pre>&lt;code>#proxy_pass http://127.0.0.1; #这里是跳转到代理ip，这个代理ip上有一个监听的web服务器
rewrite ^/ http://www.jjonline.cn/none.html; #跳转到这个网页去
#return 404; #直接返回404码，然后会寻找root指定的404.html文件
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>**域名跳转 **&lt;/p>
&lt;p>server {&lt;/p>
&lt;pre>&lt;code>listen 80;
server_name jump.jjonline.cn #需要跳转的多级域名
index index.html index.htm index.php; #入口索引文件的名字
root /var/www/public_html/; #这个站点的根目录
rewrite ^/ http://www.jjonline.cn/;
#rewrite到这个地址，功能表现：在浏览器上输入jump.jjonline.cn并回车，不会有任何提示直接变成www.jjonline.cn
access_log off;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>&lt;strong>多域名转向&lt;/strong>&lt;/p>
&lt;p>server {&lt;/p>
&lt;pre>&lt;code>listen 80;
server_name www.jjonline.cn www.jjonline.org;
index index.html index.htm index.php;
root /var/www/public_html/;
if ($host ~ “jjonline\.org”) {
rewrite ^(.*) http://www.jjonline.cn$1 permanent;
}
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>**三级域名跳转 **&lt;/p>
&lt;p>if ($http_host ~_ “^(._).i.jjonline.cn$”) {&lt;/p>
&lt;pre>&lt;code>rewrite ^(.*) http://demo.jjonline.cn$1;
break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>&lt;strong>域名镜向&lt;/strong>&lt;/p>
&lt;p>server {&lt;/p>
&lt;pre>&lt;code>listen 80;
server_name mirror.jjonline.cn;
index index.html index.htm index.php;
root /var/www/public_html;
rewrite ^/(.*) http://www.jjonline.cn/$1 last;
access_log off;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>&lt;strong>某个子目录作镜向,这里的示例是 demo 子目录&lt;/strong>&lt;/p>
&lt;p>location ^~ /demo {&lt;/p>
&lt;pre>&lt;code>rewrite ^.+ http://demo.jjonline.cn/ last;
break;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>以下在附带本博客的 rewrite 写法，emlog 系统的 rewrite&lt;/p>
&lt;p>location ~ {&lt;/p>
&lt;pre>&lt;code>if (!-e $request_filename) {
rewrite ^/(.+)$ /index.php last;
}
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p></description></item><item><title>基础配置</title><link>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f9yyq7qehrj20p00dwt94.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="nginx-配置详解与生产环境实践">Nginx 配置详解与生产环境实践&lt;/h1>
&lt;p>在了解具体的 Nginx 配置项之前我们需要对于 Nginx 配置文件的构成有所概念，一般来说，Nginx 配置文件会由如下几个部分构成：&lt;/p>
&lt;pre tabindex="0">&lt;code># 全局块
...
# events块
events {
...
}
# http块
http
{
# http全局块
...
# 虚拟主机server块
server
{
# server全局块
...
# location块
location [PATTERN]
{
...
}
location [PATTERN]
{
...
}
}
server
{
...
}
# http全局块
...
}
&lt;/code>&lt;/pre>&lt;p>在上述配置中我们可以看出，Nginx 配置文件由以下几个部分构成：&lt;/p>
&lt;ul>
&lt;li>全局块：配置影响 nginx 全局的指令。一般有运行 nginx 服务器的用户组，nginx 进程 pid 存放路径，日志存放路径，配置文件引入，允许生成 worker process 数等。&lt;/li>
&lt;li>events 块：配置影响 nginx 服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。&lt;/li>
&lt;li>http 块：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type 定义，日志自定义，是否使用 sendfile 传输文件，连接超时时间，单连接请求数等。&lt;/li>
&lt;li>server 块：配置虚拟主机的相关参数，一个 http 中可以有多个 server。&lt;/li>
&lt;li>location 块：配置请求的路由，以及各种页面的处理情况。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>########### 每个指令必须有分号结束。#################
#user administrator administrators; #配置用户或者组，默认为nobody nobody。
#worker_processes 2; #允许生成的进程数，默认为1
#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址
error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
events {
accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on
multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off
#use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport
worker_connections 1024; #最大连接数，默认为512
}
http {
include mime.types; #文件扩展名与文件类型映射表
default_type application/octet-stream; #默认文件类型，默认为text/plain
#access_log off; #取消服务日志
log_format myFormat &amp;#39;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&amp;#39;; #自定义格式
access_log log/access.log myFormat; #combined为日志格式的默认值
sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。
# 定义常量
upstream mysvr {
server 127.0.0.1:7878;
server 192.168.10.121:3333 backup; #热备
}
error_page 404 https://www.baidu.com; #错误页
#定义某个负载均衡服务器
server {
keepalive_requests 120; #单连接请求上限次数。
listen 4545; #监听端口
server_name 127.0.0.1; #监听地址
location ~*^.+$ { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
#root path; #根目录
#index vv.txt; #设置默认页
proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表
deny 127.0.0.1; #拒绝的ip
allow 172.18.5.54; #允许的ip
}
}
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>include /etc/nginx/conf.d/*.conf;
include /etc/nginx/sites-enabled/*;
&lt;/code>&lt;/pre>&lt;h1 id="虚拟主机与静态站点">虚拟主机与静态站点&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.nginx.com/resources/admin-guide/serving-static-content/" target="_blank" rel="noopener">SERVING STATIC CONTENT&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>本部分概述如何配置 Nginx 进行静态内容服务，Nginx 的静态内容分发能力还是非常强大的。&lt;/p>
&lt;pre tabindex="0">&lt;code>http {
server {
listen 80;
server_name www.domain1.com;
access_log logs/domain1.access.log main;
location / {
index index.html;
root /var/www/domain1.com/htdocs;
}
}
server {
listen 80;
server_name www.domain2.com;
access_log logs/domain2.access.log main;
location / {
index index.html;
root /var/www/domain2.com/htdocs;
}
}
}
&lt;/code>&lt;/pre>&lt;h2 id="虚拟主机配置详解">虚拟主机配置详解&lt;/h2>
&lt;h3 id="主机与端口">主机与端口&lt;/h3>
&lt;pre tabindex="0">&lt;code>listen 127.0.0.1:8000;
listen *:8000;
listen localhost:8000;
# IPV6
listen [::]:8000;
# other params
listen 443 default_server ssl;
listen 127.0.0.1 default_server accept_filter=dataready backlog=1024
&lt;/code>&lt;/pre>&lt;h3 id="服务域名">服务域名&lt;/h3>
&lt;pre tabindex="0">&lt;code># 支持多域名配置
server_name www.barretlee.com barretlee.com;
# 支持泛域名解析
server_name *.barretlee.com;
# 支持对于域名的正则匹配
server_name ~^\.barret\.com$;
&lt;/code>&lt;/pre>&lt;h3 id="uri-匹配">URI 匹配&lt;/h3>
&lt;pre tabindex="0">&lt;code>location = / {
# 完全匹配 =
# 大小写敏感 ~
# 忽略大小写 ~*
}
location ^~ /images/ {
# 前半部分匹配 ^~
# 可以使用正则，如：
# location ~* \.(gif|jpg|png)$ { }
}
location / {
# 如果以上都未匹配，会进入这里
}
&lt;/code>&lt;/pre>&lt;h2 id="文件路径配置">文件路径配置&lt;/h2>
&lt;h3 id="根目录">根目录&lt;/h3>
&lt;pre tabindex="0">&lt;code>location / {
root /home/barret/test/;
}
&lt;/code>&lt;/pre>&lt;h3 id="别名">别名&lt;/h3>
&lt;pre tabindex="0">&lt;code>location /blog {
alias /home/barret/www/blog/;
}
location ~ ^/blog/(\d+)/([\w-]+)$ {
# /blog/20141202/article-name
# -&amp;gt; /blog/20141202-article-name.md
alias /home/barret/www/blog/$1-$2.md;
}
&lt;/code>&lt;/pre>&lt;h3 id="首页">首页&lt;/h3>
&lt;pre tabindex="0">&lt;code>index /html/index.html /php/index.php;
&lt;/code>&lt;/pre>&lt;h3 id="重定向页面">重定向页面&lt;/h3>
&lt;pre tabindex="0">&lt;code>error_page 404 /404.html;
error_page 502 503 /50x.html;
error_page 404 =200 /1x1.gif;
location / {
error_page 404 @fallback;
}
location @fallback {
# 将请求反向代理到上游服务器处理
proxy_pass http://localhost:9000;
}
&lt;/code>&lt;/pre>&lt;h3 id="try_files">try_files&lt;/h3>
&lt;pre tabindex="0">&lt;code>try_files $uri $uri.html $uri/index.html @other;
location @other {
# 尝试寻找匹配 uri 的文件，失败了就会转到上游处理
proxy_pass http://localhost:9000;
}
location / {
# 尝试寻找匹配 uri 的文件，没找到直接返回 502
try_files $uri $uri.html =502;
}
&lt;/code>&lt;/pre>&lt;h2 id="缓存配置">缓存配置&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000006689795" target="_blank" rel="noopener">HTTP 缓存的四种风味与缓存策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="expire过期时间">Expire:过期时间&lt;/h3>
&lt;p>在 Nginx 中可以配置缓存的过期时间：&lt;/p>
&lt;pre tabindex="0">&lt;code> location ~* \.(?:ico|css|js|gif|jpe?g|png)$ {
expires 30d;
add_header Vary Accept-Encoding;
access_log off;
}
&lt;/code>&lt;/pre>&lt;p>我们也可以添加更复杂的配置项：&lt;/p>
&lt;pre tabindex="0">&lt;code> location ~* ^.+\.(?:css|cur|js|jpe?g|gif|htc|ico|png|html|xml|otf|ttf|eot|woff|svg)$ {
access_log off;
expires 30d;
## No need to bleed constant updates. Send the all shebang in one
## fell swoop.
tcp_nodelay off;
## Set the OS file cache.
open_file_cache max=3000 inactive=120s;
open_file_cache_valid 45s;
open_file_cache_min_uses 2;
open_file_cache_errors off;
}
&lt;/code>&lt;/pre>&lt;h1 id="反向代理">反向代理&lt;/h1>
&lt;pre tabindex="0">&lt;code>events{
}
http{
upstream ggzy {
server 127.0.0.1:1398 weight=3;
server 127.0.0.1:1399;
}
# 80端口配置，可配置多个Virtual Host
server {
listen 80;
index index index.htm index.py index.html;
server_name app.truelore.cn;
location / {
proxy_pass_header Server;
proxy_set_header Host $http_host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Scheme $scheme;
proxy_pass http//ggzy;
}
}
}
&lt;/code>&lt;/pre>&lt;h2 id="nodejs-application">NodeJS Application&lt;/h2>
&lt;pre tabindex="0">&lt;code>const http = require(&amp;#39;http&amp;#39;);
http.createServer((req, res) =&amp;gt; {
res.end(&amp;#39;hello world&amp;#39;);
}).listen(9000);
&lt;/code>&lt;/pre>&lt;p>任何请求过来都返回 hello world，简版的 Nginx 配置如下，&lt;/p>
&lt;pre tabindex="0">&lt;code>events {
# 这里可不写东西
use epoll;
}
http {
server {
listen 127.0.0.1:8888;
# 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回
try_files $uri $uri/index.html;
location ~* ^/(js|css|image|font)/$ {
# 静态资源都在 static 文件夹下
root /home/barret/www/static/;
}
location /app {
# Node.js 在 9000 开了一个监听端口
proxy_pass http://127.0.0.1:9000;
}
# 上面处理出错或者未找到的，返回对应状态码文件
error_page 404 /404.html;
error_page 502 503 504 /50x.html;
}
}
&lt;/code>&lt;/pre>&lt;p>首先 try_files，尝试直接匹配文件；没找到就匹配静态资源；还没找到就交给 Node 处理；否则就返回 4xx/5xx 的状态码。&lt;/p>
&lt;h2 id="upstream-cache">Upstream Cache&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.nginx.com/blog/nginx-caching-guide/" target="_blank" rel="noopener">A Guide to Caching with NGINX and NGINX Plus&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>http {
,,,,,
proxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=imgcache:100m inactive=1d max_size=10g;
server {
........
location ~* ^.+\.(js|ico|gif|jpg|jpeg|png|html|htm)$ {
log_not_found off;
access_log off;
expires 7d;
proxy_pass http://img.example.com ;
proxy_cache imgcache;
proxy_cache_valid 200 302 1d;
proxy_cache_valid 404 10m;
proxy_cache_valid any 1h;
proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;
}
}
}
&lt;/code>&lt;/pre>&lt;h1 id="https">HTTPS&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000004985253" target="_blank" rel="noopener">HTTPS 理论详解与实践 &lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="lets-encrypt-证书申请">Let&amp;rsquo;s Encrypt 证书申请&lt;/h2>
&lt;p>Let&amp;rsquo;s Encrypt 为我们提供了非常方便的命令行工具&lt;a href="https://certbot.eff.org/#ubuntuxenial-nginx" target="_blank" rel="noopener">certbot&lt;/a>，笔者是在 Ubuntu 16.04 的机器上进行配置，因此只要执行如下命令即可:&lt;/p>
&lt;pre tabindex="0">&lt;code># 安装letsencrypt命令行
$ sudo apt-get install letsencrypt
# 独立的为example.com与www.example.com申请证书
$ letsencrypt certonly --standalone -d example.com -d www.example.com
# 自动执行证书刷新操作
$ letsencrypt renew --dry-run --agree-tos
&lt;/code>&lt;/pre>&lt;h2 id="基本-https-配置">基本 HTTPS 配置&lt;/h2>
&lt;p>基本的 HTTPS 支持配置如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>server {
listen 192.168.1.11:443 ssl; #ssl端口
server_name test.com;
#为一个server{......}开启ssl支持
#指定PEM格式的证书文件
ssl_certificate /etc/nginx/test.pem;
#指定PEM格式的私钥文件
ssl_certificate_key /etc/nginx/test.key;
ssl_session_cache shared:SSL:1m;
ssl_session_timeout 5m;
ssl_ciphers HIGH:!aNULL:!MD5;
ssl_prefer_server_ciphers on;
location / {
root html;
index index.html index.htm;
}
}
&lt;/code>&lt;/pre>&lt;p>在真实的生产环境中，我们的配置如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>server {
# 如果需要spdy也可以加上,lnmp1.2及其后版本都默认支持spdy,lnmp1.3 nginx 1.9.5以上版本默认支持http2
listen 443 ssl;
# 这里是你的域名
server_name www.vpser.net;
index index.html index.htm index.php default.html default.htm default.php;
# 网站目录
root /home/wwwroot/www.vpser.net;
# 前面生成的证书，改一下里面的域名就行
ssl_certificate /etc/letsencrypt/live/www.vpser.net/fullchain.pem;
# 前面生成的密钥，改一下里面的域名就行
ssl_certificate_key /etc/letsencrypt/live/www.vpser.net/privkey.pem;
ssl_ciphers &amp;#34;EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5&amp;#34;;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_prefer_server_ciphers on;
ssl_session_cache shared:SSL:10m;
#这个是伪静态根据自己的需求改成其他或删除
include wordpress.conf;
#error_page 404 /404.html;
location ~ [^/]\.php(/|$)
{
# comment try_files $uri =404; to enable pathinfo
try_files $uri =404;
fastcgi_pass unix:/tmp/php-cgi.sock;
fastcgi_index index.php;
# lnmp 1.0及之前版本替换为include fcgi.conf;
include fastcgi.conf;
#include pathinfo.conf;
}
location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
{
expires 30d;
}
location ~ .*\.(js|css)?$
{
expires 12h;
}
access_log off;
}
&lt;/code>&lt;/pre>&lt;h2 id="强制-http-转到-https">强制 HTTP 转到 HTTPS&lt;/h2>
&lt;h3 id="nginx-rewrite">Nginx Rewrite&lt;/h3>
&lt;pre tabindex="0">&lt;code>server {
listen 192.168.1.111:80;
server_name test.com;
rewrite ^(.*)$ https://$host$1 permanent;
}
&lt;/code>&lt;/pre>&lt;h3 id="nginx-497-错误码">Nginx 497 错误码&lt;/h3>
&lt;p>利用 error_page 命令将 497 状态码的链接重定向到https://test.com这个域名上&lt;/p>
&lt;pre tabindex="0">&lt;code>server {
listen 192.168.1.11:443; #ssl端口
listen 192.168.1.11:80; #用户习惯用http访问，加上80，后面通过497状态码让它自动跳到443端口
server_name test.com;
#为一个server{......}开启ssl支持
ssl on;
#指定PEM格式的证书文件
ssl_certificate /etc/nginx/test.pem;
#指定PEM格式的私钥文件
ssl_certificate_key /etc/nginx/test.key;
#让http请求重定向到https请求
error_page 497 https://$host$uri?$args;
}
&lt;/code>&lt;/pre>&lt;h3 id="meta-刷新前端跳转">Meta 刷新，前端跳转&lt;/h3>
&lt;p>在 HTTP 正常返回的页面中添加 meta 属性：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&amp;#34;refresh&amp;#34; content=&amp;#34;0;url=https://test.com/&amp;#34;&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>server {
listen 192.168.1.11:80;
server_name test.com;
location / {
#index.html放在虚拟主机监听的根目录下
root /srv/www/http.test.com/;
}
#将404的页面重定向到https的首页
error_page 404 https://test.com/;
}
&lt;/code>&lt;/pre>&lt;h2 id="反向-https-转发到内部-http">反向 HTTPS 转发到内部 HTTP&lt;/h2></description></item><item><title>进程模型</title><link>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-series/4.%E6%8E%A5%E5%85%A5%E7%BD%91%E5%85%B3/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="nginx-进程与处理模型">Nginx 进程与处理模型&lt;/h1>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/67636582" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67636582&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>