<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>4.云原生 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/</link><atom:link href="https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml"/><description>4.云原生</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>4.云原生</title><link>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/</link></image><item><title>12-Factor 应用原则</title><link>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/12-factor-%E5%BA%94%E7%94%A8%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/12-factor-%E5%BA%94%E7%94%A8%E5%8E%9F%E5%88%99/</guid><description>&lt;h1 id="12-factor-应用原则">12-Factor 应用原则&lt;/h1>
&lt;ul>
&lt;li>使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。&lt;/li>
&lt;li>和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。&lt;/li>
&lt;li>适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。&lt;/li>
&lt;li>将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。&lt;/li>
&lt;li>易拓展：可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。&lt;/li>
&lt;/ul>
&lt;h1 id="i-基准代码一份基准代码codebase多份部署deploy">I. 基准代码：一份基准代码（Codebase），多份部署（deploy）&lt;/h1>
&lt;p>12-Factor 应用通常会使用版本控制系统加以管理，如 Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。&lt;/p>
&lt;p>一份代码库对应多份部署，基准代码和应用之间总是保持一一对应的关系：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/637ecf9f16f2c2beb1359d50.png" alt="Codebase to deploys" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们（然而多个应用共享一份基准代码缺在很多公司很常见，特别在 ToB 的公司，很多公司会有定制需求）。尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。·&lt;/p>
&lt;p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。&lt;/p>
&lt;h1 id="ii-依赖显式声明依赖关系-dependency-">II. 依赖：显式声明依赖关系（ dependency ）&lt;/h1>
&lt;p>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。12-Factor 规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。&lt;/p>
&lt;p>例如， Ruby 的 Bundler 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具：Pip 用作依赖声明， Virtualenv 用作依赖隔离。甚至 C 语言也有类似工具， Autoconf 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。&lt;/p>
&lt;p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是 curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。&lt;/p>
&lt;h1 id="iii-配置在环境中存储配置">III. 配置：在环境中存储配置&lt;/h1>
&lt;p>通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：&lt;/p>
&lt;ul>
&lt;li>数据库，Memcached，以及其他 后端服务 的配置&lt;/li>
&lt;li>第三方服务的证书，如 Amazon S3、Twitter 等&lt;/li>
&lt;li>每份部署特有的配置，如域名等&lt;/li>
&lt;/ul>
&lt;p>有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时代码模块间的依赖注入关系。这类配置在不同部署间不存在差异，所以应该写入代码。&lt;/p>
&lt;p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。&lt;/p>
&lt;p>12-Factor 推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如 Rails 中的 development, test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa。随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。&lt;/p>
&lt;p>12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。&lt;/p>
&lt;h1 id="iv-后端服务把后端服务当作附加资源backing-services">IV. 后端服务：把后端服务当作附加资源(backing services)&lt;/h1>
&lt;p>后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。&lt;/p>
&lt;p>12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。&lt;/p>
&lt;p>每个不同的后端服务是一份资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/637ed87116f2c2beb1421445.png" alt="一种部署附加 4 个后端服务" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。&lt;/p>
&lt;h1 id="v-构建发布运行严格分离构建和运行">V. 构建，发布，运行：严格分离构建和运行&lt;/h1>
&lt;p>基准代码 转化为一份部署(非开发环境)需要以下三个阶段：&lt;/p>
&lt;ul>
&lt;li>构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。&lt;/li>
&lt;li>发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。&lt;/li>
&lt;li>运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序进程。代码被构建，然后和配置结合成为发布版本&lt;/li>
&lt;/ul>
&lt;p>12-factor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/637ed8f616f2c2beb1428dea.png" alt="版本回退" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。&lt;/p>
&lt;h1 id="vi-进程以一个或多个无状态进程运行应用">VI. 进程：以一个或多个无状态进程运行应用&lt;/h1>
&lt;p>运行环境中，应用程序通常是以一个和多个进程运行的。最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如 python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。&lt;/p>
&lt;p>12-Factor 应用的进程必须无状态且无共享。任何需要持久化的数据都要存储在后端服务内，比如数据库。内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor 应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。&lt;/p>
&lt;p>源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤 做此动作：正如 Rails 资源管道 ，而不是在运行阶段。一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。&lt;/p>
&lt;h1 id="vii-端口绑定通过端口绑定提供服务">VII. 端口绑定：通过端口绑定提供服务&lt;/h1>
&lt;p>互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。&lt;/p>
&lt;p>本地环境中，开发人员通过类似 http://localhost:5000/ 的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的 Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。&lt;/p>
&lt;p>HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。&lt;/p>
&lt;h1 id="viii-并发通过进程模型进行扩展">VIII. 并发：通过进程模型进行扩展&lt;/h1>
&lt;p>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。扩展表现为运行中的进程，工作多样性表现为进程类型。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/637ee5f416f2c2beb154f6bb.png" alt="通过进程模型扩展" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。&lt;/p>
&lt;p>上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。&lt;/p>
&lt;h2 id="多线程">多线程&lt;/h2>
&lt;h1 id="ix-易处理快速启动和优雅终止可最大化健壮性">IX. 易处理：快速启动和优雅终止可最大化健壮性&lt;/h1>
&lt;p>12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。&lt;/p>
&lt;p>进程 一旦接收 终止信号（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是 HTTP 请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个 NACK 信号。 Beanstalkd 中，任务终止并退回队列会在 worker 断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。&lt;/p>
&lt;p>进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。&lt;/p>
&lt;h1 id="x-开发环境与线上环境等价尽可能的保持开发预发布线上环境相同">X. 开发环境与线上环境等价：尽可能的保持开发，预发布，线上环境相同&lt;/h1>
&lt;p>从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：&lt;/p>
&lt;ul>
&lt;li>时间差异：开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。&lt;/li>
&lt;li>人员差异：开发人员编写代码，运维人员部署代码。&lt;/li>
&lt;li>工具差异：开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。&lt;/li>
&lt;/ul>
&lt;p>12-Factor 应用想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异:&lt;/p>
&lt;ul>
&lt;li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。&lt;/li>
&lt;li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。&lt;/li>
&lt;li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。&lt;/li>
&lt;/ul>
&lt;p>将上述总结变为一个表格如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Item&lt;/th>
&lt;th>传统应用&lt;/th>
&lt;th>12-Factor 应用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>每次部署间隔&lt;/td>
&lt;td>数周&lt;/td>
&lt;td>几个小时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>开发人员 vs 运维人员&lt;/td>
&lt;td>不同的人&lt;/td>
&lt;td>相同的人&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>开发环境 vs 线上环境&lt;/td>
&lt;td>不同&lt;/td>
&lt;td>尽量接近&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>语言&lt;/th>
&lt;th>类库&lt;/th>
&lt;th>适配器&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>数据库&lt;/td>
&lt;td>Ruby/Rails&lt;/td>
&lt;td>ActiveRecord&lt;/td>
&lt;td>MySQL, PostgreSQL, SQLite&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>队列&lt;/td>
&lt;td>Python/Django&lt;/td>
&lt;td>Celery&lt;/td>
&lt;td>RabbitMQ, Beanstalkd, Redis&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>缓存&lt;/td>
&lt;td>Ruby/Rails&lt;/td>
&lt;td>ActiveSupport::Cache&lt;/td>
&lt;td>Memory, filesystem,Memcached&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。&lt;/p>
&lt;p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于 Homebrew，apt-get 等现代的打包系统，诸如 Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。&lt;/p>
&lt;h1 id="xi-日志把日志当作事件流">XI. 日志：把日志当作事件流&lt;/h1>
&lt;p>日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。&lt;/p>
&lt;p>12-factor 应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。&lt;/p>
&lt;p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：&lt;/p>
&lt;ul>
&lt;li>找出过去一段时间特殊的事件。&lt;/li>
&lt;li>图形化一个大规模的趋势，比如每分钟的请求量。&lt;/li>
&lt;li>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。&lt;/li>
&lt;/ul>
&lt;h1 id="xii-管理进程后台管理任务当作一次性进程运行">XII. 管理进程——后台管理任务当作一次性进程运行&lt;/h1>
&lt;p>进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：&lt;/p>
&lt;ul>
&lt;li>运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。&lt;/li>
&lt;li>运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。&lt;/li>
&lt;li>运行一些提交到代码仓库的一次性脚本。&lt;/li>
&lt;/ul>
&lt;p>一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。所有进程类型应该使用同样的 依赖隔离 技术。例如，如果 Ruby 的 web 进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。&lt;/p>
&lt;p>12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用 ssh 或是运行环境提供的其他机制来运行这样的进程。&lt;/p>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/5d523c5b3739" target="_blank" rel="noopener">https://www.jianshu.com/p/5d523c5b3739&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Distributionless</title><link>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/distributionless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/distributionless/</guid><description>&lt;h1 id="distributionless">Distributionless&lt;/h1>
&lt;p>云原生是分布式应用当下重要的发展路径，其终态应当是 Distributionless。背后的含义有两点。首先，所有与分布式相关的问题由云平台解决。换句话说，基于云平台做二次开发的开发者无需掌握底层复杂的技术与概念就能高效地开发、部署和发布应用。云平台会提供各种工具作为脚手架，帮助开发者去发现问题、诊断、排错和做资源编排等工作。其二，分布式应用的开发会跟传统应用的开发一样方便，甚至更加便捷。信息流动的效率与充分度是很多创新的重要因素，互联网天然具有这些优势，这种优势一定会让分布式应用的开发效率持续得到巨大改善。&lt;/p>
&lt;p>Distrubutionless 的发展趋势是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>平台变厚、变重、变标准，应用变薄、变轻。分布式应用的复杂度无论用什么技术方案都是存在的，关键在于如何解和在哪儿解。逻辑上，将复杂度下沉到平台才是正道，这就带来了平台变厚和重、应用变薄和轻的结果。沿着云原生的路径，只有平台标准化才能最终实现应用的可移植性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据平面网格化。分布式应用从单体走向微服务软件架构，所隐含的思路是数据平面应当网格化。服务网格作为云原生的关键技术，未来一定存在不同应用对于网格的定制需求，不同应用定制所带来的开销应当由应用所在的机器承担，而不能转嫁给其他应用，唯有网格化才能实现资源使用在应用级别的资源隔离（不同的应用加载实现不同定制逻辑的插件）。类似 RSocket 这样采用集中 Broker 的技术根本无法满足这一要求。数据平面的最大挑战在于如何隔离好业务对数据平面的定制化要求，以及如何做到路径无损。后者是指，在增加 Sidecar 的情形下，通过技术创新实现 RT 和资源占用趋于零。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>控制平面集中化。数据平面与控制平面是孪生兄弟，一个“形散”的数据平面需要有一个“神不散”的控制平面去帮助实现全局治理。控制平面的技术挑战在于如何在最短的时间内，将整个集群的相关控制信息推送到数据平面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运维平面产品化。产品化水平的高低代表了未来分布式应用运维便利性和应急响应的及时性。产品化过程中对概念的抽象和人机交互的设计，代表了云平台厂商对分布式应用开发这一专业领域的洞见和最佳实践，也表达了云厂商对使用技术的人性化的认知深度。产品化工作一定不是以图形化的人机交互方式去表达技术细节，而是为用户塑造一套让人容易理解和掌握的心智模式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开发平面无缝整合。开发平面由分布式应用的开发者日常工作所应遵守的流程组成，包含代不限于需求与任务分解、概要设计、编码、单元测试、集成测试、代码管理、软件打包和发布等内容。开发平面如何做到以开发者为中心，使他能流畅而高效地开展自己的工作是关键挑战。此外，开发平面的设计需要对高效软件开发的方法论有很好的梳理与表达，且能践行行业的一些共识实践。比如，能方便地实现需求的可溯和软件缺陷的跟踪。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于云平台厂商来说，Distributionless 的关键竞争力来自运维平面的产品化和开发平面无缝整合的能力。这两块是直接触达客户和用户体现技术以更快、更好交付客户价值的关键。相信“体验为王”在未来分布式应用领域同样适用。&lt;/p></description></item><item><title>Serverless</title><link>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/serverless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-series/1.%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84/4.%E4%BA%91%E5%8E%9F%E7%94%9F/serverless/</guid><description>&lt;h1 id="serverless--无服务器架构">Serverless | 无服务器架构&lt;/h1>
&lt;p>Serverless 无服务器是一种架构理念，其核心思想是将提供服务资源的基础设施抽象成各种服务，以 API 接口的方式供给用户按需调用，真正做到按需伸缩、按使用收费。消除了对传统的海量持续在线服务器组件的需求，降低了开发和运维的复杂性，降低运营成本并缩短了业务系统的交付周期，使得用户能够专注在价值密度更高的业务逻辑的开发上。&lt;/p>
&lt;p>目前业界较为公认的无服务器架构主要包括两个方面，即提供计算资源的函数服务平台 FaaS，以及提供托管云服务的后端服务 BaaS。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>函数即服务（Function as a Service）：是一项基于事件驱动的函数托管计算服务。通过函数服务，开发者只需要编写业务函数代码并设置运行的条件，无需配置和管理服务器等基础设施，函数代码运行在无状态的容器中，由事件触发且短暂易失，并完全由第三方管理，基础设施对应用开发者完全透明。函数以弹性、高可靠的方式运行，并且按实际执行资源计费，不执行不产生费用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>后端即服务（Backend as a Service）：BaaS 覆盖了应用可能依赖的所有第三方服务，如云数据库、身份验证、对象存储等服务，开发人员通过 API 和由 BaaS 服务商提供的 SDK，能够集成所需的所有后端功能，而无需构建后端应用，更不必管理虚拟机或容器等基础设施，就能保证应用的正常运行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="客户价值">客户价值&lt;/h2>
&lt;p>无服务器架构是一种新的软件架构范式，它因为 AWS Lambda 服务而推广。Serverless 对客户的最大价值有两点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将资本支出（CAPEX）变成了运营成本（OPEX），且能很好地解决业务“估不准问题”。Serverless 采用更精确地根据业务量所消耗的资源去支付费用，无需在事先估计业务量而先采购好计算资源。传统的通过预估业务峰值采购计算资源的方式下，如果业务量估高了就会造成采购多余的资源而带来浪费，如果业务量估少了又会使得业务价值无法最大化而让营收变窄。Serverless 从技术层面做到了可以在毫秒级实现计算资源扩容而很好地应对业务流量的波动。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>省去了高昂的运维成本。Serverless 由于是免服务器运维的，所以不需要配置相应的人员去运维服务器。Serverless 的整个解决方案通过封装向开发者屏蔽了大量的技术细节，让开发者可以专注于业务逻辑而带去更高的开发效率和缩短业务上线时间。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可以预见，Serverless 是弹性、易用性和移植性的重要落地形式。有部分人对 Service Mesh 和 Serverless 存在这样的困惑：Service Mesh 是解决微服务软件架构下服务与服务之间复杂度问题的，只要采纳了微服务软件架构就应当使用 Service Mesh。Serverless 解决的是免服务器运维的问题，一个运用于微服务软件架构的 Serverless 解决方案，应当包含 Service Mesh 的内容，只不过对于终端的开发者很可能感知不到而已。&lt;/p>
&lt;h1 id="faas">FaaS&lt;/h1>
&lt;p>FaaS 的理念是，诸如亚马逊之类的云提供商甚至是诸如 Fission.io 或 funktion 之类的本地软件都可以提供服务，其中用户可以请求远程运行的功能以执行非常特定的任务。功能结束后，这些结果将返回给用户。不维护任何服务或有状态数据，并且用户将功能代码提供给运行该功能的服务。&lt;/p>
&lt;p>无服务器架构的优势在于，不需要配置虚拟机和/或容器来构建利用 FaaS 的应用程序部分。一旦它们的功能结束，运行这些功能的计算实例从用户的角度来看就不再存在。此外，需要由用户监控和维护的微服务和/或容器的数量减少，节省了成本、时间和精力。&lt;/p>
&lt;p>无服务器架构为软件工程师和架构师提供了另一种功能强大的软件构建工具，可用于设计灵活且可扩展的软件。已知的 FaaS 有 Amazon 的 AWS Lambda、Microsoft 的 Azure Functions、Google 的 Cloud Functions 等。&lt;/p>
&lt;h2 id="缺陷">缺陷&lt;/h2>
&lt;p>与微服务和云原生应用程序类似，无服务器架构并不适用于所有场景。FaaS 提供的功能本身并不保持状态，这意味着在编写功能代码时需要特别注意。这与全微服务不同——开发人员可以完全控制状态。尽管有这种限制，但在 FaaS 的情况下保持状态的一种方法是将状态传播到数据库或像 Redis 这样的内存缓存。&lt;/p>
&lt;p>这些功能的启动时间并不总是很快，因为要有时间分配给 FaaS 服务提供商发送请求，然后在某些情况下启动运行该功能的计算实例也需要时间。在设计无服务器应用程序时必须考虑这些延迟。FaaS 不像微服务那样持续运行，这使得它们不适合任何需要持续运行软件的任务。&lt;/p>
&lt;p>无服务器应用程序具有与其他云原生应用程序相同的限制，其中应用程序从一个云提供商到另一个云提供商，或从云到本地环境的可移植性因供应商锁定而变得具有挑战性。&lt;/p>
&lt;h1 id="baas">BaaS&lt;/h1>
&lt;p>无服务器应用程序的另一个定义是使用 BaaS 或后端作为服务范式的应用程序。BaaS 的想法是，开发人员只编写其应用程序的客户端代码，然后依赖于托管在云中的多个软件预构建服务（可通过 API 访问）。BaaS 在移动应用程序编程中很受欢迎，开发人员可以依赖大量的后端服务来驱动应用程序的大部分功能。BaaS 服务的例子有：Firebase 和 Parse。&lt;/p></description></item></channel></rss>