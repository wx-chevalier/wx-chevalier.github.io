<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>多主复制 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/distributedstorage-notes/02.%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/</link><atom:link href="https://ng-tech.icu/books/distributedstorage-notes/02.%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/index.xml" rel="self" type="application/rss+xml"/><description>多主复制</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>多主复制</title><link>https://ng-tech.icu/books/distributedstorage-notes/02.%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/</link></image><item><title>冲突解决</title><link>https://ng-tech.icu/books/distributedstorage-notes/02.%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/distributedstorage-notes/02.%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</guid><description>&lt;h1 id="多主复制中的冲突解决">多主复制中的冲突解决&lt;/h1>
&lt;p>多领导者复制的最大问题是可能发生写冲突，这意味着需要解决冲突。例如，两个写操作并发地修改了同一条记录中的同一个字段，并将其设置为两个不同的值。考虑一个由两个用户同时编辑的维基页面，如下图所示。用户 1 将页面的标题从 A 更改为 B，并且用户 2 同时将标题从 A 更改为 C。每个用户的更改已成功应用到其本地主库。但当异步复制时，会发现冲突。单主数据库中不会出现此问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2020/02/09/1fsqr8.md.png" alt="两个主库同时更新同一记录引起的写入冲突" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其他类型的冲突可能更为微妙，难以发现。例如，考虑一个会议室预订系统：它记录谁订了哪个时间段的哪个房间。应用需要确保每个房间只有一组人同时预定（即不得有相同房间的重叠预订）。在这种情况下，如果同时为同一个房间创建两个不同的预订，则可能会发生冲突。即使应用程序在允许用户进行预订之前检查可用性，如果两次预订是由两个不同的领导者进行的，则可能会有冲突。&lt;/p>
&lt;h1 id="同步与异步冲突检测">同步与异步冲突检测&lt;/h1>
&lt;p>在单主数据库中，第二个写入将被阻塞，并等待第一个写入完成，或中止第二个写入事务，强制用户重试。另一方面，在多活配置中，两个写入都是成功的，并且在稍后的时间点仅仅异步地检测到冲突。那时要求用户解决冲突可能为时已晚。&lt;/p>
&lt;p>原则上，可以使冲突检测同步 - 即等待写入被复制到所有副本，然后再告诉用户写入成功。但是，通过这样做，您将失去多主复制的主要优点：允许每个副本独立接受写入。如果您想要同步冲突检测，那么您可以使用单主程序复制。&lt;/p>
&lt;h1 id="避免冲突">避免冲突&lt;/h1>
&lt;p>处理冲突的最简单的策略就是避免它们：如果应用程序可以确保特定记录的所有写入都通过同一个领导者，那么冲突就不会发生。由于多领导者复制处理的许多实现冲突相当不好，避免冲突是一个经常推荐的方法。&lt;/p>
&lt;p>例如，在用户可以编辑自己的数据的应用程序中，可以确保来自特定用户的请求始终路由到同一数据中心，并使用该数据中心的领导者进行读写。不同的用户可能有不同的“家庭”数据中心（可能根据用户的地理位置选择），但从任何用户的角度来看，配置基本上都是单一的领导者。&lt;/p>
&lt;p>但是，有时您可能需要更改指定的记录的主库——可能是因为一个数据中心出现故障，您需要将流量重新路由到另一个数据中心，或者可能是因为用户已经迁移到另一个位置，现在更接近不同的数据中心。在这种情况下，冲突避免会中断，你必须处理不同主库同时写入的可能性。&lt;/p>
&lt;h1 id="收敛至一致的状态">收敛至一致的状态&lt;/h1>
&lt;p>单主数据库按顺序应用写操作：如果同一个字段有多个更新，则最后一个写操作将确定该字段的最终值。在多主配置中，写入顺序没有定义，所以最终值应该是什么并不清楚。在标题修改的例子中，在主库 1 中标题首先更新为 B 而后更新为 C；在主库 2 中，首先更新为 C，然后更新为 B。两个顺序都不是“更正确”的。&lt;/p>
&lt;p>如果每个副本只是按照它看到写入的顺序写入，那么数据库最终将处于不一致的状态：最终值将是在主库 1 的 C 和主库 2 的 B。这是不可接受的，每个复制方案都必须确保数据在所有副本中最终都是相同的。因此，数据库必须以一种收敛（convergent）的方式解决冲突，这意味着所有副本必须在所有变更复制完成时收敛至一个相同的最终值。&lt;/p>
&lt;p>实现冲突合并解决有多种途径：&lt;/p>
&lt;ul>
&lt;li>给每个写入一个唯一的 ID（例如，一个时间戳，一个长的随机数，一个 UUID 或者一个键和值的哈希），挑选最高 ID 的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为最后写入胜利（LWW, last write wins）。虽然这种方法很流行，但是很容易造成数据丢失。&lt;/li>
&lt;li>为每个副本分配一个唯一的 ID，ID 编号更高的写入具有更高的优先级。这种方法也意味着数据丢失。&lt;/li>
&lt;li>以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连接它们。&lt;/li>
&lt;li>在保留所有信息的显式数据结构中记录冲突，并编写解决冲突的应用程序代码（也许通过提示用户的方式）。&lt;/li>
&lt;/ul>
&lt;h1 id="自定义冲突解决逻辑">自定义冲突解决逻辑&lt;/h1>
&lt;p>作为解决冲突最合适的方法可能取决于应用程序，大多数多主复制工具允许使用应用程序代码编写冲突解决逻辑。该代码可以在写入或读取时执行。&lt;/p>
&lt;h2 id="写时执行">写时执行&lt;/h2>
&lt;p>只要数据库系统检测到复制更改日志中存在冲突，就会调用冲突处理程序。例如，Bucardo 允许您为此编写一段 Perl 代码。这个处理程序通常不能提示用户——它在后台进程中运行，并且必须快速执行。&lt;/p>
&lt;h2 id="读时执行">读时执行&lt;/h2>
&lt;p>当检测到冲突时，所有冲突写入被存储。下一次读取数据时，会将这些多个版本的数据返回给应用程序。应用程序可能会提示用户或自动解决冲突，并将结果写回数据库。例如，CouchDB 以这种方式工作。请注意，冲突解决通常适用于单个行或文档层面，而不是整个事务。因此，如果您有一个事务会原子性地进行几次不同的写入，则对于冲突解决而言，每个写入仍需分开单独考虑。&lt;/p></description></item><item><title>多主复制拓扑</title><link>https://ng-tech.icu/books/distributedstorage-notes/02.%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/distributedstorage-notes/02.%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91/</guid><description>&lt;h1 id="多主复制拓扑">多主复制拓扑&lt;/h1>
&lt;p>复制拓扑描述写入从一个节点传播到另一个节点的通信路径。如果你有两个领导者，只有一个合理的拓扑结构：领导者 1 必须把他所有的写到领导者 2，反之亦然。有两个以上的领导，各种不同的拓扑是可能的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2020/02/09/1fy5eU.png" alt="三个可以设置多领导者复制的示例拓扑。" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最普遍的拓扑是全部到全部，其中每个领导者将其写入每个其他领导。但是，也会使用更多受限制的拓扑：例如，默认情况下，MySQL 仅支持环形拓扑（circular topology）。其中每个节点接收来自一个节点的写入，并将这些写入（加上自己的任何写入）转发给另一个节点。另一种流行的拓扑结构具有星形的形状，一个指定的根节点将写入转发给所有其他节点。星型拓扑可以推广到树。&lt;/p>
&lt;p>在圆形和星形拓扑中，写入可能需要在到达所有副本之前通过多个节点。因此，节点需要转发从其他节点收到的数据更改。为了防止无限复制循环，每个节点被赋予一个唯一的标识符，并且在复制日志中，每个写入都被标记了所有已经通过的节点的标识符。当一个节点收到用自己的标识符标记的数据更改时，该数据更改将被忽略，因为节点知道它已经被处理。&lt;/p>
&lt;p>循环和星型拓扑的问题是，如果只有一个节点发生故障，则可能会中断其他节点之间的复制消息流，导致它们无法通信，直到节点修复。拓扑结构可以重新配置为在发生故障的节点上工作，但在大多数部署中，这种重新配置必须手动完成。更密集连接的拓扑结构（例如全部到全部）的容错性更好，因为它允许消息沿着不同的路径传播，避免单点故障。&lt;/p>
&lt;p>另一方面，全能拓扑也可能有问题。特别是，一些网络链接可能比其他网络链接更快（例如，由于网络拥塞），结果是一些复制消息可能“超过”其他复制消息，如下图所示。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2020/02/09/1f6Y0U.md.png" alt="使用多主程序复制时，可能会在某些副本中写入错误的顺序" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>客户端 A 向主库 1 的表中插入一行，客户端 B 在主库 3 上更新该行。然而，主库 2 可以以不同的顺序接收写入：它可以首先接收更新（其中，从它的角度来看，是对数据库中不存在的行的更新），并且仅在稍后接收到相应的插入（其应该在更新之前）。这是一个因果关系的问题，类似于我们在“一致前缀读”中看到的：更新取决于先前的插入，所以我们需要确保所有节点先处理插入，然后再处理更新。仅仅在每一次写入时添加一个时间戳是不够的，因为时钟不可能被充分地同步，以便在主库 2 处正确地排序这些事件。&lt;/p></description></item></channel></rss>