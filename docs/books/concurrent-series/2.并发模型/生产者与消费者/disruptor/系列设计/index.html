<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="Disruptor 设计 Disruptor 通过以下设计来解决队列速度慢的问题： 环形数组结构：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。 元素位置定位：数组长度 2^n，通过位运算，加快定位的速度。下标采取递"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E7%B3%BB%E5%88%97%E8%AE%BE%E8%AE%A1/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E7%B3%BB%E5%88%97%E8%AE%BE%E8%AE%A1/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E7%B3%BB%E5%88%97%E8%AE%BE%E8%AE%A1/"><meta property="og:title" content="系列设计 | Next-gen Tech Edu"><meta property="og:description" content="Disruptor 设计 Disruptor 通过以下设计来解决队列速度慢的问题： 环形数组结构：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。 元素位置定位：数组长度 2^n，通过位运算，加快定位的速度。下标采取递"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>系列设计 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=e5e05b397c13c0be14e4edf47cae352a><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">Disruptor</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idf32e1365267a317ecd63f620ccbc241c")' href=#idf32e1365267a317ecd63f620ccbc241c aria-expanded=false aria-controls=idf32e1365267a317ecd63f620ccbc241c aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/>生产者与消费者</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idf32e1365267a317ecd63f620ccbc241c aria-expanded=false aria-controls=idf32e1365267a317ecd63f620ccbc241c><i class="fa-solid fa-angle-down" id=caret-idf32e1365267a317ecd63f620ccbc241c></i></a></div><ul class="nav docs-sidenav collapse show" id=idf32e1365267a317ecd63f620ccbc241c><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id09b47cda43382257fd8ae10b9338700d")' href=#id09b47cda43382257fd8ae10b9338700d aria-expanded=false aria-controls=id09b47cda43382257fd8ae10b9338700d aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/>Disruptor</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id09b47cda43382257fd8ae10b9338700d aria-expanded=false aria-controls=id09b47cda43382257fd8ae10b9338700d><i class="fa-solid fa-angle-down" id=caret-id09b47cda43382257fd8ae10b9338700d></i></a></div><ul class="nav docs-sidenav collapse show" id=id09b47cda43382257fd8ae10b9338700d><li class="child level"><a href=/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E6%9B%B4%E5%A4%9A%E6%A1%88%E4%BE%8B/>更多案例</a></li><li class="child level"><a href=/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/>快速开始</a></li><li class="child level"><a href=/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B/>生产与消费流程</a></li><li class="child level active"><a href=/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E7%B3%BB%E5%88%97%E8%AE%BE%E8%AE%A1/>系列设计</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#核心组件>核心组件</a></li><li><a href=#ringbuffer>RingBuffer</a></li></ul><ul><li><a href=#锁的损耗>锁的损耗</a></li><li><a href=#伪共享>伪共享</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>系列设计</h1><div class=article-style><h1 id=disruptor-设计>Disruptor 设计</h1><p>Disruptor 通过以下设计来解决队列速度慢的问题：</p><ul><li>环形数组结构：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</li><li>元素位置定位：数组长度 2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心 index 溢出的问题。index 是 long 类型，即使 100 万 QPS 的处理速度，也需要 30 万年才能用完。</li><li>无锁设计：每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</li></ul><h2 id=核心组件>核心组件</h2><ul><li>RingBuffer: 被看作 Disruptor 最主要的组件，然而从 3.0 开始 RingBuffer 仅仅负责存储和更新在 Disruptor 中流通的数据。对一些特殊的使用场景能够被用户(使用其他数据结构)完全替代。</li><li>Sequence：Disruptor 使用 Sequence 来表示一个特殊组件处理的序号。和 Disruptor 一样，每个消费者(EventProcessor)都维持着一个 Sequence。大部分的并发代码依赖这些 Sequence 值的运转，因此 Sequence 支持多种当前为 AtomicLong 类的特性。</li><li>Sequencer：这是 Disruptor 真正的核心。实现了这个接口的两种生产者（单生产者和多生产者）均实现了所有的并发算法，为了在生产者和消费者之间进行准确快速的数据传递。</li><li>SequenceBarrier: 由 Sequencer 生成，并且包含了已经发布的 Sequence 的引用，这些的 Sequence 源于 Sequencer 和一些独立的消费者的 Sequence。它包含了决定是否有供消费者来消费的 Event 的逻辑。</li><li>WaitStrategy：决定一个消费者将如何等待生产者将 Event 置入 Disruptor。</li><li>Event：从生产者到消费者过程中所处理的数据单元。Disruptor 中没有代码表示 Event，因为它完全是由用户定义的。</li><li>EventProcessor：主要事件循环，处理 Disruptor 中的 Event，并且拥有消费者的 Sequence。它有一个实现类是 BatchEventProcessor，包含了 event loop 有效的实现，并且将回调到一个 EventHandler 接口的实现对象。</li><li>EventHandler：由用户实现并且代表了 Disruptor 中的一个消费者的接口。</li><li>Producer：由用户实现，它调用 RingBuffer 来插入事件(Event)，在 Disruptor 中没有相应的实现代码，由用户实现。</li><li>WorkProcessor：确保每个 sequence 只被一个 processor 消费，在同一个 WorkPool 中的处理多个 WorkProcessor 不会消费同样的 sequence。</li><li>WorkerPool：一个 WorkProcessor 池，其中 WorkProcessor 将消费 Sequence，所以任务可以在实现 WorkHandler 接口的 worker 吃间移交</li><li>LifecycleAware：当 BatchEventProcessor 启动和停止时，于实现这个接口用于接收通知。</li></ul><h2 id=ringbuffer>RingBuffer</h2><p>正如名字所说的一样，它是一个环（首尾相接的环），你可以把它用做在不同上下文（线程）间传递数据的 buffer。基本来说，ringbuffer 拥有一个序号，这个序号指向数组中下一个可用元素。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://assets.ng-tech.icu/superbed/2021/07/22/60f93a6d5132923bf801d279.jpg alt=环示意图 loading=lazy data-zoomable></div></div></figure></p><p>Disruptor 说的是生产者和消费者的故事。有一个数组，生产者往里面扔芝麻；消费者从里面捡芝麻。但是扔芝麻和捡芝麻也要考虑速度的问题：</p><ul><li>消费者捡的比扔的快，那么消费者要停下来。生产者扔了新的芝麻，然后消费者继续。</li><li>数组的长度是有限的，生产者到末尾的时候会再从数组的开始位置继续。这个时候可能会追上消费者，消费者还没从那个地方捡走芝麻，这个时候生产者要等待消费者捡走芝麻，然后继续。</li></ul><p>随着你不停地填充这个 buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。要找到数组中当前序号指向的元素，可以通过 mod 操作：sequence mod array length = array index（取模操作）以上面的 ringbuffer 为例（java 的 mod 语法）：12 % 10 = 2。很简单吧。</p><h1 id=java-内置队列的不足>Java 内置队列的不足</h1><p>PCP 又称 Bounded-Buffer 问题，其核心就是保证对一个 Buffer 的存取操作在多线程环境下不会出错。使用 Java 中的 ArrayBlockingQueue 和 LinkedBlockingQueue 类能轻松的完成 PCP 模型，这对于一般程序已经没问题了，但是对于并发度高、TPS 要求较大的系统则不然。</p><p>Java 的内置队列如下表所示。</p><table><thead><tr><th style=text-align:left>队列</th><th style=text-align:left>有界性</th><th style=text-align:left>锁</th><th style=text-align:left>数据结构</th></tr></thead><tbody><tr><td style=text-align:left>ArrayBlockingQueue</td><td style=text-align:left>bounded</td><td style=text-align:left>加锁</td><td style=text-align:left>arraylist</td></tr><tr><td style=text-align:left>LinkedBlockingQueue</td><td style=text-align:left>optionally-bounded</td><td style=text-align:left>加锁</td><td style=text-align:left>linkedlist</td></tr><tr><td style=text-align:left>ConcurrentLinkedQueue</td><td style=text-align:left>unbounded</td><td style=text-align:left>无锁</td><td style=text-align:left>linkedlist</td></tr><tr><td style=text-align:left>LinkedTransferQueue</td><td style=text-align:left>unbounded</td><td style=text-align:left>无锁</td><td style=text-align:left>linkedlist</td></tr><tr><td style=text-align:left>PriorityBlockingQueue</td><td style=text-align:left>unbounded</td><td style=text-align:left>加锁</td><td style=text-align:left>heap</td></tr><tr><td style=text-align:left>DelayQueue</td><td style=text-align:left>unbounded</td><td style=text-align:left>加锁</td><td style=text-align:left>heap</td></tr></tbody></table><p>队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是 ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成 LinkedBlockingQueue 和 ConcurrentLinkedQueue 两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的 LinkedTransferQueue 都是通过原子变量 compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。</p><p>通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少 Java 的垃圾回收对系统性能的影响，会尽量选择 array/heap 格式的数据结构。这样筛选下来，符合条件的队列就只有 ArrayBlockingQueue。</p><h2 id=锁的损耗>锁的损耗</h2><p>BlockingQueue 使用的是 package java.util.concurrent.locks 中实现的锁，当多个线程（例如生产者）同时写入 Queue 时，锁的争抢会导致只有一个生产者可以执行，其他线程都中断了，也就是线程的状态从 RUNNING 切换到 BLOCKED，直到某个生产者线程使用完 Buffer 后释放锁，其他线程状态才从 BLOCKED 切换到 RUNNABLE，然后时间片到其他线程后再进行锁的争抢。上述过程中，一般来说生产者存放一个数据到 Buffer 中所需时间是非常短的，操作系统切换线程上下文的速度也是非常快的，但是当线程数量增多后，OS 切换线程所带来的开销逐渐增多，锁的反复申请和释放成为性能瓶颈。BlockingQueue 除了使用锁带来的性能损失外，还可能因为线程争抢的顺序问题造成性能再次损失：实际使用中发现线程的调度顺序并不理想，可能出现短时间内 OS 频繁调度出生产者或消费者的情况，这样造成缓冲区可能短时间内被填满或被清空的极端情况。（理想情况应该是缓冲区长度适中，生产和消费速度基本一致）</p><p>下面是 ArrayBlockingQueue 通过加锁的方式实现的 offer 方法，保证线程安全。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>offer</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>checkNotNull</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=n>ReentrantLock</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>this</span><span class=o>.</span><span class=na>lock</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>count</span> <span class=o>==</span> <span class=n>items</span><span class=o>.</span><span class=na>length</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>insert</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>对于上面的问题 Disruptor 的解决方案是：不用锁。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://assets.ng-tech.icu/superbed/2021/07/22/60f93c775132923bf80710d4.jpg alt=环示意图 loading=lazy data-zoomable></div></div></figure></p><p>Disruptor 使用一个 Ring Buffer 存放生产者的产品，环形缓冲区实际上还是一段连续内存，之所以称作环形是因为它对数据存放位置的处理，生产者和消费者各有一个指针（数组下标），消费者的指针指向下一个要读取的 Slot，生产者指针指向下一个要放入的 Slot，消费或生产后，各自的指针值 p = (p +1) % n，n 是缓冲区长度，这样指针在缓冲区上反复游走，故可以将缓冲区看成环状。（Ring Buffer 并非 Disruptor 原创，Linux 内核中就有环形缓冲区的实现）使用 Ring Buffer 时：</p><ul><li>当生产者和消费者都只有一个时，由于两个线程分别操作不同的指针，所以不需要锁。</li><li>当有多个消费者时，每个消费者各自控制自己的指针，依次读取每个 Slot（也就是每个消费者都会读取到所有的产品），这时只需要保证生产者指针不会超过最慢的消费者（超过最后一个消费者“一圈”）即可，也不需要锁。</li><li>当有多个生产者时，多个线程共用一个写指针，此处需要考虑多线程问题，例如两个生产者线程同时写数据，当前写指针=0，运行后其中一个线程应获得缓冲区 0 号 Slot，另一个应该获得 1 号，写指针=2。对于这种情况，Disruptor 使用 CAS 来保证多线程安全。</li></ul><h2 id=伪共享>伪共享</h2><p>ArrayBlockingQueue 有三个成员变量：</p><ul><li>takeIndex：需要被取走的元素下标</li><li>putIndex：可被元素插入的位置的下标</li><li>count：队列中元素的数量</li></ul><p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://assets.ng-tech.icu/superbed/2021/07/22/60f933c45132923bf8ed2e36.jpg alt="ArrayBlockingQueue 伪共享示意图" loading=lazy data-zoomable></div></div></figure></p><p>如上图所示，当生产者线程 put 一个元素到 ArrayBlockingQueue 时，putIndex 会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。这种无法充分使用缓存行特性的现象，称为伪共享。解决伪共享问题，可以在变量的前后都占据一定的填充位置，尽量让变量占用一个完整的缓存行。CPU1 上的线程更新了 X，则 CPU2 上的 Y 则不会失效。同样地，CPU2 上的线程更新了 Y，则 CPU1 的不会失效。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>LhsPadding</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>protected</span> <span class=kt>long</span> <span class=n>p1</span><span class=o>,</span> <span class=n>p2</span><span class=o>,</span> <span class=n>p3</span><span class=o>,</span> <span class=n>p4</span><span class=o>,</span> <span class=n>p5</span><span class=o>,</span> <span class=n>p6</span><span class=o>,</span> <span class=n>p7</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Value</span> <span class=kd>extends</span> <span class=n>LhsPadding</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>protected</span> <span class=kd>volatile</span> <span class=kt>long</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>RhsPadding</span> <span class=kd>extends</span> <span class=n>Value</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>protected</span> <span class=kt>long</span> <span class=n>p9</span><span class=o>,</span> <span class=n>p10</span><span class=o>,</span> <span class=n>p11</span><span class=o>,</span> <span class=n>p12</span><span class=o>,</span> <span class=n>p13</span><span class=o>,</span> <span class=n>p14</span><span class=o>,</span> <span class=n>p15</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;p&gt;Concurrent sequence class used for tracking the progress of
</span></span></span><span class=line><span class=cl><span class=cm> * the ring buffer and event processors.  Support a number
</span></span></span><span class=line><span class=cl><span class=cm> * of concurrent operations including CAS and order writes.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;p&gt;Also attempts to be more efficient with regards to false
</span></span></span><span class=line><span class=cl><span class=cm> * sharing by adding padding around the volatile field.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Sequence</span> <span class=kd>extends</span> <span class=n>RhsPadding</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>INITIAL_VALUE</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1L</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Unsafe</span> <span class=n>UNSAFE</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>VALUE_OFFSET</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>UNSAFE</span> <span class=o>=</span> <span class=n>Util</span><span class=o>.</span><span class=na>getUnsafe</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span>
</span></span><span class=line><span class=cl>        <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>VALUE_OFFSET</span> <span class=o>=</span> <span class=n>UNSAFE</span><span class=o>.</span><span class=na>objectFieldOffset</span><span class=o>(</span><span class=n>Value</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getDeclaredField</span><span class=o>(</span><span class=s>&#34;value&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>catch</span> <span class=o>(</span><span class=kd>final</span> <span class=n>Exception</span> <span class=n>e</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div><p>在 Sequence 的实现中，主要使用的是 Value，但通过 LhsPadding 和 RhsPadding 在 Value 的前后填充了一些空间，使 Value 无冲突的存在于缓存行中。</p></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>上一页</div><a href=/books/concurrent-series/2.%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/disruptor/%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B/ rel=next>生产与消费流程</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>