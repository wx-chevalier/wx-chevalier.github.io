<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Futures &amp; Promises | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/</link><atom:link href="https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/index.xml" rel="self" type="application/rss+xml"/><description>Futures &amp; Promises</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Futures &amp; Promises</title><link>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/</link></image><item><title>Promise 实践</title><link>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/promise-%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/promise-%E5%AE%9E%E8%B7%B5/</guid><description>&lt;h1 id="promise-实现">Promise 实现&lt;/h1>
&lt;h1 id="隐式与显式-promise">隐式与显式 Promise&lt;/h1>
&lt;h1 id="promise-pipelining">Promise Pipelining&lt;/h1>
&lt;p>传统 RPC 系统的缺陷之一是它们正在阻塞。设想一个场景，您需要调用一个 API“ A”和另一个 API“ B”，然后汇总这两个调用的结果并将该结果用作另一个 API“ C”的参数。现在，执行此操作的逻辑方法是并行调用 A 和 B，然后在完成后汇总结果并调用 C。不幸的是，在阻塞系统中，执行方法是调用 A，等待 完成它，调用 B，等待，然后聚合并调用 C。这似乎是在浪费时间，但是如果没有异步性，这是不可能的。即使具有异步性，线性管理或扩展系统也有些困难。幸运的是，我们有 Promise。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://dist-prog-book.com/chapter/2/images/p-2.png" alt="Conventional RPC with Pipelining" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Future/Promise 可以传递，等待或链接在一起。这些属性有助于使使用它们的程序员的生活更轻松。这也减少了与分布式计算相关的延迟。Promise 启用了数据流并发，这也是确定性的，并且更易于推理。&lt;/p>
&lt;h1 id="异常处理">异常处理&lt;/h1>
&lt;h1 id="futures-and-promises-in-action">Futures and Promises in Action&lt;/h1>
&lt;h2 id="twitter-finagle">Twitter Finagle&lt;/h2>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="http://dist-prog-book.com/chapter/2/futures.html#implicit-vs-explicit-promises" target="_blank" rel="noopener">http://dist-prog-book.com/chapter/2/futures.html#implicit-vs-explicit-promises&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>概念梳理</title><link>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86/</guid><description>&lt;h1 id="基础概念">基础概念&lt;/h1>
&lt;p>正如我们将在后续章节中看到的那样，我们选择称其为“概念”，其确切定义往往会有所不同。我们将从对 futures/promises 的概念的尽可能广泛的定义开始，然后放大并涵盖不同语言对这些构造的解释之间的许多语义差异。一个 Future 或者 Promise 可以看做那些暂时不可得但是最终会被得到的值。换句话说，它是对时间概念进行编码的抽象。通过选择使用此构造，可以假定您的值现在可以具有许多可能的状态，具体取决于我们请求它的时间点。最简单的变化包括两个与时间有关的状态：&lt;/p>
&lt;ul>
&lt;li>completed/determined：计算完毕，可以获得值。&lt;/li>
&lt;li>incomplete/undetermined：计算还在进行中。&lt;/li>
&lt;/ul>
&lt;p>稍后我们将看到，在 futures/promises 的某些变体中引入了其他状态，以更好地支持错误处理和取消之类的需求。重要的是，futures/promises 通常可以实现一定程度的并发。也就是说，在 Futures 的第一个定义中：&lt;/p>
&lt;blockquote>
&lt;p>The construct (future X) immediately returns a future for the value of the expression X and concurrently begins evaluating X.When the evaluation of X yields a value, that value replaces the future.&lt;/p>
&lt;ul>
&lt;li>(Halstead, 1985)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>futures/promises 的某些解释具有与之相关的类型，而另一些则没有。通常，未来/Promise 是单项任务；也就是说，它只能被写入一次。一些解释是阻塞的（同步的），另一些则是完全非阻塞的（异步的）。某些解释必须显式启动（即手动启动），而在其他解释中，计算是隐式启动的。受函数编程的启发，此构造的不同解释之间的主要区别之一与流水线或组合有关。对 futures/promises 的一些较流行的解释使链接操作或定义在完成由 futures/promises 表示的计算时要调用的操作的流水线成为可能。这与大量使用回调或更强制性的直接阻止方法形成对比。&lt;/p>
&lt;h2 id="源起与应用">源起与应用&lt;/h2>
&lt;p>作为相关主题的 futures/promises 的兴起在很大程度上与并行和并发编程以及分布式系统的兴起同时发生。这自然而然地遵循，因为作为对时间进行编码的抽象，当延迟成为问题时，futures/promises 引入了一种很好的方式来推断状态变化；当一个节点必须与分布式系统中的另一个节点进行通信时，程序员通常会面临这些问题。但是，futures/promises 在许多其他情况下也被认为是有用的，无论是分布式的还是无用的。此类上下文包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Request-Response Patterns，例如通过 HTTP 的网络服务调用。Futures 可以用来表示 HTTP 请求的响应值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Input/Output，例如需要用户输入的 UI 对话框，或例如从磁盘读取大文件的操作。Futures 可以用来表示 IO 调用和 IO 的结果值（例如，终端输入，已读取文件的字节数组）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Long-Running Computations，想象一下，您希望启动长时间运行的计算（例如复杂的数值算法）的过程不要等待该长时间运行的计算完成，而是继续处理其他任务。未来可能会用来表示这种长期运行的计算及其结果的价值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Database Queries，像长时间运行的计算一样，数据库查询可能很耗时。因此，像上面一样，可能希望将执行查询的工作转移到另一个进程，然后继续处理下一个任务。Futures 可以用来表示查询和查询的结果值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RPC (Remote Procedure Call)，当对服务器进行 RPC 调用时，网络延迟通常是一个问题。像上面一样，可能希望不必等待 RPC 调用的结果，而只需将其卸载到另一个进程即可。Futures 可以用来表示 RPC 调用及其结果。当服务器响应结果时，Futures 就完成了，其价值就是服务器的响应。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Reading Data from a Socket 可能由于网络延迟而非常耗时。因此，可能希望不必等待传入的数据，而是将其卸载到另一个进程。Futures 可以用来表示读取操作以及 Futures 完成时读取的结果值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Timeouts，例如管理 Web 服务中的超时。表示超时的 Future 可能只返回没有结果或某种空结果，例如类型化编程语言中的 Unit 类型。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>今天，许多现实世界中的服务和系统都在诸如此类的流行环境中大量使用 futures/promises，这要归功于对未来的看法或对诸如 JavaScript，Node.js，Scala，Java，C++等流行语言和框架的 Promise。正如我们将在其他章节中看到的那样，futures/promises 的这种扩散导致 futures/promises 随着时间和跨语言而改变了含义和名称。&lt;/p>
&lt;h2 id="相似概念">相似概念&lt;/h2>
&lt;p>Future, Promise, Delay 以及 Deferred 通常指的是大致相同的同步机制，其中对象充当迄今未知结果的代理。当结果可用时，然后执行其他一些代码。多年来，这些术语已指代语言和生态系统之间略有不同的语义。在部分语言中，可能直接存在像 Future, Promise, Delay 以及 Deferred 这样的类或可构造函数。不过像 Scala、Java 以及 Dart 中，它们都是将 Future 与 Promise 当做不同的对象进行处理：&lt;/p>
&lt;ul>
&lt;li>Future 是对于那些尚待计算的值的只读引用。&lt;/li>
&lt;li>Promise 或 CompletableFuture 或 Completer 是与 Future 关联的单赋值对象。&lt;/li>
&lt;/ul>
&lt;p>简单来说，Future 是对于某个写入到 Promise 的值的只读的窗口；我们可以通过调用 Promise 的 future 方法来获取到 Future 对象。这两个概念在 Scala 中的定义如下：&lt;/p>
&lt;blockquote>
&lt;p>A future is a placeholder object for a result that does not yet exist.A promise is a writable, single-assignment container, which completes a future.Promises can complete the future with a result to indicate success, or with an exception to indicate failure.&lt;/p>
&lt;/blockquote>
&lt;p>Scala Future 与 Java（6）Future 之间的重要区别在于，Scala Future 本质上是异步的。Java 的未来（至少到 Java 6 之前）都处于阻塞状态。Java 7 将异步 Future 引入了人们的极大关注。在 Java 8 中，Future 接口具有一些方法来检查计算是否完成，等待其完成以及在计算完成时检索计算结果。可以将 &lt;code>CompletableFutures&lt;/code> 视为一个 Promise，因为可以明确设置它们的值。但是，&lt;code>CompletableFuture&lt;/code> 还实现了 &lt;code>Future&lt;/code> 接口，使其也可以用作 &lt;code>Future&lt;/code>。使用公共设置方法可以将 Promise 视为未来，调用方（或其他任何人）可以使用该方法来设置未来的价值。&lt;/p>
&lt;p>在 JavaScript 世界中，JQuery 引入了 Deferred 对象的概念，这些对象用于表示尚未完成的工作单元。Deferred 对象包含一个 Promise 对象，表示该工作单元的结果。Promise 是函数返回的值。Deferred 的对象也可以由其调用方取消。类似于 Scala 与 Java，C# 也区分了 Promise 与 Future。在 C# 中，Futures 被称为 &lt;code>Task&amp;lt;T&amp;gt;&lt;/code>，Promise 被称为 &lt;code>TaskCompletionSource&amp;lt;T&amp;gt;&lt;/code>。Future 的结果存放在了 &lt;code>Task&amp;lt;T&amp;gt;.Result&lt;/code>，&lt;code>TaskCompletionSource&amp;lt;T&amp;gt;.Task&amp;lt;TResult&amp;gt;&lt;/code> 则包含了完成 &lt;code>Task&lt;/code> 对象或者抛出异常的方法。&lt;/p>
&lt;p>JavaScript 规范中还定义了单独的 Promise 对象，&lt;code>(Promises/A+, 2013)&lt;/code> 规范紧急定义了接口而将具体的实现留给了各个标准。JavaScript 中的 Promise 同样是异步的，并且可以流式调用。如我们所见，Future/Promise 的语言和库实现之间的概念，语义和术语似乎有所不同。术语和语义上的这些差异源于悠久的历史和独立的语言社区，这些社区激增了对 Future/Promise 的使用。&lt;/p>
&lt;h1 id="简史">简史&lt;/h1>
&lt;p>如下的时间轴是对于 futures/promises 的简史的梳理：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s1.ax1x.com/2020/03/30/GuWM8A.md.png" alt="History" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最终导致 futures/promises 的第一个概念出现在 1961 年，当时有所谓的 thunks。Thunk 可以被看作是对 futures/promises 的原语，顺序的概念。根据其发明者 P.Z.Ingerman 的说法，thunks 是：&lt;/p>
&lt;blockquote>
&lt;p>A piece of coding which provides an address&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>(Ingerman, 1961)&lt;/p>
&lt;/blockquote>
&lt;p>更详细的 futures/promises 的简史参考&lt;a href="http://dist-prog-book.com/chapter/2/futures.html#brief-history" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p></description></item><item><title>执行语义</title><link>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/%E6%89%A7%E8%A1%8C%E8%AF%AD%E4%B9%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/concurrent-series/4.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/futures-promises/%E6%89%A7%E8%A1%8C%E8%AF%AD%E4%B9%89/</guid><description>&lt;h1 id="执行语义">执行语义&lt;/h1>
&lt;p>随着这些年来架构和运行时的发展和变化，实现 futures/promises 的技术也是如此，以至于抽象化转化为系统资源的有效利用。在本节中，我们将介绍三种主要执行模型，在这些模型上以流行的语言和库为基础构建 futures/promises。也就是说，我们将看到 futures 和 promises 在其 API 下实际执行和解决的不同方式。&lt;/p>
&lt;h1 id="thread-pools">Thread Pools&lt;/h1>
&lt;p>线程池是一种使用户可以访问可以进行工作的一组就绪的空闲线程的抽象。线程池的实现会照顾到工作线程的创建，管理和调度，如果不小心处理，它们很容易变得棘手且代价高昂。线程池具有许多不同的风格，具有许多用于调度和执行任务的技术，并且具有固定数量的线程，或者具有根据负载动态调整自身大小的能力。Java 的 Executor 就是典型的线程池的实现，Executor 包含了一系列 Runnable 的任务，它对上屏蔽了任务具体执行细节的抽象。这些详细信息（例如选择运行任务的线程，任务的计划方式）由 Executor 接口的基础实现管理。&lt;/p>
&lt;p>类似于 Executor，Scala 在 &lt;code>scala.concurrent&lt;/code> 包中提供了 ExecutionContext 类，其基础的特性类似于 Java 的 Executor；它负责并发高效地执行计算，而无需池中的用户去担心诸如调度之类的事情。更重要地是，ExecutionContext 同样可被当做接口，我们能够改变线程池地底层实现而保证上层接口的一致性。在诸多的实现中，Scala 的默认 ExecutionContext 的实现是基于 Java 的 ForkJoinPool，一种具有 work-stealing 算法的线程池实现，其中空闲线程拾取先前安排给其他繁忙线程的任务。ForkJoinPool 是一种流行的线程池实现，因为它比 Executors 的性能有所提高，能够更好地避免池引起的死锁，并最大程度地减少了在线程之间切换所花费的时间。&lt;/p>
&lt;p>Scala 的 futures &amp;amp; promsies 就是基于 ExecutionContext，虽然通常用户使用由 ForkJoinPool 支持的基础默认 ExecutionContext，但如果用户需要特定行为（例如阻止 futures），他们还可以选择提供（或实现）自己的 ExecutionContext。n Scala，对 Future 或 Promise 的每次使用都需要传递某种 ExecutionContext。此参数是隐式的，通常是 ExecutionContext.global（默认的基础 ForkJoinPool ExecutionContext）。例如，创建并运行一个基本的 future：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-scala" data-lang="scala">&lt;span class="line">&lt;span class="cl">&lt;span class="k">implicit&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="n">ec&lt;/span> &lt;span class="k">=&lt;/span> &lt;span class="nc">ExecutionContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">global&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="k">:&lt;/span> &lt;span class="kt">Future&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="kt">String&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="k">=&lt;/span> &lt;span class="nc">Future&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="err">“&lt;/span>&lt;span class="n">hello&lt;/span> &lt;span class="n">world&lt;/span>&lt;span class="err">`&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在此示例中，全局执行上下文用于异步运行所创建的 Future。如前所述，Future 的 ExecutionContext 参数是隐式的。这意味着，如果编译器在所谓的隐式范围内找到 ExecutionContext 的实例，则它将自动传递给对 Future 的调用，而用户不必显式传递它。在上面的示例中，在声明 ec 时使用隐式关键字将 ec 置于隐式范围内。如前所述，Scala 中的 Future 和 Promise 是异步的，这是通过使用回调实现的。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-scala" data-lang="scala">&lt;span class="line">&lt;span class="cl">&lt;span class="k">implicit&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="n">ec&lt;/span> &lt;span class="k">=&lt;/span> &lt;span class="nc">ExecutionContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">global&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="k">=&lt;/span> &lt;span class="nc">Future&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Http&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;http://api.fixed.io/latest?base=USD&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="n">asString&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">f&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">onComplete&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nc">Success&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="k">=&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nc">Failure&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="k">=&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getMessage&lt;/span>&lt;span class="o">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在此示例中，我们首先创建一个 Future f，然后当它完成时，我们提供两个可能的表达式，这些表达式可以根据 Future 是否成功执行或是否有错误来调用。在这种情况下，如果成功，我们将获得计算结果的 HTTP 字符串，并将其打印出来。如果引发了异常，我们将获取包含在异常中的消息字符串并进行打印。那么，它们如何一起工作？&lt;/p>
&lt;p>如前所述，Future 需要一个 ExecutionContext，这是几乎所有 Future API 的隐式参数。此 ExecutionContext 用于执行 Future。Scala 足够灵活，可以让用户实现自己的 ExecutionContext，但是让我们谈谈默认的 ExecutionContext，它是一个 ForkJoinPool。ForkJoinPool 非常适合生成许多小计算然后又重新组合在一起的小型计算。Scala 的 ForkJoinPool 要求提交给它的任务是 ForkJoinTask。提交给全局 ExecutionContext 的任务被安静地包装在 ForkJoinTask 中，然后执行。ForkJoinPool 还使用 ManagedBlock 方法来支持可能的阻塞任务，该方法将在需要时创建备用线程，以确保在当前线程被阻塞时确保足够的并行度。总而言之，ForkJoinPool 是一个非常好的通用 ExecutionContext，它在大多数情况下都非常有效。&lt;/p>
&lt;h1 id="event-loops">Event Loops&lt;/h1>
&lt;p>现代平台和运行时通常依赖于许多底层系统层进行操作。例如，给定的语言实现，库或框架可能会依赖基础文件系统，数据库系统和其他网络服务。与这些组件的交互通常需要一段时间，我们除了等待响应外什么也不做。这可能会浪费大量的计算资源。JavaScript 是单线程异步运行时。现在，通常异步编程通常与多线程相关联，但是我们不允许在 JavaScript 中创建新线程。而是使用事件循环机制实现 JavaScript 中的异步性。历史上一直使用 JavaScript 与 DOM 和浏览器中的用户交互进行交互，因此事件驱动的编程模型自然适用于该语言：而令人惊讶的是，即使在 Node.js 的高吞吐率场景中，该特性已然能够被较好地应用。&lt;/p>
&lt;p>事件驱动的编程模型背后的总体思想是，逻辑流控制由事件处理的顺序决定。这种机制的基础是不断侦听事件并在检测到事件时触发回调。简而言之，这是 JavaScript 的事件循环。典型的 JavaScript 引擎具有一些基本组件。他们是：&lt;/p>
&lt;ul>
&lt;li>Heap Used to allocate memory for objects&lt;/li>
&lt;li>Stack Function call frames go into a stack from where they’re picked up from top to be executed.&lt;/li>
&lt;li>Queue A message queue holds the messages to be processed.&lt;/li>
&lt;/ul>
&lt;p>每条消息都有一个回调函数，在处理该消息时会触发该函数。这些消息可以通过按钮单击或滚动之类的用户操作或 HTTP 请求之类的操作，请求数据库以获取记录或读取/写入文件的方式来生成。将邮件何时排入队列与执行时间分开，意味着单线程不必等待操作完成就可以继续进行操作。我们在要执行的操作上附加了回调，当时间到了时，回调将以我们的操作结果运行。回调在孤立的情况下可以很好地工作，但是它们迫使我们进入一种继续传递执行方式的方式，即所谓的回调地狱（Callback hell）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">getData&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">param&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">callback&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">$&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;http://example.com/get/&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">param&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">responseText&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">callback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">responseText&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">getData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">d&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Promise 则能提供给我们更好地代码可读性：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">getData&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">param&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">callback&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Promise&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">resolve&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">reject&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">$&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;http://example.com/get/&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">param&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">responseText&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">resolve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">responseText&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">getData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">getData&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">getData&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">getData&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">then&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">getData&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Promise 是一种抽象，使使用 JavaScript 中的异步操作更加有趣。回调会导致控制反转，这很难大规模扩展。从继续传递样式继续，在继续传递样式中，您指定操作完成后需要执行的操作，被调用方仅返回 Promise 对象。这使责任链倒置了，因为现在，呼叫者负责在 Promise 完成后处理 Promise 的结果。ES2015 规范规定 Promise 不得在创建事件循环的同一时刻触发其解析/拒绝功能。这是重要的属性，因为它确保确定的执行顺序。而且，一旦 Promise 兑现或失败，就不得更改 Promise 的值。这确保了 Promise 不能被多次解决。&lt;/p>
&lt;p>让我们举一个例子来了解在 JavaScript 引擎中发生的 Promise 解决工作流程。假设我们执行一个函数 &lt;code>g()&lt;/code>，该函数又调用另一个函数 &lt;code>f()&lt;/code>。函数 &lt;code>f&lt;/code> 返回一个 Promise，在递减计数 1000 毫秒后，将使用单个值 true 解析该 Promise。一旦 &lt;code>f&lt;/code> 得到解决，就会基于 Promise 的值来提醒值 &lt;code>true&lt;/code> 或 &lt;code>false&lt;/code>。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://dist-prog-book.com/chapter/2/images/5.png" alt="Callback vs Promise" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>现在，JavaScript 的运行时是单线程的。这个说法即对也不对。执行用户代码的线程是单线程的。它执行堆栈顶部的内容，将其运行至完成，然后移至堆栈上的下一个内容。但是，也有许多帮助程序线程可以处理诸如网络或计时器/setTimeout 类型事件之类的事件。该计时线程处理 setTimeout 的计数器。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://dist-prog-book.com/chapter/2/images/6.png" alt="Timer Thread" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>计时器到期后，计时器线程将一条消息放入消息队列中。然后由事件循环处理排队的消息。如上所述，事件循环只是一个无限循环，它检查消息是否已准备好进行处理，将其拾取并将其放入堆栈中以执行回调。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://dist-prog-book.com/chapter/2/images/7.png" alt="Timer Expired" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在这里，由于 future 的值为 true，所以在选择执行回调时会向我们发出 true 值的警报。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://dist-prog-book.com/chapter/2/images/8.png" alt="Timer Callback" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们在这里忽略了堆，但是所有函数，变量和回调都存储在堆中。正如我们在这里看到的，即使据说 JavaScript 是单线程的，也有许多帮助程序线程可以帮助主线程执行超时，UI，网络操作，文件操作等操作。Run-to-completion 可以帮助我们以一种很好的方式对代码进行推理。每当函数启动时，它需要在产生主线程之前完成。它访问的数据不能被其他人修改。这也意味着每个功能都需要在合理的时间内完成，否则程序似乎已挂起。这使得 JavaScript 非常适合排队等待完成后又要拾取的 I/O 任务，而不适合通常需要很长时间才能完成的数据处理密集型任务。&lt;/p>
&lt;p>我们还没有讨论错误处理，但是它的处理方式完全相同，错误回调由 Promise 被拒绝的错误对象调用。事件循环已被证明具有惊人的性能。当网络服务器是围绕多线程设计的时，一旦您建立了数百个并发连接，CPU 就会花费大量的时间进行任务切换，从而开始失去整体性能。从一个线程切换到另一个线程会产生开销，这在规模上可能会相加很大。当使用每个连接一个线程时，Apache 过去甚至阻塞了数百个并发用户，而 Node.js 可以基于事件循环和异步 IO 扩展到 100,000 个并发连接。&lt;/p>
&lt;h1 id="thread-model">Thread Model&lt;/h1>
&lt;p>Oz 编程语言引入了数据流并发模型的思想。在 Oz 中，只要程序遇到未绑定的变量，它就会等待其解析。变量的数据流属性有助于我们在 Oz 中编写线程，这些线程通过生产者-消费者模式通过流进行通信。基于数据流的并发模型的主要优点是它具有确定性-使用相同参数调用的同一操作始终会产生相同的结果。如果代码没有副作用，则使并发程序的推理变得容易得多。&lt;/p>
&lt;p>Alice ML 是 Standard ML 的方言，支持惰性计算，并发，分布式和约束编程。Alice 项目的早期目标是在一种类型化的编程语言之上重建 Oz 编程语言的功能。以 Standard ML 方言为基础，Alice 还通过使用 Future 的类型将并发功能作为语言的一部分提供。Alice 的 Future 代表并发操作的不确定结果。Alice ML 中的 Promise 是 Future 的显式句柄。&lt;/p>
&lt;p>可以使用 spawn 关键字在自己的线程中计算 Alice 中的任何表达式。Spawn 总是返回一个 Future，该 Future 充当操作结果的占位符。从某种意义上说，Alice 中的线程总会有结果，Alice ML 中的 Future 可以被认为是功能线程。如果线程执行的操作要求将 Future 的值用作占位符，则称该线程正在接触 Future。阻塞所有涉及 Future 的线程，直到解决 Future。如果线程引发异常，则 Future 失败，并且在接触该异常的线程中重新引发该异常。Future 也可以作为价值传递。这有助于我们在 Alice 中实现并发数据流模型。&lt;/p>
&lt;p>Alice 还允许对表达式进行延迟计算。带有 lazy 关键字的表达式将被计算为延迟的 Future。需要时可以计算懒惰的 Future。如果与并发或延迟的 Future 关联的计算以异常结束，则将导致失败的 Future。请求失败的 Future 不会受到阻碍，只会引发导致失败的异常。&lt;/p></description></item></channel></rss>