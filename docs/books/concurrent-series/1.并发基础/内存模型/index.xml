<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>内存模型 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><atom:link href="https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/index.xml" rel="self" type="application/rss+xml"/><description>内存模型</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>内存模型</title><link>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link></image><item><title>2.有序性</title><link>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.%E6%9C%89%E5%BA%8F%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.%E6%9C%89%E5%BA%8F%E6%80%A7/</guid><description>&lt;h1 id="有序性">有序性&lt;/h1>
&lt;p>顾名思义，有序性指的是程序按照代码的先后顺序执行。现代编译器的代码优化和编译器指令重排可能会影响到代码的执行顺序。编译期指令重排是通过调整代码中的指令顺序，在不改变代码语义的前提下，对变量访问进行优化。从而尽可能的减少对寄存器的读取和存储，并充分复用寄存器。但是编译器对数据的依赖关系判断只能在单执行流内，无法判断其他执行流对竞争数据的依赖关系。就拿无锁环形队列来说，如果 Writer 做的是先放置数据，再更新索引的行为。如果索引先于数据更新，Reader 就有可能会因为判断索引已更新而读到脏数据。&lt;/p>
&lt;p>禁止编译器对该类变量的优化，解决了编译期的重排序并不能保证有序性，因为 CPU 还有乱序执行（Out-of-Order Execution）的特性。流水线（Pipeline）和乱序执行是现代 CPU 基本都具有的特性。机器指令在流水线中经历取指、译码、执行、访存、写回等操作。为了 CPU 的执行效率，流水线都是并行处理的，在不影响语义的情况下。处理器次序（Process Ordering，机器指令在 CPU 实际执行时的顺序）和程序次序（Program Ordering，程序代码的逻辑执行顺序）是允许不一致的，即满足 As-if-Serial 特性。显然，这里的不影响语义依旧只能是保证指令间的显式因果关系，无法保证隐式因果关系。即无法保证语义上不相关但是在程序逻辑上相关的操作序列按序执行。从此单核时代 CPU 的 Self-Consistent 特性在多核时代已不存在，多核 CPU 作为一个整体看，不再满足 Self-Consistent 特性。&lt;/p>
&lt;p>简单总结一下，如果不做多余的防护措施，单核时代的无锁环形队列在多核 CPU 中，一个 CPU 核心上的 Writer 写入数据，更新 index 后。另一个 CPU 核心上的 Reader 依靠这个 index 来判断数据是否写入的方式不一定可靠。index 有可能先于数据被写入，从而导致 Reader 读到脏数据。&lt;/p>
&lt;p>在 Java 中与有序性相关的经典问题就是单例模式，譬如我们会采用静态函数来获取某个对象的实例，并且使用 synchronized 加锁来保证只有单线程能够触发创建，其他线程则是直接获取到实例对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">instance&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">synchronized&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">instance&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">instance&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Singleton&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过虽然我们期望的对象创建的过程是：内存分配、初始化对象、将对象引用赋值给成员变量，但是实际情况下经过优化的代码往往会首先进行变量赋值，而后进行对象初始化。假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 &lt;code>instance != null&lt;/code>，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。&lt;/p></description></item><item><title>3.原子性</title><link>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.%E5%8E%9F%E5%AD%90%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.%E5%8E%9F%E5%AD%90%E6%80%A7/</guid><description>&lt;h1 id="原子性">原子性&lt;/h1>
&lt;p>所谓的原子性，就是一个或者多个操作在 CPU 执行的过程中不被中断的特性，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符。我们在编程语言中部分看似原子操作的指令，在被编译到汇编之后往往会变成多个操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 编译成汇编之后就是：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 读取当前变量 i 并把它赋值给一个临时寄存器;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">movl&lt;/span> &lt;span class="nf">i&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">%rip), %&lt;/span>&lt;span class="n">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 给临时寄存器+1;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">addl&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%eax
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o"># 把 eax 的新值写回内存
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">movl %&lt;/span>&lt;span class="n">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">i&lt;/span>&lt;span class="p">(&lt;/span>%&lt;span class="n">rip&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以清楚看到 C 代码只需要一句，但编译成汇编却需要三步(这里不考虑编译器优化，实际上通过编译器优化可以将这三条汇编指令合并成一条)。也就是说，只有简单的读取、赋值(而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作)才是原子操作。按照原子操作解决同步问题方式：依靠处理器原语支持把上述三条指令合三为一，当做一条指令来执行，保证在执行过程中不会被打断并且多线程并发也不会受到干扰。这样同步问题迎刃而解，这也就是所谓的原子操作。但处理器没有义务为任意代码片段提供原子性操作，尤其是我们的临界区资源十分庞大甚至大小不确定，处理器没有必要或是很难提供原子性支持，此时往往需要依赖于锁来保证原子性。&lt;/p>
&lt;p>对应原子操作/事务在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。&lt;/p></description></item><item><title>4.内存屏障</title><link>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/concurrent-series/1.%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</guid><description>&lt;h1 id="内存屏障">内存屏障&lt;/h1>
&lt;p>编译器优化乱序和 CPU 执行乱序的问题可以分别使用优化屏障（Optimization Barrier）和内存屏障（Memory Barrier）这两个机制来解决。多处理器同时访问共享主存，每个处理器都要对读写进行重新排序，一旦数据更新，就需要同步更新到主存上 。在这种情况下，代码和指令重排，再加上缓存延迟指令结果输出导致共享变量被修改的顺序发生了变化，使得程序的行为变得无法预测。为了解决这种不可预测的行为，处理器提供一组机器指令来确保指令的顺序要求，它告诉处理器在继续执行前提交所有尚未处理的载入和存储指令。同样的也可以要求编译器不要对给定点以及周围指令序列进行重排。这些确保顺序的指令称为内存屏障，简单的说内存屏障做了两件事情：&lt;strong>拒绝重排，更新缓存&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>优化屏障 (Optimization Barrier)：避免编译器的重排序优化操作，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行；这就保证了编译时期的优化不会影响到实际代码逻辑顺序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存屏障 (Memory Barrier)分为写屏障（Store Barrier）、读屏障（Load Barrier）和全屏障（Full Barrier），其作用有两个：防止指令之间的重排序、保证数据的可见性。&lt;/p>
&lt;ul>
&lt;li>写屏障：强制将写缓冲器中的内容写入到高速缓存中，或者将屏障之后的指令全部写到写缓冲器直到之前写缓冲器中的内容全部被刷回缓存中，也就是处理 0 必须等到所有的 invalidate ack 消息后，才能执行后续的操作，相当于 flush 操作；&lt;/li>
&lt;li>读屏障：处理器在读取数据前，必须强制检查无效队列中是否有 invalidate 消息，如果有必须先处理完无效队列汇总的无效消息，再进行数据读取,相当于 refresh 操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>通过加入读写屏障保证了可见性与有序性。之所以说保证了有序性，是因为指令乱序现象就是写缓冲器异步接收到其他处理器中的 invalidate ack 消息后，再执行写缓冲器中的内容，导致本应该执行的指令顺序发生错乱。通过加入写屏障后保证了异步操作之后才能执行后续的指令，保证了原来的指令顺序。POSIX、C++、Java 都有各自的共享内存模型，实现上并没有什么差异，只是在一些细节上稍有不同。这里所说的内存模型并非是指内存布 局，特指内存、Cache、CPU、写缓冲区、寄存器以及其他的硬件和编译器优化的交互时对读写指令操作提供保护手段以确保读写序。将这些繁杂因素可以笼统的归纳为两个方面：重排和缓存，即上文所说的代码重排、指令重排和 CPU Cache。&lt;/p>
&lt;p>内存屏障的意义重大，是确保正确并发的关键。通过正确的设置内存屏障可以确保指令按照我们期望的顺序执行。这里需要注意的是内存屏蔽只应该作用于需要同步的指令或者还可以包含周围指令的片段。如果用来同步所有指令，目前绝大多数处理器架构的设计就会毫无意义。&lt;/p>
&lt;h2 id="lock-指令">Lock 指令&lt;/h2>
&lt;p>以 Java 中的 volatile 指令为例，它有 volatile 变量修饰的共享变量进行写操作的时候会多出第二行汇编代码：&lt;code>lock addl $0×0,(%esp);&lt;/code>，通过查 IA-32 架构软件开发者手册可知，Lock 前缀的指令在多核处理器下会引发了两件事情：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Lock 前缀指令会引起处理器缓存回写到内存。Lock 前缀指令导致在执行指令期间，声言处理器的 LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。对于 Intel486 和 Pentium 处理器，在锁操作时，总是在总线上声言 LOCK#信号。但在 P6 和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言 LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。IA-32 处理器和 Intel 64 处理器使用 MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和 Intel 64 处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在 Pentium 和 P6 family 处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>C++11 提供一组用户 API std::memory_order 来指导处理器读写顺序。Java 使用 happens-before 规则来屏蔽具体细节保证，指导 JVM 在指令生成的过程中穿插屏障指令。内存屏障也可以在编译期间指示对指令或者包括周围指令序列不进行优化，称之为编译器屏障，相当于轻量级内存屏障，它的工作同样重要，因为它在编译期指导编译器优化。屏障的实现稍微复杂一些，我们使用一组抽象的假想指令来描述内存屏障的工作原理。使用 MB_R、MB_W、MB 来抽象处理器指令为宏：&lt;/p>
&lt;ul>
&lt;li>MB_R 代表读内存屏障，它保证读取操作不会重排到该指令调用之后。&lt;/li>
&lt;li>MB_W 代表写内存屏障，它保证写入操作不会重排到该指令调用之后。&lt;/li>
&lt;li>MB 代表读写内存屏障，可保证之前的指令不会重排到该指令调用之后。&lt;/li>
&lt;/ul>
&lt;p>这些屏障指令在单核处理器上同样有效，因为单处理器虽不涉及多处理器间数据同步问题，但指令重排和缓存仍然影响数据的正确同步。指令重排是非常底层的且实 现效果差异非常大，尤其是不同体系架构对内存屏障的支持程度，甚至在不支持指令重排的体系架构中根本不必使用屏障指令。具体如何使用这些屏障指令是支持的 平台、编译器或虚拟机要实现的，我们只需要使用这些实现的 API(指的是各种并发关键字、锁、以及重入性等，下节详细介绍)。这里的目的只是为了帮助更好 的理解内存屏障的工作原理。&lt;/p></description></item></channel></rss>