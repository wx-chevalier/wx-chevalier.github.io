<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>基础 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/</link><atom:link href="https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml"/><description>基础</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>基础</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/</link></image><item><title>Rebase</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/rebase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/rebase/</guid><description>&lt;h1 id="git-rebase-详解">Git Rebase 详解&lt;/h1>
&lt;p>本文主要讲解下 Git Rebase 的基本概念用法、其内部原理以及我们在真实项目中使用 Git Rebase 应该遵循的原则以及为啥需要遵循这些原则。&lt;/p>
&lt;h1 id="rebase-基础">Rebase 基础&lt;/h1>
&lt;p>相信对于 rebase 肯定不会陌生，就好像上图描述的过程一样，当你使用 rebase 命令的时候，即好像将你需要去 rebase 的分支拔下来然后重新插到另一个分支上。官方对于 rebase 的描述为：&lt;/p>
&lt;pre tabindex="0">&lt;code>“git-rebase: Forward-port local commits to the updated upstream head”— git doc
&lt;/code>&lt;/pre>&lt;p>翻译一下，就是讲你在某个分支上的所有提交记录移花接木到另一个分支上。这边需要强调一个概念：reapply，使用 rebase 并不是简单地好像你用 ctrl-x/ctrl-v 进行剪切复制一样，rebase 会依次地将你所要操作的分支的所有提交应用到目标分支上。也就是说，实际上在执行 rebase 的时候，有两个隐含的注意点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在重放之前的提交的时候，Git 会创建新的提交，也就是说即使你重放的提交与之前的一模一样 Git 也会将之当做新的独立的提交进行处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Git rebase 并不会删除老的提交，也就是说你在对某个分支执行了 rebase 操作之后，老的提交仍然会存放在.git 文件夹的 objects 目录下。如果你对于 Git 是如何存放你的提交不太了解的话可以参考这篇文章：&lt;a href="https://medium.freecodecamp.com/understanding-git-for-real-by-exploring-the-git-directory-1e079c15b807#.6ylqa5e2w" target="_blank" rel="noopener">Understanding git for real by exploring the .git directory&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>基于以上表述，我们可以得出以下相对更准确的 Git rebase 的工作流程：&lt;/p>
&lt;p>从上图可以看出，在对特征分支进行 rebase 之后，其等效于创建了新的提交。并且老的提交也没有被销毁，只是简单地不能再被访问或者使用。在对于分支的章节我们曾经提及，一个分支只是一个执行提交的指针。因此如果既没有分支或者 Tag 指向某个提交，该提交将无法再被访问使用，但是该提交会一直存在于你的文件系统中，占用着你的磁盘存储。&lt;/p>
&lt;h1 id="使用-rebase-修改本地历史">使用 Rebase 修改本地历史&lt;/h1>
&lt;p>顾名思义，Rebase(变基)有移花接木之效果，能将特性分支移接到主分支之上，常用于优化提交历史，或者修改本地的提交信息。首先查看本地的 Commit 历史：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ git log --pretty&lt;span class="o">=&lt;/span>oneline
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">a931ac7c808e2471b22b5bd20f0cad046b1c5d0d c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">b76d157d507e819d7511132bdb5a80dd421d854f b
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">df239176e1a2ffac927d8b496ea00d5488481db5 a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 Git Rebase:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用 Git Rebase，对最后两个提交进行操作&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rebase --interactive HEAD~2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">pick&lt;/span> &lt;span class="n">b76d157&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">squash&lt;/span> &lt;span class="n">a931ac7&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">//&lt;/span>&lt;span class="n">change&lt;/span> &lt;span class="n">pick&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">squash&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Rebase df23917..a931ac7 onto df23917&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Commands:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># p, pick = use commit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># r, reword = use commit, but edit the commit message&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># e, edit = use commit, but stop for amending&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># s, squash = use commit, but meld into previous commit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># f, fixup = like &amp;#34;squash&amp;#34;, but discard this commit&amp;#39;s log message&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># If you remove a line here THAT COMMIT WILL BE LOST.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># However, if you remove everything, the rebase will be aborted.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后保存并且关闭编辑器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># This is a combination of 2 commits.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># The first commit&amp;#39;s message is:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># This is the 2nd commit message:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">c&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样的话就已经完成了合并&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ git log --pretty&lt;span class="o">=&lt;/span>oneline
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">18fd73d3ce748f2a58d1b566c03dd9dafe0b6b4f b and c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">df239176e1a2ffac927d8b496ea00d5488481db5 a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="golden-rule-of-rebase">Golden Rule of Rebase&lt;/h1>
&lt;blockquote>
&lt;p>“No one shall rebase a shared branch” — Everyone about rebase&lt;/p>
&lt;/blockquote>
&lt;p>估计你也肯定看过这个原则，不过可能表述不一样罢了。本章节就是用实例的角度来探讨下，为啥不能再一个共享的分支上进行 Git rebase 操作。所谓共享的分支，即是指那些存在于远端并且允许团队中的其他人进行 Pull 操作的分支。假设现在 Bob 和 Anna 在同一个项目组中工作，项目所属的仓库和分支大概是下图这样：&lt;/p>
&lt;p>现在 Bob 为了图一时方便打破了原则，正巧这时 Anna 在特征分支上进行了新的提交，此时的结构图大概是这样的：&lt;/p>
&lt;p>当 Bob 打算推送自己的分支到远端的时候，它收到了如下的警告：&lt;/p>
&lt;p>Git 尝试着使用 fast-forward 来合并你的分支，具体的细节我们会在其他博客中进行讨论，这边只需要明白远端的 Git Server 被 Bob 搞得一头雾水，不知道应该如何去合并。此时 Bob 为了推送他的本地的提交，只能选择强行合并，即告诉远端：不要再尝试着合并我推送给你的和你已经有点提交，一切按照我推送过去的来。那么 Git 会进行如下操作：&lt;/p>
&lt;p>然后呢，当 Anna 也进行推送的时候，她会得到如下的提醒：&lt;/p>
&lt;p>这个消息很正常，没啥特殊的，只是 Git 提醒 Anna 她本地的版本与远程分支并不一致，在 Anna 提交之前，分支中的 Commit 序列是如下这样的：&lt;/p>
&lt;pre tabindex="0">&lt;code>A--B--C--D&amp;#39; origin/feature // GitHub
A--B--D--E feature // Anna
&lt;/code>&lt;/pre>&lt;p>在进行 Pull 操作之后，Git 会进行自动地合并操作，结果大概是这样的：&lt;/p>
&lt;p>这个第 M 个提交即代表着合并的提交，也就是 Anna 本地的分支与 Github 上的特征分支最终合并的点，现在 Anna 解决了所有的合并冲突并且可以 Push 她的代码，在 Bob 进行 Pull 之后，每个人的 Git Commit 结构为：&lt;/p>
&lt;p>到这里，看到上面这个混乱的流线图，相信你对于 Rebase 和所谓的黄金准则也有了更形象深入的理解。这还只是仅有两个人，一个特征分支的项目因为误用 rebase 产生的后果。如果你团队中的每个人都对公共分支进行 rebase 操作，那还不得一团乱麻。另外，相信你也注意到，在远端的仓库中存有大量的重复的 Commit 信息，这会大大浪费我们的存储空间。如果你还觉得这么什么，那我们来假设下还有一哥们 Emma，第三个开发人员，在他进行了本地 Commit 并且 Push 到远端之后，仓库变为了：&lt;/p></description></item><item><title>Workflow</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/workflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/workflow/</guid><description>&lt;h1 id="git-workflow">Git Workflow&lt;/h1>
&lt;h1 id="commit-message--提交信息规范">Commit Message | 提交信息规范&lt;/h1>
&lt;p>目前规范使用较多的是 &lt;a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md%23-git-commit-guidelines" target="_blank" rel="noopener">Angular 团队的规范&lt;/a>, 继而衍生了 &lt;a href="https://conventionalcommits.org/" target="_blank" rel="noopener">Conventional Commits specification&lt;/a>. 很多工具也是基于此规范, 它的 message 格式如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;
&amp;lt;BLANK LINE&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;BLANK LINE&amp;gt;
&amp;lt;footer&amp;gt;
&lt;/code>&lt;/pre>&lt;p>我们通过 git commit 命令带出的 vim 界面填写的最终结果应该类似如上这个结构, 大致分为三个部分(使用空行分割):&lt;/p>
&lt;ul>
&lt;li>标题行: 必填, 描述主要修改类型和内容&lt;/li>
&lt;li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等&lt;/li>
&lt;li>页脚注释: 放 Breaking Changes 或 Closed Issues&lt;/li>
&lt;/ul>
&lt;p>分别由如下部分构成:&lt;/p>
&lt;ul>
&lt;li>type: commit 的类型
&lt;ul>
&lt;li>feat: 新特性&lt;/li>
&lt;li>fix: 修改问题&lt;/li>
&lt;li>refactor: 代码重构&lt;/li>
&lt;li>docs: 文档修改&lt;/li>
&lt;li>style: 代码格式修改, 注意不是 css 修改&lt;/li>
&lt;li>test: 测试用例修改&lt;/li>
&lt;li>chore: 其他修改, 比如构建流程, 依赖管理.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>scope: commit 影响的范围, 比如: route, component, utils, build&amp;hellip;&lt;/li>
&lt;li>subject: commit 的概述, 建议符合 &lt;a href="https%ef%bc%9a//stackoverflow.com/questions/2290016/git-commit-messages-50-72-formatting" target="_blank" rel="noopener">50/72 formatting&lt;/a>&lt;/li>
&lt;li>body: commit 具体修改内容, 可以分为多行, 建议符合 &lt;a href="https%ef%bc%9a//stackoverflow.com/questions/2290016/git-commit-messages-50-72-formatting" target="_blank" rel="noopener">50/72 formatting&lt;/a>&lt;/li>
&lt;li>footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.&lt;/li>
&lt;/ul>
&lt;h2 id="模板">模板&lt;/h2>
&lt;p>这样一个符合规范的 commit message, 就好像是一份邮件。如果你只是个人的项目, 或者想尝试一下这样的规范格式, 那么你可以为 git 设置 commit template, 每次 git commit 的时候在 vim 中带出, 时刻提醒自己。修改 ~/.gitconfig, 添加:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">template&lt;/span> &lt;span class="o">=&lt;/span> ~/.gitmessage
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>新建 ~/.gitmessage 内容可以如下:&lt;/p>
&lt;pre tabindex="0">&lt;code># head: &amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;
# - type: feat, fix, docs, style, refactor, test, chore
# - scope: can be empty (eg. if the change is a global or difficult to assign to a single component)
# - subject: start with verb (such as &amp;#39;change&amp;#39;), 50-character line
#
# body: 72-character wrapped. This should answer:
# * Why was this change necessary?
# * How does it address the problem?
# * Are there any side effects?
#
# footer:
# - Include a link to the ticket, if any.
# - BREAKING CHANGE
#
&lt;/code>&lt;/pre>&lt;h2 id="merge-request">Merge Request&lt;/h2>
&lt;p>推荐团队中采用 Merge Request 的方式进行协作开发，即基于主分支 clone 之后再合并回去：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">checkout&lt;/span> &lt;span class="nx">dev&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">pull&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="nx">rebase&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="nx">prune&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">checkout&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="nx">feat&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nx">or&lt;/span> &lt;span class="nx">fix&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span> &lt;span class="nx">coding&lt;/span> &lt;span class="nx">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span> &lt;span class="nx">may&lt;/span> &lt;span class="nx">commit&lt;/span> &lt;span class="nx">several&lt;/span> &lt;span class="nx">times&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">commit&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span> &lt;span class="nx">make&lt;/span> &lt;span class="nx">sure&lt;/span> &lt;span class="nx">rebase&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="nx">origin&lt;/span> &lt;span class="nx">dev&lt;/span> &lt;span class="nx">branch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">fetch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">rebase&lt;/span> &lt;span class="nx">origin&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">dev&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">push&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nx">maybe&lt;/span> &lt;span class="sb">`-f`&lt;/span> &lt;span class="nx">flag&lt;/span> &lt;span class="nx">is&lt;/span> &lt;span class="nx">required&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">you&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="nx">ve&lt;/span> &lt;span class="nx">pushed&lt;/span> &lt;span class="nx">before&lt;/span> &lt;span class="nx">rebase&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span> &lt;span class="nx">create&lt;/span> &lt;span class="nx">Merge&lt;/span> &lt;span class="nx">Request&lt;/span> &lt;span class="nx">to&lt;/span> &lt;span class="nx">dev&lt;/span> &lt;span class="nx">branch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span> &lt;span class="nx">code&lt;/span> &lt;span class="nx">changes&lt;/span> &lt;span class="nx">according&lt;/span> &lt;span class="nx">MR&lt;/span> &lt;span class="nx">review&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span> &lt;span class="nx">confirm&lt;/span> &lt;span class="nx">to&lt;/span> &lt;span class="nx">rebase&lt;/span> &lt;span class="nx">again&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="nx">others&lt;/span> &lt;span class="nx">merged&lt;/span> &lt;span class="nx">before&lt;/span> &lt;span class="nx">your&lt;/span> &lt;span class="nx">MR&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">fetch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">rebase&lt;/span> &lt;span class="nx">origin&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">dev&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">git&lt;/span> &lt;span class="nx">push&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/34223150" target="_blank" rel="noopener">2018-优雅的提交你的 Git Commit Message&lt;/a>: commit message 是开发的日常操作, 写好 log 不仅有助于他人 review, 还可以有效的输出 CHANGELOG, 对项目的管理实际至关重要, 但是实际工作中却常常被大家忽略。&lt;/li>
&lt;/ul></description></item><item><title>仓库</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E4%BB%93%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E4%BB%93%E5%BA%93/</guid><description>&lt;h1 id="仓库">仓库&lt;/h1>
&lt;p>Git 是来源于 Linux 内核开发中的的一个分布式版本管理工具，基于 Git 的工作流程也是有很多工作流。&lt;/p>
&lt;h1 id="configuration--配置">Configuration | 配置&lt;/h1>
&lt;h2 id="management--配置管理">Management | 配置管理&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列举所有的别名与配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Git 别名配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.&amp;lt;handle&amp;gt; &amp;lt;command&amp;gt; git config --global alias.st status
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置 Git 为大小写敏感&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global core.ignorecase &lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以查看常用的辅助查询命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在 Git 命令行里查看 everyday git&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git &lt;span class="nb">help&lt;/span> everyday
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示 git 常用的帮助命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git &lt;span class="nb">help&lt;/span> -g
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取 Git Bash 的自动补全&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">curl http://git.io/vfhol &amp;gt; ~/.git-completion.bash &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;[ -f ~/.git-completion.bash ] &amp;amp;&amp;amp; . ~/.git-completion.bash&amp;#39;&lt;/span> &amp;gt;&amp;gt; ~/.bashrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置自动更正&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global help.autocorrect &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="user--用户配置">User | 用户配置&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 配置 HTTP 代理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global http.proxy http://127.0.0.1:1080
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global https.proxy https://127.0.0.1:1080
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 配置 Socks 代理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global http.proxy &lt;span class="s1">&amp;#39;socks5://127.0.0.1:1080&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global https.proxy &lt;span class="s1">&amp;#39;socks5://127.0.0.1:1080&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 取消代理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global --unset http.proxy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global --unset https.proxy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global http.sslVerify &lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.cp&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;cherry-pick&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.st&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;status -sb&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.cl&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;clone&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.ci&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;commit&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.co&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;checkout&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.br&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;branch&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.dc&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;diff --cached&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.lg&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s2">&amp;#34;log --graph --pretty=format:&amp;#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %Cblue&amp;lt;%an&amp;gt;%Creset&amp;#39; --abbrev-commit --date=relative --all&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.last&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;log -1 --stat&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">gitalias&lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;alias.unstage&amp;#39;&lt;/span>&lt;span class="o">]=&lt;/span>&lt;span class="s1">&amp;#39;reset HEAD --&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="认证信息">认证信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用 credential 管理密码，拉取仓库时候仅需要输入一次&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git config --global credential.helper store
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="repository--仓库配置与管理">Repository | 仓库配置与管理&lt;/h1>
&lt;p>初始化某个仓库：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 初始化一个版本仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#Clone远程版本库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone git@xbc.me:wordpress.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone https://username@github.com/username/repository.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加远程版本库origin，语法为 git remote add [shortname] [url]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote add origin git@xbc.me:wordpress.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用 credential 管理密码，拉取仓库时候仅需要输入一次&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git config --global credential.helper store
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看远端仓库相关信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取所有远端引用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 或者&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote show
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 修改某个远端的地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote set-url origin &amp;lt;URL&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看仓库的统计信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看当前仓库中的所有未打包的 objects 和磁盘占用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git count-objects --human-readable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 从 object 数据库中删除所有不可达的 object&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git gc --prune&lt;span class="o">=&lt;/span>now --aggressive
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="gitignore">.gitignore&lt;/h1>
&lt;p>注意忽略只对未跟踪文件有效，对于已加入版本库的文件无效，Git 内置三级忽略文件机制：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>版本库共享式忽略文件，版本库中目录下的 .gitignore 文件作用于整个目录及子目录，会随着该版本库同其他人共享。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地的针对具体版本库的独享式忽略文件，即在版本库 .git 目录下的文件 info/exclude 中设置文件忽略&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地的全局的独享式忽略文件，通过 Git 的配置变量 core.excludesfile 指定的一个忽略文件(指定文件名)，其设置的忽略对所有本地版本库均有效。设置方法如下(文件名可以任意设置)：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ git config --global core.excludesfile ~/.gitignore
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Git 的忽略文件遵循以下语法规则：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>忽略文件中的空行或以井号(#)开始的行将会被忽略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以使用 Linux 通配符。例如：星号(*)代表任意多个字符，问号(？)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2,&amp;hellip;})代表可选的字符串等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果名称的最前面有一个感叹号(!)，表示例外规则，将不被忽略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果名称的最前面是一个路径分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果名称的最后面是一个路径分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="statistics--统计数据">Statistics | 统计数据&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看 Git 上的个人代码量，username 需要修改为真实用户名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git log --author&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;username&amp;#34;&lt;/span> --pretty&lt;span class="o">=&lt;/span>tformat: --numstat &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &amp;#34;added lines: %s, removed lines: %s, total lines: %s\n&amp;#34;, add, subs, loc }&amp;#39;&lt;/span> -
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># added lines: 120745, removed lines: 71738, total lines: 49007&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 统计每个人增删行数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log --format&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;%aN&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> sort -u &lt;span class="p">|&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="nb">read&lt;/span> name&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="nb">echo&lt;/span> -en &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$name&lt;/span>&lt;span class="s2">\t&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> git log --author&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$name&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> --pretty&lt;span class="o">=&lt;/span>tformat: --numstat &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &amp;#34;added lines: %s, removed lines: %s, total lines: %s\n&amp;#34;, add, subs, loc }&amp;#39;&lt;/span> -&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 统计提交数前五名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git log --pretty&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;%aN&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> sort &lt;span class="p">|&lt;/span> uniq -c &lt;span class="p">|&lt;/span> sort -k1 -n -r &lt;span class="p">|&lt;/span> head -n &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="仓库清理">仓库清理&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看历史大文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git rev-list --objects --all &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>git verify-pack -v .git/objects/pack/*.idx &lt;span class="p">|&lt;/span> sort -k &lt;span class="m">3&lt;/span> -n &lt;span class="p">|&lt;/span> tail -5 &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{print$1}&amp;#39;&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 从历史中删除 target/ 这个文件夹&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git filter-branch --force --index-filter &lt;span class="s1">&amp;#39;git rm -r --cached --ignore-unmatch target/&amp;#39;&lt;/span> --prune-empty --tag-name-filter cat -- --all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 执行仓库压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git gc --prune&lt;span class="o">=&lt;/span>now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 推送到远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git push origin --force --all
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>分支</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E5%88%86%E6%94%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E5%88%86%E6%94%AF/</guid><description>&lt;h1 id="branch--分支">Branch | 分支&lt;/h1>
&lt;p>Git 中的分支实际上只是 Commit 指针。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 命令行中查看版本树&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git log --pretty&lt;span class="o">=&lt;/span>oneline --graph --decorate --all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 内置的可视化界面查看版本树&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ gitk --all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据提交人过滤 Commit 信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git log --author&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;username&amp;#34;&lt;/span> --pretty&lt;span class="o">=&lt;/span>format:&lt;span class="s2">&amp;#34;%h - %an, %ar : %s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="manipulation--操作">Manipulation | 操作&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建某个分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch BRANCH_NAME
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建并且切换到某个分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b BRANCH_NAME
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="head">Head&lt;/h2>
&lt;p>分支是&lt;/p>
&lt;h1 id="merge--分支合并">Merge | 分支合并&lt;/h1>
&lt;p>&amp;ndash;force 会使用本地分支的提交覆盖远端推送分支的提交。也就是说，如果其他人在相同的分支推送了新的提交，你的这一举动将“删除”他的那些提交！就算在强制推送之前先 fetch 并且 merge 或 rebase 了也是不安全的，因为这些操作到推送之间依然存在时间差，别人的提交可能发生在这个时间差之内。使用此参数推送，如果远端有其他人推送了新的提交，那么推送将被拒绝，这种拒绝和没有加 &amp;ndash;force 参数时的拒绝是一样的。&lt;/p>
&lt;h2 id="cherry-pick">cherry-pick&lt;/h2>
&lt;p>git cherry-pick 可以选择某一个分支中的一个或几个 commit(s) 来进行操作，譬如我们存在多个稳定开发版本，在不能完全合并分支的情况下又想把某些功能合入到某个分支，那就可以利用 cherry-pick 对已经存在的 commit 进行再次提交。注意，当执行完 cherry-pick 以后，将会生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名一样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选择某个其他分支的 commit 合并到当前分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git cherry-pick &amp;lt;commit id&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果出现冲突，则类似于 Rebase 进行解决&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 手动查看冲突文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git status
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置文件已经解决冲突&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git add ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置 cherry-pick 继续执行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git cherry-pick --continue
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git cherry-pick --quit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git cherry-pick --abort
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>提交</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E6%8F%90%E4%BA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E6%8F%90%E4%BA%A4/</guid><description>&lt;h1 id="提交">提交&lt;/h1>
&lt;h1 id="commit--提交">Commit | 提交&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 管道命令，可用于脚本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git diff-tree --no-commit-id --name-only -r bd61ad98
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看某次提交中修改的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git show --pretty&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span> --name-only bd61ad98
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速提交">快速提交&lt;/h2>
&lt;p>有时候我们希望能一键执行 add、commit、push 这些操作，可以封装为如下的函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="k">function&lt;/span> lazygit&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> git add .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> git commit -a -m &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$1&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> git push
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># lazygit &amp;#34;My commit msg&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者封装为单独的 Git alias 命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">git config --global alias.cmp &lt;span class="s1">&amp;#39;!f() { git add -A &amp;amp;&amp;amp; git commit -m &amp;#34;$@&amp;#34; &amp;amp;&amp;amp; git push; }; f&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>alias&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">cmp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;!f() { git add -A &amp;amp;&amp;amp; git commit -m \&amp;#34;&lt;/span>&lt;span class="nv">$@&lt;/span>&lt;span class="s2">\&amp;#34; &amp;amp;&amp;amp; git push; }; f&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用方式如下&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git cmp &lt;span class="s2">&amp;#34;Long commit message goes here&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="tracking--追踪">Tracking | 追踪&lt;/h1>
&lt;p>查看当前追踪的文件信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 展示所有被追踪的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git ls-files -t
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 展示所有未被追踪的分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git ls-files --others
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 展示所有被忽略的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git ls-files --others -i --exclude-standard
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git check-ignore *
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git status --ignored
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 从工作目录中删除文件，同时会暂存信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git rm &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 从版本控制中移除该文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git rm --cached &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 本地重命名并且提交&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ git mv &lt;span class="o">[&lt;/span>file-original&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file-renamed&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="stash--贮存">Stash | 贮存&lt;/h1>
&lt;p>git stash &amp;ndash; The command saves your local modifications away and reverts the working directory to match the HEAD commit. It allows you to store your uncommited modifications into a buffer area called stash, and deletes it from the branch you are working on. You may later retreive them by applying the stash.&lt;/p>
&lt;h1 id="undo--撤销">Undo | 撤销&lt;/h1></description></item><item><title>运行机制</title><link>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/engineering-series/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/%E5%9F%BA%E7%A1%80/%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid><description>&lt;h1 id="git-mechanism--git-运行机制">Git Mechanism | Git 运行机制&lt;/h1>
&lt;p>当你创建一个仓库的时候，使用 git init 指令，git 将会创建一个神奇的目录：.git。这个目录下包含了所有 git 正常工作所需要的信息。而 Git 运行的基础以及一切信息的存放地，就在这个目录。&lt;/p>
&lt;pre tabindex="0">&lt;code>├── HEAD
├── branches
├── config
├── description
├── hooks
│ ├── pre-commit.sample
│ ├── pre-push.sample
│ └── ...
├── info
│ └── exclude
├── objects
│ ├── info
│ └── pack
└── refs
├── heads
└── tags
&lt;/code>&lt;/pre>&lt;p>我们先粗略地看下各个文件目录的作用：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>config: 这个文件包含你仓库的设置信息。例如这里会放你远程仓库的 URL，你的 email 地址，你的用户名等…。每次你在控制台使用“git config…”指令时，修改的就是这里。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>description: gitweb(可以说是 github 的前身)用来显示仓库的描述。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hooks: 这是一个有意思的特性。Git 提供了一系列的脚本，你可以在 git 每一个有实质意义的阶段让它们自动运行。这些脚本就是 hooks，可以在 commit/rebase/pull…. 的前后运行。脚本的名字表示它什么时候被运行。例如一个有用的预推送 hook 可能会测试关于保持远程仓库一致性的式样原则。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>info-exclude: 你可以把你不想让 git 处理的文件放到 .gitignore 文件里。那么，exclude 文件也有同样的作用，不同的地方是它不会被共享，比如当你不想跟踪你的自定义的 IDE 相关的配置文件时，即使通常情况下 .gitignore 就足够了(如果你用到了这个请在评论中告诉我)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="commit-的流程">commit 的流程&lt;/h2>
&lt;p>每一次你创建一个文件并跟踪它会发现，git 会对其进行压缩然后以 git 自己的数据结构形式来存储。这个压缩的对象会有一个唯一的名字，即一个哈希值，这个值存放在 object 目录下。在探索 object 目录前，我们先要问自己 commit 到底是何方神圣。commit 大致可以视为你工作目录的快照，但是它又不仅仅只是一种快照。实际上，当你提交的时候，为创建你工作目录的快照 git 只做了两件事：&lt;/p>
&lt;ul>
&lt;li>如果这个文件没有改变，git 仅仅只把压缩文件的名字(就是哈希值)放入快照。&lt;/li>
&lt;li>如果文件发生了变化，git 会压缩它，然后把压缩后的文件存入 object 目录。最后再把压缩文件的名字(哈希值)放入快照。&lt;/li>
&lt;/ul>
&lt;p>一旦快照创建好，其本身也会被压缩并且以一个哈希值命名。那么所有的压缩对象都放在哪里呢？答案是 object 目录。&lt;/p>
&lt;pre tabindex="0">&lt;code>├── 4c
│ └── f44f1e3fe4fb7f8aa42138c324f63f5ac85828 // hash
├── 86
│ └── 550c31847e518e1927f95991c949fc14efc711 // hash
├── e6
│ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391 // hash
├── info // let&amp;#39;s ignore that
└── pack // let&amp;#39;s ignore that too
&lt;/code>&lt;/pre>&lt;p>这就是我创建一个空文件 file_1.txt 并提交后 object 目录看起来的样子。请注意如果你的文件的哈希值是“89faaee…”，git 会把这个文件存在 “89” 目录下然后命名这个文件为 “faaee…”。你会看到 3 个哈希。一个对应 file_1.txt，另一个对应在提交时所创建的快照。那么第三个是什么呢？其实是因为 commit 本身也是一个对象并且也被压缩存放在 object 目录下。
现在，你需要记住的是一个 commit 包含四个部分：&lt;/p>
&lt;ul>
&lt;li>工作目录快照的哈希&lt;/li>
&lt;li>提交的说明信息&lt;/li>
&lt;li>提交者的信息&lt;/li>
&lt;li>父提交的哈希值
如果我们解压缩一个提交，你自己可以看看到底是什么：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>// by looking at the history you can easily find your commit hash
// you also don&amp;#39;t have to paste the whole hash, only enough
// characters to make the hash unique
git cat-file -p 4cf44f1e3fe4fb7f8aa42138c324f63f5ac85828
&lt;/code>&lt;/pre>&lt;p>这是我看到的&lt;/p>
&lt;pre tabindex="0">&lt;code>tree 86550c31847e518e1927f95991c949fc14efc711
author Pierre De Wulf &amp;amp;amp;amp;lt;test@gmail.com&amp;amp;amp;amp;gt; 1455775173 -0500
committer Pierre De Wulf &amp;amp;amp;amp;lt;test@gmail.com&amp;amp;amp;amp;gt; 1455775173 -0500
commit A
&lt;/code>&lt;/pre>&lt;p>如你所见我们得到了所期望看到的的：快照的哈希，作者，提交信息。这里有两样东西很重要：&lt;/p>
&lt;ul>
&lt;li>正如预料的一样，快照的哈希 “86550…” 也是一个对象并且能在 object 目录下找到。&lt;/li>
&lt;li>因为这是我的第一个提交，所以没有父提交。
那我的快照里面到底是些什么呢？&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>git cat-file -p 86550c31847e518e1927f95991c949fc14efc711
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 file_1.txt
&lt;/code>&lt;/pre>&lt;p>到这里我们看到的最后一个对象是我们先前提到的唯一会存在于快照中的对象。它是一个 blob(二进制文件)，这里就不作深究了。&lt;/p>
&lt;h2 id="head标签分支">HEAD/标签/分支&lt;/h2>
&lt;p>那么现在你知道 git 的每一个对象都有一个正确的哈希值。现在我们来看看 HEAD 吧！那么，在 HEAD 里又有什么呢？&lt;/p>
&lt;pre tabindex="0">&lt;code>cat HEAD
ref: refs/heads/master
&lt;/code>&lt;/pre>&lt;p>这看起来 HEAD 不是一个 hash，倒是容易理解，因为 HEAD 可以看作一个你目前所在分支的指针。如果我们看看 refs/heads/master，就会发现这些：&lt;/p>
&lt;pre tabindex="0">&lt;code>cat refs/heads/master
4cf44f1e3fe4fb7f8aa42138c324f63f5ac85828
&lt;/code>&lt;/pre></description></item></channel></rss>