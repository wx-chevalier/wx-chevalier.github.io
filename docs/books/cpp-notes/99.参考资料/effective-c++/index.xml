<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Effective C&#43;&#43; | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/</link>
      <atom:link href="https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c++/index.xml" rel="self" type="application/rss+xml" />
    <description>Effective C&#43;&#43;</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>Effective C&#43;&#43;</title>
      <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/</link>
    </image>
    
    <item>
      <title>01.accustoming-yourself-to-cpp</title>
      <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/01.accustoming-yourself-to-cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/01.accustoming-yourself-to-cpp/</guid>
      <description>&lt;p&gt;原书的第一部分，主要是对 C++语言的介绍以及优化&lt;code&gt;#define&lt;/code&gt;的方法等比较基础的知识点。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;item1-视-c为一个语言集合&#34;&gt;item1 视 C++为一个语言集合&lt;/h2&gt;
&lt;p&gt;不同于 C，C++已经不再是一个带有单一语言规则的计算机语言。今天的 C++是一个多重泛型编程语言，它同时支持&lt;em&gt;面向过程&lt;/em&gt; 、&lt;em&gt;面向对象&lt;/em&gt; 、&lt;em&gt;函数式编程&lt;/em&gt; 、&lt;em&gt;泛型编程&lt;/em&gt; 、&lt;em&gt;元编程&lt;/em&gt; 。因此，我们需要&lt;strong&gt;将 C+++视为一个由相关语言组成的集合，而不是单一语言&lt;/strong&gt;。它包含了四个语言模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;：C++是以 C 语言为基础的，C++的语法规则、预处理器、内置数据类型、数组、指针等都是来自于 C，许多 C++的语法就是较高级的 C。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object-Oriented C++&lt;/strong&gt;：也就是很多时候提到的&lt;em&gt;C With Classes&lt;/em&gt; ，其中包含了 C++面向对象的机制：类，以及封装、继承、多态、虚函数等类的支持机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template C++&lt;/strong&gt;：泛型编程模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STL&lt;/strong&gt;：STL 是一个封装了容器、迭代器、算法以及函数对象的 template 库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为什么要区分 C++中的语言模块&lt;/strong&gt;
为了提高 C++的效率，使用不同的语言模块需要遵循不同的编程策略，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 C 语言中，一般使用值传递（pass-by-value）；&lt;/li&gt;
&lt;li&gt;在 OOC 和模板 C++中，使用常量引用（pass-by-reference-const）传递更加高效；&lt;/li&gt;
&lt;li&gt;对于 STL，因为迭代器是基于指针构造而成，直接使用值传递即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item2-用-constenuminline-代替define&#34;&gt;item2 用 const,enum,inline 代替#define&lt;/h2&gt;
&lt;p&gt;换言之，以&lt;strong&gt;编译器替换预处理器&lt;/strong&gt;。预处理宏会在编译器之前被简单的替换成代码，经常会发生意料之外的错误，这种错误往往难以跟踪到。因此，除了一些特殊的指令外，如&lt;code&gt;#include&lt;/code&gt;，应该尽量避免使用预处理宏。解决之道是对&lt;code&gt;#define&lt;/code&gt;进行替换。&lt;/p&gt;
&lt;h3 id=&#34;21-const-替换define-定义的常量&#34;&gt;2.1 const 替换#define 定义的常量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数值常量&lt;/strong&gt;：对于数值类型的常量，可以通过定义一个全局常量来对&lt;code&gt;#define&lt;/code&gt;进行替换，如&lt;code&gt;const double A=3.141592654;&lt;/code&gt;替换&lt;code&gt;#define A 3.141592654&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常量指针&lt;/strong&gt;：由于常量定义通常被放在头文件中以便被不同的源码包含，因此需要把指针以及指针指向的数据都定义位&lt;code&gt;const&lt;/code&gt;，如&lt;code&gt;const char* const author=&amp;quot;Scotter Meyers&amp;quot;;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类的常量&lt;/strong&gt;：对于类中的常量成员，为了保证其能被类的对象访问到，又不会生成多个拷贝，需要将其声明为静态常量，即&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Player{
private:
    static const int numTurns=5;//静态成员变量，属于类不会在实例化过程中产生拷贝；const成员，不能进行赋值操作
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;22-enum-使用技巧&#34;&gt;2.2 enum 使用技巧&lt;/h3&gt;
&lt;p&gt;当我们要在一个类中声明一个常量，这个常量不允许在在声明时进行初始化，而接下来某个语句明确要用到这个变量，比如说静态数组的声明，如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numTurns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//一些编译器不允许static成员在声明时赋值，需要在类外进行定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scores&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numTurns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 编译无法通过，在编译过程中必须要指定数组大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;面对上面个的问题，我们可以选择使用 enum 来解决，即：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Player{
private:
    enum {NumTurns=5};    // 因为枚举类型的数值可以充当int使用，
    int scores[NumTurns]; // 所以，编译通过。
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;23-inline-函数&#34;&gt;2.3 inline 函数&lt;/h3&gt;
&lt;p&gt;对于一些简单又需要反复调用的程序语句，将其封装成函数是非常不划算的，因为调用函数的开销甚至超过了函数内代码运行的开销。&lt;code&gt;#define&lt;/code&gt;实现类似于函数的宏定义，好处是可以减少简单函数调用造成额外开销，但是其代码非常不雅观，而且会导致一些未知的错误。C++提供了&lt;strong&gt;内联函数&lt;/strong&gt;来帮助我们避免简单函数调用带来的不必要开销，也可以避免宏替换带来的不可预料的错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于单纯的常量，最好用&lt;code&gt;const&lt;/code&gt;对象或&lt;code&gt;enum&lt;/code&gt;对象替换&lt;code&gt;#define&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于形似函数的宏，最好用&lt;code&gt;inline&lt;/code&gt;函数替换&lt;code&gt;#define&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item3-多用-const&#34;&gt;item3 多用 const&lt;/h2&gt;
&lt;p&gt;const 允许指定一个语义约束，告诉编译器和程序员某个值应该保持不变，而编译器会强制实施这个约束。&lt;/p&gt;
&lt;h3 id=&#34;31-const-与指针&#34;&gt;3.1 const 与指针&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常量指针&lt;/strong&gt;：指向常量的指针，const 在&lt;code&gt;*&lt;/code&gt;左边&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指针常量&lt;/strong&gt;：指针类型的常量，const 在&lt;code&gt;*&lt;/code&gt;右边&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const char* p; // 数据是常量
char const* p; // 数据是常量
char* const p; // 指针是常量
const char* const p; // 指针和数据都是常量
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;32-const-与-stl-迭代器&#34;&gt;3.2 const 与 STL 迭代器&lt;/h3&gt;
&lt;p&gt;STL 迭代器相当于类型 T 的指针，即&lt;code&gt;T*&lt;/code&gt;。因此，如果想定义一个迭代器指向一个常数，需要使用 const_iterator。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; vec;
std::vector&amp;lt;int&amp;gt;::const_iterator const_itr = vec.begin(); // const_itr类似于const T*，指向一个常量
++const_itr;                                              // 迭代器可变
*const_itr = 10;                                          // 错误，*const_itr不可变

const std::vector&amp;lt;int&amp;gt;::iterator itr = vec.begin();       // iter类似于T* const
++itr;                                                    // 错误，指针是一个常量
*itr = 10;                                                // 改变指向的值
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;33-const-与函数&#34;&gt;3.3 const 与函数&lt;/h3&gt;
&lt;p&gt;const 最有效的用法是在函数声明时的应用。在一个函数声明式内，const 可以和函数返回值、参数以及函数自身产生关联。例如，我们可以让函数返回一个常量值，可以降低因用户错误而造成的意外。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Rational{...};
Rational operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs){...};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在某处使用乘法操作符时，误把比较操作符&lt;code&gt;===&lt;/code&gt;写成了赋值操作符&lt;code&gt;=&lt;/code&gt;，如&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Rational a,b,c;
if((a*b)=c){...}     // 编译器不会报错，很难追踪错误
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决办法是&lt;strong&gt;将操作符定义为返回 const&lt;/strong&gt;，这样对其赋值将会是非法操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const Rational operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs){...};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;34-const-与类的成员函数&#34;&gt;3.4 const 与类的成员函数&lt;/h3&gt;
&lt;p&gt;用 const 关键字修饰类的成员函数主要有两个作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是可以直观的告诉用户函数是否会改变成员变量；&lt;/li&gt;
&lt;li&gt;二是用 const 修饰的对象只能调用 const 修饰的成员函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-数据常量性和逻辑常量性&#34;&gt;3.5 数据常量性和逻辑常量性&lt;/h3&gt;
&lt;p&gt;C++标准对成员函数常量性的规定是&lt;strong&gt;数据常量性&lt;/strong&gt;，即不允许成员变量被修改。C++编译器对此的检测标准是&lt;strong&gt;检查该成员函数中有没有给成员变量进行赋值操作&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class CTextBlock
{
    public:
        char&amp;amp; operator[](std::size_t pos) const
        {
            return pText[pos];
        }
    private:
        char* pText;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只有指针属于对象，指针所指向的数据不属于对象，const 修饰的&lt;code&gt;operator[]&lt;/code&gt;中并没有赋值操作符，编译器会通过编译，但是其存在着潜在风险。如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const CTextBlock ctb(&amp;#34;Hello&amp;#34;); // 声明一个常量对象
char* pc = &amp;amp;ctb[0];            // 调用operator[]取得一个指针，指向ctb的数据
*pc = &amp;#34;J&amp;#34;;                     // 数据被修改为&amp;#34;Jello&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据常量性还存在着另一个局限性，如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class CTextBlock
{
    public:
        std::size_t length() const
        {
            if(!lengthIsValid)
            {
                textLength = std::strlen(pText);  // 有赋值操作，编译会发生错误，但事实上这种改变是允许且必要的
                lengthIsValid = true;
            }
            return textLength;
        }
    private:
        char* pText;
        std::size_t textLength;
        bool lengthIsValid;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决办法是&lt;strong&gt;逻辑常量性&lt;/strong&gt;，即使用&lt;code&gt;mutable&lt;/code&gt;关键字来修饰成员变量，允许数据被修改，但是这些修改不反映到类外。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CTextBlock&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lengthIsValid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;textLength&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pText&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 编译可以通过
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;lengthIsValid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;textLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pText&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;mutable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;textLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;mutable&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lengthIsValid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;36-在-const-和-non-const-成员函数中避免重复&#34;&gt;3.6 在 const 和 non-const 成员函数中避免重复&lt;/h3&gt;
&lt;p&gt;在 C+++中，两个函数如果只是常量性不同，可以被重载。但是这样就存在着两个几乎完全重复的函数，虽然可以另外写一个私有函数进行调用，但是还是存在一些重复的代码，如函数调用和 return 等语句。我们真正应该实现的是&lt;strong&gt;一次实现，两次调用&lt;/strong&gt;，即其中一个调用另一个，需要用到&lt;strong&gt;常量性转换&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class TextBlock
{
   public:
        const char&amp;amp; operator[](std::size_t pos) const
        {
            // ....
            return pText[ pos ];
        }
        char&amp;amp; operator[](std::size_t pos)
        {
            return
                const_cast&amp;lt;char&amp;amp;&amp;gt;(                         // 将[]的const移除，转换成char&amp;amp;
                    static_cast&amp;lt;const TextBlock&amp;amp;&amp;gt;(*this)   // 为*this加上const，从而可以调用const操作
                        [ position ]
                );
        }
    private:
        char* pText;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量，指针，迭代器以及函数都可以通过 const 的修饰来实现只读的目的；&lt;/li&gt;
&lt;li&gt;编译器强制使用的是数据常量性，但是编写程序的时候应该采用逻辑常量性，对需要修改的成员变量加上&lt;code&gt;mutalbe&lt;/code&gt;关键字修饰；&lt;/li&gt;
&lt;li&gt;const 和 non-const 成员函数有着大量重复的实现，可以使用 non-const 函数来调用 const 函数来避免重复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item4-确保对象在使用前已被初始化&#34;&gt;item4 确保对象在使用前已被初始化&lt;/h2&gt;
&lt;p&gt;C++不能保证每个对象在定义时都被自动初始化，最佳的办法就是永远在使用对象之前先将其初始化。&lt;/p&gt;
&lt;h3 id=&#34;41-内置数据类型的初始化&#34;&gt;4.1 内置数据类型的初始化&lt;/h3&gt;
&lt;p&gt;C++的内置数据类型继承自 C，不能保证变量在定义式自动初始化。使用未初始化的数据可能会导致程序运行错误，因此需要手动进行初始化。&lt;/p&gt;
&lt;h3 id=&#34;42-类的初始化&#34;&gt;4.2 类的初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于用户自定义的类，需要构造函数来完成类的初始化，需要保证构造函数将对象的每一个成员初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++规定，对象的成员变量的初始化动作发生在进入构造函数体之前。因此，在构造函数体内对成员变量进行的是赋值操作，其先调用默认构造函数对成员函数进行初始化，然后对它们赋予新值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;较优的办法是使用&lt;strong&gt;初始化列表&lt;/strong&gt;来对成员变量进行初始化，从而不再调用默认构造函数，直接进行赋值操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++有着固定的初始化顺序，基类先于派生类被初始化，成员变量是按照其声明的顺序进行初始化的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的初始化：构造函数与初始化列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用和常量的初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化顺序：继承关系中，先父类后子类；同一个类中，只与成员变量的声明顺序有关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非局部静态对象的初始化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-non-local-static-对象的初始化&#34;&gt;4.3 non-local static 对象的初始化&lt;/h3&gt;
&lt;p&gt;在不同的源码文件中，分别包含了至少一个 non-local static 对象，当这些对象发生互动时，他们的初始化顺序是不确定的，直接使用这些对象会给程序的运行带来风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：non-local static 对象&lt;/strong&gt;
所谓的 static 对象，其生命周期从被构造出来到程序结束，包括全局对象、定义在 namespace 作用域内的对象、在类或者函数内被声明为 static 的对象。其中，在函数内的 static 对象称为 local static 对象，其他的 static 对象我们就称为 nono-local static 对象。
静态对象不是基于堆或者栈的，初始化的静态对象在内存的 Data 段，未初始化的位于 BSS 段。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* demo1.cpp */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FileSyste&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numDisks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FileSystem&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 在全局范围声明一个对象fs，供其他单元调用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* demo2.cpp */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Directory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Directory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;disks&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numDisks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 调用了fs对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上述代码中，如果我们要创建一个&lt;code&gt;Directory&lt;/code&gt;对象，构造函数就会调用&lt;code&gt;fs&lt;/code&gt;对象。但是两个对象是在不同的源文件不同的时间建立起来的，无法保证 fs 已经被初始化。解决办法就是：&lt;strong&gt;将 non-local static 对象转换成 local static 对象&lt;/strong&gt;，即将每一个 non-local static 对象放到一个函数里面去，这是单例模式的常用的手法。其依据是：在 C++中，函数的 local static 对象会在该函数第一次被调用时进行初始化，因此我们只需要让函数返回一个指向 local static 对象的指针或引用，就可以得到一个在使用时保证被初始化的对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* demo1.cpp */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FileSyste&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numDisks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;FileSystem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FileSystem&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 声明了一个局部静态变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* demo2.cpp */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Directory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Directory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;disks&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numDisks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 调用了fs对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Directory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Directory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于内置的数据类型，要进行手动初始化；&lt;/li&gt;
&lt;li&gt;构造函数对类进行初始化最好使用&lt;em&gt;初始化列表&lt;/em&gt; 来替换&lt;em&gt;在构造函数中使用赋值操作&lt;/em&gt; 。构造函数按照变量声明的顺序进行初始化；&lt;/li&gt;
&lt;li&gt;对于静态对象，用局部静态对象来替换全局静态对象来保证使用前确定被初始化。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>02.constructors-destructors-and-assignment-operators</title>
      <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/02.constructors-destructors-and-assignment-operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/02.constructors-destructors-and-assignment-operators/</guid>
      <description>&lt;p&gt;本文对应原书第二部分，主要记录 C++类中使用构造函数、析构函数以及赋值运算需要注意的事项。&lt;/p&gt;
&lt;h2 id=&#34;item5-了解-c-类中自动生成和调用的函数&#34;&gt;item5 了解 C++ 类中自动生成和调用的函数&lt;/h2&gt;
&lt;p&gt;编译器会默认为类创建默认构造函数，拷贝构造函数，赋值操作符，以及析构函数，但是这些函数只要在调用时才会生成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 假设调用了以下功能，此类等价于
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Empty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;Empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;                              &lt;span class=&#34;c1&#34;&gt;// 默认构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;                             &lt;span class=&#34;c1&#34;&gt;// 析构函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;Empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Empty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){}&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 拷贝构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;Empty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Empty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 赋值运算符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Notes:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认生成的析构函数是 non-virtual，除非这个类的基类声明有 virtual 析构函数&lt;/li&gt;
&lt;li&gt;自动生成的拷贝构造函数和赋值操作符只是单纯的将源对象的所有非静态成员变量拷贝到目标对象，因此当对象中包含&lt;em&gt;引用成员&lt;/em&gt; 和&lt;em&gt;const 成员&lt;/em&gt; 时，由于 C++中不允许引用被初始化后指向另一个对象，所以 C++编译器会拒绝为其赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 定义一个模板类
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NameObject&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;NameObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nameValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;objectValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 对类进行以下操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Persephone&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Satch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;NameObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Dog1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Dog1.nameValue指向了str1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;NameObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Dog2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Dog2.nameValue指向了str2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Dog2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Dog1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 会发生Dog2.nameValue=Dog1.nameValue，C++中引用被初始化后不允许指向另一个对象，编译器无法通过
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有进行声明，C++编译器会自动为类创建&lt;em&gt;默认构造函数&lt;/em&gt;、&lt;em&gt;拷贝构造函数&lt;/em&gt;、&lt;em&gt;赋值运算符&lt;/em&gt;，以及&lt;em&gt;析构函数&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item6-若不想使用编译器自动生成的函数要显式拒绝&#34;&gt;item6 若不想使用编译器自动生成的函数，要显式拒绝&lt;/h2&gt;
&lt;p&gt;在有些特定功能的类中，我们希望其不支持拷贝和赋值功能，比如 RAII 范式编程中。但是，即使不声明拷贝构造函数和赋值运算符，当调用它们时，编译器还是会自动声明。&lt;strong&gt;为了屏蔽编译器自动提供的函数，可以将相应的成员函数声明为 private 并且不予实现&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有编译器自动提供的函数都是 public 的&lt;/li&gt;
&lt;li&gt;将编译器默认生成的函数进行显式声明为 private，可以避免其被外部函数调用&lt;/li&gt;
&lt;li&gt;对声明的函数不进行定义，可以避免其被类的成员函数或友元函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当不想让编译器为类自动生成某些函数时，可将相应的成员函数声明为 private 并且不予实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item7-为多态基类声明-virtual-析构函数&#34;&gt;item7 为多态基类声明 virtual 析构函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;析构函数&lt;/strong&gt;：析构函数是用来释放对象资源的。当对象的声明周期结束或者对象资源通过 delete 被显式释放时，对象的析构函数被显式调用，从而释放对象占用的资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多态&lt;/strong&gt;：多态是 C++面向对象编程的思想之一。在编程中一个显著的特征就是&lt;em&gt;通过基类指针指向子类对象，实现对子类对象的操作&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++明确指出，当派生类对象通过一个基类指针被删除，而这个基类的析构函数不是虚函数，其结果没有定义，在实际的执行中表现为只调用了基类的析构函数，派生类的资源没有被释放。
当基类析构函数被声明为虚函数，派生类的析构函数也默认为是虚函数。当派生类对象被销毁时，基类会找到派生类的虚函数表，调用派生类的析构函数，接着调用基类的析构函数，实现资源的完全释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来实现多态的基类应该将其析构函数声明为虚函数。如果一个类中包含有虚函数，那它就是被用来实现多态的，就需要一个虚的析构函数。&lt;/li&gt;
&lt;li&gt;如果类的设计目的不是作为基类或者不是用来实现多态的基类，就不需要将析构函数声明为虚函数。这是因为当一个类中包含虚函数的时候，编译器会为对象生成一个虚表指针，类也会多一个虚函数表，会增加内存资源的消耗。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item8-不要让析构函数抛出异常&#34;&gt;item8 不要让析构函数抛出异常&lt;/h2&gt;
&lt;p&gt;析构函数被调用的情况有两种：1、对象正常结束生命周期时调用；2、在异常发生时，编译器释放对象资源时调用。在第一种情况下，析构函数抛出异常不会出现无法预料的结果，可以正常捕获。但是在后一种情况下，如果对象发生异常，异常模块为了维护系统对象数据的一致性，会去调用对象的析构函数释放资源，析构函数如果抛出异常，异常处理机制无法捕获，只能调用&lt;code&gt;terminate()&lt;/code&gt;函数，系统会崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从语法上讲，析构函数抛出异常是可以的，但是 C++中并不推荐这一做法。&lt;/li&gt;
&lt;li&gt;如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕获该异常，然后吞下它们或者不传播。&lt;/li&gt;
&lt;li&gt;如果需要对某个函数运行期间抛出的异常进行处理，那么类应该提供一个普通函数而不是利用析构函数来进行该操作。主要针对的是资源释放过程中可能出现的异常，如数据库断开连接或者文件句柄的释放等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item9-不要在构造和析构函数中调用-virtual-函数&#34;&gt;item9 不要在构造和析构函数中调用 virtual 函数&lt;/h2&gt;
&lt;p&gt;构造函数的工作是进行初始化，派生类对象构造期间首先会调用基类的构造函数，对象的类型也变成了基类的类型。如果基类的构造函数中调用了虚函数，虚函数不会绑定到子类的版本，这样 virtual 函数没有任何意义。析构函数书中也是同样的道理。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Transaction
    {
        public:
            Transaction(){init();}                       // 默认构造函数
            ~Transaction(){}                             // 析构函数

            virtual void log() const = 0;
        private:
            void init(){
                log(); // 这种情况更加危险，因为其更难发现
            }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要在构造和析构函数中调用 virtual 函数，因为基类中调用的虚函数调用的是其自己的而不属于派生类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item10-自定义赋值操作符operator-要返回this-的引用&#34;&gt;item10 自定义赋值操作符(operator=) 要返回*this 的引用&lt;/h2&gt;
&lt;p&gt;C++的赋值操作符可以进行链式赋值，为了实现链式赋值，赋值操作符必须返回一个指向当前对象的引用，这是 C++中自定义赋值操作符应该遵循的规则。这个规则对于&lt;code&gt;+=&lt;/code&gt;、&lt;code&gt;-=&lt;/code&gt;、&lt;code&gt;*=&lt;/code&gt;等赋值相关的操作符同样适用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
    int x,y,z;
    x=y=z=5;  // 链式赋值，等效于x=(y=(z=5))

    class Widget{
    public:
        ...
        Widget&amp;amp; operator=(const Widget&amp;amp; rhs){          //要返回一个当前类的引用
            ...
            return *this;                              //返回给左边的变量
        }
        ...
    };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this 是用来指向当前对象的对象，只存在类的成员函数里。&lt;/li&gt;
&lt;li&gt;自定义赋值操作符要返回一个指向当前对象的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item11-注意-operator-的自我赋值&#34;&gt;item11 注意 operator= 的“自我赋值”&lt;/h2&gt;
&lt;p&gt;虽然在代码中我们不会有意去进行自我赋值，但是一些代码还是存在潜在自我赋值的可能性，如&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    a[i] = a[j]; // 当i=j时就是自我赋值
    *px = *py;   // 如果px和py恰好指向的是同一个对象，这也是自我赋值

    class Base{...};
    class Derived:public Base{...};
    void doSomething(const Base&amp;amp; rb,Derived* pd); // rb和pd有可能指向同一个对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们在类中对资源进行管理要特别关注可能发生的拷贝现象。当我们要手动管理资源时，赋值操作符就就可能是不安全的。在下面的代码中，如果发生了自我赋值，delete 语句不仅会释放*this 自身的资源，rhs 的资源也会被释放，最后返回的是一个损坏的数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Bitmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 删除当前版本
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bitmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;Bitmap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了避免自我赋值出现的错误，可以采用参数自身验证、重新排列语句等方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;解决方法 1：参数自身验证&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
    {
        if(this==&amp;amp;rhs)
            return *this;

        delete pb;  // 删除当前版本
        pb = new Bitmap(*rhs.bp); // 风险是：当该语句抛出异常，返回的仍然是损坏数据
        return *this;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;解决方法 2：重新排列语句&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
    {
        Bitmap* pOrigin = pb;     // 备份原来的pb
        pb = new Bitmap(*rhs.bp); // 赋值rhs的pb
        delete pb;  // 删除备份
        return *this;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中因为对数据进行了备份，复制，删除等操作，如果该赋值操作符频繁使用，其效率是比较低的。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;解决方法 3：先复制后交换(copy and swap)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Class Widget{
        ...
        public:
            void swap(Widget&amp;amp; rhs); // 交换rhs和*this的数据

            Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
            {
                Widget temp(rhs);   // 为rhs数据创建备份
                swap(temp);         // 将*this数据和rhs交换
                return *this;
            }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;解决方法 4：用传值替换传引用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Widget&amp;amp; Widget::operator=(Widget rhs)
    {
        swap(rhs);
        return *this;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中利用了 C++传值会自动生成一份本地拷贝的特性，有效减少了代码长度，也增加了效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用赋值操作符要充分保证自我赋值发生时程序的安全性。&lt;/li&gt;
&lt;li&gt;任何函数中操作了一个以上对象时，要保证即使多个对象是同一个对象时，其行为仍然是正确的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item12-对象进行复制时需要完整拷贝&#34;&gt;item12 对象进行复制时需要完整拷贝&lt;/h2&gt;
&lt;p&gt;设计良好的面向对象系统会将对象的内部封装起来，只保留拷贝构造函数和赋值操作符来负责对象的拷贝。当我们自己定义赋值运算符和拷贝构造函数函数时，特别注意：1、复制类中所有的局部变量；2、派生类中要调用基类中相应的函数或操作符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制函数要确保复制对象内所有的成员变量以及所有基类成员变量。&lt;/li&gt;
&lt;li&gt;拷贝构造函数和赋值操作符有相近的代码，两者之间不能互相调用，可以建立一个新的成员函数给两者调用。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>03.resource-management</title>
      <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/03.resource-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/03.resource-management/</guid>
      <description>&lt;p&gt;本文对应原书第三部分，主要记录 C++中资源管理需要注意的事项，包括用对象管理资源、对象的复制行为、资源的释放以及智能指针等。&lt;/p&gt;
&lt;h2 id=&#34;item13-使用对象来管理资源&#34;&gt;item13 使用对象来管理资源&lt;/h2&gt;
&lt;p&gt;我们使用系统资源必须遵循&lt;code&gt;申请资源&lt;/code&gt;-&amp;gt;&lt;code&gt;使用资源&lt;/code&gt;-&amp;gt;&lt;code&gt;释放资源&lt;/code&gt;这样一个完成的步骤，如果资源使用后没有释放就会造成资源泄漏。在编程中我们通过手动管理资源往往会存在着因为异常或者逻辑不合理跳过了资源释放，或者忘记释放资源等问题。为了避免以上情况出现，我们可以利用 C++的对象析构函数自动调用机制，把资源封装在对象里面，当对象的生命周期结束，资源会保证被释放，也就是 RAII 规范。其基本思想就是&lt;strong&gt;在构造函数中申请资源，在析构函数中释放资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为防止资源泄漏，使用 RAII 机制来进行资源管理，通过构造函数获取资源，利用析构函数确保资源被释放。&lt;/li&gt;
&lt;li&gt;C++中常用的 RAII 实例就是智能指针。&lt;code&gt;shared_ptr&lt;/code&gt;使用引用计数来管理资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item14-注意资源管理类的拷贝行为&#34;&gt;item14 注意资源管理类的拷贝行为&lt;/h2&gt;
&lt;p&gt;现在假设我们用 RAII 规范来管理一个互斥锁，保证该互斥锁最后能被解除。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Lock
    {
        public:
            explicit Lock(Mutex* pm):mutexPtr(pm)
            {lock(mutexPtr);}
            ~Lock(){unlock(mutexPtr);}
        private:
            Mutex* mutexPtr;
    }

    /* 接下来我们使用这个类*/
    Mutex m;
    Lock lock1(&amp;amp;m);    // 锁定m
    Lock lock2(lock1); // 将lock1复制到lock2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，发生了资源的复制。在用 RAII 规范来管理资源类的时候，特别要注意这个类的拷贝行为。对于资源管理类的拷贝，通常可以采取以下几种措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;禁止拷贝&lt;/strong&gt;
对于有些资源来说，比如上面提到的互斥锁，它的拷贝是没有意义，我们可以通过将其拷贝构造函数和赋值运算符显式声明为 private 来禁止外部使用其拷贝功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Lock
    {
        public:
            explicit Lock(Mutex* pm):mutexPtr(pm)
            {lock(mutexPtr);}
            ~Lock(){unlock(mutexPtr);}
        private:
            /* 私有化其拷贝函数 */
            Lock(const Lock&amp;amp; lock);
            Lock&amp;amp; operator=(const Lock&amp;amp; lock);
            Mutex* mutexPtr;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;使用引用计数&lt;/strong&gt;
有时我们希望保有资源，直到最后一个使用者被销毁。这种情况下复制 RAII 对象时，应该将该资源的引用计数递增。&lt;code&gt;shared_ptr&lt;/code&gt;就是使用的这种机制，&lt;code&gt;shared_ptr&lt;/code&gt;提供了一个特殊的可定义函数——删除器(deleter)，即在其引用计数为零时调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Lock
    {
        public:
            explicit Lock(Mutex* pm):mutexPtr(pm，unlock) // 将unlock函数绑定到删除器
            {lock(mutexPtr.get());}   // 锁定原始指针
            // 这里不再需要定义析构函数来释放资源 ~Lock(){unlock(mutexPtr);}
        private:
            std::shared_ptr&amp;lt;Mutex&amp;gt; mutexPtr; // 使用shared_ptr，不再使用原始指针
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;深度拷贝&lt;/strong&gt;
当我们需要的不仅仅是资源的所有权，而是要获取资源的副本的时候，我们就需要拷贝底层资源，即不仅仅是指向资源的指针，在内存上的资源也要进行复制，也就是“深拷贝”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;所有权转移&lt;/strong&gt;
当我们只想要一个 RAII 对象来持有这个资源，在进行拷贝的时候就要进行所有权的转移，即释放原对象对资源的权限，将所有权转移到新的对象上，这也是&lt;code&gt;auto_ptr&lt;/code&gt;的工作原理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAII 对象的拷贝要根据其管理的资源具体考虑，资源的拷贝行为决定 RAII 对象的拷贝行为。&lt;/li&gt;
&lt;li&gt;常用的 RAII 对象的拷贝行为有：禁止拷贝、使用引用计数、深度拷贝、所有权转移。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item15-在资源管理类中提供对原始资源的访问&#34;&gt;item15 在资源管理类中提供对原始资源的访问&lt;/h2&gt;
&lt;p&gt;资源管理类通过对原始资源的封装可以有效避免资源泄漏，但是在很多情况下外部的 API 需要直接访问原始资源，因此我们需要在资源管理类中提供对原始资源的访问。提供访问的方式有两种：&lt;em&gt;显式访问&lt;/em&gt; 和&lt;em&gt;隐式访问&lt;/em&gt;。其中，显示访问比较安全，隐式访问便于使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显式访问：在 RAII 类中声明一个显式的转换函数，返回原始资源类型的对象&lt;/li&gt;
&lt;li&gt;隐式访问：利用 operator 操作符声明一个隐式转换函数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;智能指针获取原始指针&lt;/strong&gt;
智能指针都有一个成员函数&lt;code&gt;get()&lt;/code&gt;，来执行显式转换，返回智能指针对象包含的原始指针：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    mutexPtr.get(); // 获取指向互斥锁的原始指针
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;智能指针重载了指针解引操作符(operator-&amp;gt;和 operator*)，它们允许隐式的将智能指针转换成底部的原始指针。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Investment
    {
        public:
            bool isTaxFree() const;
    }

    Investment* pInv;
    std::shared_ptr&amp;lt;Investment&amp;gt; ptr1(pInv); // 使用shared_ptr管理资源
    bool tax1 = ptr1-&amp;gt;isTaxFree(); // 使用operator-&amp;gt;访问原始资源
    std::auto_ptr&amp;lt;Investment&amp;gt; ptr2(pInv); // 使用auto_ptr管理资源
    bool tax1 = (*ptr2).isTaxFree(); // 使用operator*访问原始资源
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;自定义 RAII 类获取原始资源&lt;/strong&gt;
同智能指针类似，在自定义的 RAII 类中可以通过定义一个&lt;code&gt;get()&lt;/code&gt;函数来显式的返回原始资源，也可以通过 operator 操作符声明一个隐式转换函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 往往需要访问原始资源，因此 RAII 类应该提供一个访问原始资源的方法。&lt;/li&gt;
&lt;li&gt;对原始资源的访问有显式和隐式两种。一般而言，显式比较安全，隐式便于使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item16-使用-newdelete-形式要对应&#34;&gt;item16 使用 new/delete 形式要对应&lt;/h2&gt;
&lt;p&gt;为了保证内存的释放，我们经常会特别注意 new/delete 成对的出现。对于下面的代码，使用了 new 也有对应的 delete，但还是有错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    std::string* strArray = new std::string[100];
    ...
    delete strArray;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当使用 new 来创建一个对象时，发生了两件事：第一，通过 operator new 操作符分配内存；第二，针对此内存，有一个或多个构造函数被调用。同理，使用 delete 时也有两件事发生：针对此内存有一个或多个析构函数被调用，然后通过 operator delete 释放内存。delete 最大的问题在于&lt;strong&gt;即将被删除的内存中到底有多少个对象&lt;/strong&gt;？这个答案决定了有多少个析构函数被调用。
确定 delete 要删除多少个对象，就需要明确告诉 delete 被删除的指针指向的是单一对象还是一个数组。这是因为单一对象的内存布局不同于数组的内存布局。数组对象中包含了一个表明数组大小的记录，以便 delete 知道需要调用多少次析构函数。单一对象的内存中没有这个记录。
让 delete 知道内存中是否存在一个数组大小记录的方法，就是显式的声明，如果使用 delete 时加上&lt;code&gt;[]&lt;/code&gt;，delete 便认定指向的是一个数组，否则便认定指向的是一个单一对象。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    std::string* strPtr1 = new std::string;
    std::string* strPtr2 = new std::string[100];
    ...
    delete strPtr1;  // 使用delete删除单个对象
    delete[] strPtr2;// 使用delete[]删除数组
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要针对单个对象，应该使用 new 对应 delete，对于对象数组，new[] 要对应 delete[]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item17-用单独的语句来创建智能指针&#34;&gt;item17 用单独的语句来创建智能指针&lt;/h2&gt;
&lt;p&gt;假设有如下函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    int priority(); // 返回程序的优先级
    void processWidget(std::shared_ptr&amp;lt;Widget&amp;gt; pw, int priority);

    /* 通过以下语句来调用processWidget */
    processWidget(std::shared_ptr&amp;lt;Widget&amp;gt;(new Widget),priority());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述调用 processWidget 的代码中使用了智能指针来管理资源，但是仍然存在资源泄漏的可能。
在调用 processWidget 函数之前，编译器需要完成三件事：调用&lt;code&gt;priority()&lt;/code&gt;函数；执行&lt;code&gt;new Widget&lt;/code&gt;；调用&lt;code&gt;shared_ptr构造函数&lt;/code&gt;。其中，&lt;code&gt;new Widget&lt;/code&gt;的执行在调用&lt;code&gt;shared_ptr构造函数&lt;/code&gt;之前，但是调用&lt;code&gt;priority()&lt;/code&gt;函数的次序是不一定的。这是因为在 C++中，为了保证代码效率，不是以固定的顺序来解析函数参数的。假设编译器生成的代码执行顺序是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、执行&lt;code&gt;new Widget&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;2、调用&lt;code&gt;priority()&lt;/code&gt;函数；&lt;/li&gt;
&lt;li&gt;3、调用&lt;code&gt;shared_ptr构造函数&lt;/code&gt;。
如果调用&lt;code&gt;priority()&lt;/code&gt;函数的过程中抛出异常，&lt;code&gt;new Widget&lt;/code&gt;返回的指针就会遗失，因为它还没有被放入智能指针中，从而造成资源泄漏。
为了避免上述问题，需要用单独的语句来创建智能指针，从而保证两个动作不会被隔离，即将 new 的对象立即放入智能指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    std::shared_ptr&amp;lt;Widget&amp;gt; pw(new Widget);
    processWidget(pw,priority());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用单独的语句创建智能指针，否则可能导致难以察觉的资源泄漏问题。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>04.designs-and-declarations</title>
      <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/04.designs-and-declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/04.designs-and-declarations/</guid>
      <description>&lt;p&gt;本文对应原书的第四部分，主要介绍为了设计和声明良好的 C++接口需要注意的事项。&lt;/p&gt;
&lt;h2 id=&#34;item18-让接口不容易被误用&#34;&gt;item18 让接口不容易被误用&lt;/h2&gt;
&lt;p&gt;所谓的接口就是提供给用户使用代码的途径。C++有大量关于接口的概念，如函数接口，类接口，模板接口等。理想情况下，如果用户用错了接口，这个代码不应该通过编译。如果代码通过了编译，就应该得到想要的结果。
让接口不易被误用的办法包括：建立新类型、限制类型上的操作，保证接口设计的一致性，消除用户的资源管理责任。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;建立新的数据类型、限制类型上的操作&lt;/strong&gt;
接口要设计的不易被误用，就要充分考虑用户可能犯的错误。假如设计一个表示日期的类：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Date
    {
        public:
            Date(int month, int day, int year); // 美式日期标准
    }

    Date d1(30,3,1995); // 错误，输入的是英式日期标准
    Date d2(3,40,1995); // 数字输入错误
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像上述这样的错误，可以通过引入新的数据类型来进行预防。通过使用简单的包装类(wrapper class)，让编译器来检测错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    struct Day{
        explicit Day(int d):val(d){}
        int val;
    };
    struct Month{
        explicit Month(int m):val(m){}
        int val;
    };
    struct Year{
        explicit Year(int y):val(y){}
        int val;
    };
    class Date
    {
        public:
            Date(const Month&amp;amp; m, const Day&amp;amp; d, const Year&amp;amp; y); // 美式日期标准
    }

    Date d1(3,30,1995); // 数据类型错误
    Date d2(Day(30), Month(3), Year(1995)); // 格式错误
    Date d3(Month(3), Day(30), Year(1995)); //正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将 Day，Month，Year 设计成成熟的类比使用上述的结构体要好。上述代码保证了数据类型的准确性，限制其值的范围也是必要的，例如一年只有 12 个月，Month 应该反映出这个事实。可以通过 enum 满足功能上的要求，但是 enum 不是类型安全的(type safe)，item2 中展示过 enum 可以被用来当作 int 类型使用。比较安全的做法是预先定义所有有效的 Month。下面的代码虽然繁琐，但是保证了数据的准确性。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Month{
  public:
    static Month Jan(){return Month(1);}  //用函数替换对象，避免初始化出现问题(item4)
    static Month Feb(){return Month(2);}
    ...
    static Month Dec(){return Month(12);}
  private:
    explicit Month(int m);  //explicit禁止参数隐式转换，private禁止用户生成自定义的月份
    ...
};

Date d(Month::Mar(), Day(30), Year(1995)); //正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;预防错误的另一个办法是，限制类型内什么操作允许，什么操作不允许，常见的限制是加上&lt;code&gt;const&lt;/code&gt;。item3 中展示了用&lt;code&gt;const&lt;/code&gt;修饰 operator*返回值来避免无意义的赋值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    if(a * b = c)... // 应该是a * b == c
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;保证接口设计的一致性&lt;/strong&gt;
STL 容器的接口设计保证了高度的一致性，例如每个 STL 容器都是通过&lt;code&gt;size()&lt;/code&gt;成员函数返回容器中对象的个数。而在 Java 中，数组使用&lt;code&gt;length&lt;/code&gt;属性，List 使用&lt;code&gt;size()&lt;/code&gt;成员函数。这样的不一致性会给开发人员带来不便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免要求用户必须进行某些操作&lt;/strong&gt;
任何要求用户记得做某些事情的接口都容易造成误用，因为用户很可能忘记完成。例如动态分配了一个资源，要求用户以特定的方式释放资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Investment* createInvestment();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于上述接口，要求用户在资源使用完后进行释放，但是用户可能产生两种错误：忘记释放资源；多次释放资源。解决方法是用智能指针来进行管理资源，为了避免用户忘记把函数的返回值封装到智能指针内，我们最好让这个函数直接返回一个智能指针对象：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    std::shared_ptr&amp;lt;Investment&amp;gt; createInvestment();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际上，返回一个智能指针还解决了一些列用户资源泄漏的问题，如 item14 中讲到的，&lt;code&gt;shared_ptr&lt;/code&gt;允许在建立智能指针时为它指定一个资源释放函数(即所谓的删除器，deleter)。
假如在我们设计的接口中，通过&lt;code&gt;createInvestment()&lt;/code&gt;得到一个 Investment*对象，这个对象必须通过&lt;code&gt;getRidOfInvestment()&lt;/code&gt;来进行资源释放。我们必须把&lt;code&gt;getRidOfInvestment()&lt;/code&gt;绑定到 shared_ptr 的删除器，这样 shared_ptr 在使用完成后会自动调用指定的资源释放函数，避免使用错误的释放机制。
shared_ptr 还有一个好处是，它会自动使用它的每个指针专属的删除器，从而能够避免所谓的 DLL 交叉问题(cross-DLL problem)。这个问题发生于当对象在一个 DLL 中被创建，在另外一个 DLL 中被释放时，在许多平台上会导致运行时问题，因为不同的 DLL 可能会被链接到不同的代码。shared_ptr 会在构造时就确定当引用计数为零时调用哪个 DLL 的删除器，因此不必担心 DLL 交叉问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个良好的接口应该保证其不容易被误用。我们在设计接口时要努力实现这个目标。&lt;/li&gt;
&lt;li&gt;保证正确使用的方法包括保证接口的一致性，以及自定义类型的行为与内置类型的行为保持一致。&lt;/li&gt;
&lt;li&gt;避免无用的方法包括定义新的包装类型、限制类型的操作、限制取值范围、避免让用户负责管理资源等。&lt;/li&gt;
&lt;li&gt;shared_ptr 支持绑定自定义的删除器，实现想要的析构机制，可以有效防范 DLL 交叉问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item19-把类当作类型来设计&#34;&gt;item19 把类当作类型来设计&lt;/h2&gt;
&lt;p&gt;在面向对象编程的语言中，当定义一个新 class 的时候，也就是定义了一个新的 type。这就意味着重载函数和操作符、控制内存的分配和释放、定义对象的初始化和析构等等，全部都要加以考虑。因此，应该带着像语言设计者设计原始类型一样谨慎。
设计一个良好的 class 是一项艰巨的工作，好的 type 有自然的语法、直观的语义以及高效的实现。在 C++中，设计一个良好的类应该时刻考虑到以下的规范：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新类型的对象如何被创建和销毁？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这影响了类的构造函数和析构函数，以及内存分配函数和释放函数(operator new, operator new[], operator delete, operator delete[])的设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对象的初始化和对象的赋值应该有什么区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这决定了构造函数和赋值操作符的行为，以及其间的差异。初始化用于未创建的对象，赋值适用于已创建的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新类型的对象如果作为值进行传递有什么意义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拷贝构造函数决定了一个 type 的值传递如何实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新类型的合法值有什么限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常情况下，并不是所有的成员变量是有效的。为了避免函数抛出异常，我们要在成员函数中堆变量进行错误检查工作，尤其是构造函数、赋值操作符和所谓的 setter 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新的类型是否存在继承关系&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果新的类型继承自已有的类型，类型的设计就会受到被继承类的约束，比如说函数是否为虚函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新类型允许进行什么样的转换&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新类型的对象可能被隐式地转换成其他类型，需要决定是否允许类型的转换。如果希望把 T1 隐式转换成 T2，可以在 class T1 中定义一个类型转换函数(operator T2)，或者在 class T2 内写一个可被单一实参调用(non-explicit-one-argument)的构造函数。如果进行显式转换，需要定义个显式转换的函数(item15)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;哪些运算符和函数对于新类型是合理的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这决定了新类型中需要声明哪些函数，包括成员函数，非成员函数，友元函数等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;哪些标准函数是需要被禁止的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将不希望编译器自动生成的标准函数声明为 private(item6)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;谁可以访问新类型中的成员&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这决定了成员函数的访问级别是 public，protected 或 private。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新类型中的“隐藏接口”是什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新类型对于性能、异常安全性、资源管理有什么保障，需要在代码中加上相应的约束条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新类型的通用性如何&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要新类型适用于多种类型，应该定义一个类模板(class template)，而不是单个 class。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否真的需要一个新类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只是定义新的派生类以便为既有类增加功能，定义一些非成员函数或者函数模板更加划算。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计 class 就是设计 type，在定义一个新的 type 前，要充分考虑到上述问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item20-用常量引用传递代替值传递&#34;&gt;item20 用常量引用传递代替值传递&lt;/h2&gt;
&lt;p&gt;默认情况下，C++以值传递的方式传递对象给函数的。编译器会调用对象的拷贝构造函数创建实参的副本，再把副本传递到函数中，而拷贝是一个耗时的操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Person
    {
        public:
            Person();
            virtual ~Person();
            ...
        private:
            std::string name;
            std::string address;
    }
    class Student:public Person
    {
        public:
            Student();
            ~Student();
            ...
        private:
            std::string schoolName;
            std::string schoolAddress;
    }

    bool validateStudent(Student s);
    // 以值传递的方式调用函数
    Student stu;
    bool isOK=validateStudent(stu); // 调用函数，以值传递的方式传递参数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当上述函数被调用时，发生了以下过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Student 类的拷贝函数被调用，用来初始化参数 s&lt;/li&gt;
&lt;li&gt;当 validateStudent 函数返回时，s 被销毁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，当函数 validateStudent 被调用时，参数的传递成本是&lt;strong&gt;调用了一次 Student 的拷贝构造函数，调用了一次 Student 的析构函数&lt;/strong&gt;。Student 中还有两个 string 对象，所以每次构造 Student 对象也会构造两个 string 对象。Student 又继承自 Person 类，Person 类中也包含两个 string 对象。这就意味着，Student 对象的值传递会调用一次 Student 拷贝构造函数、一次 Person 拷贝构造函数、四次 string 拷贝构造函数，析构过程也有同样的过程。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    bool validateStudent(const Student&amp;amp; s);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;传递常量引用的效率要高得多，没有任何构造函数或析构函数被调用，因为没有任何对象被调用。参数声明中&lt;code&gt;const&lt;/code&gt;是十分重要的，这样可以避免传入的参数在函数内被修改。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以传引用的方式传递参数可以避免对象切割(slicing)问题。当函数的参数类型是基类，通过值传递传入派生类对象时，调用的是基类的拷贝构造函数，派生类中派生的特性就会被切割，留下的是基类对象。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Window
    {
    public:
        ...
        std::string name() const;
        virtual void display() const;
    }

    class WindowWithScrollBars:public Window
    {
    public:
        ...
        virtual void display() const;
    }

    void printNameAndDisplay(Window w) // 值传递，会产生对象切割
    {
        std::cout&amp;lt;&amp;lt;w.name();
        w.display();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;display()&lt;/code&gt;是虚函数，在两个类中有不同的实现。如果使用值传递就会导致对象被切割，函数内调用的永远是基类 Window 中的版本。解决对象切个问题的方法就是传递常量引用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    void printNameAndDisplay(const Window&amp;amp; w)
    {
        std::cout&amp;lt;&amp;lt;w.name();
        w.display();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;在 C++中，引用往往是通过指针来实现的，引用传递本质上就是指针传递。因此，对于内置的类型，值传递比引用传递的效率要高。此外，STL 迭代器和函数对象都被设计为值传递。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量用常量引用传递替换值传递，前者通常比较高效，并可以避免对象切割问题。&lt;/li&gt;
&lt;li&gt;对于内置类型，STL 迭代器和函数对象，值传递更加高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item21-不要在需要返回对象时返回引用&#34;&gt;item21 不要在需要返回对象时返回引用&lt;/h2&gt;
&lt;p&gt;在 item20 中我们见证到了引用传递的高效性，但这并不意味着引用传递是没有风险的。引用是已经存在的变量的别称，引用存在的风险就是&lt;strong&gt;指向一个并不存在的对象&lt;/strong&gt;。这个错误很容易出现在函数的返回值是一个引用的情况下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Rational
    {
    public:
        Rational(int numerator=0,int denominator=1);
        ...
    private:
        int n,d;
        friend const Rational operator*(const Rational&amp;amp; lhs,const Rational&amp;amp; rhs);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，operator&lt;em&gt;返回的是值，该值是在函数调用时生成的拷贝副本。如果返回的是一个引用，，那它必然指向一个 Rational 对象，该对象包含两个 Rational 的乘积。operator&lt;/em&gt;返回的 Rational 对象必须通过函数自己创建，函数创建新对象的途径有两个：&lt;strong&gt;在栈上创建&lt;/strong&gt;以及&lt;strong&gt;在堆上创建&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 在栈上创建
    const Rational&amp;amp; operator*(const Rational&amp;amp; lhs,const Rational&amp;amp; rhs)
    {
        Rational result(lhs.n*rhs.n,lhs.d*rhs.d); // 在栈上创建对象
        return result; // result的生命周期结束，被析构
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，operator*返回的是指向 result 的引用，但是 result 是一个局部变量，当函数返回时自动销毁，那么引用指向的就是一个错误的对象。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    const Rational&amp;amp; operator*(const Rational&amp;amp; lhs,const Rational&amp;amp; rhs)
    {
        Rational* result = new Rational(lhs.n*rhs.n,lhs.d*rhs.d); // 在堆上创建对象
        return *result;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码在堆上创建 Rational 对象，对象资源在函数内没有被释放，可以被访问。但是这就要求用户要进行资源释放，否则就有资源泄漏的风向，这违背了 item18 中设计良好接口的原则。
无论时在堆上还是在栈上创建对象，每次访问这个函数都会调用一次构造函数，我们的目的时节省这次调用。下面代码通过引入静态变量来解决这个问题，但是静态对象可能会带来多线程安全问题。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    const Rational&amp;amp; operator*(const Rational&amp;amp; lhs,const Rational&amp;amp; rhs)
    {
        static Rational result; // 创建静态对象
        ...
        return result;
    }

    // 调用
    Rational a,b,c,d;
    if((a*b)==(c*d)) // 等价于operator==(operator*(a,b),operator*(c,d))
    {
        ... // 分支语句1
    }
    else
    {
        ... // 分支语句2
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，无论 a,b,c,d 取什么值，if 的条件语句每次结果都为 true。当 operator==被执行，会产生两次 operator*的调用，他们返回的是指向同一个对象的引用，因此一定会相等。&lt;/p&gt;
&lt;p&gt;上面所举的反例，是为了说明当一个函数必须要返回一个新的对象时，为了代码安全我们应该接受值传递带来的构造和析构成本。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    const Rational operator*(const Rational&amp;amp; lhs,const Rational&amp;amp; rhs)
    {
        return Rational(lhs.n*rhs.n,lhs.d*rhs.d);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要让函数返回一个指向局部变量的指针或引用，否则会造成资源泄漏和程序崩溃。&lt;/li&gt;
&lt;li&gt;不要让函数返回一个指向局部静态对象(程序中可能需要多个这样的对象)的指针或引用。&lt;/li&gt;
&lt;li&gt;在面临返回引用还是返回值的选择时，优先保证程序能正常运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item22-类的数据成员声明为-private&#34;&gt;item22 类的数据成员声明为 private&lt;/h2&gt;
&lt;p&gt;本 item 主要通过分析为什么数据成员不能是 public，其观点同样适用于 protected，最后得出一个结论：成员变量应该是 private。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;保证语法的一致性&lt;/strong&gt;
在 item18 中强调良好的接口应该保证其设计的一致性。如果成员变量不是 public，那么能够访问成员变量的唯一方法就是通过成员函数。如果 public 接口内的都是函数，用户就不需要在访问成员时在意是否该使用小括号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;精确控制对成员变量的处理&lt;/strong&gt;
如果成员变量是 public，任何人都可以进行读写。如果将其私有化，通过函数获取或者设定其值，可以实现“不准访问”、“只读”、“只写”以及“读写”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class AccessLevels
    {
    public:
        ...
        int getReadOnly() const      {return readOnly;}   //读取只读的成员
        void setReadWrite(int value) {readWrite = value;} //写入可读写的成员
        int getReadWrite() const     {return readWrite;}  //读取可读写的成员
        void setWriteOnly(int value) {writeOnly = value;} //写入只写的成员
    private:
        int noAccess:  //这个成员既不能读也不能写
        int readOnly;  //这个成员只读
        int readWrite; //这个成员可读可写
        int writeOnly; //这个成员只写
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;保证类的封装&lt;/strong&gt;
如果通过函数来访问成员变量，便于更改某个计算过程来替换成员变量，而用户不用关注其内部实现是否发生变化。例如，对于一个自动测速程序，当汽车通过时，其速度便被计算并被填入速度收集器。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class SpeedDataCollection
    {
    public:
        void addValue(int speed);    // 把当前测得的速度放进数据集
        double averageSoFar() const; // 利用数据计算平均速度
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于函数&lt;code&gt;averageSoFar()&lt;/code&gt;，我们有两种思路进行实现：第一，在类中定义一个成员变量，记录所有速度的平均值，当&lt;code&gt;averageSoFar()&lt;/code&gt;被调用时，只需要返回该变量就可；第二，每次调用&lt;code&gt;averageSoFar()&lt;/code&gt;函数时都重新计算平均值，此函数可以访问速度数据集中每一个值。两种方法可以适用于不同的环境，方法一&lt;code&gt;averageSoFar()&lt;/code&gt;高效，但是要为累积总量、数据点数以及平均值分配存储空间，比较消耗内存；方法二中调用&lt;code&gt;averageSoFar()&lt;/code&gt;时才进行计算，执行较慢。方法一适用于对反应速度有要求的情况，方法二适用于内存比较紧张的机器上(如嵌入式设备)。
将成员变量隐藏在函数接口的背后，可以为所有可能的实现方式提供弹性支持。对用户隐藏成员变量，可以确保 class 的约束条件总是会获得维护，因为只有成员函数可以影响它们。
假设我们有一个 public 成员变量，如果对其进行了修改或删除，所有使用它的代码都有可能被破坏，对于 protected 成员变量来说，使用它的派生类也会被破坏，protected 成员变量和 public 成员变量一样缺乏封装性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成员变量要声明为 private，这样可以保证接口的一致性、可以进行精确的访问权限控制，并提供 class 多种功能实现的弹性。&lt;/li&gt;
&lt;li&gt;protected 并不比 public 更具有封装性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item23-用非成员且非友元函数来替换成员函数&#34;&gt;item23 用非成员且非友元函数来替换成员函数&lt;/h2&gt;
&lt;p&gt;这个 item 更直白的意思是“不要随意把函数定义为类的成员函数”，否则会破坏类的封装性。这个结论看着很矛盾，直觉上我们把函数定义为成员函数貌似更具有封装的特征。事实上并不是这样的！
假设我们定义了一个浏览器类，它用到三个函数来实现清除下载缓存、清除浏览记录、清除 cookies：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class WebBrowser
    {
    public:
        void clearCache();
        void clearHistory();
        void removeCookies();
        void cleanEverything(); // 调用上面三个函数
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面代码中，声明了一个成员函数&lt;code&gt;cleanEverything()&lt;/code&gt;实现一键清除。这个功能也可以通过一个非成员函数进行实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    void clearBrowser(WebBrowser&amp;amp; wb)
    {
        wb.clearCache();
        wb.clearHistory();
        wb.removeCookies();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面两种实现方法，哪种更好？在面向对象编程中，数据以及执行数据操作的函数应该被捆绑在一起，这意味着成员函数的方案更好。事实上，这是不正确的，这是对面向对象真实意义的误解。面向对象要求数据应该尽可能的被封装，与直观判断相反，成员函数&lt;code&gt;cleanEverything()&lt;/code&gt;的封装性要比非成员函数&lt;code&gt;clearBrowser(WebBrowser&amp;amp;)&lt;/code&gt;低。此外，提供非成员函数可以为 WebBrowser 类相关的功能提供更大的包装弹性，减少编译依赖，增加 WebBrowser 的可延伸性。究其原因，我们需要从封装进行讨论。
对于对象的成员变量，越少的代码可以访问到数据，意味着成员变量的封装性越好。我们通过计算能够访问数据的函数数量来衡量其封装性，能访问成员变量的函数越多，其封装性越低。item22 中提到，成员变量应该是 private，否则就毫无封装性。能够访问 private 成员变量的函数只有成员函数和友元函数。如果要在一个成员函数和一个非成员且非友元的函数之间做选择，且两者功能相同，那么非成员函数并不会增加能够访问成员变量的函数，具有更好的封装性。
&lt;strong&gt;需要注意的是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面的讨论只适用于&lt;strong&gt;非成员且非友元&lt;/strong&gt;函数，而不是非成员函数。因为友元函数和成员函数对封装性的影响是相同的。&lt;/li&gt;
&lt;li&gt;上面所谓的“非成员函数”并不意味着其不能是其他类的成员函数。例如我们可以让&lt;code&gt;clearBrowser(WebBrowser&amp;amp;)&lt;/code&gt;成为某个工具类的静态成员函数，只要它不是 WebBrowser 的成员或友元函数，就不破坏 WebBrowser 的封装性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;clearBrowser(WebBrowser&amp;amp;)&lt;/code&gt;函数既不是成员函数也不是友元函数，没有对 WebBrowser 的特殊访问权限，即使这个函数不存在，用户也可以自己调用三个函数实现同样的功能，我们将它称为便利函数。虽然不能作为成员函数，但是为了管理方便，我们可以将其和 WebBrowser 放在同一个命名空间下。如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    namespace WebBrowserStuff
    {
        class WebBrowser{...};
        void clearBrowser(WebBrowser&amp;amp;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将两者放在同一个命名空间下还有另外一个作用。与 class 不同的是,namespace 可以跨越多个源文件，这样就可以把不同功能的代码放在不同的头文件中，降低编译依赖性。假如 WebBrowser 有多个不同功能的便利函数，某些与书签有关，某些与打印有关，某些与 Cookies 有关……当只需要书签相关的便利函数时，我们并不希望与管理 Cookies 的便利函数发生编译依赖关系。分离它们的最直接做法就是将书签相关的便利函数声明在一个头文件中，Cookies 管理的函数声明在另外一个头文件中。如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 头文件webbrowser.h，WebBrowset的核心功能以及所有用户都使用的便利函数
    namespace WebBrowserStuff
    {
        class WebBrowser{...};
        ...
    }

    // 头文件webbrowserbookmarks.h
    namespace WebBrowserStuff
    {
        ...   // 书签相关的便利函数
    }

    // 头文件webbrowsercookies.h
    namespace WebBrowserStuff
    {
        ...   // Cookies管理相关的便利函数
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实，这正是 C++标准库的组织方式。C++标准库有数十个头文件，每个头文件都声明了 std 的某些机能。如果用户只想使用&lt;code&gt;vector&lt;/code&gt;的功能，就不需要&lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt;，这允许用户只对他们使用那一小部分系统形成编译依赖。
将所有便利函数放在隶属于同一命名空间的多个头文件，意味着用户可以轻松扩展这一组便利函数。用户所需要做的就是添加更多非成员且非友元函数到命名空间内，如用户为 WebBrowser 添加下载功能，只需要在 WebBrowserStuff 命名空间中建立一个头文件，内含便利函数的声明即可，新函数就像原来的便利函数那样可用并且整合为一体。这是 class 无法实现的，虽然可以派生出子类来扩展功能，但是子类无法访问父类的 private 成员而且并非所有的类都被设计用来作为基类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能用非成员且非友元的函数替换成员函数，这样可以增加类的封装性、包装弹性和功能扩展性。&lt;/li&gt;
&lt;li&gt;命名空间可以分布在不同的编译单元中，减小编译依赖性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item24-如果参数要进行类型转换该函数不能作为成员函数&#34;&gt;item24 如果参数要进行类型转换，该函数不能作为成员函数&lt;/h2&gt;
&lt;p&gt;在导论中提到，&lt;strong&gt;class 支持隐式类型转换会给程序带来隐患&lt;/strong&gt;，因为如果出现了类型错误，编译器是不会报错的。但是我们在建立数值类型时，比如设计一个类来表现有理数，允许整数隐式转换为有理数是完全合理的。此外，C++也支持 int 到 double 的隐式转换。我们设计一个有理数类：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Rational
    {
    public:
        Rational(int numerator = 0, int denominator = 1);
        //构造函数专门不声明为explicit来允许从int到Rational的隐式转换
        int numerator() const;
        int denominator() const;

        const Rational operator*(const Rational&amp;amp; rhs) const;
    ...
    };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为有理数，我们可以定义各种算术运算符，例如加减乘除。上述代码中，我们采用常规的将 operator*声明为成员函数，并进行代码调用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 可以对任意两个有理数对象进行相乘
    Rational oneEighth(1,8);
    Rational oneHalf(1,2);
    Rational result = oneEighth * oneHalf; //编译通过
    result = result * oneEighth; //编译通过

    // 将一个对象和int进行相乘
    result = oneHalf * 2; //编译通过，等价于result = oneHalf.operator*(2)，int进行了隐式类型转换
    result = 2 * oneHalf; //编译错误，等价于result = 2.operator*(oneHalf)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，一个对象和 int 数据进行相乘时，我们往往会想当然的觉得两种写法都是正确的，因为乘法满足交换律。事实上，&lt;code&gt;oneHalf&lt;/code&gt;是一个包含&lt;code&gt;operator*&lt;/code&gt;函数的对象，编译器可以调用该函数，然而整数 2 并没有&lt;code&gt;operator*&lt;/code&gt;成员函数。虽然编译器会在命名空间内或 global 作用域内尝试寻找可以调用的非成员&lt;code&gt;operator*&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    result = operator*(2, oneHalf);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是本例中并没有声明这样一个函数，所以编译器会报错。
对于运行正确的代码，其发生了隐式类型转换，编译器知道传递的是 int 类型的值，而函数需要的是 Rational。编译器用传入的值隐式调用了 Rational 的构造函数，生成了一个 Rational 对象，其真正的过程如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    const Rational tmp(2);
    result = onHalf*tmp;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述情况是因为构造函数是 non-explicit，如果构造函数是 explicit 的，编译器就不会这么操作，那么以下语句都不会通过编译。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    result = oneHalf * 2; //编译错误，构造函数声明为explicit，int便不能转换为Rational
    result = 2 * oneHalf; //编译错误，等价于result = 2.operator*(oneHalf)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结下来，&lt;strong&gt;只有当参数位于参数表里时才可以进行隐式转换&lt;/strong&gt;。我们这里的&lt;code&gt;operator*&lt;/code&gt;作为成员函数，只能对乘号右边的函数参数进行隐式转换，而不在参数表里的参数，即调用成员函数的对象不能进行隐式转换。&lt;/p&gt;
&lt;p&gt;然而，我们还是希望两个语句都可以编译通过，这也满足我们对乘法交换律的认识。解决方案就是将&lt;code&gt;operator*&lt;/code&gt;声明为非成员函数，即允许编译器在每个实参上进行隐式类型转换。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Rational
    {
    public:
        Rational(int numerator = 0, int denominator = 1);
        //构造函数专门不声明为explicit来允许从int到Rational的隐式转换
        int numerator() const;
        int denominator() const;
        ...  // 不声明operator*
    }

    const Rational operator*(const Rational&amp;amp; lhs,const Rational&amp;amp; rhs) // 非成员函数
    {
        return Rational(lhs.numerator()*rhs.numerator(),
                        lhs.denominator()*rhs.denominator());
    }

    Rational oneFourth(1,4);
    Rational result;
    result = oneFourth * 2; //可以编译
    result = 2 * oneFourth; //可以编译
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很多 C++程序员有一个&lt;strong&gt;误区&lt;/strong&gt;：如果某个函数跟某个类有关并且不能作为成员函数，那么就应该将其作为友元函数。这个想法是完全不必要的，本例表明了&lt;code&gt;operator*&lt;/code&gt;完全可以由 Rational 的 public 接口完成任务，不不要额外的特殊接口。而且，能够避免使用友元函数就应该极力避免。&lt;/p&gt;
&lt;p&gt;本条款讨论的内容只是限于面向对象编程这一条件下，当我们在 Template C++条件下时，让 Rational 作为一个 class template 更为妥当，涉及的内容在以后讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果某个函数所有的参数都可能需要隐式转换，这个函数必须作为非成员函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item25-考虑写一个高效的-swap-函数&#34;&gt;item25 考虑写一个高效的 swap 函数&lt;/h2&gt;
&lt;p&gt;swap 是一个非常有用的函数，是保证代码异常安全性重要方法(Item29)，也可以用来避免自我赋值(Item11)。在标准库里面，swap 的实现方式就是经典的方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    namespace std
    {
        template&amp;lt;typename T&amp;gt;
        void swap(T&amp;amp; a,T&amp;amp; b)
        {
            T temp(a);
            a=b;
            b=temp;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要类型 T 支持拷贝(拷贝构造函数和赋值操作符)，swap 函数就会帮助实现交换功能。但是在上述过程中进行了三次拷贝：a 拷贝给 temp，b 拷贝给 a，temp 拷贝给 b。如果实现的是比较大的对象的交换，其效率是非常低的。
为了解决上述问题，常用的方法叫做&lt;strong&gt;pimpl&lt;/strong&gt;(pointer to implementation，item31)，其基本的思想就是把数据和功能放到不同的类中，并通过一个指针来访问数据。通过这种方法设计 Widget 类：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class WidgetImpl
    {
    public:
        ...
    private:
        int a,b,c; // 可能有很多数据
        std::vector&amp;lt;double&amp;gt; vec; // 意味着复制需要很长时间
    }
    class Widget
    {
    public:
        Widget(const Widget&amp;amp; rhs);
        Widget&amp;amp; operator=(const Widget&amp;amp; rhs)
        {
            ...
            *pImpl = *(rhs.pImpl); // 复制Widget时，让其复制WindgetImpl对象
            ...
        }
    private:
        WidgetImpl* pImpl; // 指针所指向的对象内包含Widget数据
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一来，当需要交换两个对象时，直接交换指针即可，不需要交换成千上万的数据。但是 std::swap 并不会这么操作，它不止复制三个 Widget，还会复制三个 WidgetImpl 对象。我们需要明确的告诉 std::swap，当传入的对象是 Widget 对象时，需要进行&lt;strong&gt;特殊化&lt;/strong&gt;对待。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    namespace std
    {
        template&amp;lt;&amp;gt; // 表示这是一个std::swap函数完全特殊化的实现
        void swap&amp;lt;Widget&amp;gt;(Widget&amp;amp; a,Widget&amp;amp; b) // 当T是Widget时，会调用这个版本的函数
        {
            swap(a.pImpl,b,pImpl); // 只需要置换Widget对象的pImpl指针即可
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常情况下，我们不能改变 std 命名空间中的任何东西，但是我们可以为 template 设计一个特殊化的版本，让其适用于我们自己的类。但是上面的代码是无法通过编译的，因为其访问了 Widget 对象的私有成员。我们可以把这个函数声明为类的友元函数，但是更常见的做法是在 Widget 类中声明一个 public 的 swap 成员函数，然后将 std::swap 特殊化并调用该成员函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Widget
    {
    public:
        void swap(Widget&amp;amp; other)
        {
            using std::swap;
            swap(pImpl,other.pImpl);
        }
    }

    namespace std
    {
        template&amp;lt;&amp;gt;
        void swap&amp;lt;Widget&amp;gt;(Widget&amp;amp; a,Widget&amp;amp; b)
        {
            a.swap(b);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就可以通过编译，而且这也是 STL 标准容器实现 swap 的实现方法，STL 也是通过提供 public swap 成员函数和 std::swap 特殊化版本来实现交换功能的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面讨论的对象是类，如果 WidgetImpl 和 Widget 是类模板的话，我们可以将数据类型加以参数化：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    class WidgetImpl{...}
    template&amp;lt;template T&amp;gt;
    class Widget{...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是特殊化 std::swap 是会出现问题，即&lt;strong&gt;部分特殊化&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    namespace std
    {
        template&amp;lt;typename T&amp;gt;
        void swap&amp;lt;Widget&amp;lt;T&amp;gt;&amp;gt;(Widget&amp;lt;T&amp;gt;&amp;amp; a,Widget&amp;lt;T&amp;gt;&amp;amp; b)
        {
            a.swap(b);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是 C++只允许对类模板进行部分特殊化，在函数模板上进行部分特殊化是行不通的，这段代码不应该通过编译。如果要部分特殊化一个函数模板，常见做法是为它添加一个重载版本，即：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    namespace std
    {
        template&amp;lt;typename T&amp;gt;
        void swap(Widget&amp;lt;T&amp;gt;&amp;amp; a,Widget&amp;lt;T&amp;gt;&amp;amp; b)
        {
            a.swap(b);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重载函数模板是没有问题的，但是 std 命名空间规则比较特殊，用户只能对其中的功能进行特殊化，不允许用户自行扩展。解决办法就是不将重载版本的函数放入 std 命名空间：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    namespace WidgetStuff
    {
        template&amp;lt;typename T&amp;gt;
        class Widget&amp;lt;...&amp;gt;
        ...
        template&amp;lt;typename T&amp;gt; // 非成员的swap函数，在用户自定义命名空间内
        void swap(Widget&amp;lt;T&amp;gt;&amp;amp; a,Widget&amp;lt;T&amp;gt;&amp;amp; b)
        {
            a.swap(b);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码的好处是能把我们自定义的所有类相关的功能整合在一起，在逻辑上和代码上都更加的简洁。这也符合 C++的函数搜索法则，即实参依赖查找(argument dependent lookup)。&lt;/p&gt;
&lt;p&gt;重载函数模板的方法既适用于类也适用于类模板，但是对 std 进行特殊化依然是必要的。如果我们想让 swap 函数适用于多种情况，除了在我们自己的命名空间写一个非成员版本的 swap 函数，在 std 里面依然要特殊化一个 swap。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面讨论的是针对 swap 代码编写者的建议，对于用户来说也有一些需要注意的事项。假设一个函数模板内部需要交换两个对象的值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    void doSomething(T&amp;amp; obj1,T&amp;amp; obj2)
    {
        ...
        swap(obj1,obj2);
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中应该调用的 swap 函数是哪一个版本呢？是默认存在的一般化的 std::swap，还是可能存在的特殊化的 std::swap，抑或是可能存在于某个自定义命名空间专属于 T 的 swap 重载函数？最理想的情况是调用专属于类型 T 的自定义 swap，如果没有则使用一般化版本的 std::swap。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    void doSomething(T&amp;amp; obj1,T&amp;amp; obj2)
    {
        using std::swap; // 令std::swap在此函数可用
        ...
        swap(obj1,obj2); // 为T类型对象调用最佳swap版本
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当编译器看到调用 swap 的时候，实参依赖查找会让编译器在全局作用域和实参的命名空间里搜索。例如，如果 T 是 Widget 类型，那么编译器就会查找 Widget 的命名空间的 swap。using 声明式让 std::swap 在函数内曝光，如果编译器在 Widget 命名空间内没有找到 swap，就会调用 std::swap。但是编译器会优先查找特殊化的 std::swap，为了提高效率，需要对其进行特殊化。在调用 swap 函数时应该注意下面的调用方式。编译器只会调用 std 命名空间中的 swap 函数(因此，对 std::swap 进行特殊化是必要的)，而忽略其他命名空间中的 T 专属版本。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    std::swap(obj1,obj2);
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;到现在为止，我们讨论了默认的 std::swap、std::swap 特殊化版本、成员 swap 函数、非成员 swap 函数、以及对 swap 的调用。我们进行一个总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果默认的 std::swap 对效率没有太大影响，可以直接使用一般化版本。&lt;/li&gt;
&lt;li&gt;如果默认的 std::swap 效率不足(类或模板实现了 pimpl 方法)，应该尝试进行以下操作：
&lt;ul&gt;
&lt;li&gt;提供一个 public swap 成员函数，让它高效的交换自定义类型的两个对象的值，而且这个函数禁止抛出异常(item29)&lt;/li&gt;
&lt;li&gt;在类或模板所在的命名空间提供一个非成员 swap 函数，并令它调用上述 swap 成员函数&lt;/li&gt;
&lt;li&gt;如果所写的是一个类而非类模板，可以为该类特殊化一个 std::swap，并让其调用 swap 成员函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果调用 swap，确定要包含 using 声明式，以便让编译器可以访问 std::swap。另外 swap 的调用不要加 namespace 修饰符。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;成员 swap 函数不允许抛出异常，这是因为 swap 的一个重要用途就是帮助类和类模板提供异常安全性。但是非成员的 swap 函数允许抛出异常，因为它是以拷贝构造函数和赋值操作符为基础的，一般情况下 i 昂着都允许抛出异常。当我们需要自定义一个高效的 swap 函数，还注意要保证其异常安全性，但是两者往往是相辅相成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当默认的 std::swap 函数效率不高时，可以在类中提供一个 swap 成员函数，但是要保证其不抛出异常。&lt;/li&gt;
&lt;li&gt;如果提供了一个成员 swap 函数，相应的要提供一个非成员的 swap 函数来调用这个成员函数。对于类(非模板)来说，还要特殊化 std::swap。&lt;/li&gt;
&lt;li&gt;在调用 swap 函数时，要针对 std::swap 使用 using 声明式，swap 的调用函数前不加任何命名空间修饰符。&lt;/li&gt;
&lt;li&gt;为自定义的类型完全特殊化 std 模板是好的，但是不要尝试在 std 命名空间中添加任何东西。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>05.implementations</title>
      <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/05.implementations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/05.implementations/</guid>
      <description>&lt;p&gt;本文对应原书的第五部分，主要介绍在接口实现过程中需要注意的事项，包括类型转换、异常安全和内联函数的使用等。&lt;/p&gt;
&lt;h2 id=&#34;item26-尽可能推迟变量定义&#34;&gt;item26 尽可能推迟变量定义&lt;/h2&gt;
&lt;p&gt;只要我们定义了一个变量而其带有一个构造函数或析构函数，那么当程序运行到此处时，就会产生构造成本，当变量的生命周期结束时，会产生析构成本。即使变量没有被使用，这些成本依然存在。我们主观上都会避免定义不使用的变量，然而我们的代码中很有可能产生没有被使用的变量。我们定义一个密码加密的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encryptPassword&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 变量定义太早了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;encrypted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minPasswordLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logic_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Password too short&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//加密
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上述代码中，对象&lt;code&gt;encrypted&lt;/code&gt;并不是完全没有被使用，但是如果函数抛出了异常，它就是一个没有被使用的变量，它所消耗的资源也就浪费了。解决办法就是推迟变量&lt;code&gt;encrypted&lt;/code&gt;的定义，直到确实需要它时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encryptPassword&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minPasswordLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logic_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Password too short&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 推迟变量定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;encrypted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//加密
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码仍然不是最优的，因为&lt;code&gt;encrypted&lt;/code&gt;虽然定义了但是没有任何实参作为初始值，这意味着调用的是其默认构造函数，然后对其赋值，其效率比直接在构造时指定初始值的效率差(item4)。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encryptPassword&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minPasswordLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logic_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Password too short&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;encrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 通过拷贝构造函数定义并初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//加密
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;“尽可能推迟”的真正意义，不仅仅在于推迟定义变量到要使用它的时刻，甚至应该推迟到能够给它初始值为止。这样可以避免构造和析构一些不必要的中间变量，还可以避免无意义的默认构造行为。&lt;/p&gt;
&lt;p&gt;对于循环问题，如果变量只是在循环体内使用，那么是把变量定义在循环外比较好，还是应该把它定义在循环内？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 方法A，在外面定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 方法B，在里面定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;Widget&lt;/code&gt;函数内部，以上两种方法的成本如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法 A：1 次构造+1 次析构+n 次赋值&lt;/li&gt;
&lt;li&gt;方法 B：n 次构造+n 次析构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果对象的一次赋值成本低于一组构造+析构成本，方法 A 比较高效，尤其是 n 比较大的时候，否则方法 B 比较好。但是方法 A 的作用域比方法 B 大，程序的可读性和可维护性较差。因此除非(1)明确赋值成本比构造+析构成本低，(2)代码更注重效率，我们默认使用方法 B。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能推迟变量定义，直到它要被用到，且有初始值可用时。这样做可以增加程序的可读性并改善程序效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item27-减少类型转换的使用&#34;&gt;item27 减少类型转换的使用&lt;/h2&gt;
&lt;p&gt;C++的语法被设计成类型安全的。因此，如果程序顺利通过了编译并且没有发出任何警告，这表示理论上代码不会包含类型不安全的操作。但是，类型转换会破坏类型系统，可能会带来意想不到的风险。C++中的类型转换有 3 种方式，C 风格、函数风格和 C++风格：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// C风格
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 函数风格
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两种形式并没有明显区别，纯粹只是小括号的位置不同。我们称这两种形式为旧式转换。C++风格的类型转换有四种方式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    static_cast&amp;lt;T&amp;gt;(expression)
    dynamic_cast&amp;lt;T&amp;gt;(expression)
    const_cast&amp;lt;T&amp;gt;(expression)
    reinterpret&amp;lt;T&amp;gt;(expression)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;：C++中的任何隐式转换都是使用 static_cast 来实现的(C++ Primer)，任何编写程序时能够明确的类型都可以使用 static_cast，基本数据类型的转换如 int 转为 double、void 指针转为 typed 指针、基类指针转为派生类指针、non-const 对象转为 const 对象，但是不能将 const 对象转为 non-const 对象等。static_cast 发生在编译阶段，不提供运行时检查(所以叫 static_cast)，所以这种强制转换存在安全隐患。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;：dynamic_cast 在运行时进行转换(所以是 dynamic_cast)，会进行运行时检查，有一定的安全性，因此会额外消耗一些性能。dynamic_cast 用于继承体系中，而且只支持&lt;strong&gt;指向多态类型的指针或引用&lt;/strong&gt;，即继承中的派生类对象或有虚函数的基类。可以将派生类指针向上转型为基类指针，也可以将基类指针向下转型为派生类指针，但返回的是空指针。因此 dynamic_cast 的一个用途就是检测当前指针指向的是基类还是派生类，如果返回空指针，说明其指向基类，如果返回有效指针，指向的就是派生类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;：const_cast 常被用来&lt;em&gt;移除对象的常量性&lt;/em&gt;，这也是唯一具有此功能的 C++类型转换符。去除对象的常量性主要用在函数的值传递中，如果需要将一个 const 实参传递给 non-const 形参，就需要移除对象的常量性。此外，const_cast 还可以去掉 volatile 限定符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;：用来把某种类型的指针转为其他类型的指针，是一种非常激进的指针类型转换，在编译器完成，可以转换为任何类型的指针，所以极不安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相对于旧式转换，建议使用 C++风格类型转换。原因是：第一，它们很容易在代码中进行辨识，可以快速定位类型转换的问题；第二，将类型的转换细化，因此编译器能更好的进行诊断。C++风格的类型转换完全能够取代 C 风格的类型转换，如显式构造函数的类型转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Widget
    {
    public:
        explicit Widget(int size);
        ...
    };

    void doSomething(const Widget&amp;amp; w);
    doSomething(Widget(15));  // 利用函数风格类型转换，
    doSomething(static_cast&amp;lt;Widget&amp;gt;(15)); //C++风格类型转换
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面两种方式没有功能上的差异，都会把 int 转换为临时的 Widget 对象传递给函数。如果要突出对象的创建，用函数风格，如果要突出类型转换，用 C++风格。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;许多程序员错误地认为，类型转换只是告诉编译器把某种类型视为另一种类型。事实上，无论显式转换还是隐式转换都会产生更多的机器代码。如将 int 转换成 double 类型肯定会产生一些代码，因为在大部分计算机体系结构中，int 的底层表述不同于 double 的底层表述。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Base{...}
    class Derived:public Base{...}

    Derived d;
    Base* pb = &amp;amp;d; // Derived*隐式转换为Base*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，我们只是建立一个基类指针指向一个派生类对象，但有时候两个指针的值是不同的。这种情况下，会有一个**偏移量(offset)**在运行期间施加在&lt;code&gt;Derived*&lt;/code&gt;上，用以获得正确的&lt;code&gt;Base*&lt;/code&gt; 值。上面例子表明，单一对象(如 Derived 对象)可能拥有一个以上的地址(如以&lt;code&gt;Base*&lt;/code&gt;指向它时的指针和以&lt;code&gt;Derived*&lt;/code&gt;指向它时的指针)。一旦使用多继承，这种情况经常发生，即使在单一继承中也可能发生。
对象的布局方式和它们的地址计算方式随着编译器的不同而不同，因此上面提到的偏移量往往是不固定，在一个平台上的偏移量是这么多，并不代表另一个平台上的编译器生成的偏移量也是这么多。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;类型转换的另一个有趣现象是，很容易写出看起来正确事实上错误的代码。例如，许多应用框架要求派生类的 virtual 函数代码的第一个动作是调用基类的对应函数。我们有一个 Window 基类和一个 SpecialWindow 派生类，两者都定义了 virtual 函数 onResize，进一步假设 SpecialWindow 的 onResize 函数被要求首先调用 Window 的 onResize。下面的实现方式看起来正确，实际上是错的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	class Window
    {
    public:
        virtual void onResize(){...}
        ...
    }
    class SpecialWindow:public Window
    {
    public:
        virtual void onResize()
        {
            static_cast&amp;lt;Window&amp;gt;(*this).onResize(); // 将 *this 转型为Window，然后调用其onResize，这是不可行的。
            ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码中强调类型转换动作，无论是 C++风格类型转换还是旧式类型转换都符合下面的描述。正如预期的那样，上述代码中&lt;code&gt;*this&lt;/code&gt;转型为 Window，也调用了&lt;code&gt;Window::onResize()&lt;/code&gt;。问题在于，上述类型转换语句中会生成一个副本，这个副本的内容是“&lt;code&gt;*this&lt;/code&gt;对象中的基类部分”，上述代码并不是在当前对象中调用&lt;code&gt;Window::onResize()&lt;/code&gt;而是在副本上调用的，然后执行当前对象的专属动作。如果&lt;code&gt;Window::onResize()&lt;/code&gt;修改了对象的内容，，当前对象事实上并没有被修改，被修改的是副本对象。这样的话调用&lt;code&gt;Window::onResize()&lt;/code&gt;就失去了其意义。
解决之道就是去除类型转换动作，直接告诉编译器调用基类的的&lt;code&gt;onResize()&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class SpecialWindow:public Window
    {
    public:
        virtual void onResize()
        {
            Window::onResize(); // 调用Window::onResize()作用于 *this。
            ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;上面的例子说明，如果要进行类型转换的时候，就要注意可能会出现错误，使用&lt;code&gt;dynamic_cast&lt;/code&gt;更是如此。首先，dynamic_cast 的效率比较慢，因为类型的检测是通过字符串的比较实现的，在深层次继承或者多继承中，调用&lt;code&gt;strcmp&lt;/code&gt;的次数会很多，如果程序很看重性能，就尤其要注意 dynamic_cast。
之所以需要 dynamic_cast，通常是因为我们想对派生类进行操作，但是我们持有的是一个基类指针，需要通过 dynamic_cast 判断其指向的是基类对象还是派生类对象。通常有两种方法来避免 dynamic_cast 的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种方法&lt;/strong&gt;，使用容器存储指向派生类对象的指针(通常是智能指针，item13)，这样就避免了需要通过基类指针来操作派生类。如我们在 SpecialWindow 中增加闪烁功能：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Window{...}
    class SpecialWindow:public Window
    {
    public:
        void blink();
        ...
    }

    typedef std::vector&amp;lt;std::shared_ptr&amp;lt;Window&amp;gt;&amp;gt; VPW;
    VPW winPtrs;
    ...
    for(VPW::iterator iter = winPtrs.begin();
        iter != winPtrs.end();
        ++iter)
    {
        if(SpecialWindow* psw = dynamic_cast&amp;lt;SpecialWindow*&amp;gt;(iter-&amp;gt;get()))
        {
            psw-&amp;gt;blink();
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码中使用了 dynamic_cast 来判断基类指针是否指向派生类对象，我们希望避免使用 dynamic_cast。可以这样做：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    typedef std::vector&amp;lt;std::shared_ptr&amp;lt;SpecialWindow&amp;gt;&amp;gt; VPSW;
    VPSW winPtrs;

    for(VPSW::iterator iter = winPtrs.begin();
        iter != winPtrs.end();
        ++iter)
    {
        (*iter)-&amp;gt;blink();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方法的缺陷是容器中只能存储一种类型的派生类对象，如果像保存多种类型的派生类，就需要多个这样的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种方法&lt;/strong&gt;，就是在基类中提供一个 virtual 函数，通过基类对象调用这个函数的方式实现派生类的功能(其实就是多态)。例如，虽然只有 SpecialWindow 可以闪烁，但是我们可以在基类中声明一个不予实现的&lt;code&gt;blink()&lt;/code&gt;函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Window
    {
        virtual void blink(){} // 执行代码缺省
        ...
    }
    class SpecialWindow:public Window
    {
    public:
        void blink(){...};
        ...
    }

    typedef std::vector&amp;lt;std::shared_ptr&amp;lt;Window&amp;gt;&amp;gt; VPW;
    VPW winPtrs;  // 容器，内含指针，指向所有可能的Window类型
    ...
    for(VPW::iterator iter = winPtrs.begin();
        iter != winPtrs.end();
        ++iter)
    {
        (*iter)-&amp;gt;blink();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面两种方法，即使用包含派生类指针的容器和使用包含多态基类指针的容器，可能并不百分百适用于所有场合，但是它们确实能替换 dynamic_cast。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还有一种需要避免的糟糕代码，就是 dynamic_cast 串联出现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Window{...}
    class SpecialWindow1:public Window
    {
    public:
        void blink();
        ...
    }
    ... // 其他类型的派生类
    typedef std::vector&amp;lt;std::shared_ptr&amp;lt;Window&amp;gt;&amp;gt; VPW;
    VPW winPtrs;
    ...
    for(VPW::iterator iter = winPtrs.begin();
        iter != winPtrs.end();
        ++iter)
    {
        if(SpecialWindow* psw = dynamic_cast&amp;lt;SpecialWindow1*&amp;gt;(iter-&amp;gt;get()))
        {...}
        else if(SpecialWindow* psw = dynamic_cast&amp;lt;SpecialWindow2*&amp;gt;(iter-&amp;gt;get()))
        {...}
        else if(SpecialWindow* psw = dynamic_cast&amp;lt;SpecialWindow3*&amp;gt;(iter-&amp;gt;get()))
        {...}
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码不仅生成大量低效率的机器代码，而且极其脆弱，每次 Window 类的继承体系有变化，所有的这类代码都必须重新检查是否需要修改。例如，如果有新的派生类，就需要添加分支语句。&lt;/p&gt;
&lt;p&gt;良好的 C++代码很少使用类型转换，但是类型转换又是无法完全避免的，如 int 转为 double。我们能做的就是尽可能隔离转型操作，通常是将它隐藏在函数内，函数接口可以保护使用者不受函数内部任何不良操作的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果可以就要尽量避免类型转换，尤其是在注重效率的代码中要避免 dynamic_cast。如果需要进行类型转换，尽量用其他方案替代。&lt;/li&gt;
&lt;li&gt;如果类型转换是必要的，就把它封装在函数内，这样用户只能调用接口而自己的代码中就不会出现类型转换。&lt;/li&gt;
&lt;li&gt;尽量使用 C++风格的类型转换替换 C 风格类型转换，有助于在程序中进行识别和定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item28-避免返回指向对象内部成员的句柄&#34;&gt;item28 避免返回指向对象内部成员的句柄&lt;/h2&gt;
&lt;p&gt;假设我们要写一个表示矩形的类，每个矩形由其左上角和右下角表示。为了让 Rectangle 对象尽可能小，我们选择把定义矩形的点放在一个结构体内，再让 Rectangle 指向它。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Point
    {
    public:
        Point(int x,int y);
        void setX(int x);
        void setY(int y);
    }

    struct RectData
    {
        Point ulhc;
        Point lrhc;
    };
    class Rectangle
    {
        ...
    private:
        std::shared_ptr&amp;lt;RectData&amp;gt; pData;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Rectangle 的用户想要获得矩形的点，所以提供了两个返回点的函数。Point 是一个自定义类型，根据 item20 的建议，返回一个引用(引用方式传递用户自定义类型往往比值传递高效)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Rectangle
    {
    public:
        Point&amp;amp; upperLeft() const{return pData-&amp;gt;ulhc;}
        Point&amp;amp; lowerRight() const(return pData-&amp;gt;lrhc;)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码可以通过编译器的编译，但是却是错误的。一方面&lt;code&gt;upperLeft()&lt;/code&gt;和&lt;code&gt;lowerRight()&lt;/code&gt;两个函数被声明为 const 成员函数，因为它们只是返回一个值，而不需要用户对值进行修改。另一方面，两个函数却都返回了一个指向内部 private 成员变量的引用，调用者可以通过引用修改内部数据，如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Point coord1(0,0);
    Point coord2(100,100);
    const Rectangle rec(coord1,coord2);

    rec.upperLeft().setX(50); // coord1的坐标变为(50,0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面我们可以得到两点教训：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成员变量的封装性取决于破坏封装的函数，本例中的 ulhc 和 lrhc 虽然声明为 private，但事实上却是 public 的，因为&lt;code&gt;upperLeft()&lt;/code&gt;和&lt;code&gt;lowerRight()&lt;/code&gt;两个 public 函数传递出了它们的引用。&lt;/li&gt;
&lt;li&gt;如果一个函数返回了指向储存在对象外部的数据成员的引用，即使这个函数声明为了 const，调用这个函数的人也能修改这个成员。这正是 item3 中数据常量性的局限性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了引用，成员函数返回指针或迭代器也会因为相同的原因产生相同的结果。引用、指针和迭代器都是我们这里所讲的&lt;strong&gt;句柄&lt;/strong&gt;，即接触对象的某种方式。直接返回句柄总会带来破坏封装性的风险，这也导致声明为 const 的函数并不是真正的 const。
内部成员除了内部数据外还包括内部函数，即声明为 private 或 protected 的函数，因此也不要返回它们的句柄，否则用户也可以通过返回的函数指针来调用它们，这样私有的成员也相当于变成了公有。
如果要解决返回引用会导致成员变量被改变的问题，只需要给函数的返回类型加上 const，这样用户就只能对其进行读操作而不能进行写操作了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Rectangle
    {
    public:
        const Point&amp;amp; upperLeft() const{return pData-&amp;gt;ulhc;}
        const Point&amp;amp; lowerRight() const(return pData-&amp;gt;lrhc;)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;虽然解决了封装性的问题，但是返回句柄还会导致&lt;strong&gt;野句柄&lt;/strong&gt;的出现，即这个句柄所指向的对象不存在了。野句柄最常见的来源就是函数的返回值。假如我们给某个 GUI 对象写一个返回它边界框的函数，返回类型是 Rectangle：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class GUIObject{...} // GUI对象
    const Rectangle boundingBox(const GUIObject&amp;amp; obj);

    // 用户可能使用下面的代码
    GUIObject* pgo;
    ...
    const Point* pUpperLeft = &amp;amp;(boundingBox(*pgo).upperLeft());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面的代码中，取值运算符括号里面的 boundingBox 函数会返回一个临时的 Rectangle 对象，我们称它为 temp。随后取得其左上角的 Point 对象，pUpperLeft 获得了这个对象的地址。可是 temp 是一个临时对象，这行代码运行完之后，temp 就会被销毁，最后 pUpperLeft 存了指向一个并不存在的对象的指针。&lt;/p&gt;
&lt;p&gt;这就是为什么返回指向内部成员的句柄是危险的，不论这个句柄是指针或迭代器或引用，也不论这个 handle 是否为 const，也不论返回 handle 的函数是否为 const。但这并不意味着绝对不能让成员函数返回 handle。有时候是必须的，如 operator[] (索引操作符)，用来获取容器中某个对象，他返回的就是指向容器里对象的引用，让用户能够完成写操作。但在我们的程序中，应该要尽力避免。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要避免返回指向内部成员的句柄，包括指针、引用、迭代器，这样可以增加封装性，并减少野句柄的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item29-保证代码的异常安全性&#34;&gt;item29 保证代码的异常安全性&lt;/h2&gt;
&lt;p&gt;假设有一个可进行背景替换的菜单 GUI 类，我们希望这个类能用于多线程环境：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class PrettyMenu
    {
    public:
        void changeBackground(std::istream&amp;amp; imgSrc); // 改变背景图像
        ...
    private:
        Mutex mutex;  // 互斥器
        Image* bgImage; // 目前的背景图像
        int imageChange; // 背景图被改变的次数
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是&lt;code&gt;changeBackground&lt;/code&gt;函数的一个可能实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
    {
        lock(&amp;amp;mutex); // 锁定互斥器
        delete bgImage; // 释放旧背景图
        ++imgChange;  // 更新计数器
        bgImage = new Image(imgSrc); // 设置新的背景图
        unlock(&amp;amp;mutex); //解除锁定
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所谓的&lt;strong&gt;异常安全性&lt;/strong&gt;是指当异常发生时，1)不会发生资源泄漏，2)不会破坏数据。上述代码就没有实现这两点，当&lt;code&gt;new Image(imgSrc)&lt;/code&gt;发生异常，unlock 不会被调用，mutex 就会一直被锁住；同时，imageChanges 被改变，bgImage 指向一个被删除的对象。
解决资源泄漏问题很容易，可以使用 item13 中提到的用对象管理资源，item14 中也介绍了 Mutex 的安全管理类 Lock。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
    {
        Lock lock(&amp;amp;mutex); // RAII资源管理类
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决了资源泄漏的问题，接下来我们关注数据破坏的问题。函数的异常安全性有三种级别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基本保证&lt;/strong&gt;：如果异常发生，程序内的任何对象都保持在有效的状态，没有任何数据和对象被破坏，所有对象也处于前后一致的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强烈保证&lt;/strong&gt;：如果异常发生，程序状态不变。这就意味这对强烈保证函数的调用是原子性的：如果函数成功，则完全成功；如果函数失败，程序会恢复到函数调用前的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不抛出异常保证&lt;/strong&gt;：函数绝不抛出异常，因为它们总能完成它们的功能。例如所有对基本类型(int，指针等)的操作都提供不抛出异常保证，它是异常安全代码的基础。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设我们给函数规定一个空的异常规范，那这个函数貌似提供了最安全的不抛出异常保证。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    void doSomething() throw(); // 空的异常规范
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事实上，&lt;code&gt;doSomething()&lt;/code&gt;函数并不是不会抛出异常，而是如果它抛出了异常就是严重错误，然后出发&lt;code&gt;unexpected()&lt;/code&gt;函数，而&lt;code&gt;unexpected()&lt;/code&gt;函数会触发&lt;code&gt;terminate()&lt;/code&gt;。所以，&lt;code&gt;doSomething()&lt;/code&gt;没有提供任何异常安全保证。函数的声明无法提供任何安全性保证，而是由函数的实现决定的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;异常安全的代码必须满足上述三种保证之一，如果不这样做，代码就不具备异常安全性。我们需要考虑的是选择为函数提供哪种保证。一般而言会想到提供最强烈的保证——不抛出异常，然而这是很难做到的，任何使用动态内存的东西(如 STL 容器)都会在内存不足时抛出 bad_alloc 异常(item49)。如果可以的话为函数提供不抛出异常保证，但是对大部分函数而言，我们通常在基本保证和强烈保证中做出选择。
对于&lt;code&gt;changeBackground()&lt;/code&gt;提供强烈保证不困难。首先，改变 PrettyMenu 的 bgImage 成员变量的类型，使用智能指针来管理资源。第二，重新排列 changeBackground 内语句的次序，在更换图像后再更新 imageChange 的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class PrettyMenu
    {
        std::shared_ptr&amp;lt;Image&amp;gt; bgImage;
    }

    void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
    {
        Lock lock(&amp;amp;mutex); // RAII资源管理类
        bgImage.reset(new Image(imgSrc)); // 设定bgImage内部指针
        ++imageChange;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过智能指针来管理资源，不再需要手动 delete 图像。删除图像的操作发生在新图像被成功创建后，delete 只在 reset 函数内部被调用。这两个操作几乎可以保证&lt;code&gt;changeBackground()&lt;/code&gt;提供强烈的异常安全保证。美中不足的是 imgSrc 参数，如果 istream&amp;amp;类型的数据不可读，Image 构造函数可能会抛出异常，所以最坏的情况下&lt;code&gt;changeBackground()&lt;/code&gt;只提供基本保证。&lt;/p&gt;
&lt;p&gt;有一个一般化的策略可以提供异常安全性的强烈保证，即&lt;strong&gt;拷贝和交换&lt;/strong&gt;(copy and swap)。其基本原理是：给想要改变的对象创建一个副本，然后对副本进行操作，当成功执行完所有操作，将副本和原对象交换。如果其中任何一步抛出异常，原对象不会改变。
实现方法通常是将对象的数据放到另一个对象内部，即 item25 中提到的 pimpl 方法。对 PrettyMenu 而言，典型的写法如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    struct PMImpl
    {
        std::shared_ptr&amp;lt;Image&amp;gt; bgImage;
        int imageChange;
    }
    class PrettyMenu
    {
    private:
        Mutex mutex;
        std::shared_ptr&amp;lt;PMImpl&amp;gt; pImpl;
    }
    void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
    {
        using std::swap;
        Lock lock(&amp;amp;mutex);
        std::shared_ptr&amp;lt;PMImpl&amp;gt; pNew(new PMImpl(*pImpl)); // 获得副本数据
        pNew-&amp;gt;bgImage.reset(new Image(imgSrc)); // 修改副本
        ++(pNew-&amp;gt;imageChange); // 交换数据

        swap(pImpl,pNew);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中使用 struct 来封装数据，它的封装性可以被 PrettyMenu 的私有接口保证，要接触到其中的数据要先通过 PrettyMenu 的私有接口。使用类也可以，但可能不方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拷贝和交换&lt;/strong&gt;策略可以保证对象的原子性，但是它并不能保证整个函数有强烈的异常安全性。为了了解原因，我们可以看下述代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    void someFunc()
    {
        ... // 对local对象进行拷贝
        f1();
        f2();
        ... // 将修改后的对象进行交换
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果&lt;code&gt;f1()&lt;/code&gt;和&lt;code&gt;f2()&lt;/code&gt;的异常安全性比 &lt;em&gt;强烈保证&lt;/em&gt; 低，那么很难为&lt;code&gt;someFunc()&lt;/code&gt;提供强烈保证。例如，&lt;code&gt;f1()&lt;/code&gt;只提供 &lt;em&gt;基本保证&lt;/em&gt; ，为了让&lt;code&gt;someFunc()&lt;/code&gt;提供强烈保证，我们需要获取&lt;code&gt;f1()&lt;/code&gt;之前整个程序的状态、捕获&lt;code&gt;f1()&lt;/code&gt;所有可能的异常、然后恢复状态。即使&lt;code&gt;f1()&lt;/code&gt;和&lt;code&gt;f2()&lt;/code&gt;都提供强烈保证，依然存在风险，如果&lt;code&gt;f1()&lt;/code&gt;正常运行，已经对对象进行了改变，&lt;code&gt;f2()&lt;/code&gt;运行过程中抛出异常，程序状态和以前已经不同了。
问题在于连带影响，如果函数只操作局部状态，提供强烈保证相对容易。但是当函数对非局部数据有影响时，提供强烈保证就困难的多。另一个重要的问题就在于效率，&lt;strong&gt;拷贝和交换&lt;/strong&gt;要对修改的对象进行拷贝，这会消耗额外的资源。因此，当提供强烈保证比较困难时，我们必须提供&lt;em&gt;基本保证&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异常安全的函数在抛出异常时也不会泄漏资源和破坏数据。异常安全性有三种级别：基本保证、强烈保证和不抛出异常保证。&lt;/li&gt;
&lt;li&gt;强烈保证可以通过&lt;strong&gt;拷贝和交换&lt;/strong&gt;来实现，但是强烈保证并非对所有函数都可实现或具有实际意义。&lt;/li&gt;
&lt;li&gt;函数提供的异常安全保证通常最高只等于其调用的各个函数中最弱级别的异常安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item31-透彻了解-inline-函数&#34;&gt;item31 透彻了解 inline 函数&lt;/h2&gt;
&lt;p&gt;内联函数有众多优点，相较于宏来说它更像函数(item2)，又不会像调用普通函数那样产生额外的开销。因为编译器最优化机制可以优化那些没有进行函数调用的代码，所以当我们在代码中使用 inline 函数时，意味着编译器可能对它进行语境相关的最优化。
内联函数的基本原理是在函数调用的地方替换为函数本体，这就意味着可能会增加目标代码的大小。而且 inline 函数只是对编译器的一个申请，不是强制命令，是否将其作为 inline 函数使用由编译器进行判断。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;声明 inline 函数的做法是在其定义式(非声明式)前面加上关键字 inline。例如标准的 max 模板函数实现方式为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    inline const T&amp;amp; std::max(const T&amp;amp; a,const T&amp;amp; b)
    {
        return a &amp;lt; b?b:a;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;inline 函数通常定义在头文件中，这是因为 inlining 行为在大多数 C++程序中是编译器行为，为了将函数调用替换为函数本体，编译器必须要了解函数的实现。template 也通常被放在头文件中，以为它一旦被调用，编译器为了将它具体化，也需要了解函数的具体实现。
template 的具体化和 inlining 无关。如果我们要将一个模板函数具体化出来的所有函数都进行 inlining，就可以将此 template 声明为 inline。如果模板函数不要求具体化的所有函数 inlining，就应该避免将该 template 声明为 inline。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个声明为 inline 的函数是否进行 inlining，取决于编译器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大部分编译器拒绝将太过复杂的函数(如带有递归或循环)进行内联；&lt;/li&gt;
&lt;li&gt;编译器也会拒绝将虚函数内联，这是因为虚函数意味着在运行时才确定调用的函数，而内联发生在编译期；&lt;/li&gt;
&lt;li&gt;如果程序要获取 inline 函数的地址，编译器通常会为此函数生成一个非内联的函数体；&lt;/li&gt;
&lt;li&gt;编译器不会对通过函数指针调用的函数进行 inlining。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    inline void f(){...}
    void (*pf) = f;
    f(); // 函数会被inlining
    pf(); // 通过函数指针调用，不会被inlining
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;对于下面的代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Base
    {
    public:
        ...
    private:
        std::string str1;
    }

    class Derived:public Base
    {
    public:
        Derived(){}; // 构造函数看着是空的
    private:
        std::string str1,str2;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，派生类的构造函数中没有任何代码，看起来是 inline 函数的绝佳候选。为了分析问题，我们需要了解对象被创建和销毁时发生了什么。当创建一个对象时，其每一个基类和每一个成员变量都会被自动构造，当销毁一个对象时，反向程序的析构行为也会自动发生。编译器会在编译期产生这些功能代码并将其插入到程序中，有时候就放在构造和析构函数中。编译器为上面看起来空的 Derived 构造函数产生的代码相当于下面：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Derived::Derived()
    {
        Base::Base();
        try{ str1.std::string::string(); }
        catch(...)
        {
            Base::Base();
            throw;
        }
        try{ str2.std::string::string(); }
        catch(...)
        {
            data1.std::string::~string();
            Base::~Base();
            throw;
        }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码并不代表编译器生成的真正代码，但已经反映出编译后的 Derived 空白构造函数。事实上构造函数和析构函数在函数中被大量的调用，如果全部 inlining 的话，这些调用都会被扩展为函数体，势必造成目标代码膨胀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inline 函数主要用在功能简单、被频繁调用的函数上。这既可以使代码膨胀最小化，也能最大化提升程序的速度。&lt;/li&gt;
&lt;li&gt;不要因为 template 也出现在头文件中，就将其声明为 inline.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item31-最小化文件之间的编译依赖关系&#34;&gt;item31 最小化文件之间的编译依赖关系&lt;/h2&gt;
&lt;p&gt;在 C++中，class 不仅详细描述了其外部接口，也给出了内部的实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Person
    {
    public:
        Person(const std::string&amp;amp; name,const Date&amp;amp; birthday,const Address&amp;amp; addr);
        std::string name() const;
        std::string birthday() const;
        std::string address() const;
        ...
    privare:
        std::string theName;
        Date theBirthday;
        Address theAddress;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码要通过编译器的编译还需要引入&lt;code&gt;std::string&lt;/code&gt;，&lt;code&gt;Data&lt;/code&gt;和&lt;code&gt;Address&lt;/code&gt;的定义式，这样的定义式通常式由&lt;code&gt;#include&lt;/code&gt;提示符来实现的。因此上述代码最开始的地方可能存在代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    #include &amp;lt;string&amp;gt;
    #include &amp;#34;date.h&amp;#34;
    #include &amp;#34;address.h&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是这样一来，&lt;code&gt;Person&lt;/code&gt;的定义文件和其包含文件之间就形成了编译依赖关系。如果依赖的头文件有任何修改，或者这些头文件依赖的其他文件被改变，那么 Person 的文件就得重新编译，任何使用 Person 的文件也必须重新编译。这样的一连串的编译依赖关系对于项目来说就是巨大的灾难。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为了解决过度依赖问题，我们可以尝试使用前置声明来替代#include。通过前置声明，可以让 Person 在其自身接口被修改时才重新编译。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    namespace std
    {
        class string; // 这是错误的前置声明
    }
    class Date;
    class Address;
    class Person
    {
    public:
        Person(const std::string&amp;amp; name,const Date&amp;amp; birthday,const Address&amp;amp; addr);
        std::string name() const;
        std::string birthday() const;
        std::string address() const;
        ...
    privare:
        std::string theName;
        Date theBirthday;
        Address theAddress;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码存在两个问题。第一，string 不是一个类，它是一个 typedef(定义为 basic_string&lt;char&gt;)，因此上述关于 string 的前置声明不正确，而且我们也不应该手动声明标准程序库。另外，标准头文件不太可能成为编译瓶颈。第二，编译在编译期间必须要知道对象的大小，获取这项信息的唯一办法就是访问 class 的定义式。前置声明可以合法的不列出实现的细节，那编译器就无法确定该分配多少空间。
解决上述问题的办法就是：1)标准程序库文件不适用前置声明；2)定义一个指针，让其指向实现细节的对象。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    #include &amp;lt;string&amp;gt;  // 标准库头文件不使用前置声明
    #include &amp;lt;memory&amp;gt;

    class PersonImpl;
    class Date;
    class Address;
    class Person
    {
    public:
        Person(const std::string&amp;amp; name,const Date&amp;amp; birthday,const Address&amp;amp; addr);
        std::string birthday() const;
        std::string address() const;
        ...
    privare:
        std::shared_ptr&amp;lt;PersonImpl&amp;gt; pImpl; // 指向实现细节的指针
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码使用了 pimpl 方法来实现类，Person 类中只有一个指针成员，编译器只需要给指针分配空间即可。这样的设计之下，Person 的接口就完全和 Date，Address 和 Person 的实现细节进行了分离。这些 class 的任何修改都不需要 Person 重新编译，这就是&lt;strong&gt;接口与实现分离&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接口与实现分离的关键在于&lt;strong&gt;以声明依赖替换定义依赖&lt;/strong&gt;，这也是编译依赖最小化的本质，即&lt;strong&gt;为每个类单独提供声明文件和定义文件，如果无法实现，就让其依赖其他文件的声明式而非定义式&lt;/strong&gt;。最小化编译依赖的设计策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;尽可能使用对象引用或者对象指针来替换直接使用对象&lt;/strong&gt;。通过一个类型声明式就可以定义出指向该类型的引用和指针，如果定义该类型的对象，就需要访问该类型的定义式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用 class 声明式代替 class 定义式&lt;/strong&gt;。当我们声明一个函数而它又用到某个 class 时，其并不会用到该 class 的定义式，即使函数是以值传递的方式传递该类型参数或返回值也是一样的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Date; // class声明式
    Date day(); // 函数返回Date类型对象
    void clearAppointments(Date d); //
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，声明 today 函数和 clearAppointments 函数不需要 Date 的定义。这是因为如果有人调用上面两个函数，那么 Date 的定义在函数调用前已经且必须被访问到。3. &lt;strong&gt;为声明式和定义式提供不同的头文件&lt;/strong&gt;。即我们需要提供两个头文件，一个用于声明式，一个用于定义式，这些文件必须保持一致。声明式头文件中包含了各个类型的声明，对应的定义分布在不同的定义式头文件中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    #include &amp;#34;datefwd.h&amp;#34; // 头文件内声明了class Date
    Date day();
    void clearAppointments(Date d);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们应该在程序中&lt;code&gt;#include&lt;/code&gt;声明式头文件，而不是在文件中重复前置声明多个函数。&lt;code&gt;datefwd.h&lt;/code&gt;的命名方式取自 C++标准库头文件的&lt;code&gt;&amp;lt;iosfwd&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;iosfwd&amp;gt;&lt;/code&gt;内包含了 iostream 各个组件的声明式，其对应的定义分布在不同的头文件内，包括&lt;code&gt;&amp;lt;sstream&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;streambuf&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;fstream&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;。
&lt;code&gt;&amp;lt;iosfwd&amp;gt;&lt;/code&gt;另外一个启发意义在于，上述建议 template 和 non-template 同样适用，虽然许多编译环境中 template 的定义式通常放在头文件中，但是 C++提供关键字&lt;code&gt;export&lt;/code&gt;语序将 template 声明式和定义式放在不同的文件内。&lt;/p&gt;
&lt;p&gt;像 Person 这样使用 pimpl 方法法的类常被称为&lt;strong&gt;句柄类(Handle Classe)&lt;/strong&gt;。当 PersonImpl 的内部实现发生改变时，Person 的代码不需要重新编译。让 Person 变成一个句柄类不会改变它的功能，只是改变了其完成功能的方式。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    #include &amp;#34;Person.h&amp;#34; // 包含class Person的定义式
    #include &amp;#34;PersonImpl.h&amp;#34;  // 包含PersonImpl的定义式，否则无法调用其成员函数

    Person::Person(const std::string&amp;amp; name,const Date&amp;amp; birthday,const Address&amp;amp; addr)
    :pImpl(new PersonImpl(name,birthday,addr))  // 初始化智能指针指向的对象
    {}
    std::string Person::name() const
    {
        return pImpl-&amp;gt;name();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;另一种设计句柄类的方法是，让 Person 成为一种特殊的抽象基类(abstract base class)，称为&lt;strong&gt;接口类(Interface Class)&lt;/strong&gt;。这个类的作用是为派生类提供接口，因此接口类中通常没有成员变量，没有构造函数，只有一个 virtual 析构函数和一组描述接口的纯虚函数。针对 Person 的接口类可能如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Person
    {
    public:
        virtual ~Person();
        virtual std::string name() const =0;
        virtual std::string birthday() const =0;
        virtual std::string address() const =0;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和 Handle 类一样，除非 Interface 类的接口发生变换，否则不需要重新编译。用户必须适用 Person 的指针或引用来写程序，因为包含纯虚函数的类无法实例化。因此，接口类的用户必须有办法创建新的对象。常用的方法是调用一个特殊的函数，这个函数能够像构造函数一样执行对派生类的实例化。这样的函数一般称为工厂(factory)函数或 virtual 构造函数，该函数返回一个指针指向动态分配的对象。这样的函数在接口类中一般声明为 static：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Person
    {
    public:
        static std::shared_ptr&amp;lt;Person&amp;gt; create(const std::string&amp;amp; name,
                                            const Date&amp;amp; birthday,const Address&amp;amp; addr);
    }
    // 适用工厂函数初始化对象
    std::string name;
    Date dateOfBirth;
    Address address;
    ...
    // 创建一个对象
    std::shared_ptr&amp;lt;Person&amp;gt; pp(Person::create(name,dateOfBirth,address));
    ...
    std::cout &amp;lt;&amp;lt; pp-&amp;gt;name() // 通过Person接口使用这个对象
              &amp;lt;&amp;lt; &amp;#34; was born on &amp;#34;
              &amp;lt;&amp;lt; pp-&amp;gt;birthDate()
              &amp;lt;&amp;lt; &amp;#34; and lives at &amp;#34;
              &amp;lt;&amp;lt; pp-&amp;gt;address();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，必须定义支持支持接口类的具体类而且真正的构造函数必须被调用。假设 Person 接口类有一个派生类 RealPerson 且能够被实例化，RealPerson 提供继承来的 virtual 函数的实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class RealPerson:public Person
    {
    public:
        RealPerson(const std::string&amp;amp; name,const Date&amp;amp; birthday,const Address&amp;amp; addr)
        :theName(name),theBirthDate(birthday),theAddress(addr)
        {}
        virtual ~RealPerson(){}
        std::string name() const;
        std::string birthDate() const;
        std::string address() const;
    private:
        std::string theName;
        Date theBirthDate;
        Address theAddress;
    }

    std::shared_ptr&amp;lt;Person&amp;gt; Person::create(const std::string&amp;amp; name,
                                           const Date&amp;amp; birthday,
                                           const Address&amp;amp; addr)
    {
        return std::shared_ptr&amp;lt;Person&amp;gt; (new RealPerson(name,birthday,addr));
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Person::create 能够创建不同派生类型的对象。RealPerson 示范了实现接口类的两个最常见机制之一，即从接口类继承它的接口规格，然后实现接口中的函数。另一个机制设计多继承，即 item40 的主题。&lt;/p&gt;
&lt;p&gt;Handle 类和 Interface 类解除了接口和实现之间的耦合关系，从而降低文件之间的编译依赖性。在 Handle 类中，成员函数通过实现指针取得对象的数据，而且必须在存储每一个对象所需的内存中增加存储指针的内存。最后，实现指针必须通过 Handle 类的构造函数进行初始化，让其指向一个动态分配得到的对象。Interface 类的每个函数是 virtual，每次调用函数都需要通过虚指针去进行访问，而且 Interface 类的派生类都包含一个虚函数表，这会增加对象的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小化编译依赖性的一般原则是：用声明依赖替代定义依赖。基于此原则的两个方法是 Handle 类和 Interface 类。&lt;/li&gt;
&lt;li&gt;程序库头文件应该以完整并且只有声明的形式存在，无论是否涉及 template 都适用。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>06.inheritance-and-objected-oriented-design</title>
      <link>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/06.inheritance-and-objected-oriented-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/cpp-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/effective-c&#43;&#43;/06.inheritance-and-objected-oriented-design/</guid>
      <description>&lt;p&gt;本文对应原书的第六部分，主要介绍使用 C++进行面向对象编程时关于继承需要注意的事项。&lt;/p&gt;
&lt;h2 id=&#34;item32-让-public-继承塑造出-is-a-关系&#34;&gt;item32 让 public 继承塑造出 is-a 关系&lt;/h2&gt;
&lt;p&gt;用 C++进行面向对象编程，最重要的规则就是：public 继承要塑造出“&lt;strong&gt;is-a&lt;/strong&gt;”的关系。如果一个类 D(Derived)以 public 的形式继承了类 B(Base)，那就是在告诉 C++编译器，每一个类型为 D 的对象也是一个类型为 B 的对象，反之不成立。这就是说任何类型 B 的对象可以使用的地方，类型为 D 的对象一样可以使用，因为类 D 的对象就是一个类型为 B 的对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码描述的就是&lt;strong&gt;is-a&lt;/strong&gt;关系，根据日常经验我们知道每个学生都是一个人，当并不是每个人都是学生，这就是 public 继承体系严格确定的意义。在 C++中，如果函数期望获得类型为 Person 的实参，都可以接受一个 Student 对象。这种关系只有在 Student 以 public 形式继承 Person 时才成立，private 继承的意义与此完全不同(item39)。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;public 继承和 is-a 的关系听起来很简单，但是有时候直觉可能会误导我们。例如，企鹅是一种鸟，鸟会飞，这些都是事实。我们用 C++来描述这一关系：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Bird
    {
    public:
        virtual void fly();
    }
    class Penguin:public Bird
    {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个继承体系下，我们得出企鹅会飞，但事实上且不会飞。这就是&lt;strong&gt;自然语言的二义性&lt;/strong&gt;给我们造成的误导，我们说鸟会飞，真正的意思是一般的鸟都有飞行能力，但是有些鸟不会飞。我们需要更准确的继承体系来更准确的反映我们的真正意思：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Bird
    {...}
    class FlyingBird:public Bird
    {
    public:
        virtual void fly();
    }
    class Penguin:public Bird
    {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了上述修改类的继承体系外，还有一种思想是：为类 Penguin 重新定义 fly 函数，让它产生一个运行时错误。在这种情况下，程序能够通过编译器的编译，但是在运行时调用 fly 函数会给出一个错误提示。这里表达的逻辑就不再是“企鹅不会飞”，而是“企鹅会飞，但这么做是错误的”。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Penguin:public Bird
    {
    public:
        virtual void fly(){error(&amp;#34;Attempt to make a penguin fly!&amp;#34;);} // 调用fly函数会提示错误
    }

    Penguin p;
    p.fly(); // 通过编译，运行时会提示错误
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;item18 中提到，良好的接口可以防止无效的代码通过编译。因此，上述代码的设计是不合理的。对于某些系统而言，我们不需要区分会飞的鸟和不会飞的鸟，这种情况下原先的两个类的继承体系就能够满足要求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Bird&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 无飞行函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Penguin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bird&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 无飞行函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;生活的经验给了我们关于对象继承的直觉，然而这样的直觉并不一定是正确的。比如，我们实现一个正方形类继承自矩形类：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Rectangle&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;setHeight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newHeight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setWidth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newWidth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;makeBigger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Rectangle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldHeight&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;rect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setWidth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 宽度增加10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;oldHeight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 判断高是否改变，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Square&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Rectangle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Square&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 正方形的高度等于宽度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;makeBigger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 理论上来说应该仍然成立
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据正方形的定义，宽高相等应该是在任何时候都成立的。然而&lt;code&gt;makeBigger&lt;/code&gt;却破坏了正方形的属性，所以在这种情况下正方形并不是一个矩形，即 Square 继承 Rectangle 是错误的。C++类的继承比现实世界中的继承关系更为严格，即&lt;strong&gt;适用于基类的属性都要适用于派生类&lt;/strong&gt;。
&lt;strong&gt;is-a&lt;/strong&gt;并不是唯一存在于类与类之间的关系，另外两个常见的关系是&lt;strong&gt;has-a&lt;/strong&gt;和&lt;strong&gt;use-a&lt;/strong&gt;，这些关系在 item38 和 item39 中讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public 继承意味着类与类之间是 is-a 的关系，适用于基类的每一件事情也适用于其派生类，因为每一个派生类对象也是一个基类对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item33-避免继承中发生的名称覆盖&#34;&gt;item33 避免继承中发生的名称覆盖&lt;/h2&gt;
&lt;p&gt;名称屏蔽的发生其实和继承无关，而是和作用域有关。举个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	int x; // 全局变量
	void someFunc()
	{
		double x; // 局部变量
		std::cin&amp;gt;&amp;gt;x;
	}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/book/Effective-CPP/effective_cpp33_global_scop.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;
上面代码中于数据读取相关的是局部变量，这是因为内层的作用域名称会屏蔽外部作用域的名称。当编译器在 someFunc 的作用域中遇到 x 时，会在当前作用域寻找相关的定义，如果找到就不会再检查其他作用域。在此例中，someFunc 的 x 类型为 double，全局 x 的类型为 int，但是这不会影响结果，因为 C++名字屏蔽的规则是&lt;strong&gt;只覆盖名称，和类型无关&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在类的继承关系中，派生类能够访问基类的成员，这是因为派生类继承了基类中声明的成员，具体的关系是派生类的作用域嵌套在基类的作用域内。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Base
    {
    private:
        int x;
    public:
        virtual void mf1()=0;
        virtual void mf2();
        void mf3();
        ...
    }

    class Derived:public Base
    {
    public:
        virtual void mf1();
        void mf4(){ mf2();}
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/book/Effective-CPP/effective_cpp33_scop1.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;
上述代码中既涉及了 public 和 private，也涉及了成员变量和成员函数，还涉及了虚函数，纯虚函数和普通函数三种概念，这是为了强调我们讨论的内容至于名称有关，和其他无关。上述代码中，mf4 调用了 mf2 函数。编译器的做法是查找各个作用域，先查找 mf4 函数的作用域，然后查找类 Derived 的作用域，接着查找类 Base 的作用域，类 Base 所在命名空间的作用域，最后到全局作用域，直到编译器找到 mf2 为止。&lt;/p&gt;
&lt;p&gt;接下来我们在派生类中重载函数 mf1 和 mf3，并且为派生类增加一个新的 mf3 函数(要避免重定义继承而来的非虚函数，item36)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Base
    {
    private:
        int x;

    public:
        virtual void mf1() = 0;
        virtual void mf1(int); // 基类中重载mf1函数
        virtual void mf2();
        void mf3();
        void mf3(double); // 基类中重载mf3函数
        ...
    };

    class Derived: public Base
    {
    public:
        virtual void mf1();
        void mf3(); // 增加新的mf3函数
        void mf4();
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/book/Effective-CPP/effective_cpp33_scop2.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于名字屏蔽，上述代码中 Base 类中所有名为 mf1 和 mf3 的函数都被 Derived 类中名为 mf1 和 mf3 的函数覆盖。从名称搜索的观点来看，&lt;code&gt;Base::mf1&lt;/code&gt;和&lt;code&gt;Base::mf3&lt;/code&gt;不再被类 Derived 继承。上述规则，即使基类和派生类中的函数有不同的参数类型也适用，无论是否是虚函数也适用。名称屏蔽的原因是，防止我们在程序库或应用框架内建立一个新的派生类时附带地从遥远的基类中继承重载函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Derived d;
    int x;

    d.mf1();  // 正确，调用了Derived::mf1
    d.mf1(x); // 错误，Base::mf1(int)被屏蔽
    d.mf2();  // 正确，调用了Derived::mf2
    d.mf3();  // 正确，调用了Derived::mf3
    d.mf3(x); // 错误，Base::mf3(double)被屏蔽
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;如果想要避免 C++继承过程中发生的名字屏蔽，可以使用&lt;strong&gt;using 声明式&lt;/strong&gt;来实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Base
    {
    public:
        virtual void mf1() = 0;
        virtual void mf1(int);
        virtual void mf2();
        void mf3();
        void mf3(double);
    private:
        int x;
    }
    class Derived:public Base
    {
    public:
        // 让类Base中名为mf1和mf3的所有函数在Derived中可见
        using Base::mf1;
        using Base::mf3;
        virtual void mf1();
        void mf3();
        void mf4();
        ...
    }

    // 现在，继承机制可以正常工作
    Derived d;
    int x;
    ...
    d.mf1();   // 正确，调用Derived::mf1
    d.mf1(x);  // 正确，调用Base::mf1
    d.mf2();   // 正确，调用Base::mf2
    d.mf3();   // 正确，调用Derived::mf3
    d.mf3(x);  // 正确，调用Base::mf3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/book/Effective-CPP/effective_cpp33_scop3.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;
从上述代码可以看出，如果继承了一个带有重载函数的基类并且想在派生类中重定义其中的一部分，那么需要在派生类中为不想被屏蔽的名称进行&lt;strong&gt;using 声明&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 public 继承中，派生类和基类是 is-a 的关系，派生类继承了基类的所有函数，但是有的时候我们只想继承某一个重载函数，using 声明式在这里派不上用场，因为 using 声明式会让继承来的给定名称的多有同名函数在派生类中可见。因此，我们需要用到另一种技术——&lt;strong&gt;转发函数(forwarding function)&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Base
    {
    public:
        virtual void mf1() = 0;
        virtual void mf1(int);
        ...
    }
    class Derived:public Base
    {
    public:
        virtual void mf1() // 转发函数
        {
            Base::mf1();
        }
        ...
    }

    Derived d;
    int x;
    d.mf1();    // 正确，调用Derived::mf1
    d.mf1(x);   // 错误，Base::mf1(int)b被屏蔽
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转发函数的另一个作用是帮助那些不支持 using 声明式的编译器将继承等到的函数引入派生类作用域中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;派生类中的函数名称会屏蔽基类中的所有同名函数，与函数的参数和返回值无关。&lt;/li&gt;
&lt;li&gt;为了在派生类中引入被屏蔽的基类函数，可以使用 using 声明式或转发函数(forwarding function)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item34-区分接口继承和实现继承&#34;&gt;item34 区分接口继承和实现继承&lt;/h2&gt;
&lt;p&gt;C++的 public 继承有两部分组成：&lt;strong&gt;函数接口继承&lt;/strong&gt;和&lt;strong&gt;函数实现继承&lt;/strong&gt;，这两种继承对应的是函数的声明和函数的实现。在 class 的设计中，有时候我们希望派生类只继承成员函数的接口；有时候希望派生类同时继承函数的接口和继承，但又希望能够重写它们继承的实现；有时候希望同时继承函数的接口和实现，但是不希望重写实现。为了更好的描述这三者之间的差异，我们考虑一个展现图形绘制的继承体系：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Shape
    {
    public:
        virtual void draw() =0;
        virtual void error(const std::string&amp;amp; msg);
        int objectedID() const;
        ...
    }
    class Rectangle:public Shape{...}
    class Ellipse:public Shape{...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Shape 类声明了三个函数，第一个是&lt;code&gt;draw&lt;/code&gt;，用来绘制形状；第二个是&lt;code&gt;error&lt;/code&gt;，准备让需要报出错误的函数调用；第三个是&lt;code&gt;objectID&lt;/code&gt;，用来返回当前对象的标识码。每个函数的声明方式不同：&lt;code&gt;draw&lt;/code&gt;是纯虚函数，&lt;code&gt;error&lt;/code&gt;是虚函数，&lt;code&gt;objectID&lt;/code&gt;是普通函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;纯虚函数&lt;/strong&gt;
纯虚函数有两个突出的特性：1)必须在具象类中被实现；2)在抽象类中通常没有被定义。这两个性质表明了：&lt;strong&gt;声明一个纯虚函数的目的就是为了让派生类继承函数接口&lt;/strong&gt;。Shape 是一个抽象类，无法进行实例化，其派生类要进行实例化就必须提供&lt;code&gt;draw&lt;/code&gt;函数的实现。虽然我们也可以在抽象类中为纯虚函数函数提供定义，但是无法通过对象进行访问，只能通过&lt;code&gt;shape::draw()&lt;/code&gt;这样的形式进行访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Shape* ps = new Shape(); // 错误，Shape无法实例化
    Shape* ps1 = new Rectangle(); // 正确
    ps1-&amp;gt;draw(); // 调用Rectangle::draw()
    Shape* ps2 = new Ellipse();
    ps2-&amp;gt;draw(); // 调用Ellipse::draw()
    ps1-&amp;gt;Shape::draw(); // 调用Shape::draw()
    ps2-&amp;gt;Shape::draw();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;虚函数&lt;/strong&gt;
普通的虚函数和纯虚函数有一些不同，普通虚函数不仅提供了继承的函数接口，也提供了默认的函数实现，派生类也可以重写函数的实现。虚函数的性质表明了：&lt;strong&gt;声明一个虚函数的目的是让派生类同时继承函数的接口和默认实现，并能够重写实现&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Shape
    {
    public:
        virtual void error(const std::string&amp;amp; msg);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该接口表示，每个类都必须提供一个当发生错误时可被调用的函数，但每个类可以自定义错误行为。如果不想自定义，可以使用基类提供的默认实现。但是，允许虚函数同时指定函数声明和函数默认实现的行为，可能会造成危险。我们考虑一个航空公司设计的飞机继承体系：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Airport{...}
    class Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination);
    }
    void Airplane::fly(const Airport&amp;amp; destination)
    {
        ... // 默认实现
    }

    class ModelA:public Airplane{...}
    class ModelB:public Airplane{...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，A 型飞机和 B 型飞机都继承了函数&lt;code&gt;fly&lt;/code&gt;的默认实现。现新增 C 型飞机，它的飞行方式与默认方式不同。由于程序员忘记给 C 重新定义&lt;code&gt;fly&lt;/code&gt;函数，因此当派生类 C 调用&lt;code&gt;fly&lt;/code&gt;函数时会调用默认实现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class ModelC:public Airplane
    {
        ... // 未声明fly函数
    }

    Airport PDX;
    Airplane* pa = new ModelC;
    ...
    pa-&amp;gt;fly(PDX); // 调用Airplane::fly
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码的问题不在于 Airplane::fly 有默认实现，而在于 ModelC 在未明确要调用的情况下就继承了该默认的实现。我们可以通过切断虚函数接口和默认实现之间的直接关系来避免上述的不安全行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;为默认实现定义一个独立的函数&lt;/strong&gt;，具体做法是将函数声明为纯虚函数来提供接口，另外定义一个独立的&lt;code&gt;defaultFly&lt;/code&gt;函数来提供默认的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination) = 0;

    protected:
        void defaultFly(const Airport&amp;amp; destination)
        {
            ... // 默认实现
        }
    }

    class ModelA:public Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination)
        {
            defaultFly(destination);
        }
    }
    class ModelB:public Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination)
        {
            defaultFly(destination);
        }
    }

    class ModelC:public Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中类 ModelC 不会再出现意外调用默认 fly 实现的情况，因为纯虚函数要求派生类 ModelC 必须提供自己的实现。但是上述方案并不是完全安全的，程序员可能因为剪贴(copy-and-paste)代码而造成错误，而且由于函数名称过于相似也会引起 class 命名空间污染问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;为纯虚函数提供默认实现&lt;/strong&gt;，利用&lt;em&gt;纯虚函数必须在派生类中重新实现，但也可以拥有自己的实现&lt;/em&gt; 这一特性来进行实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination) = 0;
    }
    void Airplane::fly(const Airport&amp;amp; destination)
    {
        ... // 默认实现
    }

    class ModelA:public Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination)
        {
            Airport::fly(destination);
        }
    }

    class ModelC:public Airplane
    {
    public:
        virtual void fly(const Airport&amp;amp; destination);
    }
    void ModelC::fly(const Airport&amp;amp; destination)
    {
        ... // 定制实现
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这与上一个方案一模一样，只不过纯虚函数&lt;code&gt;Airplane::fly&lt;/code&gt;替换了独立函数&lt;code&gt;Airplane::defaultFly&lt;/code&gt;。本质上是将 fly 分割为两个基本要素：声明部分表示的接口以及定义部分表现的默认实现。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;普通函数&lt;/strong&gt;
如果成员函数是一个非虚函数，这意味着并不打算在派生类中对其进行重写，&lt;strong&gt;声明非虚函数的目的是为了让派生类继承函数的接口以及一个强制的实现&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;纯虚函数、普通虚函数、非虚函数之间的差异可以让我们准确指定派生类继承的东西，即&lt;strong&gt;只继承接口&lt;/strong&gt;、&lt;strong&gt;继承接口和默认实现&lt;/strong&gt;、或是&lt;strong&gt;继承接口和强制的实现&lt;/strong&gt;。由于不同类型的声明有着不同的意义，当我们声明函数时必须要谨慎选择，避免常犯的两个错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一个错误是将所有的函数声明为非虚函数&lt;/strong&gt;。这使得派生类没有空间进行特殊化，实际上任何一个类只要是被用来作为基类，都会拥有若干的虚函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二个错误是将所有成员函数声明为虚函数&lt;/strong&gt;。在接口类中这样做是正确的(item37)，但是某些不应该在派生类中被重新定义的函数应该声明为非虚函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口继承和实现继承不同。在 public 继承中，派生类总是继承基类的接口。&lt;/li&gt;
&lt;li&gt;纯虚函数只具体指定接口继承。&lt;/li&gt;
&lt;li&gt;普通虚函数指定接口继承以及默认的实现继承。&lt;/li&gt;
&lt;li&gt;非虚函数指定接口继承以及强制性实现继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item35-考虑-virtual-函数的替代方法&#34;&gt;item35 考虑 virtual 函数的替代方法&lt;/h2&gt;
&lt;p&gt;假如我们在设计一个游戏软件，打算为游戏中的角色设计一个继承体系，提供一个&lt;code&gt;healthValue&lt;/code&gt;成员函数来表示游戏角色的健康状态。最直接的做法就是声明一个 virtual 函数&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class GameCharacter
    {
    public:
        virtual int healthValue() const; // 返回角色的健康状态值
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中提供了一个普通的虚函数，这意味着提供了一个默认的实现。这种设计方式简单明白，所以一般都不会去考虑其他的替代设计。但事实上，更好的设计方法是存在的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NVI 可以实现模板方法模式，用非虚函数来调用更加封装的虚函数&lt;/li&gt;
&lt;li&gt;用函数指针代替虚函数，实现策略模式&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;std::function&lt;/code&gt;实现策略模式，可以支持兼容目标函数签名的可调用对象&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;通过 NVI 实现模板方法模式&lt;/strong&gt;
所谓的 NVI(non-virtual interface)，就是将所有的虚函数声明为 private，然后通过一个 public non-virtual 函数来调用该 virtual 函数，我们把这个 public 函数称为 virtual 函数的&lt;strong&gt;包装器(wrapper)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class GameCharacter
    {
    public:
        int healthValue() const
        {
            // do sth before
            int retValue = doHealthValue();
            // do sth after
            return retValue;
        }
    private:
        virtual int doHealthValue() const // 派生类可以重新实现该方法
        {...}
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码表示的就是 NVI 方法，它是&lt;strong&gt;模板方法设计模式&lt;/strong&gt;的一种独特表现形式。NVI 方法的一个优点是可以在调用&lt;code&gt;doHealthValue&lt;/code&gt;函数前后设置一些上下文的工作，比如给互斥量加锁/解锁、验证前置条件/后置条件、类的不变式等。
上述代码中&lt;code&gt;doHealthBalue&lt;/code&gt;在派生类中是无法访问的，但是派生类中却对其进行了重新定义。虽然看着有些矛盾，但是 C++中支持&lt;strong&gt;在派生类中重新定义继承而来的 private virtual 函数&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;通过函数指针实现策略模式&lt;/strong&gt;
NVI 方法对于 public virtual 函数来说只是一个简单的替代方案，事实上我们可以完全将&lt;code&gt;healthValue&lt;/code&gt;完全独立出来，让它不受角色的影响，只在构造函数时将该函数作为参数传入。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class GameCharacter; // 前置声明
    int defaultHealthCalc(const GameCharacter&amp;amp; gc); // 默认的计算方法
    class GameCharacter //
    {
    public:
        typedef int (*HealthCalcFunc)(const GameCharacter&amp;amp; gc); // 声明一个函数指针
        explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc): // 传入函数指针
        healthFunc(hcf){}
        int healthValue() const
        {
            return healthFunc(*this);
        }
        ...
    private:
        HealthCalcFunc healthFunc;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码就是一个常见的&lt;strong&gt;策略设计模式&lt;/strong&gt;的简单应用。相较于 public virtual 函数，它提供了一些设计的灵活性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个角色类的不同对象可以有不同的&lt;code&gt;healthCalcFunc&lt;/code&gt;，只需要在构造时传入不同的策略就可实现。&lt;/li&gt;
&lt;li&gt;角色的&lt;code&gt;healthCalcFunc&lt;/code&gt;可以动态待变，只需要提供一个&lt;code&gt;setHealthCalclator&lt;/code&gt;成员方法即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class EvilBadGuy:public GameCharacter
    {
    public:
        explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc)
        :GameCharacter(hcf)
        {...}
        ...
    }
    int loseHealthQuickly(const GameCharacter&amp;amp;); // 计算方法1
    int loseHealthSlowly(const GameCharacter&amp;amp;);  // 计算方法2

    EvilBadGuy ebg1(loseHealthQuickly); // 相同类型的角色设置不同的计算方法
    EvilBadGuy ebg2(loseHealthSlowly);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用外部函数实现了策略模式，但因为&lt;code&gt;healthCalcFunc&lt;/code&gt;是外部函数，这就意味着其无法访问类的私有成员。一般来说，解决方法是：&lt;strong&gt;弱化 class 的封装&lt;/strong&gt;，或者&lt;strong&gt;为实现提供 public 成员&lt;/strong&gt;。两种方案的选择需要根据实际问题来进行权衡。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;通过 std::function 实现策略模式&lt;/strong&gt;
事实上，通过函数指针来实现策略模式过于死板，我们完全可以使用&lt;code&gt;std::function&lt;/code&gt;对象来替代函数指针。&lt;code&gt;std::function&lt;/code&gt;是一种&lt;strong&gt;通用的多态函数包装器&lt;/strong&gt;，它是一个对象，这就意味它可以保存任意一种类型兼容的可调用实体(callable entity)，如函数对象，成员函数指针，lambda 表达式等。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class GameCharacter; // 前置声明
    int defaultHealthCalc(const GameCharacter&amp;amp; gc); // 默认的计算方法
    class GameCharacter //
    {
    public:
        typedef istd::function&amp;lt;int (const GameCharacter&amp;amp;)&amp;gt; HealthCalcFunc; // 使用std::function
        explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):
        healthFunc(hcf){}
        int healthValue() const
        {
            return healthFunc(*this);
        }
        ...
    private:
        HealthCalcFunc healthFunc;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和使用函数指针的不同在于，上述代码用&lt;code&gt;std::function&lt;/code&gt;声明了一个目标签名式(target signature)，表示接受一个指向&lt;code&gt;const GameCharacter&lt;/code&gt;的引用作为参数，并返回一个 int。声明的&lt;code&gt;HealthCalcFunc&lt;/code&gt;可以持有任何与签名式兼容的可调用实体。所谓的兼容，意思是这个可调用实体的参数可以被隐式转换为&lt;code&gt;const GameCharacter&lt;/code&gt;，其返回类型可以被隐式转换为 int。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;calcHealth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameCharacter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 健康计算方法，返回值为short
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HealthCalculator&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameCharacter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GameLevel&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;health&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameCharacter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 成员函数，返回值为float
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EvilBadGuy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameCharacter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EyeCandyCharacter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameCharacter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{...}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;EvilBadGuy&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ebg1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;calcHealth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 人物1，使用某个函数计算健康值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;EyeCandyCharacter&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ecc1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthCalculator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 人物2，使用某个函数对象计算健康值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;GameLevel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentLevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;EvilBadGuy&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ebg2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GameLevel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;health&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentLevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 人物3，使用某个成员函数计算健康值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码中，无论时类型兼容的函数、函数对象还是成员函数，都可以用来初始化一个&lt;code&gt;GameCharacter&lt;/code&gt;对象。同时，需要注意的是&lt;code&gt;std::bind&lt;/code&gt;的用法。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;经典策略模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;忽略上面关于策略模式的实现，我们讨论更一般的实现方式。经典的策略模式会将健康计算函数设计成一个分离的继承体系中 virtual 成员函数，其 UML 设计图为:&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/book/Effective-CPP/effective_cpp35_strategy_pattern.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如图所示，&lt;code&gt;GameCharacter&lt;/code&gt;是某个继承体系的根类，体系中的&lt;code&gt;EvilBadGuy&lt;/code&gt;和&lt;code&gt;EyeCandyCharacter&lt;/code&gt;都是派生类，&lt;code&gt;HealthCalcFunc&lt;/code&gt;是另一个继承体系的根类，体系中的&lt;code&gt;SlowHealthLoser&lt;/code&gt;和&lt;code&gt;FastHealthLoser&lt;/code&gt;都是派生类，每个&lt;code&gt;GameCharacter&lt;/code&gt;对象都包含一个指针，用来指向一个来自&lt;code&gt;HealthCalcFunc&lt;/code&gt;继承体系的对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GameCharacter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HealthCalcFunc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;calc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameCharacter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;HealthCalcFunc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defaultHealthCalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GameCharacter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;explicit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameCharacter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthCalcFunc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;phcf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;defaultHealthCalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pHealthCalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;phcf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;healthValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pHealthCalc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;calc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;HealthCalcFunc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pHealthCalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;熟悉策略模式的人一眼就能看出上述代码是策略模式的经典实现，其可以通过继承&lt;code&gt;HealthCalcFunc&lt;/code&gt;很方便的生成新的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virtual 函数的替代方案包括：NVI 方法以及上面提到的三种策略设计模式。&lt;/li&gt;
&lt;li&gt;将功能提取到外部函数的缺点是非成员函数无法访问类的私有成员。&lt;/li&gt;
&lt;li&gt;std::function 对象的行为就像一般的函数指针，但是其可以接受任何类型兼容的可调用实体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item36-不要重写继承来的非虚函数&#34;&gt;item36 不要重写继承来的非虚函数&lt;/h2&gt;
&lt;p&gt;例如,类 D 以 public 的形式继承了类 B，类 B 定义了一个 public 成员函数 mf：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class B
    {
    public:
        void mf();
        ...
    }
    class D:public B
    {
    public:
        void mf(); // 覆盖率B::mf()
        ...
    }

    //
    D x;
    B* pB = &amp;amp;x;
    D* pD = &amp;amp;x;
    pB-&amp;gt;mf(); // 调用的是B::mf
    pD-&amp;gt;mf(); // 调用的是D::mf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，指针&lt;code&gt;pB&lt;/code&gt;和&lt;code&gt;pD&lt;/code&gt;都指向的是派生类的对象，并通过对象来调用成员函数 mf。两者指向的对象相同，调用的函数也相同，但是其功能却不一样。原因是：非虚函数 B::mf 和 D::mf 都是&lt;strong&gt;静态绑定&lt;/strong&gt;，即函数依赖于对象的静态类型，发生在编译期。意思是&lt;code&gt;pB&lt;/code&gt;是一个类型为 B 的指针，通过&lt;code&gt;pB&lt;/code&gt;调用的非虚函数永远都是类 B 中定义的版本。
另一方面，虚函数则是&lt;strong&gt;动态绑定&lt;/strong&gt;的，发生在运行期，函数依赖于动态类型。由于&lt;code&gt;pB&lt;/code&gt;和&lt;code&gt;pD&lt;/code&gt;指向的都是类型为 D 的对象，所以两者调用的都是对象 x 中的虚函数。&lt;/p&gt;
&lt;p&gt;事实上，在派生类中重新定义基类的非虚函数在设计上是矛盾的。基类中声明的非虚函数意味着适用于基类对象的特性同样适用于派生类对象。如果重新定义了非虚函数，那么派生类和基类就不再是 is-a 的关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在任何情况下都不要去重新定义一个继承来的非虚函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item37-不要重定义通过继承得到的默认参数值&#34;&gt;item37 不要重定义通过继承得到的默认参数值&lt;/h2&gt;
&lt;p&gt;我们将需要继承的函数分为两类：&lt;strong&gt;virtual 函数&lt;/strong&gt;和&lt;strong&gt;non-virtual 函数&lt;/strong&gt;，对继承来的 non-virtual 函数进行重新定义是错误的(item36)，所以本节主要讨论&lt;strong&gt;继承一个带有默认参数的 virtual 函数&lt;/strong&gt;。不要重新定义继承来的默认参数值成立的原因是，&lt;strong&gt;虽然虚函是动态绑定的，但是默认参数是静态绑定的，只有动态绑定的东西才应该被重写&lt;/strong&gt;。静态绑定是在编译期决定的，又称前期绑定；动态绑定是在运行期决定的，又称后期绑定。&lt;/p&gt;
&lt;p&gt;对象的&lt;strong&gt;静态类型&lt;/strong&gt;，就是它在程序中被声明时采用的类型。对于以下的 class 继承体系：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Shape
    {
    public:
        enum ShapeColor{Red,Green,Blue};
        // 提供一个绘制函数
        virtual void draw(ShapeColor color=Red) const=0;
        ...
    }

    class Rectangle:public Shape
    {
    public:
        // 给派生类赋予不同的默认参数值
        virtual void draw(ShapeColor color=Green) const;
        ...
    }
    class Circle:public Shape
    {
    public:
        virtual void draw(ShapeColor color) const;
    }

    // 考虑指针
    Shape* ps;                 // 静态类型为Shape*
    Shape* pc = new Circle;    // 静态类型为Shape*
    Shape* pr = new Rectangle; // 静态类型为Shape*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，&lt;code&gt;ps&lt;/code&gt;，&lt;code&gt;pc&lt;/code&gt;和&lt;code&gt;pr&lt;/code&gt;都声明为 Shape 类型的指针，无论它们指向什么对象，它们的动态类型都是&lt;code&gt;Shape*&lt;/code&gt;。
对象的&lt;strong&gt;动态类型&lt;/strong&gt;就是当前指向的对象的类型，也就是说动态类型决定了一个对象会有什么行为。在上述代码中，&lt;code&gt;pc&lt;/code&gt;的动态类型是&lt;code&gt;Circle*&lt;/code&gt;，&lt;code&gt;pr&lt;/code&gt;的动态类型是&lt;code&gt;Rectangle*&lt;/code&gt;，&lt;code&gt;pc&lt;/code&gt;没有动态类型，因为其没有指向任何对象。virtual 函数就是通过动态绑定来决定在运行时调用哪一个函数实现代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    pc-&amp;gt;draw(Shape::Red); // 调用Circle::draw(Shape::Red)
    pr-&amp;gt;draw(Shape::Red); // 调用Rectangle::draw(Shape::Red)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;virtual 函数是动态绑定的，而默认参数值却是静态绑定的。这就意味着我们可能会调用一个定义于派生类中的 virtual 函数的同时，却使用了基类为其指定的默认参数值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    pr-&amp;gt;draw(); // 调用Rectangle::draw(Shape::Red)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，&lt;code&gt;pr&lt;/code&gt;的动态类型是&lt;code&gt;Rectangle*&lt;/code&gt;，所以调用的是 Rectangle 的函数实现，&lt;code&gt;Rectangle::draw()&lt;/code&gt;的默认参数是&lt;code&gt;Green&lt;/code&gt;。但是&lt;code&gt;pr&lt;/code&gt;的静态类型是&lt;code&gt;Shape*&lt;/code&gt;，所以实际调用的默认参数值来自于基类 Shape 而不是派生类 Rectangle。
C++之所以选择这样的方式来运作是&lt;strong&gt;为了保证运行时效率&lt;/strong&gt;。如果默认参数值是动态绑定，编译器就必须要通过某种方法在运行期为 virtual 函数决定适当的默认参数值，这比直接在编译期的机制更加缓慢和复杂。&lt;/p&gt;
&lt;p&gt;解决矛盾的方法就是考虑 virtual 函数的替代设计。item35 中提供了 virtual 函数的替代设计，其中之一是 NVI(non-virtual interface)方法：让基类中的 public 非虚函数调用 private 虚函数，后者可以被派生类重定义。在这里，我们可以让非虚函数指定默认参数值，private 虚函数负责功能实现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Shape
    {
    public:
        enum ShapeColor{Red,Green,Blue};
        void draw(ShapeColor color=Red) const
        {
            doDraw(color);
        }
    private:
        virtual void doDraw(ShapeColor color) const =0;

    }
     class Rectangle:public Shape
     {
    public:
        ...
    private:
        virtual void doDraw(ShapeColor color) const;
     }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，由于非虚函不应该在派生类中被重新定义，所以这个设计可以很清楚地使得 draw 函数的 color 默认值参数总是为 Red。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要在派生类中重新定义继承得到的默认参数值，因为默认参数值是静态绑定的，而 virtual 函数是动态绑定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item38-通过组合塑造-has-a-或-use-a-关系&#34;&gt;item38 通过组合塑造 has-a 或 use-a 关系&lt;/h2&gt;
&lt;p&gt;组合是类型之间的一种关系，当某种类型的对象内包含其他类型的对象，就是组合关系。如下面的代码中，Person 对象由 std::string，Address，PhoneNumber 组成。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Address{...}
    class PhoneNumber{...}

    class Person
    {
    public:
        ...
    private:
        std::string name;
        Address address;
        PhoneNumber faxNumber;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;item32 中提到，public 继承有 is-a 的意义。组合也有它自己的意义，事实上它有两种意义，即&lt;strong&gt;has-a&lt;/strong&gt;(包含)意义和&lt;strong&gt;use-a&lt;/strong&gt;(依赖)意义。这是因为我们在软件中会处理两个不同的领域(domain)，程序中的一些对象对应现实世界中的某些事物，如人、汽车、视频画面等等，这样的对象属于应用领域；其他的对象则只是实现工具，如缓冲区、互斥器、搜索树等等，这些对象属于实现领域。当组合发生于应用域的对象之间，表现出&lt;strong&gt;has-a&lt;/strong&gt;的关系；当组合发生于实现域，表现出的就是&lt;strong&gt;use-a&lt;/strong&gt;的关系。&lt;/p&gt;
&lt;p&gt;上面的 Person 类展示了&lt;strong&gt;has-a&lt;/strong&gt;的关系，Person 有一个名称，一个地址以及电话号码。&lt;strong&gt;has-a&lt;/strong&gt;和&lt;strong&gt;is-a&lt;/strong&gt;之间不难区分，比较难以区分的是&lt;strong&gt;is-a&lt;/strong&gt;和&lt;strong&gt;use-a&lt;/strong&gt;关系。假设要使用一个 list 对象来实现一个 Set 对象，我们可能会想到说让 Set 类继承 List 类，这样可以使用 List 的一些现有的属性和方法。但是 list 中允许包含重复元素，set 中不包含重复元素，这样 set 和 list 就不是 is-a 的关系，不适合用 public 继承来塑造。正确的方法是，Set 对象通过使用一个 List 对象来实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    template&amp;lt;class T&amp;gt;
    class Set
    {
    public:
        bool member(const T&amp;amp; item) const;
        bool insert(const T&amp;amp; item);
        voie remove(const T&amp;amp; item);
        std::size_t size() const;
    private:
        std::list&amp;lt;T&amp;gt; rep; // 用来描述set的数据
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类 Set 的成员函数可依赖 List 以及标准库来完成。一个类型使用另一个类型的属性和方法来实现自己的功能，塑造出的就是&lt;strong&gt;use-a&lt;/strong&gt;的关系。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    bool Set&amp;lt;T&amp;gt;::member(const T&amp;amp; item) const
    {
        return std::find(rep.begin(),rep.end())!=rep.end();
    }
    template&amp;lt;typename T&amp;gt;
    void Set&amp;lt;T&amp;gt;::insert(const T&amp;amp; item)
    {
        if (!member(item))
            rep.push_back(item);
    }

    template&amp;lt;typename T&amp;gt;
    void Set&amp;lt;T&amp;gt;::remove(const T&amp;amp; item)
    {
        typename std::list&amp;lt;T&amp;gt;::iterator it =               // see Item 42 for info on
            std::find(rep.begin(), rep.end(), item);       // &amp;#34;typename&amp;#34; here
        if (it != rep.end())
            rep.erase(it);
    }

    template&amp;lt;typename T&amp;gt;
    std::size_t Set&amp;lt;T&amp;gt;::size() const
    {
        return rep.size();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;综上，&lt;strong&gt;has-a&lt;/strong&gt;关系是将一个类当作另一个类的属性；&lt;strong&gt;use-a&lt;/strong&gt;关系是在一个类中使用了另一个类的对象的成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合和 public 继承的意义完全不同。&lt;/li&gt;
&lt;li&gt;在应用域，组合意味着 has-a 的关系，即一个类型中包含了另一个类型的对象作为属性。&lt;/li&gt;
&lt;li&gt;在实现域，组合意味着 use-a 的关系，即一个类使用了另一个类的数据和方法来实现自生的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item39-慎用-private-继承&#34;&gt;item39 慎用 private 继承&lt;/h2&gt;
&lt;p&gt;item32 中提出了在 C++中 public 继承描述的是 is-a 的关系，这是因为编译器会在必要的时候将派生类对象隐式转换为基类对象。我们考虑用 private 来替换 item32 中的 public 继承：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Person{...}
    class Student:private Person{...}; // 私有继承
    void eat(const Person&amp;amp; p); //

    Person p;  // p is a Person
    Student s; // s is a Student
    eat(p);    // 正确
    eat(s);    // 错误
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，&lt;code&gt;Person&lt;/code&gt;对象可以正确调用，但是&lt;code&gt;Student&lt;/code&gt;对象不能正确调用。这就是 private 继承和 public 继承的不同之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 private 继承中，编译器不会自动将一个派生类对象转换为一个基类对象；&lt;/li&gt;
&lt;li&gt;由 private 从基类中继承来的所有成员，包括 public 和 protected，都会变成 private 属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;在 private 继承中，派生类继承了基类的实现，没有继承基类的接口，这就意味着&lt;strong&gt;private 继承只是一种软件实现的方式，与软件设计无关&lt;/strong&gt;。private 继承和 item38 中的组合一样，都可以表示 use-a 的关系。我们如何在两者之间进行取舍呢？答案很简单：尽可能使用组合，必要时才使用 private 继承。&lt;/p&gt;
&lt;p&gt;我们设计一个 Widget 类，让它记录每个成员函数被调用的次数。为了完成这个任务，我们还需要设计一个定时器：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Timer
    {
    public:
        explicit Timer(int tickFrequency);
        virtual void onTick() const;
    }

    class Widget::private Timer
    {
    private:
        virtual void onTick() const;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，为了能在 Widget 中重新定义 Timer 的虚函数，Widget 必须继承 Timer。但是 public 继承不适用于此种情况，因为 Widget 与 Timer 不是 is-a 的关系。因此必须使用 private 方式继承 Timer，这样 Timer 中的 public 函数&lt;code&gt;onTicker()&lt;/code&gt;在 Widget 中变成&lt;code&gt;private&lt;/code&gt;，这样既可以在 Widget 中实现对函数的重定义，又可以避免 public 继承可能造成的接口误用(item18)。上述代码的功能也可以通过组合的方式实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Widget
    {
    private:
        class WidgetTimer:public Timer
        {
        public:
            virtual void onTick() const;
            ...
        }
        WidgetTimer timer;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码的组合方式虽然比 private 继承略微复杂一点，但是实现了相同的功能。建议尽可能使用组合替代 private 继承的原因，可以考虑以下两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们需要将 Widget 设计为一个基类，但是我们不想在派生类中重新定义&lt;code&gt;onTick&lt;/code&gt;。如果 Widget 与 Timer 之间的关系是继承，这样的设计是无法实现的(item35，派生类中需要重新定义虚函数，即使不会使用)。但是如果 WidgetTimer 是 Widget 中的一个 private 成员，Widget 的派生类将无法获得 WidgetTimer 对象的值，就无法继承或重新定义它的虚函数。&lt;/li&gt;
&lt;li&gt;最小化 Widget 的编译依赖性。如果 Widget 继承了 Timer，那么 Widget 被编译时 Timer 的定义就必须可见，这就意味着 Widget 的定义文件必须要&lt;code&gt;#include Timer.h&lt;/code&gt;。如果将 WidgetTimer 移出 Widget 之外而通过一个指针指向 WidgetTimer 对象，Widget 就可以只需要一个 WidgetTimer 的声明式，不再需要&lt;code&gt;#include&lt;/code&gt;任何与 Timer 相关的东西。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;private 继承的实现非常简单，而且有时只能使用 private 继承：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当派生类需要访问基类中的 protected 成员时。因为对象组合后只能访问 public 成员，而 private 继承可以访问 protected 成员。&lt;/li&gt;
&lt;li&gt;派生类需要重新定义基类中的虚函数时。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;我们考虑一个不带任何数据的空白基类，其对象理论上应该是不使用任何空间的，因为对象中没有任何数据需要存储。但是 C++指定&lt;strong&gt;凡是独立的对象都必须有非零的大小&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class Empty{}
    class HoldsAnInt
    {
    private:
        int x;
        Empty e; // 独立的对象
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码中，&lt;code&gt;Empty&lt;/code&gt;的对象是一个独立对象，编译器会给其分配一个内存，因此会有&lt;code&gt;sizeof(HoldsAnInt) &amp;gt; sizeof(int)&lt;/code&gt;。
如果我们通过使用 private 继承 Empty，这样编译器就不会为其分配空间，因为派生类中的基类成分并不是一个独立对象。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class HoldsAnInt:private Empty
    {
    private:
        int x;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述代码中，&lt;code&gt;sizeof(HoldsAnInt) == sizeof(int)&lt;/code&gt;是成立的，这就是所谓的**EBO(empty base optimization，即空白基类最优化)。如果我们的程序特别在意空间消耗，就可以使用 EBO，而且 EBO 一般只用在单继承中。现实中的类一般都不是空白类，所以这种情况并不多见。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private 继承描述的是 use-a 的关系，但是在编程过程中还是优先使用组合的方式。只有在派生类需要访问基类的 protected 成员，或者需要重新定义继承而来的 virtual 函数时，才使用 private 继承。&lt;/li&gt;
&lt;li&gt;和组合不同，private 继承可以实现空白基类的最优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;item40-慎用多继承&#34;&gt;item40 慎用多继承&lt;/h2&gt;
&lt;p&gt;所谓的多继承，就是一个类有一个以上的基类。这就意味着程序有可能东一个以上的基类中继承相同的名称(如函数，typedef 等)，这会导致&lt;strong&gt;基类名称调用的歧义性&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class A
    {
    public:
        void chechOut();
    }
    class B
    {
    private:
        void checkOut();
    }
    class MP3Player:public A,
                    private B
    {...}

    MP3Player mp;
    mp.checkOut(); // 会发生歧义，无法确定调用的是哪个函数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C++中调用重载函数的规则是：首先确认调用函数的匹配度，找出最佳匹配后才会验证其是否可调用。因此上述代码中对&lt;code&gt;checkOut&lt;/code&gt;的调用是有歧义的，即使一个是 public，另一个是 private，它们的匹配程度是一样的，没有最佳匹配。为了解决歧义性，需要明确指出调用的是哪一个基类的函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    mp.A::checkOut(); // 调用的是A::checkOut()
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;在多继承中，如果基类拥有更高的基类，就有可能导致&lt;strong&gt;菱形继承&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class File{}
    class InputFile:public File{}
    class OutputFile:public File{}
    class IOFile:public InputFile, public OutputFile{}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/book/Effective-CPP/effective_cpp40_inheritence1.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们假设类 File 中有一个成员变量 filename，那么 IOFile 继承下来的 filename 成员变量应该有多少个呢，一个或者两个？事实上，C++两种情况都支持，默认是保存两份数据的方式。如果只需要保存一份，就需要让类 File 称为一个虚基类，这样就需要让所有直接继承 File 类的派生类使用&lt;strong&gt;virtual 继承&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class File{}
    class InputFile:virtual public File{}
    class OutputFile:virtual public File{}
    class IOFile:public InputFile,
                 public OutputFile
    {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/book/Effective-CPP/effective_cpp40_inheritence2.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;C++标准库中包含了一个多重继承体系，名称分别为&lt;code&gt;basic_ios&lt;/code&gt;，&lt;code&gt;basic_istream&lt;/code&gt;，&lt;code&gt;basic_ostream&lt;/code&gt;和&lt;code&gt;basic_iostream&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了保证程序的正确性，我们希望 public 继承都是 virtual。但是，正确性有时候并不是我们唯一需要考虑的。虚继承的实例化的对象要比普通的对象占用更多的空间，访问 virtual 基类的成员变量的速度也比 non-virtual 基类的成员变量要慢。另外，virtual 基类的初始化责任是由继承体系中最底层的派生类来完成的，而且要负责初始化整个继承链上所有虚基类的初始化。&lt;/p&gt;
&lt;p&gt;作者对于 virtual 继承的建议是：第一，尽量不要使用 virtual 基类；第二，如果必须使用 virtual 基类，要避免在其中放置数据变量。这样可以减少因为初始化带来的意想不到的错误。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面提到的不包含数据的虚基类，在 C++中我们称为接口类。item31 中，一个&lt;code&gt;Person&lt;/code&gt;的接口类定义为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class IPerson
    {
    public:
        virtual ~IPerson();
        virtual std::string name() const = 0;
        virtual std::string birthDate() const = 0;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用户只能通过指针或引用来使用 IPerson，因为抽象类无法进行实例化来创建对象。为了创建一个 IPerson 对象，用户可以使用 factory functions(工厂函数，item31)来讲派生自 IPerson 的具体类进行实例化。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    // 工厂函数，根据一个数据库ID创建一个Person对象
    std::shared_ptr&amp;lt;IPerson&amp;gt; makePerson(DatebaseID personIdentifier);
    // 从用户手上获取一个数据库ID
    DatabaseID askUserForDatabaseID();

    DatabaseID id(askUserForDatabaseID());
    std::shared_ptr&amp;lt;IPerson&amp;gt; pp(makePerson(id)); // 创建一个对象支持IPerson接口
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;多继承的一个重要的应用就是：组合 public 继承的接口类和 private 继承的实现类。即：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    class IPerson
    {
    public:
        virtual ~IPerson();
        virtual std::string name() const = 0;
        virtual std::string birthDate() const = 0;
    }
    class DatabaseID{...}
    class PersonInfo  // 包含若干函数，实现IPerson接口
    {
    public:
        explicit PersonInfo(DatabaseID pid);
        virtual ~PersonInfo();
        virtual const char* theName() const;
        virtual const char* theBirthDate() const;
        virtual const char* valueDelimOpen() const;
        virtual const char* valueDelimClose() const;
    }

    class CPerson:public IPerson,private PersonInfo
    {
    public:
        explicit CPerson(DatabaseID pid):PersonInfo(pid){}
        virtual std::string name() const
        {
            return PersonInfo::theName();
        }
        virtual std::string birthDate() const
        {
            return PersonInfo::theBirthDate();
        }
    private:
        const char* valueDelimOpen() const // 重新定义继承来的函数
        {
            return &amp;#34;&amp;#34;;
        }
        const char* valueDelimClose() const // 重新定义继承来的函数
        {
            return &amp;#34;&amp;#34;;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note：总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多继承比单继承复杂，多继承可能导致调用的歧义性以及菱形继承。&lt;/li&gt;
&lt;li&gt;解决菱形继承问题需要用到虚继承，但是虚继承会带来更多的空间消耗和时间消耗，以及复杂的初始化成本。不带数据成员的虚基类是最有价值的。&lt;/li&gt;
&lt;li&gt;多重继承有它的合理用途，即把 public 继承接口类和 private 继承协助实现类结合起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献--资源链接&#34;&gt;参考文献 &amp;amp; 资源链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://harttle.land/2015/08/30/effective-cpp-32.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Effective C++ 32：确保 public 继承是&amp;quot;is a&amp;quot;的关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ctolib.com/docs/sfile/effective-cpp/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Effective C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
