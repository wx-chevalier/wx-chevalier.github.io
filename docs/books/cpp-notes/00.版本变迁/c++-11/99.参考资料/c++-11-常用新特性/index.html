<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
    <meta name="google-site-verification" content="google69a5cccb61297807" />
    <meta name="baidu-site-verification" content="cqmZHEleVh" />
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="C&#43;&#43;11 常用新特性（一） 最近工作中，遇到一些问题，使用 C11 实现起来会更加方便，而线上的生产环境还不支持 C11，于是决定新年开工后，在组内把 C&#43;&#43;11 推广开来，整理以下文档，方便自己查阅，也方便同事快速上手。（对于异步" />

  
  <link rel="alternate" hreflang="zh" href="https://ng-tech.icu/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c&#43;&#43;-11-%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css" integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin="anonymous">
    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.0d97305106da5efa530e28b021b4c580.css" />

  




<script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', "G-40NYXJ8823");
</script>


  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://ng-tech.icu/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c&#43;&#43;-11-%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@wx-chevalier" />
    <meta property="twitter:creator" content="@wx-chevalier" />
  
  <meta property="og:site_name" content="Next-gen Tech Edu" />
  <meta property="og:url" content="https://ng-tech.icu/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c&#43;&#43;-11-%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7/" />
  <meta property="og:title" content="C&#43;&#43; 11 常用新特性 | Next-gen Tech Edu" />
  <meta property="og:description" content="C&#43;&#43;11 常用新特性（一） 最近工作中，遇到一些问题，使用 C11 实现起来会更加方便，而线上的生产环境还不支持 C11，于是决定新年开工后，在组内把 C&#43;&#43;11 推广开来，整理以下文档，方便自己查阅，也方便同事快速上手。（对于异步" /><meta property="og:image" content="https://ng-tech.icu/media/sharing.png" />
    <meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
    
  

  



  

  

  





  <title>C&#43;&#43; 11 常用新特性 | Next-gen Tech Edu</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="08b28a38161649fd227bda6103b1fb63" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">Next-gen Tech Edu</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">Next-gen Tech Edu</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/books-gallery"><span>笔记（万篇）</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#knowledge-map"><span>知识图谱</span></a>
          </li>

          
          

          
          <style>
            .dropdown-item{
              display: inline-flex;
            }
          </style>
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>实验室</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/galaxy-home/gh-craft"><span>Craft 方块世界</span></a>
              
                <a class="dropdown-item" href="/galaxy-home/glossary-cards"><span>3D 知识卡牌</span></a>
              
            </div>
          </li>

          
          

          
          <style>
            .dropdown-item{
              display: inline-flex;
            }
          </style>
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>其他阅读渠道</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="https://zhuanlan.zhihu.com/wxyyxc1992"><img style="width:16px;height:16px;display:inline-block;margin-right:8px" src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png"></img><span>知乎</span></a>
              
                <a class="dropdown-item" href="https://segmentfault.com/blog/wxyyxc1992"><img style="width:16px;height:16px;display:inline-block;margin-right:8px" src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png"></img><span>SegmentFault</span></a>
              
                <a class="dropdown-item" href="https://zhuanlan.zhihu.com/wxyyxc1992"><img style="width:16px;height:16px;display:inline-block;margin-right:8px" src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png"></img><span>掘金</span></a>
              
            </div>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        
        
        <li class="nav-item">
          <a class="nav-link js-search" href="#" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link" href="https://github.com/wx-chevalier" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        

        
        
        
        <div></div>
        
        <style>
        @media only screen and (max-width: 600px) {
          .jimmysong-template {
            display: none!important;
          }
        }
        </style>
        
        <li class="jimmysong-template" style="color: white;font-size: 12px;">
          <a href="https://jimmysong.io" style="color: white">By Jimmy Song's Template</a>
        </li>
      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    




<link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css">
<div class="container-xl docs">
  <div class="row flex-xl-nowrap">
    <div class="docs-sidebar">
      <form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <div class="d-flex">
      <span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">
        
          99.参考资料
        
      </span>
      <span><i class="fas fa-chevron-down"></i></span>
    </div>
  </button>

  
  <button class="form-control sidebar-search js-search d-none d-md-flex">
    <i class="fas fa-search pr-2"></i>
    <span class="sidebar-search-text">搜索...</span>
    <span class="sidebar-search-shortcut">/</span>
  </button>
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  
  
  
  

  
  
    

    
      

      <ul class="nav docs-sidenav">
        <li style="display: inline-flex">
          <a style="cursor: pointer;" onclick="window.history.back()">
            <i class="fas fa-arrow-left pr-1"></i>
            Back
          </a>
          <span>|</span>
          <a href="/books/">
            <i class="fa-solid fa-house" style="margin-right: 4px"></i>
            Books
          </a>
        </li>
      </ul>

      
      
        
          
        
      



  
    
    
    
    
      
    
    

    
    
    
    
    
    <div class="docs-toc-item has-child">
    <div class="parent-node d-flex justify-content-between" onClick="Collapse(&#34;caret-id40fd5b4860e77a4c233741b5a330ee43&#34;)" href="#id40fd5b4860e77a4c233741b5a330ee43" aria-expanded="false" aria-controls="id40fd5b4860e77a4c233741b5a330ee43" aria-hidden="false" data-toggle="collapse">
    
    <a class="d-inline docs-toc-link " href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/">C&#43;&#43; 11</a>
    <a class="nav-toogle d-inline level" aria-hidden="false" data-toggle="collapse" href="#id40fd5b4860e77a4c233741b5a330ee43" aria-expanded="false" aria-controls="id40fd5b4860e77a4c233741b5a330ee43">
    
    <i class="fa-solid fa-angle-down" id="caret-id40fd5b4860e77a4c233741b5a330ee43"></i>
    
    </a>
    
    </div>
    
      
      <ul class="nav docs-sidenav collapse  show " id="id40fd5b4860e77a4c233741b5a330ee43">
      



  
    
    
    
    
      
    
    

    
    
    
    
    
    <div class="docs-toc-item has-child">
    <div class="parent-node d-flex justify-content-between" onClick="Collapse(&#34;caret-ide9792fd18eb298eb3a2c9d3ad1407316&#34;)" href="#ide9792fd18eb298eb3a2c9d3ad1407316" aria-expanded="false" aria-controls="ide9792fd18eb298eb3a2c9d3ad1407316" aria-hidden="false" data-toggle="collapse">
    
    <a class="d-inline docs-toc-link " href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">99.参考资料</a>
    <a class="nav-toogle d-inline level" aria-hidden="false" data-toggle="collapse" href="#ide9792fd18eb298eb3a2c9d3ad1407316" aria-expanded="false" aria-controls="ide9792fd18eb298eb3a2c9d3ad1407316">
    
    <i class="fa-solid fa-angle-down" id="caret-ide9792fd18eb298eb3a2c9d3ad1407316"></i>
    
    </a>
    
    </div>
    
      
      <ul class="nav docs-sidenav collapse  show " id="ide9792fd18eb298eb3a2c9d3ad1407316">
      



  <li class="child level "><a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-anthony-calandra-c&#43;&#43;-11-features/">2022-Anthony Calandra-C&#43;&#43; 11 Features</a></li>




  <li class="child level active"><a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/c&#43;&#43;-11-%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7/">C&#43;&#43; 11 常用新特性</a></li>




  <li class="child level "><a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%AF%8F%E4%B8%AA-c&#43;&#43;%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E7%9A%8410%E4%B8%AA-c&#43;&#43;-11%E7%89%B9%E6%80%A7/">每个 C&#43;&#43;开发人员都应该使用的10个 C&#43;&#43; 11特性</a></li>




  <li class="child level "><a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-11/">深入理解 C&#43;&#43; 11</a></li>




  <li class="child level "><a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86c&#43;&#43;-11-%E6%96%B0%E7%89%B9%E6%80%A7/">吐血整理：C&#43;&#43; 11 新特性</a></li>




  <li class="child level "><a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0c&#43;&#43;-11-%E6%96%B0%E7%89%B9%E6%80%A7/">学习笔记：C&#43;&#43; 11 新特性</a></li>

      
        </ul>
      
    

    
      </div>
    

      
        </ul>
      
    

    
      </div>
    

    
  
</nav>

    </div>

    
    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      
     
      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">目录</a></li>
      </ul>
     

      <nav id="TableOfContents">
  <ul>
    <li><a href="#auto">auto</a></li>
    <li><a href="#decltype">decltype</a></li>
    <li><a href="#拖尾返回类型auto-与-decltype-配合">拖尾返回类型、auto 与 decltype 配合</a></li>
  </ul>

  <ul>
    <li><a href="#基于范围的-for-循环">基于范围的 for 循环</a></li>
  </ul>

  <ul>
    <li><a href="#外部模板">外部模板</a></li>
    <li><a href="#尖括号-">尖括号 “&gt;”</a></li>
    <li><a href="#类型别名模板">类型别名模板</a></li>
    <li><a href="#默认模板参数">默认模板参数</a></li>
  </ul>

  <ul>
    <li><a href="#委托构造">委托构造</a></li>
    <li><a href="#继承构造">继承构造</a></li>
  </ul>

  <ul>
    <li><a href="#stdarray">std::array</a></li>
    <li><a href="#stdforward_list">std::forward_list</a></li>
    <li><a href="#无序容器">无序容器</a></li>
    <li><a href="#元组-stdtuple">元组 std::tuple</a></li>
  </ul>

  <ul>
    <li><a href="#lambda-表达式的基本语法如下">Lambda 表达式的基本语法如下：</a></li>
    <li><a href="#lambda-表达式的大致原理">lambda 表达式的大致原理：</a></li>
    <li><a href="#lambda-表达式是不能被赋值的">lambda 表达式是不能被赋值的：</a></li>
  </ul>

  <ul>
    <li><a href="#stdfunction-简介">std::function 简介</a>
      <ul>
        <li><a href="#member-types">Member types</a></li>
        <li><a href="#member-functions">Member functions</a></li>
      </ul>
    </li>
    <li><a href="#stdfunction-使用">std::function 使用</a></li>
  </ul>

  <ul>
    <li><a href="#转移左值">转移左值</a></li>
  </ul>
</nav>

      
<div class="subscribe-module col-24 mt-1">
    <img src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png" alt="image" title="王下邀月熊的微信公众号"/>
</div>



    </div>
    

    <main class="py-md-3 pl-md-3 docs-content col-xl-8" role="main">

      <article class="article">

          

          <h1>C&#43;&#43; 11 常用新特性</h1>

          <div class="article-style">
            <h1 id="c11-常用新特性一">C++11 常用新特性（一）</h1>
<p>最近工作中，遇到一些问题，使用 C11 实现起来会更加方便，而线上的生产环境还不支持 C11，于是决定新年开工后，在组内把 C++11 推广开来，整理以下文档，方便自己查阅，也方便同事快速上手。（对于异步编程十分实用的 Future/Promise 以及智能指针等，将不做整理介绍，组内使用的框架已经支持并广泛使用了，用的是自己公司参考 boost 实现的版本）</p>
<h1 id="nullptr">nullptr</h1>
<p>nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 <code>((void *)0)</code>，有些则会直接将其定义为 0。</p>
<p>C++ 不允许直接将 <code>void *</code> 隐式转换到其他类型，但如果 NULL 被定义为 ((void *)0)，那么当编译 <code>char *ch = NULL;</code> 时，NULL 只好被定义为 0。</p>
<p>而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span></code></pre></div><p>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。</p>
<p>nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<p>当需要使用 NULL 时候，养成直接使用 nullptr 的习惯。</p>
<h1 id="类型推导">类型推导</h1>
<p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。</p>
<h2 id="auto">auto</h2>
<p>auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。而随着 register 被弃用，对 auto 的语义变更也就非常自然了。</p>
<p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。在以前我们需要这样来书写一个迭代器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="nf">cbegin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="nf">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">itr</span><span class="p">)</span>
</span></span></code></pre></div><p>而有了 auto 之后可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1">// 所以 itr 也应该是 vector&lt;int&gt;::const_iterator 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="nf">cbegin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="nf">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">itr</span><span class="p">);</span>
</span></span></code></pre></div><p>一些其他的常见用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>             <span class="c1">// i 被推导为 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">new</span> <span class="k">auto</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// arr 被推导为 int *
</span></span></span></code></pre></div><p>注意：auto 不能用于函数传参，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="p">,</span> <span class="k">auto</span> <span class="n">y</span><span class="p">);</span>
</span></span></code></pre></div><p>此外，auto 还不能用于推导数组类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"> <span class="k">auto</span> <span class="n">auto_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">auto</span> <span class="n">auto_arr2</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="decltype">decltype</h2>
<p>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">decltype</span><span class="p">(</span><span class="err">表达式</span><span class="p">)</span>
</span></span></code></pre></div><p>在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。</p>
<p>有时候，我们可能需要计算某个表达式的类型，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">decltype</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="n">z</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="拖尾返回类型auto-与-decltype-配合">拖尾返回类型、auto 与 decltype 配合</h2>
<p>你可能会思考，auto 能不能用于推导函数的返回类型。考虑这样一个例子加法函数的例子，在传统 C++ 中我们必须这么写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">R</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。</p>
<p>在 C++11 中这个问题得到解决。虽然你可能马上回反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">decltype</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">);</span>
</span></span></code></pre></div><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="区间迭代">区间迭代</h1>
<h2 id="基于范围的-for-循环">基于范围的 for 循环</h2>
<p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句。
最常用的 std::vector 遍历将从原来的样子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">arr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>变得非常的简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// &amp; 启用了引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">i</span> <span class="p">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="初始化列表">初始化列表</h1>
<p>C++11 提供了统一的语法来初始化任意的对象，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_b</span><span class="p">)</span><span class="o">:</span> <span class="nf">a</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="nf">b</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="nl">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">};</span>    <span class="c1">// 统一的初始化语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">B</span> <span class="n">b</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">};</span>
</span></span></code></pre></div><p>C++11 还把初始化列表的概念绑定到了类型上，并将其称之为<code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Magic</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Magic</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Magic</span> <span class="n">magic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</span></span></code></pre></div><h1 id="模板增强">模板增强</h1>
<h2 id="外部模板">外部模板</h2>
<p>传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。</p>
<p>C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span> <span class="n">class</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span>            <span class="c1">// 强行实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="n">template</span> <span class="n">class</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// 不在该编译文件中实例化模板
</span></span></span></code></pre></div><h2 id="尖括号-">尖括号 “&gt;”</h2>
<p>在传统 C++ 的编译器中，<code>&gt;&gt;</code>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">wow</span><span class="p">;</span>
</span></span></code></pre></div><p>这在传统 C 编译器下是不能够被编译的，而 C11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。</p>
<h2 id="类型别名模板">类型别名模板</h2>
<p>在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span> <span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">SuckType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">U</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SuckType</span><span class="p">()</span><span class="o">:</span><span class="nf">a</span><span class="p">(</span><span class="n">value</span><span class="p">),</span><span class="nf">b</span><span class="p">(</span><span class="n">value</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span> <span class="kr">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">SuckType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">NewType</span><span class="p">;</span> <span class="c1">// 不合法
</span></span></span></code></pre></div><p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">NewType</span> <span class="o">=</span> <span class="n">SuckType</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// 合法
</span></span></span></code></pre></div><h2 id="默认模板参数">默认模板参数</h2>
<p>我们可能定义了一个加法函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但在使用时发现，要使用 add，就必须每次都指定其模板参数的类型。</p>
<p>在 C++11 中提供了一种便利，可以指定模板的默认参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="构造函数">构造函数</h1>
<h2 id="委托构造">委托构造</h2>
<p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Base</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">value1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="nf">Base</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 委托 Base() 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">value2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="继承构造">继承构造</h2>
<p>在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。</p>
<p>假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">A</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">A</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...等等系列的构造函数版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="err">；</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nl">B</span><span class="p">:</span><span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="nf">A</span><span class="p">(</span><span class="n">i</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">B</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="nf">A</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">i</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">B</span><span class="p">(</span><span class="n">folat</span> <span class="n">f</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">:</span><span class="nf">A</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//......等等好多个和基类构造函数对应的构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="err">；</span>
</span></span></code></pre></div><p>C++11 的继承构造：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">A</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">A</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...等等系列的构造函数版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="err">；</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nl">B</span><span class="p">:</span><span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">using</span> <span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//关于基类各构造函数的继承一句话搞定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="err">；</span>
</span></span></code></pre></div><p>如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。</p>
<h1 id="heading"></h1>
<h1 id="新增容器">新增容器</h1>
<h2 id="stdarray">std::array</h2>
<p>std::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。</p>
<p>std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array 只需指定其类型和大小即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">arr</span><span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// 非法, 数组大小参数必须是常量表达式
</span></span></span></code></pre></div><p>当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// C 风格接口传参
</span></span></span><span class="line"><span class="cl"><span class="c1">// foo(arr, arr.size());           // 非法, 无法隐式转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">.</span><span class="nf">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="nf">data</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="nf">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 `std::sort`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="nf">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="nf">end</span><span class="p">());</span>
</span></span></code></pre></div><h2 id="stdforward_list">std::forward_list</h2>
<p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。</p>
<p>和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p>
<h2 id="无序容器">无序容器</h2>
<p>C++11 引入了两组无序容器：
<code>std::unordered_map/std::unordered_multimap</code>和 <code>std::unordered_set/std::unordered_multiset</code>。</p>
<p>无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。</p>
<h2 id="元组-stdtuple">元组 std::tuple</h2>
<p>元组的使用有三个核心的函数：</p>
<p><code>std::make_tuple</code>: 构造元组
<code>std::get</code>: 获得元组某个位置的值
<code>std::tie</code>: 元组拆包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">get_student</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="nf">make_tuple</span><span class="p">(</span><span class="mf">3.8</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#34;张三&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="nf">make_tuple</span><span class="p">(</span><span class="mf">2.9</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#34;李四&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="nf">make_tuple</span><span class="p">(</span><span class="mf">1.7</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="s">&#34;王五&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="nf">make_tuple</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="s">&#34;null&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果只写 0 会出现推断错误, 编译失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">student</span> <span class="o">=</span> <span class="nf">get_student</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ID: 0, &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="s">&#34;GPA: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">student</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="s">&#34;成绩: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">student</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="s">&#34;姓名: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">student</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">gpa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">grade</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 元组进行拆包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="nf">tie</span><span class="p">(</span><span class="n">gpa</span><span class="p">,</span> <span class="n">grade</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_student</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ID: 1, &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="s">&#34;GPA: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">gpa</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="s">&#34;成绩: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">grade</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="s">&#34;姓名: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>合并两个元组，可以通过 std::tuple_cat 来实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">new_tuple</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="nf">tuple_cat</span><span class="p">(</span><span class="nf">get_student</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="nf">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span></span></code></pre></div><h1 id="正则表达式">正则表达式</h1>
<p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p>
<ol>
<li>
<p>检查一个串是否包含某种形式的子串；</p>
</li>
<li>
<p>将匹配的子串替换；</p>
</li>
<li>
<p>从某个串中取出符合条件的子串。</p>
</li>
</ol>
<p>C++11 提供的正则表达式库操作 std::string 对象，对模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。</p>
<p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式：</p>
<p>[a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个及以上小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 . 转义后则表示匹配字符 . ，最后的 txt 表示严格匹配 txt 这三个字母。因此这个正则表达式的所要匹配的内容就是文件名为纯小写字母的文本文件。
std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;regex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fnames</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;foo.txt&#34;</span><span class="p">,</span> <span class="s">&#34;bar.txt&#34;</span><span class="p">,</span> <span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;a0.txt&#34;</span><span class="p">,</span> <span class="s">&#34;AAA.txt&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在 C++ 中 `\` 会被作为字符串内的转义符，为使 `\.` 作为正则表达式传递进去生效，需要对 `\` 进行二次转义，从而有 `\\.`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">regex</span> <span class="nf">txt_regex</span><span class="p">(</span><span class="s">&#34;[a-z]+</span><span class="se">\\</span><span class="s">.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">fname</span><span class="p">:</span> <span class="n">fnames</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fname</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="nf">regex_match</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">txt_regex</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results，在标准库中， std::smatch 被定义为了 std::match_results，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">regex</span> <span class="nf">base_regex</span><span class="p">(</span><span class="s">&#34;([a-z]+)</span><span class="se">\\</span><span class="s">.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">smatch</span> <span class="n">base_match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">fname</span><span class="p">:</span> <span class="n">fnames</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="nf">regex_match</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">base_match</span><span class="p">,</span> <span class="n">base_regex</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// sub_match 的第一个元素匹配整个字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sub_match 的第二个元素匹配了第一个括号表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">base_match</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">base</span> <span class="o">=</span> <span class="n">base_match</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">str</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sub-match[0]: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">base_match</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fname</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; sub-match[1]: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">base</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>以上两个代码段的输出结果为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">foo.txt: <span class="m">1</span>
</span></span><span class="line"><span class="cl">bar.txt: <span class="m">1</span>
</span></span><span class="line"><span class="cl">test: <span class="m">0</span>
</span></span><span class="line"><span class="cl">a0.txt: <span class="m">0</span>
</span></span><span class="line"><span class="cl">AAA.txt: <span class="m">0</span>
</span></span><span class="line"><span class="cl">sub-match<span class="o">[</span>0<span class="o">]</span>: foo.txt
</span></span><span class="line"><span class="cl">foo.txt sub-match<span class="o">[</span>1<span class="o">]</span>: foo
</span></span><span class="line"><span class="cl">sub-match<span class="o">[</span>0<span class="o">]</span>: bar.txt
</span></span><span class="line"><span class="cl">bar.txt sub-match<span class="o">[</span>1<span class="o">]</span>: bar
</span></span></code></pre></div><h1 id="语言级线程支持">语言级线程支持</h1>
<p>std::thread<br>
std::mutex/std::unique_lock<br>
std::future/std::packaged_task<br>
std::condition_variable<br></p>
<h1 id="c11-常用新特性二">C++11 常用新特性(二）</h1>
<h1 id="lambda-表达式">Lambda 表达式</h1>
<p>Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。</p>
<h2 id="lambda-表达式的基本语法如下">Lambda 表达式的基本语法如下：</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">[</span> <span class="n">caputrue</span> <span class="p">]</span> <span class="p">(</span> <span class="n">params</span> <span class="p">)</span> <span class="n">opt</span> <span class="o">-&gt;</span> <span class="n">ret</span> <span class="p">{</span> <span class="n">body</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div><ol>
<li>
<p>capture 是捕获列表；</p>
</li>
<li>
<p>params 是参数表；(选填)</p>
</li>
<li>
<p>opt 是函数选项；可以填<code>mutable</code>,<code>exception</code>,<code>attribute</code>（选填）</p>
</li>
</ol>
<ul>
<li>
<p>mutable 说明 lambda 表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的 non-const 方法。</p>
</li>
<li>
<p>exception 说明 lambda 表达式是否抛出异常以及何种异常。</p>
</li>
<li>
<p>attribute 用来声明属性。</p>
</li>
</ul>
<ol>
<li>ret 是返回值类型（拖尾返回类型）。(选填)</li>
<li>body 是函数体。</li>
</ol>
<p>捕获列表：lambda 表达式的捕获列表精细控制了 lambda 表达式能够访问的外部变量，以及如何访问这些变量。</p>
<ol>
<li>
<p>[]不捕获任何变量。</p>
</li>
<li>
<p>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</p>
</li>
<li>
<p>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，<strong>且被捕获的量在 lambda 表达式被创建时拷贝，而非调用时才拷贝</strong>。如果希望 lambda 表达式在调用时能即时访问外部变量，我们应当用引用方式捕获。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nf">f</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       <span class="c1">//输出0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nf">f</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>       <span class="c1">//输出1
</span></span></span></code></pre></div><ol>
<li>
<p>[=,&amp;foo]按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</p>
</li>
<li>
<p>[bar]按值捕获 bar 变量，同时不捕获其他变量。</p>
</li>
<li>
<p>[this]捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。<strong>如果已经使用了&amp;或者=，就默认添加此选项</strong>。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="n">i_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">         <span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i_</span><span class="p">;</span> <span class="p">};</span>                   <span class="c1">//error,没有捕获外部变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">auto</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i_</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>          <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i_</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>        <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">auto</span> <span class="n">x4</span> <span class="o">=</span> <span class="p">[</span><span class="n">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i_</span><span class="p">;</span> <span class="p">};</span>               <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">auto</span> <span class="n">x5</span> <span class="o">=</span> <span class="p">[</span><span class="n">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i_</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>       <span class="c1">//error,没有捕获x,y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">auto</span> <span class="n">x6</span> <span class="o">=</span> <span class="p">[</span><span class="n">this</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i_</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>     <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">auto</span> <span class="n">x7</span> <span class="o">=</span> <span class="p">[</span><span class="n">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i_</span><span class="o">++</span><span class="p">;</span> <span class="p">};</span>             <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span> <span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>                         <span class="c1">//error,没有捕获外部变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">++</span> <span class="p">};</span>                      <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>                        <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f4</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="p">};</span>                       <span class="c1">//error,a是以复制方式捕获的，无法修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f5</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span> <span class="p">};</span>                      <span class="c1">//error,没有捕获变量b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f6</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">++</span><span class="p">);</span> <span class="p">};</span>                <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f7</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">++</span><span class="p">);</span> <span class="p">};</span>                <span class="c1">//OK
</span></span></span></code></pre></div><p>注意 f4，虽然<strong>按值捕获的变量</strong>值均复制一份存储在 lambda 表达式变量中，修改他们也并不会真正影响到外部，但<strong>我们却仍然无法修改它们</strong>。如果希望去修改按值捕获的外部变量，需要显示指明 lambda 表达式为 mutable。<strong>被 mutable 修饰的 lambda 表达式就算没有参数也要写明参数列表。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="p">};</span>                <span class="c1">//error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="k">mutable</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="p">};</span>       <span class="c1">//OK
</span></span></span></code></pre></div><p>原因：<strong>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”</strong>。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照 C++标准，<strong>lambda 表达式的 operator()默认是 const 的</strong>，一个 const 成员函数是无法修改成员变量的值的。<strong>而 mutable 的作用，就在于取消 operator()的 const。</strong></p>
<h2 id="lambda-表达式的大致原理">lambda 表达式的大致原理：</h2>
<p>每当你定义一个 lambda 表达式后，<strong>编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）</strong>。那么在运行时，<strong>这个 lambda 表达式就会返回一个匿名的闭包实例</strong>，是一个右值。所以，我们上面的 lambda 表达式的结果就是一个个闭包。<strong>对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员</strong>。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记 mutable，都可以在 lambda 表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。</p>
<h2 id="lambda-表达式是不能被赋值的">lambda 表达式是不能被赋值的：</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;B&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// 非法，lambda无法赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>   <span class="c1">// 合法，生成一个副本
</span></span></span></code></pre></div><p>闭包类型禁用了赋值操作符，但是没有禁用复制构造函数，所以你仍然可以用一个 lambda 表达式去初始化另外一个 lambda 表达式而产生副本。</p>
<p>在多种捕获方式中，<strong>最好不要使用[=]和[&amp;]默认捕获所有变量</strong>。</p>
<p>默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的生命周期：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="nf">add_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面函数返回了一个 lambda 表达式，参数 x 仅是一个临时变量，函数 add_x 调用后就被销毁了，但是返回的 lambda 表达式却引用了该变量，当调用这个表达式时，引用的是一个垃圾值，会产生没有意义的结果。上面这种情况，使用默认传值方式可以避免悬挂引用问题。</p>
<p>但是采用默认值捕获所有变量仍然有风险，看下面的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Filter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Filter</span><span class="p">(</span><span class="kt">int</span> <span class="n">divisorVal</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">divisor</span><span class="p">{</span><span class="n">divisorVal</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="nf">getFilter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">divisor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>这个类中有一个成员方法，可以返回一个 lambda 表达式，这个表达式使用了类的数据成员 divisor。而且采用默认值方式捕捉所有变量。你可能认为这个 lambda 表达式也捕捉了 divisor 的一份副本，但是实际上并没有。因为数据成员 divisor 对 lambda 表达式并不可见，你可以用下面的代码验证：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 类的方法，下面无法编译，因为divisor并不在lambda捕捉的范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="nf">getFilter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="n">divisor</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>原代码中，lambda 表达式实际上捕捉的是 this 指针的副本，所以原来的代码等价于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="nf">getFilter</span><span class="p">()</span> <span class="p">{</span>    <span class="k">return</span> <span class="p">[</span><span class="n">this</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};}</span>
</span></span></code></pre></div><p>尽管还是以值方式捕获，但是捕获的是指针，其实相当于以引用的方式捕获了当前类对象，<strong>所以 lambda 表达式的闭包与一个类对象绑定在一起了，这很危险，因为你仍然有可能在类对象析构后使用这个 lambda 表达式</strong>，那么类似“悬挂引用”的问题也会产生。所以，<strong>采用默认值捕捉所有变量仍然是不安全的</strong>，主要是由于指针变量的复制，实际上还是按引用传值。</p>
<p>lambda 表达式可以赋值给对应类型的函数指针。但是使用函数指针并不是那么方便。所以 STL 定义在&lt; functional &gt;头文件提供了一个多态的函数对象封装 std::function，其类似于函数指针。它可以绑定任何类函数对象，只要参数与返回类型相同。如下面的返回一个 bool 且接收两个 int 的函数包装器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div><p>lambda 表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数。</p>
<p>最常用的是在 STL 算法中，比如你要统计一个数组中满足特定条件的元素数量，通过 lambda 表达式给出条件，传递给 count_if 函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="nf">count_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="nf">beigin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="nf">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">value</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span> <span class="p">});</span>
</span></span></code></pre></div><p>再比如你想生成斐波那契数列，然后保存在数组中，此时你可以使用 generate 函数，并辅助 lambda 表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">              <span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="n">value</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 此时v {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}
</span></span></span></code></pre></div><p>当需要遍历容器并对每个元素进行操作时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">even_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="nf">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">even_count</span><span class="p">](</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span> <span class="n">even_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The number of even is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">even_count</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div><p>大部分 STL 算法，可以非常灵活地搭配 lambda 表达式来实现想要的效果。</p>
<h1 id="c-stdfunction">C++ std::function</h1>
<p>std::function 是一个函数对象的包装器，std::function 的实例可以存储，复制和调用任何可调用的目标，包括：</p>
<ol>
<li>
<p>函数。</p>
</li>
<li>
<p>lamada 表达式。</p>
</li>
<li>
<p>绑定表达式或其他函数对象。</p>
</li>
<li>
<p>指向成员函数和指向数据成员的指针。</p>
</li>
</ol>
<p>当<code>std::function</code>对象没有初始化任何实际的可调用元素，调用<code>std::function</code>对象将抛出<code>std::bad_function_call</code>异常。</p>
<h2 id="stdfunction-简介">std::function 简介</h2>
<p>类模版 std::function 是一种通用、多态的函数封装。std::function 的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda 表达式、函数指针、以及其它函数对象等。std::function 对象是对 C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。</p>
<p><strong>通常 std::function 是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为 T1, …,TN 的 N 个参数，并且返回一个可转换到 R 类型的值</strong>。std::function 使用 模板转换构造函数接收被包装的函数对象；特别是，闭包类型可以隐式地转换为 std::function。</p>
<p>C++标准库详细说明了这个的基本使用http://www.cplusplus.com/reference/functional/function/.</p>
<p>这里我们大概总结一下。</p>
<h3 id="member-types">Member types</h3>
<table>
<thead>
<tr>
<th>成员类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>result_type</td>
<td>返回类型</td>
</tr>
<tr>
<td>argument_type</td>
<td>如果函数对象只有一个参数，那么这个代表参数类型。</td>
</tr>
<tr>
<td>first_argument_type</td>
<td>如果函数对象有两个个参数，那么这个代表第一个参数类型。</td>
</tr>
<tr>
<td>second_argument_type</td>
<td>如果函数对象有两个个参数，那么这个代表第二个参数类型。</td>
</tr>
</tbody>
</table>
<h3 id="member-functions">Member functions</h3>
<table>
<thead>
<tr>
<th>成员函数声明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>构造函数：constructs a new std::function instance</td>
</tr>
<tr>
<td>destructor</td>
<td>析构函数： destroys a std::function instance</td>
</tr>
<tr>
<td>operator=</td>
<td>给定义的 function 对象赋值</td>
</tr>
<tr>
<td>operator bool</td>
<td>检查定义的 function 对象是否包含一个有效的对象</td>
</tr>
<tr>
<td>operator()</td>
<td>调用一个对象</td>
</tr>
</tbody>
</table>
<h2 id="stdfunction-使用">std::function 使用</h2>
<p>封装普通函数例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;memory&gt;using namespace std;typedef std::function&lt;int(int)&gt; Functional;int TestFunc(int a)  {      return a;  }int main(){    Functional obj = TestFunc;        int res = obj(1);    std::cout &lt;&lt; res &lt;&lt; std::endl;    while(1);    return 0;}</span><span class="cp">
</span></span></span></code></pre></div><p>封装 lambda 表达式 ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;memory&gt;using namespace std;typedef std::function&lt;int(int)&gt; Functional;auto lambda = [](int a)-&gt;int{return a;};int main(){    Functional obj = lambda;        res = obj(2);    std::cout &lt;&lt; res &lt;&lt; std::endl;    while(1);    return 0;}</span><span class="cp">
</span></span></span></code></pre></div><p>封装仿函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;memory&gt;using namespace std;typedef std::function&lt;int(int)&gt; Functional;class Functor{public:    int operator()(int a)    {        return a;    }};int main(){    Functor func;    Functional obj = func;    res = obj(3);    std::cout &lt;&lt; res &lt;&lt; std::endl;    while(1);    return 0;}</span><span class="cp">
</span></span></span></code></pre></div><p>封装类的成员函数和 static 成员函数 ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">Functional</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">CTest</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">Func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="nf">SFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CTest</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">obj</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="nf">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CTest</span><span class="o">::</span><span class="n">Func</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="nf">obj</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;member function : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">obj</span> <span class="o">=</span> <span class="n">CTest</span><span class="o">::</span><span class="n">SFunc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="nf">obj</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;static member function : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>关于可调用实体转换为 std::function 对象需要遵守以下两条原则：</p>
<ol>
<li>转换后的 std::function 对象的参数能转换为可调用实体的参数；</li>
<li>可调用实体的返回值能转换为 std::function 对象的返回值。</li>
</ol>
<p><strong>std::function 对象最大的用处就是在实现函数回调</strong>，使用者需要注意，<strong>它不能被用来检查相等或者不相等，但是可以与 NULL 或者 nullptr 进行比较。</strong></p>
<p><strong>为什么要用 std::function？</strong></p>
<p>好用并实用的东西才会加入标准的。因为好用，实用，我们才在项目中使用它。std::function 实现了一套类型消除机制，可以统一处理不同的函数对象类型。以前我们使用函数指针来完成这些；现在我们可以使用更安全的 std::function 来完成这些任务。</p>
<p>参考文档：</p>
<p><a href="https://blog.csdn.net/xiangbaohui/article/details/106741654" target="_blank" rel="noopener">C++ std::function 技术浅谈</a></p>
<h1 id="heading-1"></h1>
<h1 id="右值引用和-move-语义">右值引用和 move 语义</h1>
<p>先看一个简单的例子直观感受下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">a</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                                    <span class="c1">// line 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">b</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>                                    <span class="c1">// line 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">c</span><span class="p">(</span><span class="nf">some_function_returning_a_string</span><span class="p">());</span>       <span class="c1">// line 3
</span></span></span></code></pre></div><p>如果使用以下拷贝构造函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">string</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>以上 3 行中，只有第一行(line 1)的 x 深度拷贝是有必要的，因为我们可能会在后边用到 x，x 是一个左值(lvalues)。</p>
<p>第二行和第三行的参数则是右值，因为表达式产生的 string 对象是匿名对象，之后没有办法再使用了。</p>
<p>C++ 11 引入了一种新的机制叫做“右值引用”，以便我们通过重载直接使用右值参数。我们所要做的就是写一个以右值引用为参数的构造函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">string</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span>   <span class="c1">// string&amp;&amp; is an rvalue reference to a string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">that</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们没有深度拷贝堆内存中的数据，而是仅仅复制了指针，并把源对象的指针置空。事实上，我们“偷取”了属于源对象的内存数据。由于源对象是一个右值，不会再被使用，因此客户并不会觉察到源对象被改变了。在这里，我们并没有真正的复制，所以我们把这个构造函数叫做“转移构造函数”（move constructor），他的工作就是把资源从一个对象转移到另一个对象，而不是复制他们。</p>
<p>有了右值引用，再来看看赋值操作符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">string</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">string</span> <span class="n">that</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="nf">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意到我们是直接对参数 that 传值，所以 that 会像其他任何对象一样被初始化，那么确切的说，that 是怎样被初始化的呢？对于 C++ 98，答案是复制构造函数，<strong>但是对于 C++ 11，编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择。</strong></p>
<p>如果是 a=b，这样就会调用复制构造函数来初始化 that（因为 b 是左值），赋值操作符会与新创建的对象交换数据，深度拷贝。这就是 copy and swap 惯用法的定义：构造一个副本，与副本交换数据，并让副本在作用域内自动销毁。这里也一样。</p>
<p>如果是 a = x + y，这样就会调用转移构造函数来初始化 that（因为 x+y 是右值），所以这里没有深度拷贝，只有高效的数据转移。相对于参数，that 依然是一个独立的对象，但是他的构造函数是无用的（trivial），因此堆中的数据没有必要复制，而仅仅是转移。没有必要复制他，因为 x+y 是右值，再次，从右值指向的对象中转移是没有问题的。</p>
<p>总结一下：复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。</p>
<p>下面我们进一步讨论右值引用和 move 语义。</p>
<p>C98 标准库中提供了一种唯一拥有性的智能指针<code>std::auto_ptr</code>，<strong>该类型在 C11 中已被废弃</strong>，因为其“复制”行为是危险的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">a</span><span class="p">(</span><span class="n">new</span> <span class="n">Triangle</span><span class="p">);</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span></code></pre></div><p>注意 b 是怎样使用 a 进行初始化的，它不复制 triangle，而是把 triangle 的所有权从 a 传递给了 b，也可以说成“a 被转移进了 b”或者“triangle 被从 a 转移到了 b”。</p>
<p>auto_ptr 的复制构造函数可能看起来像这样（简化）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">auto_ptr</span><span class="p">(</span><span class="n">auto_ptr</span><span class="o">&amp;</span> <span class="n">source</span><span class="p">)</span>   <span class="c1">// note the missing const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">source</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// now the source no longer owns the object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>auto_ptr 的危险之处在于看上去应该是复制，但实际上确是转移。调用被转移过的 auto_ptr 的成员函数将会导致不可预知的后果。所以你必须非常谨慎的使用 auto_ptr ，如果他被转移过。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">make_triangle</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span> <span class="n">Triangle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">c</span><span class="p">(</span><span class="nf">make_triangle</span><span class="p">());</span>      <span class="c1">// move temporary into c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="nf">make_triangle</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">area</span><span class="p">();</span>   <span class="c1">// perfectly safe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">a</span><span class="p">(</span><span class="n">new</span> <span class="n">Triangle</span><span class="p">);</span>    <span class="c1">// create triangle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>               <span class="c1">// move a into b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="nf">area</span><span class="p">();</span>                <span class="c1">// undefined behavior
</span></span></span></code></pre></div><p>显然，在持有 auto_ptr 对象的 a 表达式和持有调用函数返回的 auto_ptr 值类型的 make_triangle()表达式之间一定有一些潜在的区别，每调用一次后者就会创建一个新的 auto_ptr 对象。这里 a 其实就是一个左值（lvalue）的例子，而 make_triangle()就是右值（rvalue）的例子。</p>
<p>转移像 a 这样的左值是非常危险的，因为我们可能调用 a 的成员函数，这会导致不可预知的行为。另一方面，转移像 make_triangle()这样的右值却是非常安全的，因为复制构造函数之后，我们不能再使用这个临时对象了，因为这个转移后的临时对象会在下一行之前销毁掉。</p>
<p>我们现在知道转移左值是十分危险的，但是转移右值却是很安全的。如果 C++能从语言级别支持区分左值和右值参数，我就可以完全杜绝对左值转移，或者把转移左值在调用的时候暴露出来，以使我们不会不经意的转移左值。</p>
<p>C++ 11 对这个问题的答案是右值引用。右值引用是针对右值的新的引用类型，语法是 X&amp;&amp;。以前的老的引用类型 X&amp; 现在被称作左值引用。</p>
<p>使用右值引用 X&amp;&amp;作为参数的最有用的函数之一就是转移构造函数 X::X(X&amp;&amp; source)，它的主要作用是把源对象的本地资源转移给当前对象。</p>
<p>C++ 11 中，std::auto_ptr&lt; T &gt;已经被 std::unique_ptr&lt; T &gt;所取代，后者就是利用的右值引用。</p>
<p>其转移构造函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">source</span><span class="p">)</span>   <span class="c1">// note the rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ptr</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">source</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个转移构造函数跟 auto_ptr 中复制构造函数做的事情一样，但是它却只能接受右值作为参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">a</span><span class="p">(</span><span class="n">new</span> <span class="n">Triangle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>                 <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">c</span><span class="p">(</span><span class="nf">make_triangle</span><span class="p">());</span>       <span class="c1">// okay
</span></span></span></code></pre></div><p>第二行不能编译通过，因为 a 是左值，但是参数 unique_ptr&amp;&amp; source 只能接受右值，这正是我们所需要的，杜绝危险的隐式转移。第三行编译没有问题，因为 make_triangle()是右值，转移构造函数会将临时对象的所有权转移给对象 c，这正是我们需要的。</p>
<h2 id="转移左值">转移左值</h2>
<p>有时候，我们可能想转移左值，也就是说，有时候我们想让编译器把左值当作右值对待，以便能使用转移构造函数，即便这有点不安全。出于这个目的，C++ 11 在标准库的头文件&lt; utility &gt;中提供了一个模板函数 std::move。实际上，std::move 仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移。</p>
<p>以下是如何正确的转移左值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">a</span><span class="p">(</span><span class="n">new</span> <span class="n">Triangle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>              <span class="c1">// still an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="nf">c</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="nf">move</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>   <span class="c1">// okay
</span></span></span></code></pre></div><p>请注意，第三行之后，a 不再拥有 Triangle 对象。不过这没有关系，因为通过明确的写出 std::move(a)，我们很清楚我们的意图：亲爱的转移构造函数，你可以对 a 做任何想要做的事情来初始化 c；我不再需要 a 了，对于 a，您请自便。</p>
<p>当然，如果你在使用了 mova(a)之后，还继续使用 a，那无疑是搬起石头砸自己的脚，还是会导致严重的运行错误。</p>
<p>总之，std::move(some_lvalue)将左值转换为右值（可以理解为一种类型转换），使接下来的转移成为可能。</p>
<p>一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Foo</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="n">member</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Foo</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&amp;&amp;</span> <span class="n">parameter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="nf">member</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>   <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面的 parameter，其类型是一个右值引用，只能说明 parameter 是指向右值的引用，而 parameter 本身是个左值。（Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.）</p>
<p>因此以上对 parameter 的转移是不允许的，需要使用<code>std::move</code>来显示转换成右值。</p>

          </div>

          



          
          
          <div class="article-widget">
            
<div class="container-xl row post-nav">
  
  
  
  <div class="col-6 post-nav-item">
    <div class="meta-nav">上一页</div>
    <a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-anthony-calandra-c&#43;&#43;-11-features/" rel="next">2022-Anthony Calandra-C&#43;&#43; 11 Features</a>
  </div>
  
  
  
  <div class="col-6 post-nav-item">
    <div class="meta-nav">下一页</div>
    <a href="/books/cpp-notes/00.%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81/c&#43;&#43;-11/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%AF%8F%E4%B8%AA-c&#43;&#43;%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E7%9A%8410%E4%B8%AA-c&#43;&#43;-11%E7%89%B9%E6%80%A7/" rel="prev">每个 C&#43;&#43;开发人员都应该使用的10个 C&#43;&#43; 11特性</a>
  </div>
  
</div>

          </div>
          

        <div class="body-footer">
          <p>最近更新于 0001-01-01</p>

          



          


  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    
<div id="disqus_thread"></div>
<script>
  var disqus_config = function () {
    
    
    
  };
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
      return;
    }
    var d = document, s = d.createElement('script'); 
    s.async = true;
    s.src = 'https://' + "ngte" + '.disqus.com/embed.js';
    
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
  



          


        </div>

      </article>

      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2017-2022 NGTE all rights reserved</p>
        </div>
    </div>
  </div>

  <script type="text/javascript" id="clstr_globe" async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script>
  
</footer>


    </main>
  </div>
</div>
<script src="//unpkg.com/heti/umd/heti-addon.min.js"></script>
<script>
  const heti = new Heti('.article');
  heti.autoSpacing();
</script>
<script type="text/javascript">
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "12adcc35-9621-4313-8262-62dc654b29d8";
  (function () {
    setTimeout(function() {
      d = document;
      s = d.createElement("script");
      s.src = "https://client.crisp.chat/l.js";
      s.async = 1;
      d.getElementsByTagName("head")[0].appendChild(s);
    }, 2500);
  })();
</script>
  </div>

  <div class="page-footer">
    
    
  </div>

      

    
    <script src="/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js"></script>

    
    
    
      

      
      

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
        
        
      

    

    
    
    

    
    
    
      
      <script id="search-hit-algolia-template" type="text/html">
        <div class="search-hit">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a>
            </div>
            <div class="article-metadata search-hit-type">{{type}}</div>
            <p class="search-hit-description">{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p>
          </div>
        </div>
      </script>
      
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js" crossorigin="anonymous"></script>
      
      
    

    
    

    
    
    
    
      <script id="dsq-count-scr" src="https://ngte.disqus.com/count.js" async></script>
      
    

    
    
      
      
      
      
      
      
      
    

    
    <script src="/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js" type="module"></script>
    

    
    
    
    <script id="page-data" type="application/json">{"use_headroom":false}</script>

    
    
    
    
    
    
    
    
    
    
    <script src="/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js"></script>

    
    
    
    
    
    
    <script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>


    

    
    
    <script src="https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    <script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>

    


</body>
</html>
