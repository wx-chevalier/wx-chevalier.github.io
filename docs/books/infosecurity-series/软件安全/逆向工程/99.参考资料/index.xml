<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>99.参考资料 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link><atom:link href="https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml"/><description>99.参考资料</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>99.参考资料</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link></image><item><title>【2021 春节】安卓中级题逆向总结</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-%E6%98%A5%E8%8A%82%E5%AE%89%E5%8D%93%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-%E6%98%A5%E8%8A%82%E5%AE%89%E5%8D%93%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://www.52pojie.cn/thread-1378761-1-1.html" target="_blank" rel="noopener">www.52pojie.cn&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>作者**&lt;strong>论*&lt;/strong>*坛账号：Light 紫星&lt;/strong>&lt;/p>
&lt;p>【2021 春节】解题领红包之三&lt;br>
逆向总结本题所用到的工具：&lt;br>
Jadx1.2.0&lt;br>
FrIDA14.2.13&lt;br>
ida7.5.0&lt;br>
Python3.7.2&lt;br>
首先安装 apk，打开后是这个界面：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZJTibibw28ic2DrbYUibtwtCfCMdGibliaouQ0q3db7Vl8xADubEq89ZpTlvbCSGLOsRZhg17te2y3yauicA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;br>
随便输入 flag，提示 flag 格式错误，请重试。拖入 jadx，找到关键函数，如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>package p004cn.pojie52.cm01;
import android.os.Bundle;
import android.view.View;
import android.widget.EditText;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
/* renamed from: cn.pojie52.cm01.MainActivity */
public class MainActivity extends AppCompatActivity {
public native boolean check(String str);
static {
System.loadLibrary(&amp;#34;native-lib&amp;#34;);
}
/* access modifiers changed from: protected */
@Override // androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, androidx.appcompat.app.AppCompatActivity, androidx.fragment.app.FragmentActivity
public void onCreate(Bundle bundle) {
super.onCreate(bundle);
setContentView(C0266R.layout.activity_main);
final EditText editText = (EditText) findViewById(C0266R.C0268id.flag);
findViewById(C0266R.C0268id.check).setOnClickListener(new View.OnClickListener() {
/* class p004cn.pojie52.cm01.MainActivity.View$OnClickListenerC02651 */
public void onClick(View view) {
String trim = editText.getText().toString().trim();
if (trim.length() != 30) {
Toast.makeText(MainActivity.this, &amp;#34;flag格式错误，请重试&amp;#34;, 0).show();
} else if (MainActivity.this.check(trim)) {
Toast.makeText(MainActivity.this, &amp;#34;恭喜你，验证正确！&amp;#34;, 0).show();
} else {
Toast.makeText(MainActivity.this, &amp;#34;flag错误，再接再厉&amp;#34;, 0).show();
}
}
});
}
}
&lt;/code>&lt;/pre>&lt;p>这里判断了输入的长度是否为 30 位，然后进入了 so 验证。
下一步，把 so 拖入 ida，直接定位到关键函数：Java_cn_pojie52_cm01_MainActivity_check&lt;br>
该函数内容如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>__int64 __fastcall Java_cn_pojie52_cm01_MainActivity_check(_JNIEnv *a1, __int64 a2, __int64 a3)
{
const char *v5; // x21
size_t v6; // w0
int v7; // w0
__int64 v8; // x0
_BYTE *v9; // x0
int8x16_t v10; // q0
int8x16_t v11; // q4
int8x16_t v12; // q2
int8x16_t v13; // q5
int8x16_t v14; // q1
int8x16_t v15; // q0
__int64 v16; // x8
unsigned int v17; // w19
_BYTE v19[33]; // [xsp+0h] [xbp-A0h]
int v20; // [xsp+21h] [xbp-7Fh]
char v21; // [xsp+25h] [xbp-7Bh]
char v22; // [xsp+26h] [xbp-7Ah]
char v23; // [xsp+27h] [xbp-79h]
char v24; // [xsp+28h] [xbp-78h]
char dest[16]; // [xsp+38h] [xbp-68h] BYREF
__int128 v26; // [xsp+48h] [xbp-58h]
__int128 v27; // [xsp+58h] [xbp-48h]
__int128 v28; // [xsp+68h] [xbp-38h]
__int64 v29; // [xsp+78h] [xbp-28h]
v29 = *(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
if ( a1-&amp;gt;functions-&amp;gt;GetStringUTFLength(a1, a3) != 30 )
return 0;
v5 = a1-&amp;gt;functions-&amp;gt;GetStringUTFChars(a1, a3, 0LL);
v28 = 0u;
v27 = 0u;
v26 = 0u;
*dest = 0u;
v6 = strlen(v5);
strncpy(dest, v5, v6);
a1-&amp;gt;functions-&amp;gt;ReleaseStringUTFChars(a1, a3, v5);
v7 = strlen(dest);
sub_B90(dest, v7, &amp;#34;areyousure??????&amp;#34;);
v8 = strlen(dest);
v9 = sub_D90(dest, v8);
*v19 = unk_11A1;
*&amp;amp;v19[16] = unk_11B1;
*&amp;amp;v19[25] = unk_11BA;
v10.n128_u64[0] = 0xB2B2B2B2B2B2B2B2LL;
v10.n128_u64[1] = 0xB2B2B2B2B2B2B2B2LL;
v11.n128_u64[0] = 0xFEFEFEFEFEFEFEFELL;
v11.n128_u64[1] = 0xFEFEFEFEFEFEFEFELL;
v19[0] = 53;
v12 = veorq_s8(vaddq_s8(veorq_s8(vaddq_s8(*&amp;amp;v19[1], v10), xmmword_1130), xmmword_1140), v11);
v13.n128_u64[0] = 0x101010101010101LL;
v13.n128_u64[1] = 0x101010101010101LL;
v14.n128_u64[0] = 0x3E3E3E3E3E3E3E3ELL;
v14.n128_u64[1] = 0x3E3E3E3E3E3E3E3ELL;
*&amp;amp;v19[1] = vaddq_s8(
veorq_s8(vsubq_s8(v13, vorrq_s8(vshrq_n_u8(v12, 7uLL), vshlq_n_s8(v12, 1uLL))), xmmword_1150),
v14);
v20 = 1782990162;
v15 = veorq_s8(vaddq_s8(veorq_s8(vaddq_s8(*&amp;amp;v19[17], v10), xmmword_1160), xmmword_1170), v11);
v21 = ((1
- ((2 * ((((unk_11C6 - 78) ^ 0xB2) - 117) ^ 0xFE)) | ((((((unk_11C6 - 78) ^ 0xB2) - 117) ^ 0xFE) &amp;amp; 0x80) != 0))) ^ 0x25)
+ 62;
v16 = 0LL;
v22 = ((1
- ((2 * ((((unk_11C7 - 78) ^ 0xB1) - 118) ^ 0xFE)) | ((((((unk_11C7 - 78) ^ 0xB1) - 118) ^ 0xFE) &amp;amp; 0x80) != 0))) ^ 0x26)
+ 62;
*&amp;amp;v19[17] = vaddq_s8(
veorq_s8(vsubq_s8(v13, vorrq_s8(vshrq_n_u8(v15, 7uLL), vshlq_n_s8(v15, 1uLL))), xmmword_1180),
v14);
v23 = ((1
- ((2 * ((((unk_11C8 - 78) ^ 0xB0) - 119) ^ 0xFE)) | ((((((unk_11C8 - 78) ^ 0xB0) - 119) ^ 0xFE) &amp;amp; 0x80) != 0))) ^ 0x27)
+ 62;
v24 = ((1
- ((2 * ((((unk_11C9 - 78) ^ 0xBF) - 120) ^ 0xFE)) | ((((((unk_11C9 - 78) ^ 0xBF) - 120) ^ 0xFE) &amp;amp; 0x80) != 0))) ^ 0x28)
+ 62;
while ( v9[v16] == v19[v16] )
{
if ( v9[v16] )
{
if ( ++v16 != 41 )
continue;
}
v17 = 1;
goto LABEL_9;
}
v17 = 0;
LABEL_9:
free(v9);
return v17;
}
&lt;/code>&lt;/pre>&lt;p>大概看一下流程，先判断输入是否 30 位，然后把输入的数据传入 sub_B90 进行处理，再传入 sub_D90 处理一次，处理后的结果为 v9，最后 v9 和 v19 进行比较。所以这里要先看一下 sub_b90 和 sub_d90 是干什么的，直接使用 frida 进行 hook 调用这两个函数，&lt;br>
frida 代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code># -*- coding: UTF-8 -*-
import frida, sys
jscode = &amp;#39;&amp;#39;&amp;#39;
function inline_hook() {
var so_addr = Module.findBaseAddress(&amp;#34;libnative-lib.so&amp;#34;);
if (so_addr) {
console.log(&amp;#34;so_addr:&amp;#34;, so_addr);
var addr_b90 = so_addr.add(0xb90);
var sub_b90 = new NativeFunction(addr_b90 , &amp;#39;int&amp;#39;, [&amp;#39;pointer&amp;#39;, &amp;#39;int&amp;#39;,&amp;#39;pointer&amp;#39;]);
var arg1 = Memory.allocUtf8String(&amp;#39;111111111111111111111111111111&amp;#39;);
var arg2 = 30;
var arg3 = Memory.allocUtf8String(&amp;#39;areyousure??????&amp;#39;);
var ret_b90 = sub_b90(arg1,arg2,arg3);
console.log(Memory.readByteArray(arg1,64));
var addr_d90 = so_addr.add(0xd90);
var sub_d90 = new NativeFunction(addr_d90 , &amp;#39;pointer&amp;#39;, [&amp;#39;pointer&amp;#39;, &amp;#39;int&amp;#39; ]);
var arg1 = Memory.allocUtf8String(&amp;#39;111111111111111111111111111111&amp;#39;);
var arg2 = 30;
var ret_d90 = sub_d90(arg1,arg2);
console.log(Memory.readByteArray(ret_d90,64));
}
}
setImmediate(inline_hook)
&amp;#39;&amp;#39;&amp;#39;
def on_message(message, data):
if message[&amp;#39;type&amp;#39;] == &amp;#39;send&amp;#39;:
print(&amp;#34; {0}&amp;#34;.format(message[&amp;#39;payload&amp;#39;]))
else:
print(message)
pass
#print(frida.enumerate_devices())
# 查找USB设备并附加到目标进程
device = frida.get_remote_device()
#pid = device.spawn([&amp;#34;com.live.xctv&amp;#34;])
#session = device.attach(pid)
session =device.attach(&amp;#39;cn.pojie52.cm01&amp;#39;) #这里是要注入的apk包名
# 在目标进程里创建脚本
script = session.create_script(jscode)
# 注册消息回调
script.on(&amp;#39;message&amp;#39;, on_message)
print(&amp;#39; Start attach&amp;#39;)
# 加载创建好的javascript脚本
script.load()
# 读取系统输入
sys.stdin.read()
&lt;/code>&lt;/pre>&lt;p>结果如下：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZJTibibw28ic2DrbYUibtwtCfCMWOPR3xJqIq6QSaF3ow8nOTAA6qSIUQKu058IwXqe5Xy5ZRF4KS6voQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;br>
然后我们先进入 sub_b90 看一下，&lt;br>
sub_b90 函数内容如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>unsigned __int64 __fastcall sub_B90(_BYTE *a1, unsigned int a2, char *s)
{
unsigned __int64 result; // x0
unsigned __int64 v7; // x8
signed int v8; // w9
int v9; // w11
int v10; // w9
int v11; // w12
int v12; // w9
signed int v13; // w11
__int64 v14; // x8
int v15; // w12
int v16; // w9
int v17; // w13
int v18; // w11
int v19; // w14
__int128 v20[2]; // [xsp+0h] [xbp-140h]
__int128 v21[14]; // [xsp+20h] [xbp-120h] BYREF
__int64 v22; // [xsp+108h] [xbp-38h]
v22 = *(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
result = strlen(s);
v20[0] = xmmword_11D0;
v20[1] = xmmword_11E0;
qmemcpy(v21, &amp;#34; !\&amp;#34;#$%&amp;amp;&amp;#39;()*+,-./0123456789:;&amp;lt;=&amp;gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmno&amp;#34;, 80);
v21[5] = xmmword_1240;
v21[6] = xmmword_1250;
v21[7] = xmmword_1260;
v21[8] = xmmword_1270;
v21[9] = xmmword_1280;
v7 = 0LL;
v8 = 0;
v21[10] = xmmword_1290;
v21[11] = xmmword_12A0;
v21[12] = xmmword_12B0;
v21[13] = xmmword_12C0;
do
{
v9 = *(v20 + v7);
v10 = v8 + v9 + s[v7 - v7 / result * result];
v11 = v10 + 255;
if ( v10 &amp;gt;= 0 )
v11 = v10;
v8 = v10 - (v11 &amp;amp; 0xFFFFFF00);
*(v20 + v7++) = *(v20 + v8);
*(v20 + v8) = v9;
}
while ( v7 != 256 );
if ( a2 )
{
v12 = 0;
v13 = 0;
v14 = a2;
do
{
v15 = v12 + 1;
if ( v12 + 1 &amp;gt;= 0 )
v16 = v12 + 1;
else
v16 = v12 + 256;
v12 = v15 - (v16 &amp;amp; 0xFFFFFF00);
v17 = *(v20 + v12);
v18 = v13 + v17;
v19 = v18 + 255;
if ( v18 &amp;gt;= 0 )
v19 = v18;
v13 = v18 - (v19 &amp;amp; 0xFFFFFF00);
--v14;
*(v20 + v12) = *(v20 + v13);
*(v20 + v13) = v17;
*a1++ ^= *(v20 + (*(v20 + v12) + v17));
}
while ( v14 );
}
return result;
}
&lt;/code>&lt;/pre>&lt;p>大概分析一下 sub_b90，是根据传入的第三个参数 s 把 v20 进行了一个初始化，然后再把参数 a1 和 v20 进行了异或运算，主要看这个异或运算，先设想一下，如果是把 a1 进行了异或，那么得到的结果和 a1 之前的数据再异或就可以计算出异或的 key，这里我们把它叫做 xorkey，那么先看一下我们传入的参数，是 30 个 1，也就是 30 个 0x31 ，然后看结果，第一位是 0xe0，0x31^0xe0 = 209，然后把参数改为 30 个 2，即 0x32，得出首位的结果是 0xe3，0xe3^0x32 结果也是 209，证明我们的思路是正确的，然后依次求出所有的 xorkey，&lt;br>
最后计算出的结果为：&lt;br>
xorkey = [209, 90, 6, 144, 68, 230, 199, 229, 222, 40, 247, 242, 102, 145, 200, 133, 66, 223, 249, 224, 130, 1, 43, 59, 56, 99, 55, 189, 46, 77]&lt;br>
接下来看 sub_d90，咋一看返回值，全是字母，看起来有点像 base64，于是用 base64 编码 30 个 1 进行测试，发现结果吻合，于是可以断定 sub_d90 是 base64 函数。
接下来，就可以写出通过 v9 求输入参数的函数：&lt;/p>
&lt;pre tabindex="0">&lt;code>import base64
xorkey = [209, 90, 6, 144, 68, 230, 199, 229, 222, 40, 247, 242, 102, 145, 200, 133, 66, 223, 249, 224, 130, 1, 43, 59, 56, 99, 55, 189, 46, 77]
def sub_B90(data,l):
ret = []
for i in range(l):
ret.append(((data[i]))^xorkey[i])
s=&amp;#39;&amp;#39;
for i in ret:
s+=chr(i)
print(s)
return ret
def resv(data):
data =base64.b64decode(data)
t = sub_B90(data,len(data))
return(t)
&lt;/code>&lt;/pre>&lt;p>调用 resv 即可计算出输入的参数。
这个时候我们发现，还有一个 v19 是我们不知道的，如果找到 v19 然后代入 resv 就能求出本题的结果！&lt;br>
根据 ida 的注释，我们知道 v19 是 xsp+0h，而 dest 是 xsp+38h，而 dest 又作为参数传入了 sub_b90，这里我直接 hooksub_b90，得到 xsp，然后再在 v19 初始化结束之后输出 xsp 的值，即可得到 v19，&lt;br>
这里的 hook 代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code># -*- coding: UTF-8 -*-
import frida, sys
jscode = &amp;#39;&amp;#39;&amp;#39;
var destAddr = &amp;#39;&amp;#39;; //定位xsp地址
function inline_hook() {
var so_addr = Module.findBaseAddress(&amp;#34;libnative-lib.so&amp;#34;);
if (so_addr) {
console.log(&amp;#34;so_addr:&amp;#34;, so_addr);
var addr_b90 = so_addr.add(0xB90);
var sub_b90 = new NativeFunction(addr_b90 , &amp;#39;int&amp;#39;, [&amp;#39;pointer&amp;#39;, &amp;#39;int&amp;#39;, &amp;#39;pointer&amp;#39;]);
Interceptor.attach(sub_b90, {
onEnter: function(args)
{
destAddr = args[0];
console.log(&amp;#39;onEnter B90&amp;#39;);
},
//在hook函数之后执行的语句
onLeave:function(retval)
{
console.log(&amp;#39;onLeave B90&amp;#39;);
}
});
var addr_b2c = so_addr.add(0xb2c);
console.log(&amp;#34;The addr_b2c:&amp;#34;, addr_b2c);
Java.perform(function() {
Interceptor.attach(addr_b2c, {
onEnter: function(args) {
console.log(&amp;#34;addr_b2c OnEnter :&amp;#34;, Memory.readByteArray(destAddr.sub(0x38),64) );
}
})
})
}
}
setImmediate(inline_hook)
&amp;#39;&amp;#39;&amp;#39;
def on_message(message, data):
if message[&amp;#39;type&amp;#39;] == &amp;#39;send&amp;#39;:
print(&amp;#34; {0}&amp;#34;.format(message[&amp;#39;payload&amp;#39;]))
else:
print(message)
pass
#print(frida.enumerate_devices())
# 查找USB设备并附加到目标进程
device = frida.get_remote_device()
#pid = device.spawn([&amp;#34;com.live.xctv&amp;#34;])
#session = device.attach(pid)
session =device.attach(&amp;#39;cn.pojie52.cm01&amp;#39;) #这里是要注入的apk包名
# 在目标进程里创建脚本
script = session.create_script(jscode)
# 注册消息回调
script.on(&amp;#39;message&amp;#39;, on_message)
print(&amp;#39; Start attach&amp;#39;)
# 加载创建好的javascript脚本
script.load()
# 读取系统输入
sys.stdin.read()
&lt;/code>&lt;/pre>&lt;p>随便输入一个 30 位的注册码，得到的结果如下：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZJTibibw28ic2DrbYUibtwtCfCMwmRIGMlSuUNuXz1fzZH38qdwOxrUiaB5r49CGIyW12ahz6GpMQC86HA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;br>
看来这个字符串就是我们要的了。把这个字符串代入函数 resv，即可求出本题的 flag：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZJTibibw28ic2DrbYUibtwtCfCMH6iaB0etSWEBG1UJkZZNrm9IuJwBrvpRSNZASpXjibAEP5L7s3E0lHEg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;br>
输入 52pojieHappyChineseNewYear2021 到输入框，点击验证按钮，提示成功！本题分析结束。&lt;/p>
&lt;p>*&lt;strong>*&amp;ndash; 官方论坛**&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.52pojie.cn" target="_blank" rel="noopener">www.52pojie.cn&lt;/a>&lt;/p>
&lt;p>&lt;strong>&amp;ndash; 推荐给朋友&lt;/strong>&lt;/p>
&lt;p>公众微信号：吾爱破解论坛&lt;/p>
&lt;p>或搜微信号：pojie_52&lt;/p></description></item><item><title>【转载】Unidbg Hook 大全 - SeeFlowerX</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E8%BD%AC%E8%BD%BDunidbg-hook-%E5%A4%A7%E5%85%A8-seeflowerx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E8%BD%AC%E8%BD%BDunidbg-hook-%E5%A4%A7%E5%85%A8-seeflowerx/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://blog.seeflower.dev/archives/67/" target="_blank" rel="noopener">blog.seeflower.dev&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Be patient.&lt;/p>
&lt;/blockquote>
&lt;p>本文章转载自龙哥，已获许可，持续更新中。&lt;/p>
&lt;p>&lt;strong>本文总结了 Unidbg Hook and Call 的知识，部分 Hook 代码采用 Frida 与 Unidbg 对照的方式，帮助熟悉 Frida 但不熟悉 Unidbg 的读者快速入门。&lt;/strong>&lt;/p>
&lt;p>样例前往百度云下载：&lt;/p>
&lt;p>链接：&lt;a href="https://pan.baidu.com/s/1ZRPtQrx4QAPEQhrpq6gbgg" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZRPtQrx4QAPEQhrpq6gbgg&lt;/a> 提取码：6666&lt;/p>
&lt;p>&lt;strong>更多 Unidbg 使用和算法还原的教程可见星球。&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/1.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h2 id="一基础知识">一、基础知识&lt;/h2>
&lt;h3 id="1-获取-so-基地址">1. 获取 SO 基地址&lt;/h3>
&lt;h4 id="frida-获取基地址">Ⅰfrida 获取基地址&lt;/h4>
&lt;pre tabindex="0">&lt;code>var baseAddr = Module.findBaseAddress(&amp;#34;libnative-lib.so&amp;#34;);
&lt;/code>&lt;/pre>&lt;h4 id="-unidbg-获取基地址">Ⅱ Unidbg 获取基地址&lt;/h4>
&lt;pre tabindex="0">&lt;code>DalvikModule dm = vm.loadLibrary(&amp;#34;libnative-lib.so&amp;#34;, true);
module = dm.getModule();
System.out.println(&amp;#34;baseAddr:&amp;#34;+module.base);
&lt;/code>&lt;/pre>&lt;p>加载了多个 SO 的情况&lt;/p>
&lt;pre tabindex="0">&lt;code>Module yourModule = emulator.getMemory().findModule(&amp;#34;yourModuleName&amp;#34;);
System.out.println(&amp;#34;baseAddr:&amp;#34;+yourModule.base);
&lt;/code>&lt;/pre>&lt;p>如果只主动加载一个 SO，其基址恒为 0x40000000 , 这是一个检测 Unidbg 的点，可以在 com/github/unidbg/memory/Memory.java 中做修改&lt;/p>
&lt;pre tabindex="0">&lt;code>public interface Memory extends IO, Loader, StackMemory {
long STACK_BASE = 0xc0000000L;
int STACK_SIZE_OF_PAGE = 256;
long MMAP_BASE = 0x40000000L;
UnidbgPointer allocateStack(int size);
UnidbgPointer pointer(long address);
void setStackPoint(long sp);
&lt;/code>&lt;/pre>&lt;h3 id="2-获取函数地址">2. 获取函数地址&lt;/h3>
&lt;h4 id="-frida-获取导出函数地址">Ⅰ Frida 获取导出函数地址&lt;/h4>
&lt;pre tabindex="0">&lt;code>Module.findExportByName(&amp;#34;libc.so&amp;#34;, &amp;#34;strcmp&amp;#34;)
&lt;/code>&lt;/pre>&lt;h4 id="-unidbg-获取导出函数地址">Ⅱ Unidbg 获取导出函数地址&lt;/h4>
&lt;pre tabindex="0">&lt;code>DalvikModule dm = vm.loadLibrary(&amp;#34;libnative-lib.so&amp;#34;, true);
module = dm.getModule();
int address = (int) module.findSymbolByName(&amp;#34;funcNmae&amp;#34;).getAddress();
&lt;/code>&lt;/pre>&lt;h4 id="-frida-获取非导出函数地址">Ⅲ Frida 获取非导出函数地址&lt;/h4>
&lt;pre tabindex="0">&lt;code>var soAddr = Module.findBaseAddress(&amp;#34;libnative-lib.so&amp;#34;);
var FuncAddr = soAddr.add(0x1768 + 1);
&lt;/code>&lt;/pre>&lt;h4 id="-unidbg-获取非导出函数地址">Ⅳ Unidbg 获取非导出函数地址&lt;/h4>
&lt;pre tabindex="0">&lt;code>DalvikModule dm = vm.loadLibrary(&amp;#34;libnative-lib.so&amp;#34;, true);
module = dm.getModule();
int offset = 0x1768;
int address = (int) (module.base + offset);
&lt;/code>&lt;/pre>&lt;h3 id="3unidbg-hook-大盘点">3.Unidbg Hook 大盘点&lt;/h3>
&lt;p>Unidbg 在 Android 上支持的 Hook，可以分为两大类&lt;/p>
&lt;ul>
&lt;li>Unidbg 内置的第三方 Hook 框架，包括 xHook/Whale/HookZz&lt;/li>
&lt;li>Unicorn Hook 以及 Unidbg 基于它封装的 Console Debugger&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一类是 Unidbg 支持并内置的第三方 Hook 框架，有 Dobby(前身 HookZz)/Whale 这样的 Inline Hook 框架，也有 xHook 这样的 PLT Hook 框架。有小伙伴可能困惑 Unidbg 是否能支持 Frida？我个人观点是目前阶段不现实，Frida 比 Dobby 或者 xHook 都复杂的多，Unidbg 目前还跑不通，除此之外，Dobby + Whale + xHook 也绝对够用了，没有非 Frida 不可的需求。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第二类是当 Unidbg 的底层引擎选择为 Unicorn 时（默认引擎），Unicorn 自带的 Hook 功能。Unicorn 提供了各种级别和粒度的 Hook，内存 Hook / 指令 / 基本块 Hook / 异常 Hook 等等，十分强大和好用，而且 Unidbg 基于它封装了更便于使用的 Console Debugger。&lt;/strong>&lt;/p>
&lt;p>该怎么选择 Hook 方案？这得看使用 Unidbg 的目的。如果项目用于&lt;strong>模拟执行&lt;/strong>，那么建议使用 Console Debugger 做快速分析，排查错误，跑通代码后用第三方 Hook 框架做持久化，为什么？这得从 Unidbg 支持的汇编执行引擎说起。Unidbg 支持多种底层引擎，最早也是默认的引擎是 Unicorn，从名字也能看出，Unidbg 和 Unicorn 有很大关系。但后续 Unidbg 又支持了数个引擎，任何提高程序复杂度的行为，肯定都为了解决某个痛点。&lt;/p>
&lt;p>hypervisor 引擎可以在搭载了 &lt;em>Apple Silicon&lt;/em> 芯片的设备上模拟执行；&lt;/p>
&lt;p>KVM 引擎可以在树莓派上模拟执行；&lt;/p>
&lt;p>Dynarmic 引擎是为了更快的模拟执行；&lt;/p>
&lt;p>Unicorn 是最强大最完善的模拟执行引擎，但它相比 Dynarmic 太慢了，同场景下，Dynarmic 比 Unicorn 模拟执行快数倍甚至十数倍。如果使用 Unidbg 是为了实现生产环境下的模拟执行，速度最重要，那么 Dynarmic + &lt;strong>&lt;a href="https://github.com/anjia0532/unidbg-boot-server" target="_blank" rel="noopener">unidbg-boot-server&lt;/a>&lt;/strong> 这个高并发 server 服务器，是完美之选。一般实操中，先使用 Unicorn 引擎跑通模拟执行代码，切换成 Dynarmic 无误后，直接上生产环境。&lt;/p>
&lt;p>&lt;em>Dynarmic 引擎使用&lt;/em>&lt;/p>
&lt;pre tabindex="0">&lt;code>private static AndroidEmulator createARMEmulator() {
return AndroidEmulatorBuilder.for32Bit()
.addBackendFactory(new DynarmicFactory(true))
.build();
}
&lt;/code>&lt;/pre>&lt;p>&lt;em>Unicorn 默认引擎&lt;/em>&lt;/p>
&lt;pre tabindex="0">&lt;code>private static AndroidEmulator createARMEmulator() {
return AndroidEmulatorBuilder.for32Bit()
.build();
}
&lt;/code>&lt;/pre>&lt;p>使用 Unidbg 的第二个场景是&lt;strong>辅助算法还原&lt;/strong>，即模拟执行只是算法还原的前奏，在模拟执行无误后，使用 Unidbg 辅助算法还原。这种情况下自然使用 Unicorn 引擎，两大类 Hook 方案都可以使用，选择哪类？我倾向于自始至终使用第二类方案，即基于 Unicorn Hook 的方案。&lt;/p>
&lt;p>我个人认为有三点优势&lt;/p>
&lt;ul>
&lt;li>HookZz 或者 xHook 等方案，都可以基于其 Hook 实现原理进行检测，但 Unicorn 原生 Hook 不容易被检测。&lt;/li>
&lt;li>Unicorn Hook 没有局限，其他方案局限性较大。比如 Inline Hook 方案不能 Hook 短函数，或者两个相邻的地址；PLT Hook 不能 Hook Sub_xxx 子函数。&lt;/li>
&lt;li>第三方 inline Hook 框架和原生 Hook 方案同时使用时会摩擦出 BUG 的火花，事实上，单使用 Unicorn 的某些 Hook 功能都有 BUG。所以说，统一用原生 Hook 会少一些 BUG，少一些麻烦。&lt;/li>
&lt;/ul>
&lt;p>总结如下&lt;/p>
&lt;h4 id="-以模拟执行为目的">Ⅰ 以模拟执行为目的&lt;/h4>
&lt;p>使用第三方 Hook 方案，arm32 下 HookZz 的支持较好，arm64 下 Dobby 的支持较好，HookZz/Dobby Hook 不成功时，如果函数是导出函数，使用 xHook，否则使用 Whale。&lt;/p>
&lt;h4 id="-以算法还原为目的">Ⅱ 以算法还原为目的&lt;/h4>
&lt;p>使用 Console Debugger 和 Unicorn Hook，并建议不优先使用第三方 Hook 方案。&lt;/p>
&lt;h3 id="4-本篇的基础代码">4. 本篇的基础代码&lt;/h3>
&lt;p>即模拟执行 demo 的代码&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tutorial;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.arm.HookStatus;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.CodeHook;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.BreakPointCallback;
import com.github.unidbg.hook.HookContext;
import com.github.unidbg.hook.ReplaceCallback;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.hook.whale.IWhale;
import com.github.unidbg.hook.whale.Whale;
import com.github.unidbg.hook.xhook.IxHook;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.XHookImpl;
import com.github.unidbg.linux.android.dvm.DalvikModule;
import com.github.unidbg.linux.android.dvm.DvmClass;
import com.github.unidbg.linux.android.dvm.DvmObject;
import com.github.unidbg.linux.android.dvm.VM;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import unicorn.ArmConst;
import unicorn.Unicorn;
import java.io.File;
public class hookInUnidbg {
private final AndroidEmulator emulator;
private final VM vm;
private final Module module;
hookInUnidbg() {
emulator = AndroidEmulatorBuilder.for32Bit().build();
final Memory memory = emulator.getMemory();
memory.setLibraryResolver(new AndroidResolver(23));
vm = emulator.createDalvikVM(new File(&amp;#34;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&amp;#34;));
DalvikModule dm = vm.loadLibrary(&amp;#34;hookinunidbg&amp;#34;, true);
module = dm.getModule();
dm.callJNI_OnLoad(emulator);
}
public void call(){
DvmClass dvmClass = vm.resolveClass(&amp;#34;com/example/hookinunidbg/MainActivity&amp;#34;);
String methodSign = &amp;#34;call()V&amp;#34;;
DvmObject&amp;lt;?&amp;gt; dvmObject = dvmClass.newObject(null);
dvmObject.callJniMethodObject(emulator, methodSign);
}
public static void main(String[] args) {
hookInUnidbg mydemo = new hookInUnidbg();
mydemo.call();
}
}
&lt;/code>&lt;/pre>&lt;p>运行时有一些日志输出，为正常逻辑。&lt;/p>
&lt;h2 id="二hook-函数">二、Hook 函数&lt;/h2>
&lt;p>demo hookInunidbg 中运行了数个函数，在本节中关注其中运行的 base64_encode 函数。&lt;/p>
&lt;pre tabindex="0">&lt;code>unsigned int
base64_encode(const unsigned char *in, unsigned int inlen, char *out);
&lt;/code>&lt;/pre>&lt;p>参数解释如下&lt;/p>
&lt;blockquote>
&lt;p>char *out：一块 buffer 的首地址，用来存放转码后的内容。&lt;/p>
&lt;p>char *in：原字符串的首地址，指向原字符串内容。&lt;/p>
&lt;p>int inlen：原字符串长度。&lt;/p>
&lt;p>返回值：正常情况下返回转换后字符串的实际长度。&lt;/p>
&lt;/blockquote>
&lt;p>本节的任务就是打印 base64 前的内容，以及编码后的内容。&lt;/p>
&lt;h3 id="1frida">1.Frida&lt;/h3>
&lt;pre tabindex="0">&lt;code>function main(){
var base_addr = Module.findBaseAddress(&amp;#34;libhookinunidbg.so&amp;#34;);
if (base_addr){
var func_addr = Module.findExportByName(&amp;#34;libhookinunidbg.so&amp;#34;, &amp;#34;base64_encode&amp;#34;);
console.log(&amp;#34;hook base64_encode function&amp;#34;)
Interceptor.attach(func_addr,{
onEnter: function (args) {
console.log(&amp;#34;\n input:&amp;#34;)
this.buffer = args[2];
var length = args[1];
console.log(hexdump(args[0],{length: length.toUInt32()}))
console.log(&amp;#34;\n&amp;#34;)
},
onLeave: function () {
console.log(&amp;#34; output:&amp;#34;)
console.log(this.buffer.readCString());
}
})
}
}
setImmediate(main);
&lt;/code>&lt;/pre>&lt;h3 id="2console-debugger">2.Console Debugger&lt;/h3>
&lt;p>Console Debugger 快速打击、快速验证 的交互调试器&lt;/p>
&lt;pre tabindex="0">&lt;code>emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;base64_encode&amp;#34;).getAddress());
&lt;/code>&lt;/pre>&lt;p>需要重申和强调几个概念&lt;/p>
&lt;ul>
&lt;li>运行到对应地址时触发断点，类似于 GDB 调试或者 IDA 调试，时机为&lt;strong>目标指令执行前&lt;/strong>。&lt;/li>
&lt;li>断点不具有函数的种种概念，需要从 ARM 汇编指令的角度去理解函数。&lt;/li>
&lt;li>Console Debugger 用于辅助算法分析，快速分析、确认某个函数的功能。在 Unicorn 引擎下才可以用。&lt;/li>
&lt;/ul>
&lt;p>针对第二条做补充&lt;/p>
&lt;blockquote>
&lt;p>根据 ARM ATPCS 调用约定，当参数个数小于等于 4 个的时候，子程序间通过 R0~R3 来传递参数（即 R0-R3 代表参数 1 - 参数 4），如果参数个数大于 4 个，余下的参数通过 sp 所指向的数据栈进行参数传递。而函数的返回值总是通过 R0 传递回来。&lt;/p>
&lt;/blockquote>
&lt;p>以目标函数为例，函数调用前，调用方把三个参数依次放在 R0-R2 中。&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/2.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/2.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>立即数可以直接查看，比如此处的参数 2 是 5。如果怀疑是指针，比如参数 1 和参数 3，交互调试中输入 mxx 查看。mrx 等价于 Frida 中的 hexdump(xxx)。以这里的 r0 为例，既可以 mr0 也可以 m0x400022e0 查看其指向的内存。&lt;/p>
&lt;p>Unidbg 在数据展示上，相较于 Frida Hexdump，有一些不同，体现在两方面&lt;/p>
&lt;ul>
&lt;li>Frida hexdump 时，左侧基地址从当前地址开始，而 Unidbg 从 0 开始。&lt;/li>
&lt;li>Unidbg 给出了所打印数据块的 md5 值，方便对比两块数据块内容是否一致，而且 Unidbg 展示数据的 Hex String，方便在大量日志中搜索。&lt;/li>
&lt;/ul>
&lt;p>Console Debugger 支持许多调试、分析的命令，全部展示如下&lt;/p>
&lt;pre tabindex="0">&lt;code>c: continue
n: step over
bt: back trace
st hex: search stack
shw hex: search writable heap
shr hex: search readable heap
shx hex: search executable heap
nb: break at next block
s|si: step into
s[decimal]: execute specified amount instruction
s(blx): execute util BLX mnemonic, low performance
m(op) [size]: show memory, default size is 0x70, size may hex or decimal
mr0-mr7, mfp, mip, msp [size]: show memory of specified register
m(address) [size]: show memory of specified address, address must start with 0x
wr0-wr7, wfp, wip, wsp &amp;lt;value&amp;gt;: write specified register
wb(address), ws(address), wi(address) &amp;lt;value&amp;gt;: write (byte, short, integer) memory of specified address, address must start with 0x
wx(address) &amp;lt;hex&amp;gt;: write bytes to memory at specified address, address must start with 0x
b(address): add temporarily breakpoint, address must start with 0x, can be module offset
b: add breakpoint of register PC
r: remove breakpoint of register PC
blr: add temporarily breakpoint of register LR
p (assembly): patch assembly at PC address
where: show java stack trace
trace [begin end]: Set trace instructions
traceRead [begin end]: Set trace memory read
traceWrite [begin end]: Set trace memory write
vm: view loaded modules
vbs: view breakpoints
d|dis: show disassemble
d(0x): show disassemble at specify address
stop: stop emulation
run [arg]: run test
cc size: convert asm from 0x400008a0 - 0x400008a0 + size bytes to c function
&lt;/code>&lt;/pre>&lt;p>在 Frida 代码中，用 &lt;code>console.log(hexdump(args[0],{length: args[1].toUInt32()}))&lt;/code>来表示 &lt;strong>打印参数 1 指向的内存块，以参数 2 为长度&lt;/strong> 这样的效果，Unidbg 中同样可以处理长度。&lt;/p>
&lt;pre tabindex="0">&lt;code>mr0 5
&amp;gt;-----------------------------------------------------------------------------&amp;lt;
[23:41:37 891]r0=RX@0x400022e0[libhookinunidbg.so]0x22e0, md5=f5704182e75d12316f5b729e89a499df, hex=6c696c6163
size: 5
0000: 6C 69 6C 61 63 lilac
^-----------------------------------------------------------------------------^
&lt;/code>&lt;/pre>&lt;p>目前 Console Debugger 还不支持 &lt;em>mr0 r1&lt;/em> 这样的语法。&lt;/p>
&lt;p>至此实现了 Frida OnEnter 的功能，接下来要获取 OnLeave 的时机点，即函数执行完的时机。在 ARM 汇编中，LR 寄存器存放了程序的返回地址，当函数跑到 LR 所指向的地址时，函数已经结束了。又因为断点是在目标地址执行前触发，所以在 LR 处的断点断下时，目标函数执行完且刚执行完，这就是 Frida OnLeave 时机点的原理。在 Console Debugger 交互调试中，使用 blr 命令可以在 lr 处下一个临时断点，它只会触发一次。&lt;/p>
&lt;p>整体逻辑如下&lt;/p>
&lt;ul>
&lt;li>在目标函数的地址处下断点&lt;/li>
&lt;li>运行到断点处，进入 Console Debugger 交互调试&lt;/li>
&lt;li>mxx 系列查看参数&lt;/li>
&lt;li>blr 在函数返回处下断点&lt;/li>
&lt;li>c 使程序继续运行，到返回值处断下&lt;/li>
&lt;li>查看此时的 buffer&lt;/li>
&lt;/ul>
&lt;p>需要注意的是，在 onLeave 中 mr2 是胡闹。R2 只在程序入口处表示参数 3，在函数运算的过程中，R2 作为通用寄存器被用于存储、运算，它已经不是指向 buffer 的地址了。在 Frida 中，我们在 OnEnter 里将 args[2] 即 R2 的值保存在 this.buffer 中，OnLeave 中再取出来打印。而在 Console Debugger 交互调试中，办法更简单粗暴——鼠标往上拉一下，看看原来 r2 的值是什么，发现是 0x401d2000，然后 m0x401d2000。&lt;/p>
&lt;p>这样我们就实现了 Frida 的等效功能。听起来有一些麻烦，但熟练后你会认同我的观点——Console Debugger 是最好最快最稳定的调试工具。除此之外，Console Debugger 也可以做持久化的 Hook，代码如下。&lt;/p>
&lt;pre tabindex="0">&lt;code>public void HookByConsoleDebugger(){
emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;base64_encode&amp;#34;).getAddress(), new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
RegisterContext context = emulator.getContext();
Pointer input = context.getPointerArg(0);
int length = context.getIntArg(1);
Pointer buffer = context.getPointerArg(2);
Inspector.inspect(input.getByteArray(0, length), &amp;#34;base64 input&amp;#34;);
emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
String result = buffer.getString(0);
System.out.println(&amp;#34;base64 result:&amp;#34;+result);
return true;
}
});
return true;
}
});
}
&lt;/code>&lt;/pre>&lt;p>onHit 返回 ture 时，断点触发时不会进入交互界面；为 false 时会。当函数被调用了三五百次时，我们不希望它反复停下来，然后不停 “c” 来继续运行。&lt;/p>
&lt;h3 id="3-第三方-hook-框架">3. 第三方 Hook 框架&lt;/h3>
&lt;p>如下目标函数均在 JNIOnLoad 前调用&lt;/p>
&lt;h4 id="xhook">ⅠxHook&lt;/h4>
&lt;pre tabindex="0">&lt;code>public void HookByXhook(){
IxHook xHook = XHookImpl.getInstance(emulator);
xHook.register(&amp;#34;libhookinunidbg.so&amp;#34;, &amp;#34;base64_encode&amp;#34;, new ReplaceCallback() {
@Override
public HookStatus onCall(Emulator&amp;lt;?&amp;gt; emulator, HookContext context, long originFunction) {
Pointer input = context.getPointerArg(0);
int length = context.getIntArg(1);
Pointer buffer = context.getPointerArg(2);
Inspector.inspect(input.getByteArray(0, length), &amp;#34;base64 input&amp;#34;);
context.push(buffer);
return HookStatus.RET(emulator, originFunction);
}
@Override
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookContext context) {
Pointer buffer = context.pop();
System.out.println(&amp;#34;base64 result:&amp;#34;+buffer.getString(0));
}
}, true);
xHook.refresh();
}
&lt;/code>&lt;/pre>&lt;p>xHook 是爱奇艺开源的 Android PLT hook 框架，优点是挺稳定好用，缺点是不能 Hook Sub_xxx 子函数。&lt;/p>
&lt;h4 id="-hookzz">Ⅱ HookZz&lt;/h4>
&lt;pre tabindex="0">&lt;code>public void HookByHookZz(){
IHookZz hookZz = HookZz.getInstance(emulator);
hookZz.enable_arm_arm64_b_branch();
hookZz.wrap(module.findSymbolByName(&amp;#34;base64_encode&amp;#34;), new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) {
Pointer input = context.getPointerArg(0);
int length = context.getIntArg(1);
Pointer buffer = context.getPointerArg(2);
Inspector.inspect(input.getByteArray(0, length), &amp;#34;base64 input&amp;#34;);
context.push(buffer);
}
@Override
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) {
Pointer buffer = context.pop();
System.out.println(&amp;#34;base64 result:&amp;#34;+buffer.getString(0));
}
});
hookZz.disable_arm_arm64_b_branch();
}
&lt;/code>&lt;/pre>&lt;p>HookZz 也可以实现类似于单行断点的 Hook，但在 Unidbg 的 Hook 大环境下感觉用处不大，不建议使用。&lt;/p>
&lt;pre tabindex="0">&lt;code>IHookZz hookZz = HookZz.getInstance(emulator);
hookZz.instrument(module.base + 0x978 + 1, new InstrumentCallback&amp;lt;RegisterContext&amp;gt;() {
@Override
public void dbiCall(Emulator&amp;lt;?&amp;gt; emulator, RegisterContext ctx, HookEntryInfo info) {
System.out.println(ctx.getIntArg(0));
}
});
&lt;/code>&lt;/pre>&lt;p>HookZz 现在叫 Dobby，Unidbg 中是 HookZz 和 Dobby 是两个独立的 Hook 库，因为作者认为 HookZz 在 arm32 上支持较好，Dobby 在 arm64 上支持较好。HookZz 是 inline hook 方案，因此可以 Hook Sub_xxx，缺点是短函数可能出 bug，受限于 inline Hook 原理。&lt;/p>
&lt;h4 id="-whale">Ⅲ Whale&lt;/h4>
&lt;pre tabindex="0">&lt;code>public void HookByWhale(){
IWhale whale = Whale.getInstance(emulator);
whale.inlineHookFunction(module.findSymbolByName(&amp;#34;base64_encode&amp;#34;), new ReplaceCallback() {
Pointer buffer;
@Override
public HookStatus onCall(Emulator&amp;lt;?&amp;gt; emulator, long originFunction) {
RegisterContext context = emulator.getContext();
Pointer input = context.getPointerArg(0);
int length = context.getIntArg(1);
buffer = context.getPointerArg(2);
Inspector.inspect(input.getByteArray(0, length), &amp;#34;base64 input&amp;#34;);
return HookStatus.RET(emulator, originFunction);
}
@Override
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookContext context) {
System.out.println(&amp;#34;base64 result:&amp;#34;+buffer.getString(0));
}
}, true);
}
&lt;/code>&lt;/pre>&lt;p>Whale 是一个跨平台的 Hook 框架，在 Andorid Native Hook 上也是 inline Hook 方案，具体情况我了解的不多。&lt;/p>
&lt;h3 id="4unicorn-hook">4.Unicorn Hook&lt;/h3>
&lt;p>如果想对某个函数进行集中的、高强度的、同时又灵活的调试，Unicorn CodeHook 是一个好选择。比如我想查看目标函数第一条指令的 r1，第二条指令的 r2，第三条指令的 r3，类似于这种需求。&lt;/p>
&lt;p>hook_add_new 第一个参数是 Hook 回调，我们这里选择 CodeHook，它是逐条指令 Hook，参数 2 是起始地址，参数 3 是结束地址，参数 4 一般填 null。这意味着从起始地址到终止地址这个执行范围内的每条指令，我们都可以在其执行前处理它。&lt;/p>
&lt;p>找到目标函数的代码范围&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/3.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/3.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>public void HookByUnicorn(){
long start = module.base+0x97C;
long end = module.base+0x97C+0x17A;
emulator.getBackend().hook_add_new(new CodeHook() {
@Override
public void hook(Backend backend, long address, int size, Object user) {
RegisterContext registerContext = emulator.getContext();
if(address == module.base + 0x97C){
int r0 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R0);
System.out.println(&amp;#34;0x97C 处 r0:&amp;#34;+Integer.toHexString(r0));
}
if(address == module.base + 0x97C + 2){
int r2 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R2);
System.out.println(&amp;#34;0x97C +2 处 r2:&amp;#34;+Integer.toHexString(r2));
}
if(address == module.base + 0x97C + 4){
int r4 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R4);
System.out.println(&amp;#34;0x97C +4 处 r4:&amp;#34;+Integer.toHexString(r4));
}
}
@Override
public void onAttach(Unicorn.UnHook unHook) {
}
@Override
public void detach() {
}
}, start, end, null);
}
&lt;/code>&lt;/pre>&lt;h2 id="三replace-参数和返回值">三、Replace 参数和返回值&lt;/h2>
&lt;h3 id="1-替换参数">1. 替换参数&lt;/h3>
&lt;p>需求：如果入参为 lilac，改为 hello world，对应的入参长度也要改。正确结果是 &lt;strong>aGVsbG8gd29ybGQ=&lt;/strong>。&lt;/p>
&lt;h4 id="frida">ⅠFrida&lt;/h4>
&lt;pre tabindex="0">&lt;code>function main(){
var base_addr = Module.findBaseAddress(&amp;#34;libhookinunidbg.so&amp;#34;);
if (base_addr){
var func_addr = Module.findExportByName(&amp;#34;libhookinunidbg.so&amp;#34;, &amp;#34;base64_encode&amp;#34;);
console.log(&amp;#34;hook base64_encode function&amp;#34;)
var fakeinput = &amp;#34;hello world&amp;#34;
var fakeinputPtr = Memory.allocUtf8String(fakeinput);
Interceptor.attach(func_addr,{
onEnter: function (args) {
args[0] = fakeinputPtr;
args[1] = ptr(fakeinput.length);
this.buffer = args[2];
},
onLeave: function () {
console.log(&amp;#34; output:&amp;#34;)
console.log(this.buffer.readCString());
}
})
}
}
setImmediate(main);
&lt;/code>&lt;/pre>&lt;h4 id="-console-debugger">Ⅱ Console Debugger&lt;/h4>
&lt;p>快速打击、快速验证的 Console Debugger 如何实现这一目标？&lt;/p>
&lt;p>① 下断点，运行代码后进入 debugger&lt;/p>
&lt;pre tabindex="0">&lt;code>emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;base64_encode&amp;#34;).getAddress());
&lt;/code>&lt;/pre>&lt;p>② 通过命令修改参数 1 和 2&lt;/p>
&lt;pre tabindex="0">&lt;code>wx0x40002403 68656c6c6f20776f726c64
&amp;gt;-----------------------------------------------------------------------------&amp;lt;
[14:06:46 165]RX@0x40002403[libhookinunidbg.so]0x2403, md5=5eb63bbbe01eeed093cb22bb8f5acdc3, hex=68656c6c6f20776f726c64
size: 11
0000: 68 65 6C 6C 6F 20 77 6F 72 6C 64 hello world
^-----------------------------------------------------------------------------^
wr1 11
&amp;gt;&amp;gt;&amp;gt; r1=0xb
&lt;/code>&lt;/pre>&lt;p>Console Debugger 支持下列写操作&lt;/p>
&lt;pre tabindex="0">&lt;code>wr0-wr7, wfp, wip, wsp &amp;lt;value&amp;gt;: write specified register
wb(address), ws(address), wi(address) &amp;lt;value&amp;gt;: write (byte, short, integer) memory of specified address, address must start with 0x
wx(address) &amp;lt;hex&amp;gt;: write bytes to memory at specified address, address must start with 0x
&lt;/code>&lt;/pre>&lt;p>但这其实并不方便，还是做持久化比较舒服。&lt;/p>
&lt;pre tabindex="0">&lt;code>public void ReplaceArgByConsoleDebugger(){
emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;base64_encode&amp;#34;).getAddress(), new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
RegisterContext context = emulator.getContext();
String fakeInput = &amp;#34;hello world&amp;#34;;
int length = fakeInput.length();
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length);
MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true);
fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8));
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer);
Pointer buffer = context.getPointerArg(2);
emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
String result = buffer.getString(0);
System.out.println(&amp;#34;base64 result:&amp;#34;+result);
return true;
}
});
return true;
}
});
}
&lt;/code>&lt;/pre>&lt;h4 id="-第三方-hook-框架">Ⅲ 第三方 Hook 框架&lt;/h4>
&lt;p>变来变去的只有外壳。&lt;/p>
&lt;p>① xHook&lt;/p>
&lt;pre tabindex="0">&lt;code>public void ReplaceArgByXhook(){
IxHook xHook = XHookImpl.getInstance(emulator);
xHook.register(&amp;#34;libhookinunidbg.so&amp;#34;, &amp;#34;base64_encode&amp;#34;, new ReplaceCallback() {
@Override
public HookStatus onCall(Emulator&amp;lt;?&amp;gt; emulator, HookContext context, long originFunction) {
String fakeInput = &amp;#34;hello world&amp;#34;;
int length = fakeInput.length();
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length);
MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true);
fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8));
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer);
Pointer buffer = context.getPointerArg(2);
context.push(buffer);
return HookStatus.RET(emulator, originFunction);
}
@Override
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookContext context) {
Pointer buffer = context.pop();
System.out.println(&amp;#34;base64 result:&amp;#34;+buffer.getString(0));
}
}, true);
xHook.refresh();
}
&lt;/code>&lt;/pre>&lt;p>② HookZz&lt;/p>
&lt;pre tabindex="0">&lt;code>public void ReplaceArgByHookZz(){
IHookZz hookZz = HookZz.getInstance(emulator);
hookZz.enable_arm_arm64_b_branch();
hookZz.wrap(module.findSymbolByName(&amp;#34;base64_encode&amp;#34;), new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) {
Pointer input = context.getPointerArg(0);
String fakeInput = &amp;#34;hello world&amp;#34;;
input.setString(0, fakeInput);
context.setR1(fakeInput.length());
Pointer buffer = context.getPointerArg(2);
context.push(buffer);
}
@Override
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) {
Pointer buffer = context.pop();
System.out.println(&amp;#34;base64 result:&amp;#34;+buffer.getString(0));
}
});
hookZz.disable_arm_arm64_b_branch();
}
&lt;/code>&lt;/pre>&lt;p>因为可以用 HookZzArm32RegisterContext，相对来说代码简单一些。&lt;/p>
&lt;h3 id="2-修改返回值">2. 修改返回值&lt;/h3>
&lt;p>修改返回值的逻辑和替换参数并没什么区别，但它可以引出第四节，所以还是仔细讲一下。&lt;/p>
&lt;p>在 demo 中，有一个 verifyApkSign 函数，它总是返回 1，并导致 APK 校验失败，因此目标就是让它返回 0。&lt;/p>
&lt;pre tabindex="0">&lt;code>extern &amp;#34;C&amp;#34;
JNIEXPORT void JNICALL
Java_com_example_hookinunidbg_MainActivity_call(JNIEnv *env, jobject thiz) {
int verifyret = verifyApkSign();
if(verifyret == 1){
LOGE(&amp;#34;APK sign verify failed!&amp;#34;);
} else{
LOGE(&amp;#34;APK sign verify success!&amp;#34;);
}
testBase64();
}
extern &amp;#34;C&amp;#34; int verifyApkSign(){
LOGE(&amp;#34;verify apk sign&amp;#34;);
return 1;
};
&lt;/code>&lt;/pre>&lt;h4 id="frida-1">ⅠFrida&lt;/h4>
&lt;pre tabindex="0">&lt;code>function main(){
var base_addr = Module.findBaseAddress(&amp;#34;libhookinunidbg.so&amp;#34;);
if (base_addr){
var func_addr = Module.findExportByName(&amp;#34;libhookinunidbg.so&amp;#34;, &amp;#34;verifyApkSign&amp;#34;);
console.log(&amp;#34;hook verifyApkSign function&amp;#34;)
Interceptor.attach(func_addr,{
onEnter: function (args) {
},
onLeave: function (retval) {
retval.replace(0);
}
})
}
}
setImmediate(main);
&lt;/code>&lt;/pre>&lt;h4 id="-console-debugger-1">Ⅱ Console Debugger&lt;/h4>
&lt;pre tabindex="0">&lt;code>public void ReplaceRetByConsoleDebugger(){
emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;verifyApkSign&amp;#34;).getAddress(), new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
RegisterContext context = emulator.getContext();
emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0);
return true;
}
});
return true;
}
});
}
&lt;/code>&lt;/pre>&lt;p>我们的 Hook 生效了，但 verifyApkSign 函数里的 log 还是打印出来了。在一些情况中，我们想改掉函数原本的执行行为，而不是仅仅打印一些信息或者替换入参和返回值。即需要彻底的函数替换——替换原有函数，使用自己的函数。&lt;/p>
&lt;h2 id="四替换函数">四、替换函数&lt;/h2>
&lt;h3 id="1frida-1">1.Frida&lt;/h3>
&lt;pre tabindex="0">&lt;code>const verifyApkSignPtr = Module.findExportByName(&amp;#34;libhookinunidbg.so&amp;#34;, &amp;#34;verifyApkSign&amp;#34;);
Interceptor.replace(verifyApkSignPtr, new NativeCallback(() =&amp;gt; {
console.log(&amp;#34;replace verifyApkSign Function&amp;#34;)
return 0;
}, &amp;#39;void&amp;#39;, []));
&lt;/code>&lt;/pre>&lt;h3 id="2-第三方-hook-框架">2. 第三方 Hook 框架&lt;/h3>
&lt;p>这里只演示 xHook&lt;/p>
&lt;pre tabindex="0">&lt;code>public void ReplaceFuncByHookZz(){
HookZz hook = HookZz.getInstance(emulator);
hook.replace(module.findSymbolByName(&amp;#34;verifyApkSign&amp;#34;).getAddress(), new ReplaceCallback() {
@Override
public HookStatus onCall(Emulator&amp;lt;?&amp;gt; emulator, HookContext context, long originFunction) {
emulator.getBackend().reg_write(Unicorn.UC_ARM_REG_R0,0);
return HookStatus.RET(emulator,context.getLR());
}
});
}
&lt;/code>&lt;/pre>&lt;p>xHook 的版本很清晰易懂，我们做了两件事&lt;/p>
&lt;ul>
&lt;li>R0 赋值为 0&lt;/li>
&lt;li>LR 赋值给 PC，这意味着函数一行不执行就返回了，又因为 R0 赋值 0 所以返回值为 0。&lt;/li>
&lt;/ul>
&lt;h3 id="3console-debugger">3.Console Debugger&lt;/h3>
&lt;pre tabindex="0">&lt;code>public void ReplaceFuncByConsoleDebugger(){
emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;verifyApkSign&amp;#34;).getAddress(), new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
System.out.println(&amp;#34;替换函数 verifyApkSign&amp;#34;);
RegisterContext registerContext = emulator.getContext();
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC, registerContext.getLRPointer().peer);
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0);
return true;
}
});
}
&lt;/code>&lt;/pre>&lt;p>非常清晰易懂。&lt;/p>
&lt;h2 id="五call-函数">五、Call 函数&lt;/h2>
&lt;p>分析具体算法时，常需要对其进行主动调用，进行更灵活和细致的分析&lt;/p>
&lt;p>// TODO&lt;/p>
&lt;h3 id="1frida-2">1.Frida&lt;/h3>
&lt;h3 id="2unidbg">2.Unidbg&lt;/h3>
&lt;h2 id="六patch-与内存检索">六、Patch 与内存检索&lt;/h2>
&lt;h3 id="1patch">1.Patch&lt;/h3>
&lt;p>Patch 就是直接对二进制文件进行修改，Patch 本质上只有两种形式&lt;/p>
&lt;ul>
&lt;li>patch 二进制文件&lt;/li>
&lt;li>在内存里 patch&lt;/li>
&lt;/ul>
&lt;p>Patch 的应用场景很多，在一些场景比 Hook 更好用，这就是需要介绍它的原因。Patch 二进制文件的形式是大多数人所熟悉的，在 IDA 中使用 KeyPatch 打补丁的体验很友好。但这里我们关注的是内存 Patch。&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/6.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/6.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>0x8CA 处调用了签名校验函数，第三四节中通过 Replace 返回值或函数的方式来处理它，但实际上，修改 0x8CA 处这条四字节指令也是好办法。&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/7.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/7.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>需要注意的是，本文只讨论了 arm32，指令集只考虑最常见的 thumb2，arm 以及 arm64 可以自行测试。&lt;/p>
&lt;h4 id="frida-2">ⅠFrida&lt;/h4>
&lt;p>① 方法一&lt;/p>
&lt;pre tabindex="0">&lt;code>var str_name_so = &amp;#34;libhookinunidbg.so&amp;#34;;
var n_addr_func_offset = 0x8CA;
var n_addr_so = Module.findBaseAddress(str_name_so);
var n_addr_assemble = n_addr_so.add(n_addr_func_offset);
Memory.protect(n_addr_assemble, 4, &amp;#39;rwx&amp;#39;);
n_addr_assemble.writeByteArray([0x00, 0x20, 0x00, 0xBF]);
&lt;/code>&lt;/pre>&lt;p>但这并不是最佳实践，因为相较于 Unidbg，Frida 操作在真实 Android 系统上，存在两个问题&lt;/p>
&lt;ul>
&lt;li>是否存在多线程操纵目标地址处的内存？是否有冲突&lt;/li>
&lt;li>arm 的缓存刷新机制&lt;/li>
&lt;/ul>
&lt;p>所以 Frida 提供了更安全可靠的系列 API 来修改内存中的字节&lt;/p>
&lt;p>② 方法二&lt;/p>
&lt;pre tabindex="0">&lt;code>var str_name_so = &amp;#34;libhookinunidbg.so&amp;#34;;
var n_addr_func_offset = 0x8CA;
var n_addr_so = Module.findBaseAddress(str_name_so);
var n_addr_assemble = n_addr_so.add(n_addr_func_offset);
Memory.patchCode(n_addr_assemble, 4, function () {
var cw = new ThumbWriter(n_addr_assemble);
cw.putInstruction(0x2000)
cw.putInstruction(0xBF00);
cw.flush();
console.log(hexdump(n_addr_assemble))
});
&lt;/code>&lt;/pre>&lt;h4 id="-unidbg">Ⅱ Unidbg&lt;/h4>
&lt;p>Unidbg 在修改内存上，既可以传机器码，也可以传汇编指令&lt;/p>
&lt;p>① 方法一&lt;/p>
&lt;pre tabindex="0">&lt;code>public void Patch1(){
int patchCode = 0xBF002000;
emulator.getMemory().pointer(module.base + 0x8CA).setInt(0,patchCode);
}
&lt;/code>&lt;/pre>&lt;p>② 方法二&lt;/p>
&lt;pre tabindex="0">&lt;code>public void Patch2(){
byte[] patchCode = {0x00, 0x20, 0x00, (byte) 0xBF};
emulator.getBackend().mem_write(module.base + 0x8CA, patchCode);
}
&lt;/code>&lt;/pre>&lt;p>③ 方法三&lt;/p>
&lt;pre tabindex="0">&lt;code>public void Patch3(){
try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) {
KeystoneEncoded encoded = keystone.assemble(&amp;#34;movs r0,0;nop&amp;#34;);
byte[] patchCode = encoded.getMachineCode();
emulator.getMemory().pointer(module.base + 0x8CA).write(0, patchCode, 0, patchCode.length);
}
}
&lt;/code>&lt;/pre>&lt;h3 id="2-内存检索">2. 内存检索&lt;/h3>
&lt;p>假设 SO 存在碎片化，比如要分析某个 SO 的多个版本，需要 Patch 签名校验或者某处汇编，地址在不同版本不固定，但函数特征固定，内存检索 + 动态 Patch 就是一个好办法，可以很好适应不同版本、碎片化。&lt;/p>
&lt;p>搜索特征片段依据需求，可能是搜索函数开头十字节，也可能是搜索目标地址上下字节或者其他。&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/8.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h4 id="frida-3">ⅠFrida&lt;/h4>
&lt;pre tabindex="0">&lt;code>function searchAndPatch() {
var module = Process.findModuleByName(&amp;#34;libhookinunidbg.so&amp;#34;);
var pattern = &amp;#34;80 b5 6f 46 84 b0 03 90 02 91&amp;#34;
var matches = Memory.scanSync(module.base, module.size, pattern);
console.log(matches.length)
if (matches.length !== 0)
{
var n_addr_assemble = matches[0].address.add(10);
Memory.patchCode(n_addr_assemble, 4, function () {
var cw = new ThumbWriter(n_addr_assemble);
cw.putInstruction(0x2000)
cw.putInstruction(0xBF00);
cw.flush();
console.log(hexdump(n_addr_assemble))
});
}
}
setImmediate(searchAndPatch);
&lt;/code>&lt;/pre>&lt;h4 id="-unidbg-1">Ⅱ Unidbg&lt;/h4>
&lt;pre tabindex="0">&lt;code>public void SearchAndPatch(){
byte[] patterns = {(byte) 0x80, (byte) 0xb5,0x6f,0x46, (byte) 0x84, (byte) 0xb0,0x03, (byte) 0x90,0x02, (byte) 0x91};
Collection&amp;lt;Pointer&amp;gt; pointers = searchMemory(module.base, module.base+module.size, patterns);
if(pointers.size() &amp;gt; 0){
try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) {
KeystoneEncoded encoded = keystone.assemble(&amp;#34;movs r0,0;nop&amp;#34;);
byte[] patchCode = encoded.getMachineCode();
((ArrayList&amp;lt;Pointer&amp;gt;) pointers).get(0).write(10, patchCode, 0, patchCode.length);
}
}
}
private Collection&amp;lt;Pointer&amp;gt; searchMemory(long start, long end, byte[] data) {
List&amp;lt;Pointer&amp;gt; pointers = new ArrayList&amp;lt;&amp;gt;();
for (long i = start, m = end - data.length; i &amp;lt; m; i++) {
byte[] oneByte = emulator.getBackend().mem_read(i, 1);
if (data[0] != oneByte[0]) {
continue;
}
if (Arrays.equals(data, emulator.getBackend().mem_read(i, data.length))) {
pointers.add(UnidbgPointer.pointer(emulator, i));
i += (data.length - 1);
}
}
return pointers;
}
&lt;/code>&lt;/pre>&lt;p>&lt;em>值得一提的是，本节的内容也可用 &lt;a href="https://github.com/lief-project/LIEF" target="_blank" rel="noopener">LIEF&lt;/a> Patch 二进制文件实现。&lt;/em>&lt;/p>
&lt;h2 id="七hook-时机过晚问题">七、Hook 时机过晚问题&lt;/h2>
&lt;p>上文中，Hook 代码都位于 &lt;strong>SO 加载后， 执行 JNI_OnLoad 之前&lt;/strong>，和如下 Frida 代码同等时机。&lt;/p>
&lt;pre tabindex="0">&lt;code>var android_dlopen_ext = Module.findExportByName(null, &amp;#34;android_dlopen_ext&amp;#34;);
if (android_dlopen_ext != null) {
Interceptor.attach(android_dlopen_ext, {
onEnter: function (args) {
this.hook = false;
var soName = args[0].readCString();
if (soName.indexOf(&amp;#34;libhookinunidbg.so&amp;#34;) !== -1) {
this.hook = true;
}
},
onLeave: function (retval) {
if (this.hook) {
this.hook = false;
}
}
});
}
&lt;/code>&lt;/pre>&lt;p>但如果**.init 和. init_array 段**存在代码逻辑（init→init_array→JNIOnLoad），Hook 时机就太晚了，这种情况下就需要将 Hook 时机点提前到 init 执行前。&lt;/p>
&lt;p>在 Frida 中，为了实现这一点，需要在 linker 中做文章，通常做法是 Hook Linker 中的 call_function 或 call_constructor 函数。而在 Unidbg 中，有以下一些办法。&lt;/p>
&lt;p>以我们的 demo hookInUnidbg 为例，其中 init 段里就有如下逻辑，比较两个字符串的大小。&lt;/p>
&lt;pre tabindex="0">&lt;code>extern &amp;#34;C&amp;#34; void _init(void) {
char str1[15];
char str2[15];
int ret;
strcpy(str1, &amp;#34;abcdef&amp;#34;);
strcpy(str2, &amp;#34;ABCDEF&amp;#34;);
ret = strcmp(str1, str2);
if(ret &amp;lt; 0)
{
LOGI(&amp;#34;str1 小于 str2&amp;#34;);
}
else if(ret &amp;gt; 0)
{
LOGI(&amp;#34;str1 大于 str2&amp;#34;);
}
else
{
LOGI(&amp;#34;str1 等于 str2&amp;#34;);
}
}
&lt;/code>&lt;/pre>&lt;p>当前显示 &lt;strong>str1 大于 str2&lt;/strong>，我们的 Hook 目标是让其显示 &lt;strong>str1 小于 str2&lt;/strong>。&lt;/p>
&lt;h3 id="1-提前加载-libc">1. 提前加载 libc&lt;/h3>
&lt;p>提前加载 libc，然后 hook strcmp 函数，修改其返回值为 - 1 是一个办法。如下是完整代码，提供了 Console Debugger 以及 HookZz 两个版本。&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tutorial;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.BreakPointCallback;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.memory.Memory;
import unicorn.ArmConst;
import java.io.File;
public class hookInUnidbg {
private final AndroidEmulator emulator;
private final VM vm;
private final Module module;
private final Module moduleLibc;
hookInUnidbg() {
emulator = AndroidEmulatorBuilder.for32Bit().build();
final Memory memory = emulator.getMemory();
memory.setLibraryResolver(new AndroidResolver(23));
vm = emulator.createDalvikVM(new File(&amp;#34;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&amp;#34;));
DalvikModule dmLibc = vm.loadLibrary(new File(&amp;#34;unidbg-android/src/main/resources/android/sdk23/lib/libc.so&amp;#34;), true);
moduleLibc = dmLibc.getModule();
hookStrcmpByUnicorn();
DalvikModule dm = vm.loadLibrary(&amp;#34;hookinunidbg&amp;#34;, true);
module = dm.getModule();
dm.callJNI_OnLoad(emulator);
}
public void call(){
DvmClass dvmClass = vm.resolveClass(&amp;#34;com/example/hookinunidbg/MainActivity&amp;#34;);
String methodSign = &amp;#34;call()V&amp;#34;;
DvmObject&amp;lt;?&amp;gt; dvmObject = dvmClass.newObject(null);
dvmObject.callJniMethodObject(emulator, methodSign);
}
public static void main(String[] args) {
hookInUnidbg mydemo = new hookInUnidbg();
mydemo.call();
}
public void hookStrcmpByUnicorn(){
emulator.attach().addBreakPoint(moduleLibc.findSymbolByName(&amp;#34;strcmp&amp;#34;).getAddress(), new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
RegisterContext registerContext = emulator.getContext();
String arg1 = registerContext.getPointerArg(0).getString(0);
emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
if(arg1.equals(&amp;#34;abcdef&amp;#34;)){
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, -1);
}
return true;
}
});
return true;
}
});
}
public void hookStrcmpByHookZz(){
IHookZz hookZz = HookZz.getInstance(emulator);
hookZz.enable_arm_arm64_b_branch();
hookZz.wrap(moduleLibc.findSymbolByName(&amp;#34;strcmp&amp;#34;), new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
String arg1;
@Override
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
arg1 = ctx.getPointerArg(0).getString(0);
}
@Override
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
if(arg1.equals(&amp;#34;abcdef&amp;#34;)){
ctx.setR0(-1);
}
}
});
hookZz.disable_arm_arm64_b_branch();
}
}
&lt;/code>&lt;/pre>&lt;p>但如果想 hook 的目标函数不是 libc 里的函数，就没效果了。比如想在 0x978 下个断点。&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/9.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/9.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h3 id="2-固定地址下断点">2. 固定地址下断点&lt;/h3>
&lt;p>这是最常用也最方便的方式，但只有 Unicorn 引擎下可以使用。&lt;/p>
&lt;p>通过 &lt;code>vm.loadLibrary&lt;/code> 加载的第一个用户 SO，其基地址是 0x40000000，因此可以在 IDA 中看函数偏移，通过绝对地址 Console Debugger Hook。&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tutorial;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.BreakPointCallback;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.memory.Memory;
import unicorn.ArmConst;
import java.io.File;
public class hookInUnidbg {
private final AndroidEmulator emulator;
private final VM vm;
private final Module module;
private Module moduleLibc;
hookInUnidbg() {
emulator = AndroidEmulatorBuilder.for32Bit().build();
final Memory memory = emulator.getMemory();
memory.setLibraryResolver(new AndroidResolver(23));
vm = emulator.createDalvikVM(new File(&amp;#34;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&amp;#34;));
emulator.attach().addBreakPoint(0x40000000 + 0x978);
DalvikModule dm = vm.loadLibrary(&amp;#34;hookinunidbg&amp;#34;, true);
module = dm.getModule();
dm.callJNI_OnLoad(emulator);
}
public void call(){
DvmClass dvmClass = vm.resolveClass(&amp;#34;com/example/hookinunidbg/MainActivity&amp;#34;);
String methodSign = &amp;#34;call()V&amp;#34;;
DvmObject&amp;lt;?&amp;gt; dvmObject = dvmClass.newObject(null);
dvmObject.callJniMethodObject(emulator, methodSign);
}
public static void main(String[] args) {
hookInUnidbg mydemo = new hookInUnidbg();
mydemo.call();
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://blog.seeflower.dev/images/10.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/10.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>如果加载了多个用户 SO，可以先运行一遍代码，确认目标 SO 的基地址（Unidbg 中不存在地址随机化，目标函数每次地址都固定。）然后在 loadLibrary 前 Hook 该地址，即可保证 Hook 不遗漏。&lt;/p>
&lt;h3 id="3-使用-unidbg-提供的模块监听器">3. 使用 Unidbg 提供的模块监听器&lt;/h3>
&lt;p>实现自己的模块监听器&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tutorial;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.ModuleListener;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.hook.hookzz.HookEntryInfo;
import com.github.unidbg.hook.hookzz.HookZz;
import com.github.unidbg.hook.hookzz.InstrumentCallback;
public class MyModuleListener implements ModuleListener {
private HookZz hook;
@Override
public void onLoaded(Emulator&amp;lt;?&amp;gt; emulator, Module module) {
if(module.name.equals(&amp;#34;libc.so&amp;#34;)){
hook = HookZz.getInstance(emulator);
}
if(module.name.equals(&amp;#34;libhookinunidbg.so&amp;#34;)){
hook.instrument(module.base + 0x978 + 1, new InstrumentCallback&amp;lt;RegisterContext&amp;gt;() {
@Override
public void dbiCall(Emulator&amp;lt;?&amp;gt; emulator, RegisterContext ctx, HookEntryInfo info) {
System.out.println(ctx.getIntArg(0));
}
});
}
}
}
&lt;/code>&lt;/pre>&lt;p>通过&lt;code>memory.addModuleListener&lt;/code>绑定。&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tutorial;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.memory.Memory;
import java.io.File;
public class hookInUnidbg{
private final AndroidEmulator emulator;
private final VM vm;
hookInUnidbg() {
emulator = AndroidEmulatorBuilder.for32Bit().build();
final Memory memory = emulator.getMemory();
memory.addModuleListener(new MyModuleListener());
memory.setLibraryResolver(new AndroidResolver(23));
vm = emulator.createDalvikVM(new File(&amp;#34;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&amp;#34;));
DalvikModule dm = vm.loadLibrary(&amp;#34;hookinunidbg&amp;#34;, true);
Module module = dm.getModule();
dm.callJNI_OnLoad(emulator);
}
public void call(){
DvmClass dvmClass = vm.resolveClass(&amp;#34;com/example/hookinunidbg/MainActivity&amp;#34;);
String methodSign = &amp;#34;call()V&amp;#34;;
DvmObject&amp;lt;?&amp;gt; dvmObject = dvmClass.newObject(null);
dvmObject.callJniMethodObject(emulator, methodSign);
}
public static void main(String[] args) {
hookInUnidbg mydemo = new hookInUnidbg();
mydemo.call();
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;em>每种方法都有对应使用场景，按需使用。除此之外也可以修改 Unidbg 源码，在 callInitFunction 函数前添加自己的逻辑。&lt;/em>&lt;/p>
&lt;h2 id="八条件断点">八、条件断点&lt;/h2>
&lt;p>在算法分析时，条件断点可以减少干扰信息。以 strcmp 为例，整个进程的所有模块都可能调用 strcmp 函数。&lt;/p>
&lt;h3 id="1-限定于某-so">1. 限定于某 SO&lt;/h3>
&lt;h4 id="frida-4">ⅠFrida&lt;/h4>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(
Module.findExportByName(&amp;#34;libc.so&amp;#34;, &amp;#34;strcmp&amp;#34;), {
onEnter: function(args) {
var moduleName = Process.getModuleByAddress(this.returnAddress).name;
console.log(&amp;#34;strcmp arg1:&amp;#34;+args[0].readCString())
console.log(&amp;#34;call from :&amp;#34;+moduleName)
},
onLeave: function(ret) {
}
}
);
&lt;/code>&lt;/pre>&lt;h4 id="-unidbg-2">Ⅱ Unidbg&lt;/h4>
&lt;pre tabindex="0">&lt;code>public void hookstrcmp(){
long address = module.findSymbolByName(&amp;#34;strcmp&amp;#34;).getAddress();
emulator.attach().addBreakPoint(address, new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
RegisterContext registerContext = emulator.getContext();
String arg1 = registerContext.getPointerArg(0).getString(0);
String moduleName = emulator.getMemory().findModuleByAddress(registerContext.getLRPointer().peer).name;
if(moduleName.equals(&amp;#34;libhookinunidbg.so&amp;#34;)){
System.out.println(&amp;#34;strcmp arg1:&amp;#34;+arg1);
}
return true;
}
});
}
&lt;/code>&lt;/pre>&lt;h3 id="2-限定于某函数">2. 限定于某函数&lt;/h3>
&lt;p>比如某个函数在 SO 中被大量使用，现在只想分析这个函数在函数 a 中的使用。&lt;/p>
&lt;h4 id="frida-5">ⅠFrida&lt;/h4>
&lt;pre tabindex="0">&lt;code>var show = false;
Interceptor.attach(
Module.findExportByName(&amp;#34;libc.so&amp;#34;, &amp;#34;strcmp&amp;#34;), {
onEnter: function(args) {
if(show){
console.log(&amp;#34;strcmp arg1:&amp;#34;+args[0].readCString())
}
},
onLeave: function(ret) {
}
}
);
Interceptor.attach(
Module.findExportByName(&amp;#34;libhookinunidbg.so&amp;#34;, &amp;#34;targetfunction&amp;#34;),{
onEnter: function(args) {
show = this;
},
onLeave: function(ret) {
show = false;
}
}
)
&lt;/code>&lt;/pre>&lt;h4 id="-unidbg-3">Ⅱ Unidbg&lt;/h4>
&lt;pre tabindex="0">&lt;code>public void hookstrcmp(){
emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;targetfunction&amp;#34;).getAddress(), new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
RegisterContext registerContext = emulator.getContext();
show = true;
emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
show = false;
return true;
}
});
return true;
}
});
emulator.attach().addBreakPoint(module.findSymbolByName(&amp;#34;strcmp&amp;#34;).getAddress(), new BreakPointCallback() {
@Override
public boolean onHit(Emulator&amp;lt;?&amp;gt; emulator, long address) {
RegisterContext registerContext = emulator.getContext();
String arg1 = registerContext.getPointerArg(0).getString(0);
if(show){
System.out.println(&amp;#34;strcmp arg1:&amp;#34;+arg1);
}
return true;
}
});
}
&lt;/code>&lt;/pre>&lt;h3 id="3-限定于某处">3. 限定于某处&lt;/h3>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/11.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/11.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>比如上图，只关注 0xA00 处发生的 strcmp。一个办法是 hook strcmp 函数，只在 lr 寄存器 = module.base + 0xA00 + 4 + 1 时打印输出。&lt;/p>
&lt;p>另一个办法是 Console Debugger , 也很方便。&lt;/p>
&lt;pre tabindex="0">&lt;code>emulator.attach().addBreakPoint(module, 0xA00);
emulator.attach().addBreakPoint(module, 0xA04);
&lt;/code>&lt;/pre>&lt;p>一定要掌握这些知识，并做到灵活变通。在实战中，诸如 “A hook 生效后再打印 B 函数的输出 “是很常见的，否则每个函数都打印几百行看的人眼都迷糊。&lt;/p>
&lt;h2 id="九系统调用拦截以时间为例">九、系统调用拦截——以时间为例&lt;/h2>
&lt;p>这里说的系统调用拦截，并不是要对系统调用进行 Hook，比如 &lt;a href="https://github.com/AeonLucid/frida-syscall-interceptor" target="_blank" rel="noopener">frida - syscall - intercceptor&lt;/a> 这样，系统调用全部是 Unidbg 自己实现的，日志一开就能看，显然也没有 Hook 的必要。Unidbg 的&lt;strong>系统调用拦截&lt;/strong>是为了替换系统调用，修改 Unidbg 中系统调用的实现。&lt;/p>
&lt;p>有两个问题需要解释&lt;/p>
&lt;ul>
&lt;li>
&lt;p>为什么要修改系统调用？&lt;/p>
&lt;p>Unidbg 中部分系统调用没实现或者没实现好，以及有时候想要固定其输出，比如获取时间的系统调用，这些需求需要我们修复或修改 Unidbg 中系统调用的实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为什么不直接修改 Unidbg 源码&lt;/p>
&lt;p>1 是灵活性较差，2 是我们的实现或修改并不是完美的，直接改 Unidbg 源码是对运行环境的污染，影响其他项目。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在分析算法时，输入不变的前提下，如果输出在不停变化，会干扰算法分析，这种情况的一大来源是时间戳参与了运算。在 Frida 中，为了控制这种干扰因素，常常会 Hook libc 的 gettimeodfay 这个时间获取函数。&lt;/p>
&lt;h3 id="1frida-3">1.Frida&lt;/h3>
&lt;p>&lt;em>hook time&lt;/em>&lt;/p>
&lt;pre tabindex="0">&lt;code>var time = Module.findExportByName(null, &amp;#34;time&amp;#34;);
if (time != null) {
Interceptor.attach(time, {
onEnter: function (args) {
},
onLeave: function (retval) {
retval.replace(100);
}
})
}
&lt;/code>&lt;/pre>&lt;p>&lt;em>hook gettimeofday&lt;/em>&lt;/p>
&lt;pre tabindex="0">&lt;code>function hook_gettimeofday() {
var addr_gettimeofday = Module.findExportByName(null, &amp;#34;gettimeofday&amp;#34;);
var gettimeofday = new NativeFunction(addr_gettimeofday, &amp;#34;int&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
Interceptor.replace(addr_gettimeofday, new NativeCallback(function (ptr_tz, ptr_tzp) {
var result = gettimeofday(ptr_tz, ptr_tzp);
if (result == 0) {
console.log(&amp;#34;hook gettimeofday:&amp;#34;, ptr_tz, ptr_tzp, result);
var t = new Int32Array(ArrayBuffer.wrap(ptr_tz, 8));
t[0] = 0xAAAA;
t[1] = 0xBBBB;
console.log(hexdump(ptr_tz));
}
return result;
}, &amp;#34;int&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]));
}
&lt;/code>&lt;/pre>&lt;p>但 Frida 做这件事并不容易做圆满，单是 libc.so，就有 time、gettimeodfay、clock_gettime、clock 这四个库函数可以获取时间戳，而且样本可以通过内联汇编使用系统调用，获取时间戳。&lt;/p>
&lt;h3 id="2unidbg-1">2.Unidbg&lt;/h3>
&lt;p>Unidbg 中可以更方便、更大范围的固定时间，不必像 Frida 那般。time 和 gettimeodfay 库函数基于 gettimeodfay 这个系统调用，clock_gettime 和 clock 基于 clock_gettime 系统调用。所以只要在 Unidbg 中固定 gettimeodfay 和 clock_gettime 这两个系统调用获取的时间戳，就可以一劳永逸。&lt;/p>
&lt;p>首先实现时间相关的系统调用处理器，其中的 &lt;em>System.currentTimeMillis()&lt;/em> 和 &lt;em>System.nanoTime()&lt;/em> 改成定数。&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tutorial;
import com.github.unidbg.Emulator;
import com.github.unidbg.linux.ARM32SyscallHandler;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.unix.struct.TimeVal32;
import com.github.unidbg.unix.struct.TimeZone;
import com.sun.jna.Pointer;
import unicorn.ArmConst;
import java.util.Calendar;
public class TimeSyscallHandler extends ARM32SyscallHandler {
public TimeSyscallHandler(SvcMemory svcMemory) {
super(svcMemory);
}
@Override
protected boolean handleUnknownSyscall(Emulator emulator, int NR) {
switch (NR) {
case 78:
mygettimeofday(emulator);
return true;
case 263:
myclock_gettime(emulator);
return true;
}
return super.handleUnknownSyscall(emulator, NR);
}
private void mygettimeofday(Emulator&amp;lt;?&amp;gt; emulator) {
Pointer tv = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
Pointer tz = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, mygettimeofday(tv, tz));
};
private int mygettimeofday(Pointer tv, Pointer tz) {
long currentTimeMillis = System.currentTimeMillis();
long tv_sec = currentTimeMillis / 1000;
long tv_usec = (currentTimeMillis % 1000) * 1000;
TimeVal32 timeVal = new TimeVal32(tv);
timeVal.tv_sec = (int) tv_sec;
timeVal.tv_usec = (int) tv_usec;
timeVal.pack();
if (tz != null) {
Calendar calendar = Calendar.getInstance();
int tz_minuteswest = -(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 1000);
TimeZone timeZone = new TimeZone(tz);
timeZone.tz_minuteswest = tz_minuteswest;
timeZone.tz_dsttime = 0;
timeZone.pack();
}
return 0;
}
private static final int CLOCK_REALTIME = 0;
private static final int CLOCK_MONOTONIC = 1;
private static final int CLOCK_THREAD_CPUTIME_ID = 3;
private static final int CLOCK_MONOTONIC_RAW = 4;
private static final int CLOCK_MONOTONIC_COARSE = 6;
private static final int CLOCK_BOOTTIME = 7;
private final long nanoTime = System.nanoTime();
private int myclock_gettime(Emulator&amp;lt;?&amp;gt; emulator) {
int clk_id = emulator.getBackend().reg_read(ArmConst.UC_ARM_REG_R0).intValue();
Pointer tp = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
long offset = clk_id == CLOCK_REALTIME ? System.currentTimeMillis() * 1000000L : System.nanoTime() - nanoTime;
long tv_sec = offset / 1000000000L;
long tv_nsec = offset % 1000000000L;
switch (clk_id) {
case CLOCK_REALTIME:
case CLOCK_MONOTONIC:
case CLOCK_MONOTONIC_RAW:
case CLOCK_MONOTONIC_COARSE:
case CLOCK_BOOTTIME:
tp.setInt(0, (int) tv_sec);
tp.setInt(4, (int) tv_nsec);
return 0;
case CLOCK_THREAD_CPUTIME_ID:
tp.setInt(0, 0);
tp.setInt(4, 1);
return 0;
}
throw new UnsupportedOperationException(&amp;#34;clk_id=&amp;#34; + clk_id);
}
}
&lt;/code>&lt;/pre>&lt;p>在自己的模拟器上使用它，原来模拟器创建是这么一句&lt;/p>
&lt;pre tabindex="0">&lt;code>emulator = AndroidEmulatorBuilder.for32Bit().build();
&lt;/code>&lt;/pre>&lt;p>修改如下&lt;/p>
&lt;pre tabindex="0">&lt;code>AndroidEmulatorBuilder builder = new AndroidEmulatorBuilder(false) {
public AndroidEmulator build() {
return new AndroidARMEmulator(processName, rootDir,
backendFactories) {
@Override
protected UnixSyscallHandler&amp;lt;AndroidFileIO&amp;gt;
createSyscallHandler(SvcMemory svcMemory) {
return new TimeSyscallHandler(svcMemory);
}
};
}
};
emulator = builder.build();
&lt;/code>&lt;/pre>&lt;h2 id="十hook-检测">十、Hook 检测&lt;/h2>
&lt;p>Anti Unidbg 的方法浩如烟海，但事实上几乎没有主动 Anti Unidbg 的样本，有两方面原因&lt;/p>
&lt;ul>
&lt;li>Unidbg 自身的多个重大弱点没有解决，比如多线程和信号机制尚未实现。&lt;/li>
&lt;li>Unidbg 普及率和推广度还不高。&lt;/li>
&lt;/ul>
&lt;p>所以本节专注于 Hook 检测。&lt;/p>
&lt;h3 id="1-检测第三方-hook-框架">1. 检测第三方 Hook 框架&lt;/h3>
&lt;p>基于其 Hook 实现原理，可以对应检测。&lt;/p>
&lt;h4 id="inline-hook">ⅠInline Hook&lt;/h4>
&lt;p>以我熟悉的 inline Hook 检测为例，inline Hook 需要修改 Hook 处的前几个字节，跳转到自己的地方实现逻辑，最后再跳转回来。那么就有两类思路实现检测，首先开辟一个检测线程，对关键函数做如下二选一循环操作&lt;/p>
&lt;ul>
&lt;li>函数开头前几个字节是否被篡改&lt;/li>
&lt;li>函数体是否完整未被修改，常使用 crc32 校验，为什么不用 md5 或其他哈希函数？因为 crc32 极快，性能影响小，碰撞率又在可接受的范围内&lt;/li>
&lt;/ul>
&lt;p>相关项目：&lt;a href="https://github.com/liaogang/check_fish_inline_hook" target="_blank" rel="noopener">check_fish_inline_hook&lt;/a>&lt;/p>
&lt;h4 id="-got-hook">Ⅱ Got Hook&lt;/h4>
&lt;p>相关项目：&lt;a href="https://github.com/SliverBullet5563/CheckGotHook" target="_blank" rel="noopener">SliverBullet5563/CheckGotHook: 检测 got hook（使用 xhook 测试）&lt;/a>&lt;/p>
&lt;h3 id="2-检测-unicorn-based-hook">2. 检测 Unicorn Based Hook&lt;/h3>
&lt;p>Unicorn Hook 似乎不可检测，但 Unicorn 也是可检测的。在星球的 Anti-Unidbg 系列，就提到过一种检测方式。在 Android 系统中，只支持对四字节对齐的内存地址做读写操作，所以通过内联汇编尝试向 SP+1 的位置做读写，在真机上会导致 App 崩溃，而 Unidbg 模拟执行不会出任何问题。当然，我们并不希望 App 崩溃，所以需要在代码中实现自己的信号处理函数，当此处发生异常时，信号处理函数接收信号并做出某种处理，因为 Unidbg 中程序不会异常，所以也不会走到信号处理函数，这里面可以设计形成差异。&lt;/p>
&lt;p>除此之外，Unicorn 下断点调试或者做指令追踪时，必然会导致函数运行时间超出常理，基于运行时间的反调试策略也可行。&lt;/p>
&lt;h2 id="十一unidbg-trace-四件套">十一、Unidbg Trace 四件套&lt;/h2>
&lt;p>基于 Frida 存在许多 trace 方案，比如用于 trace JNI 函数的 &lt;a href="https://github.com/chame1eon/jnitrace" target="_blank" rel="noopener">JNItrace&lt;/a>，用于 trace Java 调用的 &lt;a href="https://github.com/hluwa/ZenTracer" target="_blank" rel="noopener">ZenTrace&lt;/a>、&lt;a href="https://github.com/r0ysue/r0tracer" target="_blank" rel="noopener">r0tracer&lt;/a>，又或者是官方的多功能 trace 工具 &lt;a href="https://frida.re/docs/frida-trace/" target="_blank" rel="noopener">frida-trace&lt;/a>，用于指令级 trace 的 &lt;a href="https://frida.re/docs/stalker/" target="_blank" rel="noopener">Frida Stalker&lt;/a>，又或者是 trace SO 中所有函数的 &lt;a href="https://github.com/Pr0214/trace_natives" target="_blank" rel="noopener">trace_natives&lt;/a> ，以及 Linux 上著名的 &lt;a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html" target="_blank" rel="noopener">strace&lt;/a> 或者 基于 Frida 的 &lt;a href="https://github.com/AeonLucid/frida-syscall-interceptor" target="_blank" rel="noopener">frida-syscall-interceptor&lt;/a>，用于 trace 系统调用。&lt;/p>
&lt;p>在 Unidbg 上，上述的大部分 trace，只需要调整日志等级就能实现。我们这里所讲的 trace，聚焦于如何让使用者对代码执行流有更强的掌控。&lt;/p>
&lt;h3 id="1instruction-tracing">1.Instruction tracing&lt;/h3>
&lt;p>令追踪包括两部分&lt;/p>
&lt;ul>
&lt;li>记录每条指令的执行，打印地址、机器码、汇编等信息&lt;/li>
&lt;li>打印每条指令相关的寄存器值&lt;/li>
&lt;/ul>
&lt;p>Unidbg 基于 Unicorn CodeHook 封装了指令追踪，方法和效果如下&lt;/p>
&lt;pre tabindex="0">&lt;code>TraceHook traceCode();
TraceHook traceCode(long begin, long end);
TraceHook traceCode(long begin, long end, TraceCodeListener listener);
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://blog.seeflower.dev/images/12.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/12.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Unidbg 的指令追踪，在第一部分的工作做得很好，采用 模块名 + 相对偏移 + 机器码 + 绝对地址 + 汇编 的展示形式，但美中不足的是，它并没有做第二部分的工作，可以使用如下的脚本在 Unidbg 中实现完善的指令追踪，其原理也是实现了一个自己的 codehook。&lt;/p>
&lt;p>&lt;a href="https://github.com/zhkl0228/unidbg/pull/214/commits/64f9835ebc0d529b2b92cf2bb4846210dff20e3c" target="_blank" rel="noopener">增加 trace 的部分 by dqzg12300 · Pull Request #214&lt;/a>&lt;/p>
&lt;h3 id="2function-tracing">2.Function Tracing&lt;/h3>
&lt;p>指令 Trace 是最细粒度的 Trace，优点是细，缺点是动辄数百上千万行，让人迷失其中。函数粒度的 trace 则不然，粗糙但容易理解全貌，在算法还原的一些场景中会起到帮助。在 IDA Debug 中，即可选择函数追踪来记录函数调用，包括了有符号函数以及 IDA 识别并命名为 Sub_addr 的子函数。&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/13.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/13.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>在 Frida 上，可以使用 &lt;a href="https://github.com/Pr0214/trace_natives" target="_blank" rel="noopener">trace_natives&lt;/a> 对 一个 SO 中的全部函数进行 Trace，并形成如下调用图。&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/14.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/14.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Unidbg 中可以做到这一点吗？不妨看一下 Frida trace_natives 脚本，其中有三个关注点。&lt;/p>
&lt;ul>
&lt;li>如何获得一个 SO 的全部函数列表，就像 IDA 一样&lt;/li>
&lt;li>如何 Hook 函数&lt;/li>
&lt;li>如何获得调用层级关系，形成树结构&lt;/li>
&lt;/ul>
&lt;p>关于问题 1，trace_natives 怎么解决的？直接编写 IDA 脚本获取 IDA 的函数列表&lt;/p>
&lt;pre tabindex="0">&lt;code>def getFunctionList():
functionlist = &amp;#34;&amp;#34;
minLength = 10
maxAddress = ida_ida.inf_get_max_ea()
for func in idautils.Functions(0, maxAddress):
if len(list(idautils.FuncItems(func))) &amp;gt; minLength:
functionName = str(idaapi.ida_funcs.get_func_name(func))
oneFunction = hex(func) + &amp;#34;!&amp;#34; + functionName + &amp;#34;\t\n&amp;#34;
functionlist += oneFunction
return functionlist
&lt;/code>&lt;/pre>&lt;p>脚本获取了函数以及对应函数名列表，同时通过 minLength 过滤较短的函数，至少包含 10 条汇编指令的函数才会被计入。这么做有两个原因&lt;/p>
&lt;ul>
&lt;li>过短的函数可能导致 Frida Hook 失败（inline hook 原理所致）&lt;/li>
&lt;li>过短的函数可能是工具函数，调用次数多，但价值不大，让调用图变得臃肿不堪&lt;/li>
&lt;/ul>
&lt;p>完整的 IDA 插件 getFunctions 代码如下&lt;/p>
&lt;pre tabindex="0">&lt;code>import os
import time
import ida_ida
import ida_nalt
import idaapi
import idautils
from idaapi import plugin_t
from idaapi import PLUGIN_PROC
from idaapi import PLUGIN_OK
def getFunctionList():
functionlist = &amp;#34;&amp;#34;
minLength = 10
maxAddress = ida_ida.inf_get_max_ea()
for func in idautils.Functions(0, maxAddress):
if len(list(idautils.FuncItems(func))) &amp;gt; minLength:
functionName = str(idaapi.ida_funcs.get_func_name(func))
oneFunction = hex(func) + &amp;#34;!&amp;#34; + functionName + &amp;#34;\t\n&amp;#34;
functionlist += oneFunction
return functionlist
def getSoPathAndName():
fullpath = ida_nalt.get_input_file_path()
filepath, filename = os.path.split(fullpath)
return filepath, filename
class getFunctions(plugin_t):
flags = PLUGIN_PROC
comment = &amp;#34;getFunctions&amp;#34;
help = &amp;#34;&amp;#34;
wanted_name = &amp;#34;getFunctions&amp;#34;
wanted_hotkey = &amp;#34;&amp;#34;
def init(self):
print(&amp;#34;getFunctions(v0.1) plugin has been loaded.&amp;#34;)
return PLUGIN_OK
def run(self, arg):
so_path, so_name = getSoPathAndName()
functionlist = getFunctionList()
script_name = so_name.split(&amp;#34;.&amp;#34;)[0] + &amp;#34;_functionlist_&amp;#34; + str(int(time.time())) + &amp;#34;.txt&amp;#34;
save_path = os.path.join(so_path, script_name)
with open(save_path, &amp;#34;w&amp;#34;, encoding=&amp;#34;utf-8&amp;#34;) as F:
F.write(functionlist)
F.close()
print(f&amp;#34;location: {save_path}&amp;#34;)
def term(self):
pass
def PLUGIN_ENTRY():
return getFunctions()
&lt;/code>&lt;/pre>&lt;p>关于问题 2：使用 Frida Native Hook&lt;/p>
&lt;p>关于问题 3：Frida 的 frida-trace 自带调用层级关系，所以 trace_Natives 脚本依赖 Frida-trace，展示出了树结构的调用图。分析源码发现，frida-trace 使用了 Frida 在 Interceptor.attach 环境中的 depth 如下代码中的 this.depth），depth 表示了调用深度。那深度的值哪来的呢？其最终依赖于 Frida 的栈回溯。&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(Module.getExportByName(null, &amp;#39;read&amp;#39;), {
onEnter(args) {
console.log(&amp;#39;Context information:&amp;#39;);
console.log(&amp;#39;Context : &amp;#39; + JSON.stringify(this.context));
console.log(&amp;#39;Return : &amp;#39; + this.returnAddress);
console.log(&amp;#39;ThreadId : &amp;#39; + this.threadId);
console.log(&amp;#39;Depth : &amp;#39; + this.depth);
console.log(&amp;#39;Errornr : &amp;#39; + this.err);
this.fd = args[0].toInt32();
this.buf = args[1];
this.count = args[2].toInt32();
},
onLeave(result) {
console.log(&amp;#39;----------&amp;#39;)
const numBytes = result.toInt32();
if (numBytes &amp;gt; 0) {
console.log(hexdump(this.buf, { length: numBytes, ansi: true }));
}
console.log(&amp;#39;Result : &amp;#39; + numBytes);
}
})
&lt;/code>&lt;/pre>&lt;p>这三个问题能在 Unidbg 中解决吗？如果能解决，那就有了 Unidbg 版的 Function Tracing。&lt;/p>
&lt;p>首先问题一，只是一个获取函数列表的插件，与使用 Frida 还是 Unidbg 无关，构不成问题。我们还可以更进一步思考，trace_Natives 依赖 IDA 实现对 SO 函数的识别，但与此同时也增加了使用的复杂度，而且加壳的 SO 无法直接识别函数，必须得先 dump+fix SO，其实还挺折腾人，不如不依赖 IDA，换个办法识别函数。ARM 中，函数序言常常以 push 指令开始，这可以代表绝大多数函数。配合 Unidbg 的 BlockHook 或者 CodeHook，就可以解析并 Hook 这些函数，问题二也顺带解决了。少部分函数会遗漏，但也无关痛痒。BlockHook 还会提供当前基本块的大小，我们设置对较小的块不予理睬。&lt;/p>
&lt;p>接下来就是问题三，栈回溯这块，Unidbg 也实现了 arm unwind 栈回溯，一些情况下有 Bug，但总体应该能用。但 Unidbg 没有提供打印深度的函数，在 Unwinder 类中添加一个它。&lt;/p>
&lt;p>&lt;em>src/main/java/com/github/unidbg/unwind/Unwinder.java&lt;/em>&lt;/p>
&lt;pre tabindex="0">&lt;code>public final int depth(){
int count = 0;
Frame frame = null;
while((frame = unw_step(emulator, frame)) != null) {
if(frame.isFinish()){
return count;
}
count++;
}
return count;
}
&lt;/code>&lt;/pre>&lt;p>接下来三步骤合一，组装代码&lt;/p>
&lt;pre tabindex="0">&lt;code>PrintStream traceStream = null;
try {
String traceFile = &amp;#34;unidbg-android/src/test/resources/app/traceFunctions.txt&amp;#34;;
traceStream = new PrintStream(new FileOutputStream(traceFile), true);
} catch (FileNotFoundException e) {
e.printStackTrace();
}
final PrintStream finalTraceStream = traceStream;
emulator.getBackend().hook_add_new(new BlockHook() {
@Override
public void hookBlock(Backend backend, long address, int size, Object user) {
if(size&amp;gt;8){
Capstone.CsInsn[] insns = emulator.disassemble(address, 4, 0);
if(insns[0].mnemonic.equals(&amp;#34;push&amp;#34;)){
int level = emulator.getUnwinder().depth();
assert finalTraceStream != null;
for(int i = 0 ; i &amp;lt; level ; i++){
finalTraceStream.print(&amp;#34; | &amp;#34;);
}
finalTraceStream.println(&amp;#34; &amp;#34;+&amp;#34;sub_&amp;#34;+Integer.toHexString((int) (address-module.base))+&amp;#34; &amp;#34;);
}
}
}
@Override
public void onAttach(Unicorn.UnHook unHook) {
}
@Override
public void detach() {
}
}, module.base, module.base+module.size, 0);
&lt;/code>&lt;/pre>&lt;p>可以发现代码非常的简洁优雅，效果也不错&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/15.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/15.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h3 id="3unidbg-findkey">3.Unidbg-FindKey&lt;/h3>
&lt;p>&lt;a href="https://github.com/Pr0214/Unidbg_FindKey" target="_blank" rel="noopener">Unidbg_FindKey&lt;/a>&lt;/p>
&lt;p>// TODO 原理和扩充&lt;/p>
&lt;h3 id="4unidbg-findcrypt">4.Unidbg-Findcrypt&lt;/h3>
&lt;p>Findcrypt 是老牌经典工具，Unidbg 版的 Findcrypt 是要做啥？解决什么痛点？有三个主要原因&lt;/p>
&lt;ul>
&lt;li>Findcrypt 处理不了加壳 SO&lt;/li>
&lt;li>Findcrypt 中说存在某种加密，但 SO 中并不一定用，我们的目标函数更不一定用。&lt;/li>
&lt;li>从 Findcrypt 提示的常数不一定能找到对应函数，静态交叉分析有局限&lt;/li>
&lt;/ul>
&lt;p>// TODO&lt;/p>
&lt;h2 id="十二固定随机数">十二、固定随机数&lt;/h2>
&lt;p>// TODO&lt;/p>
&lt;h2 id="十三杂项">十三、杂项&lt;/h2>
&lt;p>无需 Hook，Unidbg 中通过其他方式实现&lt;/p>
&lt;p>// TODO&lt;/p></description></item><item><title>2022 某安卓 Crackme 流程分析</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-%E6%9F%90%E5%AE%89%E5%8D%93-crackme-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-%E6%9F%90%E5%AE%89%E5%8D%93-crackme-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzIxNjMwMzkwOA==&amp;amp;mid=2247485239&amp;amp;idx=1&amp;amp;sn=be7cb8e18cad26ba242a44d5de496bde&amp;amp;chksm=978a577ca0fdde6a274bc79a4eb6d386fddf48c0085b084e715020ed4e8d414b5dcced3d1f97&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0216MEd0pVJ6ywEAa986ZKU5&amp;amp;sharer_sharetime=1644973105735&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>安卓题目指路：https://www.52pojie.cn/thread-1582582-1-1.html&lt;/p>
&lt;p>jadx 打开 apk&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaOPzToMvcJRyrkHtOIsXuYgXmZTZWAgNdlaiahy1x8wXer6wADfL6AKA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>锁定函数&lt;/p>
&lt;pre tabindex="0">&lt;code>public native boolean checkSn(String str);
&lt;/code>&lt;/pre>&lt;p>根据输入的值来校验返回值，当输入正确的 flag 时返回 true&lt;/p>
&lt;p>打开 lib52pojie.so，JniOnload 动态加载 checkSn&lt;/p>
&lt;p>unidbg 代码获取下函数地址&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.pojie52;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.TraceHook;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.listener.TraceWriteListener;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.trace.KingTrace;
import java.io.*;
public class uniStart extends AbstractJni implements IOResolver {
private AndroidEmulator emulator;
private VM vm;
private Module module;
private Boolean logging = true;
private String processName = &amp;#34;com.wuaipojie.crackme2022&amp;#34;;
private DvmClass mainActivity;
private Debugger debugger;
public uniStart(boolean logging) throws IOException {
this.logging = logging;
emulator = AndroidEmulatorBuilder.for64Bit().setProcessName(processName).build();
final Memory memory = emulator.getMemory();
memory.setLibraryResolver(new AndroidResolver(23));
emulator.getSyscallHandler().addIOResolver(this);
vm = emulator.createDalvikVM(new File(&amp;#34;unidbg-android/src/main/resources/android/apk/524.apk&amp;#34;));
DalvikModule dm = vm.loadLibrary(&amp;#34;52pojie&amp;#34;, true);
vm.setVerbose(logging);
vm.setJni(this);
dm.callJNI_OnLoad(emulator);
module = dm.getModule();
mainActivity = vm.resolveClass(&amp;#34;com/wuaipojie/crackme2022/MainActivity&amp;#34;);
debugger = emulator.attach();
}
public static void main(String[] args) throws IOException {
uniStart uniStart = new uniStart(true);
}
@Override
public FileResult resolve(Emulator emulator, String pathname, int oflags) {
System.out.println(&amp;#34;pathname: &amp;#34; + pathname);
return null;
}
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiayziaD8HLnnOBsAqQq6A4BdiaJdF1kSe1F4ic9Q7QpP7fXWefsXqbP6nqg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>拿到函数地址：0x6f74&lt;/p>
&lt;p>lib52pojie.so 静态分析该地址处的函数，开发过程使用了内联汇编，静态基本上得不到什么有效信息&lt;/p>
&lt;p>直接使用 unidbg 来 trace 分析&lt;/p>
&lt;p>KingTrace 指路：https://github.com/dqzg12300/unidbg_tools/tree/main/unidbg-api/src/main/java/trace&lt;/p>
&lt;pre tabindex="0">&lt;code>public class uniStart extends AbstractJni implements IOResolver {
private AndroidEmulator emulator;
private VM vm;
private Module module;
private Boolean logging = true;
private String processName = &amp;#34;com.wuaipojie.crackme2022&amp;#34;;
private DvmClass mainActivity;
private Debugger debugger;
public uniStart(boolean logging) throws IOException {
this.logging = logging;
emulator = AndroidEmulatorBuilder.for64Bit().setProcessName(processName).build();
final Memory memory = emulator.getMemory();
memory.setLibraryResolver(new AndroidResolver(23));
emulator.getSyscallHandler().addIOResolver(this);
vm = emulator.createDalvikVM(new File(&amp;#34;unidbg-android/src/main/resources/android/apk/524.apk&amp;#34;));
DalvikModule dm = vm.loadLibrary(&amp;#34;52pojie&amp;#34;, true);
vm.setVerbose(logging);
vm.setJni(this);
dm.callJNI_OnLoad(emulator);
module = dm.getModule();
String StringFile = &amp;#34;unidbg-android/src/main/java/com/pojie52/trace1.txt&amp;#34;;
KingTrace.traceCode(emulator, module, StringFile);
mainActivity = vm.resolveClass(&amp;#34;com/wuaipojie/crackme2022/MainActivity&amp;#34;);
debugger = emulator.attach();
}
public static void main(String[] args) throws IOException {
uniStart uniStart = new uniStart(true);
uniStart.checkSn();
}
public void checkSn() {
boolean success = mainActivity.callStaticJniMethodBoolean(emulator, &amp;#34;checkSn(Ljava/lang/String;)Z&amp;#34;,
new StringObject(vm, &amp;#34;adair&amp;#34;));
System.out.println(&amp;#34;success: &amp;#34; + success);
}
@Override
public FileResult resolve(Emulator emulator, String pathname, int oflags) {
System.out.println(&amp;#34;pathname: &amp;#34; + pathname);
return null;
}
}
&lt;/code>&lt;/pre>&lt;p>最终只有 75 行，猜测入参长度问题导致在入口处就直接返回了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaWGxayu8oexgSKu2qNVKtc8icjB2VErpfUy8GQV90RJyZiceeA3KwXxicg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在 trace.log 中搜索 cmp 指令&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x06fd8] [ 1f 40 00 71 ] 0x40006fd8: cmp w0, #0x10 &amp;gt;&amp;gt;&amp;gt; w0=0x5//w0=0x5
&lt;/code>&lt;/pre>&lt;p>判断长度是否为 0x10，由此判断输入字符串长度应为 16 字节才会继续往下执行（从 java 代码中也可获取该信息），修改入参为：&lt;code>52pojieairadaira&lt;/code>&lt;/p>
&lt;p>重新 trace&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaMMs7ncO5nnO2uYZs0qmblXY5icwZG5jCwvPzUMsm3iaeJWszRS21JXMQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>39000 + 行，trace 应该是正常了，当然这个入参函数返回的结果肯定是 false，根据题目要求，传入参数，经过计算得到值，那么这个值一定会与内存中某个值做异同判断，再根据判断的结果返回到 java 中的 boolean 中，那么就还是从 trace 日志中的 cmp 指令下手，全局搜索 cmp 关键字从后往前找，&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x07848] [ 1f 00 00 71 ] 0x40007848: cmp w0, #0 &amp;gt;&amp;gt;&amp;gt; w0=0xffffffa2//w0=0xffffffa2
[lib52pojie.so] [0x0785c] [ ea 17 9f 1a ] 0x4000785c: cset w10, eq &amp;gt;&amp;gt;&amp;gt; w10=0xd87d7949//w10=0x0
[lib52pojie.so] [0x078e4] [ 40 01 00 12 ] 0x400078e4: and w0, w10, #1 &amp;gt;&amp;gt;&amp;gt; w0=0xffffffa2w10=0x0//w0=0x0
[lib52pojie.so] [0x07904] [ c0 03 5f d6 ] 0x40007904: ret
&lt;/code>&lt;/pre>&lt;p>贴近 trace 尾部的位置，在一个函数中 cmp 之后 ret 了 0x0 出去，那么大概率这个地方是最终判断两值是否相等的位置，其中 cset 指令的意思时通过判断上一条 cmp 指令的结果对结果寄存器赋值，在该例中为&lt;/p>
&lt;pre tabindex="0">&lt;code>cmp w0, #0 &amp;gt;&amp;gt;&amp;gt; w0 != 0x0 -&amp;gt; Z标志位变成0
cset w10, eq &amp;gt;&amp;gt;&amp;gt; w10 = 0x0 # 如果上面cmp之后之后Z标志位的值为1，则此处w10 = 0x1
&lt;/code>&lt;/pre>&lt;p>理解了 cset 的原理，再通过 unidbg 的 patchCode 功能来验证一下&lt;/p>
&lt;pre tabindex="0">&lt;code>public static void main(String[] args) throws IOException {
uniStart uniStart = new uniStart(true);
uniStart.debugger1();
uniStart.checkSn();
}
public void debugger1() {
// byte[] patchCode = {(byte) 0xea, 0x07, (byte) 0x9f, (byte) 0x1a}; // EA079F1A -&amp;gt; cset w10, ne 0x785c
byte[] patchCode = {(byte) 0x1f, (byte) 0x00, (byte) 0x00, (byte) 0x6B}; // 1F00006B -&amp;gt; cmp w0, w0
// cmp w0, w0结果恒为true
emulator.getBackend().mem_write(module.base + 0x7848, patchCode);
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiadOic5FdjmicxZMpkzTOkNP5PzydIn4hKStufyMubKan6iaLJjJOFT7KbQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最终结果返回 true，那么此处位置则可以暂时认为是最终判断的位置，记录此处地址：0x7848&lt;/p>
&lt;p>以该地址为起始点，往上查找 w0 或者 x0 第一次出现的位置&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x0798c] [ e0 03 15 aa ] 0x4000798c: mov x0, x21 &amp;gt;&amp;gt;&amp;gt; x0=0x40398058x21=0x40398058//x0=0x40398058
&lt;/code>&lt;/pre>&lt;p>通过 unidbg 的 debugger 功能断点调试，查看 x0 和 x1 地址处的内存值&lt;/p>
&lt;pre tabindex="0">&lt;code>private Debugger debugger;
public uniStart(boolean logging) throws IOException {
debugger = emulator.attach();
}
public static void main(String[] args) throws IOException {
uniStart uniStart = new uniStart(true);
uniStart.debugger1();
uniStart.checkSn();
}
public void debugger1() {
debugger.addBreakPoint(module.base + 0x798c);
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaxz5WmMOcncGEBiabLGmeGAxNdJ5ibPfVickvUK0ibqmQfUbcW0sS78UwYQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>得到两个 32 字节长度的 hex，初步判断这里可能就是最终需要做判断的两个值，通过修改入参发现，x0 在内存中的值动态变化，x1 在内存中的值是固定不变的，记录下这个地方的值&lt;/p>
&lt;pre tabindex="0">&lt;code>maybe encrypt result: 56ec3d4c526764d7949fe1f201d9fe45ce3601c8d282129884d8bf985034450e
maybe check result: 6e6649305baf80c49b1b063c0500c80346ccfd42b3063ae7312b52a21cd334d8
&lt;/code>&lt;/pre>&lt;p>根据 x1 地址 0x40398018 逆推，找到给这个地址赋值的地方&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x07208] [ 68 01 00 f0 ] 0x40007208: adrp x8, #0x40036000 &amp;gt;&amp;gt;&amp;gt; x8=0x0//x8=0x40036000
[lib52pojie.so] [0x0720c] [ 08 11 42 f9 ] 0x4000720c: ldr x8, [x8, #0x420] &amp;gt;&amp;gt;&amp;gt; x8=0x40036000x8=0x40036000//x8=0xffffffffc5c93154
[lib52pojie.so] [0x07210] [ 89 13 87 52 ] 0x40007210: movz w9, #0x389c &amp;gt;&amp;gt;&amp;gt; w9=0x0//w9=0x389c
[lib52pojie.so] [0x07214] [ 49 47 af 72 ] 0x40007214: movk w9, #0x7a3a, lsl #16 &amp;gt;&amp;gt;&amp;gt; w9=0x389c//w9=0x7a3a389c
[lib52pojie.so] [0x07218] [ 01 01 09 8b ] 0x40007218: add x1, x8, x9 &amp;gt;&amp;gt;&amp;gt; x1=0x40036a70x8=0xffffffffc5c93154x9=0x7a3a389c//x1=0x400369f0
[lib52pojie.so] [0x07598] [ f3 03 01 aa ] 0x40007598: mov x19, x1 &amp;gt;&amp;gt;&amp;gt; x19=0x3796751bx1=0x400369f0//x19=0x400369f0
[lib52pojie.so] [0x07698] [ e0 03 13 aa ] 0x40007698: mov x0, x19 &amp;gt;&amp;gt;&amp;gt; x0=0x20x19=0x400369f0//x0=0x400369f0
[lib52pojie.so] [0x0c864] [ 00 00 40 f9 ] 0x4000c864: ldr x0, [x0] &amp;gt;&amp;gt;&amp;gt; x0=0x400369f0x0=0x400369f0//x0=0x40398018
[lib52pojie.so] [0x077dc] [ f6 03 00 aa ] 0x400077dc: mov x22, x0 &amp;gt;&amp;gt;&amp;gt; x22=0x4000c884x0=0x40398018//x22=0x40398018
[lib52pojie.so] [0x077fc] [ e1 03 16 aa ] 0x400077fc: mov x1, x22 &amp;gt;&amp;gt;&amp;gt; x1=0x400369f0x22=0x40398018//x1=0x40398018
[lib52pojie.so] [0x07990] [ e1 03 14 aa ] 0x40007990: mov x1, x20 &amp;gt;&amp;gt;&amp;gt; x1=0x40398018x20=0x40398018//x1=0x40398018
&lt;/code>&lt;/pre>&lt;p>从上往下看，先是 x8 处指向固定地址 0x40036000，接着从该地址 + 0x420 的地址处取出数据赋值给 x8&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWialqHq60zutKOpjica4Dkr6Ps7kKO6iaTZorYaT568NWU8kLJZPxGWBbXw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>固定 w9 取值为 0x7a3a389c，与 x8 相加得到 0x400369f0 地址，在此处获取该地址的内存值如下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiamSpyxu3o7E5tk0oQOwqrNmPtuGkujgI7W44jibaibscj0sMTLWdvkQSg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可得上述 x1 的值是固定写死在内存中的，这个结论极大地加深了该值作为 check result 的可能性，此时记录该内存值&lt;/p>
&lt;p>回过头，我们再看下 encrypt result 的 set 过程&lt;/p>
&lt;p>一步步根据汇编回推太慢，使用 unidbg 的 memory trace write 功能定位关键写入位置&lt;/p>
&lt;pre tabindex="0">&lt;code>public void debugger1() {
emulator.traceWrite(0x40398058, 0x40398058+32);
emulator.traceWrite(0x40398058, 0x40398058+32, new TraceWriteListener() {
@Override
public boolean onWrite(Emulator&amp;lt;?&amp;gt; emulator, long address, int size, long value) {
emulator.getUnwinder().unwind();
return false;
}
});
debugger.addBreakPoint(module.base + 0xcc1c);
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaoHfvw2CtHrOX4jGxmmK7iahLe58DxPcsk3IXuQ5VYc1OzN5mNlU1lVw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>debugger 调试 0xcc1c 地址&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiatgH73aDaiazxAjDbFCvl6xibia860t2A3MGWsE0hQJSpicdKp32JJCd1lw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>此时 0x40398058 地址处还未写入值，可能的 encrypt result 和入参明文都在 x1 寄存器处，trace.log 中向上查找 0xbffff480 的写入位置&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiakKz6YDO2lLHzIs9PpXZ8JEcV3ysB2cibav5q14tSc8D4yz73yH3kVnw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一共 166 条结果，往上翻找&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWia7K3nW4WUBQtUASFKO3c9ibRtLNZ6gx4f60UBXgpnibQL6FDX6Lmzmcbg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>24000 行左右在大量的往 0xbffff480 地址处存储数据，跳至目标处&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaIJvHGibT0SI9yjvicnGqtbAd2d8fhHFAZyXiaXA6SQ5QO5PDp8a2KAC4w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>分别向 0xbffff480 的 0x0~0xf 偏移处写入 16 个字节的数据，将写入数据的最低位 hex 取出&lt;/p>
&lt;pre tabindex="0">&lt;code>strb w9, [x14] &amp;gt;&amp;gt;&amp;gt; w9=0xa511f056x14=0xbffff480//w9=0xa511f056 0x56
strb w9, [x14, #1] &amp;gt;&amp;gt;&amp;gt; w9=0xf0563decx14=0xbffff480//w9=0xf0563dec 0xec
strb w8, [x14, #2] &amp;gt;&amp;gt;&amp;gt; w8=0x11f0563dx14=0xbffff480//w8=0x11f0563d 0x3d
strb w8, [x14, #3] &amp;gt;&amp;gt;&amp;gt; w8=0x563dec4cx14=0xbffff480//w8=0x563dec4c 0x4c
strb w9, [x14, #4] &amp;gt;&amp;gt;&amp;gt; w9=0xd5906852x14=0xbffff480//w9=0xd5906852 0x52
strb w12, [x14, #5] &amp;gt;&amp;gt;&amp;gt; w12=0x68526467x14=0xbffff480//w12=0x68526467 0x67
strb w11, [x14, #6] &amp;gt;&amp;gt;&amp;gt; w11=0x90685264x14=0xbffff480//w11=0x90685264 0x64
strb w8, [x14, #7] &amp;gt;&amp;gt;&amp;gt; w8=0x526467d7x14=0xbffff480//w8=0x526467d7 0xd7
strb w13, [x14, #8] &amp;gt;&amp;gt;&amp;gt; w13=0x38cf0994x14=0xbffff480//w13=0x38cf0994 0x94
strb w8, [x14, #9] &amp;gt;&amp;gt;&amp;gt; w8=0x994e19fx14=0xbffff480//w8=0x994e19f 0x9f
strb w9, [x14, #0xa] &amp;gt;&amp;gt;&amp;gt; w9=0xcf0994e1x14=0xbffff480//w9=0xcf0994e1 0xe1
strb w9, [x14, #0xb] &amp;gt;&amp;gt;&amp;gt; w9=0x94e19ff2x14=0xbffff480//w9=0x94e19ff2 0xf2
strb w9, [x14, #0xc] &amp;gt;&amp;gt;&amp;gt; w9=0xde2ab601x14=0xbffff480//w9=0xde2ab601 0x01
strb w9, [x14, #0xd] &amp;gt;&amp;gt;&amp;gt; w9=0xb601fed9x14=0xbffff480//w9=0xb601fed9 0xd9
strb w8, [x14, #0xe] &amp;gt;&amp;gt;&amp;gt; w8=0x2ab601fex14=0xbffff480//w8=0x2ab601fe 0xfe
strb w8, [x14, #0xf] &amp;gt;&amp;gt;&amp;gt; w8=0x1fed945x14=0xbffff480//w8=0x1fed945 0x45
&lt;/code>&lt;/pre>&lt;p>是不是和 encrypt_result 的前 16 个字节 56ec3d4c526764d7949fe1f201d9fe45 匹配上了呢&lt;/p>
&lt;p>找到位置之后，再向上回溯明文到这一步的整个传输过程，以 0x0 处的 0xa511f056 为例&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x090f4] [ e8 8d 40 f9 ] 0x400090f4: ldr x8, [x15, #0x118] &amp;gt;&amp;gt;&amp;gt; x8=0x0x15=0xbffff0e0//x8=0xa511f0563dec4c
[lib52pojie.so] [0x090fc] [ 09 fd 58 d3 ] 0x400090fc: lsr x9, x8, #0x18 &amp;gt;&amp;gt;&amp;gt; x9=0x0x8=0xa511f0563dec4c//x9=0xa511f056
[lib52pojie.so] [0x09100] [ c9 01 00 39 ] 0x40009100: strb w9, [x14] &amp;gt;&amp;gt;&amp;gt; w9=0xa511f056x14=0xbffff480//w9=0xa511f056
&lt;/code>&lt;/pre>&lt;p>全局搜索 0xa511f0563dec4c&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaJfgbqr0ibrabnJibOcd7gf1E6TfB9nIfTiaS3hbmjSAicmdW851IL7D0oQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>0x8ff4 地址处 x8+0x20=0xbffff1d8+0x20=0xbffff1f8&lt;/p>
&lt;p>0x90f4 地址处 x15+0x118=0xbffffe0e+0x118=0xbffff1f8&lt;/p>
&lt;p>因此 0x8ff4 为 0xa511f0563dec4c 数据写入的位置&lt;/p>
&lt;p>再从 0x8ff4 往上回溯就能够找到下方关键位置，对应地址 0xacc4&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x0acc4] [ 00 00 13 ca ] 0x4000acc4: eor x0, x0, x19 &amp;gt;&amp;gt;&amp;gt; x0=0xf17a354ab377b6x0=0xf17a354ab377b6x19=0x546bc51c8e9bfa//x0=0xa511f0563dec4c
&lt;/code>&lt;/pre>&lt;p>全局搜索该地址发现有 64 处引用，且在第 32-33 之间跨度比较大，因此判断 encrypt_result 的前 16 个字节是由前 32 处引用生成，后 16 字节由后 32 处引用生成&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiazIwG3DATcLs4ZATthMSIXb8mwTZze0cwvwhicNWgFlWjFrgroBiaF36g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>从第一处引用位置往回推&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaFEIw9wRVrnTEXMGTCvrJWjeg3CsUtzvBu5jwr9AEUIvY4h1LcIicqpw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>第一轮运算 ret 之后想 x30 返回地址为 0x8fec，因此可以判断跳转指令 b 的地址为 0x8fec-0x4=0x8fe8，向上查找 0x8fe8 地址&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWianVnkCuqictTdKaPiawzvwpbXXz8rFSfKenp0AsJqL3pmlU6T5cygTMdA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>因此每轮运算即为 0x8fe8~0x8fec 之间的大概 300 多行指令，上图中框出来的则为首轮运算的参数，通过对地址 0x8fd4 全局搜索，查看前 32 轮运算的所有入参&lt;/p>
&lt;p>第一次：&lt;/p>
&lt;pre tabindex="0">&lt;code># 入参
[lib52pojie.so] [0x08fd4] [ e1 03 15 aa ] 0x40008fd4: mov x1, x21 &amp;gt;&amp;gt;&amp;gt; x1=0x8d71d734x21=0x37561947//x1=0x37561947
[lib52pojie.so] [0x08fd8] [ e2 03 16 aa ] 0x40008fd8: mov x2, x22 &amp;gt;&amp;gt;&amp;gt; x2=0x48x22=0x20155a74//x2=0x20155a74
[lib52pojie.so] [0x08fdc] [ e3 03 17 aa ] 0x40008fdc: mov x3, x23 &amp;gt;&amp;gt;&amp;gt; x3=0x10x23=0x99813f01//x3=0x99813f01
[lib52pojie.so] [0x08fe0] [ e4 03 18 aa ] 0x40008fe0: mov x4, x24 &amp;gt;&amp;gt;&amp;gt; x4=0x40x24=0x81b236f5//x4=0x81b236f5
[lib52pojie.so] [0x08fe4] [ e5 03 19 aa ] 0x40008fe4: mov x5, x25 &amp;gt;&amp;gt;&amp;gt; x5=0x20x25=0x3c3b90e65e1f82//x5=0x3c3b90e65e1f82
# 返回值
[lib52pojie.so] [0x0acc4] [ 00 00 13 ca ] 0x4000acc4: eor x0, x0, x19 &amp;gt;&amp;gt;&amp;gt; x0=0xb69f0624f6464bx0=0xb69f0624f6464bx19=0x37561947//x0=0xb69f0613a05f0c
&lt;/code>&lt;/pre>&lt;p>第二次：&lt;/p>
&lt;pre tabindex="0">&lt;code># 入参
[lib52pojie.so] [0x08fd4] [ e1 03 15 aa ] 0x40008fd4: mov x1, x21 &amp;gt;&amp;gt;&amp;gt; x1=0x8d71d734x21=0x20155a74//x1=0x20155a74
[lib52pojie.so] [0x08fd8] [ e2 03 16 aa ] 0x40008fd8: mov x2, x22 &amp;gt;&amp;gt;&amp;gt; x2=0x48x22=0x99813f01//x2=0x99813f01
[lib52pojie.so] [0x08fdc] [ e3 03 17 aa ] 0x40008fdc: mov x3, x23 &amp;gt;&amp;gt;&amp;gt; x3=0x10x23=0x81b236f5//x3=0x81b236f5
[lib52pojie.so] [0x08fe0] [ e4 03 18 aa ] 0x40008fe0: mov x4, x24 &amp;gt;&amp;gt;&amp;gt; x4=0x40x24=0xb69f0613a05f0c//x4=0xb69f0613a05f0c
[lib52pojie.so] [0x08fe4] [ e5 03 19 aa ] 0x40008fe4: mov x5, x25 &amp;gt;&amp;gt;&amp;gt; x5=0x20x25=0x72c025ec20d5a2//x5=0x72c025ec20d5a2
# 返回值
[lib52pojie.so] [0x0acc4] [ 00 00 13 ca ] 0x4000acc4: eor x0, x0, x19 &amp;gt;&amp;gt;&amp;gt; x0=0x7fbd3dd7591b0ex0=0x7fbd3dd7591b0ex19=0x20155a74//x0=0x7fbd3df74c417a
&lt;/code>&lt;/pre>&lt;p>第三次：&lt;/p>
&lt;pre tabindex="0">&lt;code># 入参
[lib52pojie.so] [0x08fd4] [ e1 03 15 aa ] 0x40008fd4: mov x1, x21 &amp;gt;&amp;gt;&amp;gt; x1=0x8d71d734x21=0x99813f01//x1=0x99813f01
[lib52pojie.so] [0x08fd8] [ e2 03 16 aa ] 0x40008fd8: mov x2, x22 &amp;gt;&amp;gt;&amp;gt; x2=0x48x22=0x81b236f5//x2=0x81b236f5
[lib52pojie.so] [0x08fdc] [ e3 03 17 aa ] 0x40008fdc: mov x3, x23 &amp;gt;&amp;gt;&amp;gt; x3=0x10x23=0xb69f0613a05f0c//x3=0xb69f0613a05f0c
[lib52pojie.so] [0x08fe0] [ e4 03 18 aa ] 0x40008fe0: mov x4, x24 &amp;gt;&amp;gt;&amp;gt; x4=0x40x24=0x7fbd3df74c417a//x4=0x7fbd3df74c417a
[lib52pojie.so] [0x08fe4] [ e5 03 19 aa ] 0x40008fe4: mov x5, x25 &amp;gt;&amp;gt;&amp;gt; x5=0x20x25=0x4145992b8ee3ef//x5=0x4145992b8ee3ef
# 返回值
[lib52pojie.so] [0x0acc4] [ 00 00 13 ca ] 0x4000acc4: eor x0, x0, x19 &amp;gt;&amp;gt;&amp;gt; x0=0x4e37555f6d7650x0=0x4e37555f6d7650x19=0x99813f01//x0=0x4e3755c6ec4951
&lt;/code>&lt;/pre>&lt;p>至第 32 次计算结束后的值就可以得到最终结果 0xa511f0563dec4c 就可以作为上述最终赋值 56ec3d4c526764d7949fe1f201d9fe45 的起始数据&lt;/p>
&lt;pre tabindex="0">&lt;code># 返回值
[lib52pojie.so] [0x0acc4] [ 00 00 13 ca ] 0x4000acc4: eor x0, x0, x19 &amp;gt;&amp;gt;&amp;gt; x0=0xf17a354ab377b6x0=0xf17a354ab377b6x19=0x546bc51c8e9bfa//x0=0xa511f0563dec4c
&lt;/code>&lt;/pre>&lt;p>再根据上述列出的几次运算入参和返回过程，得出运算规则如下图所示，其中参数 5 为固定 32 长度数组，每轮运算取出数组中对应索引的值&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaK59Fia0Ruhj5NQoIghzV9zGc9djPEibkfMH6h2R12hcaWzHic3b4BFEYA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如此我们只需要知道第一轮传入的参数，就能拿到经过 32 轮运算之后的结果了&lt;/p>
&lt;p>第一轮入参如下&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x08fd4] [ e1 03 15 aa ] 0x40008fd4: mov x1, x21 &amp;gt;&amp;gt;&amp;gt; x1=0x8d71d734x21=0x37561947//x1=0x37561947
&lt;/code>&lt;/pre>&lt;p>全局搜索 0x37561947，找到关键位置&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x08de8] [ 31 9e 68 d3 ] 0x40008de8: lsl x17, x17, #0x18 &amp;gt;&amp;gt;&amp;gt; x17=0x37x17=0x37//x17=0x37000000
[lib52pojie.so] [0x08dec] [ ff 05 00 71 ] 0x40008dec: cmp w15, #1 &amp;gt;&amp;gt;&amp;gt; w15=0x1//w15=0x1
[lib52pojie.so] [0x08df0] [ 51 1e 78 b3 ] 0x40008df0: bfi x17, x18, #8, #8 &amp;gt;&amp;gt;&amp;gt; x17=0x37000000x18=0x19//x17=0x37001900
[lib52pojie.so] [0x08df4] [ 41 01 00 54 ] 0x40008df4: b.ne #0x40008e1c
[lib52pojie.so] [0x08df8] [ 80 9d 68 d3 ] 0x40008df8: lsl x0, x12, #0x18 &amp;gt;&amp;gt;&amp;gt; x0=0xbffff0e0x12=0x20//x0=0x20000000
[lib52pojie.so] [0x08dfc] [ 32 42 0a aa ] 0x40008dfc: orr x18, x17, x10, lsl #16 &amp;gt;&amp;gt;&amp;gt; x18=0x19x17=0x37001900x10=0x56//x18=0x37561900
[lib52pojie.so] [0x08e00] [ a0 1d 78 b3 ] 0x40008e00: bfi x0, x13, #8, #8 &amp;gt;&amp;gt;&amp;gt; x0=0x20000000x13=0x5a//x0=0x20005a00
[lib52pojie.so] [0x08e04] [ 52 02 0b aa ] 0x40008e04: orr x18, x18, x11 &amp;gt;&amp;gt;&amp;gt; x18=0x37561900x18=0x37561900x11=0x47//x18=0x37561947
&lt;/code>&lt;/pre>&lt;p>发现是由 0x37,0x56,0x19,0x47 通过移位操作，直接搜索这些 hex 会有很多响应结果，暂且不在往上回溯，到现在我们都没关心过真正的入参&lt;code>52pojieairadaira&lt;/code>，对应 hex &lt;code>35,32,70,6f,6a,69,65,61,69,72,61,64,61,69,72,61&lt;/code>&lt;/p>
&lt;p>全局搜索&lt;code>0x35&lt;/code>，搜索到的第一个响应结果如下&lt;/p>
&lt;pre tabindex="0">&lt;code>[lib52pojie.so] [0x09b34] [ 69 69 6a 38 ] 0x40009b34: ldrb w9, [x11, x10] &amp;gt;&amp;gt;&amp;gt; w9=0x0x11=0xbffff4a0x10=0x0//w9=0x35
[lib52pojie.so] [0x09b38] [ 8c 01 40 f9 ] 0x40009b38: ldr x12, [x12] &amp;gt;&amp;gt;&amp;gt; x12=0xbffff2d0x12=0xbffff2d0//x12=0xbffff480
[lib52pojie.so] [0x09b3c] [ 08 01 09 4a ] 0x40009b3c: eor w8, w8, w9 &amp;gt;&amp;gt;&amp;gt; w8=0x2w8=0x2w9=0x35//w8=0x37
&lt;/code>&lt;/pre>&lt;p>可以看到在 0x9b3c 地址处让 0x35 ^ 0x2 得到 0x37，全局搜索 0x9b3c 地址&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiadLQDA0eDTJ7t2NLia5fOrMkFiaK8B1xPHnrEwPgSl9yaP2wWDDJj42pg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>前 16 个结果的 w9 为入参&lt;code>52pojieairadaira&lt;/code>对应的 hex，指令执行结束 w8 对应的结果为【&amp;lsquo;0x37&amp;rsquo;, &amp;lsquo;0x19&amp;rsquo;, &amp;lsquo;0x56&amp;rsquo;, &amp;lsquo;0x47&amp;rsquo;, &amp;lsquo;0x20&amp;rsquo;, &amp;lsquo;0x5a&amp;rsquo;, &amp;lsquo;0x15&amp;rsquo;, &amp;lsquo;0x74&amp;rsquo;, &amp;lsquo;0x99&amp;rsquo;, &amp;lsquo;0x3f&amp;rsquo;, &amp;lsquo;0x81&amp;rsquo;, &amp;lsquo;0x1&amp;rsquo;, &amp;lsquo;0x81&amp;rsquo;, &amp;lsquo;0x36&amp;rsquo;, &amp;lsquo;0xb2&amp;rsquo;, &amp;lsquo;0xf5&amp;rsquo;】，与上述我们需求的第一轮运算入参的所有 16 个字节匹配&lt;/p>
&lt;p>再看匹配到的后 16 个结果中，w9 的 hex 组装为【0x0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10】，w8 的参数组装为 0x56,0xec,0x3d,0x4c,0x52,0x67,0x64,0xd7,0x94,0x9f,0xe1,0xf2,0x1,0xd9,0xfe,0x45，正好对应前 32 轮的计算结果 56ec3d4c526764d7949fe1f201d9fe45&lt;/p>
&lt;p>因此整个流程大概是&lt;/p>
&lt;p>① 入参 hex 异或 xor_key_table（【0x2, 0x2b, 0x26, 0x28, 0x4a, 0x33, 0x70, 0x15, 0xf0, 0x4d, 0xe0, 0x65, 0xe0, 0x5f, 0xc0, 0x94】），对应索引异或得到【0x37,0x19,0x56,0x47,0x20,0x5a,0x15,0x74,0x99,0x3f,0x81,0x01,0x81,0x36,0xb2,0xf5】&lt;/p>
&lt;pre tabindex="0">&lt;code># 52pojieairadaira
hex_param = [0x35, 0x32, 0x70, 0x6f, 0x6a, 0x69, 0x65, 0x61, 0x69, 0x72, 0x61, 0x64, 0x61, 0x69, 0x72, 0x61]
xor_key = [0x2, 0x2b, 0x26, 0x28, 0x4a, 0x33, 0x70, 0x15, 0xf0, 0x4d, 0xe0, 0x65, 0xe0, 0x5f, 0xc0, 0x94]
real_param = []
for i in range(len(hex_param)):
a = hex_param[i] ^ xor_key[i]
real_param.append(a)
&lt;/code>&lt;/pre>&lt;p>② 将上述异或之后得到的 hex 移位拼接成【0x37561947，0x20155a74，0x99813f01，0x81b236f5】&lt;/p>
&lt;pre tabindex="0">&lt;code>params = []
for i in range(0, len(real_param), 4):
param = (real_param[i] &amp;lt;&amp;lt; 24) + (real_param[i + 2] &amp;lt;&amp;lt; 16) + (real_param[i + 1] &amp;lt;&amp;lt; 8) + real_param[i + 3]
params.append(param)
&lt;/code>&lt;/pre>&lt;p>③ 经过 32 轮运算（汇编转 c/python，无捷径）&lt;/p>
&lt;pre tabindex="0">&lt;code>hex_list = [0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67,
0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4,
0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08,
0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba,
0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb,
0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b,
0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4,
0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1,
0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6,
0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45,
0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd,
0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd,
0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9,
0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e,
0xd7, 0xcb, 0x39, 0x48]
hex_params = [0x3c3b90e65e1f82, 0x72c025ec20d5a2, 0x4145992b8ee3ef, 0x69cff9c3113c5e, 0x73a0bdc7e35bb5,
0x6587f6717f5417,
0x33f15055cc7021, 0x54d89634fd983e, 0x7fb7780a7fadbb, 0x4f4f92ef4f948e, 0x5f72ac76224645,
0x64fedb2ae2d1ac,
0x5aa8969e2ac4bc, 0x680fea99ef2053, 0x6c1e634f07843e, 0x677673b06c935, 0x3d1b6be4557920, 0x1b04f5e1299f9c,
0x326a513916a44c, 0x1ff10831d1d12e, 0x72fb7bdb5a88e, 0x6c3867e930366f, 0x4f884102f7796b, 0x7005c6149330c,
0x284c586c9b290, 0x19ca128d08d882, 0x544b18a95a6bde, 0x6a14600a6179ed, 0x1d4be54074b82b, 0x7581763c59130d,
0x4bb3c753b8931b, 0x668bd94d4abaa7]
def bfi(dst, src, length, width):
ls = 0xFFFFFFFF &amp;gt;&amp;gt; (32 - width)
lsb = length
ls = ~((ls &amp;lt;&amp;lt; lsb) &amp;amp; 0xff)
if ls &amp;lt; -1:
# 针对特例
ls = -1
dst = dst &amp;amp; ls
dst = dst | (src &amp;amp; ls) &amp;lt;&amp;lt; lsb
return dst
all_encrypt_hex = []
def encrypt(*args):
kwargs = args[0]
x1 = kwargs[0] # 0x37561947
x2 = kwargs[1] # 0x20155a74
x3 = kwargs[2] # 0x99813f01
x4 = kwargs[3] # 0x81b236f5
x5 = kwargs[4] # 0x3c3b90e65e1f82 # 0x08fe4
x29 = [0] * 1024
xx19 = x1 # 0x0abd4
x9 = x3 ^ x2 # 0x0ac14
x9 = x9 ^ x4 # 0x0ac2c
x21 = x9 ^ x5 # 0x0ac30
x1 = x21 # 0x0ac90
x29[-0x60] = x1
x8 = x21
x21 = x8 &amp;gt;&amp;gt; 0x8 # 0x0ad80
x22 = x8 &amp;gt;&amp;gt; 0x10 # 0x0ad84
x9 = x8
x25 = x9 &amp;gt;&amp;gt; 0x18 # 0x0ad98
x1 = x25
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10] # 0xb4
x29[-0x68] = x0 # 0x0ab94
x1 = x21 &amp;amp; 0xffffffff # 0x0ade8
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10] # 0xe6
x29[-0x70] = x0
x1 = x22 &amp;amp; 0xffffffff
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10] # 0x4c
x27 = x0
x1 = x29[-0x60]
x10 = x1 &amp;amp; 0xff # 0x2
x0 = hex_list[x10]
x9 = x29[-0x70]
x12 = x29[-0x68]
x10 = x27 &amp;amp; 0xff # 0x0afb4
x8 = x12 &amp;amp; 0xff
x9 = x9 &amp;amp; 0xff
x8 = x8 &amp;lt;&amp;lt; 0x18
# bfi x8, x9, #8, #8
x8 = bfi(x8, x9, 0x8, 0x8)
x8 = bfi(x8, x10, 0x10, 0x8)
x9 = x8 &amp;gt;&amp;gt; 0xe
x10 = x8 &amp;gt;&amp;gt; 0x16
x11 = x8 &amp;gt;&amp;gt; 8
x8 = x8 + x0
x12 = x12 &amp;gt;&amp;gt; 6
# bfi x10, x8, #0xa, #0x20
x10 = bfi(x10, x8, 0xa, 0x20)
x12 = bfi(x12, x8, 0x2, 0x20)
x9 = bfi(x9, x8, 0x12, 0x20)
x11 = bfi(x11, x8, 0x18, 0x20) # 0x0afec
x8 = x10 ^ x8
x8 = x8 ^ x9
x8 = x8 ^ x11
x0 = x8 ^ x12
x0 = x0 ^ xx19 # 0x0acc4
# print(hex(x0))
all_encrypt_hex.append(x0)
result_params = [x2, x3, x4, x0]
return result_params
for i in range(32):
params.append(hex_params[i])
params = encrypt(params)
&lt;/code>&lt;/pre>&lt;p>④ 将运算结果取低位移位运算（0x9100）&lt;/p>
&lt;pre tabindex="0">&lt;code>encrypt_hex = [0] * 16
x8 = all_encrypt_hex[-1]
w8 = x8 &amp;amp; 0xffffffff
x9 = x8 &amp;gt;&amp;gt; 0x18
encrypt_hex[0] = x9 &amp;amp; 0xff
x9 = x8 &amp;gt;&amp;gt; 0x8
encrypt_hex[3] = w8 &amp;amp; 0xff
x8 = x8 &amp;gt;&amp;gt; 0x10
w8 = x8 &amp;amp; 0xffffffff
encrypt_hex[1] = x9 &amp;amp; 0xff
encrypt_hex[2] = w8 &amp;amp; 0xff
x8 = all_encrypt_hex[-2]
w9 = x8 &amp;gt;&amp;gt; 0x18
encrypt_hex[4] = w9 &amp;amp; 0xff
x9 = all_encrypt_hex[-3]
x11 = x8 &amp;gt;&amp;gt; 0x10
x12 = x8 &amp;gt;&amp;gt; 0x8
x13 = x9 &amp;gt;&amp;gt; 0x18
w8 = x8 &amp;amp; 0xffffffff
encrypt_hex[7] = w8 &amp;amp; 0xff
w12 = x12 &amp;amp; 0xffffffff
encrypt_hex[5] = w12 &amp;amp; 0xff
w11 = x11 &amp;amp; 0xffffffff
encrypt_hex[6] = w11 &amp;amp; 0xff
w13 = x13 &amp;amp; 0xffffffff
encrypt_hex[8] = w13 &amp;amp; 0xff
w9 = x9 &amp;amp; 0xffffffff
encrypt_hex[0xb] = w9 &amp;amp; 0xff
x8 = x9 &amp;gt;&amp;gt; 0x8
x9 = x9 &amp;gt;&amp;gt; 0x10
w8 = x8 &amp;amp; 0xfffffff
w9 = x9 &amp;amp; 0xfffffff
encrypt_hex[0x9] = w8 &amp;amp; 0xff
encrypt_hex[0xa] = w9 &amp;amp; 0xff
x8 = all_encrypt_hex[-4]
x9 = x8 &amp;gt;&amp;gt; 0x18
w9 = x9 &amp;amp; 0xffffffff
encrypt_hex[0xc] = w9 &amp;amp; 0xff
w8 = x8 &amp;amp; 0xffffffff
encrypt_hex[0xf] = w8 &amp;amp; 0xff
x9 = x8 &amp;gt;&amp;gt; 8
x8 = x8 &amp;gt;&amp;gt; 0x10
w9 = x9 &amp;amp; 0xffffffff
w8 = x8 &amp;amp; 0xffffffff
encrypt_hex[0xd] = w9 &amp;amp; 0xff
encrypt_hex[0xe] = w8 &amp;amp; 0xff
print(&amp;#34;,&amp;#34;.join([hex(i) for i in encrypt_hex]))
&lt;/code>&lt;/pre>&lt;p>以上前 32 轮运算结束，0xbffff480 处的前 16 个字节也已得到&lt;/p>
&lt;p>⑤ 将上述结果【0x56,0xec,0x3d,0x4c,0x52,0x67,0x64,0xd7,0x94,0x9f,0xe1,0xf2,0x1,0xd9,0xfe,0x45】作为新的异或 table 与【0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10】对应位置异或&lt;/p>
&lt;pre tabindex="0">&lt;code>hex_param_01 = [0x0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10]
xor_key_01 = [0x56, 0xec, 0x3d, 0x4c, 0x52, 0x67, 0x64, 0xd7, 0x94, 0x9f, 0xe1, 0xf2, 0x1, 0xd9, 0xfe, 0x45]
real_param_01 = []
for i in range(len(hex_param_01)):
a = hex_param_01[i] ^ xor_key_01[i]
real_param_01.append(a)
&lt;/code>&lt;/pre>&lt;p>重复上述 ②③④ 步，得到第 64 轮结束后的 16 字节为【0xce,0x36,0x1,0xc8,0xd2,0x82,0x12,0x98,0x84,0xd8,0xbf,0x98,0x50,0x34,0x45,0xe】，正好对应 0xbffff480 处的后 16 字节&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaGruPMP1ibRRaF5yfUULNSIcKYbiaJjmqqbUj2thZkmaV0CbZ4yo7rmWA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>至此，整个加密流程则已经完整分析结束，得到最终生成的结果：56ec3d4c526764d7949fe1f201d9fe45ce3601c8d282129884d8bf985034450e&lt;/p>
&lt;p>根据题目要求，我们需要传入明文让这个最终的结果等于：6e6649305baf80c49b1b063c0500c80346ccfd42b3063ae7312b52a21cd334d8，这样才能拿到正确的 flag 并最终让函数执行结果返回 true&lt;/p>
&lt;p>现在加密函数分析出来了，但是要怎么拿到对应的解密函数呢&lt;/p>
&lt;p>整理下上述过程，为了使结果为 6e6649305baf80c49b1b063c0500c80346ccfd42b3063ae7312b52a21cd334d8，我们手中已经掌握的数据有&lt;/p>
&lt;p>共 64 轮，以每 32 轮运算分为上下两部分&lt;/p>
&lt;pre tabindex="0">&lt;code># 上部分
传参明文：未知
计算传参：未知
异或keyTable（常量Table）：022b26284a337015f04de065e05fc094
最终结果：6e6649305baf80c49b1b063c0500c803
# 下部分
传参明文为：00101010101010101010101010101010
异或keyTable为（此为上部分最终计算的结果）：6e664930 5baf80c4 9b1b063c 0500c803
计算传参：0x6e597620, 0x4b90bfd4, 0x8b160b2c, 0x15d81013
最终计算结果：46ccfd42b3063ae7312b52a21cd334d8
&lt;/code>&lt;/pre>&lt;p>那么如果我们根据下部分计算过程成功逆推出来计算传参，是不是就能拿到下部分传参的明文了呢&lt;/p>
&lt;p>首先说明下如果通过计算过程的传参推出明文&lt;/p>
&lt;pre tabindex="0">&lt;code>0x6e ^ 0x6e = 0x00
0x59 ^ 0x49 = 0x10
0x76 ^ 0x66 = 0x10
0x20 ^ 0x30 = 0x10
0x5b ^ 0x4b = 0x10
0x90 ^ 0x80 = 0x10
0xbf ^ 0xaf = 0x10
0xd4 ^ 0xc4 = 0x10
...
0x15 ^ 0x05 = 0x10
0xd8 ^ 0xc8 = 0x10
0x10 ^ 0x00 = 0x10
0x13 ^ 0x03 = 0x10
&lt;/code>&lt;/pre>&lt;p>回过头我们再看下具体的 encrypt 函数逻辑&lt;/p>
&lt;pre tabindex="0">&lt;code>def encrypt(*args):
kwargs = args[0]
x1 = kwargs[0] # 未知
x2 = kwargs[1] # 0xe8c7201c34d3d8
x3 = kwargs[2] # 0x42da1431522ba2
x4 = kwargs[3] # 0xfb05dab33a06e7
x5 = kwargs[4] # 0x668bd94d4abaa7 -&amp;gt; 常量table最后一个元素
x29 = [0] * 1024
xx19 = x1
x9 = x3 ^ x2
x9 = x9 ^ x4
x21 = x9 ^ x5
x1 = x21
x29[-0x60] = x1
x8 = x21
x21 = x8 &amp;gt;&amp;gt; 0x8
x22 = x8 &amp;gt;&amp;gt; 0x10
x9 = x8
x25 = x9 &amp;gt;&amp;gt; 0x18
x1 = x25
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x29[-0x68] = x0
x1 = x21 &amp;amp; 0xffffffff
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x29[-0x70] = x0
x1 = x22 &amp;amp; 0xffffffff
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x27 = x0
x1 = x29[-0x60]
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x9 = x29[-0x70]
x12 = x29[-0x68]
x10 = x27 &amp;amp; 0xff
x8 = x12 &amp;amp; 0xff
x9 = x9 &amp;amp; 0xff
x8 = x8 &amp;lt;&amp;lt; 0x18
x8 = bfi(x8, x9, 0x8, 0x8)
x8 = bfi(x8, x10, 0x10, 0x8)
x9 = x8 &amp;gt;&amp;gt; 0xe
x10 = x8 &amp;gt;&amp;gt; 0x16
x11 = x8 &amp;gt;&amp;gt; 8
x8 = x8 + x0
x12 = x12 &amp;gt;&amp;gt; 6
x10 = bfi(x10, x8, 0xa, 0x20)
x12 = bfi(x12, x8, 0x2, 0x20)
x9 = bfi(x9, x8, 0x12, 0x20)
x11 = bfi(x11, x8, 0x18, 0x20)
x8 = x10 ^ x8
x8 = x8 ^ x9
x8 = x8 ^ x11
x0 = x8 ^ x12# x0 = 0x8A26C2E1034B06
x0 = x0 ^ xx19# x0 = x0 ^ xx19 = 0x9c426546fdcc42 -&amp;gt; xx19 = 0x8A26C2E1034B06 ^ 0x9c426546fdcc42 = 0x1664a7a7fe8744 -&amp;gt; x1 = 0x1664a7a7fe8744
print(hex(x0))
&lt;/code>&lt;/pre>&lt;p>最终我们是得到一个 x0 的值，即是每轮计算的结果，这个结果又会与 xx19 进行异或，而 xx19 是从 x1 赋值得来的，x1 即是我们传入的第一个参数，且在后续过程中并没有参与其他的运算，经过最后一步我们是能拿到最后一轮 x0 的值，现在想拿到最后一轮 xx19 的值，将 x2, x3, x4, x5 这四个值正常传入，在最后一步 x0 = x8 ^ x12 仍能拿到正确计算的的 x0 值，该值再与 xx19 进行异或即可得到传入的 x1 的值，以上述最后一轮入参和出参计算过程，代码注释为例，最终推出 x1 的值为 0x1664a7a7fe8744，正向加密过程输出可以看到&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaOYt1yfZmEenzrrdzLagmBfiabmpJVO0freX89sHLatnZOKyGs5IuibZQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>是能够匹配上最后一轮传入的第一个参数，另外根据图中还能得到的另一个信息就是下部分计算的后 16 字节结果是能够 encrypt 最后一轮拿到的（同上述第四步），如下规则&lt;/p>
&lt;pre tabindex="0">&lt;code>0xe8c7201c34d3d8 &amp;amp; 0xffffffff -&amp;gt; 0x1c34d3d8 -&amp;gt; 0x1c,0xd3,0x34,0xd8 -&amp;gt; 12-15字节
0x42da1431522ba2 &amp;amp; 0xffffffff -&amp;gt; 0x31522ba2 -&amp;gt; 0x31,0x2b,0x52,0xa2 -&amp;gt; 8-11字节
0xfb05dab33a06e7 &amp;amp; 0xffffffff -&amp;gt; 0xb33a06e7 -&amp;gt; 0xb3,0x06,0x3a,0xe7 -&amp;gt; 4-7字节
0x9c426546fdcc42 &amp;amp; 0xffffffff -&amp;gt; 0x46fdcc42 -&amp;gt; 0x46,0xcc,0xfd,0x42 -&amp;gt; 0-3字节
&lt;/code>&lt;/pre>&lt;p>另外我们考虑到另一个问题就是，后续所有计算的值都是高位，但是最终我们拿到的 x1 一定是低 8 位的值，因此后续计算都以低八位的数据来传入参数&lt;/p>
&lt;p>现在知道了 decrypt 的方法，那么据此方法再执行 32 轮不就能够推出上述加密过程下部分的计算传参了吗&lt;/p>
&lt;pre tabindex="0">&lt;code>def decrypt(*args):
kwargs = args[0]
x1 = kwargs[0]
x2 = kwargs[1]
x3 = kwargs[2]
x4 = kwargs[3]
x5 = kwargs[4]
x29 = [0] * 1024
xx19 = x1
x9 = x3 ^ x2
x9 = x9 ^ x4
x21 = x9 ^ x5
x1 = x21
x29[-0x60] = x1
x8 = x21
x21 = x8 &amp;gt;&amp;gt; 0x8
x22 = x8 &amp;gt;&amp;gt; 0x10
x9 = x8
x25 = x9 &amp;gt;&amp;gt; 0x18
x1 = x25
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x29[-0x68] = x0
x1 = x21 &amp;amp; 0xffffffff
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x29[-0x70] = x0
x1 = x22 &amp;amp; 0xffffffff
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x27 = x0
x1 = x29[-0x60]
x10 = x1 &amp;amp; 0xff
x0 = hex_list[x10]
x9 = x29[-0x70]
x12 = x29[-0x68]
x10 = x27 &amp;amp; 0xff
x8 = x12 &amp;amp; 0xff
x9 = x9 &amp;amp; 0xff
x8 = x8 &amp;lt;&amp;lt; 0x18
x8 = bfi(x8, x9, 0x8, 0x8)
x8 = bfi(x8, x10, 0x10, 0x8)
x9 = x8 &amp;gt;&amp;gt; 0xe
x10 = x8 &amp;gt;&amp;gt; 0x16
x11 = x8 &amp;gt;&amp;gt; 8
x8 = x8 + x0
x12 = x12 &amp;gt;&amp;gt; 6
x10 = bfi(x10, x8, 0xa, 0x20)
x12 = bfi(x12, x8, 0x2, 0x20)
x9 = bfi(x9, x8, 0x12, 0x20)
x11 = bfi(x11, x8, 0x18, 0x20)
x8 = x10 ^ x8
x8 = x8 ^ x9
x8 = x8 ^ x11
x0 = x8 ^ x12
x0 = x0 ^ xx19
return x0
# 46ccfd42
final_result = 0x46fdcc42
# b3063ae7
final_list1 = 0x1c34d3d8
# 312b52a2
final_list2 = 0x31522ba2
# 1cd334d8
final_list3 = 0xb33a06e7
result = [final_result, final_list1, final_list2, final_list3, hex_params[-1]]
x0 = decrypt(result)
result = [final_list3, x0, final_list1, final_list2, hex_params[-2]]
x1 = decrypt(result)
result = [final_list2, x1, x0, final_list1, hex_params[-3]]
x2 = decrypt(result)
result = [final_list1, x2, x1, x0, hex_params[-4]]
x3 = decrypt(result)
result = [x0, x3, x2, x1, hex_params[-5]]
x4 = decrypt(result)
result = [x1, x4, x3, x2, hex_params[-6]]
x5 = decrypt(result)
result = [x2, x5, x4, x3, hex_params[-7]]
x6 = decrypt(result)
result = [x3, x6, x5, x4, hex_params[-8]]
x7 = decrypt(result)
result = [x4, x7, x6, x5, hex_params[-9]]
x8 = decrypt(result)
result = [x5, x8, x7, x6, hex_params[-10]]
x9 = decrypt(result)
result = [x6, x9, x8, x7, hex_params[-11]]
x10 = decrypt(result)
result = [x7, x10, x9, x8, hex_params[-12]]
x11 = decrypt(result)
result = [x8, x11, x10, x9, hex_params[-13]]
x12 = decrypt(result)
result = [x9, x12, x11, x10, hex_params[-14]]
x13 = decrypt(result)
result = [x10, x13, x12, x11, hex_params[-15]]
x14 = decrypt(result)
result = [x11, x14, x13, x12, hex_params[-16]]
x15 = decrypt(result)
result = [x12, x15, x14, x13, hex_params[-17]]
x16 = decrypt(result)
result = [x13, x16, x15, x14, hex_params[-18]]
x17 = decrypt(result)
result = [x14, x17, x16, x15, hex_params[-19]]
x18 = decrypt(result)
result = [x15, x18, x17, x16, hex_params[-20]]
x19 = decrypt(result)
result = [x16, x19, x18, x17, hex_params[-21]]
x20 = decrypt(result)
result = [x17, x20, x19, x18, hex_params[-22]]
x21 = decrypt(result)
result = [x18, x21, x20, x19, hex_params[-23]]
x22 = decrypt(result)
result = [x19, x22, x21, x20, hex_params[-24]]
x23 = decrypt(result)
result = [x20, x23, x22, x21, hex_params[-25]]
x24 = decrypt(result)
result = [x21, x24, x23, x22, hex_params[-26]]
x25 = decrypt(result)
result = [x22, x25, x24, x23, hex_params[-27]]
x26 = decrypt(result)
result = [x23, x26, x25, x24, hex_params[-28]]
x27 = decrypt(result)
result = [x24, x27, x26, x25, hex_params[-29]]
x28 = decrypt(result)
result = [x25, x28, x27, x26, hex_params[-30]]
x29 = decrypt(result)
result = [x26, x29, x28, x27, hex_params[-31]]
x30 = decrypt(result)
result = [x27, x30, x29, x28, hex_params[-32]]
x31 = decrypt(result)
print(hex(x31), hex(x30), hex(x29), hex(x28))
&lt;/code>&lt;/pre>&lt;p>得出结果【0xe8c7206e597620， 0x42da144b90bfd4， 0xfb05da8b160b2c， 0x9c426515d81013】&lt;/p>
&lt;p>再分别取每个值的低 8 位：【0x6e597620， 0x4b90bfd4， 0x8b160b2c， 0x15d81013】&lt;/p>
&lt;p>是不是就与上面下部分计算最终想要拿到的计算传参一样了呢，整个 decrypt 流程就完整解析出来了&lt;/p>
&lt;p>把上述 decrypt 传参修改为【0x6e496630，0x05c80003，0x9b061b3c，0x5b80afc4】&lt;/p>
&lt;p>计算得到结果【0x4e12ab59517c7f， 0xc75c9e64420645， 0xa60707c0890756， 0x5457c9ce8e3cc9】&lt;/p>
&lt;p>分别取低八位：【0x59517c7f，0x64420645，0xc0890756，0xce8e3cc9】，此即为上部分计算的计算传参&lt;/p>
&lt;p>再由上部分的异或 keyTable【0x2, 0x2b, 0x26, 0x28, 0x4a, 0x33, 0x70, 0x15, 0xf0, 0x4d, 0xe0, 0x65, 0xe0, 0x5f, 0xc0, 0x94】&lt;/p>
&lt;p>最终拿到上部分计算传参明文及 flag&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;&amp;#34;&amp;#34;
0x59 ^ 0x2 = [
0x7c ^ 0x2b = W
0x51 ^ 0x26 = w
0x7f ^ 0x28 = W
59517c7f
0x64 ^ 0x4a = .
0x06 ^ 0x33 = 5
0x42 ^ 0x70 = 2
0x45 ^ 0x15 = P
64420645
0xc0 ^ 0xf0 = 0
0x07 ^ 0x4d = J
0x89 ^ 0xe0 = i
0x56 ^ 0x65 = 3
c0890756
0xce ^ 0xe0 = .
0x3c ^ 0x5f = c
0x8e ^ 0xc0 = N
0xc9 ^ 0x94 = ]
ce8e3cc9
flag: [WwW.52P0Ji3.cN]
&amp;#34;&amp;#34;&amp;#34;
&lt;/code>&lt;/pre>&lt;p>将 flag 放置 unidbg 种作为参数传入，返回为 true&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaVS68ztV6fcuWcF3xD4Eic7Y1OrgV1Jr70ia81KcoIre7pp1kcTiag9gKA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>写在最后，许久没更新文章了，本篇篇幅较多，连贯性可能不够，感兴趣的小伙伴可自行根据文章流程尝试获取 flag，后台回复 &amp;ldquo;查查&amp;rdquo; 获取资源包（本篇文章的 md 文档，观感较好，.py，.java 及 trace 文件等）。&lt;/p>
&lt;p>最后的最后&lt;/p>
&lt;p>&lt;strong>查企业，查信用就上企查查~&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/YY4a1FLD4yiaRqhUn1B4oa6IGz5wP2HWiaCIwSqddwdSM8ya4MiaTVqwN72zVlb8lFFDGVxcsicbOos7Hkkfzt6icibQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>app 逆向 平头哥实战（某农产品 app）</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/app-%E9%80%86%E5%90%91-%E5%B9%B3%E5%A4%B4%E5%93%A5%E5%AE%9E%E6%88%98%E6%9F%90%E5%86%9C%E4%BA%A7%E5%93%81-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/app-%E9%80%86%E5%90%91-%E5%B9%B3%E5%A4%B4%E5%93%A5%E5%AE%9E%E6%88%98%E6%9F%90%E5%86%9C%E4%BA%A7%E5%93%81-app/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODQ2NTU1OA==&amp;amp;mid=2247483690&amp;amp;idx=1&amp;amp;sn=27bf7e794923eddb33db649e8cff3c78&amp;amp;chksm=c0636b53f714e2455ee92ea38d24c29d75a3a60054c3c328739eea2fad641748b9e72ea0c6c6&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0302WsjmRKB1KVsoGm0GKQrv&amp;amp;sharer_sharetime=1646203591311&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>转发说明：&lt;/p>
&lt;p>本文章对 app 的逆向分析全程使用平头哥工具链、包括 hook、插件、抓包、脱壳等。除此之外平头哥的多开分身、自动化框架、rdp、调度任务框架、sekiro 继承的 RPC 框架等。可以覆盖移动安全分析的多个业务需求&lt;/p>
&lt;p>对平头哥感兴趣的同学，可以添加微信：virjar1，备注平头哥，拉入微信交流群&lt;/p>
&lt;p>以下为黑同学对平头哥使用的文章全文：&lt;/p>
&lt;p>使用渣总的平头哥对这个 app 进行脱壳，抓包，破解，分析&lt;/p>
&lt;pre tabindex="0">&lt;code>平头哥项目地址：https://github.com/virjarRatel
克隆如下图的项目模板地址：https://github.com/virjarRatel/ratel-module-template
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0FibY4HLfpc79mE5yuPPwkAricVK0kNUDpopvI8vL7gib3sEHWTuExiaKvw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>克隆下来之后用 Android Studio 打开这个项目&lt;/p>
&lt;p>我们通过以下命令来快速创建平头哥项目，因为我是 win 所以使用 bat 来创建&lt;/p>
&lt;p>linux 要使用 sh 创建 &lt;/p>
&lt;pre tabindex="0">&lt;code>template.bat -a C:\Users\LEGION\Desktop\ptg2.0\com.nst.android_7.5.5_408308_ratel.apk -m create_nst
&lt;/code>&lt;/pre>&lt;p>命令：template.bat -a 【指定你的 apk 所在的路径】-m 【给你的插件项目起一个名字】如下图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0v2BKhZ6htpQDaWk4rAH3hsQnIl9pQdicFyVGhp4h39a7RwDKEQSwsWw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>就会生成一个后缀名字为 create_nst 的插件 要在 settings.gradle 设置里面添加你生成的 app 的名字，看到有一个小绿点说明我们配置的没有问题了，接下来就要开始搞 app 了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH06XGELnCh5nRsU6wsITSicSoN0pIhKEHqeFiceTBrgW5XmgfWqWA2P6Jw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>打开创建好的项目会发现有一些代码逻辑，我们可以给他删除掉编写自己的代码逻辑  &lt;/p>
&lt;p>样本 app 手机商城直接搜索 农商通  下载即可 jadx 打开发现这个 app 是加固的所以我们要用平头哥进行脱壳，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0KxyhFNGAFhEzXasAJU0cTTNwfu26dPicJjZ2mNz1d8iaJrAfRAm09ibWA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>平头哥脱壳代码 如图所示 因为脱下来的壳会 copy 到 / sdcard/xxxx.apk 这个路径下&lt;/p>
&lt;pre tabindex="0">&lt;code>public class Unpack {
public static final String tag = &amp;#34;TR_HOOK&amp;#34;;
public static void entry(RC_LoadPackage.LoadPackageParam lpparam) {
// TODO 抽取壳要把这个选项打开
// UnPackerToolKit.autoEnable(true);
UnPackerToolKit.unpack(new UnPackerToolKit.UnpackEvent() {
@Override
public void onFinish(File file) {
try {
FileUtils.copyFile(file, new File(&amp;#34;/sdcard/nst-unpack.apk&amp;#34;));
} catch (IOException e) {
Log.e(tag, &amp;#34;unpacked error&amp;#34;, e);
e.printStackTrace();
}
}
});
}
}
&lt;/code>&lt;/pre>&lt;p>注意：这个 app 必须是平头哥感染后的应用才可以 &lt;/p>
&lt;p>下面安装插件进行脱壳 点击这个按钮等待安装&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0fgQ0zSHvffgTqWib4Y4VKxZrRWlIfEFbxruTFq3UWDibZAE7s9KwpUww/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>安装成功之后在会在 RatelManager.apk 中看见如下 app 就是感染成功了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0jXsxYVNm5NvAibLDEXHICKuIL1DSAUibspor9iaTRV1K2IHhqSqN6GFjw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>下面运行我们写好的插件开始进行脱壳&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0wfKvjjejvxZeribvkKxdsXCgHeViaOpujU8NLl1K3BzF3Kr7b55S45uw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>进入 cmd 输入 命令  adb logcat -s unpack 然后点击 app 倒数 三二一&lt;/p>
&lt;p>就会看到脱壳日志 平头哥会重新组装成一个 apk，为了 jadx 更好的分析看到平头哥最后打印的日志我们去这个路径下看看&lt;/p>
&lt;pre tabindex="0">&lt;code>/data/user/0/com.nst.android/files/ratel_unpack/unpacked.apk
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0BG85vqS0xsxbqmicXT74bWrBZHBbMkk3vNiaq3jk497GCrZ2b9kjOPIQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到这个有很多 dex 文件，还有一个 apk 证明平头哥脱壳成功了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0Gias4B8JuyA2WFaGzia6DaTjMuzDibpbSsFd9slCXHgiaZCibYiaNMvpcWLw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>因为我们脱壳代码写的是把脱壳 apk copy 到这个路径下所以我们直接看这个路径下有没有&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0TcOwh2tdlej6G7eMs9axlJnbYVL4ratvj7ZUc5NQ7TSyVdDzC1qyCQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>发现是有这个 apk 的，我们只需要拿这个 apk 分析就可以了，还有一种情况是拿不到这个 apk 的，原因是你在这个插件里面设置了一机多号的功能&lt;/p>
&lt;p>如果设置一机多号功能是有一个默认用户（default_0）需要在下面路径下寻找的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0CgrhbhbM4TB0oEeYibnbNQOFaqwbBXVI2B4stotNQCmePvNu0XLHLDg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也可以直接导出 dex 分析也是可以的&lt;/p>
&lt;p>现在我们开始抓包，为了方便我就先用 fiddler 抓包 发现有一个 x 签名和 okhttp3&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60owDKrsHvaJRxJVINdVsgH0NCxYhwLtscLygES07BC36vJuJDcd9GqyTLEibpMg1mr6rI0afkI9krg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>下面用平头哥进行抓包和堆栈打印 非常简单建议去看渣总的平头哥的文档 重新安装插件进行抓包&lt;/p>
&lt;pre tabindex="0">&lt;code>SocketMonitor.setPacketEventObserver(new FileLogEventObserver(new File(RatelToolKit.whiteSdcardDirPath, &amp;#34;socketMonitor&amp;#34;)));
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGaBfGBepx6l4EqpibRypMiaCltu2m3McSkHgIcbC7ggOgF2PeAWzPLWxQA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>默认抓包文件是在 / sdcard/ratel_white_dir/com.nst.android 路径下的 socketMonitor 文件里面，我们直接导出分析&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGaLkkmhOhPDsQKiceE5qkTiaXNTTv3cWkpN4b1Qlib1jSuiaVKgzVKQrYHng/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们对比 fiddler 抓包发现基本上报文响应是一样的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGacZHYDK2gkFgv5lY2kpPJQIWN1TNCOwCghbvIzb6pibo5Jj27dYibwuZA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>因为平头哥下面打印出调用栈了，又是 okhttp3 的请求库所以我们直接看调用栈就会发现下面的调用栈可能就是这个 app 的收发包函数，因为 okhttp3 是系统库所以我们不用关心，下面去找这个发包位置&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGaq6FUtnYY0284tWh4OQe69UFUTldZpIrvYAf4Wp7WCdGMvfHEJjBqNg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>经过查找果不其然是这个发包函数在下面我们正好看到了有关签名的信息 me.androidlibrary.network.okhttp.OkhttpFactory$1.intercept&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGaYsjeXWnxtibcHWtrT3fOQ4wiaULQzGfOEuACNibwylrV9S5oJToe8w0EQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>之前抓包的时候对比过有一个 “x” 的签名我们根据平头哥的调用栈追溯到 app 发包函数的具体位置当然这个是一个拦截器，签名逻辑就是在拦截器里&lt;/p>
&lt;p>具体的签名逻辑就是这个 我们只关心 x 的签名就可以了因为这个是没有登录的情况下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGa7CH1bdsB3RHUibXWzvLiacZsJ0p7icr4LGpwkawibvMNo6GcRBEAVf7PHA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>x：的签名逻辑发现是调用的这个类下的这个方法&lt;/p>
&lt;p>再往下追溯就到到了加密实现的类标准的 aes 算法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGattABzsTIBrWricrKHj328UxshsOJCmUTThp4hibSf1uw1KEGwTh830cg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们开始 hook 这个类中的方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGaPHrK4NncTHmzAbLngKwnSEB4DOp0mSicmdcx3Kh1goYIqg7QLqOQNfw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其实到这里我们已经分析的差不多了，现在要做的就是知道她的明文是什么就可以了，我们开始 hook 这个 开始写平头哥插件其实和 xposed 的写法是一摸一样的&lt;/p>
&lt;p>&lt;strong>因为是带壳的 app，渣总对平头哥做了封装 所以我们可以使用下面的 api 进行获取 apk 运行的类加载器，这个样我们就不用手动拦截 attch 的方式获取 context&lt;/strong>&lt;/p>
&lt;p>&lt;strong>可以看到使用平头哥的插件 hook 的就是加密后的返回的结果&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGabBic7aVrFRRibOTYkyTbpoZTAfgOs3gOEnFlwxic0EmUnoiaD7FaFb7JBQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后的明文加密数据就是就是 13 位的时间戳 + 一个固定的 key + AES 算法的中的 CBC 模式的 vi 偏移量&lt;/p>
&lt;p>vi: 固定值 0312032293271340&lt;/p>
&lt;p>str：就是时间戳 13 位的&lt;/p>
&lt;p>str2：也是固定值 key 45ryu230a@n2x302&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGag3h33Jt8s5XSbVibzvjKyVODbFjPA4rlgl5rBkBatm29iaXdxia5F6MuA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后献上平头哥 hook 代码&lt;/p>
&lt;pre tabindex="0">&lt;code>package ratel.com.nst.android;
import android.util.Log;
import com.virjar.ratel.api.RatelToolKit;
import com.virjar.ratel.api.extension.FileLogger;
import com.virjar.ratel.api.inspect.ClassLoadMonitor;
import com.virjar.ratel.api.rposed.IRposedHookLoadPackage;
import com.virjar.ratel.api.rposed.RC_MethodHook;
import com.virjar.ratel.api.rposed.RposedHelpers;
import com.virjar.ratel.api.rposed.callbacks.RC_LoadPackage;
public class HookNst implements IRposedHookLoadPackage {
private static final String tag = &amp;#34;NST_HOOK&amp;#34;;
@Override
public void handleLoadPackage(RC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
Log.i(tag, &amp;#34;start&amp;#34;);
ClassLoadMonitor.addClassLoadMonitor(&amp;#34;com.nst.android.utils.aes.AESUtils&amp;#34;, new ClassLoadMonitor.OnClassLoader() {
@Override
public void onClassLoad(Class&amp;lt;?&amp;gt; clazz) {
Log.i(tag, &amp;#34;find class: &amp;#34; + clazz.getName());
RposedHelpers.findAndHookMethod(clazz, &amp;#34;encrypt&amp;#34;,
String.class,
String.class,
new RC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
super.beforeHookedMethod(param);
String arg1 = (String) param.args[0];
String arg2 = (String) param.args[1];
Log.i(tag, &amp;#34;加密前的参数1：&amp;#34; + arg1);
Log.i(tag, &amp;#34;加密前的参数2：&amp;#34; + arg2);
Log.i(tag, &amp;#34;-------------------------&amp;#34;);
}
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
super.afterHookedMethod(param);
String agr3 = (String) param.getResult();
Log.i(tag, &amp;#34;加密后的结果：&amp;#34; + agr3);
}
});
}
});
Log.i(tag, &amp;#34;end&amp;#34;);
}
}
&lt;/code>&lt;/pre>&lt;p>最后线上 python 算法还原这里是搜了一位大佬的博客，我是直接拿来用的&lt;/p>
&lt;pre tabindex="0">&lt;code>import base64
from Crypto.Cipher import AES
def AES_Encrypt(key, data):
vi = &amp;#39;0312032293271340&amp;#39;
pad = lambda s: s + (16 - len(s) % 16) * chr(16 - len(s) % 16)
data = pad(data)
cipher = AES.new(key.encode(&amp;#39;utf8&amp;#39;), AES.MODE_CBC, vi.encode(&amp;#39;utf8&amp;#39;))
encryptedbytes = cipher.encrypt(data.encode(&amp;#39;utf8&amp;#39;))
# 加密后得到的是bytes类型的数据
encodestrs = base64.b64encode(encryptedbytes)
# 使用Base64进行编码,返回byte字符串
enctext = encodestrs.decode(&amp;#39;utf8&amp;#39;)
# 对byte字符串按utf-8进行解码
return enctext
def AES_Decrypt(key, data):
vi = &amp;#39;0102030405060708&amp;#39;
data = data.encode(&amp;#39;utf8&amp;#39;)
encodebytes = base64.decodebytes(data)
# 将加密数据转换位bytes类型数据
cipher = AES.new(key.encode(&amp;#39;utf8&amp;#39;), AES.MODE_CBC, vi.encode(&amp;#39;utf8&amp;#39;))
text_decrypted = cipher.decrypt(encodebytes)
unpad = lambda s: s[0:-s[-1]]
text_decrypted = unpad(text_decrypted)
# 去补位
text_decrypted = text_decrypted.decode(&amp;#39;utf8&amp;#39;)
return text_decrypted
key = &amp;#39;45ryu230a@n2x302&amp;#39;
data = &amp;#39;1633919358891&amp;#39;
AES_Encrypt(key, data)
enctext = AES_Encrypt(key, data)
print(enctext)
text_decrypted = AES_Decrypt(key, enctext)
print(text_decrypted)
# python实现的算法，和hook出来的是一摸一样的
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGa0qlACP8ficXfV58oVNYHZmHrkiaODvvcQ94kV9BqK7mticVH8FQGDpllQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后试试请求可以成功不 成功了，说明我们的算法是没有问题的现在就可以愉快的玩耍了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icp3x3Pxg60ppUaVFHPm4ib3dkic21TqfGaiaXg843Mkwf7V6gB7xeEmmxmXP0J6vGJltCrLceQ7LOKCHdhGfiaj7HQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>Frida Android hook _ Sakura の blog</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://eternalsakura13.com/2020/07/04/frida/" target="_blank" rel="noopener">eternalsakura13.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>建了一个知识星球：天问之路如果想学习二进制安全，或者和我交流，欢迎来这里找我 w Frida 环境 &lt;a href="https://github.com/frida/frida" target="_blank" rel="noopener">https://github.com/frida/frida&lt;/a> pyenvpython 全版本随机切换，这里提供&amp;hellip;&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;h2 id="建了一个知识星球天问之路-建了一个知识星球天问之路建了一个知识星球天问之路">&lt;a href="#%e5%bb%ba%e4%ba%86%e4%b8%80%e4%b8%aa%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83%ef%bc%9a%e5%a4%a9%e9%97%ae%e4%b9%8b%e8%b7%af" title="建了一个知识星球：天问之路">&lt;/a>建了一个知识星球：天问之路&lt;/h2>
&lt;p>如果想学习二进制安全，或者和我交流，欢迎来这里找我 w&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2021-06-22-034815.jpg" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2021-06-22-034815.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h2 id="frida环境-frida环境frida-环境">&lt;a href="#Frida%e7%8e%af%e5%a2%83" title="Frida环境">&lt;/a>Frida 环境&lt;/h2>
&lt;p>&lt;a href="https://github.com/frida/frida" target="_blank" rel="noopener">https://github.com/frida/frida&lt;/a>&lt;/p>
&lt;h3 id="pyenv-pyenvpyenv">&lt;a href="#pyenv" title="pyenv">&lt;/a>pyenv&lt;/h3>
&lt;p>python 全版本随机切换，这里提供 &lt;a href="https://github.com/pyenv/pyenv#homebrew-on-macos" target="_blank" rel="noopener">macOS 上的配置方法&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>brew update
brew install pyenv
echo -e &amp;#39;if command -v pyenv 1&amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then\n eval &amp;#34;$(pyenv init -)&amp;#34;\nfi&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>下载一个3.8.2，下载真的很慢，要慢慢等
pyenv install 3.8.2
pyenv versions
sakura@sakuradeMacBook-Pro:~$ pyenv versions
system
* 3.8.2 (set by /Users/sakura/.python-version)
切换到我们装的
pyenv local 3.8.2
python -V
pip -V
原本系统自带的
python local system
python -V
&lt;/code>&lt;/pre>&lt;p>另外当你需要临时禁用 pyenv 的时候&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134140.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134140.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
把这个注释了然后另开终端就好了。&lt;/p>
&lt;p>关于卸载某个 python 版本&lt;/p>
&lt;pre tabindex="0">&lt;code>Uninstalling Python Versions
As time goes on, you will accumulate Python versions in your $(pyenv root)/versions directory.
To remove old Python versions, pyenv uninstall command to automate the removal process.
Alternatively, simply rm -rf the directory of the version you want to remove. You can find the directory of a particular Python version with the pyenv prefix command, e.g. pyenv prefix 2.6.8.
&lt;/code>&lt;/pre>&lt;h3 id="frida安装-frida安装frida-安装">&lt;a href="#frida%e5%ae%89%e8%a3%85" title="frida安装">&lt;/a>frida 安装&lt;/h3>
&lt;p>如果直接按下述安装则会直接安装 frida 和 frida-tools 的最新版本。&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install frida-tools
frida --version
frida-ps --version
&lt;/code>&lt;/pre>&lt;p>我们也可以自由安装旧版本的 frida，例如 12.8.0&lt;/p>
&lt;pre tabindex="0">&lt;code>pyenv install 3.7.7
pyenv local 3.7.7
pip install frida==12.8.0
pip install frida-tools==5.3.0
&lt;/code>&lt;/pre>&lt;p>老版本 frida 和对应关系&lt;br>
对应关系很好找&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134837.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134837.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h3 id="安装objection-安装objection安装-objection">&lt;a href="#%e5%ae%89%e8%a3%85objection" title="安装objection">&lt;/a>安装 objection&lt;/h3>
&lt;pre tabindex="0">&lt;code>pyenv local 3.8.2
pip install objection
objection -h
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>pyenv local 3.7.7
pip install objection==1.8.4
objection -h
&lt;/code>&lt;/pre>&lt;h3 id="frida使用-frida使用frida-使用">&lt;a href="#frida%e4%bd%bf%e7%94%a8" title="frida使用">&lt;/a>frida 使用&lt;/h3>
&lt;p>下载 frida-server 并解压，在这里下载 &lt;a href="https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz" target="_blank" rel="noopener">frida-server-12.8.0&lt;/a>&lt;/p>
&lt;p>先 adb shell，然后切换到 root 权限, 把之前 push 进来的 frida server 改个名字叫 fs&lt;br>
然后运行 frida&lt;/p>
&lt;pre tabindex="0">&lt;code>adb push /Users/sakura/Desktop/lab/alpha/tools/android/frida-server-12.8.0-android-arm64 /data/local/tmp
chmod +x fs
./fs
&lt;/code>&lt;/pre>&lt;p>如果要监听端口，就&lt;/p>
&lt;pre tabindex="0">&lt;code>./fs -l 0.0.0.0:8888
&lt;/code>&lt;/pre>&lt;h3 id="frida开发环境搭建-frida开发环境搭建frida-开发环境搭建">&lt;a href="#frida%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba" title="frida开发环境搭建">&lt;/a>frida 开发环境搭建&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>安装&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone https://github.com/oleavr/frida-agent-example.git
cd frida-agent-example/
npm install
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>使用 vscode 打开此工程，在 agent 文件夹下编写 js，会有智能提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npm run watch&lt;/code>会监控代码修改自动编译生成 js 文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>python 脚本或者 cli 加载_agent.js&lt;br>
&lt;code>frida -U -f com.example.android --no-pause -l _agent.js&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>下面是测试脚本&lt;/p>
&lt;p>&lt;code>s1.js&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>function main() {
Java.perform(function x() {
console.log(&amp;#34;sakura&amp;#34;)
})
}
setImmediate(main)
&lt;/code>&lt;/pre>&lt;p>&lt;code>loader.py&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>import time
import frida
device8 = frida.get_device_manager().add_remote_device(&amp;#34;192.168.0.9:8888&amp;#34;)
pid = device8.spawn(&amp;#34;com.android.settings&amp;#34;)
device8.resume(pid)
time.sleep(1)
session = device8.attach(pid)
with open(&amp;#34;si.js&amp;#34;) as f:
script = session.create_script(f.read())
script.load()
input() #等待输入
&lt;/code>&lt;/pre>&lt;p>解释一下，这个脚本就是先通过&lt;code>frida.get_device_manager().add_remote_device&lt;/code>来找到 device, 然后 spawn 方式启动 settings，然后 attach 到上面，并执行 frida 脚本。&lt;/p>
&lt;h2 id="frida基础-frida基础frida-基础">&lt;a href="#FRIDA%e5%9f%ba%e7%a1%80" title="FRIDA基础">&lt;/a>FRIDA 基础&lt;/h2>
&lt;h3 id="frida查看当前存在的进程-frida查看当前存在的进程frida-查看当前存在的进程">&lt;a href="#frida%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e5%ad%98%e5%9c%a8%e7%9a%84%e8%bf%9b%e7%a8%8b" title="frida查看当前存在的进程">&lt;/a>frida 查看当前存在的进程&lt;/h3>
&lt;p>&lt;code>frida-ps -U&lt;/code>查看通过 usb 连接的 android 手机上的进程。&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ frida-ps --help
Usage: frida-ps [options]
Options:
--version show program&amp;#39;s version number and exit
-h, --help show this help message and exit
-D ID, --device=ID connect to device with the given ID
-U, --usb connect to USB device
-R, --remote connect to remote frida-server
-H HOST, --host=HOST connect to remote frida-server on HOST
-a, --applications list only applications
-i, --installed include all installed applications
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ frida-ps -U
PID Name
----- ---------------------------------------------------
3640 ATFWD-daemon
707 adbd
728 adsprpcd
26041 android.hardware.audio@2.0-service
741 android.hardware.biometrics.fingerprint@
&lt;/code>&lt;/pre>&lt;p>通过 grep 过滤就可以找到我们想要的包名。&lt;/p>
&lt;h3 id="frida打印参数和修改返回值-frida打印参数和修改返回值frida-打印参数和修改返回值">&lt;a href="#frida%e6%89%93%e5%8d%b0%e5%8f%82%e6%95%b0%e5%92%8c%e4%bf%ae%e6%94%b9%e8%bf%94%e5%9b%9e%e5%80%bc" title="frida打印参数和修改返回值">&lt;/a>frida 打印参数和修改返回值&lt;/h3>
&lt;pre tabindex="0">&lt;code>package myapplication.example.com.frida_demo;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
public class MainActivity extends AppCompatActivity {
private String total = &amp;#34;@@@###@@@&amp;#34;;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
while (true){
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
fun(50,30);
Log.d(&amp;#34;sakura.string&amp;#34; , fun(&amp;#34;LoWeRcAsE Me!!!!!!!!!&amp;#34;));
}
}
void fun(int x , int y ){
Log.d(&amp;#34;sakura.Sum&amp;#34; , String.valueOf(x+y));
}
String fun(String x){
total +=x;
return x.toLowerCase();
}
String secret(){
return total;
}
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>function main() {
console.log(&amp;#34;Enter the Script!&amp;#34;);
Java.perform(function x() {
console.log(&amp;#34;Inside Java perform&amp;#34;);
var MainActivity = Java.use(&amp;#34;myapplication.example.com.frida_demo.MainActivity&amp;#34;);
// 重载找到指定的函数
MainActivity.fun.overload(&amp;#39;java.lang.String&amp;#39;).implementation = function (str) {
//打印参数
console.log(&amp;#34;original call : str:&amp;#34; + str);
//修改结果
var ret_value = &amp;#34;sakura&amp;#34;;
return ret_value;
};
})
}
setImmediate(main);
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ frida-ps -U | grep frida
8738 frida-helper-32
8897 myapplication.example.com.frida_demo
// -f是通过spawn，也就是重启apk注入js
sakura@sakuradeMacBook-Pro:~$ frida -U -f myapplication.example.com.frida_demo -l frida_demo.js
...
original call : str:LoWeRcAsE Me!!!!!!!!!
12-21 04:46:49.875 9594-9594/myapplication.example.com.frida_demo D/sakura.string: sakura
&lt;/code>&lt;/pre>&lt;h3 id="frida寻找instance主动调用frida寻找instance主动调用frida-寻找-instance主动调用">&lt;a href="#frida%e5%af%bb%e6%89%beinstance%ef%bc%8c%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e3%80%82%22frida%e5%af%bb%e6%89%beinstance%ef%bc%8c%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e3%80%82%22">&lt;/a>frida 寻找 instance，主动调用。&lt;/h3>
&lt;pre tabindex="0">&lt;code>function main() {
console.log(&amp;#34;Enter the Script!&amp;#34;);
Java.perform(function x() {
console.log(&amp;#34;Inside Java perform&amp;#34;);
var MainActivity = Java.use(&amp;#34;myapplication.example.com.frida_demo.MainActivity&amp;#34;);
//overload 选择被重载的对象
MainActivity.fun.overload(&amp;#39;java.lang.String&amp;#39;).implementation = function (str) {
//打印参数
console.log(&amp;#34;original call : str:&amp;#34; + str);
//修改结果
var ret_value = &amp;#34;sakura&amp;#34;;
return ret_value;
};
// 寻找类型为classname的实例
Java.choose(&amp;#34;myapplication.example.com.frida_demo.MainActivity&amp;#34;, {
onMatch: function (x) {
console.log(&amp;#34;find instance :&amp;#34; + x);
console.log(&amp;#34;result of secret func:&amp;#34; + x.secret());
},
onComplete: function () {
console.log(&amp;#34;end&amp;#34;);
}
});
});
}
setImmediate(main);
&lt;/code>&lt;/pre>&lt;h3 id="frida-rpc-frida-rpcfrida-rpc">&lt;a href="#frida-rpc" title="frida rpc">&lt;/a>frida rpc&lt;/h3>
&lt;pre tabindex="0">&lt;code>function callFun() {
Java.perform(function fn() {
console.log(&amp;#34;begin&amp;#34;);
Java.choose(&amp;#34;myapplication.example.com.frida_demo.MainActivity&amp;#34;, {
onMatch: function (x) {
console.log(&amp;#34;find instance :&amp;#34; + x);
console.log(&amp;#34;result of fun(string) func:&amp;#34; + x.fun(Java.use(&amp;#34;java.lang.String&amp;#34;).$new(&amp;#34;sakura&amp;#34;)));
},
onComplete: function () {
console.log(&amp;#34;end&amp;#34;);
}
})
})
}
rpc.exports = {
callfun: callFun
};
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>import time
import frida
device = frida.get_usb_device()
pid = device.spawn([&amp;#34;myapplication.example.com.frida_demo&amp;#34;])
device.resume(pid)
time.sleep(1)
session = device.attach(pid)
with open(&amp;#34;frida_demo_rpc_call.js&amp;#34;) as f:
script = session.create_script(f.read())
def my_message_handler(message, payload):
print(message)
print(payload)
script.on(&amp;#34;message&amp;#34;, my_message_handler)
script.load()
script.exports.callfun()
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/gitsource/frida-agent-example/agent$ python frida_demo_rpc_loader.py
begin
find instance :myapplication.example.com.frida_demo.MainActivity@1d4b09d
result of fun(string):sakura
end
&lt;/code>&lt;/pre>&lt;h3 id="frida动态修改-frida动态修改frida-动态修改">&lt;a href="#frida%e5%8a%a8%e6%80%81%e4%bf%ae%e6%94%b9" title="frida动态修改">&lt;/a>frida 动态修改&lt;/h3>
&lt;p>即将手机上的 app 的内容发送到 PC 上的 frida python 程序，然后处理后返回给 app，然后 app 再做后续的流程，核心是理解&lt;code>send/recv&lt;/code>函数&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;TextView
android:id=&amp;#34;@+id/textView&amp;#34;
android:layout_width=&amp;#34;wrap_content&amp;#34;
android:layout_height=&amp;#34;wrap_content&amp;#34;
android:text=&amp;#34;please input username and password&amp;#34;
app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;
app:layout_constraintLeft_toLeftOf=&amp;#34;parent&amp;#34;
app:layout_constraintRight_toRightOf=&amp;#34;parent&amp;#34;
app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt;
&amp;lt;EditText
android:id=&amp;#34;@+id/editText&amp;#34;
android:layout_width=&amp;#34;fill_parent&amp;#34;
android:layout_height=&amp;#34;40dp&amp;#34;
android:hint=&amp;#34;username&amp;#34;
android:maxLength=&amp;#34;20&amp;#34;
app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;
app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34;
app:layout_constraintHorizontal_bias=&amp;#34;1.0&amp;#34;
app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;
app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;
app:layout_constraintVertical_bias=&amp;#34;0.095&amp;#34; /&amp;gt;
&amp;lt;EditText
android:id=&amp;#34;@+id/editText2&amp;#34;
android:layout_width=&amp;#34;fill_parent&amp;#34;
android:layout_height=&amp;#34;40dp&amp;#34;
android:hint=&amp;#34;password&amp;#34;
android:maxLength=&amp;#34;20&amp;#34;
app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;
app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;
app:layout_constraintVertical_bias=&amp;#34;0.239&amp;#34; /&amp;gt;
&amp;lt;Button
android:id=&amp;#34;@+id/button&amp;#34;
android:layout_width=&amp;#34;100dp&amp;#34;
android:layout_height=&amp;#34;35dp&amp;#34;
android:layout_gravity=&amp;#34;right|center_horizontal&amp;#34;
android:text=&amp;#34;提交&amp;#34;
android:visibility=&amp;#34;visible&amp;#34;
app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;
app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34;
app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;
app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;
app:layout_constraintVertical_bias=&amp;#34;0.745&amp;#34; /&amp;gt;
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>public class MainActivity extends AppCompatActivity {
EditText username_et;
EditText password_et;
TextView message_tv;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
password_et = (EditText) this.findViewById(R.id.editText2);
username_et = (EditText) this.findViewById(R.id.editText);
message_tv = ((TextView) findViewById(R.id.textView));
this.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
if (username_et.getText().toString().compareTo(&amp;#34;admin&amp;#34;) == 0) {
message_tv.setText(&amp;#34;You cannot login as admin&amp;#34;);
return;
}
//hook target
message_tv.setText(&amp;#34;Sending to the server :&amp;#34; + Base64.encodeToString((username_et.getText().toString() + &amp;#34;:&amp;#34; + password_et.getText().toString()).getBytes(), Base64.DEFAULT));
}
});
}
}
&lt;/code>&lt;/pre>&lt;p>先分析问题，我的最终目标是让 message_tv.setText 可以” 发送”username 为 admin 的 base64 字符串。
那肯定是 hook TextView.setText 这个函数。&lt;/p>
&lt;pre tabindex="0">&lt;code>console.log(&amp;#34;Script loaded successfully &amp;#34;);
Java.perform(function () {
var tv_class = Java.use(&amp;#34;android.widget.TextView&amp;#34;);
tv_class.setText.overload(&amp;#34;java.lang.CharSequence&amp;#34;).implementation = function (x) {
var string_to_send = x.toString();
var string_to_recv;
send(string_to_send); // send data to python code
recv(function (received_json_object) {
string_to_recv = received_json_object.my_data
console.log(&amp;#34;string_to_recv: &amp;#34; + string_to_recv);
}).wait(); //block execution till the message is received
var my_string = Java.use(&amp;#34;java.lang.String&amp;#34;).$new(string_to_recv);
this.setText(my_string);
}
});
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>import time
import frida
import base64
def my_message_handler(message, payload):
print(message)
print(payload)
if message[&amp;#34;type&amp;#34;] == &amp;#34;send&amp;#34;:
print(message[&amp;#34;payload&amp;#34;])
data = message[&amp;#34;payload&amp;#34;].split(&amp;#34;:&amp;#34;)[1].strip()
print( &amp;#39;message:&amp;#39;, message)
#data = data.decode(&amp;#34;base64&amp;#34;)
#data = data
data = str(base64.b64decode(data))
print( &amp;#39;data:&amp;#39;,data)
user, pw = data.split(&amp;#34;:&amp;#34;)
print( &amp;#39;pw:&amp;#39;,pw)
#data = (&amp;#34;admin&amp;#34; + &amp;#34;:&amp;#34; + pw).encode(&amp;#34;base64&amp;#34;)
data = str(base64.b64encode((&amp;#34;admin&amp;#34; + &amp;#34;:&amp;#34; + pw).encode()))
print( &amp;#34;encoded data:&amp;#34;, data)
script.post({&amp;#34;my_data&amp;#34;: data}) # send JSON object
print( &amp;#34;Modified data sent&amp;#34;)
device = frida.get_usb_device()
pid = device.spawn([&amp;#34;myapplication.example.com.frida_demo&amp;#34;])
device.resume(pid)
time.sleep(1)
session = device.attach(pid)
with open(&amp;#34;frida_demo2.js&amp;#34;) as f:
script = session.create_script(f.read())
script.on(&amp;#34;message&amp;#34;, my_message_handler)
script.load()
input()
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/gitsource/frida-agent-example/agent$ python frida_demo_rpc_loader2.py
Script loaded successfully
{&amp;#39;type&amp;#39;: &amp;#39;send&amp;#39;, &amp;#39;payload&amp;#39;: &amp;#39;Sending to the server :c2FrdXJhOjEyMzQ1Ng==\n&amp;#39;}
None
Sending to the server :c2FrdXJhOjEyMzQ1Ng==
message: {&amp;#39;type&amp;#39;: &amp;#39;send&amp;#39;, &amp;#39;payload&amp;#39;: &amp;#39;Sending to the server :c2FrdXJhOjEyMzQ1Ng==\n&amp;#39;}
data: b&amp;#39;sakura:123456&amp;#39;
pw: 123456&amp;#39;
encoded data: b&amp;#39;YWRtaW46MTIzNDU2Jw==&amp;#39;
Modified data sent
string_to_recv: b&amp;#39;YWRtaW46MTIzNDU2Jw==&amp;#39;
&lt;/code>&lt;/pre>&lt;p>参考链接：&lt;a href="https://github.com/Mind0xP/Frida-Python-Binding" target="_blank" rel="noopener">https://github.com/Mind0xP/Frida-Python-Binding&lt;/a>&lt;/p>
&lt;h3 id="api-list-api-listapi-list">&lt;a href="#API-List" title="API List">&lt;/a>API List&lt;/h3>
&lt;ul>
&lt;li>&lt;code>Java.choose(className: string, callbacks: Java.ChooseCallbacks): void&lt;/code>&lt;br>
通过扫描 Java VM 的堆来枚举 className 类的 live instance。&lt;/li>
&lt;li>&lt;code>Java.use(className: string): Java.Wrapper&amp;lt;{}&amp;gt;&lt;/code>&lt;br>
动态为 className 生成 JavaScript Wrapper，可以通过调用&lt;code>$new()&lt;/code>来调用构造函数来实例化对象。
在实例上调用&lt;code>$dispose()&lt;/code>以对其进行显式清理，或者等待 JavaScript 对象被 gc。&lt;/li>
&lt;li>&lt;code>Java.perform(fn: () =&amp;gt; void): void&lt;/code>&lt;br>
Function to run while attached to the VM.&lt;br>
Ensures that the current thread is attached to the VM and calls fn. (This isn’t necessary in callbacks from Java.)&lt;br>
Will defer calling fn if the app’s class loader is not available yet. Use Java.performNow() if access to the app’s classes is not needed.&lt;/li>
&lt;li>&lt;code>send(message: any, data?: ArrayBuffer | number[]): void&lt;/code>&lt;br>
任何 JSON 可序列化的值。
将 JSON 序列化后的 message 发送到您的基于 Frida 的应用程序，并包含 (可选) 一些原始二进制数据。
The latter is useful if you e.g. dumped some memory using NativePointer#readByteArray().&lt;/li>
&lt;li>&lt;code>recv(callback: MessageCallback): MessageRecvOperation&lt;/code>&lt;br>
Requests callback to be called on the next message received from your Frida-based application.&lt;br>
This will only give you one message, so you need to call recv() again to receive the next one.&lt;/li>
&lt;li>&lt;code>wait(): void&lt;/code>&lt;br>
堵塞，直到 message 已经 receive 并且 callback 已经执行完毕并返回&lt;/li>
&lt;/ul>
&lt;h2 id="frida动静态结合分析-frida动静态结合分析frida-动静态结合分析">&lt;a href="#Frida%e5%8a%a8%e9%9d%99%e6%80%81%e7%bb%93%e5%90%88%e5%88%86%e6%9e%90" title="Frida动静态结合分析">&lt;/a>Frida 动静态结合分析&lt;/h2>
&lt;h3 id="objection-objectionobjection">&lt;a href="#Objection" title="Objection">&lt;/a>Objection&lt;/h3>
&lt;ul>
&lt;li>参考这篇文章&lt;br>
&lt;a href="https://www.anquanke.com/post/id/197657" target="_blank" rel="noopener">实用 FRIDA 进阶：内存漫游、hook anywhere、抓包&lt;/a>&lt;/li>
&lt;li>objection&lt;br>
&lt;a href="https://pypi.org/project/objection/" target="_blank" rel="noopener">https://pypi.org/project/objection/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="objection启动并注入内存-objection启动并注入内存objection-启动并注入内存">&lt;a href="#objection%e5%90%af%e5%8a%a8%e5%b9%b6%e6%b3%a8%e5%85%a5%e5%86%85%e5%ad%98" title="objection启动并注入内存">&lt;/a>objection 启动并注入内存&lt;/h4>
&lt;p>&lt;code>objection -d -g package_name explore&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ objection -d -g com.android.settings explore
[debug] Agent path is: /Users/sakura/.pyenv/versions/3.7.7/lib/python3.7/site-packages/objection/agent.js
[debug] Injecting agent...
Using USB device `Google Pixel`
[debug] Attempting to attach to process: `com.android.settings`
[debug] Process attached!
Agent injected and responds ok!
_ _ _ _
___| |_|_|___ ___| |_|_|___ ___
| . | . | | -_| _| _| | . | |
|___|___| |___|___|_| |_|___|_|_|
|___|(object)inject(ion) v1.8.4
Runtime Mobile Exploration
by: @leonjza from @sensepost
[tab] for command suggestions
com.android.settings on (google: 8.1.0) [usb] #
&lt;/code>&lt;/pre>&lt;h4 id="objection-memory-objection-memoryobjection-memory">&lt;a href="#objection-memory" title="objection memory">&lt;/a>objection memory&lt;/h4>
&lt;h5 id="查看内存中加载的module-memory-list-modules-查看内存中加载的module-memory-list-modules查看内存中加载的-module-memory-list-modules">&lt;a href="#%e6%9f%a5%e7%9c%8b%e5%86%85%e5%ad%98%e4%b8%ad%e5%8a%a0%e8%bd%bd%e7%9a%84module-memory-list-modules" title="查看内存中加载的module memory list modules">&lt;/a>查看内存中加载的 module &lt;code>memory list modules&lt;/code>&lt;/h5>
&lt;pre tabindex="0">&lt;code>com.android.settings on (google: 8.1.0) [usb] # memory list modules
Save the output by adding `--json modules.json` to this command
Name Base Size Path
----------------------------------------------- ------------ -------------------- ---------------------------------------------------------------
app_process64 0x64ce143000 32768 (32.0 KiB) /system/bin/app_process64
libandroid_runtime.so 0x7a90bc3000 1990656 (1.9 MiB) /system/lib64/libandroid_runtime.so
libbinder.so 0x7a9379f000 557056 (544.0 KiB) /system/lib64/libbinder.so
&lt;/code>&lt;/pre>&lt;h5 id="查看库的导出函数-memory-list-exports-libssl-so-查看库的导出函数-memory-list-exports-libsslso查看库的导出函数-memory-list-exports-libsslso">&lt;a href="#%e6%9f%a5%e7%9c%8b%e5%ba%93%e7%9a%84%e5%af%bc%e5%87%ba%e5%87%bd%e6%95%b0-memory-list-exports-libssl-so" title="查看库的导出函数 memory list exports libssl.so">&lt;/a>查看库的导出函数 &lt;code>memory list exports libssl.so&lt;/code>&lt;/h5>
&lt;pre tabindex="0">&lt;code>com.android.settings on (google: 8.1.0) [usb] # memory list exports libssl.so
Save the output by adding `--json exports.json` to this command
Type Name Address
-------- ----------------------------------------------------- ------------
function SSL_use_certificate_ASN1 0x7c8ff006f8
function SSL_CTX_set_dos_protection_cb 0x7c8ff077b8
function SSL_SESSION_set_ex_data 0x7c8ff098f4
function SSL_CTX_set_session_psk_dhe_timeout 0x7c8ff0a754
function SSL_CTX_sess_accept 0x7c8ff063b8
function SSL_select_next_proto 0x7c8ff06a74
&lt;/code>&lt;/pre>&lt;h5 id="dump内存空间-dump内存空间dump-内存空间">&lt;a href="#dump%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4" title="dump内存空间">&lt;/a>dump 内存空间&lt;/h5>
&lt;ul>
&lt;li>
&lt;p>&lt;code>memory dump all 文件名&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>memory dump from_base 起始地址 字节数 文件名&lt;/code>&lt;/p>
&lt;h5 id="搜索内存空间-搜索内存空间搜索内存空间">&lt;a href="#%e6%90%9c%e7%b4%a2%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4" title="搜索内存空间">&lt;/a>搜索内存空间&lt;/h5>
&lt;p>&lt;code>Usage: memory search &amp;quot;&amp;lt;pattern eg: 41 41 41 ?? 41&amp;gt;&amp;quot; (--string) (--offsets-only)&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="objection-android-objection-androidobjection-android">&lt;a href="#objection-android" title="objection android">&lt;/a>objection android&lt;/h4>
&lt;h5 id="内存堆搜索实例-android-heap-search-instances-类名-内存堆搜索实例-android-heap-search-instances-类名内存堆搜索实例-android-heap-search-instances-类名">&lt;a href="#%e5%86%85%e5%ad%98%e5%a0%86%e6%90%9c%e7%b4%a2%e5%ae%9e%e4%be%8b-android-heap-search-instances-%e7%b1%bb%e5%90%8d" title="内存堆搜索实例 android heap search instances 类名">&lt;/a>内存堆搜索实例 &lt;code>android heap search instances 类名&lt;/code>&lt;/h5>
&lt;p>在堆上搜索类的实例&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ objection -g myapplication.example.com.frida_demo explore
Using USB device `Google Pixel`
Agent injected and responds ok!
[usb] # android heap search instances myapplication.example.com.frida_demo
.MainActivity
Class instance enumeration complete for myapplication.example.com.frida_demo.MainActivity
Handle Class toString()
-------- ------------------------------------------------- ---------------------------------------------------------
0x2102 myapplication.example.com.frida_demo.MainActivity myapplication.example.com.frida_demo.MainActivity@5b1b0af
&lt;/code>&lt;/pre>&lt;h5 id="调用实例的方法-android-heap-execute-实例id-实例方法-调用实例的方法-android-heap-execute-实例id-实例方法调用实例的方法-android-heap-execute-实例id-实例方法">&lt;a href="#%e8%b0%83%e7%94%a8%e5%ae%9e%e4%be%8b%e7%9a%84%e6%96%b9%e6%b3%95-android-heap-execute-%e5%ae%9e%e4%be%8bID-%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95" title="调用实例的方法 android heap execute 实例ID 实例方法">&lt;/a>调用实例的方法 &lt;code>android heap execute 实例ID 实例方法&lt;/code>&lt;/h5>
&lt;h5 id="查看当前可用的activity或者service-android-hooking-list-activities-services-查看当前可用的activity或者service-android-hooking-list-activitiesservices查看当前可用的-activity-或者-service-android-hooking-list-activitiesservices">&lt;a href="#%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e5%8f%af%e7%94%a8%e7%9a%84activity%e6%88%96%e8%80%85service-android-hooking-list-activities-services" title="查看当前可用的activity或者service android hooking list activities/services">&lt;/a>查看当前可用的 activity 或者 service &lt;code>android hooking list activities/services&lt;/code>&lt;/h5>
&lt;h5 id="直接启动activity或者服务-android-intent-launch-activity-launch-service-activity-服务-直接启动activity或者服务-android-intent-launch_activitylaunch_service-activity服务直接启动-activity-或者服务-android-intent-launch_activitylaunch_service-activity服务">&lt;a href="#%e7%9b%b4%e6%8e%a5%e5%90%af%e5%8a%a8activity%e6%88%96%e8%80%85%e6%9c%8d%e5%8a%a1-android-intent-launch-activity-launch-service-activity-%e6%9c%8d%e5%8a%a1" title="直接启动activity或者服务 android intent launch_activity/launch_service activity/服务">&lt;/a>直接启动 activity 或者服务 &lt;code>android intent launch_activity/launch_service activity/服务&lt;/code>&lt;/h5>
&lt;p>&lt;code>android intent launch_activity com.android.settings.DisplaySettings&lt;/code>&lt;br>
这个命令比较有趣的是用在如果有些设计的不好，可能就直接绕过了密码锁屏等直接进去。&lt;/p>
&lt;pre tabindex="0">&lt;code>com.android.settings on (google: 8.1.0) [usb] # android hooking list services
com.android.settings.SettingsDumpService
com.android.settings.TetherService
com.android.settings.bluetooth.BluetoothPairingService
&lt;/code>&lt;/pre>&lt;h5 id="列出内存中所有的类-android-hooking-list-classes-列出内存中所有的类-android-hooking-list-classes列出内存中所有的类-android-hooking-list-classes">&lt;a href="#%e5%88%97%e5%87%ba%e5%86%85%e5%ad%98%e4%b8%ad%e6%89%80%e6%9c%89%e7%9a%84%e7%b1%bb-android-hooking-list-classes" title="列出内存中所有的类 android hooking list classes">&lt;/a>列出内存中所有的类 &lt;code>android hooking list classes&lt;/code>&lt;/h5>
&lt;h5 id="在内存中所有已加载的类中搜索包含特定关键词的类-android-hooking-search-classes-display-在内存中所有已加载的类中搜索包含特定关键词的类android-hooking-search-classes-display在内存中所有已加载的类中搜索包含特定关键词的类android-hooking-search-classes-display">&lt;a href="#%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e6%89%80%e6%9c%89%e5%b7%b2%e5%8a%a0%e8%bd%bd%e7%9a%84%e7%b1%bb%e4%b8%ad%e6%90%9c%e7%b4%a2%e5%8c%85%e5%90%ab%e7%89%b9%e5%ae%9a%e5%85%b3%e9%94%ae%e8%af%8d%e7%9a%84%e7%b1%bb%e3%80%82-android-hooking-search-classes-display" title="在内存中所有已加载的类中搜索包含特定关键词的类。android hooking search classes display">&lt;/a>在内存中所有已加载的类中搜索包含特定关键词的类。&lt;code>android hooking search classes display&lt;/code>&lt;/h5>
&lt;pre tabindex="0">&lt;code>com.android.settings on (google: 8.1.0) [usb] # android hooking search classes display
[Landroid.icu.text.DisplayContext$Type;
[Landroid.icu.text.DisplayContext;
[Landroid.view.Display$Mode;
android.hardware.display.DisplayManager
android.hardware.display.DisplayManager$DisplayListener
android.hardware.display.DisplayManagerGlobal
&lt;/code>&lt;/pre>&lt;h5 id="内存中搜索指定类的所有方法-android-hooking-list-class-methods-类名-内存中搜索指定类的所有方法-android-hooking-list-class_methods-类名内存中搜索指定类的所有方法-android-hooking-list-class_methods-类名">&lt;a href="#%e5%86%85%e5%ad%98%e4%b8%ad%e6%90%9c%e7%b4%a2%e6%8c%87%e5%ae%9a%e7%b1%bb%e7%9a%84%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95-android-hooking-list-class-methods-%e7%b1%bb%e5%90%8d" title="内存中搜索指定类的所有方法 android hooking list class_methods 类名">&lt;/a>内存中搜索指定类的所有方法 &lt;code>android hooking list class_methods 类名&lt;/code>&lt;/h5>
&lt;pre tabindex="0">&lt;code>com.android.settings on (google: 8.1.0) [usb] # android hooking list class_methods java.nio.charset.Charset
private static java.nio.charset.Charset java.nio.charset.Charset.lookup(java.lang.String)
private static java.nio.charset.Charset java.nio.charset.Charset.lookup2(java.lang.String)
private static java.nio.charset.Charset java.nio.charset.Charset.lookupViaProviders(java.lang.String)
&lt;/code>&lt;/pre>&lt;h5 id="在内存中所有已加载的类的方法中搜索包含特定关键词的方法-android-hooking-search-methods-display-在内存中所有已加载的类的方法中搜索包含特定关键词的方法-android-hooking-search-methods-display在内存中所有已加载的类的方法中搜索包含特定关键词的方法-android-hooking-search-methods-display">&lt;a href="#%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e6%89%80%e6%9c%89%e5%b7%b2%e5%8a%a0%e8%bd%bd%e7%9a%84%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95%e4%b8%ad%e6%90%9c%e7%b4%a2%e5%8c%85%e5%90%ab%e7%89%b9%e5%ae%9a%e5%85%b3%e9%94%ae%e8%af%8d%e7%9a%84%e6%96%b9%e6%b3%95-android-hooking-search-methods-display" title="在内存中所有已加载的类的方法中搜索包含特定关键词的方法 android hooking search methods display">&lt;/a>在内存中所有已加载的类的方法中搜索包含特定关键词的方法 &lt;code>android hooking search methods display&lt;/code>&lt;/h5>
&lt;p>知道名字开始在内存里搜就很有用&lt;/p>
&lt;pre tabindex="0">&lt;code>com.android.settings on (google: 8.1.0) [usb] # android hooking search methods display
Warning, searching all classes may take some time and in some cases, crash the target application.
Continue? [y/N]: y
Found 5529 classes, searching methods (this may take some time)...
android.app.ActionBar.getDisplayOptions
android.app.ActionBar.setDefaultDisplayHomeAsUpEnabled
android.app.ActionBar.setDisplayHomeAsUpEnabled
&lt;/code>&lt;/pre>&lt;h5 id="hook类的方法hook类里的所有方法-具体某个方法-hook类的方法hook类里的所有方法具体某个方法hook-类的方法hook-类里的所有方法--具体某个方法">&lt;a href="#hook%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%88hook%e7%b1%bb%e9%87%8c%e7%9a%84%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95-%e5%85%b7%e4%bd%93%e6%9f%90%e4%b8%aa%e6%96%b9%e6%b3%95%ef%bc%89" title="hook类的方法（hook类里的所有方法/具体某个方法）">&lt;/a>hook 类的方法（hook 类里的所有方法 / 具体某个方法）&lt;/h5>
&lt;ul>
&lt;li>
&lt;p>&lt;code>android hooking watch class 类名&lt;/code>&lt;br>
这样就可以 hook 这个类里面的所有方法，每次调用都会被 log 出来。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>android hooking watch class 类名 --dump-args --dump-backtrace --dump-return&lt;/code>&lt;br>
在上面的基础上，额外 dump 参数，栈回溯，返回值&lt;/p>
&lt;pre tabindex="0">&lt;code>android hooking watch class xxx.MainActivity --dump-args --dump-backtrace --dump-return
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>android hooking watch class_method 方法名&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>//可以直接hook到所有重载
android hooking watch class_method xxx.MainActivity.fun --dump-args --dump-backtrace --dump-return
&lt;/code>&lt;/pre>&lt;h4 id="grep-trick和文件保存-grep-trick和文件保存grep-trick-和文件保存">&lt;a href="#grep-trick%e5%92%8c%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98" title="grep trick和文件保存">&lt;/a>grep trick 和文件保存&lt;/h4>
&lt;p>objection log 默认是不能用 grep 过滤的，但是可以通过&lt;code>objection run xxx | grep yyy的&lt;/code>方式，从终端通过管道来过滤。
用法如下&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ objection -g com.android.settings run memory list modules | grep libc
Warning: Output is not to a terminal (fd=1).
libcutils.so 0x7a94a1c000 81920 (80.0 KiB) /system/lib64/libcutils.so
libc++.so 0x7a9114e000 983040 (960.0 KiB) /system/lib64/libc++.so
libc.so 0x7a9249d000 892928 (872.0 KiB) /system/lib64/libc.so
libcrypto.so 0x7a92283000 1155072 (1.1 MiB) /system/lib64/libcrypto.so
&lt;/code>&lt;/pre>&lt;p>有的命令后面可以通过&lt;code>--json logfile&lt;/code>来直接保存结果到文件里。
有的可以通过查看&lt;code>.objection&lt;/code>文件里的输出 log 来查看结果。&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/.objection$ cat *log | grep -i display
android.hardware.display.DisplayManager
android.hardware.display.DisplayManager$DisplayListener
android.hardware.display.DisplayManagerGlobal
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h3 id="案例学习-案例学习案例学习">&lt;a href="#%e6%a1%88%e4%be%8b%e5%ad%a6%e4%b9%a0" title="案例学习">&lt;/a>案例学习&lt;/h3>
&lt;h4 id="案例学习case1-仿vx数据库原型取证逆向分析-案例学习case1仿vx数据库原型取证逆向分析案例学习-case1仿-vx-数据库原型取证逆向分析">&lt;a href="#%e6%a1%88%e4%be%8b%e5%ad%a6%e4%b9%a0case1-%e3%80%8a%e4%bb%bfVX%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e5%9e%8b%e5%8f%96%e8%af%81%e9%80%86%e5%90%91%e5%88%86%e6%9e%90%e3%80%8b" title="案例学习case1:《仿VX数据库原型取证逆向分析》">&lt;/a>案例学习 case1:《仿 VX 数据库原型取证逆向分析》&lt;/h4>
&lt;p>&lt;a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;amp;tid=1082706" target="_blank" rel="noopener">附件链接&lt;/a>&lt;br>
&lt;a href="https://github.com/nelenkov/android-backup-extractor" target="_blank" rel="noopener">android-backup-extractor 工具链接&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-100849.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-100849.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn$ java -version
java version &amp;#34;1.8.0_141&amp;#34;
sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn$ java -jar abe-all.jar unpack 1.ab 1.tar
0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% 11% 12% 13% 14% 15% 16% 17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% 34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% 51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% 68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% 85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100%
9097216 bytes written to 1.tar.
...
sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn/apps/com.example.yaphetshan.tencentwelcome$ ls
Encryto.db _manifest a db
&lt;/code>&lt;/pre>&lt;p>装个夜神模拟器玩&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:/Applications/NoxAppPlayer.app/Contents/MacOS$ ./adb connect 127.0.0.1:62001
* daemon not running. starting it now on port 5037 *
adb E 5139 141210 usb_osx.cpp:138] Unable to create an interface plug-in (e00002be)
* daemon started successfully *
connected to 127.0.0.1:62001
sakura@sakuradeMacBook-Pro:/Applications/NoxAppPlayer.app/Contents/MacOS$ ./adb shell
dream2qltechn:/ # whoami
root
dream2qltechn:/ # uname -a
Linux localhost 4.0.9+ #222 SMP PREEMPT Sat Mar 14 18:24:36 HKT 2020 i686
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-120749.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-120749.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121130.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121130.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>肯定还是先定位目标字符串&lt;code>Wait a Minute,What was happend?&lt;/code>&lt;br>
jadx 搜索字符串&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121255.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121255.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121403.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121403.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>重点在 a() 代码里，其实是根据明文的 name 和 password，然后&lt;code>aVar.a(a2 + aVar.b(a2, contentValues.getAsString(&amp;quot;password&amp;quot;))).substring(0, 7)&lt;/code>再做一遍复杂的计算并截取 7 位当做密码，传入 getWritableDatabase 去解密 demo.db 数据库。&lt;/p>
&lt;p>所以我们 hook 一下 getWritableDatabase 即可。&lt;/p>
&lt;pre tabindex="0">&lt;code>frida-ps -U
...
5662 com.example.yaphetshan.tencentwelcome
objection -d -g com.example.yaphetshan.tencentwelcome explore
&lt;/code>&lt;/pre>&lt;p>看一下源码&lt;/p>
&lt;pre tabindex="0">&lt;code>package net.sqlcipher.database;
...
public abstract class SQLiteOpenHelper {
...
public synchronized SQLiteDatabase getWritableDatabase(char[] cArr) {
&lt;/code>&lt;/pre>&lt;p>也可以 objection search 一下这个 method&lt;/p>
&lt;pre tabindex="0">&lt;code>...mple.yaphetshan.tencentwelcome on (samsung: 7.1.2) [usb] # android hooking search methods getWritableDatabase
Warning, searching all classes may take some time and in some cases, crash the target application.
Continue? [y/N]: y
Found 4650 classes, searching methods (this may take some time)...
android.database.sqlite.SQLiteOpenHelper.getWritableDatabase
...
net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase
&lt;/code>&lt;/pre>&lt;p>hook 一下这个 method&lt;/p>
&lt;pre tabindex="0">&lt;code>[usb] # android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase --dump-args --dump-backtrace --dump-return
- [incoming message] ------------------
{
&amp;#34;payload&amp;#34;: &amp;#34;Attempting to watch class \u001b[32mnet.sqlcipher.database.SQLiteOpenHelper\u001b[39m and method \u001b[32mgetWritableDatabase\u001b[39m.&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;send&amp;#34;
}
- [./incoming message] ----------------
(agent) Attempting to watch class net.sqlcipher.database.SQLiteOpenHelper and method getWritableDatabase.
- [incoming message] ------------------
{
&amp;#34;payload&amp;#34;: &amp;#34;Hooking \u001b[32mnet.sqlcipher.database.SQLiteOpenHelper\u001b[39m.\u001b[92mgetWritableDatabase\u001b[39m(\u001b[31mjava.lang.String\u001b[39m)&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;send&amp;#34;
}
- [./incoming message] ----------------
(agent) Hooking net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(java.lang.String)
- [incoming message] ------------------
{
&amp;#34;payload&amp;#34;: &amp;#34;Hooking \u001b[32mnet.sqlcipher.database.SQLiteOpenHelper\u001b[39m.\u001b[92mgetWritableDatabase\u001b[39m(\u001b[31m[C\u001b[39m)&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;send&amp;#34;
}
- [./incoming message] ----------------
(agent) Hooking net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase([C)
- [incoming message] ------------------
{
&amp;#34;payload&amp;#34;: &amp;#34;Registering job \u001b[94mjytq1qeyllq\u001b[39m. Type: \u001b[92mwatch-method for: net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase\u001b[39m&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;send&amp;#34;
}
- [./incoming message] ----------------
(agent) Registering job jytq1qeyllq. Type: watch-method for: net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase
...mple.yaphetshan.tencentwelcome on (samsung: 7.1.2) [usb] #
&lt;/code>&lt;/pre>&lt;p>hook 好之后再打开这个 apk&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125545.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125545.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125604.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125604.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>(agent) [1v488x28gcs] Called net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(java.lang.String)
...
(agent) [1v488x28gcs] Backtrace:
net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(Native Method)
com.example.yaphetshan.tencentwelcome.MainActivity.a(MainActivity.java:55)
com.example.yaphetshan.tencentwelcome.MainActivity.onCreate(MainActivity.java:42)
android.app.Activity.performCreate(Activity.java:6692)
...
(agent) [1v488x28gcs] Arguments net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(ae56f99)
...
...mple.yaphetshan.tencentwelcome on (samsung: 7.1.2) [usb] # jobs list
Job ID Hooks Type
----------- ------- -----------------------------------------------------------------------------
1v488x28gcs 2 watch-method for: net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase
&lt;/code>&lt;/pre>&lt;p>找到参数&lt;code>ae56f99&lt;/code>&lt;br>
剩下的就是用这个密码去打开加密的 db。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125824.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125824.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
然后 base64 解密一下就好了。&lt;/p>
&lt;p>还有一种策略是主动调用, 基于数据流的主动调用分析是非常有意思的。
即自己去调用 a 函数以触发 getWritableDatabase 的数据库解密。
先寻找 a 所在类的实例，然后 hook getWritableDatabase，最终主动调用 a。
这里幸运的是 a 没有什么奇奇怪怪的参数需要我们传入，主动调用这种策略在循环注册等地方可能就会有需求 8.&lt;/p>
&lt;pre tabindex="0">&lt;code>[usb] # android heap search instances com.example.yaphetshan.tencentwelcome.MainActivity
Class instance enumeration complete for com.example.yaphetshan.tencentwelcome.MainActivity
Handle Class toString()
-------- -------------------------------------------------- ----------------------------------------------------------
0x20078a com.example.yaphetshan.tencentwelcome.MainActivity com.example.yaphetshan.tencentwelcome.MainActivity@1528f80
[usb] # android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase --dump-args --dump-backtrace --dump-return
[usb] # android heap execute 0x20078a a
(agent) [taupgwkum4h] Arguments net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(ae56f99)
&lt;/code>&lt;/pre>&lt;h4 id="案例学习case2-主动调用爆破密码-案例学习case2主动调用爆破密码案例学习-case2-主动调用爆破密码">&lt;a href="#%e6%a1%88%e4%be%8b%e5%ad%a6%e4%b9%a0case2-%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e7%88%86%e7%a0%b4%e5%af%86%e7%a0%81" title="案例学习case2:主动调用爆破密码">&lt;/a>案例学习 case2: 主动调用爆破密码&lt;/h4>
&lt;p>&lt;a href="https://bbs.pediy.com/thread-257745.htm" target="_blank" rel="noopener">附件链接&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-132438.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-132438.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>因为直接找&lt;code>Unfortunately,note the right PIN :(&lt;/code>找不到，可能是把字符串藏在什么资源文件里了。
review 代码之后找到校验的核心函数，逻辑就是将 input 编码一下之后和密码比较，这肯定是什么不可逆的加密。&lt;/p>
&lt;pre tabindex="0">&lt;code>public static boolean verifyPassword(Context context, String input) {
if (input.length() != 4) {
return false;
}
byte[] v = encodePassword(input);
byte[] p = &amp;#34;09042ec2c2c08c4cbece042681caf1d13984f24a&amp;#34;.getBytes();
if (v.length != p.length) {
return false;
}
for (int i = 0; i &amp;lt; v.length; i++) {
if (v[i] != p[i]) {
return false;
}
}
return true;
}
&lt;/code>&lt;/pre>&lt;p>这里就爆破一下密码。&lt;/p>
&lt;pre tabindex="0">&lt;code>frida-ps -U | grep qualification
7660 org.teamsik.ahe17.qualification.easy
frida -U org.teamsik.ahe17.qualification.easy -l force.js
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>function main() {
Java.perform(function x() {
console.log(&amp;#34;In Java perform&amp;#34;)
var verify = Java.use(&amp;#34;org.teamsik.ahe17.qualification.Verifier&amp;#34;)
var stringClass = Java.use(&amp;#34;java.lang.String&amp;#34;)
var p = stringClass.$new(&amp;#34;09042ec2c2c08c4cbece042681caf1d13984f24a&amp;#34;)
var pSign = p.getBytes()
// var pStr = stringClass.$new(pSign)
// console.log(parseInt(pStr))
for (var i = 999; i &amp;lt; 10000; i++){
var v = stringClass.$new(String(i))
var vSign = verify.encodePassword(v)
if (parseInt(stringClass.$new(pSign)) == parseInt(stringClass.$new(vSign))) {
console.log(&amp;#34;yes: &amp;#34; + v)
break
}
console.log(&amp;#34;not :&amp;#34; + v)
}
})
}
setImmediate(main)
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>...
not :9080
not :9081
not :9082
yes: 9083
&lt;/code>&lt;/pre>&lt;p>这里注意 parseInt&lt;/p>
&lt;h2 id="frida-hook基础-一-frida-hook基础一frida-hook-基础-一">&lt;a href="#Frida-hook%e5%9f%ba%e7%a1%80-%e4%b8%80" title="Frida hook基础(一)">&lt;/a>Frida hook 基础 (一)&lt;/h2>
&lt;ul>
&lt;li>调用静态函数和调用非静态函数&lt;/li>
&lt;li>设置 (同名) 成员变量&lt;/li>
&lt;li>内部类，枚举类的函数并 hook，trace 原型 1&lt;/li>
&lt;li>查找接口，hook 动态加载 dex&lt;/li>
&lt;li>枚举 class，trace 原型 2&lt;/li>
&lt;li>objection 不能切换 classloader&lt;/li>
&lt;/ul>
&lt;h3 id="frida-hook-打印参数返回值-设置返回值-主动调用-frida-hook--打印参数返回值设置返回值主动调用frida-hook--打印参数返回值--设置返回值--主动调用">&lt;a href="#Frida-hook-%e6%89%93%e5%8d%b0%e5%8f%82%e6%95%b0%e3%80%81%e8%bf%94%e5%9b%9e%e5%80%bc-%e8%ae%be%e7%bd%ae%e8%bf%94%e5%9b%9e%e5%80%bc-%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8" title="Frida hook : 打印参数、返回值/设置返回值/主动调用">&lt;/a>Frida hook : 打印参数、返回值 / 设置返回值 / 主动调用&lt;/h3>
&lt;p>demo 就不贴了，还是先定位登录失败点，然后搜索字符串。&lt;/p>
&lt;pre tabindex="0">&lt;code>public class LoginActivity extends AppCompatActivity {
/* access modifiers changed from: private */
public Context mContext;
public void onCreate(Bundle bundle) {
super.onCreate(bundle);
this.mContext = this;
setContentView((int) R.layout.activity_login);
final EditText editText = (EditText) findViewById(R.id.username);
final EditText editText2 = (EditText) findViewById(R.id.password);
((Button) findViewById(R.id.login)).setOnClickListener(new View.OnClickListener() {
public void onClick(View view) {
String obj = editText.getText().toString();
String obj2 = editText2.getText().toString();
if (TextUtils.isEmpty(obj) || TextUtils.isEmpty(obj2)) {
Toast.makeText(LoginActivity.this.mContext, &amp;#34;username or password is empty.&amp;#34;, 1).show();
} else if (LoginActivity.a(obj, obj).equals(obj2)) {
LoginActivity.this.startActivity(new Intent(LoginActivity.this.mContext, FridaActivity1.class));
LoginActivity.this.finishActivity(0);
} else {
Toast.makeText(LoginActivity.this.mContext, &amp;#34;Login failed.&amp;#34;, 1).show();
}
}
});
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>LoginActivity.a(obj, obj).equals(obj2)&lt;/code>分析之后可得 obj2 来自 password，由从 username 得来的 obj，经过 a 函数运算之后得到一个值，这两个值相等则登录成功。
所以这里关键是 hook a 函数的参数，最简脚本如下。&lt;/p>
&lt;pre tabindex="0">&lt;code>//打印参数、返回值
function Login(){
Java.perform(function(){
Java.use(&amp;#34;com.example.androiddemo.Activity.LoginActivity&amp;#34;).a.overload(&amp;#39;java.lang.String&amp;#39;, &amp;#39;java.lang.String&amp;#39;).implementation = function (str, str2){
var result = this.a(str, str2);
console.log(&amp;#34;args0:&amp;#34;+str+&amp;#34; args1:&amp;#34;+str2+&amp;#34; result:&amp;#34;+result);
return result;
}
})
}
setImmediate(Login)
&lt;/code>&lt;/pre>&lt;p>观察输入和输出, 这里也可以直接主动调用。&lt;/p>
&lt;pre tabindex="0">&lt;code>function login() {
Java.perform(function () {
console.log(&amp;#34;start&amp;#34;)
var login = Java.use(&amp;#34;com.example.androiddemo.Activity.LoginActivity&amp;#34;)
var result = login.a(&amp;#34;1234&amp;#34;,&amp;#34;1234&amp;#34;)
console.log(result)
})
}
setImmediate(login)
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>...
start
4e4feaea959d426155a480dc07ef92f4754ee93edbe56d993d74f131497e66fb
然后
adb shell input text &amp;#34;4e4feaea959d426155a480dc07ef92f4754ee93edbe56d993d74f131497e66fb&amp;#34;
&lt;/code>&lt;/pre>&lt;p>接下来是第一关&lt;/p>
&lt;pre tabindex="0">&lt;code>public abstract class BaseFridaActivity extends AppCompatActivity implements View.OnClickListener {
public Button mNextCheck;
public void CheckSuccess() {
}
public abstract String getNextCheckTitle();
public abstract void onCheck();
/* access modifiers changed from: protected */
public void onCreate(Bundle bundle) {
super.onCreate(bundle);
setContentView((int) R.layout.activity_frida);
this.mNextCheck = (Button) findViewById(R.id.next_check);
this.mNextCheck.setOnClickListener(this);
Button button = this.mNextCheck;
button.setText(getNextCheckTitle() + &amp;#34;，点击进入下一关&amp;#34;);
}
public void onClick(View view) {
onCheck();
}
public void CheckFailed() {
Toast.makeText(this, &amp;#34;Check Failed!&amp;#34;, 1).show();
}
}
...
public class FridaActivity1 extends BaseFridaActivity {
private static final char[] table = {&amp;#39;L&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;N&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;Q&amp;#39;, &amp;#39;P&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;F&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;p&amp;#39;, &amp;#39;q&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;v&amp;#39;, &amp;#39;w&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;g&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;j&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;k&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39;, &amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;+&amp;#39;, &amp;#39;/&amp;#39;};
public String getNextCheckTitle() {
return &amp;#34;当前第1关&amp;#34;;
}
public void onCheck() {
try {
if (a(b(&amp;#34;请输入密码:&amp;#34;)).equals(&amp;#34;R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&amp;#34;)) {
CheckSuccess();
startActivity(new Intent(this, FridaActivity2.class));
finishActivity(0);
return;
}
super.CheckFailed();
} catch (Exception e) {
e.printStackTrace();
}
}
public static String a(byte[] bArr) throws Exception {
StringBuilder sb = new StringBuilder();
for (int i = 0; i &amp;lt;= bArr.length - 1; i += 3) {
byte[] bArr2 = new byte[4];
byte b = 0;
for (int i2 = 0; i2 &amp;lt;= 2; i2++) {
int i3 = i + i2;
if (i3 &amp;lt;= bArr.length - 1) {
bArr2[i2] = (byte) (b | ((bArr[i3] &amp;amp; 255) &amp;gt;&amp;gt;&amp;gt; ((i2 * 2) + 2)));
b = (byte) ((((bArr[i3] &amp;amp; 255) &amp;lt;&amp;lt; (((2 - i2) * 2) + 2)) &amp;amp; 255) &amp;gt;&amp;gt;&amp;gt; 2);
} else {
bArr2[i2] = b;
b = 64;
}
}
bArr2[3] = b;
for (int i4 = 0; i4 &amp;lt;= 3; i4++) {
if (bArr2[i4] &amp;lt;= 63) {
sb.append(table[bArr2[i4]]);
} else {
sb.append(&amp;#39;=&amp;#39;);
}
}
}
return sb.toString();
}
public static byte[] b(String str) {
try {
ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
GZIPOutputStream gZIPOutputStream = new GZIPOutputStream(byteArrayOutputStream);
gZIPOutputStream.write(str.getBytes());
gZIPOutputStream.finish();
gZIPOutputStream.close();
byte[] byteArray = byteArrayOutputStream.toByteArray();
try {
byteArrayOutputStream.close();
return byteArray;
} catch (Exception e) {
e.printStackTrace();
return byteArray;
}
} catch (Exception unused) {
return null;
}
}
}
&lt;/code>&lt;/pre>&lt;p>关键函数在&lt;code>a(b(&amp;quot;请输入密码:&amp;quot;)).equals(&amp;quot;R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&amp;quot;)&lt;/code>&lt;br>
这里应该直接 hook a，让其返回值为&lt;code>R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&lt;/code>就可以进入下一关了。&lt;/p>
&lt;pre tabindex="0">&lt;code>function ch1() {
Java.perform(function () {
console.log(&amp;#34;start&amp;#34;)
Java.use(&amp;#34;com.example.androiddemo.Activity.FridaActivity1&amp;#34;).a.implementation = function (x) {
return &amp;#34;R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&amp;#34;
}
})
}
&lt;/code>&lt;/pre>&lt;h3 id="frida-hook-主动调用静态-非静态函数-以及-设置静态-非静态成员变量的值-frida-hook--主动调用静态非静态函数-以及-设置静态非静态成员变量的值frida-hook--主动调用静态--非静态函数-以及-设置静态--非静态成员变量的值">&lt;a href="#Frida-hook-%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e9%9d%99%e6%80%81-%e9%9d%9e%e9%9d%99%e6%80%81%e5%87%bd%e6%95%b0-%e4%bb%a5%e5%8f%8a-%e8%ae%be%e7%bd%ae%e9%9d%99%e6%80%81-%e9%9d%9e%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc" title="Frida hook : 主动调用静态/非静态函数 以及 设置静态/非静态成员变量的值">&lt;/a>Frida hook : 主动调用静态 / 非静态函数 以及 设置静态 / 非静态成员变量的值&lt;/h3>
&lt;p>总结:&lt;/p>
&lt;ul>
&lt;li>静态函数直接 use class 然后调用方法，非静态函数需要先 choose 实例然后调用&lt;/li>
&lt;li>设置成员变量的值，写法是&lt;code>xx.value = yy&lt;/code>，其他方面和函数一样。&lt;/li>
&lt;li>如果有一个成员变量和成员函数的名字相同，则在其前面加一个&lt;code>_&lt;/code>，如&lt;code>_xx.value = yy&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>然后是第二关&lt;/p>
&lt;pre tabindex="0">&lt;code>public class FridaActivity2 extends BaseFridaActivity {
private static boolean static_bool_var = false;
private boolean bool_var = false;
public String getNextCheckTitle() {
return &amp;#34;当前第2关&amp;#34;;
}
private static void setStatic_bool_var() {
static_bool_var = true;
}
private void setBool_var() {
this.bool_var = true;
}
public void onCheck() {
if (!static_bool_var || !this.bool_var) {
super.CheckFailed();
return;
}
CheckSuccess();
startActivity(new Intent(this, FridaActivity3.class));
finishActivity(0);
}
}
&lt;/code>&lt;/pre>&lt;p>这一关的关键在于下面的 if 判断要为 false，则&lt;code>static_bool_var&lt;/code>和&lt;code>this.bool_var&lt;/code>都要为 true。&lt;/p>
&lt;pre tabindex="0">&lt;code>if (!static_bool_var || !this.bool_var) {
super.CheckFailed();
return;
}
&lt;/code>&lt;/pre>&lt;p>这样就要调用&lt;code>setBool_var&lt;/code>和&lt;code>setStatic_bool_var&lt;/code>两个函数了。&lt;/p>
&lt;pre tabindex="0">&lt;code>function ch2() {
Java.perform(function () {
console.log(&amp;#34;start&amp;#34;)
var FridaActivity2 = Java.use(&amp;#34;com.example.androiddemo.Activity.FridaActivity2&amp;#34;)
//hook静态函数直接调用
FridaActivity2.setStatic_bool_var()
//hook动态函数，找到instance实例，从实例调用函数方法
Java.choose(&amp;#34;com.example.androiddemo.Activity.FridaActivity2&amp;#34;, {
onMatch: function (instance) {
instance.setBool_var()
},
onComplete: function () {
console.log(&amp;#34;end&amp;#34;)
}
})
})
}
setImmediate(ch2)
&lt;/code>&lt;/pre>&lt;p>接下来是第三关&lt;/p>
&lt;pre tabindex="0">&lt;code>public class FridaActivity3 extends BaseFridaActivity {
private static boolean static_bool_var = false;
private boolean bool_var = false;
private boolean same_name_bool_var = false;
public String getNextCheckTitle() {
return &amp;#34;当前第3关&amp;#34;;
}
private void same_name_bool_var() {
Log.d(&amp;#34;Frida&amp;#34;, static_bool_var + &amp;#34; &amp;#34; + this.bool_var + &amp;#34; &amp;#34; + this.same_name_bool_var);
}
public void onCheck() {
if (!static_bool_var || !this.bool_var || !this.same_name_bool_var) {
super.CheckFailed();
return;
}
CheckSuccess();
startActivity(new Intent(this, FridaActivity4.class));
finishActivity(0);
}
}
&lt;/code>&lt;/pre>&lt;p>关键还是让&lt;code>if (!static_bool_var || !this.bool_var || !this.same_name_bool_var)&lt;/code>为 false，则三个变量都要为 true&lt;/p>
&lt;pre tabindex="0">&lt;code>function ch3() {
Java.perform(function () {
console.log(&amp;#34;start&amp;#34;)
var FridaActivity3 = Java.use(&amp;#34;com.example.androiddemo.Activity.FridaActivity3&amp;#34;)
FridaActivity3.static_bool_var.value = true
Java.choose(&amp;#34;com.example.androiddemo.Activity.FridaActivity3&amp;#34;, {
onMatch: function (instance) {
instance.bool_var.value = true
instance._same_name_bool_var.value = true
},
onComplete: function () {
console.log(&amp;#34;end&amp;#34;)
}
})
})
}
&lt;/code>&lt;/pre>&lt;p>这里要注意类里有一个成员函数和成员变量都叫做&lt;code>same_name_bool_var&lt;/code>，这种时候在成员变量前加一个&lt;code>_&lt;/code>，修改值的形式为&lt;code>xx.value = yy&lt;/code>&lt;/p>
&lt;h3 id="frida-hook-内部类枚举类的函数并hooktrace原型1-frida-hook--内部类枚举类的函数并hooktrace原型1frida-hook--内部类枚举类的函数并-hooktrace-原型-1">&lt;a href="#Frida-hook-%e5%86%85%e9%83%a8%e7%b1%bb%ef%bc%8c%e6%9e%9a%e4%b8%be%e7%b1%bb%e7%9a%84%e5%87%bd%e6%95%b0%e5%b9%b6hook%ef%bc%8ctrace%e5%8e%9f%e5%9e%8b1" title="Frida hook : 内部类，枚举类的函数并hook，trace原型1">&lt;/a>Frida hook : 内部类，枚举类的函数并 hook，trace 原型 1&lt;/h3>
&lt;p>总结:&lt;/p>
&lt;ul>
&lt;li>对于内部类，通过&lt;code>类名$内部类名&lt;/code>去 use 或者 choose&lt;/li>
&lt;li>对 use 得到的 clazz 应用反射，如&lt;code>clazz.class.getDeclaredMethods()&lt;/code>可以得到类里面声明的所有方法，即可以枚举类里面的所有函数。&lt;/li>
&lt;/ul>
&lt;p>接下来是第四关&lt;/p>
&lt;pre tabindex="0">&lt;code>public class FridaActivity4 extends BaseFridaActivity {
public String getNextCheckTitle() {
return &amp;#34;当前第4关&amp;#34;;
}
private static class InnerClasses {
public static boolean check1() {
return false;
}
public static boolean check2() {
return false;
}
public static boolean check3() {
return false;
}
public static boolean check4() {
return false;
}
public static boolean check5() {
return false;
}
public static boolean check6() {
return false;
}
private InnerClasses() {
}
}
public void onCheck() {
if (!InnerClasses.check1() || !InnerClasses.check2() || !InnerClasses.check3() || !InnerClasses.check4() || !InnerClasses.check5() || !InnerClasses.check6()) {
super.CheckFailed();
return;
}
CheckSuccess();
startActivity(new Intent(this, FridaActivity5.class));
finishActivity(0);
}
}
&lt;/code>&lt;/pre>&lt;p>这一关的关键是让&lt;code>if (!InnerClasses.check1() || !InnerClasses.check2() || !InnerClasses.check3() || !InnerClasses.check4() || !InnerClasses.check5() || !InnerClasses.check6())&lt;/code>中的所有 check 全部返回 true。&lt;/p>
&lt;p>其实这里唯一的问题就是寻找内部类&lt;code>InnerClasses&lt;/code>，对于内部类的 hook，通过&lt;code>类名$内部类名&lt;/code>去 use。&lt;/p>
&lt;pre tabindex="0">&lt;code>function ch4() {
Java.perform(function () {
var InnerClasses = Java.use(&amp;#34;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&amp;#34;)
console.log(&amp;#34;start&amp;#34;)
InnerClasses.check1.implementation = function () {
return true
}
InnerClasses.check2.implementation = function () {
return true
}
InnerClasses.check3.implementation = function () {
return true
}
InnerClasses.check4.implementation = function () {
return true
}
InnerClasses.check5.implementation = function () {
return true
}
InnerClasses.check6.implementation = function () {
return true
}
})
}
&lt;/code>&lt;/pre>&lt;p>利用反射，获取类中的所有 method 声明，然后字符串拼接去获取到方法名，例如下面的 check1，然后就可以批量 hook，而不用像我上面那样一个一个写。&lt;/p>
&lt;pre tabindex="0">&lt;code>var inner_classes = Java.use(&amp;#34;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&amp;#34;)
var all_methods = inner_classes.class.getDeclaredMethods();
...
public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check1(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check2(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check3(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check4(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check5(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check6()
&lt;/code>&lt;/pre>&lt;h3 id="frida-hook-hook动态加载的dex与查找interface-frida-hook--hook动态加载的dex与查找interfacefrida-hook--hook-动态加载的-dex与查找-interface">&lt;a href="#Frida-hook-hook%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd%e7%9a%84dex%ef%bc%8c%e4%b8%8e%e6%9f%a5%e6%89%beinterface%ef%bc%8c" title="Frida hook : hook动态加载的dex，与查找interface，">&lt;/a>Frida hook : hook 动态加载的 dex，与查找 interface，&lt;/h3>
&lt;p>总结:&lt;/p>
&lt;ul>
&lt;li>通过&lt;code>enumerateClassLoaders&lt;/code>来枚举加载进内存的 classloader，再&lt;code>loader.findClass(xxx)&lt;/code>寻找是否包括我们想要的 interface 的实现类，最后通过&lt;code>Java.classFactory.loader = loader&lt;/code>来切换 classloader，从而加载该实现类。&lt;/li>
&lt;/ul>
&lt;p>第五关比较有趣，它的 check 函数是动态加载进来的。
java 里有 interface 的概念，是指一系列抽象的接口，需要类来实现。&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.example.androiddemo.Dynamic;
public interface CheckInterface {
boolean check();
}
...
public class DynamicCheck implements CheckInterface {
public boolean check() {
return false;
}
}
...
public class FridaActivity5 extends BaseFridaActivity {
private CheckInterface DynamicDexCheck = null;
...
public CheckInterface getDynamicDexCheck() {
if (this.DynamicDexCheck == null) {
loaddex();
}
return this.DynamicDexCheck;
}
/* access modifiers changed from: protected */
public void onCreate(Bundle bundle) {
super.onCreate(bundle);
loaddex();
//this.DynamicDexCheck = (CheckInterface) new DexClassLoader(str, filesDir.getAbsolutePath(), (String) null, getClassLoader()).loadClass(&amp;#34;com.example.androiddemo.Dynamic.DynamicCheck&amp;#34;).newInstance();
}
public void onCheck() {
if (getDynamicDexCheck() == null) {
Toast.makeText(this, &amp;#34;onClick loaddex Failed!&amp;#34;, 1).show();
} else if (getDynamicDexCheck().check()) {
CheckSuccess();
startActivity(new Intent(this, FridaActivity6.class));
finishActivity(0);
} else {
super.CheckFailed();
}
}
}
&lt;/code>&lt;/pre>&lt;p>这里有个 loaddex 其实就是先从资源文件加载 classloader 到内存里，再 loadClass DynamicCheck，创建出一个实例，最终调用这个实例的 check。
所以现在我们就要先枚举 class loader，找到能实例化我们要的 class 的那个 class loader，然后把它设置成 Java 的默认 class factory 的 loader。
现在就可以用这个 class loader 来使用&lt;code>.use&lt;/code>去 import 一个给定的类。&lt;/p>
&lt;pre tabindex="0">&lt;code>function ch5() {
Java.perform(function () {
// Java.choose(&amp;#34;com.example.androiddemo.Activity.FridaActivity5&amp;#34;,{
// onMatch:function(x){
// console.log(x.getDynamicDexCheck().$className)
// },onComplete:function(){}
// })
console.log(&amp;#34;start&amp;#34;)
Java.enumerateClassLoaders({
onMatch: function (loader) {
try {
if(loader.findClass(&amp;#34;com.example.androiddemo.Dynamic.DynamicCheck&amp;#34;)){
console.log(&amp;#34;Successfully found loader&amp;#34;)
console.log(loader);
Java.classFactory.loader = loader ;
}
}
catch(error){
console.log(&amp;#34;find error:&amp;#34; + error)
}
},
onComplete: function () {
console.log(&amp;#34;end1&amp;#34;)
}
})
Java.use(&amp;#34;com.example.androiddemo.Dynamic.DynamicCheck&amp;#34;).check.implementation = function () {
return true
}
console.log(&amp;#34;end2&amp;#34;)
})
}
setImmediate(ch5)
&lt;/code>&lt;/pre>&lt;p>todo 有一个疑问&lt;br>
&lt;a href="https://github.com/frida/frida/issues/1049" target="_blank" rel="noopener">https://github.com/frida/frida/issues/1049&lt;/a>&lt;/p>
&lt;h3 id="frida-hook-枚举classtrace原型2-frida-hook--枚举classtrace原型2frida-hook--枚举-classtrace-原型-2">&lt;a href="#Frida-hook-%e6%9e%9a%e4%b8%beclass%ef%bc%8ctrace%e5%8e%9f%e5%9e%8b2" title="Frida hook : 枚举class，trace原型2">&lt;/a>Frida hook : 枚举 class，trace 原型 2&lt;/h3>
&lt;p>总结: 通过&lt;code>Java.enumerateLoadedClasses&lt;/code>来枚举类，然后&lt;code>name.indexOf(str)&lt;/code>过滤一下并 hook。&lt;/p>
&lt;p>接下来是第六关&lt;/p>
&lt;pre tabindex="0">&lt;code>import com.example.androiddemo.Activity.Frida6.Frida6Class0;
import com.example.androiddemo.Activity.Frida6.Frida6Class1;
import com.example.androiddemo.Activity.Frida6.Frida6Class2;
public class FridaActivity6 extends BaseFridaActivity {
public String getNextCheckTitle() {
return &amp;#34;当前第6关&amp;#34;;
}
public void onCheck() {
if (!Frida6Class0.check() || !Frida6Class1.check() || !Frida6Class2.check()) {
super.CheckFailed();
return;
}
CheckSuccess();
startActivity(new Intent(this, FridaActivity7.class));
finishActivity(0);
}
}
&lt;/code>&lt;/pre>&lt;p>这关是 import 了一些类，然后调用类里的静态方法，所以我们枚举所有的类，然后过滤一下，并把过滤出来的结果 hook 上，改掉其返回值。&lt;/p>
&lt;pre tabindex="0">&lt;code>function ch6() {
Java.perform(function () {
Java.enumerateLoadedClasses({
onMatch: function (name, handle){
if (name.indexOf(&amp;#34;com.example.androiddemo.Activity.Frida6&amp;#34;) != -1) {
console.log(&amp;#34;name:&amp;#34; + name + &amp;#34; handle:&amp;#34; + handle)
Java.use(name).check.implementation = function () {
return true
}
}
},
onComplete: function () {
console.log(&amp;#34;end&amp;#34;)
}
})
})
}
&lt;/code>&lt;/pre>&lt;h3 id="frida-hook-搜索interface的具体实现类-frida-hook--搜索interface的具体实现类frida-hook--搜索-interface-的具体实现类">&lt;a href="#Frida-hook-%e6%90%9c%e7%b4%a2interface%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e7%b1%bb" title="Frida hook : 搜索interface的具体实现类">&lt;/a>Frida hook : 搜索 interface 的具体实现类&lt;/h3>
&lt;p>利用反射得到类里面实现的 interface 数组，并打印出来。&lt;/p>
&lt;pre tabindex="0">&lt;code>function more() {
Java.perform(function () {
Java.enumerateLoadedClasses({
onMatch: function (class_name){
if (class_name.indexOf(&amp;#34;com.example.androiddemo&amp;#34;) &amp;lt; 0) {
return
}
else {
var hook_cls = Java.use(class_name)
var interfaces = hook_cls.class.getInterfaces()
if (interfaces.length &amp;gt; 0) {
console.log(class_name + &amp;#34;: &amp;#34;)
for (var i in interfaces) {
console.log(&amp;#34;\t&amp;#34;, interfaces[i].toString())
}
}
}
},
onComplete: function () {
console.log(&amp;#34;end&amp;#34;)
}
})
})
}
&lt;/code>&lt;/pre>&lt;h2 id="frida-hook基础二-frida-hook基础二frida-hook-基础二">&lt;a href="#Frida-hook%e5%9f%ba%e7%a1%80%ef%bc%88%e4%ba%8c" title="Frida hook基础（二)">&lt;/a>Frida hook 基础（二)&lt;/h2>
&lt;ul>
&lt;li>spawn/attach&lt;/li>
&lt;li>各种主动调用&lt;/li>
&lt;li>hook 函数和 hook 构造函数&lt;/li>
&lt;li>调用栈 / 简单脚本&lt;/li>
&lt;li>动态加载自己的 dex&lt;/li>
&lt;/ul>
&lt;p>题目下载地址:&lt;br>
&lt;a href="https://github.com/tlamb96/kgb_messenger" target="_blank" rel="noopener">https://github.com/tlamb96/kgb_messenger&lt;/a>&lt;/p>
&lt;h3 id="spawn-attach-spawnattachspawnattach">&lt;a href="#spawn-attach" title="spawn/attach">&lt;/a>spawn/attach&lt;/h3>
&lt;p>firda 的 - f 参数代表 span 启动&lt;br>
&lt;code>frida -U -f com.tlamb96.spetsnazmessenger -l frida_russian.js --no-pause&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>/* access modifiers changed from: protected */
public void onCreate(Bundle bundle) {
super.onCreate(bundle);
setContentView((int) R.layout.activity_main);
String property = System.getProperty(&amp;#34;user.home&amp;#34;);
String str = System.getenv(&amp;#34;USER&amp;#34;);
if (property == null || property.isEmpty() || !property.equals(&amp;#34;Russia&amp;#34;)) {
a(&amp;#34;Integrity Error&amp;#34;, &amp;#34;This app can only run on Russian devices.&amp;#34;);
} else if (str == null || str.isEmpty() || !str.equals(getResources().getString(R.string.User))) {
a(&amp;#34;Integrity Error&amp;#34;, &amp;#34;Must be on the user whitelist.&amp;#34;);
} else {
a.a(this);
startActivity(new Intent(this, LoginActivity.class));
}
}
}
&lt;/code>&lt;/pre>&lt;p>这个题目比较简单，但是因为这个 check 是在&lt;code>onCreate&lt;/code>里，所以 app 刚启动就自动检查，所以这里需要用 spawn 的方式去启动 frida 脚本 hook，而不是 attach。
这里有两个检查，一个是检查 property 的值，一个是检查 str 的值。
分别从&lt;code>System.getProperty&lt;/code>和&lt;code>System.getenv&lt;/code>里获取，hook 住这两个函数就行。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092212.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092212.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
这里要注意从资源文件里找到&lt;code>User&lt;/code>的值。&lt;/p>
&lt;pre tabindex="0">&lt;code>function main() {
Java.perform(function () {
Java.use(&amp;#34;java.lang.System&amp;#34;).getProperty.overload(&amp;#39;java.lang.String&amp;#39;).implementation = function (str) {
return &amp;#34;Russia&amp;#34;;
}
Java.use(&amp;#34;java.lang.System&amp;#34;).getenv.overload(&amp;#39;java.lang.String&amp;#39;).implementation = function(str){
return &amp;#34;RkxBR3s1N0VSTDFOR180UkNIM1J9Cg==&amp;#34;;
}
})
}
setImmediate(main)
&lt;/code>&lt;/pre>&lt;p>接下来进入到 login 功能&lt;/p>
&lt;pre tabindex="0">&lt;code>public void onLogin(View view) {
EditText editText = (EditText) findViewById(R.id.login_username);
EditText editText2 = (EditText) findViewById(R.id.login_password);
this.n = editText.getText().toString();
this.o = editText2.getText().toString();
if (this.n != null &amp;amp;&amp;amp; this.o != null &amp;amp;&amp;amp; !this.n.isEmpty() &amp;amp;&amp;amp; !this.o.isEmpty()) {
if (!this.n.equals(getResources().getString(R.string.username))) {
Toast.makeText(this, &amp;#34;User not recognized.&amp;#34;, 0).show();
editText.setText(&amp;#34;&amp;#34;);
editText2.setText(&amp;#34;&amp;#34;);
} else if (!j()) {
Toast.makeText(this, &amp;#34;Incorrect password.&amp;#34;, 0).show();
editText.setText(&amp;#34;&amp;#34;);
editText2.setText(&amp;#34;&amp;#34;);
} else {
i();
startActivity(new Intent(this, MessengerActivity.class));
}
}
}
...
private boolean j() {
String str = &amp;#34;&amp;#34;;
for (byte b : this.m.digest(this.o.getBytes())) {
str = str + String.format(&amp;#34;%x&amp;#34;, new Object[]{Byte.valueOf(b)});
}
return str.equals(getResources().getString(R.string.password));
}
...
private void i() {
char[] cArr = {&amp;#39;(&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;)&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;P&amp;#39;, &amp;#39;:&amp;#39;, &amp;#39;#&amp;#39;, &amp;#39;?&amp;#39;, &amp;#39;T&amp;#39;};
cArr[0] = (char) (cArr[0] ^ this.n.charAt(1));
cArr[1] = (char) (cArr[1] ^ this.o.charAt(0));
cArr[2] = (char) (cArr[2] ^ this.o.charAt(4));
cArr[3] = (char) (cArr[3] ^ this.n.charAt(4));
cArr[4] = (char) (cArr[4] ^ this.n.charAt(7));
cArr[5] = (char) (cArr[5] ^ this.n.charAt(0));
cArr[6] = (char) (cArr[6] ^ this.o.charAt(2));
cArr[7] = (char) (cArr[7] ^ this.o.charAt(3));
cArr[8] = (char) (cArr[8] ^ this.n.charAt(6));
cArr[9] = (char) (cArr[9] ^ this.n.charAt(8));
Toast.makeText(this, &amp;#34;FLAG{&amp;#34; + new String(cArr) + &amp;#34;}&amp;#34;, 1).show();
}
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092522.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092522.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
从资源文件里找到 username, 密码则是要算一个 j() 函数，要让它返回 true，顺便打印一下 i 函数 toast 到界面的 flag。&lt;/p>
&lt;pre tabindex="0">&lt;code>Java.use(&amp;#34;com.tlamb96.kgbmessenger.LoginActivity&amp;#34;).j.implementation = function () {
return true
}
...
Java.use(&amp;#34;android.widget.Toast&amp;#34;).makeText.overload(&amp;#39;android.content.Context&amp;#39;, &amp;#39;java.lang.CharSequence&amp;#39;, &amp;#39;int&amp;#39;).implementation = function (x, y, z) {
var flag = Java.use(&amp;#34;java.lang.String&amp;#34;).$new(y)
console.log(flag)
}
...
[Google Pixel::com.tlamb96.spetsnazmessenger]-&amp;gt; FLAG{G&amp;amp;qG13 R0}
&lt;/code>&lt;/pre>&lt;h3 id="frida-hook-hook构造函数-打印栈回溯-frida-hook-hook构造函数打印栈回溯frida-hook-hook-构造函数--打印栈回溯">&lt;a href="#Frida-hook-hook%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0-%e6%89%93%e5%8d%b0%e6%a0%88%e5%9b%9e%e6%ba%af" title="Frida hook :hook构造函数/打印栈回溯">&lt;/a>Frida hook :hook 构造函数 / 打印栈回溯&lt;/h3>
&lt;p>总结:&lt;br>
hook 构造函数实现通过 use 取得类，然后&lt;code>clazz.$init.implementation = callback&lt;/code> hook 构造函数。&lt;/p>
&lt;p>我们先学习一下怎么 hook 构造函数。&lt;/p>
&lt;pre tabindex="0">&lt;code>add(new com.tlamb96.kgbmessenger.b.a(R.string.katya, &amp;#34;Archer, you up?&amp;#34;, &amp;#34;2:20 am&amp;#34;, true));
...
package com.tlamb96.kgbmessenger.b;
public class a {
...
public a(int i, String str, String str2, boolean z) {
this.f448a = i;
this.b = str;
this.c = str2;
this.d = z;
}
...
}
&lt;/code>&lt;/pre>&lt;p>用&lt;code>$init&lt;/code>来 hook 构造函数&lt;/p>
&lt;pre tabindex="0">&lt;code>Java.use(&amp;#34;com.tlamb96.kgbmessenger.b.a&amp;#34;).$init.implementation = function (i, str1, str2, z) {
this.$init(i, str1, str2, z)
console.log(i, str1, str2, z)
printStack(&amp;#34;com.tlamb96.kgbmessenger.b.a&amp;#34;)
}
&lt;/code>&lt;/pre>&lt;h3 id="frida-hook-打印栈回溯-frida-hook--打印栈回溯frida-hook--打印栈回溯">&lt;a href="#Frida-hook-%e6%89%93%e5%8d%b0%e6%a0%88%e5%9b%9e%e6%ba%af" title="Frida hook : 打印栈回溯">&lt;/a>Frida hook : 打印栈回溯&lt;/h3>
&lt;p>打印栈回溯&lt;/p>
&lt;pre tabindex="0">&lt;code>function printStack(name) {
Java.perform(function () {
var Exception = Java.use(&amp;#34;java.lang.Exception&amp;#34;);
var ins = Exception.$new(&amp;#34;Exception&amp;#34;);
var straces = ins.getStackTrace();
if (straces != undefined &amp;amp;&amp;amp; straces != null) {
var strace = straces.toString();
var replaceStr = strace.replace(/,/g, &amp;#34;\\n&amp;#34;);
console.log(&amp;#34;=============================&amp;#34; + name + &amp;#34; Stack strat=======================&amp;#34;);
console.log(replaceStr);
console.log(&amp;#34;=============================&amp;#34; + name + &amp;#34; Stack end=======================\r\n&amp;#34;);
Exception.$dispose();
}
});
}
&lt;/code>&lt;/pre>&lt;p>输出就是这样&lt;/p>
&lt;pre tabindex="0">&lt;code>[Google Pixel::com.tlamb96.spetsnazmessenger]-&amp;gt; 2131558449 111 02:27 下午 false
=============================com.tlamb96.kgbmessenger.b.a Stack strat=======================
com.tlamb96.kgbmessenger.b.a.&amp;lt;init&amp;gt;(Native Method)
com.tlamb96.kgbmessenger.MessengerActivity.onSendMessage(Unknown Source:40)
java.lang.reflect.Method.invoke(Native Method)
android.support.v7.app.m$a.onClick(Unknown Source:25)
android.view.View.performClick(View.java:6294)
android.view.View$PerformClick.run(View.java:24770)
android.os.Handler.handleCallback(Handler.java:790)
android.os.Handler.dispatchMessage(Handler.java:99)
android.os.Looper.loop(Looper.java:164)
android.app.ActivityThread.main(ActivityThread.java:6494)
java.lang.reflect.Method.invoke(Native Method)
com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)
=============================com.tlamb96.kgbmessenger.b.a Stack end=======================
&lt;/code>&lt;/pre>&lt;h3 id="frida-hook-手动加载dex并调用-frida-hook--手动加载dex并调用frida-hook--手动加载-dex-并调用">&lt;a href="#Frida-hook-%e6%89%8b%e5%8a%a8%e5%8a%a0%e8%bd%bddex%e5%b9%b6%e8%b0%83%e7%94%a8" title="Frida hook : 手动加载dex并调用">&lt;/a>Frida hook : 手动加载 dex 并调用&lt;/h3>
&lt;p>总结：&lt;br>
编译出 dex 之后，通过&lt;code>Java.openClassFile(&amp;quot;xxx.dex&amp;quot;).load()&lt;/code>加载，这样我们就可以正常通过&lt;code>Java.use&lt;/code>调用里面的方法了。&lt;/p>
&lt;p>现在我们来继续解决这个问题。&lt;/p>
&lt;pre tabindex="0">&lt;code>public void onSendMessage(View view) {
EditText editText = (EditText) findViewById(R.id.edittext_chatbox);
String obj = editText.getText().toString();
if (!TextUtils.isEmpty(obj)) {
this.o.add(new com.tlamb96.kgbmessenger.b.a(R.string.user, obj, j(), false));
this.n.c();
if (a(obj.toString()).equals(this.p)) {
Log.d(&amp;#34;MessengerActivity&amp;#34;, &amp;#34;Successfully asked Boris for the password.&amp;#34;);
this.q = obj.toString();
this.o.add(new com.tlamb96.kgbmessenger.b.a(R.string.boris, &amp;#34;Only if you ask nicely&amp;#34;, j(), true));
this.n.c();
}
if (b(obj.toString()).equals(this.r)) {
Log.d(&amp;#34;MessengerActivity&amp;#34;, &amp;#34;Successfully asked Boris nicely for the password.&amp;#34;);
this.s = obj.toString();
this.o.add(new com.tlamb96.kgbmessenger.b.a(R.string.boris, &amp;#34;Wow, no one has ever been so nice to me! Here you go friend: FLAG{&amp;#34; + i() + &amp;#34;}&amp;#34;, j(), true));
this.n.c();
}
this.m.b(this.m.getAdapter().a() - 1);
editText.setText(&amp;#34;&amp;#34;);
}
}
&lt;/code>&lt;/pre>&lt;p>新的一关是一个聊天框，分析一下代码可知，obj 是我们输入的内容，输入完了之后，加到一个&lt;code>this.o&lt;/code>的 ArrayList 里。
关键的 if 判断就是&lt;code>if (a(obj.toString()).equals(this.p))&lt;/code>和&lt;code>if (b(obj.toString()).equals(this.r))&lt;/code>，所有 hook a 和 b 函数，让它们的返回值等于下面的字符串即可。&lt;/p>
&lt;pre tabindex="0">&lt;code>private String p = &amp;#34;V@]EAASB\u0012WZF\u0012e,a$7(&amp;amp;am2(3.\u0003&amp;#34;;
private String q;
private String r = &amp;#34;\u0000dslp}oQ\u0000 dks$|M\u0000h +AYQg\u0000P*!M$gQ\u0000&amp;#34;;
private String s;
&lt;/code>&lt;/pre>&lt;p>但实际上这题比我想象中的还要麻烦，这题的逻辑上是如果通过了 a 和 b 这两个函数的计算，等于对应的值之后，会把用来计算的 obj 的值赋值给 q 和 s，然后根据这个 q 和 s 来计算出最终的 flag。
所以如果不逆向算法，通过 hook 的方式通过了 a 和 b 的计算，obj 的值还是错误的，也计算不出正确的 flag。&lt;/p>
&lt;p>这样就逆向一下算法好了，先自己写一个 apk，用 java 去实现注册机。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004653.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004653.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004915.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004915.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
可以直接把 class 文件转成 dex，不复述，我比较懒，所以我直接解压 apk 找到&lt;code>classes.dex&lt;/code>，并 push 到手机上。
然后用 frida 加载这个 dex，并调用里面的方法。&lt;/p>
&lt;pre tabindex="0">&lt;code>var dex = Java.openClassFile(&amp;#34;/data/local/tmp/classes.dex&amp;#34;).load();
console.log(&amp;#34;decode_P:&amp;#34;+Java.use(&amp;#34;myapplication.example.com.reversea.reverseA&amp;#34;).decode_P());
console.log(&amp;#34;r_to_hex:&amp;#34;+Java.use(&amp;#34;myapplication.example.com.reversea.reverseA&amp;#34;).r_to_hex());
...
...
decode_P:Boris, give me the password
r_to_hex:0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100
&lt;/code>&lt;/pre>&lt;h2 id="frida打印与参数构造-frida打印与参数构造frida-打印与参数构造">&lt;a href="#Frida%e6%89%93%e5%8d%b0%e4%b8%8e%e5%8f%82%e6%95%b0%e6%9e%84%e9%80%a0" title="Frida打印与参数构造">&lt;/a>Frida 打印与参数构造&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>数组 /(字符串) 对象数组 / gson/Java.array&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对象 / 多态、强转 Java.cast / 接口 Java.register&lt;/p>
&lt;/li>
&lt;li>
&lt;p>泛型、List、Map、Set、迭代打印&lt;/p>
&lt;/li>
&lt;li>
&lt;p>non-ascii 、 child-gating、rpc 上传到 PC 上打印&lt;/p>
&lt;h3 id="char-object-object-charobject-objectcharobject-object">&lt;a href="#char-Object-Object" title="char[]/[Object Object]">&lt;/a>char[]/[Object Object]&lt;/h3>
&lt;pre tabindex="0">&lt;code>Log.d(&amp;#34;SimpleArray&amp;#34;, &amp;#34;onCreate: SImpleArray&amp;#34;);
char arr[][] = new char[4][]; // 创建一个4行的二维数组
arr[0] = new char[] { &amp;#39;春&amp;#39;, &amp;#39;眠&amp;#39;, &amp;#39;不&amp;#39;, &amp;#39;觉&amp;#39;, &amp;#39;晓&amp;#39; }; // 为每一行赋值
arr[1] = new char[] { &amp;#39;处&amp;#39;, &amp;#39;处&amp;#39;, &amp;#39;闻&amp;#39;, &amp;#39;啼&amp;#39;, &amp;#39;鸟&amp;#39; };
arr[2] = new char[] { &amp;#39;夜&amp;#39;, &amp;#39;来&amp;#39;, &amp;#39;风&amp;#39;, &amp;#39;雨&amp;#39;, &amp;#39;声&amp;#39; };
arr[3] = new char[] { &amp;#39;花&amp;#39;, &amp;#39;落&amp;#39;, &amp;#39;知&amp;#39;, &amp;#39;多&amp;#39;, &amp;#39;少&amp;#39; };
Log.d(&amp;#34;SimpleArray&amp;#34;, &amp;#34;-----横版-----&amp;#34;);
for (int i = 0; i &amp;lt; 4; i++) { // 循环4行
Log.d(&amp;#34;SimpleArraysToString&amp;#34;, Arrays.toString(arr[i]));
Log.d(&amp;#34;SimpleStringBytes&amp;#34;, Arrays.toString (Arrays.toString (arr[i]).getBytes()));
for (int j = 0; j &amp;lt; 5; j++) { // 循环5列
Log.d(&amp;#34;SimpleArray&amp;#34;, Character.toString(arr[i][j])); // 输出数组中的元素
}
if (i % 2 == 0) {
Log.d(&amp;#34;SimpleArray&amp;#34;, &amp;#34;,&amp;#34;);// 如果是一、三句，输出逗号
} else {
Log.d(&amp;#34;SimpleArray&amp;#34;, &amp;#34;。&amp;#34;);// 如果是二、四句，输出句号
}
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>Java.openClassFile(&amp;#34;/data/local/tmp/r0gson.dex&amp;#34;).load();
const gson = Java.use(&amp;#39;com.r0ysue.gson.Gson&amp;#39;);
Java.use(&amp;#34;java.lang.Character&amp;#34;).toString.overload(&amp;#39;char&amp;#39;).implementation = function(char){
var result = this.toString(char);
console.log(&amp;#34;char,result&amp;#34;,char,result);
return result;
}
Java.use(&amp;#34;java.util.Arrays&amp;#34;).toString.overload(&amp;#39;[C&amp;#39;).implementation = function(charArray){
var result = this.toString(charArray);
console.log(&amp;#34;charArray,result:&amp;#34;,charArray,result)
console.log(&amp;#34;charArray Object Object:&amp;#34;,gson.$new().toJson(charArray));
return result;
}
&lt;/code>&lt;/pre>&lt;p>这里的&lt;code>[C&lt;/code>是 JNI 函数签名&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033242.jpg" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033242.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033633.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033633.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="byte-bytebyte">&lt;a href="#byte" title="byte[]">&lt;/a>byte[]&lt;/h3>
&lt;pre tabindex="0">&lt;code>Java.openClassFile(&amp;#34;/data/local/tmp/r0gson.dex&amp;#34;).load();
const gson = Java.use(&amp;#39;com.r0ysue.gson.Gson&amp;#39;);
Java.use(&amp;#34;java.util.Arrays&amp;#34;).toString.overload(&amp;#39;[B&amp;#39;).implementation = function(byteArray){
var result = this.toString(byteArray);
console.log(&amp;#34;byteArray,result):&amp;#34;,byteArray,result)
console.log(&amp;#34;byteArray Object Object:&amp;#34;,gson.$new().toJson(byteArray));
return result;
}
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-034053.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-034053.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h3 id="java-array构造-java-array构造java-array-构造">&lt;a href="#java-array%e6%9e%84%e9%80%a0" title="java array构造">&lt;/a>java array 构造&lt;/h3>
&lt;p>如果不只是想打印出结果，而是要替换原本的参数，就要先自己构造出一个 charArray, 使用&lt;code>Java.array&lt;/code>API&lt;/p>
&lt;pre tabindex="0">&lt;code>/**
* Creates a Java array with elements of the specified `type`, from a
* JavaScript array `elements`. The resulting Java array behaves like
* a JS array, but can be passed by reference to Java APIs in order to
* allow them to modify its contents.
*
* @param type Type name of elements.
* @param elements Array of JavaScript values to use for constructing the
* Java array.
*/
function array(type: string, elements: any[]): any[];
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>Java.use(&amp;#34;java.util.Arrays&amp;#34;).toString.overload(&amp;#39;[C&amp;#39;).implementation = function(charArray){
var newCharArray = Java.array(&amp;#39;char&amp;#39;, [ &amp;#39;一&amp;#39;,&amp;#39;去&amp;#39;,&amp;#39;二&amp;#39;,&amp;#39;三&amp;#39;,&amp;#39;里&amp;#39; ]);
var result = this.toString(newCharArray);
console.log(&amp;#34;newCharArray,result:&amp;#34;,newCharArray,result)
console.log(&amp;#34;newCharArray Object Object:&amp;#34;,gson.$new().toJson(newCharArray));
var newResult = Java.use(&amp;#39;java.lang.String&amp;#39;).$new(Java.array(&amp;#39;char&amp;#39;, [ &amp;#39;烟&amp;#39;,&amp;#39;村&amp;#39;,&amp;#39;四&amp;#39;,&amp;#39;五&amp;#39;,&amp;#39;家&amp;#39;]))
return newResult;
}
&lt;/code>&lt;/pre>&lt;p>可以用来构造参数重发包，用在爬虫上。&lt;/p>
&lt;h3 id="类的多态转型-java-cast-类的多态转型javacast类的多态转型--javacast">&lt;a href="#%e7%b1%bb%e7%9a%84%e5%a4%9a%e6%80%81%ef%bc%9a%e8%bd%ac%e5%9e%8b-Java-cast" title="类的多态：转型/Java.cast">&lt;/a>类的多态：转型 / Java.cast&lt;/h3>
&lt;p>可以通过&lt;code>getClass().getName().toString()&lt;/code>来查看当前实例的类型。
找到一个 instance，通过&lt;code>Java.cast&lt;/code>来强制转换对象的类型。&lt;/p>
&lt;pre tabindex="0">&lt;code>/**
* Creates a JavaScript wrapper given the existing instance at `handle` of
* given class `klass` as returned from `Java.use()`.
*
* @param handle An existing wrapper or a JNI handle.
* @param klass Class wrapper for type to cast to.
*/
function cast(handle: Wrapper | NativePointerValue, klass: Wrapper): Wrapper;
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>public class Water { // 水 类
public static String flow(Water W) { // 水 的方法
// SomeSentence
Log.d(&amp;#34;2Object&amp;#34;, &amp;#34;water flow: I`m flowing&amp;#34;);
return &amp;#34;water flow: I`m flowing&amp;#34;;
}
public String still(Water W) { // 水 的方法
// SomeSentence
Log.d(&amp;#34;2Object&amp;#34;, &amp;#34;water still: still water runs deep!&amp;#34;);
return &amp;#34;water still: still water runs deep!&amp;#34;;
}
}
...
public class Juice extends Water { // 果汁 类 继承了水类
public String fillEnergy(){
Log.d(&amp;#34;2Object&amp;#34;, &amp;#34;Juice: i`m fillingEnergy!&amp;#34;);
return &amp;#34;Juice: i`m fillingEnergy!&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>var JuiceHandle = null ;
Java.choose(&amp;#34;com.r0ysue.a0526printout.Juice&amp;#34;,{
onMatch:function(instance){
console.log(&amp;#34;found juice instance&amp;#34;,instance);
console.log(&amp;#34;juice instance call fill&amp;#34;,instance.fillEnergy());
JuiceHandle = instance;
},onComplete:function(){
console.log(&amp;#34;juice handle search completed!&amp;#34;)
}
})
console.log(&amp;#34;Saved juice handle :&amp;#34;,JuiceHandle);
var WaterHandle = Java.cast(JuiceHandle,Java.use(&amp;#34;com.r0ysue.a0526printout.Water&amp;#34;))
console.log(&amp;#34;call Waterhandle still method:&amp;#34;,WaterHandle.still(WaterHandle));
&lt;/code>&lt;/pre>&lt;h3 id="interface-java-registerclass-interfacejavaregisterclassinterfacejavaregisterclass">&lt;a href="#interface-Java-registerClass" title="interface/Java.registerClass">&lt;/a>interface/Java.registerClass&lt;/h3>
&lt;pre tabindex="0">&lt;code>public interface liquid {
public String flow();
}
&lt;/code>&lt;/pre>&lt;p>frida 提供能力去创建一个新的 java class&lt;/p>
&lt;pre tabindex="0">&lt;code>/**
* Creates a new Java class.
*
* @param spec Object describing the class to be created.
*/
function registerClass(spec: ClassSpec): Wrapper;
&lt;/code>&lt;/pre>&lt;p>首先获取要实现的 interface，然后调用 registerClass 来实现 interface。&lt;/p>
&lt;pre tabindex="0">&lt;code>Java.perform(function(){
var liquid = Java.use(&amp;#34;com.r0ysue.a0526printout.liquid&amp;#34;);
var beer = Java.registerClass({
name: &amp;#39;com.r0ysue.a0526printout.beer&amp;#39;,
implements: [liquid],
methods: {
flow: function () {
console.log(&amp;#34;look, beer is flowing!&amp;#34;)
return &amp;#34;look, beer is flowing!&amp;#34;;
}
}
});
console.log(&amp;#34;beer.bubble:&amp;#34;,beer.$new().flow())
})
}
&lt;/code>&lt;/pre>&lt;h3 id="成员内部类-匿名内部类-成员内部类匿名内部类成员内部类--匿名内部类">&lt;a href="#%e6%88%90%e5%91%98%e5%86%85%e9%83%a8%e7%b1%bb-%e5%8c%bf%e5%90%8d%e5%86%85%e9%83%a8%e7%b1%bb" title="成员内部类/匿名内部类">&lt;/a>成员内部类 / 匿名内部类&lt;/h3>
&lt;p>看 smali 或者枚举出来的类。&lt;/p>
&lt;h3 id="hook-enum-hook-enumhook-enum">&lt;a href="#hook-enum" title="hook enum">&lt;/a>hook enum&lt;/h3>
&lt;p>关于 java 枚举，从这篇文章了解。
&lt;a href="https://www.cnblogs.com/jingmoxukong/p/6098351.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingmoxukong/p/6098351.html&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>enum Signal {
GREEN, YELLOW, RED
}
public class TrafficLight {
public static Signal color = Signal.RED;
public static void main() {
Log.d(&amp;#34;4enum&amp;#34;, &amp;#34;enum &amp;#34;+ color.getClass().getName().toString());
switch (color) {
case RED:
color = Signal.GREEN;
break;
case YELLOW:
color = Signal.RED;
break;
case GREEN:
color = Signal.YELLOW;
break;
}
}
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>Java.perform(function(){
Java.choose(&amp;#34;com.r0ysue.a0526printout.Signal&amp;#34;,{
onMatch:function(instance){
console.log(&amp;#34;instance.name:&amp;#34;,instance.name());
console.log(&amp;#34;instance.getDeclaringClass:&amp;#34;,instance.getDeclaringClass());
},onComplete:function(){
console.log(&amp;#34;search completed!&amp;#34;)
}
})
})
&lt;/code>&lt;/pre>&lt;h3 id="打印hash-map-打印hash-map打印-hash-map">&lt;a href="#%e6%89%93%e5%8d%b0hash-map" title="打印hash map">&lt;/a>打印 hash map&lt;/h3>
&lt;pre tabindex="0">&lt;code>Java.perform(function(){
Java.choose(&amp;#34;java.util.HashMap&amp;#34;,{
onMatch:function(instance){
if(instance.toString().indexOf(&amp;#34;ISBN&amp;#34;)!= -1){
console.log(&amp;#34;instance.toString:&amp;#34;,instance.toString());
}
},onComplete:function(){
console.log(&amp;#34;search complete!&amp;#34;)
}
})
})
&lt;/code>&lt;/pre>&lt;h3 id="打印non-ascii-打印non-ascii打印-non-ascii">&lt;a href="#%e6%89%93%e5%8d%b0non-ascii" title="打印non-ascii">&lt;/a>打印 non-ascii&lt;/h3>
&lt;p>&lt;a href="https://api-caller.com/2019/03/30/frida-note/#non-ascii" target="_blank" rel="noopener">https://api-caller.com/2019/03/30/frida-note/#non-ascii&lt;/a>&lt;br>
类名非 ASCII 字符串时，先编码打印出来, 再用编码后的字符串去 hook.&lt;/p>
&lt;pre tabindex="0">&lt;code>//场景hook cls.forName寻找目标类的classloader。
cls.forName.overload(&amp;#39;java.lang.String&amp;#39;, &amp;#39;boolean&amp;#39;, &amp;#39;java.lang.ClassLoader&amp;#39;).implementation = function (arg1, arg2, arg3) {
var clsName = cls.forName(arg1, arg2, arg3);
console.log(&amp;#39;oriClassName:&amp;#39; + arg1)
var base64Name = encodeURIComponent(arg1)
console.log(&amp;#39;encodeName:&amp;#39; + base64Name);
//通过日志确认base64后的非ascii字符串，下面对比并打印classloader
//clsName为特殊字符o.ÎÉ«
if (&amp;#39;o.%CE%99%C9%AB&amp;#39; == base64Name) {
//打印classloader
console.log(arg3);
}
return clsName;
}
&lt;/code>&lt;/pre>&lt;h2 id="frida-native-hook-ndk开发入门-frida-native-hook--ndk开发入门frida-native-hook--ndk-开发入门">&lt;a href="#Frida-native-hook-NDK%e5%bc%80%e5%8f%91%e5%85%a5%e9%97%a8" title="Frida native hook : NDK开发入门">&lt;/a>Frida native hook : NDK 开发入门&lt;/h2>
&lt;p>&lt;a href="https://www.jianshu.com/p/87ce6f565d37" target="_blank" rel="noopener">https://www.jianshu.com/p/87ce6f565d37&lt;/a>&lt;/p>
&lt;h2 id="frida-native-hook-jnienv和反射-frida-native-hook--jnienv和反射frida-native-hook--jnienv-和反射">&lt;a href="#Frida-native-hook-JNIEnv%e5%92%8c%e5%8f%8d%e5%b0%84" title="Frida native hook : JNIEnv和反射">&lt;/a>Frida native hook : JNIEnv 和反射&lt;/h2>
&lt;h3 id="以jni字符串来掌握基本的jnienv用法-以jni字符串来掌握基本的jnienv用法以-jni-字符串来掌握基本的-jnienv-用法">&lt;a href="#%e4%bb%a5jni%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9d%a5%e6%8e%8c%e6%8f%a1%e5%9f%ba%e6%9c%ac%e7%9a%84JNIEnv%e7%94%a8%e6%b3%95" title="以jni字符串来掌握基本的JNIEnv用法">&lt;/a>以 jni 字符串来掌握基本的 JNIEnv 用法&lt;/h3>
&lt;pre tabindex="0">&lt;code>public native String stringWithJNI(String context);
...
extern &amp;#34;C&amp;#34;
JNIEXPORT jstring JNICALL
Java_myapplication_example_com_ndk_1demo_MainActivity_stringWithJNI(JNIEnv *env, jobject instance,
jstring context_) {
const char *context = env-&amp;gt;GetStringUTFChars(context_, 0);
int context_size = env-&amp;gt;GetStringUTFLength(context_);
if (context_size &amp;gt; 0) {
LOGD(&amp;#34;%s\n&amp;#34;, context);
}
env-&amp;gt;ReleaseStringUTFChars(context_, context);
return env-&amp;gt;NewStringUTF(&amp;#34;sakura1328&amp;#34;);
}
12-26 22:30:00.548 15764-15764/myapplication.example.com.ndk_demo D/sakura1328: sakura
&lt;/code>&lt;/pre>&lt;h3 id="java反射-java反射java-反射">&lt;a href="#Java%e5%8f%8d%e5%b0%84" title="Java反射">&lt;/a>Java 反射&lt;/h3>
&lt;p>总结: 多去读一下 java 的反射 API。&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/9be58ee20dee" target="_blank" rel="noopener">Java 高级特性——反射&lt;/a>&lt;/p>
&lt;ul>
&lt;li>查找调用各种 API 接口、JNI、frida/xposed 原理的一部分&lt;/li>
&lt;li>反射基本 API&lt;/li>
&lt;li>反射修改访问控制、修改属性值&lt;/li>
&lt;li>JNI so 调用反射进入 java 世界&lt;/li>
&lt;li>xposed/Frida hook 原理&lt;/li>
&lt;/ul>
&lt;p>这里其实有一个伏笔，就是为什么我们要 trace artmethod，hook artmethod 是因为有些 so 混淆得非常厉害，然后也就很难静态分析看出 so 里面调用了哪些 java 函数，也不是通过类似 JNI 的 GetMethodID 这样来调用的。
而是通过类似 findclass 这种方法先得到类，然后再反射调用 app 里面的某个 java 函数。&lt;/p>
&lt;p>所以去 hook 它执行的位置，每一个 java 函数对于 Android 源码而言都是一个 artmethod 结构体，然后 hook 拿到 artmethod 实例以后调用类函数，打印这个函数的名称。&lt;/p>
&lt;pre tabindex="0">&lt;code>public class MainActivity extends AppCompatActivity {
private static final String TAG = &amp;#34;sakura&amp;#34;;
// Used to load the &amp;#39;native-lib&amp;#39; library on application startup.
static {
System.loadLibrary(&amp;#34;native-lib&amp;#34;);
}
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
// Example of a call to a native method
TextView tv = (TextView) findViewById(R.id.sample_text);
tv.setText(stringWithJNI(&amp;#34;sakura&amp;#34;));
// Log.d(TAG, stringFromJNI());
// Log.d(TAG, stringWithJNI(&amp;#34;sakura&amp;#34;));
try {
testClass();
} catch (ClassNotFoundException e) {
e.printStackTrace();
} catch (NoSuchFieldException e) {
e.printStackTrace();
} catch (IllegalAccessException e) {
e.printStackTrace();
} catch (NoSuchMethodException e) {
e.printStackTrace();
} catch (InvocationTargetException e) {
e.printStackTrace();
}
}
public void testClass() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
Test sakuraTest = new Test();
// 获得Class的方法（三种）
Class testClazz = MainActivity.class.getClassLoader().loadClass(&amp;#34;myapplication.example.com.ndk_demo.Test&amp;#34;);
Class testClazz2 = Class.forName(&amp;#34;myapplication.example.com.ndk_demo.Test&amp;#34;);
Class testClazz3 = Test.class;
Log.i(TAG, &amp;#34;Classloader.loadClass-&amp;gt;&amp;#34; + testClazz);
Log.i(TAG, &amp;#34;Classloader.loadClass-&amp;gt;&amp;#34; + testClazz2);
Log.i(TAG, &amp;#34;Classloader.loadClass-&amp;gt;&amp;#34; + testClazz3.getName());
// 获得类中属性相关的方法
Field publicStaticField = testClazz3.getDeclaredField(&amp;#34;publicStaticField&amp;#34;);
Log.i(TAG, &amp;#34;testClazz3.getDeclaredField-&amp;gt;&amp;#34; + publicStaticField);
Field publicField = testClazz3.getDeclaredField(&amp;#34;publicField&amp;#34;);
Log.i(TAG, &amp;#34;testClazz3.getDeclaredField-&amp;gt;&amp;#34; + publicField);
//对于Field的get方法，如果是static，则传入null即可;如果不是，则需要传入一个类的实例
String valueStaticPublic = (String) publicStaticField.get(null);
Log.i(TAG, &amp;#34;publicStaticField.get-&amp;gt;&amp;#34; + valueStaticPublic);
String valuePublic = (String) publicField.get(sakuraTest);
Log.i(TAG, &amp;#34;publicField.get-&amp;gt;&amp;#34; + valuePublic);
//对于private属性，需要设置Accessible
Field privateStaticField = testClazz3.getDeclaredField(&amp;#34;privateStaticField&amp;#34;);
privateStaticField.setAccessible(true);
String valuePrivte = (String) privateStaticField.get(null);
Log.i(TAG, &amp;#34;modified before privateStaticField.get-&amp;gt;&amp;#34; + valuePrivte);
privateStaticField.set(null, &amp;#34;modified&amp;#34;);
valuePrivte = (String) privateStaticField.get(null);
Log.i(TAG, &amp;#34;modified after privateStaticField.get-&amp;gt;&amp;#34; + valuePrivte);
Field[] fields = testClazz3.getDeclaredFields();
for (Field i : fields) {
Log.i(TAG, &amp;#34;testClazz3.getDeclaredFields-&amp;gt;&amp;#34; + i);
}
// 获得类中method相关的方法
Method publicStaticMethod = testClazz3.getDeclaredMethod(&amp;#34;publicStaticFunc&amp;#34;);
Log.i(TAG, &amp;#34;testClazz3.getDeclaredMethod-&amp;gt;&amp;#34; + publicStaticMethod);
publicStaticMethod.invoke(null);
Method publicMethod = testClazz3.getDeclaredMethod(&amp;#34;publicFunc&amp;#34;, java.lang.String.class);
Log.i(TAG, &amp;#34;testClazz3.getDeclaredMethod-&amp;gt;&amp;#34; + publicMethod);
publicMethod.invoke(sakuraTest, &amp;#34; sakura&amp;#34;);
}
/**
* A native method that is implemented by the &amp;#39;native-lib&amp;#39; native library,
* which is packaged with this application.
*/
public native String stringFromJNI();
public native String stringWithJNI(String context);
}
...
public class Test {
private static final String TAG = &amp;#34;sakura_test&amp;#34;;
public static String publicStaticField = &amp;#34;i am a publicStaticField&amp;#34;;
public String publicField = &amp;#34;i am a publicField&amp;#34;;
private static String privateStaticField = &amp;#34;i am a privateStaticField&amp;#34;;
private String privateField = &amp;#34;i am a privateField&amp;#34;;
public static void publicStaticFunc() {
Log.d(TAG, &amp;#34;I`m from publicStaticFunc&amp;#34;);
}
public void publicFunc(String str) {
Log.d(TAG, &amp;#34;I`m from publicFunc&amp;#34; + str);
}
private static void privateStaticFunc() {
Log.i(TAG, &amp;#34;I`m from privateFunc&amp;#34;);
}
private void privateFunc() {
Log.i(TAG, &amp;#34;I`m from privateFunc&amp;#34;);
}
}
...
...
12-26 23:57:11.784 17682-17682/myapplication.example.com.ndk_demo I/sakura: Classloader.loadClass-&amp;gt;class myapplication.example.com.ndk_demo.Test
12-26 23:57:11.784 17682-17682/myapplication.example.com.ndk_demo I/sakura: Classloader.loadClass-&amp;gt;class myapplication.example.com.ndk_demo.Test
12-26 23:57:11.784 17682-17682/myapplication.example.com.ndk_demo I/sakura: Classloader.loadClass-&amp;gt;myapplication.example.com.ndk_demo.Test
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredField-&amp;gt;public static java.lang.String myapplication.example.com.ndk_demo.Test.publicStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredField-&amp;gt;public java.lang.String myapplication.example.com.ndk_demo.Test.publicField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: publicStaticField.get-&amp;gt;i am a publicStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: publicField.get-&amp;gt;i am a publicField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: modified before privateStaticField.get-&amp;gt;i am a privateStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: modified after privateStaticField.get-&amp;gt;modified
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&amp;gt;private java.lang.String myapplication.example.com.ndk_demo.Test.privateField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&amp;gt;public java.lang.String myapplication.example.com.ndk_demo.Test.publicField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&amp;gt;private static final java.lang.String myapplication.example.com.ndk_demo.Test.TAG
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&amp;gt;private static java.lang.String myapplication.example.com.ndk_demo.Test.privateStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&amp;gt;public static java.lang.String myapplication.example.com.ndk_demo.Test.publicStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredMethod-&amp;gt;public static void myapplication.example.com.ndk_demo.Test.publicStaticFunc()
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo D/sakura_test: I`m from publicStaticFunc
12-26 23:57:11.786 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredMethod-&amp;gt;public void myapplication.example.com.ndk_demo.Test.publicFunc(java.lang.String)
12-26 23:57:11.786 17682-17682/myapplication.example.com.ndk_demo D/sakura_test: I`m from publicFunc sakura
&lt;/code>&lt;/pre>&lt;p>&lt;code>memory list modules&lt;/code>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-065833.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-065833.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h2 id="frida反调试-frida反调试frida-反调试">&lt;a href="#Frida%e5%8f%8d%e8%b0%83%e8%af%95" title="Frida反调试">&lt;/a>Frida 反调试&lt;/h2>
&lt;p>这一节的主要内容就是关于反调试的原理和如何破解反调试，重要内容还是看文章理解即可。
因为我并不需要做反调试相关的工作，所以部分内容略过。&lt;/p>
&lt;ul>
&lt;li>Frida 反调试与反反调试基本思路&lt;br>
（Java 层 API、Native 层 API、Syscall)
&lt;ul>
&lt;li>&lt;a href="https://github.com/qtfreet00/AntiFrida" target="_blank" rel="noopener">AntiFrida&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/b-mueller/frida-detection-demo" target="_blank" rel="noopener">frida-detection-demo&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bbs.pediy.com/thread-217482.htm" target="_blank" rel="noopener">多种特征检测 Frida&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yq.aliyun.com/articles/71120" target="_blank" rel="noopener">来自高维的对抗 - 逆向 TinyTool 自制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bbs.pediy.com/thread-253868.htm" target="_blank" rel="noopener">Unicorn 在 Android 的应用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="frida-native-hook-符号hook-jniart-amp-libc-frida-native-hook--符号hook-jniartlibcfrida-native-hook--符号-hook-jniartlibc">&lt;a href="#Frida-native-hook-%e7%ac%a6%e5%8f%b7hook-JNI%e3%80%81art-amp-libc" title="Frida native hook : 符号hook JNI、art&amp;amp;libc">&lt;/a>Frida native hook : 符号 hook JNI、art&amp;amp;libc&lt;/h2>
&lt;h3 id="native函数的java-hook及主动调用-native函数的java-hook及主动调用native-函数的-java-hook-及主动调用">&lt;a href="#Native%e5%87%bd%e6%95%b0%e7%9a%84Java-Hook%e5%8f%8a%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8" title="Native函数的Java Hook及主动调用">&lt;/a>Native 函数的 Java Hook 及主动调用&lt;/h3>
&lt;p>对 native 函数的 java 层 hook 和主动调用和普通 java 函数完全一致，略过。&lt;/p>
&lt;h3 id="jni-h头文件导入-jnih头文件导入jnih头文件导入">&lt;a href="#jni-h%e5%a4%b4%e6%96%87%e4%bb%b6%e5%af%bc%e5%85%a5" title="jni.h头文件导入">&lt;/a>&lt;code>jni.h&lt;/code>头文件导入&lt;/h3>
&lt;p>导入 jni.h，先 search 一下这个文件在哪。&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/Library/Android/sdk$ find ./ -name &amp;#34;jni.h&amp;#34;
.//ndk-bundle/sysroot/usr/include/jni.h
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-103826.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-103826.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>Error /Users/sakura/Library/Android/sdk/ndk-bundle/sysroot/usr/include/jni.h,27: Can&amp;#39;t open include file &amp;#39;stdarg.h&amp;#39;
Total 1 errors
Caching &amp;#39;Exports&amp;#39;... ok
&lt;/code>&lt;/pre>&lt;p>报错，所以拷贝一份 jni.h 出来&lt;/p>
&lt;p>将这两个头文件导入删掉&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104029.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104029.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>导入成功&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104113.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104113.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>现在就能识别_JNIEnv 了，如图&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104131.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104131.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h3 id="jni函数符号hook-jni函数符号hookjni-函数符号-hook">&lt;a href="#JNI%e5%87%bd%e6%95%b0%e7%ac%a6%e5%8f%b7hook" title="JNI函数符号hook">&lt;/a>JNI 函数符号 hook&lt;/h3>
&lt;p>先查看一下导出了哪些函数。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-102552.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-102552.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>extern &amp;#34;C&amp;#34; JNIEXPORT jstring JNICALL
Java_myapplication_example_com_ndk_1demo_MainActivity_stringFromJNI(
JNIEnv *env,
jobject /* this */) {
std::string hello = &amp;#34;Hello from C++&amp;#34;;
LOGD(&amp;#34;sakura1328&amp;#34;);
return env-&amp;gt;NewStringUTF(hello.c_str());
}
extern &amp;#34;C&amp;#34;
JNIEXPORT jstring JNICALL
Java_myapplication_example_com_ndk_1demo_MainActivity_stringWithJNI(JNIEnv *env, jobject instance,
jstring context_) {
const char *context = env-&amp;gt;GetStringUTFChars(context_, 0);
int context_size = env-&amp;gt;GetStringUTFLength(context_);
if (context_size &amp;gt; 0) {
LOGD(&amp;#34;%s\n&amp;#34;, context);
}
env-&amp;gt;ReleaseStringUTFChars(context_, context);
return env-&amp;gt;NewStringUTF(&amp;#34;sakura1328&amp;#34;);
}
&lt;/code>&lt;/pre>&lt;p>这里有几个需要的 API。&lt;/p>
&lt;ul>
&lt;li>首先是找到是否 so 被加载，通过&lt;code>Process.enumerateModules()&lt;/code>, 这个 API 可以枚举被加载到内存的 modules。&lt;/li>
&lt;li>然后通过&lt;code>Module.findBaseAddress(module name)&lt;/code>来查找要 hook 的函数所在的 so 的基地址，如果找不到就返回 null。&lt;/li>
&lt;li>然后可以通过&lt;code>findExportByName(moduleName: string, exportName: string): NativePointer&lt;/code>来查找导出函数的绝对地址。如果不知道 moduleName 是什么，可以传入一个 null 进入，但是会花费一些时间遍历所有的 module。如果找不到就返回 null。&lt;/li>
&lt;li>找到地址之后，就可以拦截 function/instruction 的执行。通过&lt;code>Interceptor.attach&lt;/code>。使用方法见下代码。&lt;/li>
&lt;li>另外为了将 jstring 的值打印出来，可以使用 jenv 的函数 getStringUtfChars，就像正常的写 native 程序一样。
&lt;code>Java.vm.getEnv().getStringUtfChars(args[2], null).readCString()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>这里我是循环调用的 string_with_jni，如果不循环调用，那就要主动调用一下这个函数，或者 hook dlopen。
hook dlopen 的方法在&lt;a href="https://github.com/lasting-yang/frida_dump/blob/master/dump_dex.js" target="_blank" rel="noopener">这个代码&lt;/a>可以参考。&lt;/p>
&lt;pre tabindex="0">&lt;code>function hook_native() {
// console.log(JSON.stringify(Process.enumerateModules()));
var libnative_addr = Module.findBaseAddress(&amp;#34;libnative-lib.so&amp;#34;)
console.log(&amp;#34;libnative_addr is: &amp;#34; + libnative_addr)
if (libnative_addr) {
var string_with_jni_addr = Module.findExportByName(&amp;#34;libnative-lib.so&amp;#34;,
&amp;#34;Java_myapplication_example_com_ndk_1demo_MainActivity_stringWithJNI&amp;#34;)
console.log(&amp;#34;string_with_jni_addr is: &amp;#34; + string_with_jni_addr)
}
Interceptor.attach(string_with_jni_addr, {
onEnter: function (args) {
console.log(&amp;#34;string_with_jni args: &amp;#34; + args[0], args[1], args[2])
console.log(Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())
},
onLeave: function (retval) {
console.log(&amp;#34;retval:&amp;#34;, retval)
console.log(Java.vm.getEnv().getStringUtfChars(retval, null).readCString())
var newRetval = Java.vm.getEnv().newStringUtf(&amp;#34;new retval from hook_native&amp;#34;);
retval.replace(ptr(newRetval));
}
})
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>libnative_addr is: 0x7a0842f000
string_with_jni_addr is: 0x7a08436194
[Google Pixel::myapplication.example.com.ndk_demo]-&amp;gt; string_with_jni args: 0x7a106cc1c0 0x7ff0b71da4 0x7ff0b71da8
sakura
retval: 0x75
sakura1328
&lt;/code>&lt;/pre>&lt;p>这里还写了一个 hook env 里的 GetStringUTFChars 的代码，和上面一样，不赘述了。&lt;/p>
&lt;pre tabindex="0">&lt;code>function hook_art(){
var addr_GetStringUTFChars = null;
//console.log( JSON.stringify(Process.enumerateModules()));
var symbols = Process.findModuleByName(&amp;#34;libart.so&amp;#34;).enumerateSymbols();
for(var i = 0;i&amp;lt;symbols.length;i++){
var symbol = symbols[i].name;
if((symbol.indexOf(&amp;#34;CheckJNI&amp;#34;)==-1)&amp;amp;&amp;amp;(symbol.indexOf(&amp;#34;JNI&amp;#34;)&amp;gt;=0)){
if(symbol.indexOf(&amp;#34;GetStringUTFChars&amp;#34;)&amp;gt;=0){
console.log(symbols[i].name);
console.log(symbols[i].address);
addr_GetStringUTFChars = symbols[i].address;
}
}
}
console.log(&amp;#34;addr_GetStringUTFChars:&amp;#34;, addr_GetStringUTFChars);
Java.perform(function (){
Interceptor.attach(addr_GetStringUTFChars, {
onEnter: function (args) {
console.log(&amp;#34;addr_GetStringUTFChars OnEnter args[0],args[1]&amp;#34;,args[0],args[1]);
//console.log(hexdump(args[0].readPointer()));
//console.log(Java.vm.tryGetEnv().getStringUtfChars(args[0]).readCString());
}, onLeave: function (retval) {
console.log(&amp;#34;addr_GetStringUTFChars OnLeave&amp;#34;,ptr(retval).readCString());
}
})
})
}
&lt;/code>&lt;/pre>&lt;h3 id="jni函数参数返回值打印和替换-jni函数参数返回值打印和替换jni-函数参数返回值打印和替换">&lt;a href="#JNI%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0%e3%80%81%e8%bf%94%e5%9b%9e%e5%80%bc%e6%89%93%e5%8d%b0%e5%92%8c%e6%9b%bf%e6%8d%a2" title="JNI函数参数、返回值打印和替换">&lt;/a>JNI 函数参数、返回值打印和替换&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>libc 函数符号 hook&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libc 函数参数、返回值打印和替换&lt;br>
hook libc 的也和上面的完全一样，也不赘述了。
所以看到这里，究其本质就是找到导出符号和它所在的 so 基地址了。&lt;/p>
&lt;pre tabindex="0">&lt;code>function hook_libc(){
var pthread_create_addr = null;
var symbols = Process.findModuleByName(&amp;#34;libc.so&amp;#34;).enumerateSymbols();
for(var i = 0;i&amp;lt;symbols.length;i++){
var symbol = symbols[i].name;
if(symbol.indexOf(&amp;#34;pthread_create&amp;#34;)&amp;gt;=0){
//console.log(symbols[i].name);
//console.log(symbols[i].address);
pthread_create_addr = symbols[i].address;
}
}
console.log(&amp;#34;pthread_create_addr,&amp;#34;,pthread_create_addr);
Interceptor.attach(pthread_create_addr,{
onEnter:function(args){
console.log(&amp;#34;pthread_create_addr args[0],args[1],args[2],args[3]:&amp;#34;,args[0],args[1],args[2],args[3]);
},onLeave:function(retval){
console.log(&amp;#34;retval is:&amp;#34;,retval)
}
})
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="frida-native-hook-jni-onload-动态注册-inline-hook-native层调用栈打印-frida-native-hook--jni_onload动态注册inline_hooknative层调用栈打印frida-native-hook--jni_onload--动态注册--inline_hooknative-层调用栈打印">&lt;a href="#Frida-native-hook-JNI-Onload-%e5%8a%a8%e6%80%81%e6%b3%a8%e5%86%8c-inline-hook-native%e5%b1%82%e8%b0%83%e7%94%a8%e6%a0%88%e6%89%93%e5%8d%b0" title="Frida native hook : JNI_Onload/动态注册/inline_hook/native层调用栈打印">&lt;/a>Frida native hook : JNI_Onload / 动态注册 / inline_hook/native 层调用栈打印&lt;/h2>
&lt;p>&lt;a href="https://github.com/android/ndk-samples" target="_blank" rel="noopener">https://github.com/android/ndk-samples&lt;/a>&lt;/p>
&lt;h3 id="jni-onload-动态注册原理-jni_onload动态注册原理jni_onload--动态注册原理">&lt;a href="#JNI-Onload-%e5%8a%a8%e6%80%81%e6%b3%a8%e5%86%8c%e5%8e%9f%e7%90%86" title="JNI_Onload/动态注册原理">&lt;/a>JNI_Onload / 动态注册原理&lt;/h3>
&lt;ul>
&lt;li>JNI_Onload / 动态注册 / Frida hook RegisterNative
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.kanxue.com/article-4482.htm" target="_blank" rel="noopener">JNI 与动态注册&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://eternalsakura13.com/2018/02/08/jni2/" target="_blank" rel="noopener">native 方法的动态注册&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/lasting-yang/frida_hook_libart" target="_blank" rel="noopener">Frida hook art&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>详细的内容参见我写的文章，这里只给出栗子。&lt;/p>
&lt;pre tabindex="0">&lt;code>Log.d(TAG,stringFromJNI2());
public native String stringFromJNI2();
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>JNIEXPORT jstring JNICALL stringFromJNI2(
JNIEnv *env,
jclass clazz) {
jclass testClass = env-&amp;gt;FindClass(&amp;#34;myapplication/example/com/ndk_demo/Test&amp;#34;);
jfieldID publicStaticField = env-&amp;gt;GetStaticFieldID(testClass, &amp;#34;publicStaticField&amp;#34;,
&amp;#34;Ljava/lang/String;&amp;#34;);
jstring publicStaticFieldValue = (jstring) env-&amp;gt;GetStaticObjectField(testClass,
publicStaticField);
const char *value_ptr = env-&amp;gt;GetStringUTFChars(publicStaticFieldValue, NULL);
LOGD(&amp;#34;now content is %s&amp;#34;, value_ptr);
std::string hello = &amp;#34;Hello from C++ stringFromJNI2&amp;#34;;
return env-&amp;gt;NewStringUTF(hello.c_str());
}
...
JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
JNIEnv *env;
vm-&amp;gt;GetEnv((void **) &amp;amp;env, JNI_VERSION_1_6);
JNINativeMethod methods[] = {
{&amp;#34;stringFromJNI2&amp;#34;, &amp;#34;()Ljava/lang/String;&amp;#34;, (void *) stringFromJNI2},
};
env-&amp;gt;RegisterNatives(env-&amp;gt;FindClass(&amp;#34;myapplication/example/com/ndk_demo/MainActivity&amp;#34;), methods,
1);
return JNI_VERSION_1_6;
}
&lt;/code>&lt;/pre>&lt;h3 id="frida-hook-registernative-frida-hook-registernativefrida-hook-registernative">&lt;a href="#Frida-hook-RegisterNative" title="Frida hook RegisterNative">&lt;/a>Frida hook RegisterNative&lt;/h3>
&lt;p>使用下面这个脚本来打印出 RegisterNatives 的参数，这里需要注意的是使用了 enumerateSymbolsSync, 它是 enumerateSymbols 的同步版本。
另外和我们之前通过&lt;code>Java.vm.tryGetEnv().getStringUtfChars&lt;/code>来调用 env 里的方法不同。
这里则是通过将之前找到的 getStringUtfChars 函数地址和参数信息封装起来，直接调用，具体的原理我没有深入分析，先记住用法。
原理其实是一样的，都是&lt;strong>根据符号找到地址，然后 hook 符号地址，然后打印参数&lt;/strong>。&lt;/p>
&lt;pre tabindex="0">&lt;code>declare const NativeFunction: NativeFunctionConstructor;
interface NativeFunctionConstructor {
new(address: NativePointerValue, retType: NativeType, argTypes: NativeType[], abiOrOptions?: NativeABI | NativeFunctionOptions): NativeFunction;
readonly prototype: NativeFunction;
}
...
var funcGetStringUTFChars = new NativeFunction(addrGetStringUTFChars, &amp;#34;pointer&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>var ishook_libart = false;
function hook_libart() {
if (ishook_libart === true) {
return;
}
var symbols = Module.enumerateSymbolsSync(&amp;#34;libart.so&amp;#34;);
var addrGetStringUTFChars = null;
var addrNewStringUTF = null;
var addrFindClass = null;
var addrGetMethodID = null;
var addrGetStaticMethodID = null;
var addrGetFieldID = null;
var addrGetStaticFieldID = null;
var addrRegisterNatives = null;
var addrAllocObject = null;
var addrCallObjectMethod = null;
var addrGetObjectClass = null;
var addrReleaseStringUTFChars = null;
for (var i = 0; i &amp;lt; symbols.length; i++) {
var symbol = symbols[i];
if (symbol.name == &amp;#34;_ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPh&amp;#34;) {
addrGetStringUTFChars = symbol.address;
console.log(&amp;#34;GetStringUTFChars is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name == &amp;#34;_ZN3art3JNI12NewStringUTFEP7_JNIEnvPKc&amp;#34;) {
addrNewStringUTF = symbol.address;
console.log(&amp;#34;NewStringUTF is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name == &amp;#34;_ZN3art3JNI9FindClassEP7_JNIEnvPKc&amp;#34;) {
addrFindClass = symbol.address;
console.log(&amp;#34;FindClass is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name == &amp;#34;_ZN3art3JNI11GetMethodIDEP7_JNIEnvP7_jclassPKcS6_&amp;#34;) {
addrGetMethodID = symbol.address;
console.log(&amp;#34;GetMethodID is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name == &amp;#34;_ZN3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jclassPKcS6_&amp;#34;) {
addrGetStaticMethodID = symbol.address;
console.log(&amp;#34;GetStaticMethodID is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name == &amp;#34;_ZN3art3JNI10GetFieldIDEP7_JNIEnvP7_jclassPKcS6_&amp;#34;) {
addrGetFieldID = symbol.address;
console.log(&amp;#34;GetFieldID is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name == &amp;#34;_ZN3art3JNI16GetStaticFieldIDEP7_JNIEnvP7_jclassPKcS6_&amp;#34;) {
addrGetStaticFieldID = symbol.address;
console.log(&amp;#34;GetStaticFieldID is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name == &amp;#34;_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi&amp;#34;) {
addrRegisterNatives = symbol.address;
console.log(&amp;#34;RegisterNatives is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name.indexOf(&amp;#34;_ZN3art3JNI11AllocObjectEP7_JNIEnvP7_jclass&amp;#34;) &amp;gt;= 0) {
addrAllocObject = symbol.address;
console.log(&amp;#34;AllocObject is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name.indexOf(&amp;#34;_ZN3art3JNI16CallObjectMethodEP7_JNIEnvP8_jobjectP10_jmethodIDz&amp;#34;) &amp;gt;= 0) {
addrCallObjectMethod = symbol.address;
console.log(&amp;#34;CallObjectMethod is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name.indexOf(&amp;#34;_ZN3art3JNI14GetObjectClassEP7_JNIEnvP8_jobject&amp;#34;) &amp;gt;= 0) {
addrGetObjectClass = symbol.address;
console.log(&amp;#34;GetObjectClass is at &amp;#34;, symbol.address, symbol.name);
} else if (symbol.name.indexOf(&amp;#34;_ZN3art3JNI21ReleaseStringUTFCharsEP7_JNIEnvP8_jstringPKc&amp;#34;) &amp;gt;= 0) {
addrReleaseStringUTFChars = symbol.address;
console.log(&amp;#34;ReleaseStringUTFChars is at &amp;#34;, symbol.address, symbol.name);
}
}
if (addrRegisterNatives != null) {
Interceptor.attach(addrRegisterNatives, {
onEnter: function (args) {
console.log(&amp;#34;[RegisterNatives] method_count:&amp;#34;, args[3]);
var env = args[0];
var java_class = args[1];
var funcAllocObject = new NativeFunction(addrAllocObject, &amp;#34;pointer&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
var funcGetMethodID = new NativeFunction(addrGetMethodID, &amp;#34;pointer&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
var funcCallObjectMethod = new NativeFunction(addrCallObjectMethod, &amp;#34;pointer&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
var funcGetObjectClass = new NativeFunction(addrGetObjectClass, &amp;#34;pointer&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
var funcGetStringUTFChars = new NativeFunction(addrGetStringUTFChars, &amp;#34;pointer&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
var funcReleaseStringUTFChars = new NativeFunction(addrReleaseStringUTFChars, &amp;#34;void&amp;#34;, [&amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;, &amp;#34;pointer&amp;#34;]);
var clz_obj = funcAllocObject(env, java_class);
var mid_getClass = funcGetMethodID(env, java_class, Memory.allocUtf8String(&amp;#34;getClass&amp;#34;), Memory.allocUtf8String(&amp;#34;()Ljava/lang/Class;&amp;#34;));
var clz_obj2 = funcCallObjectMethod(env, clz_obj, mid_getClass);
var cls = funcGetObjectClass(env, clz_obj2);
var mid_getName = funcGetMethodID(env, cls, Memory.allocUtf8String(&amp;#34;getName&amp;#34;), Memory.allocUtf8String(&amp;#34;()Ljava/lang/String;&amp;#34;));
var name_jstring = funcCallObjectMethod(env, clz_obj2, mid_getName);
var name_pchar = funcGetStringUTFChars(env, name_jstring, ptr(0));
var class_name = ptr(name_pchar).readCString();
funcReleaseStringUTFChars(env, name_jstring, name_pchar);
//console.log(class_name);
var methods_ptr = ptr(args[2]);
var method_count = parseInt(args[3]);
for (var i = 0; i &amp;lt; method_count; i++) {
var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));
var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));
var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));
var name = Memory.readCString(name_ptr);
var sig = Memory.readCString(sig_ptr);
var find_module = Process.findModuleByAddress(fnPtr_ptr);
console.log(&amp;#34;[RegisterNatives] java_class:&amp;#34;, class_name, &amp;#34;name:&amp;#34;, name, &amp;#34;sig:&amp;#34;, sig, &amp;#34;fnPtr:&amp;#34;, fnPtr_ptr, &amp;#34;module_name:&amp;#34;, find_module.name, &amp;#34;module_base:&amp;#34;, find_module.base, &amp;#34;offset:&amp;#34;, ptr(fnPtr_ptr).sub(find_module.base));
}
},
onLeave: function (retval) { }
});
}
ishook_libart = true;
}
hook_libart();
&lt;/code>&lt;/pre>&lt;p>结果很明显的打印了出来，包括动态注册的函数的名字，函数签名，加载地址和在 so 里的偏移量，&lt;/p>
&lt;pre tabindex="0">&lt;code>[RegisterNatives] java_class: myapplication.example.com.ndk_demo.MainActivity name: stringFromJNI2 sig: ()Ljava/lang/String; fnPtr: 0x79f8698484 module_name: libnative-lib.so module_base: 0x79f8691000 offset: 0x7484
&lt;/code>&lt;/pre>&lt;p>最后测试一下 yang 开源的一个 hook art 的脚本，很有意思，trace 出了非常多的需要的信息。&lt;/p>
&lt;pre tabindex="0">&lt;code>frida -U --no-pause -f package_name -l hook_art.js
...
[FindClass] name:myapplication/example/com/ndk_demo/Test
[GetStaticFieldID] name:publicStaticField, sig:Ljava/lang/String;
[GetStringUTFChars] result:i am a publicStaticField
[NewStringUTF] bytes:Hello from C++ stringFromJNI2
[GetStringUTFChars] result:sakura
&lt;/code>&lt;/pre>&lt;h3 id="native层调用栈打印-native层调用栈打印native-层调用栈打印">&lt;a href="#native%e5%b1%82%e8%b0%83%e7%94%a8%e6%a0%88%e6%89%93%e5%8d%b0" title="native层调用栈打印">&lt;/a>native 层调用栈打印&lt;/h3>
&lt;p>直接使用 frida 提供的接口打印栈回溯。&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(f, {
onEnter: function (args) {
console.log(&amp;#39;RegisterNatives called from:\n&amp;#39; +
Thread.backtrace(this.context, Backtracer.ACCURATE)
.map(DebugSymbol.fromAddress).join(&amp;#39;\n&amp;#39;) + &amp;#39;\n&amp;#39;);
}
});
&lt;/code>&lt;/pre>&lt;p>效果如下, 我加到了 hook registerNative 的地方。&lt;/p>
&lt;pre tabindex="0">&lt;code>[Google Pixel::myapplication.example.com.ndk_demo]-&amp;gt; RegisterNatives called from:
0x7a100be03c libart.so!0xe103c
0x7a100be038 libart.so!0xe1038
0x79f85699a0 libnative-lib.so!_ZN7_JNIEnv15RegisterNativesEP7_jclassPK15JNINativeMethodi+0x44
0x79f85698e0 libnative-lib.so!JNI_OnLoad+0x90
0x7a102b9fd4 libart.so!_ZN3art9JavaVMExt17LoadNativeLibraryEP7_JNIEnvRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEP8_jobjectP8_jstringPS9_+0x638
0x7a08e3820c libopenjdkjvm.so!JVM_NativeLoad+0x110
0x70b921c4 boot.oat!oatexec+0xa81c4
&lt;/code>&lt;/pre>&lt;h3 id="主动调用去进行方法参数替换-主动调用去进行方法参数替换主动调用去进行方法参数替换">&lt;a href="#%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e5%8e%bb%e8%bf%9b%e8%a1%8c%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e6%9b%bf%e6%8d%a2" title="主动调用去进行方法参数替换">&lt;/a>主动调用去进行方法参数替换&lt;/h3>
&lt;p>使用&lt;code>Interceptor.replace&lt;/code>，不赘述。主要目的还是为了改掉函数原本的执行行为，而不是仅仅打印一些信息。&lt;/p>
&lt;h3 id="inline-hook-inline-hookinline-hook">&lt;a href="#inline-hook" title="inline hook">&lt;/a>inline hook&lt;/h3>
&lt;p>inline hook 简单理解就是不是 hook 函数开始执行的地方，而是 hook 函数中间执行的指令&lt;br>
整体来说没什么区别，就是把找函数符号地址改成从 so 里找到偏移，然后加到 so 基地址上就行, 注意一下它的 attach 的 callback。&lt;/p>
&lt;pre tabindex="0">&lt;code>/**
* Callback to invoke when an instruction is about to be executed.
*/
type InstructionProbeCallback = (this: InvocationContext, args: InvocationArguments) =&amp;gt; void;
type InvocationContext = PortableInvocationContext | WindowsInvocationContext | UnixInvocationContext;
interface PortableInvocationContext {
/**
* Return address.
*/
returnAddress: NativePointer;
/**
* CPU registers. You may also update register values by assigning to these keys.
*/
context: CpuContext;
/**
* OS thread ID.
*/
threadId: ThreadId;
/**
* Call depth of relative to other invocations.
*/
depth: number;
/**
* User-defined invocation data. Useful if you want to read an argument in `onEnter` and act on it in `onLeave`.
*/
[x: string]: any;
}
...
...
interface Arm64CpuContext extends PortableCpuContext {
x0: NativePointer;
x1: NativePointer;
x2: NativePointer;
x3: NativePointer;
x4: NativePointer;
x5: NativePointer;
x6: NativePointer;
x7: NativePointer;
x8: NativePointer;
x9: NativePointer;
x10: NativePointer;
x11: NativePointer;
x12: NativePointer;
x13: NativePointer;
x14: NativePointer;
x15: NativePointer;
x16: NativePointer;
x17: NativePointer;
x18: NativePointer;
x19: NativePointer;
x20: NativePointer;
x21: NativePointer;
x22: NativePointer;
x23: NativePointer;
x24: NativePointer;
x25: NativePointer;
x26: NativePointer;
x27: NativePointer;
x28: NativePointer;
fp: NativePointer;
lr: NativePointer;
}
&lt;/code>&lt;/pre>&lt;p>我的 so 是自己编译的，具体的汇编代码如下, 总之这里很明显在 775C 时，x0 里保存的是一个指向”sakura” 这个字符串的指针。(其实我也不是很看得懂 arm64 了已经，就随便 hook 了一下)&lt;br>
所以 hook 这个指令，然后&lt;code>Memory.readCString(this.context.x0);&lt;/code>打印出来，结果如下&lt;/p>
&lt;pre tabindex="0">&lt;code>.text:000000000000772C ; __unwind {
.text:000000000000772C SUB SP, SP, #0x40
.text:0000000000007730 STP X29, X30, [SP,#0x30+var_s0]
.text:0000000000007734 ADD X29, SP, #0x30
.text:0000000000007738 ; 6: v6 = a1;
.text:0000000000007738 MOV X8, XZR
.text:000000000000773C STUR X0, [X29,#var_8]
.text:0000000000007740 ; 7: v5 = a3;
.text:0000000000007740 STUR X1, [X29,#var_10]
.text:0000000000007744 STR X2, [SP,#0x30+var_18]
.text:0000000000007748 ; 8: v4 = (const char *)_JNIEnv::GetStringUTFChars(a1, a3, 0LL);
.text:0000000000007748 LDUR X0, [X29,#var_8]
.text:000000000000774C LDR X1, [SP,#0x30+var_18]
.text:0000000000007750 MOV X2, X8
.text:0000000000007754 BL ._ZN7_JNIEnv17GetStringUTFCharsEP8_jstringPh ; _JNIEnv::GetStringUTFChars(_jstring *,uchar *)
.text:0000000000007758 STR X0, [SP,#0x30+var_20]
.text:000000000000775C ; 9: if ( (signed int)_JNIEnv::GetStringUTFLength(v6, v5) &amp;gt; 0 )
.text:000000000000775C LDUR X0, [X29,#var_8]
.text:0000000000007760 LDR X1, [SP,#0x30+var_18]
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>function inline_hook() {
var libnative_lib_addr = Module.findBaseAddress(&amp;#34;libnative-lib.so&amp;#34;);
if (libnative_lib_addr) {
console.log(&amp;#34;libnative_lib_addr:&amp;#34;, libnative_lib_addr);
var addr_775C = libnative_lib_addr.add(0x775C);
console.log(&amp;#34;addr_775C:&amp;#34;, addr_775C);
Java.perform(function () {
Interceptor.attach(addr_775C, {
onEnter: function (args) {
var name = this.context.x0.readCString()
console.log(&amp;#34;addr_775C OnEnter :&amp;#34;, this.returnAddress, name);
},
onLeave: function (retval) {
console.log(&amp;#34;retval is :&amp;#34;, retval)
}
})
})
}
}
setImmediate(inline_hook())
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>Attaching...
libnative_lib_addr: 0x79fabe0000
addr_775C: 0x79fabe775c
TypeError: cannot read property &amp;#39;apply&amp;#39; of undefined
at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:56618)
at frida/runtime/core.js:55
[Google Pixel::myapplication.example.com.ndk_demo]-&amp;gt; addr_775C OnEnter : 0x79fabe7758 sakura
addr_775C OnEnter : 0x79fabe7758 sakura
&lt;/code>&lt;/pre>&lt;p>到这里已经可以总结一下我目前的学习了，需要补充一些 frida api 的学习，比如 NativePointr 里居然有个 readCString，这些 API 是需要再看看的。&lt;/p>
&lt;h2 id="frida-native-hook-frida-hook-native-app实战-frida-native-hook--frida-hook-native-app实战frida-native-hook--frida-hook-native-app-实战">&lt;a href="#Frida-native-hook-Frida-hook-native-app%e5%ae%9e%e6%88%98" title="Frida native hook : Frida hook native app实战">&lt;/a>Frida native hook : Frida hook native app 实战&lt;/h2>
&lt;ul>
&lt;li>破解 Frida 全端口检测的 native 层反调试
&lt;ul>
&lt;li>hook libc 的 pthread_create 函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>破解 TracePid 的 native 反调试
&lt;ul>
&lt;li>target: &lt;a href="https://gtoad.github.io/2017/06/25/Android-Anti-Debug/" target="_blank" rel="noopener">https://gtoad.github.io/2017/06/25/Android-Anti-Debug/&lt;/a>&lt;/li>
&lt;li>solve : hook libc 的 fgets 函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>native 层修改参数、返回值&lt;/li>
&lt;li>静态分析&lt;code>JNI_Onload&lt;/code>&lt;/li>
&lt;li>动态 trace 主动注册 &amp;amp; IDA 溯源&lt;/li>
&lt;li>动态 trace JNI、libc 函数 &amp;amp; IDA 溯源&lt;/li>
&lt;li>native 层主动调用、打调用栈&lt;/li>
&lt;li>主动调用 libc 读写文件&lt;/li>
&lt;/ul>
&lt;p>看下 logcat&lt;/p>
&lt;pre tabindex="0">&lt;code>n/u0a128 for activity com.gdufs.xman/.MainActivity
12-28 05:53:26.898 26615 26615 V com.gdufs.xman: JNI_OnLoad()
12-28 05:53:26.898 26615 26615 V com.gdufs.xman: RegisterNatives() --&amp;gt; nativeMethod() ok
12-28 05:53:26.898 26615 26615 D com.gdufs.xman m=: 0
12-28 05:53:26.980 26615 26615 D com.gdufs.xman m=: Xman
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101517.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101517.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101821.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101821.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101843.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101843.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/gitsource/frida-agent-example/agent$ frida -U --no-pause -f com.gdufs.xman -l hook_reg.js
...
[Google Pixel::com.gdufs.xman]-&amp;gt; [RegisterNatives] method_count: 0x3
[RegisterNatives] java_class: com.gdufs.xman.MyApp name: initSN sig: ()V fnPtr: 0xd4ddf3b1 module_name: libmyjni.so module_base: 0xd4dde000 offset: 0x13b1
[RegisterNatives] java_class: com.gdufs.xman.MyApp name: saveSN sig: (Ljava/lang/String;)V fnPtr: 0xd4ddf1f9 module_name: libmyjni.so module_base: 0xd4dde000 offset: 0x11f9
[RegisterNatives] java_class: com.gdufs.xman.MyApp name: work sig: ()V fnPtr: 0xd4ddf4cd module_name: libmyjni.so module_base: 0xd4dde000 offset: 0x14cd
&lt;/code>&lt;/pre>&lt;p>结合一下看，只要 initSN 检查到&lt;code>/sdcard/reg.dat&lt;/code>里是&lt;code>EoPAoY62@ElRD&lt;/code>，应该就会给 m 设置成 1。
只要 m 的值是 1，就能走到 work() 函数的逻辑。&lt;/p>
&lt;p>参考 &lt;a href="https://frida.re/docs/javascript-api/#file" target="_blank" rel="noopener">frida 的 file api&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>function main() {
var file = new File(&amp;#34;/sdcard/reg.dat&amp;#34;,&amp;#39;w&amp;#39;)
file.write(&amp;#34;EoPAoY62@ElRD&amp;#34;)
file.flush()
file.close()
}
setImmediate(main())
&lt;/code>&lt;/pre>&lt;p>这样我们继续看 work 的逻辑&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120940.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120940.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>v2 是从 getValue 得到的，看上去就是 m 字段的值，此时应该是 1，一会 hook 一下看看。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-121012.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-121012.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>[NewStringUTF] bytes:输入即是flag,格式为xman{……}！
&lt;/code>&lt;/pre>&lt;p>callWork 里又调用了 work 函数，死循环了。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120907.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120907.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>那看来看去最后还是回到了 initSN，那其实我们看的顺序似乎错了。
理一下逻辑，n2 执行完保存到文件，然后 n1 check 一下，所以最后还是要逆 n2 的算法，pass。&lt;/p>
&lt;h2 id="frida-trace四件套-frida-trace四件套frida-trace-四件套">&lt;a href="#Frida-trace%e5%9b%9b%e4%bb%b6%e5%a5%97" title="Frida trace四件套">&lt;/a>Frida trace 四件套&lt;/h2>
&lt;h3 id="jni-trace-trace-jni-jni-trace--trace-jnijni-trace--trace-jni">&lt;a href="#jni-trace-trace-jni" title="jni trace : trace jni">&lt;/a>jni trace : trace jni&lt;/h3>
&lt;p>&lt;a href="https://github.com/chame1eon/jnitrace" target="_blank" rel="noopener">https://github.com/chame1eon/jnitrace&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install jnitrace
Requirement already satisfied: frida&amp;gt;=12.5.0 in /Users/sakura/.pyenv/versions/3.7.7/lib/python3.7/site-packages (from jnitrace) (12.8.0)
Requirement already satisfied: colorama in /Users/sakura/.pyenv/versions/3.7.7/lib/python3.7/site-packages (from jnitrace) (0.4.3)
Collecting hexdump (from jnitrace)
Downloading https://files.pythonhosted.org/packages/55/b3/279b1d57fa3681725d0db8820405cdcb4e62a9239c205e4ceac4391c78e4/hexdump-3.3.zip
Installing collected packages: hexdump, jnitrace
Running setup.py install for hexdump ... done
Running setup.py install for jnitrace ... done
Successfully installed hexdump-3.3 jnitrace-3.0.8
&lt;/code>&lt;/pre>&lt;p>usage: &lt;code>jnitrace [options] -l libname target&lt;/code>&lt;br>
默认应该是 spawn 运行的，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>-m&lt;/code>来指定是&lt;code>spawn&lt;/code>还是&lt;code>attach&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-b&lt;/code>指定是&lt;code>fuzzy&lt;/code>还是&lt;code>accurate&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-i &amp;lt;regex&amp;gt;&lt;/code>指定一个正则表达式来过滤出方法名，例如&lt;code>-i Get -i RegisterNatives&lt;/code>就会只打印出名字里包含 Get 或者 RegisterNatives 的 JNI methods。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-e &amp;lt;regex&amp;gt;&lt;/code>和&lt;code>-i&lt;/code>相反，同样通过正则表达式来过滤，但这次会将指定的内容忽略掉。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-I &amp;lt;string&amp;gt;&lt;/code>trace 导出的方法，jnitrace 认为导出的函数应该是从 Java 端能够直接调用的函数，所以可以包括使用 RegisterNatives 来注册的函数，例如&lt;code>-I stringFromJNI -I nativeMethod([B)V&lt;/code>，就包括导出名里有 stringFromJNI，以及使用 RegisterNames 来注册，并带有 nativeMethod([B)V 签名的函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-o path/output.json&lt;/code>，导出输出到文件里。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-p path/to/script.js&lt;/code>，用于在加载 jnitrace 脚本之前将指定路径的 Frida 脚本加载到目标进程中，这可以用于在 jnitrace 启动之前对抗反调试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-a path/to/script.js&lt;/code>，用于在加载 jnitrace 脚本之后将指定路径的 Frida 脚本加载到目标进程中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>--ignore-env&lt;/code>，不打印所有的 JNIEnv 函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>--ignore-vm&lt;/code>，不打印所有的 JavaVM 函数&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn/0620/0620/xman/resources/lib/armeabi-v7a$ jnitrace -l libmyjni.so com.gdufs.xman
Tracing. Press any key to quit...
Traced library &amp;#34;libmyjni.so&amp;#34; loaded from path &amp;#34;/data/app/com.gdufs.xman-X0HkzLhbptSc0tjGZ3yQ2g==/lib/arm&amp;#34;.
/* TID 28890 */
355 ms [+] JavaVM-&amp;gt;GetEnv
355 ms |- JavaVM* : 0xefe99140
355 ms |- void** : 0xda13e028
355 ms |: 0xeff312a0
355 ms |- jint : 65542
355 ms |= jint : 0
355 ms ------------------------Backtrace------------------------
355 ms |-&amp;gt; 0xda13a51b: JNI_OnLoad+0x12 (libmyjni.so:0xda139000)
/* TID 28890 */
529 ms [+] JNIEnv-&amp;gt;FindClass
529 ms |- JNIEnv* : 0xeff312a0
529 ms |- char* : 0xda13bdef
529 ms |: com/gdufs/xman/MyApp
529 ms |= jclass : 0x81 { com/gdufs/xman/MyApp }
529 ms ------------------------Backtrace------------------------
529 ms |-&amp;gt; 0xda13a539: JNI_OnLoad+0x30 (libmyjni.so:0xda139000)
/* TID 28890 */
584 ms [+] JNIEnv-&amp;gt;RegisterNatives
584 ms |- JNIEnv* : 0xeff312a0
584 ms |- jclass : 0x81 { com/gdufs/xman/MyApp }
584 ms |- JNINativeMethod* : 0xda13e004
584 ms |: 0xda13a3b1 - initSN()V
584 ms |: 0xda13a1f9 - saveSN(Ljava/lang/String;)V
584 ms |: 0xda13a4cd - work()V
584 ms |- jint : 3
584 ms |= jint : 0
584 ms ------------------------Backtrace------------------------
584 ms |-&amp;gt; 0xda13a553: JNI_OnLoad+0x4a (libmyjni.so:0xda139000)
/* TID 28890 */
638 ms [+] JNIEnv-&amp;gt;FindClass
638 ms |- JNIEnv* : 0xeff312a0
638 ms |- char* : 0xda13bdef
638 ms |: com/gdufs/xman/MyApp
638 ms |= jclass : 0x71 { com/gdufs/xman/MyApp }
638 ms -----------------------Backtrace-----------------------
638 ms |-&amp;gt; 0xda13a377: setValue+0x12 (libmyjni.so:0xda139000)
/* TID 28890 */
688 ms [+] JNIEnv-&amp;gt;GetStaticFieldID
688 ms |- JNIEnv* : 0xeff312a0
688 ms |- jclass : 0x71 { com/gdufs/xman/MyApp }
688 ms |- char* : 0xda13be04
688 ms |: m
688 ms |- char* : 0xda13be06
688 ms |: I
688 ms |= jfieldID : 0xf1165004 { m:I }
688 ms -----------------------Backtrace-----------------------
688 ms |-&amp;gt; 0xda13a38d: setValue+0x28 (libmyjni.so:0xda139000)
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h3 id="strace-trace-syscall-strace--trace-syscallstrace--trace-syscall">&lt;a href="#strace-trace-syscall" title="strace : trace syscall">&lt;/a>strace : trace syscall&lt;/h3>
&lt;p>&lt;a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html&lt;/a>&lt;/p>
&lt;h3 id="frida-trace-trace-libc-or-more-frida-trace--trace-libcor-morefrida-trace--trace-libcor-more">&lt;a href="#frida-trace-trace-libc-or-more" title="frida-trace : trace libc(or more)">&lt;/a>frida-trace : trace libc(or more)&lt;/h3>
&lt;p>&lt;a href="https://frida.re/docs/frida-trace/" target="_blank" rel="noopener">https://frida.re/docs/frida-trace/&lt;/a>&lt;/p>
&lt;p>Usage:&lt;code>frida-trace [options] target&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>frida-trace -U -i &amp;#34;strcmp&amp;#34; -f com.gdufs.xman
...
5634 ms strcmp(s1=&amp;#34;fi&amp;#34;, s2=&amp;#34;es-US&amp;#34;)
5635 ms strcmp(s1=&amp;#34;da&amp;#34;, s2=&amp;#34;es-US&amp;#34;)
5635 ms strcmp(s1=&amp;#34;es&amp;#34;, s2=&amp;#34;es-US&amp;#34;)
5635 ms strcmp(s1=&amp;#34;eu-ES&amp;#34;, s2=&amp;#34;es-US&amp;#34;)
5635 ms strcmp(s1=&amp;#34;et-EE&amp;#34;, s2=&amp;#34;es-US&amp;#34;)
5635 ms strcmp(s1=&amp;#34;et-EE&amp;#34;, s2=&amp;#34;es-US&amp;#34;)
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>art trace: &lt;a href="https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_artmethod.js" target="_blank" rel="noopener">hook artmethod&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="hook-artmethod-trace-java函数调用-hook_artmethod--trace-java函数调用hook_artmethod--trace-java-函数调用">&lt;a href="#hook-artmethod-trace-java%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8" title="hook_artmethod : trace java函数调用">&lt;/a>hook_artmethod : trace java 函数调用&lt;/h3>
&lt;p>&lt;a href="https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_artmethod.js" target="_blank" rel="noopener">https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_artmethod.js&lt;/a>&lt;/p>
&lt;h3 id="修改aosp源码打印-修改aosp源码打印修改-aosp-源码打印">&lt;a href="#%e4%bf%ae%e6%94%b9AOSP%e6%ba%90%e7%a0%81%e6%89%93%e5%8d%b0" title="修改AOSP源码打印">&lt;/a>修改 AOSP 源码打印&lt;/h3>
&lt;p>&lt;a href="https://bbs.pediy.com/thread-255653-1.htm" target="_blank" rel="noopener">改 aosp 源码 trace 信息&lt;/a>&lt;/p>
&lt;h2 id="frida-native-hook-init-array开发和自动化逆向-frida-native-hook--init_array开发和自动化逆向frida-native-hook--init_array-开发和自动化逆向">&lt;a href="#Frida-native-hook-init-array%e5%bc%80%e5%8f%91%e5%92%8c%e8%87%aa%e5%8a%a8%e5%8c%96%e9%80%86%e5%90%91" title="Frida native hook : init_array开发和自动化逆向">&lt;/a>Frida native hook : init_array 开发和自动化逆向&lt;/h2>
&lt;h3 id="init-array原理-init_array原理init_array-原理">&lt;a href="#init-array%e5%8e%9f%e7%90%86" title="init_array原理">&lt;/a>init_array 原理&lt;/h3>
&lt;p>常见的保护都会在 init_array 里面做，关于其原理，主要阅读以下文章即可。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.cnblogs.com/bingghost/p/6297325.html" target="_blank" rel="noopener">IDA 调试 android so 的. init_array 数组&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dllhook.com/post/213.html" target="_blank" rel="noopener">Android NDK 中. init 段和. init_array 段函数的定义方式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wooyun.js.org/drops/Android%20Linker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" target="_blank" rel="noopener">Linker 学习笔记&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="ida静态分析init-array-ida静态分析init_arrayida-静态分析-init_array">&lt;a href="#IDA%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90init-array" title="IDA静态分析init_array">&lt;/a>IDA 静态分析 init_array&lt;/h3>
&lt;pre tabindex="0">&lt;code>// 编译生成后在.init段 [名字不可更改]
extern &amp;#34;C&amp;#34; void _init(void) {
LOGD(&amp;#34;Enter init......&amp;#34;);
}
// 编译生成后在.init_array段 [名字可以更改]
__attribute__((__constructor__)) static void sakura_init() {
LOGD(&amp;#34;Enter sakura_init......&amp;#34;);
}
...
...
2016-12-29 16:51:23.017 5160-5160/com.example.ndk_demo D/sakura1328: Enter init......
2016-12-29 16:51:23.017 5160-5160/com.example.ndk_demo D/sakura1328: Enter sakura_init......
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161438.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161438.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
IDA 快捷键&lt;code>shift+F7&lt;/code>找到 segment，然后就可以找到&lt;code>.init_array&lt;/code>段，然后就可以找到里面保存的函数地址。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161519.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161519.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161601.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161601.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161613.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161613.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h3 id="ida动态调试so-ida动态调试soida-动态调试-so">&lt;a href="#IDA%e5%8a%a8%e6%80%81%e8%b0%83%e8%af%95so" title="IDA动态调试so">&lt;/a>IDA 动态调试 so&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>打开要调试的 apk，找到入口&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~/.gradle/caches$ adb shell dumpsys activity top | grep TASK
TASK com.android.systemui id=29 userId=0
TASK null id=26 userId=0
TASK com.example.ndk_demo id=161 userId=0
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>启动 apk, 并让设备将处于一个 Waiting For Debugger 的状态&lt;br>
&lt;code>adb shell am start -D -n com.example.ndk_demo/.MainActivity&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行 android_server64&lt;/p>
&lt;pre tabindex="0">&lt;code>sailfish:/data/local/tmp # ./android_server64
IDA Android 64-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017
Listening on 0.0.0.0:23946...
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>新开一个窗口使用 forward 程序进行端口转发：&lt;code>adb forward tcp:23946 tcp:23946&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>adb forward tcp:&amp;lt;本地机器的网络端口号&amp;gt; tcp:&amp;lt;模拟器或是真机的网络端口号&amp;gt;&lt;/code>&lt;br>
例: adb [-d|-e|-s ] forward tcp:6100 tcp:7100 表示把本机的 6100 端口号与模拟器的 7100 端口建立起相关，当模拟器或真机向自己的 7100 端口发送了数据，那们我们可以在本机的 6100 端口读取其发送的内容，这是一个很关键的命令，以后我们使用 jdb 调试 apk 之前，就要用它先把目标进程和本地端口建立起关联&lt;/p>
&lt;ul>
&lt;li>
&lt;p>打开 IDA，选择菜单 Debugger -&amp;gt; Attach -&amp;gt; Remote ARM Linux/Android debugger&lt;/p>
&lt;/li>
&lt;li>
&lt;p>打开 IDA，选择菜单 Debugger -&amp;gt; Process options, 填好，然后选择进程去 attach。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-082029.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-082029.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看待调试的进程&lt;code>adb jdwp&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ adb jdwp
10436
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>转发端口&lt;code>adb forward tcp:8700 jdwp:10436&lt;/code>，将该进程的调试端口和本机的 8700 绑定。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>jdb 连接调试端口，从而让程序继续运行 &lt;code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>找到断点并断下。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>打开 module&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095937.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095937.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
找到 linker64&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095955.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095955.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
找到 call array 函数&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100022.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100022.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;br>
下断并按 F9 断下&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100042.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100042.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>最终我确实可以调试到&lt;code>.init_array&lt;/code>的初始化，具体的代码分析见 &lt;a href="https://wooyun.js.org/drops/Android%20Linker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" target="_blank" rel="noopener">Linker 学习笔记&lt;/a>这里。&lt;/p>
&lt;h3 id="init-array-amp-amp-jni-onload-自吐-init_array--jni_onload-自吐init_array--jni_onload-自吐">&lt;a href="#init-array-amp-amp-JNI-Onload-%e2%80%9c%e8%87%aa%e5%90%90%e2%80%9d" title="init_array &amp;amp;&amp;amp; JNI_Onload “自吐”">&lt;/a>init_array &amp;amp;&amp;amp; JNI_Onload “自吐”&lt;/h3>
&lt;h4 id="jni-onload-jni_onloadjni_onload">&lt;a href="#JNI-Onload" title="JNI_Onload">&lt;/a>JNI_Onload&lt;/h4>
&lt;p>目标是找到动态注册的函数的地址，因为这种函数没有导出。&lt;/p>
&lt;pre tabindex="0">&lt;code>JNINativeMethod methods[] = {
{&amp;#34;stringFromJNI2&amp;#34;, &amp;#34;()Ljava/lang/String;&amp;#34;, (void *) stringFromJNI2},
};
env-&amp;gt;RegisterNatives(env-&amp;gt;FindClass(&amp;#34;com/example/ndk_demo/MainActivity&amp;#34;), methods,
1);
&lt;/code>&lt;/pre>&lt;p>首先&lt;code>jnitrace -m spawn -i &amp;quot;RegisterNatives&amp;quot; -l libnative-lib.so com.example.ndk_demo&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>525 ms [+] JNIEnv-&amp;gt;RegisterNatives
525 ms |- JNIEnv* : 0x7a106cc1c0
525 ms |- jclass : 0x89 { com/example/ndk_demo/MainActivity }
525 ms |- JNINativeMethod* : 0x7ff0b71120
525 ms |: 0x79f00d36b0 - stringFromJNI2()Ljava/lang/String;
&lt;/code>&lt;/pre>&lt;p>然后&lt;code>objection -d -g com.example.ndk_demo run memory list modules explore | grep demo&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>sakura@sakuradeMacBook-Pro:~$ objection -d -g com.example.ndk_demo run memory list modules explore | grep demo
[debug] Attempting to attach to process: `com.example.ndk_demo`
Warning: Output is not to a terminal (fd=1).
base.odex 0x79f0249000 106496 (104.0 KiB) /data/app/com.example.ndk_demo-HGAFhnKyKCSIpzn227pwXw==/oat/arm64/base.odex
libnative-lib.so 0x79f00c4000 221184 (216.0 KiB) /data/app/com.example.ndk_demo-HGAFhnKyKCSIpzn227pwXw==/lib/arm64/libnative...
&lt;/code>&lt;/pre>&lt;p>offset = 0x79f00d36b0 - 0x79f00c4000 = 0xf6b0&lt;/p>
&lt;p>这样就找到了&lt;br>
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-122151.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-122151.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h4 id="init-array-init_arrayinit_array">&lt;a href="#init-array" title="init_array">&lt;/a>init_array&lt;/h4>
&lt;p>没有支持 arm64，可以在安装 app 的时候&lt;code>adb install --abi armeabi-v7a&lt;/code>强制让 app 运行在 32 位模式&lt;/p>
&lt;p>这个脚本整体来说就是 hook callfunction，然后打印出 init_array 里面的函数地址和参数等。&lt;/p>
&lt;p>从源码看，关键就是 call_array 这里调用的 call_function，第一个参数代表这是注册的 init_array 里面的 function，第二个参数则是 init_array 里存储的函数的地址。&lt;/p>
&lt;pre tabindex="0">&lt;code>template &amp;lt;typename F&amp;gt;
static void call_array(const char* array_name __unused,
F* functions,
size_t count,
bool reverse,
const char* realpath) {
if (functions == nullptr) {
return;
}
TRACE(&amp;#34;[ Calling %s (size %zd) @ %p for &amp;#39;%s&amp;#39; ]&amp;#34;, array_name, count, functions, realpath);
int begin = reverse ? (count - 1) : 0;
int end = reverse ? -1 : count;
int step = reverse ? -1 : 1;
for (int i = begin; i != end; i += step) {
TRACE(&amp;#34;[ %s[%d] == %p ]&amp;#34;, array_name, i, functions[i]);
call_function(&amp;#34;function&amp;#34;, functions[i], realpath);
}
TRACE(&amp;#34;[ Done calling %s for &amp;#39;%s&amp;#39; ]&amp;#34;, array_name, realpath);
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>function LogPrint(log) {
var theDate = new Date();
var hour = theDate.getHours();
var minute = theDate.getMinutes();
var second = theDate.getSeconds();
var mSecond = theDate.getMilliseconds()
hour &amp;lt; 10 ? hour = &amp;#34;0&amp;#34; + hour : hour;
minute &amp;lt; 10 ? minute = &amp;#34;0&amp;#34; + minute : minute;
second &amp;lt; 10 ? second = &amp;#34;0&amp;#34; + second : second;
mSecond &amp;lt; 10 ? mSecond = &amp;#34;00&amp;#34; + mSecond : mSecond &amp;lt; 100 ? mSecond = &amp;#34;0&amp;#34; + mSecond : mSecond;
var time = hour + &amp;#34;:&amp;#34; + minute + &amp;#34;:&amp;#34; + second + &amp;#34;:&amp;#34; + mSecond;
var threadid = Process.getCurrentThreadId();
console.log(&amp;#34;[&amp;#34; + time + &amp;#34;]&amp;#34; + &amp;#34;-&amp;gt;threadid:&amp;#34; + threadid + &amp;#34;--&amp;#34; + log);
}
function hooklinker() {
var linkername = &amp;#34;linker&amp;#34;;
var call_function_addr = null;
var arch = Process.arch;
LogPrint(&amp;#34;Process run in:&amp;#34; + arch);
if (arch.endsWith(&amp;#34;arm&amp;#34;)) {
linkername = &amp;#34;linker&amp;#34;;
} else {
linkername = &amp;#34;linker64&amp;#34;;
LogPrint(&amp;#34;arm64 is not supported yet!&amp;#34;);
}
var symbols = Module.enumerateSymbolsSync(linkername);
for (var i = 0; i &amp;lt; symbols.length; i++) {
var symbol = symbols[i];
//LogPrint(linkername + &amp;#34;-&amp;gt;&amp;#34; + symbol.name + &amp;#34;---&amp;#34; + symbol.address);
if (symbol.name.indexOf(&amp;#34;__dl__ZL13call_functionPKcPFviPPcS2_ES0_&amp;#34;) != -1) {
call_function_addr = symbol.address;
LogPrint(&amp;#34;linker-&amp;gt;&amp;#34; + symbol.name + &amp;#34;---&amp;#34; + symbol.address)
}
}
if (call_function_addr != null) {
var func_call_function = new NativeFunction(call_function_addr, &amp;#39;void&amp;#39;, [&amp;#39;pointer&amp;#39;, &amp;#39;pointer&amp;#39;, &amp;#39;pointer&amp;#39;]);
Interceptor.replace(new NativeFunction(call_function_addr,
&amp;#39;void&amp;#39;, [&amp;#39;pointer&amp;#39;, &amp;#39;pointer&amp;#39;, &amp;#39;pointer&amp;#39;]), new NativeCallback(function (arg0, arg1, arg2) {
var functiontype = null;
var functionaddr = null;
var sopath = null;
if (arg0 != null) {
functiontype = Memory.readCString(arg0);
}
if (arg1 != null) {
functionaddr = arg1;
}
if (arg2 != null) {
sopath = Memory.readCString(arg2);
}
var modulebaseaddr = Module.findBaseAddress(sopath);
LogPrint(&amp;#34;after load:&amp;#34; + sopath + &amp;#34;--start call_function,type:&amp;#34; + functiontype + &amp;#34;--addr:&amp;#34; + functionaddr + &amp;#34;---baseaddr:&amp;#34; + modulebaseaddr);
if (sopath.indexOf(&amp;#39;libnative-lib.so&amp;#39;) &amp;gt;= 0 &amp;amp;&amp;amp; functiontype == &amp;#34;DT_INIT&amp;#34;) {
LogPrint(&amp;#34;after load:&amp;#34; + sopath + &amp;#34;--ignore call_function,type:&amp;#34; + functiontype + &amp;#34;--addr:&amp;#34; + functionaddr + &amp;#34;---baseaddr:&amp;#34; + modulebaseaddr);
} else {
func_call_function(arg0, arg1, arg2);
LogPrint(&amp;#34;after load:&amp;#34; + sopath + &amp;#34;--end call_function,type:&amp;#34; + functiontype + &amp;#34;--addr:&amp;#34; + functionaddr + &amp;#34;---baseaddr:&amp;#34; + modulebaseaddr);
}
}, &amp;#39;void&amp;#39;, [&amp;#39;pointer&amp;#39;, &amp;#39;pointer&amp;#39;, &amp;#39;pointer&amp;#39;]));
}
}
setImmediate(hooklinker)
&lt;/code>&lt;/pre>&lt;p>我调试了一下 linker64，因为没有导出 call_function 的地址，所以不能直接 hook 符号名，而是要根据偏移去 hook，以后再说。
其实要看&lt;code>init_array&lt;/code>，直接 shift+F7 去 segment 里面找&lt;code>.init_array&lt;/code>段就可以了，这里主要是为了反反调试，因为可能反调试会加在 init_array 里，hook call_function 就可以让它不加载反调试程序。&lt;/p>
&lt;h3 id="native层未导出函数主动调用任意符号和地址-native层未导出函数主动调用任意符号和地址native-层未导出函数主动调用任意符号和地址">&lt;a href="#native%e5%b1%82%e6%9c%aa%e5%af%bc%e5%87%ba%e5%87%bd%e6%95%b0%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%ef%bc%88%e4%bb%bb%e6%84%8f%e7%ac%a6%e5%8f%b7%e5%92%8c%e5%9c%b0%e5%9d%80%ef%bc%89" title="native层未导出函数主动调用（任意符号和地址）">&lt;/a>native 层未导出函数主动调用（任意符号和地址）&lt;/h3>
&lt;p>现在我想要主动调用 sakura_add 来打印值, 可以 ida 打开找符号，或者根据偏移，总之最终用这个 NativePointer 指针来初始化一个 NativeFunction 来调用。&lt;/p>
&lt;pre tabindex="0">&lt;code>extern &amp;#34;C&amp;#34;
JNIEXPORT jint JNICALL
Java_com_example_ndk_1demo_MainActivity_sakuraWithInt(JNIEnv *env, jobject thiz, jint a, jint b) {
// TODO: implement sakuraWithInt()
return sakura_add(a,b);
}
...
int sakura_add(int a, int b){
int sum = a+b;
LOGD(&amp;#34;sakura add a+b:&amp;#34;,sum);
return sum;
}
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-142324.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-142324.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>function main() {
var libnative_lib_addr = Module.findBaseAddress(&amp;#34;libnative-lib.so&amp;#34;);
console.log(&amp;#34;libnative_lib_addr is :&amp;#34;, libnative_lib_addr);
if (libnative_lib_addr) {
var sakura_add_addr1 = Module.findExportByName(&amp;#34;libnative-lib.so&amp;#34;, &amp;#34;_Z10sakura_addii&amp;#34;);
var sakura_add_addr2 = libnative_lib_addr.add(0x0F56C) ;
console.log(&amp;#34;sakura_add_addr1 &amp;#34;, sakura_add_addr1);
console.log(&amp;#34;sakura_add_addr2 &amp;#34;, sakura_add_addr2)
}
var sakura_add1 = new NativeFunction(sakura_add_addr1, &amp;#34;int&amp;#34;, [&amp;#34;int&amp;#34;, &amp;#34;int&amp;#34;]);
var sakura_add2 = new NativeFunction(sakura_add_addr2, &amp;#34;int&amp;#34;, [&amp;#34;int&amp;#34;, &amp;#34;int&amp;#34;]);
console.log(&amp;#34;sakura_add1 result is :&amp;#34;, sakura_add1(200, 33));
console.log(&amp;#34;sakura_add2 result is :&amp;#34;, sakura_add2(100, 133));
}
setImmediate(main())
...
...
libnative_lib_addr is : 0x79fa1c5000
sakura_add_addr1 0x79fa1d456c
sakura_add_addr2 0x79fa1d456c
sakura_add1 result is : 233
sakura_add2 result is : 233
&lt;/code>&lt;/pre>&lt;h2 id="c-c-hook-cc-hookcc-hook">&lt;a href="#C-C-hook" title="C/C&amp;#43;&amp;#43; hook">&lt;/a>C/C++ hook&lt;/h2>
&lt;p>//todo&lt;/p>
&lt;h3 id="native-jni层参数打印和主动调用参数构造-nativejni层参数打印和主动调用参数构造nativejni-层参数打印和主动调用参数构造">&lt;a href="#Native-JNI%e5%b1%82%e5%8f%82%e6%95%b0%e6%89%93%e5%8d%b0%e5%92%8c%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0%e6%9e%84%e9%80%a0" title="Native/JNI层参数打印和主动调用参数构造">&lt;/a>Native/JNI 层参数打印和主动调用参数构造&lt;/h3>
&lt;p>jni 的基本类型要通过调用 jni 相关的 api 转化成 c++ 对象，才能打印和调用。
jni 主动调用的时候，参数构造有两种方式，一种是&lt;code>Java.vm.getenv&lt;/code>，另一种是 hook 获取 env 之后来调用 jni 相关的 api 构造参数。&lt;/p>
&lt;h3 id="c-c-编成so并引入frida调用其中的函数-cc编成so并引入frida调用其中的函数cc-编成-so-并引入-frida-调用其中的函数">&lt;a href="#C-C-%e7%bc%96%e6%88%90so%e5%b9%b6%e5%bc%95%e5%85%a5Frida%e8%b0%83%e7%94%a8%e5%85%b6%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0" title="C/C&amp;#43;&amp;#43;编成so并引入Frida调用其中的函数">&lt;/a>C/C++ 编成 so 并引入 Frida 调用其中的函数&lt;/h3>
&lt;h2 id="致谢-致谢致谢">&lt;a href="#%e8%87%b4%e8%b0%a2" title="致谢">&lt;/a>致谢&lt;/h2>
&lt;p>本篇文章学到的内容来自且完全来自 r0ysue 的知识星球，推荐一下。
&lt;a href="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-07-061015.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-07-061015.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p></description></item><item><title>frida 免 root hook</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzkzMjE4NDgyMg==&amp;amp;mid=2247485635&amp;amp;idx=1&amp;amp;sn=cc496104f7ac8fd584f2d34800a63f3c&amp;amp;chksm=c25edf5af529564c2037b31b9b080b3e5e72b98770e3822cef6b27006db6f29a55b0b5232169&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0303BEkGyo0ipMnH418bEqua&amp;amp;sharer_sharetime=1646295077139&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/j6JcMCXCIIgjR4j04DUarll32p0Y8SYoeo8jNsFMARNkY2BrIic2VdSwK6o3k3BDshb8KJic9UTKhACvbibib1hiaicg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>因为相信， 所以看见&lt;/p>
&lt;p>答疑，就是在每周四，把问的比较多的，统一回答下。&lt;/p>
&lt;p>写文章也会比私信回复更详细些。&lt;/p>
&lt;p>本来应该是昨天发的，昨天睡觉去了，拖到了今天。&lt;/p>
&lt;p>0&lt;/p>
&lt;p>序言&lt;/p>
&lt;p>可能有的大佬并不知道 frida gadget 是个啥。&lt;/p>
&lt;p>这里先看看官方对于 gadget 的解释&lt;/p>
&lt;p>官方链接&lt;/p>
&lt;p>&lt;a href="https://frida.re/docs/gadget/" target="_blank" rel="noopener">https://frida.re/docs/gadget/&lt;/a>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TBQqP8Yibozsk3m5RccHHsxib1Br2MR1q2oYQaNcfpFR3EOWB51oxs1Mg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这句英语意思大概意思是:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/4gCJbFBBaxgr0WD3mMgto4yFaYwwjQMbuxDDBKibrhNlW5YFLV3K1XvkGj1sP1BiaYtibMLdQVrvth08BVUWP7oGw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>frida Gadget 是一个动态库，如果注入不适用于当前场景 (一般是被检测 或者没 root)，就用程序加载这个库来达到 hook 的效果。&lt;/p>
&lt;p>frida gadget 使用场景&lt;/p>
&lt;ol>
&lt;li>免 root 使用 frida&lt;/li>
&lt;li>反调试 反 root 反 frida 很强，绕不过去的时候&lt;/li>
&lt;li>frida 持久化，frida gadget 直接嵌入 app 不用每次打开 frida_server 了&lt;/li>
&lt;/ol>
&lt;p>这里用一个案例演示 frida 免 root 注入&lt;/p>
&lt;p>app 一般分为有 so 库和无 so 库，&lt;strong>这篇文章演示有 so 库的情况&lt;/strong>。&lt;/p>
&lt;p>连接方式一般分为等待连接   和 直接执行脚本，**这篇文章演示****直接执行脚本**。&lt;/p>
&lt;p>主要分为以下几个步骤&lt;/p>
&lt;p>1&lt;/p>
&lt;p>下载 frida gadget.so&lt;/p>
&lt;p>&lt;strong>2&lt;/strong>&lt;/p>
&lt;p>app so 添加依赖 加入 frida gadget.so&lt;/p>
&lt;p>3&lt;/p>
&lt;p>编写  frida gadget config 配置文件&lt;/p>
&lt;p>4&lt;/p>
&lt;p>编写注入 js&lt;/p>
&lt;p>5&lt;/p>
&lt;p>打包新 apk 执行&lt;/p>
&lt;p>1&lt;/p>
&lt;p>下载 frida gadget.so&lt;/p>
&lt;p>去哪里下载呢？&lt;/p>
&lt;p>当当当当&lt;/p>
&lt;p>当然是全球最大同性交友网站 ** github**&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TCZXviaurMaByIKzibfmXcDLiaiaPtPrmdhhTvv0tKZ8c6944YyibzQgQLOw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>直接去 frida 的 github 仓，点击 release &lt;strong>找想要的版本&lt;/strong> 去下载就可&lt;/p>
&lt;p>链接 &lt;a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">https://github.com/frida/frida/releases&lt;/a>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TewpRHcTdoicnSvAZrHBn3K9cibdzIntcvGXtianHTxXqLxibSZXicreBtQQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>2&lt;/p>
&lt;p>app so 添加依赖 加入 frida gadget.so&lt;/p>
&lt;p>这一步的原理是，让 app 在执行 so 的文件的时候，加载 frida-gadget.so&lt;/p>
&lt;p>大部分 so 文件，在运行的时候，都有一些依赖库。&lt;/p>
&lt;p>这一步就是把 frida gadget.so &lt;strong>加入到 apk 本身 so 的依赖库中&lt;/strong>。&lt;/p>
&lt;p>这一步很多大佬是用 lief 实现的。&lt;/p>
&lt;p>实际上实现这一步的办法挺多的。&lt;/p>
&lt;p>喜欢用 ubuntu 的，可以安装 patchelf 然后一行命令就搞定了&lt;/p>
&lt;p>patchelf 地址：https://github.com/NixOS/patchelf&lt;/p>
&lt;pre tabindex="0">&lt;code>patchelf --add-needed frida-gadget.so apk.so
&lt;/code>&lt;/pre>&lt;p>so easy , 再也不用担心你不会添加依赖了。&lt;/p>
&lt;p>&lt;strong>实例演示：&lt;/strong>&lt;/p>
&lt;p>看看这里的示例 apk&lt;/p>
&lt;p>apk 只有 armv7 的 so 文件 其他都没有&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TCBmHpdU1icAzgMmfiaQTV1qeDvwOz8aLF3rh7ATaC9Zu5GMoVrmyT4qg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>wtt.apk 里面有一个 so  &lt;strong>libnative-lib.so&lt;/strong>&lt;/p>
&lt;p>这里，直接给 libnative-lib.so 添加 frida-gadget.so 依赖库&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TnYynA4KdnvFpMW0G1ic7z2nVlibSCzibCWFibk4SnQkvZVtJZ6yC3O96ag/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为了防止检测，frida 这特征也太明显了，很容易被检测 被针对&lt;/p>
&lt;p>最好把这个 so 改个名字，比如 libcaiji.so   改名后如下图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TjsDvSh7W7jibxzFVmP50FXBs3ojw85AUmt3BOaewNLdF5M6fFtQtX1Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>运行 patchelf 添加依赖库&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89T8kic5gPbw5PcdicxN6UibHyNnxZOqTRibGRePOtibHv5FgcF9gIesbvOeAw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>没有添加 frida-gadget.so 依赖库之前， &lt;strong>libnative-lib.so&lt;/strong> 的依赖库如下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TXzwsdiaXIcwwr8JOKRApOZeXuOMCwqasd9hYTrP3aj3zrbHHWpsL7ww/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>搞完之后 拖进 ida 看一下  &lt;strong>libnative-lib.so 的&lt;/strong>依赖库&lt;/p>
&lt;p>这里可以看到多了一个依赖 so&lt;/p>
&lt;p>libcaiji.so 就是 frida-gadget.so 改名后的 so&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89To1G1baQmhyhxvVNzia0ia4ibudNAFXI1QtjqhntxgLJUYUpibTqUccBibwQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>3&lt;/p>
&lt;p>编写  frida gadget config 配置文件&lt;/p>
&lt;p>关于用 gadget.so 直接执行脚本&lt;/p>
&lt;p>官方文章是有介绍的，机器翻译还是有点问题的，凑合看吧&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TmeRbgXG6y3UiaJ9mNCVnTptiaa0XWQ40akBS5RbRCa7icmZibcic9XYAsXA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里我按照官方的示例，写了一个配置文件&lt;/p>
&lt;p>配置&lt;strong>文件名&lt;/strong> libcaiji.config.so&lt;/p>
&lt;p>这里, 注意配置文件命名的格式，一定是你改名后的名字 + .config.so&lt;/p>
&lt;pre tabindex="0">&lt;code>libxxx.so
libxxx.config.so
&lt;/code>&lt;/pre>&lt;p>关于命名规则，官方文档是这么描述的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TUIwYRFv83CPlLqZ8bL8icXYu4ZWW668iaqX8fC5uphEYgibb01l0D0TNw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里，按照上面的格式&lt;/p>
&lt;p>修改后的 so 名为：libcaiji.so&lt;/p>
&lt;p>配置文件的名字为：libcaiji.config.so&lt;/p>
&lt;p>配置文件代码如下&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;interaction&amp;#34;: {
  &amp;#34;type&amp;#34;: &amp;#34;script&amp;#34;,
  &amp;#34;path&amp;#34;: &amp;#34;/data/local/tmp/hook.js&amp;#34;
}
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89Tmrlibj8ICSiaco3KJkZicTrId6VlWKuHYa7tCwFSLa04k4gdqW3x0rASQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里虽然后缀名是 .so   内容其实是 json 配置文件，这点要注意&lt;/p>
&lt;p>4&lt;/p>
&lt;p>编写注入 js&lt;/p>
&lt;p>原 apk 的代码如下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TIHiakndZr8HXMLupicxNyy13IkpCKnAXPjCnugkIwTa2MiaX3Se1mxDLA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>apk 正常运行是这样的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89Tq7IeDsibZfxJkFcSv5LjicwapEas8iblWSkL9wIGx0bI8cMUTSenjtTMg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里   编写一个注入的 js&lt;/p>
&lt;p>把 弹窗显示的  aaa 改成 bbb&lt;/p>
&lt;p>这里 直接 hook &lt;strong>com.wangtietou.no_root.MainActivity&lt;/strong> 的 &lt;strong>aaa&lt;/strong> 方法&lt;/p>
&lt;p>改下返回值就可以了&lt;/p>
&lt;p>hook.js   代码如下&lt;/p>
&lt;pre tabindex="0">&lt;code>var str_name_class = &amp;#34;com.wangtietou.no_root.MainActivity&amp;#34;;
Java.perform(function()
{
   var obj = Java.use(str_name_class);
   obj.aaa.implementation = function ()
  {
       return &amp;#34;bbb&amp;#34;;
  }
});
&lt;/code>&lt;/pre>&lt;p>写完 js 把注入脚本放到之前配置的路径下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TgBTmgQtpwgdUvhAAeVrqnCgS7GAu2Jk5AsL6qIty7RWKiaGMyjNENibg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里 /data/local/tmp/hook.js&lt;/p>
&lt;p>是之前配置文件配置过的路径&lt;/p>
&lt;p>一定要写对，不然，找不到执行的 js, 怎么 hook ，凉凉&lt;/p>
&lt;p>5&lt;/p>
&lt;p>打包签名新 apk 执行&lt;/p>
&lt;p>这里把 改名后的 frida-gadget.so 和 配置文件， 放到 lib 下面 &lt;strong>libnative-lib.so&lt;/strong> 同级目录&lt;/p>
&lt;p>再压缩&lt;/p>
&lt;p>然后签名&lt;/p>
&lt;p>就可以了&lt;/p>
&lt;p>这里没有修改 dex 文件 也没有修改 AndroidManifest.xml 所以并不用使用 apktool 重新打包&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TG1haUMsx3hyeSC63aVMPduwYE0gTrRkic2HtKMKuq1miaS4dLhTW4FvQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>把修改后的 apk 目录   压缩一下就可以了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TaOE1nIJaUTTGhPdVAbZHKpOyWum0tQSmiaPoSFRuq8uxK7FqSw3OMtQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>搞完后 用 apktoolbox 重新签个名就 ojbk 了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TCQgWmRFrzFv98NgVGAG1ySVyic9MPFF7QdpvLWFG6SIa6pKtiaCgA8qA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89TpmWBp6DFrzcB8AO5aYH1V0CZJtYw7WLnYlzh9SpicxUGAPcDxomlJFQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>安装 app 执行 看一下效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/iaZmLGkOncrIOytnicwdymn8nict7UicT89Tys1icBmyMlQIiaOG86gmhq3EGticvPAcnIZYicRaBFjgrZvMeEPXyGeCjQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>bingo, 成功在没有 root 的手机上用 frida 进行了 hook&lt;/p>
&lt;p>6&lt;/p>
&lt;p>结束语&lt;/p>
&lt;p>上面搞了这么多，实际上还有更简单的办法&lt;/p>
&lt;p>有大佬早就写好了一键脚本&lt;/p>
&lt;p>文章地址：https://bbs.pediy.com/thread-268175.htm&lt;/p>
&lt;p>脚本地址：https://github.com/nszdhd1/UtilScript/&lt;/p>
&lt;p>只不过，脚本用起来不太灵活。&lt;/p>
&lt;p>&lt;strong>我准备把脚本改改，让脚本用起来更方便。&lt;/strong>&lt;/p>
&lt;p>搞完会分享给大佬们的。&lt;/p>
&lt;p>这个文章用到的所有文件，&lt;strong>周末会录个视频，然后一起发上去。&lt;/strong>&lt;/p>
&lt;p>以上。&lt;/p>
&lt;p>王某某   2021.0903 于十平米出租屋。&lt;/p>
&lt;p>关于作者：&lt;/p>
&lt;p>一个乙方安全公司搬砖的菜鸡，移动安全从业者。&lt;/p>
&lt;p>最近忙着找女票，忙着在 b 站当扑街 up 主。&lt;/p>
&lt;p>b 站 / 公众号  :  移动安全王铁头&lt;/p>
&lt;p>希望和大佬们一起学习，一起成长&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/D1XGIISrRhKQksamIGXRxFbSQuNUWamJYEUwU8KjhNprqa8STuc02vIUak808dBS7Fiao4hg6FS876bicD3uJPgQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/hib5mZ2t0cdTmGAgkySPqAr20oBpFicUtQaleTGbgBdnvlIjH1SRficZ0YseibXwjTN5qd6npxn5QvTVN35MV9v86w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>点个&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/t3ZJ9oCd1YcJavCa7NoYkIDPhAtHQg5pOlFhHYic59ia9ic2gQGkZFHurrA63iaQeCbCHjial8ZW4XEd1HhOLZj3btQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在看&lt;/p>
&lt;p>你最好看&lt;/p></description></item><item><title>getByte 算法分析与还原 - SeeFlowerX</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://blog.seeflower.dev/archives/54/" target="_blank" rel="noopener">blog.seeflower.dev&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Be patient.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>Lilac，又名：&lt;a href="https://blog.csdn.net/qq_38851536" target="_blank" rel="noopener">白龙~&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>龙哥往往一语中的，给我带来了莫大的帮助，非常感谢&lt;/p>
&lt;p>本文旨在对 getByte 算法进行分析与还原，仅供学习交流&lt;/p>
&lt;p>本文不会提供完整算法脚本&lt;/p>
&lt;p>本文将涉及以下内容：&lt;/p>
&lt;ul>
&lt;li>OLLVM 虚假控制流 (OLLVM-BCF) 反混淆&lt;/li>
&lt;li>cutter 反编译&lt;/li>
&lt;li>md5 算法识别&lt;/li>
&lt;li>SHA256 算法还原——魔数修改&lt;/li>
&lt;li>Salsa20 算法还原——逻辑魔改&lt;/li>
&lt;li>trace_natives 与 frida-trace 搭配使用&lt;/li>
&lt;li>findhash 使用&lt;/li>
&lt;li>gettimeofday 和 lrand48&lt;/li>
&lt;li>~unidbg 模拟调用 (下一篇文章)~&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>！！！为了节省版面，文章中重复的 hook 代码会省略掉，复现时请记得自行补充&lt;/strong>&lt;/p>
&lt;table>&lt;thead>&lt;tr>&lt;th>名称&lt;/th>&lt;th>物料&lt;/th>&lt;th>补充&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>目标方法&lt;/td>&lt;td>getByte&lt;/td>&lt;td>-&lt;/td>&lt;/tr>&lt;tr>&lt;td>目标类&lt;/td>&lt;td>com.tencent.starprotocol.ByteData&lt;/td>&lt;td>-&lt;/td>&lt;/tr>&lt;tr>&lt;td>目标 so&lt;/td>&lt;td>libpoxy_star.so&lt;/td>&lt;td>md5: 889415fb8e886dfdc3fdd405c105d262&lt;/td>&lt;/tr>&lt;tr>&lt;td>目标 apk&lt;/td>&lt;td>com.tencent.qqlive_V8.3.95.26016.apk&lt;/td>&lt;td>md5: 6d6cd9c0b36c49f17d0f204cf917774e&lt;/td>&lt;/tr>&lt;tr>&lt;td>frida-server&lt;/td>&lt;td>&lt;a href="https://github.com/frida/frida/releases/tag/14.2.18" target="_blank">frida-server-14.2.18-android-arm64&lt;/a>&lt;/td>&lt;td>-&lt;/td>&lt;/tr>&lt;tr>&lt;td>python&lt;/td>&lt;td>3.8.5&lt;/td>&lt;td>由 miniconda 创建&lt;/td>&lt;/tr>&lt;tr>&lt;td>IDA&lt;/td>&lt;td>IDA Pro 7.5&lt;/td>&lt;td>&lt;a href="https://down.52pojie.cn/Tools/Disassemblers/IDA_Pro_v7.5_Portable.zip" target="_blank">爱盘地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>CyberChef&lt;/td>&lt;td>CyberChef&lt;/td>&lt;td>&lt;a href="https://gchq.github.io/CyberChef" target="_blank">在线地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>findhash&lt;/td>&lt;td>findhash&lt;/td>&lt;td>&lt;a href="https://github.com/Pr0214/findhash" target="_blank">Github 地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>trace_natives&lt;/td>&lt;td>trace_natives&lt;/td>&lt;td>&lt;a href="https://github.com/Pr0214/trace_natives" target="_blank">Github 地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>jnitrace&lt;/td>&lt;td>jnitrace&lt;/td>&lt;td>&lt;a href="https://github.com/chame1eon/jnitrace" target="_blank">Github 地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>JNI-Frida-Hook&lt;/td>&lt;td>JNI-Frida-Hook&lt;/td>&lt;td>&lt;a href="https://github.com/Areizen/JNI-Frida-Hook" target="_blank">Github 地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>hook_RegisterNatives&lt;/td>&lt;td>hook_RegisterNatives&lt;/td>&lt;td>&lt;a href="https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_RegisterNatives.js" target="_blank">Github 地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>cutter&lt;/td>&lt;td>cutter&lt;/td>&lt;td>&lt;a href="https://cutter.re/" target="_blank">官方地址&lt;/a>&lt;/td>&lt;/tr>&lt;tr>&lt;td>测试 ROM&lt;/td>&lt;td>QQ1B.200205.002&lt;/td>&lt;td>&lt;del>能跑 frida 就行&lt;/del>&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>
&lt;ul>
&lt;li>物料 &lt;a href="https://gofile.io/d/bqu3Hd" target="_blank" rel="noopener">https://gofile.io/d/bqu3Hd&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="算法稳定主动调用">算法稳定主动调用&lt;/h2>
&lt;p>此处稳定意为固定输入、固定输出&lt;/p>
&lt;h3 id="获取输入输出参数">获取输入输出参数&lt;/h3>
&lt;p>已知目标方法是&lt;code>com.tencent.starprotocol.ByteData.getByte&lt;/code>，要触发这个地方的调用很简单，APP 随便打开一个视频即可&lt;/p>
&lt;p>首先用 objection 看一眼&lt;/p>
&lt;pre tabindex="0">&lt;code>android hooking watch class_method com.tencent.starprotocol.ByteData.getByte --dump-args --dump-return
&lt;/code>&lt;/pre>&lt;p>结果如下（部分参数已和谐）&lt;/p>
&lt;pre tabindex="0">&lt;code>(agent) [466367] Called com.tencent.starprotocol.ByteData.getByte(android.content.Context, long, long, long, long, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
(agent) [466367] Arguments com.tencent.starprotocol.ByteData.getByte(com.tencent.qqlive.ona.base.QQLiveApplicationWrapper@bdbc6ce, 1, 0, 0, 0, [Ljava.lang.String;@6e859e6, , ce****************************b2, [B@a368b27)
(agent) [466367] Return Value: [object Object]
&lt;/code>&lt;/pre>&lt;p>显然 objection 不能直接得到全部参数具体内容，需要手动写个 hook 脚本&lt;/p>
&lt;p>首先准备两个 hexdump 函数&lt;/p>
&lt;pre tabindex="0">&lt;code>function jhexdump(array) {
if(!array) return;
console.log(&amp;#34;---------jhexdump start---------&amp;#34;);
var ptr = Memory.alloc(array.length);
for(var i = 0; i &amp;lt; array.length; ++i)
Memory.writeS8(ptr.add(i), array[i]);
console.log(hexdump(ptr, {offset: 0, length: array.length, header: false, ansi: false}));
console.log(&amp;#34;---------jhexdump end---------&amp;#34;);
}
function dumpByteArray(obj){
console.log(&amp;#34;---------dumpByteArray start---------&amp;#34;);
let obj_ptr = ptr(obj.$h).readPointer();
let buf_ptr = obj_ptr.add(Process.pointerSize * 3);
let size = obj_ptr.add(Process.pointerSize * 2).readU32();
console.log(hexdump(buf_ptr, {offset: 0, length: size, header: false, ansi: false}));
console.log(&amp;#34;---------dumpByteArray end---------&amp;#34;);
}
&lt;/code>&lt;/pre>&lt;p>打印参数&lt;/p>
&lt;p>e.g. &lt;code>frida -U -n com.tencent.qqlive -l agent/poxy_star.js -o agent/poxy_star.log&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>function getByte_LogArgs(){
Java.perform(function(){
let gson = Java.use(&amp;#39;com.google.gson.Gson&amp;#39;);
let ByteDataCls = Java.use(&amp;#34;com.tencent.starprotocol.ByteData&amp;#34;);
ByteDataCls.getByte.overload(&amp;#34;android.content.Context&amp;#34;, &amp;#34;long&amp;#34;, &amp;#34;long&amp;#34;, &amp;#34;long&amp;#34;, &amp;#34;long&amp;#34;, &amp;#34;java.lang.Object&amp;#34;, &amp;#34;java.lang.Object&amp;#34;, &amp;#34;java.lang.Object&amp;#34;, &amp;#34;java.lang.Object&amp;#34;).implementation = function(context, num1, num2, num3, num4, obj1, obj2, obj3, obj4){
console.log(context, num1, num2, num3, num4);
console.log(&amp;#34;obj1&amp;#34;, obj1.$className, gson.$new().toJson(obj1))
console.log(&amp;#34;obj2&amp;#34;, obj2.$className, gson.$new().toJson(obj2))
console.log(&amp;#34;obj3&amp;#34;, obj3.$className, gson.$new().toJson(obj3))
console.log(&amp;#34;obj4&amp;#34;, obj4.$className, gson.$new().toJson(obj4))
dumpByteArray(obj4);
let resp = this.getByte(context, num1, num2, num3, num4, obj1, obj2, obj3, obj4)
jhexdump(resp);
return resp
}
})
}
setImmediate(getByte_LogArgs);
&lt;/code>&lt;/pre>&lt;p>点击视频，得到下面的结果&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_00-06-26.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_00-06-26.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>参数拿到后就可以开始主动调用了&lt;/p>
&lt;h3 id="frida-稳定主动调用">frida 稳定主动调用&lt;/h3>
&lt;p>经过测试，发现传入参数固定，返回结果并不固定，这是因为原算法用到了 &lt;strong>lrand48&lt;/strong> 和 &lt;strong>gettimeofday&lt;/strong>&lt;/p>
&lt;p>这是怎么发现的呢&lt;/p>
&lt;p>~&lt;strong>当然是根据经验测出来的&lt;/strong>~&lt;/p>
&lt;p>一般遇到传入参数固定但是结果变化，统统往&lt;strong>时间&lt;/strong>、&lt;strong>随机数&lt;/strong>上靠&lt;/p>
&lt;p>这里先认为是假设，下面进行验证&lt;/p>
&lt;h4 id="固定-lrand48-和-gettimeofday-返回">固定 lrand48 和 gettimeofday 返回&lt;/h4>
&lt;p>&lt;strong>lrand48&lt;/strong> 定义如下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_10-58-22.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_10-58-22.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>那么这里直接将返回设置位&lt;code>7&lt;/code>&lt;/p>
&lt;p>这里提一点，为了和其他可能为 0 的参数进行区分，建议这里&lt;strong>尽量不要设置为 0&lt;/strong>&lt;/p>
&lt;p>&lt;strong>gettimeofday&lt;/strong> 定义如下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-12-21.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-12-21.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>定义函数 int gettimeofday (struct timeval &lt;em>tv, struct timezone&lt;/em> tz);&lt;br>
函数说明 gettimeofday() 会把目前的时间有 tv 所指的结构返回，当地时区的信息则放到 tz 所指的结构中。&lt;/p>
&lt;/blockquote>
&lt;p>类型信息&lt;/p>
&lt;pre tabindex="0">&lt;code>typedef long __kernel_long_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_suseconds_t;
struct timeval {
__kernel_time_t tv_sec;
__kernel_suseconds_t tv_usec;
};
&lt;/code>&lt;/pre>&lt;p>根据上述信息，那么只需要在 &lt;strong>gettimeofday&lt;/strong> 返回时向参数一写入两个 long 类型的数即可，分别代表秒数、微秒数&lt;/p>
&lt;h4 id="验证">验证&lt;/h4>
&lt;p>另外对于图中马赛克的参数，经过测试，确定改变它们不影响最终结果，后面使用特定固定值&lt;/p>
&lt;p>于是编写如下完整的稳定主动调用脚本&lt;/p>
&lt;pre tabindex="0">&lt;code>function freeze_funcs(){
let lrand48_addr = Module.findExportByName(&amp;#34;libc.so&amp;#34;, &amp;#34;lrand48&amp;#34;);
Interceptor.attach(lrand48_addr, {onLeave: function(retval){retval.replace(7)}});
let tm_s = 1626403551;
let tm_us = 5151606;
let gettimeofday_addr = Module.findExportByName(&amp;#34;libc.so&amp;#34;, &amp;#34;gettimeofday&amp;#34;);
Interceptor.attach(gettimeofday_addr, {
onEnter: function(args) {
this.tm_ptr = args[0];
},
onLeave:function(retval){
this.tm_ptr.writeLong(tm_s);
this.tm_ptr.add(0x4).writeLong(tm_us);
}
});
}
function call_getByte(){
Java.perform(function(){
let LongCls = Java.use(&amp;#34;java.lang.Long&amp;#34;);
let StringCls = Java.use(&amp;#34;java.lang.String&amp;#34;);
let ReflectArrayCls = Java.use(&amp;#39;java.lang.reflect.Array&amp;#39;)
let ByteDataCls = Java.use(&amp;#34;com.tencent.starprotocol.ByteData&amp;#34;);
let ctx = Java.use(&amp;#39;android.app.ActivityThread&amp;#39;).currentApplication().getApplicationContext();
let num_1 = LongCls.$new(1).longValue();
let num_2 = LongCls.$new(0).longValue();
let num_3 = LongCls.$new(0).longValue();
let num_4 = LongCls.$new(0).longValue();
let obj1 = ReflectArrayCls.newInstance(StringCls.class, 9);
ReflectArrayCls.set(obj1, 0, &amp;#34;dl_10303&amp;#34;);
ReflectArrayCls.set(obj1, 1, &amp;#34;1&amp;#34;);
ReflectArrayCls.set(obj1, 2, &amp;#34;66666666666666666666666666666666&amp;#34;);
ReflectArrayCls.set(obj1, 3, &amp;#34;getCKey&amp;#34;);
ReflectArrayCls.set(obj1, 4, &amp;#34;888888888888888888888888888888888888&amp;#34;);
ReflectArrayCls.set(obj1, 5, &amp;#34;1626403551515&amp;#34;);
ReflectArrayCls.set(obj1, 6, &amp;#34;&amp;#34;);
ReflectArrayCls.set(obj1, 7, &amp;#34;8.3.95.26016&amp;#34;);
ReflectArrayCls.set(obj1, 8, &amp;#34;com.tencent.qqlive&amp;#34;);
let obj2 = StringCls.$new(&amp;#34;&amp;#34;);
let obj3 = StringCls.$new(&amp;#34;66666666666666666666666666666666&amp;#34;);
let obj4 = Java.array(&amp;#39;B&amp;#39;, [49,54,50,54,52,48,51,53,53,49,44,110,48,48,51,57,101,121,49,109,109,100,44,110,117,108,108]);
let ByteDataIns = ByteDataCls.getInstance()
let byte = ByteDataIns.getByte(ctx, num_1, num_2, num_3, num_4, obj1, obj2, obj3, obj4);
jhexdump(byte);
Interceptor.detachAll();
})
}
freeze_funcs();
call_getByte();
&lt;/code>&lt;/pre>&lt;p>现在得到固定的返回了&lt;/p>
&lt;pre tabindex="0">&lt;code>---------jhexdump start---------
b6abddd8 68 65 68 61 00 00 00 01 01 00 00 00 00 00 00 00 heha............
b6abdde8 00 00 00 03 08 00 00 00 00 44 a7 2c da 00 00 00 .........D.,....
b6abddf8 01 00 00 00 96 00 01 00 08 00 00 01 7a ad 34 cb ............z.4.
b6abde08 37 00 02 00 0a 68 68 68 68 68 68 69 69 69 68 00 7....hhhhhhiiih.
b6abde18 03 00 04 01 00 00 01 00 05 00 04 01 00 00 01 00 ................
b6abde28 04 00 04 00 00 00 00 00 06 00 04 01 00 00 04 00 ................
b6abde38 07 00 04 01 00 00 02 00 08 00 04 01 00 00 03 00 ................
b6abde48 09 00 20 45 4f 2a db 77 40 90 33 9f e2 58 8c 2f .. EO*.w@.3..X./
b6abde58 c6 4a 3d ce 7a c7 30 7d ce ac 0b aa b6 18 b3 6f .J=.z.0}.......o
b6abde68 41 74 d3 00 0a 00 10 cd b5 df 89 f5 2d 25 05 4b At..........-%.K
b6abde78 85 81 f6 cf af 1e fb 00 0b 00 10 fb 08 ad 5f af .............._.
b6abde88 a8 93 35 2d 13 cb 93 27 e8 f7 fd ..5-...&amp;#39;...
---------jhexdump end---------
&lt;/code>&lt;/pre>&lt;h2 id="so-分析准备">so 分析准备&lt;/h2>
&lt;p>通过反编译 apk，可以知道&lt;code>getByte&lt;/code>是一个 native 函数，熟练打开 IDA、拖入 so、搜索导出函数&lt;/p>
&lt;p>不好意思，没有&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-36-11.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-36-11.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>再看看字符串&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-07.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-07.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>动态注册跑不了了&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-58.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-58.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>直接就是 &lt;a href="https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_RegisterNatives.js" target="_blank" rel="noopener">&lt;strong>hook_RegisterNatives&lt;/strong>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>[RegisterNatives] java_class: com.tencent.starprotocol.ByteData name: getByte sig: (Landroid/content/Context;JJJJLjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)[B fnPtr: 0x90c969ad module_name: libpoxy_star.so module_base: 0x90c89000 offset: 0xd9ad
[RegisterNatives] java_class: com.tencent.starprotocol.ByteData name: putByte sig: (Landroid/content/Context;JJJJLjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)I fnPtr: 0x90caa995 module_name: libpoxy_star.so module_base: 0x90c89000 offset: 0x21995
&lt;/code>&lt;/pre>&lt;p>好了，让我们看看&lt;code>sub_D9AC&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-49-09.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-49-09.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>似乎有点麻烦，很多分支&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>此刻是不是头都大了，再看看 so 大小，828KB，发现了什么没有&lt;/p>
&lt;p>就动态注册了两个方法，并且没有其他静态注册的方法，so 文件却如此之大&lt;/p>
&lt;p>显然 so 有混淆&lt;/p>
&lt;p>好在反编译代码中有迹可循，可以看到反编译结果有很多下面这样的判断&lt;/p>
&lt;pre tabindex="0">&lt;code>((dword_C2C04 ^ dword_C2C08 ^ 0x100011AA) &amp;amp; 0x5120FBAA) == -1964041611
&lt;/code>&lt;/pre>&lt;p>如果你经验丰富，一眼就能看出来这是 &lt;strong>BCF(Bogus Control Flow)&lt;/strong>，即虚假控制流&lt;/p>
&lt;p>~吐槽：我是算法还原完了才知道这个点，哎，心累&amp;hellip;~&lt;/p>
&lt;h3 id="ollvm-bcf-反混淆">OLLVM-BCF 反混淆&lt;/h3>
&lt;p>这烦人的 BCF 自然是有方案处理的，具体请参考下面这篇文章&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bbs.pediy.com/thread-257213.htm" target="_blank" rel="noopener">Hex-Rays: 十步杀一人，两步秒 OLLVM-BCF&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>简单来说就是将 data 段数据的&lt;code>Write&lt;/code>属性去掉，然后重新 F5 即可，IDA 会自动完成 BCF 的优化&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-02-25.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-02-25.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>这是优化后的结果，是不是非常非常清晰了&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-05-08.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-05-08.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>知道这个操作后，简直事半功倍，基本上不用去手动 hook 确定走向了&lt;/p>
&lt;p>看雪还有一些关于 BCF 反混淆的文章，经过测试还是 IDA 来的快，效果相对更好&amp;hellip;&lt;/p>
&lt;h3 id="cutter-搭配使用">cutter 搭配使用&lt;/h3>
&lt;p>即使进行了 BCF 反混淆操作&lt;/p>
&lt;p>IDA 反编译出来的代码阅读有些问题，比如看不懂变量传递关系&lt;/p>
&lt;p>表现为函数传入参数在确定要走的那个分支里面没有被直接或者间接调用&lt;/p>
&lt;p>好在 cutter 的反编译结果至少是能看出来的&lt;/p>
&lt;p>以&lt;code>sub_AA924&lt;/code>为例&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-19-09.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-19-09.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>大致可以推测出来数据处理在最后一个 case 进行&lt;/p>
&lt;p>但是&lt;code>*(_BYTE *)(*v10 + *v8)&lt;/code>和 a1 什么关系实在是看不懂，v5 和 a1 又有什么关系？&lt;/p>
&lt;p>这也许要直接阅读汇编代码才能看出其中关系了，或者这是某种特定的形式&lt;/p>
&lt;p>实在不行也可以 hook 来确定，毕竟动态的是准确的&lt;/p>
&lt;p>或者这是一个我还没学习到的知识点&lt;/p>
&lt;p>好在 cutter 可以帮上忙&lt;/p>
&lt;p>根据下图的标注，可以知道 a1 就是&lt;code>piStack44&lt;/code>了&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-37-11.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-37-11.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>而对于后面的&lt;code>puStack52&lt;/code>，也能根据下面的标注推测出每一轮 + 1，等于是挨个取 a1 处的内容&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-39-46.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-39-46.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>如果只看 IDA，可能就比较懵了&amp;hellip;&lt;/p>
&lt;p>所以搭配使用效果更佳&lt;/p>
&lt;h2 id="返回结果追踪定位">返回结果追踪定位&lt;/h2>
&lt;p>按照常规思路，一般是看 native 函数的返回，然后追踪结果的生成过程&lt;/p>
&lt;p>先打印一波 so 的结果&lt;/p>
&lt;pre tabindex="0">&lt;code>function jbhexdump(array) {
console.log(&amp;#34;---------jbhexdump start---------&amp;#34;);
let env = Java.vm.getEnv();
let size = env.getArrayLength(array);
let data = env.getByteArrayElements(array);
console.log(hexdump(data, {offset: 0, length: size, header: false, ansi: false}));
env.releaseByteArrayElements(array, data, 0);
console.log(&amp;#34;---------jbhexdump end---------&amp;#34;);
}
function inline_hook(){
let base_addr = Module.getBaseAddress(&amp;#34;libpoxy_star.so&amp;#34;);
Interceptor.attach(base_addr.add(0xD9AC).add(1), {
onLeave: function (retval) {
console.log(`onLeave sub_D9AC`);
jbhexdump(retval);
}
});
}
freeze_funcs();
inline_hook();
call_getByte();
&lt;/code>&lt;/pre>&lt;p>日志如下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-24-29.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-24-29.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;strong>一 模 一 样&lt;/strong>&lt;/p>
&lt;p>是否反向查看函数，挨个跟踪定位算法呢，答案是否&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-29-11.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-29-11.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>在已经有 BCF 反混淆的加持下，依然可以看到函数嵌套函数，如果没有足够的精力，可能是难以定位算法的&lt;/p>
&lt;p>既然 so 结尾返回的是 jbyteArray，那么可以通过 hook SetByteArrayRegion 实现快速定位&lt;/p>
&lt;h3 id="jnitrace-定位-setbytearrayregion-调用">jnitrace 定位 SetByteArrayRegion 调用&lt;/h3>
&lt;p>jnitrace 如果以 spawn 模式可能难以追踪，这里采用 attach 模式&lt;/p>
&lt;p>具体操作是打开 APP 后一小会儿执行命令，同时注意脚本中主动调用时机&lt;/p>
&lt;pre tabindex="0">&lt;code>jnitrace -l libpoxy_star.so -m attach -a poxy_star.js com.tencent.qqlive
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://blog.seeflower.dev/images/oCam_2021_07_16_13_56_04_790.gif" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/oCam_2021_07_16_13_56_04_790.gif" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>可以看到有一个&lt;code>SetByteArrayRegion&lt;/code>内容和最终结果一样，地址是 &lt;strong>0x13d79&lt;/strong>&lt;/p>
&lt;p>另外可以通过&lt;code>-o&lt;/code>选项设置追踪结果&lt;/p>
&lt;p>这就是调用的位置了，位于&lt;code>sub_13C7C&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-03-00.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-03-00.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h3 id="更优雅的-jni-追踪">更优雅的 jni 追踪&lt;/h3>
&lt;p>前面提到可以直接用 jnitrace 进行 jni 函数调用追踪，但是不太方便&lt;/p>
&lt;p>只想在主动调用某个函数之间进行追踪怎么办呢&lt;/p>
&lt;p>参考&lt;code>JNI-Frida-Hook&lt;/code>这个项目，可以发现实现原理很简单，拿到 jni 函数的地址然后 hook 就行了&lt;/p>
&lt;p>下面是一个简单的案例，这样会灵活很多&lt;/p>
&lt;pre tabindex="0">&lt;code>let jni_struct_array = [
&amp;#34;reserved0&amp;#34;, &amp;#34;reserved1&amp;#34;, &amp;#34;reserved2&amp;#34;, &amp;#34;reserved3&amp;#34;, &amp;#34;GetVersion&amp;#34;, &amp;#34;DefineClass&amp;#34;, &amp;#34;FindClass&amp;#34;, &amp;#34;FromReflectedMethod&amp;#34;, &amp;#34;FromReflectedField&amp;#34;, &amp;#34;ToReflectedMethod&amp;#34;, &amp;#34;GetSuperclass&amp;#34;, &amp;#34;IsAssignableFrom&amp;#34;, &amp;#34;ToReflectedField&amp;#34;, &amp;#34;Throw&amp;#34;, &amp;#34;ThrowNew&amp;#34;,
&amp;#34;ExceptionOccurred&amp;#34;, &amp;#34;ExceptionDescribe&amp;#34;, &amp;#34;ExceptionClear&amp;#34;, &amp;#34;FatalError&amp;#34;, &amp;#34;PushLocalFrame&amp;#34;, &amp;#34;PopLocalFrame&amp;#34;, &amp;#34;NewGlobalRef&amp;#34;, &amp;#34;DeleteGlobalRef&amp;#34;, &amp;#34;DeleteLocalRef&amp;#34;, &amp;#34;IsSameObject&amp;#34;, &amp;#34;NewLocalRef&amp;#34;, &amp;#34;EnsureLocalCapacity&amp;#34;, &amp;#34;AllocObject&amp;#34;, &amp;#34;NewObject&amp;#34;,
&amp;#34;NewObjectV&amp;#34;, &amp;#34;NewObjectA&amp;#34;, &amp;#34;GetObjectClass&amp;#34;, &amp;#34;IsInstanceOf&amp;#34;, &amp;#34;GetMethodID&amp;#34;, &amp;#34;CallObjectMethod&amp;#34;, &amp;#34;CallObjectMethodV&amp;#34;, &amp;#34;CallObjectMethodA&amp;#34;, &amp;#34;CallBooleanMethod&amp;#34;, &amp;#34;CallBooleanMethodV&amp;#34;, &amp;#34;CallBooleanMethodA&amp;#34;, &amp;#34;CallByteMethod&amp;#34;, &amp;#34;CallByteMethodV&amp;#34;,
&amp;#34;CallByteMethodA&amp;#34;, &amp;#34;CallCharMethod&amp;#34;, &amp;#34;CallCharMethodV&amp;#34;, &amp;#34;CallCharMethodA&amp;#34;, &amp;#34;CallShortMethod&amp;#34;, &amp;#34;CallShortMethodV&amp;#34;, &amp;#34;CallShortMethodA&amp;#34;, &amp;#34;CallIntMethod&amp;#34;, &amp;#34;CallIntMethodV&amp;#34;, &amp;#34;CallIntMethodA&amp;#34;, &amp;#34;CallLongMethod&amp;#34;, &amp;#34;CallLongMethodV&amp;#34;, &amp;#34;CallLongMethodA&amp;#34;,
&amp;#34;CallFloatMethod&amp;#34;, &amp;#34;CallFloatMethodV&amp;#34;, &amp;#34;CallFloatMethodA&amp;#34;, &amp;#34;CallDoubleMethod&amp;#34;, &amp;#34;CallDoubleMethodV&amp;#34;, &amp;#34;CallDoubleMethodA&amp;#34;, &amp;#34;CallVoidMethod&amp;#34;, &amp;#34;CallVoidMethodV&amp;#34;, &amp;#34;CallVoidMethodA&amp;#34;, &amp;#34;CallNonvirtualObjectMethod&amp;#34;, &amp;#34;CallNonvirtualObjectMethodV&amp;#34;,
&amp;#34;CallNonvirtualObjectMethodA&amp;#34;, &amp;#34;CallNonvirtualBooleanMethod&amp;#34;, &amp;#34;CallNonvirtualBooleanMethodV&amp;#34;, &amp;#34;CallNonvirtualBooleanMethodA&amp;#34;, &amp;#34;CallNonvirtualByteMethod&amp;#34;, &amp;#34;CallNonvirtualByteMethodV&amp;#34;, &amp;#34;CallNonvirtualByteMethodA&amp;#34;, &amp;#34;CallNonvirtualCharMethod&amp;#34;,
&amp;#34;CallNonvirtualCharMethodV&amp;#34;, &amp;#34;CallNonvirtualCharMethodA&amp;#34;, &amp;#34;CallNonvirtualShortMethod&amp;#34;, &amp;#34;CallNonvirtualShortMethodV&amp;#34;, &amp;#34;CallNonvirtualShortMethodA&amp;#34;, &amp;#34;CallNonvirtualIntMethod&amp;#34;, &amp;#34;CallNonvirtualIntMethodV&amp;#34;, &amp;#34;CallNonvirtualIntMethodA&amp;#34;,
&amp;#34;CallNonvirtualLongMethod&amp;#34;, &amp;#34;CallNonvirtualLongMethodV&amp;#34;, &amp;#34;CallNonvirtualLongMethodA&amp;#34;, &amp;#34;CallNonvirtualFloatMethod&amp;#34;, &amp;#34;CallNonvirtualFloatMethodV&amp;#34;, &amp;#34;CallNonvirtualFloatMethodA&amp;#34;, &amp;#34;CallNonvirtualDoubleMethod&amp;#34;, &amp;#34;CallNonvirtualDoubleMethodV&amp;#34;,
&amp;#34;CallNonvirtualDoubleMethodA&amp;#34;, &amp;#34;CallNonvirtualVoidMethod&amp;#34;, &amp;#34;CallNonvirtualVoidMethodV&amp;#34;, &amp;#34;CallNonvirtualVoidMethodA&amp;#34;, &amp;#34;GetFieldID&amp;#34;, &amp;#34;GetObjectField&amp;#34;, &amp;#34;GetBooleanField&amp;#34;, &amp;#34;GetByteField&amp;#34;, &amp;#34;GetCharField&amp;#34;, &amp;#34;GetShortField&amp;#34;, &amp;#34;GetIntField&amp;#34;,
&amp;#34;GetLongField&amp;#34;, &amp;#34;GetFloatField&amp;#34;, &amp;#34;GetDoubleField&amp;#34;, &amp;#34;SetObjectField&amp;#34;, &amp;#34;SetBooleanField&amp;#34;, &amp;#34;SetByteField&amp;#34;, &amp;#34;SetCharField&amp;#34;, &amp;#34;SetShortField&amp;#34;, &amp;#34;SetIntField&amp;#34;, &amp;#34;SetLongField&amp;#34;, &amp;#34;SetFloatField&amp;#34;, &amp;#34;SetDoubleField&amp;#34;, &amp;#34;GetStaticMethodID&amp;#34;,
&amp;#34;CallStaticObjectMethod&amp;#34;, &amp;#34;CallStaticObjectMethodV&amp;#34;, &amp;#34;CallStaticObjectMethodA&amp;#34;, &amp;#34;CallStaticBooleanMethod&amp;#34;, &amp;#34;CallStaticBooleanMethodV&amp;#34;, &amp;#34;CallStaticBooleanMethodA&amp;#34;, &amp;#34;CallStaticByteMethod&amp;#34;, &amp;#34;CallStaticByteMethodV&amp;#34;, &amp;#34;CallStaticByteMethodA&amp;#34;,
&amp;#34;CallStaticCharMethod&amp;#34;, &amp;#34;CallStaticCharMethodV&amp;#34;, &amp;#34;CallStaticCharMethodA&amp;#34;, &amp;#34;CallStaticShortMethod&amp;#34;, &amp;#34;CallStaticShortMethodV&amp;#34;, &amp;#34;CallStaticShortMethodA&amp;#34;, &amp;#34;CallStaticIntMethod&amp;#34;, &amp;#34;CallStaticIntMethodV&amp;#34;, &amp;#34;CallStaticIntMethodA&amp;#34;, &amp;#34;CallStaticLongMethod&amp;#34;,
&amp;#34;CallStaticLongMethodV&amp;#34;, &amp;#34;CallStaticLongMethodA&amp;#34;, &amp;#34;CallStaticFloatMethod&amp;#34;, &amp;#34;CallStaticFloatMethodV&amp;#34;, &amp;#34;CallStaticFloatMethodA&amp;#34;, &amp;#34;CallStaticDoubleMethod&amp;#34;, &amp;#34;CallStaticDoubleMethodV&amp;#34;, &amp;#34;CallStaticDoubleMethodA&amp;#34;, &amp;#34;CallStaticVoidMethod&amp;#34;,
&amp;#34;CallStaticVoidMethodV&amp;#34;, &amp;#34;CallStaticVoidMethodA&amp;#34;, &amp;#34;GetStaticFieldID&amp;#34;, &amp;#34;GetStaticObjectField&amp;#34;, &amp;#34;GetStaticBooleanField&amp;#34;, &amp;#34;GetStaticByteField&amp;#34;, &amp;#34;GetStaticCharField&amp;#34;, &amp;#34;GetStaticShortField&amp;#34;, &amp;#34;GetStaticIntField&amp;#34;, &amp;#34;GetStaticLongField&amp;#34;,
&amp;#34;GetStaticFloatField&amp;#34;, &amp;#34;GetStaticDoubleField&amp;#34;, &amp;#34;SetStaticObjectField&amp;#34;, &amp;#34;SetStaticBooleanField&amp;#34;, &amp;#34;SetStaticByteField&amp;#34;, &amp;#34;SetStaticCharField&amp;#34;, &amp;#34;SetStaticShortField&amp;#34;, &amp;#34;SetStaticIntField&amp;#34;, &amp;#34;SetStaticLongField&amp;#34;, &amp;#34;SetStaticFloatField&amp;#34;,
&amp;#34;SetStaticDoubleField&amp;#34;, &amp;#34;NewString&amp;#34;, &amp;#34;GetStringLength&amp;#34;, &amp;#34;GetStringChars&amp;#34;, &amp;#34;ReleaseStringChars&amp;#34;, &amp;#34;NewStringUTF&amp;#34;, &amp;#34;GetStringUTFLength&amp;#34;, &amp;#34;GetStringUTFChars&amp;#34;, &amp;#34;ReleaseStringUTFChars&amp;#34;, &amp;#34;GetArrayLength&amp;#34;, &amp;#34;NewObjectArray&amp;#34;, &amp;#34;GetObjectArrayElement&amp;#34;,
&amp;#34;SetObjectArrayElement&amp;#34;, &amp;#34;NewBooleanArray&amp;#34;, &amp;#34;NewByteArray&amp;#34;, &amp;#34;NewCharArray&amp;#34;, &amp;#34;NewShortArray&amp;#34;, &amp;#34;NewIntArray&amp;#34;, &amp;#34;NewLongArray&amp;#34;, &amp;#34;NewFloatArray&amp;#34;, &amp;#34;NewDoubleArray&amp;#34;, &amp;#34;GetBooleanArrayElements&amp;#34;, &amp;#34;GetByteArrayElements&amp;#34;, &amp;#34;GetCharArrayElements&amp;#34;,
&amp;#34;GetShortArrayElements&amp;#34;, &amp;#34;GetIntArrayElements&amp;#34;, &amp;#34;GetLongArrayElements&amp;#34;, &amp;#34;GetFloatArrayElements&amp;#34;, &amp;#34;GetDoubleArrayElements&amp;#34;, &amp;#34;ReleaseBooleanArrayElements&amp;#34;, &amp;#34;ReleaseByteArrayElements&amp;#34;, &amp;#34;ReleaseCharArrayElements&amp;#34;, &amp;#34;ReleaseShortArrayElements&amp;#34;,
&amp;#34;ReleaseIntArrayElements&amp;#34;, &amp;#34;ReleaseLongArrayElements&amp;#34;, &amp;#34;ReleaseFloatArrayElements&amp;#34;, &amp;#34;ReleaseDoubleArrayElements&amp;#34;, &amp;#34;GetBooleanArrayRegion&amp;#34;, &amp;#34;GetByteArrayRegion&amp;#34;, &amp;#34;GetCharArrayRegion&amp;#34;, &amp;#34;GetShortArrayRegion&amp;#34;, &amp;#34;GetIntArrayRegion&amp;#34;,
&amp;#34;GetLongArrayRegion&amp;#34;, &amp;#34;GetFloatArrayRegion&amp;#34;, &amp;#34;GetDoubleArrayRegion&amp;#34;, &amp;#34;SetBooleanArrayRegion&amp;#34;, &amp;#34;SetByteArrayRegion&amp;#34;, &amp;#34;SetCharArrayRegion&amp;#34;, &amp;#34;SetShortArrayRegion&amp;#34;, &amp;#34;SetIntArrayRegion&amp;#34;, &amp;#34;SetLongArrayRegion&amp;#34;, &amp;#34;SetFloatArrayRegion&amp;#34;,
&amp;#34;SetDoubleArrayRegion&amp;#34;, &amp;#34;RegisterNatives&amp;#34;, &amp;#34;UnregisterNatives&amp;#34;, &amp;#34;MonitorEnter&amp;#34;, &amp;#34;MonitorExit&amp;#34;, &amp;#34;GetJavaVM&amp;#34;, &amp;#34;GetStringRegion&amp;#34;, &amp;#34;GetStringUTFRegion&amp;#34;, &amp;#34;GetPrimitiveArrayCritical&amp;#34;, &amp;#34;ReleasePrimitiveArrayCritical&amp;#34;, &amp;#34;GetStringCritical&amp;#34;,
&amp;#34;ReleaseStringCritical&amp;#34;, &amp;#34;NewWeakGlobalRef&amp;#34;, &amp;#34;DeleteWeakGlobalRef&amp;#34;, &amp;#34;ExceptionCheck&amp;#34;, &amp;#34;NewDirectByteBuffer&amp;#34;, &amp;#34;GetDirectBufferAddress&amp;#34;, &amp;#34;GetDirectBufferCapacity&amp;#34;, &amp;#34;GetObjectRefType&amp;#34;
]
function getJNIFunctionAdress(func_name){
let jnienv_addr = Java.vm.getEnv().handle.readPointer()
let offset = jni_struct_array.indexOf(func_name) * Process.pointerSize;
return Memory.readPointer(jnienv_addr.add(offset))
}
function hook_jni(func_name){
let listener = null;
switch (func_name){
case &amp;#34;SetByteArrayRegion&amp;#34;:
listener = Interceptor.attach(getJNIFunctionAdress(func_name), {
onEnter: function(args){
console.log(`env-&amp;gt;${func_name} called from ${Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&amp;#34;\n&amp;#34;)}`);
this.arg_array = args[1];
},
onLeave: function(retval){
jbhexdump(this.arg_array);
console.log(&amp;#34;SetByteArrayRegion onLeave&amp;#34;);
}
})
default:
listener = Interceptor.attach(getJNIFunctionAdress(func_name), {
onEnter: function(args){
console.log(`env-&amp;gt;${func_name} called from ${Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&amp;#34;\n&amp;#34;)}`);
}
})
}
return listener;
}
function inline_hook(){
let base_addr = Module.getBaseAddress(&amp;#34;libpoxy_star.so&amp;#34;);
Interceptor.attach(base_addr.add(0xD9AC).add(1), {
onEnter: function(args){
this.hook_jni_interceptor = hook_jni(&amp;#34;SetByteArrayRegion&amp;#34;);
},
onLeave: function (retval) {
this.hook_jni_interceptor.detach();
console.log(`onLeave sub_D9AC`);
jbhexdump(retval);
}
});
}
freeze_funcs();
inline_hook();
call_getByte();
&lt;/code>&lt;/pre>&lt;p>这样追踪更方便，符合需求，输出结果如下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-26-48.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-26-48.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h2 id="返回结果反向推导与追踪">返回结果反向推导与追踪&lt;/h2>
&lt;p>那就这个时候开始反向追踪了吗&lt;/p>
&lt;p>不，让我们把它的调用流程图也弄出来&lt;/p>
&lt;p>祭出 &lt;a href="https://github.com/Pr0214/trace_natives" target="_blank" rel="noopener">&lt;strong>trace_natives&lt;/strong>&lt;/a>，导入 IDA 插件，拿到要 trace 的函数列表&lt;/p>
&lt;p>&lt;strong>frida-trace&lt;/strong> 一把梭，注意，为了得到调用层次分明的日志，这里直接重定向到文件&lt;/p>
&lt;pre tabindex="0">&lt;code>frida-trace -UF -O libpoxy_star_1626418239.txt &amp;gt; star_trace.log
&lt;/code>&lt;/pre>&lt;p>建议先执行一次上面的命令，让它自动生成 js，停掉&lt;/p>
&lt;p>然后去目标 js 加一个返回时的日志打印，再重新运行&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-58-37.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-58-37.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>第一次执行命令的时候比较慢，因为要生成 js，后面就很快了&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-55-24.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-55-24.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>然后执行主动调用脚本&lt;/p>
&lt;p>得到记录后，找到添加的返回日志，把进入&lt;code>sub_D9AD&lt;/code>到这里之间的内容单独拿出来&lt;/p>
&lt;p>为什么这里是&lt;code>sub_D9AD&lt;/code>而不是&lt;code>sub_D9AC&lt;/code>请查阅 trace_natives 的 README&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-03-43.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-03-43.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>去除不相关的记录后依然有 1w + 行&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-10-00.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-10-00.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>当然还有办法精简，前面已经知道在进入&lt;code>sub_13C7C&lt;/code>的时候，就已经产生最终结果了&lt;/p>
&lt;p>那么只要&lt;code>sub_13C7C&lt;/code>之前的记录即可&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-12-41.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-12-41.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>很好，现在只剩 1000 + 的记录了&lt;/p>
&lt;p>根据调用记录，可以大致确定&lt;code>sub_13C7C&lt;/code>由&lt;code>sub_11AC0&lt;/code>调用&lt;/p>
&lt;p>另外发现&lt;code>sub_11AC0&lt;/code>所在位置非常靠前，说明它应该是运算的核心位置&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-15-03.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-15-03.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-18-46.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-18-46.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>现在可以反向追踪了，先看下最后这几个函数&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-23-35.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-23-35.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>并没有什么有用的信息，再往前是一个比较长的调用&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-25-21.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-25-21.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;code>sub_ABD9C&lt;/code>中只有两个函数调用&lt;/p>
&lt;ul>
&lt;li>&lt;code>sub_ABDBC&lt;/code>&lt;/li>
&lt;li>&lt;code>sub_AAE88&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-27-42.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-27-42.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>这个时候，先看看参数内容，因为很有可能&lt;code>sub_AAE88&lt;/code>之前就已经出现最终结果了&lt;/p>
&lt;p>如果是这样就可以不分析&lt;code>sub_AAE88&lt;/code>了&lt;/p>
&lt;p>hook 代码如下&lt;/p>
&lt;pre tabindex="0">&lt;code>function inline_hook(){
let hook_flag = false;
let base_addr = Module.getBaseAddress(&amp;#34;libpoxy_star.so&amp;#34;);
Interceptor.attach(base_addr.add(0xD9AC).add(1), {
onEnter: function(args){
hook_flag = true;
this.hook_jni_interceptor = hook_jni(&amp;#34;SetByteArrayRegion&amp;#34;);
},
onLeave: function (retval) {
hook_flag = false;
this.hook_jni_interceptor.detach();
console.log(`onLeave sub_D9AC`);
jbhexdump(retval);
}
});
Interceptor.attach(base_addr.add(0xAAE88).add(1), {
onEnter: function (args) {
if(hook_flag){
console.log(`call sub_AAE88`);
this.arg_0 = args[0];
console.log(&amp;#34;sub_AAE88 arg_0&amp;#34;, hexdump(args[0].readPointer()));
}
},
onLeave: function (retval) {
console.log(&amp;#34;sub_AAE88 onLeave arg_0&amp;#34;, hexdump(this.arg_0.readPointer()));
}
});
Interceptor.attach(base_addr.add(0xABDBC).add(1), {
onEnter: function (args) {
if(hook_flag){
console.log(`call sub_ABDBC`);
this.arg_0 = args[0];
console.log(&amp;#34;sub_ABDBC arg_0&amp;#34;, hexdump(args[0].readPointer()));
}
},
onLeave: function (retval) {
console.log(&amp;#34;sub_ABDBC onLeave arg_0&amp;#34;, hexdump(this.arg_0.readPointer()));
}
});
}
&lt;/code>&lt;/pre>&lt;p>通过对比可以发现进入&lt;code>sub_AAE88&lt;/code>时数据头部还不完整，但是后面的部分是一致的&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-37-27.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-37-27.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>仔细观察头部数据发现三个可疑点&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-41-53.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-41-53.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>首先是前四个字节，这会不会是什么校验呢&lt;/p>
&lt;p>答案是否，可以通过变化传入参数确定这个位置是固定值&lt;/p>
&lt;p>其次是 0x96，为何怀疑它，因为根据经验，一字节或两字节不为 0 前面为 0 的数据，很可能是后面数据的长度&lt;/p>
&lt;blockquote>
&lt;p>0x96 = 150 = 11 + 8 * 16 + 11&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>96&lt;/code>起到&lt;code>f7 d0&lt;/code>这里，长度刚好是 150，那没跑了，就是长度值&lt;/p>
&lt;p>剩下一个&lt;code>44 a7 2c da&lt;/code>，这有可能是什么呢&lt;/p>
&lt;p>逆向常常需要靠经验和猜测，既然确定 0x96 是长度，那它后面应该就是一个完整的数据块&lt;/p>
&lt;p>那么猜测它是后面数据的校验，提到数据校验，相信大家都会想到 &lt;strong>CRC32&lt;/strong>&lt;/p>
&lt;p>用 &lt;strong>CyberChef&lt;/strong> 验证一下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-51-39.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-51-39.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>猜测正确&lt;/p>
&lt;p>那么头部前面还有一些&lt;code>01 02 03 00&lt;/code>可能是什么呢&lt;/p>
&lt;p>首先在最开始已经将随机数固定为&lt;code>7&lt;/code>了，那么基本可以排除它们和随机数无关&lt;/p>
&lt;p>可能是时间吗，显然可能性不大，而且可以通过变化传入参数，可以发现除了 CRC32 部分，其他内容不变&lt;/p>
&lt;p>这样一来可以推测是一些固定或者变化比较简单的运算，那么先把它放一边吧&lt;/p>
&lt;p>现在分析&lt;code>sub_ABDBC&lt;/code>函数&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-57-43.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-57-43.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>可以看到里面有好几个重复函数，不多说，直接 hook 看参数内容&lt;/p>
&lt;p>先看&lt;code>sub_AC214&lt;/code>，参数内容都比较简单&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-00-47.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-00-47.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>然后是&lt;code>sub_AD1D0&lt;/code>，参数内容也是最终结果里面的&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-21-36.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-21-36.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>根据以上信息，除去头部，对照内容后整理如下&lt;/p>
&lt;table>&lt;thead>&lt;tr>&lt;th>tag&lt;/th>&lt;th>length&lt;/th>&lt;th>payload&lt;/th>&lt;th>func&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>00 01&lt;/td>&lt;td>00 08&lt;/td>&lt;td>00 00 01 7a ad 34 cb 37&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 02&lt;/td>&lt;td>00 0a&lt;/td>&lt;td>68 68 68 68 68 68 69 69 69 68&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 03&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 01&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 05&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 01&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 04&lt;/td>&lt;td>00 04&lt;/td>&lt;td>00 00 00 00&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 06&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 04&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 07&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 02&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 08&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 03&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 09&lt;/td>&lt;td>00 20&lt;/td>&lt;td>45 4f 2a db 77 40 90 33 9f e2 58 8c 2f c6 4a 3d ce 7a c7 30 7d ce ac 0b aa b6 18 b3 6f 41 74 d3&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 0a&lt;/td>&lt;td>00 10&lt;/td>&lt;td>cd b5 df 89 f5 2d 25 05 4b 85 81 f6 cf af 1e fb&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 0b&lt;/td>&lt;td>00 10&lt;/td>&lt;td>fb 08 ad 5f af a8 93 35 2d 13 cb 93 27 e8 f7 fd&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>
&lt;p>&lt;strong>第一个参数&lt;/strong>是什么呢，通过测试可以发现当&lt;code>gettimeofday&lt;/code>返回固定，这个值就固定&lt;/p>
&lt;p>是不是和时间有关系呢，答案是 yes&lt;/p>
&lt;blockquote>
&lt;p>0x0000017aad34cb37 = 1626403556151&lt;/p>
&lt;/blockquote>
&lt;p>固定的时间代码片段如下&lt;/p>
&lt;pre tabindex="0">&lt;code>let tm_s = 1626403551;
let tm_us = 5151606;
&lt;/code>&lt;/pre>&lt;p>Q: 似乎有些对不上，这是什么问题呢&lt;br>
A: tm_us 是微秒，显然这里是 5.151606s，超过 1s 了&lt;/p>
&lt;p>将&lt;code>tm_us&lt;/code>改为&lt;code>151606&lt;/code>，重新整理&lt;/p>
&lt;table>&lt;thead>&lt;tr>&lt;th>tag&lt;/th>&lt;th>length&lt;/th>&lt;th>payload&lt;/th>&lt;th>func&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>00 01&lt;/td>&lt;td>00 08&lt;/td>&lt;td>00 00 01 7a ad 34 b7 af&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 02&lt;/td>&lt;td>00 0a&lt;/td>&lt;td>68 68 68 68 68 68 69 69 69 68&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 03&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 01&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 05&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 01&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 04&lt;/td>&lt;td>00 04&lt;/td>&lt;td>00 00 00 00&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 06&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 04&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 07&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 02&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 08&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 03&lt;/td>&lt;td>sub_AC214&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 09&lt;/td>&lt;td>00 20&lt;/td>&lt;td>ab a3 29 3c be 3f 85 56 42 c6 91 8c 0c e8 e2 a6 06 16 ff 83 47 44 ca c3 26 6d 6f 0c e4 3e c6 64&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 0a&lt;/td>&lt;td>00 10&lt;/td>&lt;td>ea 36 73 53 c0 ac 2f 60 c7 96 68 ee f1 36 2d 3b&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 0b&lt;/td>&lt;td>00 10&lt;/td>&lt;td>23 9e 8e 64 9b 2d 17 c7 56 af 13 57 d9 46 5d 41&lt;/td>&lt;td>sub_AD1D0&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-42-44.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-42-44.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;strong>第二个参数&lt;/strong>是什么呢，通过变化传入参数等，观察结果可以知道是 lrand48 相关的&lt;/p>
&lt;p>即原始数据应该是&lt;code>aaaaaabbba&lt;/code>，它们的 ascii 码加上随机数就是第二个参数了&lt;/p>
&lt;p>&lt;strong>第三到八个参数&lt;/strong>是什么呢，通过变化传入参数，可以确定任何参数都与它们无关，它们都是固定值&lt;/p>
&lt;p>&lt;strong>第九个参数&lt;/strong>是什么呢，观察长度，发现它是 64 位的，并且变化随机数、时间都会引起改变&lt;/p>
&lt;ul>
&lt;li>修改时间的末尾三位不影响第九个参数&lt;/li>
&lt;li>修改 getByte 除&lt;code>obj4&lt;/code>外的参数不影响第九个参数&lt;/li>
&lt;/ul>
&lt;p>那么说明这个参数和随机数、时间、obj4 相关&lt;/p>
&lt;p>obj4 长度 27，随机数看第二个参数应该是有 10 个，时间长度是 8，加起来长度 45&lt;/p>
&lt;p>结果是 64 位，那么是 AES 吗，答案是否，因为 AES 结果必然是 16 整数倍，而&lt;/p>
&lt;blockquote>
&lt;p>45 + 16 &amp;lt; 64&lt;/p>
&lt;/blockquote>
&lt;p>所以基本排除掉 AES，那么还有什么是 32 位呢&lt;/p>
&lt;p>如果你经验丰富，那么肯定会想到 &lt;strong>SHA256&lt;/strong> 在输入参数小于 64 的时候结果必然是 64 位&lt;/p>
&lt;p>当然并不排除其他可能性，但目前看 &lt;strong>SHA256&lt;/strong> 可能性最高&lt;/p>
&lt;p>&lt;strong>第十和十一个参数又是什么呢&lt;/strong>，对剩下的函数一一查看，结果如下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-12-30.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-12-30.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>可以看出基本上和最后三个参数没有什么关系，32 位的话那么可能的算法就很多了，最值得怀疑的当然是最常见的 md5 了&lt;/p>
&lt;p>虽然暂时不知道第九、十、十一参数算法，但是到这里&lt;code>sub_ABDBC&lt;/code>完成分析了&lt;/p>
&lt;p>那么现在应该看&lt;code>sub_ABD9C&lt;/code>之前的函数了，即&lt;code>sub_139A4&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-17-20.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-17-20.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(base_addr.add(0x139A4).add(1), {
onLeave: function (retval) {
console.log(&amp;#34;sub_139A4 retval&amp;#34;, retval.readPointer());
}
});
&lt;/code>&lt;/pre>&lt;p>通过测试发现它的返回结果是&lt;code>sub_ABDBC&lt;/code>的参数一，也就是放最终结果的地址&lt;/p>
&lt;p>反编译代码中也没有其他特殊处理，那么可以跳过这个函数了&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-22-20.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-22-20.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>然后看&lt;code>sub_AFAC4&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-25-55.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-25-55.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>也和结果没有什么关系&lt;/p>
&lt;p>再往前看，可以发现是一个比较长的调用，这个函数就是&lt;code>sub_5BF0&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-26-58.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-26-58.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>该函数主要调用了三个函数，&lt;code>sub_6794&lt;/code>和&lt;code>sub_68DC&lt;/code>和&lt;code>sub_691C&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-28-53.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-28-53.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>先简单看下对应的反编译代码，发现前两个是 jni 相关的调用，最后一个&lt;code>sub_691C&lt;/code>比较复杂&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-37-30.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-37-30.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>不管那么多，先把&lt;code>sub_691C&lt;/code>的参数 hook 一下看看&lt;/p>
&lt;p>然后并没有发现什么特别的东西&amp;hellip;&lt;/p>
&lt;p>进入&lt;code>sub_691C&lt;/code>很快就会进入一个非常长的调用，结合之前猜测的 SHA256 和 md5，这里极有可能是两者之一&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-42-43.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-42-43.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>是时候祭出 &lt;a href="https://github.com/Pr0214/findhash" target="_blank" rel="noopener">&lt;strong>findhash&lt;/strong>&lt;/a> 了，运行插件，最终结果如下&lt;/p>
&lt;pre tabindex="0">&lt;code>***************************在二进制文件中检索hash算法常量************************************
0xc9d3c:padding used in hashing algorithms (0x80 0 ... 0)
0xbd8bc:SHA256 / SHA224 K tabke
0x33ff9:函数sub_33FF8疑似哈希函数运算部分。
0x68d09:函数sub_68D08疑似哈希函数，包含初始化魔数的代码。
0x82485:函数sub_82484疑似哈希函数，包含初始化魔数的代码。
0x99a35:函数sub_99A34疑似哈希函数，包含初始化魔数的代码。
0xaae89:函数sub_AAE88疑似哈希函数，包含初始化魔数的代码。
***************************存在以下可疑的字符串************************************
0xbd1a0:/proc/self/cmdline
0xbd56c:/proc/self/cmdline
0xbda25:/proc/self/cmdline
***********************************************************************************
花费 41.270039081573486 秒，因为会对全部函数反编译，所以比较耗时间哈
&lt;/code>&lt;/pre>&lt;p>对比调用日志，发现&lt;code>sub_68D08&lt;/code>和&lt;code>sub_82484&lt;/code>就在其中&lt;/p>
&lt;p>另外&lt;code>sub_AAE88&lt;/code>已经分析过了，这里检测到的应该是 &lt;strong>CRC32&lt;/strong>&lt;/p>
&lt;p>先看看大量被调用的&lt;code>sub_BB1A0&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-51-28.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-51-28.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>原来和算法无关&amp;hellip; 那把它去除掉&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-49-18.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-49-18.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;code>sub_82484&lt;/code>离&lt;code>sub_691C&lt;/code>不是很远，&lt;code>sub_68D08&lt;/code>则稍微后面一点&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-55-24.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-55-24.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-56-15.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-56-15.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>那现在优先看看它们，&lt;code>sub_82484&lt;/code>这显然是 SHA256 的魔数&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-57-30.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-57-30.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>为什么这么说呢，对比标准的 SHA256 算法就知道了嘛&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-00-09.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-00-09.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>经过对比可以知道 init 这里的魔数有些不一样&lt;/p>
&lt;p>插件还提示了&lt;code>0xbd8bc:SHA256 / SHA224 K tabke&lt;/code>，看一下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-01-32.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-01-32.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>经过对比发现 K 表没有改变，另外发现 K 表就在 init 之后被使用&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-03-24.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-03-24.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>基本上可以推测是只改了魔数的 SHA256 算法，现在看看&lt;code>sub_862B4&lt;/code>&lt;/p>
&lt;p>对比下一般的调用，是不是一模一样呢&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-08-06.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-08-06.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-07-07.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-07-07.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>把数据和返回 hook 一下&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(base_addr.add(0x82648).add(1), {
onEnter: function (args) {
console.log(`call sub_82648`);
console.log(&amp;#34;arg_1&amp;#34;, hexdump(args[1].readByteArray(args[2].toUInt32())))
console.log(&amp;#34;arg_2&amp;#34;, args[2].toUInt32())
}
});
Interceptor.attach(base_addr.add(0x84890).add(1), {
onEnter: function (args) {
this.arg_1 = args[1];
},
onLeave: function (retval) {
console.log(`sub_84890 onLeave`);
console.log(&amp;#34;arg_1&amp;#34;, hexdump(this.arg_1))
}
});
&lt;/code>&lt;/pre>&lt;p>确认无误&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-15-09.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-15-09.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>算法还原参考 &lt;strong>SHA256 算法还原&lt;/strong>小节，确认是仅修改了魔数的 SHA256 算法&lt;/p>
&lt;p>但是传入数据显然还不是明文，来看看&lt;code>sub_862B4&lt;/code>的调用函数&lt;code>sub_864F0&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-24-09.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-24-09.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>可以看到只有两个 memcpy 动作，应该不涉及数据的修改&lt;/p>
&lt;p>再看&lt;code>sub_864F0&lt;/code>的调用函数&lt;code>sub_85A40&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-26-09.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-26-09.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>没错，连续调用了两次&lt;code>sub_864F0&lt;/code>，而&lt;code>sub_864F0&lt;/code>内会调用&lt;code>sub_862B4&lt;/code>等做 SHA256 运算&lt;/p>
&lt;p>再看下 hook 结果，可以看出第一轮的 SHA256 结果被放到了第二轮 SHA256 的明文末尾&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-28-30.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-28-30.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>另外第一轮明文和第二轮明文中有大量重复的字符，是&lt;code>sub_85A40&lt;/code>里面的明文字符串&lt;/p>
&lt;pre tabindex="0">&lt;code>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\6666666666666666666666666666666666666666666666666666666666666666
&lt;/code>&lt;/pre>&lt;p>这两个字符的 ASCII 分别是 0x5C 和 0x36&lt;/p>
&lt;p>另外还能观察到第二轮明文里面的重复字符前面是 0x14 长度，刚好是 10 位&lt;/p>
&lt;p>综合上述信息，可以推测实际上这是一个&lt;code>HMAC-SHA256&lt;/code>算法，搜一个标准实现&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-44-37.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-44-37.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>这个可能看起来不太清晰，看这个&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/bitcoin/bitcoin/blob/master/src/crypto/hmac_sha256.cpp" target="_blank" rel="noopener">https://github.com/bitcoin/bitcoin/blob/master/src/crypto/hmac_sha256.cpp&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-47-11.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-47-11.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>另外还有部分异或操作，另外可以确定没有走这里的&lt;code>sub_862B4&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-52-42.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-52-42.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>现在看看传入参数，可以看到&lt;code>sub_85A40&lt;/code>的 a2 应该是有内容的&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-07-42.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-07-42.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>并且后面和 v20 相与，根据这一点来看，属于稍稍修改过的&lt;code>HMAC-SHA256&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-09-25.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-09-25.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>看看&lt;code>sub_85A40&lt;/code>的 a2 是什么吧&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-11-36.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-11-36.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>刚好它是 0x14 长度，这和前面提到的那个内容匹配上了&lt;/p>
&lt;p>再看看其他参数&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(base_addr.add(0x85A40).add(1), {
onEnter: function (args) {
console.log(`call sub_85A40`);
console.log(&amp;#34;sub_85A40 arg_1&amp;#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
console.log(&amp;#34;sub_85A40 arg_2&amp;#34;, args[2]);
console.log(&amp;#34;sub_85A40 arg_3&amp;#34;, hexdump(args[3].readByteArray(args[4].toUInt32())));
console.log(&amp;#34;sub_85A40 arg_4&amp;#34;, args[4]);
}
});
&lt;/code>&lt;/pre>&lt;p>出现了熟悉的内容，a2 应该是 key，a4 应该是明文&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-25-21.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-25-21.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-27-26.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-27-26.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>综合上述信息，可以进行还原了，具体参见 &lt;strong>HMAC-SHA256 算法还原&lt;/strong>小节&lt;/p>
&lt;p>至此参数九算法还原完成&lt;/p>
&lt;p>上面都是基于&lt;code>sub_82484&lt;/code>函数所推导的内容，现在可以看&lt;code>sub_68D08&lt;/code>了，毕竟它也是被怀疑的哈希函数&lt;/p>
&lt;p>查看反编译代码，显然这应该是一个 md5 函数，并且没有更改魔数&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-34-13.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-34-13.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>根据调用记录和已有信息，有理由推断就是这两个位置计算了出 md5 作为最终结果的&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-35-30.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-35-30.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>查看&lt;code>sub_9DB88&lt;/code>，又是熟悉的样式&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-39-33.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-39-33.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(base_addr.add(0x68E44).add(1), {
onEnter: function (args) {
console.log(`call sub_68E44`);
console.log(&amp;#34;sub_68E44 arg_1&amp;#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
console.log(&amp;#34;sub_68E44 arg_2&amp;#34;, args[2]);
}
});
Interceptor.attach(base_addr.add(0x6D628).add(1), {
onEnter: function (args) {
this.arg_0 = args[0];
},
onLeave: function (retval) {
console.log(&amp;#34;sub_6D628 retval&amp;#34;, hexdump(this.arg_0));
}
});
&lt;/code>&lt;/pre>&lt;p>看到了 md5 明文和返回结果&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-44-50.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-44-50.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>经过验证确定是标准的 md5&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-47-38.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-47-38.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>那么现在的问题就剩 md5 明文怎么来的了，接着看&lt;code>sub_9DB88&lt;/code>调用&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-50-54.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-50-54.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>先看&lt;code>sub_A70F4&lt;/code>，反编译代码如下，那么接着看&lt;code>sub_A605C&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-51-57.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-51-57.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>对它的参数进行 hook&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(base_addr.add(0xA605C).add(1), {
onEnter: function (args) {
console.log(`call sub_A605C`);
this.arg_6 = args[6];
console.log(&amp;#34;sub_A605C arg_1&amp;#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
console.log(&amp;#34;sub_A605C arg_2&amp;#34;, args[2]);
console.log(&amp;#34;sub_A605C arg_3&amp;#34;, args[3]);
console.log(&amp;#34;sub_A605C arg_4&amp;#34;, args[4]);
console.log(&amp;#34;sub_A605C arg_5&amp;#34;, args[5]);
console.log(&amp;#34;sub_A605C arg_6&amp;#34;, hexdump(args[6]));
console.log(&amp;#34;sub_A605C arg_7&amp;#34;, hexdump(args[7].readByteArray(args[8].toUInt32())));
console.log(&amp;#34;sub_A605C arg_8&amp;#34;, args[8]);
},
onLeave: function (retval) {
console.log(&amp;#34;sub_A605C retval&amp;#34;, hexdump(this.arg_6));
}
});
&lt;/code>&lt;/pre>&lt;p>结果如下，可以看到有一个 0x14 长度的 key，即 HMAC-SHA256 用到的 key&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-01-55.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-01-55.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>0x23 长度的明文内容，返回结果就是后续 md5 的内容&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-05-12.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-05-12.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>那么现在参数十一的运算逻辑如下&lt;/p>
&lt;blockquote>
&lt;p>结果 = md5(转换函数 (明文 + key))&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>sub_A605C&lt;/code>涉及两个运算，一个是&lt;code>sub_A4550&lt;/code>，另外是一些位运算&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-08-45.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-08-45.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;code>sub_A4550&lt;/code>反编译结果如下，看起来想某种算法，经过检索，最终可以确定是 &lt;strong>Salsa20&lt;/strong> 算法&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-15-12.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-15-12.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>魔数如下，不过对比标准算法后发现有很大差异&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-17-04.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-17-04.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://botan.randombit.net/doxygen/salsa20_8cpp_source.html" target="_blank" rel="noopener">https://botan.randombit.net/doxygen/salsa20_8cpp_source.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个代码看着可能吃力，可以看这个版本的&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/Daeinar/salsa20/blob/master/salsa.py" target="_blank" rel="noopener">https://github.com/Daeinar/salsa20/blob/master/salsa.py&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>差异表现为以下几点&lt;/p>
&lt;ul>
&lt;li>
&lt;p>state 数组的顺序不一样&lt;/p>
&lt;/li>
&lt;li>
&lt;p>_round 运算内的逻辑不一样，表现为&lt;/p>
&lt;ul>
&lt;li>
&lt;p>原算法两个数先相加，结果循环左移，左移结果与另外的数异或&lt;/p>
&lt;/li>
&lt;li>
&lt;p>魔改算法分两种情况&lt;/p>
&lt;ul>
&lt;li>两个数相加 -&amp;gt; 结果与新的数相异或 -&amp;gt; 结果循环左移 -&amp;gt; 最终结果&lt;/li>
&lt;li>两个数相加 -&amp;gt; 结果与新的数做&lt;code>(a &amp;amp; ~b) | (b &amp;amp; ~a)&lt;/code>运算 -&amp;gt; 结果循环左移 -&amp;gt; 最终结果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>_round 运算结束后，要交换 state 内数据，魔改算法没有这个过程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>10 轮_round 运算&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>基于上述结果重写了魔改后的 Salsa20 算法，其余信息参见 &lt;strong>Salsa20 算法还原&lt;/strong>小节&lt;/p>
&lt;p>至此参数十一算是还原完成了，可能会有疑问，key 怎么来的，不急后面有&lt;/p>
&lt;p>现在开始看&lt;code>sub_9CD48&lt;/code>，也就是对应参数十的计算过程&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-30-56.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-30-56.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>根据已有信息，可以知道&lt;code>sub_9DB88&lt;/code>是 md5，那么看&lt;code>sub_9C1F0&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(base_addr.add(0x9C1F0).add(1), {
onEnter: function (args) {
console.log(`call sub_9C1F0`);
this.arg_3 = args[3];
console.log(&amp;#34;sub_9C1F0 arg_1&amp;#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
console.log(&amp;#34;sub_9C1F0 arg_2&amp;#34;, args[2]);
console.log(&amp;#34;sub_9C1F0 arg_3&amp;#34;, hexdump(args[3]));
},
onLeave: function (retval) {
console.log(&amp;#34;sub_9C1F0 retval&amp;#34;, hexdump(this.arg_3));
}
});
&lt;/code>&lt;/pre>&lt;p>似乎是明文传入，然后直接拿到了后续待 md5 的内容&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-35-45.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-35-45.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>顺便 hook 下&lt;code>sub_9B980&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>Interceptor.attach(base_addr.add(0x9B980).add(1), {
onEnter: function (args) {
console.log(`call sub_9B980`);
this.arg_0 = args[0];
console.log(&amp;#34;sub_9B980 arg_0&amp;#34;, hexdump(args[0]));
console.log(&amp;#34;sub_9B980 arg_1&amp;#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
console.log(&amp;#34;sub_9B980 arg_2&amp;#34;, args[2]);
},
onLeave: function (retval) {
console.log(&amp;#34;sub_9B980 retval&amp;#34;, hexdump(this.arg_0));
}
});
&lt;/code>&lt;/pre>&lt;p>又一个熟悉的数据出现了，同时可以看到&lt;code>sub_9B980&lt;/code>的参数一在函数结束后有了内容&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-39-10.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-39-10.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>先看看&lt;code>sub_9C1F0&lt;/code>的转换&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-47-59.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-47-59.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>可以看到主要运算就是一系列位运算，简单分析如下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-50-15.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-50-15.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>这里比较简单，现在看&lt;code>sub_9B980&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-52-03.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-52-03.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>这里和前面类似&lt;/p>
&lt;p>综合以上信息编写还原算法如下&lt;/p>
&lt;pre tabindex="0">&lt;code>def init_state(key: list):
index = 0
state = [_ for _ in range(256)]
key = (key * ((256 // len(key)) + 1))[:256]
for i in range(256):
index = (index + key[i] + state[i]) % 256
state[i], state[index] = state[index], state[i]
return state
def enccypt_data(ori_data: bytes, key: list):
state = init_state(key)
index_1 = 0
index_2 = 0
_ori_data = [0] * len(ori_data)
for offset, num in enumerate(list(ori_data)):
index_1 = (index_1 + 1) % 256
index_2 = (index_2 + state[index_1]) % 256
tmp = state[index_1]
state[index_1] = state[index_2]
state[index_2] = tmp
key_index = (state[index_2] + state[index_1]) &amp;amp; 0xff
_ori_data[offset] = (num &amp;amp; ~state[key_index]) | (state[key_index] &amp;amp; ~num)
return bytes(_ori_data)
if __name__ == &amp;#39;__main__&amp;#39;:
import binascii
import hashlib
key = binascii.a2b_hex(&amp;#39;4f274c3f286b54372a40612428095143565e3140&amp;#39;)
data = binascii.a2b_hex(&amp;#39;313632363430333535312c6e303033396579316d6d642c6e756c6c0000017aad34b7af&amp;#39;)
enc_data = enccypt_data(data, key)
assert &amp;#39;ea367353c0ac2f60c79668eef1362d3b&amp;#39; == hashlib.new(&amp;#39;md5&amp;#39;, enc_data).hexdigest(), &amp;#34;测试失败&amp;#34;
print(&amp;#39;测试成功&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>至此参数十也完成还原，现在就剩一个问题，&lt;code>4f274c3f286b54372a40612428095143565e3140&lt;/code>从何处来&lt;/p>
&lt;p>已知进行 HMAC-SHA256 转换时就出现了这个 key 了，key 是&lt;code>sub_85A40&lt;/code>的传入参数，那么接着它往前看&lt;/p>
&lt;p>结果它的调用函数&lt;code>sub_86CD4&lt;/code>再向前似乎不太一样了&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-04-02.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-04-02.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>这是怎么回事呢&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-16.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-16.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>先看看调用日志，&lt;code>sub_86CD4&lt;/code>同级前一个函数是&lt;code>sub_8D970&lt;/code>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-57.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-57.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>果然这里暗藏玄机&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-11-08.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-11-08.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;code>sub_8DB6C&lt;/code>内部则是另一个跳转，显然这里没有跳，而是跳转到&lt;code>sub_86CD4&lt;/code>了&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-12-24.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-12-24.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>看&lt;code>sub_8D970&lt;/code>的调用处，结合上面的分析，这里 v16 经过&lt;code>sub_8D970&lt;/code>后应该是拿到了&lt;code>sub_86CD4&lt;/code>地址，但是实际没有产生调用&lt;/p>
&lt;p>根据下面的 v7 定位到调用处&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-21-52.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-21-52.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>如图&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-24-04.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-24-04.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>通过 hook&lt;code>sub_86CD4&lt;/code>参数可以知道其 a2 就是 key&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-25-53.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-25-53.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>那么应该定位 ptr 来源&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-27-23.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-27-23.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>然后能找到一个相关的地方&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-28-51.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-28-51.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>对&lt;code>sub_87DD8&lt;/code>参数打印，结果如下&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-32-41.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-32-41.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>好起来了！参数二是明文，参数三在函数结束后就是 key&lt;/p>
&lt;p>&lt;code>sub_87DD8&lt;/code>内两处关键位置，注意到&lt;code>sub_89BF4&lt;/code>两次调用，且有一个参数是 10&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-35-42.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-35-42.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>通过 hook&lt;code>sub_89BF4&lt;/code>的参数，可以发现该函数的功能是将传参数二末尾两位数据移动到头部&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-41-45.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-41-45.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>然后搜索 hex 发现它是一个硬编码的 key&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-44-59.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-44-59.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-45-59.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-45-59.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>是的，它在这里&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-46-43.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-46-43.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>IDA 看半天也看不出来参数怎么来的&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-52-56.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-52-56.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>用 cutter 看看&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-55-46.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-55-46.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>很好！&lt;/p>
&lt;p>结合&lt;code>sub_87DD8&lt;/code>末尾的位运算，现在可以编写 key 转换代码了&lt;/p>
&lt;pre tabindex="0">&lt;code>def gen_key(rand_data: bytes = b&amp;#39;hhhhhhiiih&amp;#39;):
data = list(binascii.a2b_hex(&amp;#39;286b54372a4061244c3f&amp;#39;))
init_data_1 = data[-2:] + data[:-2]
data = list(binascii.a2b_hex(&amp;#39;392b3e365829264f4061&amp;#39;))
init_data_2 = data[-2:] + data[:-2]
_rand_data = [num_1 ^ num_2 for num_1, num_2 in zip(list(rand_data), list(init_data_2))]
init_data = _rand_data[-2:] + init_data_1 + _rand_data[:-2]
print(&amp;#39;key&amp;#39;, bytes(init_data).hex())
return init_data
&lt;/code>&lt;/pre>&lt;h3 id="sha256-算法还原">SHA256 算法还原&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/keanemind/Python-SHA-256" target="_blank" rel="noopener">https://github.com/keanemind/Python-SHA-256&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>将这个标准 SHA256 算法中的魔数修改，测试一下&lt;/p>
&lt;p>修改部分伪代码如下&lt;/p>
&lt;pre tabindex="0">&lt;code>def generate_hash(message: bytearray) -&amp;gt; bytearray:
h0 = 0x6A09E669
h1 = 0xBB67AE87
h2 = 0x3C6BF372
h3 = 0xA54FF53A
h5 = 0x9B25688C
h4 = 0x511E527F
h6 = 0x1F73D9AB
h7 = 0x5BD0CD19
if __name__ == &amp;#39;__main__&amp;#39;:
import binascii
data = binascii.a2b_hex(b&amp;#39;137b10637437086b761c3d7874550d1f0a026d1c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5caac3b82136d0d55907e5607db20a7da7e996d5d083c1edaa1c27252212c954ff&amp;#39;)
assert &amp;#39;aba3293cbe3f855642c6918c0ce8e2a60616ff834744cac3266d6f0ce43ec664&amp;#39; == generate_hash(data).hex(), &amp;#39;测试失败&amp;#39;
print(&amp;#39;测试成功&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>测试通过&lt;/p>
&lt;h3 id="hmac-sha256-算法还原">HMAC-SHA256 算法还原&lt;/h3>
&lt;pre tabindex="0">&lt;code>def hmac_generate_hash(init_data: bytes, ori_data: bytes):
init_data_1 = [0x36] * 64
init_data_2 = [0x5C] * 64
for index, (num_1, num_2) in enumerate(zip(init_data, init_data_1)):
init_data_1[index] = num_1 ^ num_2
for index, (num_1, num_2) in enumerate(zip(init_data, init_data_2)):
init_data_2[index] = ((num_1 &amp;amp; 0xE5) + (~num_1 &amp;amp; 0x1A)) ^ ((num_2 &amp;amp; 0xE5) + (~num_2 &amp;amp; 0x1A))
tmp_result = generate_hash(bytes(init_data_1) + ori_data)
result = generate_hash(bytes(init_data_2) + tmp_result)
return result
if __name__ == &amp;#39;__main__&amp;#39;:
import binascii
key = binascii.a2b_hex(&amp;#39;4f274c3f286b54372a40612428095143565e3140&amp;#39;)
data = binascii.a2b_hex(&amp;#39;313632363430333535312c6e303033396579316d6d642c6e756c6c0000017aad34b7af&amp;#39;)
assert &amp;#39;aba3293cbe3f855642c6918c0ce8e2a60616ff834744cac3266d6f0ce43ec664&amp;#39; == hmac_generate_hash(key, data).hex(), &amp;#39;测试失败&amp;#39;
print(&amp;#39;测试成功&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>测试通过&lt;/p>
&lt;h3 id="salsa20-算法还原">Salsa20 算法还原&lt;/h3>
&lt;p>还原不易，相信看到这里的人应该都会了，就贴个关键部分截图吧&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-26-32.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-26-32.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;h2 id="返回结果构成总结">返回结果构成总结&lt;/h2>
&lt;p>表中的明文由&lt;code>getByte传入参数obj4&lt;/code>和&lt;code>gettimeofday返回结果&lt;/code>构成&lt;/p>
&lt;p>hex 如下&lt;/p>
&lt;blockquote>
&lt;p>313632363430333535312c6e303033396579316d6d642c6e756c6c0000017aad34b7af&lt;/p>
&lt;/blockquote>
&lt;table>&lt;thead>&lt;tr>&lt;th>tag&lt;/th>&lt;th>length&lt;/th>&lt;th>payload&lt;/th>&lt;th>说明&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>68 65 68 61&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>00 00 00 01 01 00 00 00&lt;/td>&lt;td>固定值 后半部分由前半部分翻转得到&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>00 00 00 00 00&lt;/td>&lt;td>未修改&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>00 00 03 08&lt;/td>&lt;td>固定值 由 sub_175B4 产生&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>00 00 00 00&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>00 00 00 00&lt;/td>&lt;td>未修改&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>4b 46 ba a2&lt;/td>&lt;td>后续数据 CRC32&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>00 00 00 01&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>-&lt;/td>&lt;td>-&lt;/td>&lt;td>00 00 00 96&lt;/td>&lt;td>后续数据长度&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 01&lt;/td>&lt;td>00 08&lt;/td>&lt;td>00 00 01 7a ad 34 b7 af&lt;/td>&lt;td>gettimeofday&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 02&lt;/td>&lt;td>00 0a&lt;/td>&lt;td>68 68 68 68 68 68 69 69 69 68&lt;/td>&lt;td>10 位 (不完全) 随机种子&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 03&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 01&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 05&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 01&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 04&lt;/td>&lt;td>00 04&lt;/td>&lt;td>00 00 00 00&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 06&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 04&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 07&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 02&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 08&lt;/td>&lt;td>00 04&lt;/td>&lt;td>01 00 00 03&lt;/td>&lt;td>固定值&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 09&lt;/td>&lt;td>00 20&lt;/td>&lt;td>ab a3 29 3c be 3f 85 56 42 c6 91 8c 0c e8 e2 a6 06 16 ff 83 47 44 ca c3 26 6d 6f 0c e4 3e c6 64&lt;/td>&lt;td>HMAC-SHA256(随机种子 key, 明文)&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 0a&lt;/td>&lt;td>00 10&lt;/td>&lt;td>ea 36 73 53 c0 ac 2f 60 c7 96 68 ee f1 36 2d 3b&lt;/td>&lt;td>md5(数据交换运算 (随机种子 key, 明文))&lt;/td>&lt;/tr>&lt;tr>&lt;td>00 0b&lt;/td>&lt;td>00 10&lt;/td>&lt;td>23 9e 8e 64 9b 2d 17 c7 56 af 13 57 d9 46 5d 41&lt;/td>&lt;td>md5(明文 ^ (Salsa20(随机种子 key, 固定数据)))&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>
&lt;p>补充&lt;/p>
&lt;p>&lt;a href="https://blog.seeflower.dev/images/Snipaste_2021-07-16_23-11-24.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://blog.seeflower.dev/images/Snipaste_2021-07-16_23-11-24.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>其他部分固定值在&lt;code>sub_AAE88&lt;/code>产生，就不展开了&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gist.github.com/SeeFlowerX/373101e86529ae04807f634b87ac4c7c" target="_blank" rel="noopener">https://gist.github.com/SeeFlowerX/373101e86529ae04807f634b87ac4c7c&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>感谢龙哥！&lt;/p></description></item><item><title>Js Ast 二部曲：某 V5 “绝对不可逆加密” 一探究竟</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%BA%8C%E9%83%A8%E6%9B%B2%E6%9F%90-v5-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86-%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%BA%8C%E9%83%A8%E6%9B%B2%E6%9F%90-v5-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86-%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://bbs.nightteam.cn/forum.php?mod=viewthread&amp;amp;tid=1498&amp;amp;highlight=ast" target="_blank" rel="noopener">bbs.nightteam.cn&lt;/a>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1616&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>Nanda 声明：本文内容仅供学习交流，严禁用于商业用途，否则由此产生的一切后果均与作者无关，请于 24 小时内删除。
本文是前几天发的《Js Ast 一部曲：高完整度还原某 V5 的加密》的进阶，上一篇文章提到过的内容本文就不重新讲解了，所以还没看过上一篇文章的小伙伴记得先去看一下哦。
我就不说闲话了，直入主题。本文既然是进阶篇，当然要加大难度，所以，选项配置如下图，全部点亮 &amp;amp; 系数选最高。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzAzfDRjZWU4Yzk1fDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>1.png&lt;/strong> &lt;em>(137.57 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzAzfDRjZWU4Yzk1fDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>初：我们依旧先来看一下前后的对比。
还原前（格式化后 900 + 行，所以我就不展示格式化后的内容了，可以找   在线 js 格式化网站   自行格式化哦。)&lt;br>
/*&lt;br>
 *  加密工具已经升级了一个版本，目前为  sojson.v5 ，主要加强了算法，以及防破解【绝对不可逆】配置，耶稣也无法 100% 还原，我说的。;&lt;br>
 *  已经打算把这个工具基础功能一直免费下去。还希望支持我。
 *  另外  sojson.v5  已经强制加入校验，注释可以去掉，但是  sojson.v5  不能去掉（如果你开通了 VIP，可以手动去掉），其他都没有任何绑定。
 *  誓死不会加入任何后门，sojson JS  加密的使命就是为了保护你们的 Javascript 。
 *  警告：如果您恶意去掉  sojson.v5  那么我们将不会保护您的 JavaScript 代码。请遵守规则&lt;br>
 *  新版本: https://www.jsjiami.com/  支持批量加密，支持大文件加密，拥有更多加密。 &lt;em>/&lt;br>
;var encode_version = &amp;lsquo;sojson.v5&amp;rsquo;, gdear = &amp;lsquo;&amp;rsquo;,  _0x1491=[&amp;rsquo;\x77\x35\x58\x43\x6a\x33\x54\x43\x6b\x77\x77\x3d&amp;rsquo;,&amp;rsquo;\x63\x63\x4f\x6e\x4a\x56\x30\x6d&amp;rsquo;,&amp;rsquo;\x77\x36\x59\x53\x57\x38\x4f\x4f\x77\x6f\x6f\x3d&amp;rsquo;,&amp;rsquo;\x63\x73\x4f\x61\x52\x38\x4f\x6a\x4e\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x4a\x6b\x5a\x45\x41\x63\x4b\x41&amp;rsquo;,&amp;rsquo;\x77\x35\x67\x78\x62\x73\x4b\x56\x77\x72\x4d\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x56\x48\x43\x68\x44\x43\x68\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x76\x44\x6b\x79\x6e\x44\x6d\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x49\x43\x2f\x44\x6d\x6d\x44\x44\x6c\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x42\x73\x4b\x30\x4f\x46\x6e\x44\x76\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x44\x44\x75\x33\x34\x38&amp;rsquo;,&amp;rsquo;\x77\x37\x66\x43\x71\x69\x74\x43\x66\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x34\x7a\x44\x67\x63\x4b\x75\x77\x34\x74\x57&amp;rsquo;,&amp;rsquo;\x77\x6f\x30\x70\x56\x4d\x4f\x59\x77\x6f\x55\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x50\x43\x72\x38\x4b\x57\x77\x70\x78\x4d&amp;rsquo;,&amp;rsquo;\x4f\x58\x37\x44\x73\x6c\x50\x44\x74\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x73\x32\x77\x71\x44\x43\x72\x57\x45\x3d&amp;rsquo;,&amp;rsquo;\x64\x4d\x4f\x77\x42\x33\x6f\x50&amp;rsquo;,&amp;rsquo;\x4c\x55\x2f\x44\x6c\x51\x6a\x43\x69\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x34\x66\x44\x73\x6a\x6e\x44\x67\x73\x4f\x31&amp;rsquo;,&amp;rsquo;\x62\x38\x4f\x2f\x56\x4d\x4b\x76\x77\x37\x77\x3d&amp;rsquo;,&amp;rsquo;\x41\x63\x4f\x72\x77\x72\x42\x4c\x47\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x51\x6a\x7a\x44\x76\x42\x39\x78&amp;rsquo;,&amp;rsquo;\x77\x6f\x54\x44\x6b\x4d\x4f\x48\x52\x32\x55\x3d&amp;rsquo;,&amp;rsquo;\x44\x38\x4b\x2b\x4c\x73\x4f\x56\x57\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x6f\x79\x77\x37\x2f\x44\x76\x54\x38\x3d&amp;rsquo;,&amp;rsquo;\x44\x38\x4f\x71\x77\x6f\x5a\x4d\x4d\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x49\x32\x65\x4d\x4b\x42\x77\x70\x34\x3d&amp;rsquo;,&amp;rsquo;\x57\x73\x4f\x6e\x4c\x51\x62\x43\x6c\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x43\x44\x72\x43\x70\x32\x2f\x44\x67\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x64\x63\x4f\x46\x77\x36\x4c\x43\x76\x6d\x38\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x58\x44\x6b\x4d\x4b\x2b\x77\x35\x4a\x52&amp;rsquo;,&amp;rsquo;\x64\x38\x4f\x42\x56\x38\x4f\x51\x45\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x4c\x43\x6c\x67\x78\x2b\x65\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x45\x73\x4f\x6f\x77\x70\x2f\x43\x70\x73\x4b\x37&amp;rsquo;,&amp;rsquo;\x46\x63\x4f\x64\x77\x35\x6f\x78\x51\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x2f\x44\x72\x63\x4b\x46\x44\x4d\x4f\x6d&amp;rsquo;,&amp;rsquo;\x66\x38\x4f\x48\x77\x37\x4c\x43\x76\x55\x4d\x3d&amp;rsquo;,&amp;rsquo;\x62\x4d\x4b\x62\x77\x35\x68\x52\x49\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x41\x63\x4b\x6a\x77\x70\x4c\x44\x6d\x38\x4f\x6d&amp;rsquo;,&amp;rsquo;\x49\x51\x4c\x44\x73\x6b\x37\x44\x6a\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x46\x38\x4b\x6b\x77\x71\x2f\x44\x6c\x4d\x4f\x6d&amp;rsquo;,&amp;rsquo;\x77\x70\x38\x4c\x65\x6b\x67\x59&amp;rsquo;,&amp;rsquo;\x77\x37\x49\x5a\x77\x35\x59\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x50\x44\x72\x6e\x30\x3d&amp;rsquo;,&amp;rsquo;\x41\x4d\x4b\x6d\x77\x70\x73\x3d&amp;rsquo;,&amp;rsquo;\x64\x6a\x6e\x44\x71\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x65\x47\x66\x43\x6f\x53\x7a\x44\x76\x48\x55\x2b\x77\x6f\x33\x43\x72\x63\x4b\x64\x77\x35\x42\x43\x4a\x7a\x66\x44\x67\x6d\x50\x43\x6a\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x50\x38\x4f\x42\x77\x36\x63\x36\x5a\x4d\x4f\x6a&amp;rsquo;,&amp;rsquo;\x49\x6d\x31\x79&amp;rsquo;,&amp;rsquo;\x77\x70\x48\x44\x71\x63\x4f\x4e&amp;rsquo;,&amp;rsquo;\x42\x4d\x4b\x47\x77\x6f\x77\x3d&amp;rsquo;,&amp;rsquo;\x35\x59\x69\x44\x36\x5a\x69\x6f\x35\x34\x75\x45\x35\x70\x32\x66\x35\x59\x2b\x2f\x37\x37\x32\x70\x41\x38\x4f\x51\x35\x4c\x79\x49\x35\x61\x79\x37\x35\x70\x32\x51\x35\x62\x2b\x38\x35\x36\x69\x6d&amp;rsquo;,&amp;rsquo;\x77\x72\x6a\x43\x6d\x53\x78\x37\x77\x36\x5a\x37&amp;rsquo;,&amp;rsquo;\x5a\x63\x4f\x63\x77\x70\x6f\x3d&amp;rsquo;,&amp;rsquo;\x43\x77\x50\x43\x76\x58\x6e\x44\x74\x63\x4b\x32\x77\x36\x48\x44\x6d\x73\x4b\x49\x58\x55\x73\x33\x77\x6f\x4e\x63\x77\x6f\x66\x44\x75\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x70\x66\x43\x72\x63\x4f\x33\x66\x38\x4b\x6a\x77\x6f\x73\x65\x77\x70\x52\x34\x4e\x4d\x4f\x61\x43\x73\x4f\x64\x77\x35\x58\x44\x67\x63\x4b\x43\x66\x45\x5a\x65\x52\x31\x49\x39\x61\x69\x4a\x79\x4a\x73\x4b\x77\x77\x35\x72\x43\x6d\x73\x4f\x68\x77\x71\x48\x44\x6d\x4d\x4f\x42\x77\x72\x73\x2f\x77\x35\x72\x43\x67\x73\x4b\x6c\x77\x35\x42\x59\x77\x35\x4c\x43\x70\x46\x70\x35\x48\x31\x62\x43\x68\x6c\x35\x66\x77\x37\x50\x44\x67\x38\x4b\x55\x77\x35\x72\x43\x6d\x4d\x4f\x74\x54\x73\x4b\x31\x4f\x45\x2f\x43\x70\x30\x6f\x46&amp;rsquo;,&amp;rsquo;\x77\x37\x62\x44\x6d\x44\x50\x44\x6d\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x54\x63\x4f\x4c\x41\x55\x55\x51&amp;rsquo;,&amp;rsquo;\x50\x55\x46\x43\x46\x45\x49\x3d&amp;rsquo;,&amp;rsquo;\x46\x41\x44\x44\x72\x31\x54\x44\x75\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x70\x62\x43\x69\x52\x4a\x6c\x77\x35\x34\x3d&amp;rsquo;,&amp;rsquo;\x58\x73\x4f\x78\x77\x36\x44\x43\x68\x6e\x77\x3d&amp;rsquo;,&amp;rsquo;\x77\x34\x41\x54\x59\x63\x4f\x46\x77\x6f\x77\x3d&amp;rsquo;,&amp;rsquo;\x55\x73\x4f\x74\x77\x36\x50\x43\x75\x6d\x49\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x38\x4f\x77\x71\x6b\x68&amp;rsquo;,&amp;rsquo;\x77\x71\x44\x44\x76\x38\x4b\x58\x42\x4d\x4f\x69\x77\x35\x4c\x43\x73\x63\x4f\x4a\x77\x72\x63\x3d&amp;rsquo;,&amp;rsquo;\x4e\x63\x4f\x4c\x77\x70\x4c\x43\x73\x63\x4b\x4c&amp;rsquo;,&amp;rsquo;\x43\x38\x4b\x6d\x45\x63\x4f\x33&amp;rsquo;,&amp;rsquo;\x54\x38\x4f\x72\x58\x4d\x4b\x4a\x77\x37\x59\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x6e\x44\x71\x4d\x4b\x54&amp;rsquo;,&amp;rsquo;\x77\x34\x55\x6b\x77\x70\x2f\x43\x75\x45\x41\x3d&amp;rsquo;,&amp;rsquo;\x48\x6d\x52\x31\x52\x43\x41\x3d&amp;rsquo;,&amp;rsquo;\x77\x34\x67\x58\x77\x72\x6a\x43\x72\x56\x77\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x50\x43\x6d\x73\x4b\x54\x77\x71\x31\x77&amp;rsquo;,&amp;rsquo;\x50\x63\x4b\x31\x45\x30\x62\x44\x74\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x34\x6a\x43\x6b\x47\x77\x3d&amp;rsquo;,&amp;rsquo;\x50\x63\x4f\x6b\x77\x37\x66\x43\x6f\x4d\x4f\x67&amp;rsquo;,&amp;rsquo;\x43\x73\x4f\x4d\x77\x6f\x6e\x43\x73\x63\x4b\x57&amp;rsquo;,&amp;rsquo;\x77\x35\x30\x69\x51\x63\x4b\x76\x77\x70\x34\x3d&amp;rsquo;,&amp;rsquo;\x77\x72\x74\x54\x77\x34\x52\x4d\x58\x4d\x4b\x61\x77\x71\x37\x43\x74\x7a\x62\x43\x75\x42\x44\x44\x73\x53\x2f\x44\x76\x47\x73\x77\x77\x70\x77\x3d&amp;rsquo;,&amp;rsquo;\x4d\x58\x78\x51\x4d\x6d\x59\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x66\x44\x72\x6d\x45\x68\x77\x71\x51\x3d&amp;rsquo;,&amp;rsquo;\x77\x35\x59\x62\x62\x73\x4f\x4a\x77\x6f\x67\x51\x77\x70\x74\x56\x77\x35\x63\x3d&amp;rsquo;,&amp;rsquo;\x4f\x63\x4b\x4e\x43\x47\x7a\x44\x76\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x42\x41\x77\x70\x41\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x6a\x43\x6b\x55\x72\x43\x74\x7a\x6b\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x77\x72\x66\x73\x4f\x38&amp;rsquo;,&amp;rsquo;\x44\x31\x70\x4a\x4d\x73\x4b\x4f&amp;rsquo;,&amp;rsquo;\x46\x6d\x4c\x44\x75\x47\x2f\x44\x6b\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x44\x44\x74\x38\x4f\x2b\x56\x6e\x67\x3d&amp;rsquo;,&amp;rsquo;\x77\x70\x66\x44\x69\x30\x34\x51\x77\x72\x34\x3d&amp;rsquo;,&amp;rsquo;\x53\x63\x4f\x4d\x62\x63\x4b\x2b\x77\x36\x6f\x3d&amp;rsquo;,&amp;rsquo;\x49\x73\x4f\x64\x77\x72\x44\x43\x68\x4d\x4b\x58&amp;rsquo;,&amp;rsquo;\x77\x36\x66\x43\x74\x6b\x6c\x63\x59\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x4c\x44\x68\x38\x4b\x6f\x77\x37\x6c\x70&amp;rsquo;,&amp;rsquo;\x77\x34\x62\x44\x67\x6a\x33\x43\x72\x77\x51\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x62\x44\x76\x32\x45\x46\x77\x71\x6f\x3d&amp;rsquo;,&amp;rsquo;\x63\x63\x4f\x38\x42\x30\x59\x47&amp;rsquo;,&amp;rsquo;\x53\x63\x4f\x4e\x4f\x58\x55\x4c&amp;rsquo;,&amp;rsquo;\x47\x38\x4f\x4d\x77\x36\x44\x43\x76\x38\x4f\x49&amp;rsquo;,&amp;rsquo;\x77\x36\x6a\x44\x71\x38\x4b\x42\x77\x34\x46\x38&amp;rsquo;,&amp;rsquo;\x77\x36\x49\x6e\x65\x4d\x4f\x4e\x77\x72\x6f\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x72\x44\x68\x73\x4b\x46\x77\x36\x78\x36&amp;rsquo;,&amp;rsquo;\x77\x6f\x72\x44\x6c\x4d\x4b\x68\x77\x36\x5a\x71&amp;rsquo;,&amp;rsquo;\x45\x73\x4f\x7a\x77\x71\x50\x43\x69\x73\x4b\x6d&amp;rsquo;,&amp;rsquo;\x77\x35\x31\x46\x77\x70\x52\x64\x4c\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x72\x33\x44\x73\x73\x4b\x43\x77\x36\x73\x3d&amp;rsquo;,&amp;rsquo;\x52\x73\x4f\x34\x77\x70\x66\x44\x68\x77\x6b\x3d&amp;rsquo;,&amp;rsquo;\x77\x72\x6a\x44\x6b\x38\x4b\x58\x77\x36\x64\x4e&amp;rsquo;,&amp;rsquo;\x45\x30\x68\x6d\x46\x4d\x4b\x65&amp;rsquo;,&amp;rsquo;\x77\x34\x54\x44\x6b\x78\x66\x43\x70\x63\x4f\x66&amp;rsquo;,&amp;rsquo;\x77\x72\x55\x4e\x61\x57\x55\x59&amp;rsquo;,&amp;rsquo;\x5a\x63\x4f\x34\x56\x73\x4b\x50\x77\x35\x45\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x62\x44\x6f\x38\x4f\x2b\x63\x6e\x38\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x6a\x44\x73\x52\x2f\x44\x67\x4d\x4f\x59&amp;rsquo;,&amp;rsquo;\x77\x37\x63\x34\x77\x36\x50\x43\x73\x4d\x4b\x5a&amp;rsquo;,&amp;rsquo;\x42\x63\x4b\x4f\x48\x73\x4f\x2f\x5a\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x53\x4d\x4f\x37\x42\x54\x7a\x43\x74\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x54\x44\x69\x63\x4f\x6c\x65\x6e\x45\x3d&amp;rsquo;,&amp;rsquo;\x77\x35\x73\x43\x77\x37\x6a\x43\x69\x63\x4b\x35&amp;rsquo;,&amp;rsquo;\x41\x32\x4c\x44\x73\x52\x50\x43\x6d\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x45\x32\x77\x34\x76\x44\x72\x7a\x34\x3d&amp;rsquo;,&amp;rsquo;\x45\x7a\x7a\x44\x6e\x6b\x6a\x44\x75\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x37\x44\x75\x73\x4b\x61\x4b\x4d\x4b\x77\x77\x35\x30\x47\x77\x35\x64\x32\x46\x38\x4f\x63\x44\x73\x4f\x48&amp;rsquo;,&amp;rsquo;\x35\x61\x65\x54\x35\x70\x36\x79\x35\x6f\x43\x56\x35\x35\x71\x52\x77\x34\x39\x5a\x36\x59\x53\x4c\x35\x62\x53\x41\x35\x61\x61\x42\x35\x4c\x75\x65\x77\x35\x33\x44\x72\x73\x4b\x39\x37\x37\x32\x4b\x77\x71\x6e\x43\x76\x4d\x4b\x4e\x35\x71\x47\x37\x35\x36\x36\x47\x37\x37\x2b\x69\x35\x36\x32\x46\x35\x36\x79\x6f\x35\x59\x65\x4a\x35\x4c\x6d\x2f\x36\x5a\x2b\x42\x52\x58\x55\x50\x77\x71\x46\x78\x77\x71\x77\x37\x51\x63\x4b\x4e\x77\x6f\x6e\x6e\x6d\x70\x72\x6b\x75\x49\x76\x6e\x6f\x37\x37\x76\x76\x34\x66\x6f\x72\x4b\x44\x6d\x6a\x49\x66\x6c\x6a\x37\x62\x6c\x68\x71\x48\x6d\x6e\x34\x6a\x6c\x68\x34\x66\x6c\x69\x36\x4c\x6c\x72\x5a\x7a\x6a\x67\x49\x6e\x6f\x76\x35\x50\x6b\x75\x61\x66\x6c\x74\x70\x72\x6c\x68\x70\x54\x6b\x75\x61\x62\x6f\x67\x62\x62\x6c\x69\x49\x37\x6c\x72\x36\x33\x43\x74\x4d\x4b\x73\x62\x4f\x4f\x44\x72\x45\x34\x43\x61\x4f\x65\x73\x6e\x75\x61\x72\x74\x4f\x65\x49\x67\x2b\x57\x48\x72\x4f\x57\x75\x73\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x36\x4c\x79\x6e\x35\x70\x6d\x55\x35\x4c\x69\x4b\x35\x4c\x69\x4f\x35\x4c\x6d\x68\x35\x37\x4f\x34\x35\x59\x6d\x39\x57\x63\x4b\x6b\x35\x70\x4f\x38\x35\x4c\x36\x6a\x34\x34\x4f\x51&amp;rsquo;,&amp;rsquo;\x77\x37\x6f\x52\x53\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x35\x36\x6d\x45\x36\x5a\x61\x63\x35\x6f\x36\x64\x36\x61\x69\x41\x35\x37\x75\x73\x5a\x2b\x4b\x43\x72\x6d\x72\x43\x73\x4f\x57\x4b\x6e\x2b\x57\x74\x72\x2b\x4b\x43\x74\x45\x6e\x6c\x6b\x5a\x39\x4c\x34\x6f\x43\x39\x4a\x57\x33\x6f\x70\x5a\x2f\x6c\x72\x36\x33\x69\x67\x35\x74\x74\x37\x37\x36\x6e\x35\x4c\x36\x69\x35\x59\x32\x4a\x35\x4c\x32\x76\x35\x35\x6d\x5a\x4c\x52\x50\x44\x6e\x75\x4f\x43\x6e\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x4c\x43\x69\x38\x4b\x56\x77\x70\x64\x64&amp;rsquo;,&amp;rsquo;\x49\x6e\x31\x53\x64\x51\x45\x3d&amp;rsquo;,&amp;rsquo;\x63\x4d\x4f\x44\x77\x70\x66\x44\x6e\x7a\x55\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x30\x74\x4c\x63\x4b\x2b\x77\x36\x67\x3d&amp;rsquo;,&amp;rsquo;\x77\x34\x55\x6e\x65\x63\x4b\x45\x77\x71\x45\x3d&amp;rsquo;,&amp;rsquo;\x77\x70\x59\x76\x59\x4d\x4f\x70\x77\x71\x73\x3d&amp;rsquo;,&amp;rsquo;\x4a\x6a\x44\x43\x6d\x31\x37\x44\x72\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x45\x6b\x52\x37\x41\x33\x38\x3d&amp;rsquo;,&amp;rsquo;\x51\x4d\x4f\x73\x62\x63\x4b\x79\x77\x35\x63\x3d&amp;rsquo;,&amp;rsquo;\x77\x35\x58\x44\x73\x6a\x33\x43\x76\x38\x4f\x69&amp;rsquo;,&amp;rsquo;\x4e\x77\x58\x44\x6a\x30\x48\x44\x6a\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x63\x4d\x4f\x73\x77\x6f\x33\x44\x67\x77\x6f\x59\x49\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x56\x4d\x4b\x46\x77\x6f\x6e\x44\x75\x4d\x4b\x58&amp;rsquo;,&amp;rsquo;\x64\x38\x4f\x61\x77\x34\x6e\x43\x68\x30\x6f\x3d&amp;rsquo;,&amp;rsquo;\x51\x4d\x4b\x45\x77\x6f\x77\x3d&amp;rsquo;,&amp;rsquo;\x77\x35\x58\x43\x70\x46\x49\x3d&amp;rsquo;,&amp;rsquo;\x48\x6c\x46\x50\x49\x73\x4b\x50\x59\x6d\x4c\x43\x6b\x73\x4b\x2b&amp;rsquo;,&amp;rsquo;\x50\x6d\x39\x55\x65\x52\x5a\x4f&amp;rsquo;,&amp;rsquo;\x4e\x31\x76\x44\x6b\x33\x62\x44\x73\x57\x50\x43\x71\x43\x49\x3d&amp;rsquo;,&amp;rsquo;\x54\x45\x30\x4f\x4b\x78\x37\x43\x67\x38\x4b\x53\x77\x34\x39\x79\x77\x70\x67\x63\x42\x68\x38\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x33\x44\x73\x51\x58\x43\x6d\x44\x67\x3d&amp;rsquo;,&amp;rsquo;\x50\x6c\x31\x75\x47\x48\x38\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x37\x44\x73\x4d\x4b\x6a\x4b\x63\x4f\x59&amp;rsquo;,&amp;rsquo;\x64\x4d\x4f\x4e\x77\x34\x4c\x43\x6e\x32\x45\x3d&amp;rsquo;,&amp;rsquo;\x53\x73\x4f\x36\x61\x73\x4f\x55\x48\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x4f\x38\x4b\x75\x77\x72\x48\x44\x76\x73\x4f\x55&amp;rsquo;,&amp;rsquo;\x77\x36\x37\x43\x69\x6c\x50\x43\x6d\x69\x77\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x2f\x44\x73\x52\x2f\x44\x6a\x4d\x4f\x58&amp;rsquo;,&amp;rsquo;\x41\x55\x6a\x44\x6b\x30\x62\x44\x6a\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x43\x48\x5a\x39\x4e\x57\x6b\x3d&amp;rsquo;,&amp;rsquo;\x55\x63\x4f\x66\x65\x63\x4f\x48\x47\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x4e\x4d\x4f\x42\x77\x6f\x74\x54\x4f\x54\x70\x78&amp;rsquo;,&amp;rsquo;\x77\x34\x50\x44\x70\x41\x58\x43\x72\x52\x7a\x44\x75\x4d\x4b\x78&amp;rsquo;,&amp;rsquo;\x77\x36\x30\x79\x61\x63\x4b\x76\x77\x71\x76\x44\x6a\x67\x72\x44\x76\x73\x4f\x59\x77\x35\x46\x35\x77\x72\x55\x43\x77\x6f\x66\x44\x72\x30\x38\x4d&amp;rsquo;,&amp;rsquo;\x77\x34\x62\x44\x70\x43\x66\x43\x6e\x52\x45\x3d&amp;rsquo;,&amp;rsquo;\x4a\x4d\x4f\x65\x77\x6f\x6c\x4a\x49\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x46\x73\x4f\x4f\x77\x37\x6a\x43\x70\x38\x4f\x73&amp;rsquo;,&amp;rsquo;\x4b\x63\x4f\x4e\x77\x37\x59\x32\x65\x73\x4f\x77\x53\x73\x4f\x73\x62\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x54\x79\x50\x44\x71\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x72\x33\x44\x70\x63\x4b\x51\x77\x37\x78\x2b&amp;rsquo;,&amp;rsquo;\x77\x72\x51\x6b\x77\x35\x58\x44\x67\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x72\x56\x77\x4e\x53\x6f\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x45\x4f\x77\x37\x72\x43\x73\x73\x4b\x48&amp;rsquo;,&amp;rsquo;\x77\x71\x6e\x44\x71\x38\x4f\x76\x52\x6d\x55\x3d&amp;rsquo;,&amp;rsquo;\x57\x63\x4f\x70\x51\x73\x4b\x50\x77\x37\x41\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x37\x43\x71\x6c\x46\x56\x57\x73\x4b\x49\x4a\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x6a\x43\x69\x73\x4b\x2b\x77\x70\x74\x5a&amp;rsquo;,&amp;rsquo;\x77\x71\x72\x44\x75\x4d\x4b\x66\x77\x36\x78\x30\x48\x4d\x4b\x43&amp;rsquo;,&amp;rsquo;\x4d\x73\x4f\x63\x77\x70\x64\x50\x4a\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x72\x77\x68\x4e\x4d\x4b\x67\x77\x37\x4c\x44\x6e\x6c\x38\x3d&amp;rsquo;,&amp;rsquo;\x77\x70\x44\x44\x75\x32\x38\x39\x77\x72\x63\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x62\x44\x6d\x44\x7a\x44\x67\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x41\x55\x77\x37\x37\x43\x75\x63\x4b\x41\x4d\x57\x63\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x48\x43\x71\x6c\x67\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x48\x44\x75\x43\x68\x59\x59\x6b\x4c\x43\x75\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x6f\x66\x44\x72\x79\x56\x4f\x66\x56\x72\x43\x74\x41\x50\x43\x71\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x71\x63\x54\x77\x36\x62\x43\x72\x73\x4b\x61\x66\x58\x77\x3d&amp;rsquo;,&amp;rsquo;\x46\x63\x4b\x70\x42\x63\x4f\x32&amp;rsquo;,&amp;rsquo;\x77\x72\x33\x43\x6b\x69\x52\x7a&amp;rsquo;,&amp;rsquo;\x54\x4d\x4f\x59\x77\x34\x58\x43\x6c\x31\x49\x3d&amp;rsquo;,&amp;rsquo;\x58\x38\x4f\x39\x51\x63\x4b\x48\x77\x34\x55\x3d&amp;rsquo;,&amp;rsquo;\x64\x51\x62\x44\x74\x51\x74\x53&amp;rsquo;,&amp;rsquo;\x77\x36\x66\x44\x6d\x54\x4c\x43\x6c\x63\x4f\x5a&amp;rsquo;,&amp;rsquo;\x4c\x4d\x4b\x62\x41\x47\x48\x44\x76\x79\x77\x3d&amp;rsquo;,&amp;rsquo;\x51\x63\x4b\x64\x77\x70\x50\x44\x75\x73\x4b\x79&amp;rsquo;,&amp;rsquo;\x66\x38\x4f\x4a\x77\x71\x45\x76\x4f\x73\x4f\x34\x45\x73\x4f\x2f\x4d\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x4c\x73\x4b\x62\x77\x6f\x38\x3d&amp;rsquo;,&amp;rsquo;\x4c\x46\x58\x44\x67\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x58\x44\x70\x53\x34\x3d&amp;rsquo;,&amp;rsquo;\x58\x38\x4f\x33\x53\x73\x4b\x44\x77\x36\x4a\x2f\x77\x70\x6a\x43\x6f\x45\x51\x3d&amp;rsquo;,&amp;rsquo;\x4d\x73\x4f\x57\x77\x70\x6e\x43\x6f\x63\x4b\x42\x5a\x58\x51\x69\x41\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x35\x34\x71\x44\x35\x70\x36\x71\x35\x59\x32\x63\x37\x37\x32\x59\x77\x36\x6e\x44\x6b\x75\x53\x38\x72\x4f\x57\x73\x73\x65\x61\x64\x6e\x65\x57\x39\x6b\x75\x65\x70\x76\x65\x2b\x39\x76\x75\x69\x38\x72\x65\x69\x73\x6e\x65\x61\x58\x6c\x4f\x61\x50\x6d\x4f\x61\x49\x6a\x4f\x53\x36\x68\x2b\x65\x61\x76\x4f\x57\x32\x6b\x75\x53\x38\x6f\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x35\x59\x75\x6a\x36\x5a\x69\x68\x35\x34\x75\x76\x35\x70\x36\x41\x35\x59\x36\x34\x37\x37\x32\x7a\x77\x34\x56\x53\x35\x4c\x79\x55\x35\x61\x79\x56\x35\x70\x32\x36\x35\x62\x32\x2b\x35\x36\x6d\x30&amp;rsquo;,&amp;rsquo;\x77\x72\x59\x43\x77\x35\x55\x3d&amp;rsquo;,&amp;rsquo;\x4c\x38\x4b\x54\x41\x55\x6e\x44\x6f\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x77\x36\x7a\x44\x68\x6a\x62\x44\x68\x38\x4f\x6d&amp;rsquo;,&amp;rsquo;\x4f\x48\x54\x44\x70\x58\x66\x44\x67\x51\x3d\x3d&amp;rsquo;,&amp;rsquo;\x54\x38\x4f\x35\x61\x67\x3d\x3d&amp;rsquo;,&amp;rsquo;\x56\x54\x6e\x44\x72\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x4d\x63\x4f\x62\x77\x6f\x74\x44\x49\x6a\x39\x37\x61\x73\x4f\x5a\x77\x34\x63\x55\x77\x34\x4c\x44\x6b\x63\x4b\x70\x43\x38\x4f\x6a&amp;rsquo;,&amp;rsquo;\x62\x63\x4f\x2b\x77\x70\x62\x43\x68\x38\x4f\x56\x62\x38\x4f\x4c\x77\x34\x66\x43\x74\x63\x4f\x33\x66\x53\x31\x49\x77\x71\x35\x65\x77\x72\x5a\x41\x61\x4d\x4f\x34\x50\x63\x4b\x62\x77\x6f\x67\x55\x48\x73\x4f\x75\x77\x71\x2f\x43\x74\x55\x73\x62\x63\x73\x4f\x2f\x43\x77\x62\x43\x71\x63\x4b\x35\x44\x63\x4b\x30\x4e\x55\x73\x6c\x77\x6f\x74\x42\x57\x56\x39\x64\x64\x31\x33\x43\x76\x30\x33\x44\x71\x68\x4c\x44\x67\x55\x49\x54\x44\x52\x70\x72\x41\x6c\x64\x69\x57\x63\x4b\x69&amp;rsquo;,&amp;rsquo;\x41\x6c\x46\x43\x4d\x77\x3d\x3d&amp;rsquo;,&amp;rsquo;\x53\x63\x4f\x78\x54\x38\x4b\x50\x77\x36\x6f\x3d&amp;rsquo;,&amp;rsquo;\x77\x37\x62\x44\x6d\x43\x72\x44\x6d\x38\x4f\x6d&amp;rsquo;,&amp;rsquo;\x43\x7a\x76\x43\x6e\x41\x3d\x3d&amp;rsquo;,&amp;rsquo;\x62\x63\x4f\x4f\x4f\x77\x3d\x3d&amp;rsquo;];(function(_0x3dfc24,_0x4bf57f){var _0x479f23=function(_0x151040){while(&amp;ndash;_0x151040){_0x3dfc24&lt;a href="_0x3dfc24[%27shift%27]%28%29">&amp;lsquo;push&amp;rsquo;&lt;/a>;}};var _0x2667ef=function(){var _0x19882c={&amp;lsquo;data&amp;rsquo;:{&amp;lsquo;key&amp;rsquo;:&amp;lsquo;cookie&amp;rsquo;,&amp;lsquo;value&amp;rsquo;:&amp;rsquo;timeout&amp;rsquo;},&amp;lsquo;setCookie&amp;rsquo;:function(_0x38a396,_0x198d9c,_0x53d2fc,_0x40f314){_0x40f314=_0x40f314||{};var _0x1d0db3=_0x198d9c+&amp;rsquo;=&amp;rsquo;+_0x53d2fc;var _0x1c23d9=0x0;for(var _0x1c23d9=0x0,_0x3c6a59=_0x38a396[&amp;rsquo;length&amp;rsquo;];_0x1c23d9&amp;lt;_0x3c6a59;_0x1c23d9++){var _0x1a8423=_0x38a396[_0x1c23d9];_0x1d0db3+=&amp;rsquo;;\x20&amp;rsquo;+_0x1a8423;var _0x504757=_0x38a396[_0x1a8423];_0x38a396&lt;a href="_0x504757">&amp;lsquo;push&amp;rsquo;&lt;/a>;_0x3c6a59=_0x38a396[&amp;rsquo;length&amp;rsquo;];if(_0x504757!==!![]){_0x1d0db3+=&amp;rsquo;=&amp;rsquo;+_0x504757;}}_0x40f314[&amp;lsquo;cookie&amp;rsquo;]=_0x1d0db3;},&amp;lsquo;removeCookie&amp;rsquo;:function(){return&amp;rsquo;dev&amp;rsquo;;},&amp;lsquo;getCookie&amp;rsquo;:function(_0x5ac218,_0x334887){_0x5ac218=_0x5ac218||function(_0x16cbc0){return _0x16cbc0;};var _0x1c3d23=_0x5ac218(new RegExp(&amp;rsquo;(?:^|;\x20)&amp;rsquo;+_0x334887&lt;a href="https://ng-tech.icu/%28[.$?*%7c%7b%7d%28%29[]%5c/&amp;#43;%5e]%29/g,%27$1%27">&amp;lsquo;replace&amp;rsquo;&lt;/a>+&amp;rsquo;=([^;]&lt;/em>)&amp;rsquo;));var _0x1aa17e=function(_0x39f8d3,_0x4de5a6){_0x39f8d3(++_0x4de5a6);};_0x1aa17e(_0x479f23,_0x4bf57f);return _0x1c3d23?decodeURIComponent(_0x1c3d23[0x1]):undefined;}};var _0x17cb94=function(){var _0x4d8f44=new RegExp(&amp;rsquo;\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*[\x27|\x22].+[\x27|\x22];?\x20*}&amp;rsquo;);return _0x4d8f44&lt;a href="_0x19882c[%27removeCookie%27][%27toString%27]%28%29">&amp;rsquo;test&amp;rsquo;&lt;/a>;};_0x19882c[&amp;lsquo;updateCookie&amp;rsquo;]=_0x17cb94;var _0x30b075=&amp;rsquo;&amp;rsquo;;var _0x3744e8=_0x19882c&lt;a href="">&amp;lsquo;updateCookie&amp;rsquo;&lt;/a>;if(!_0x3744e8){_0x19882c&lt;a href="[%27*%27],%27counter%27,0x1">&amp;lsquo;setCookie&amp;rsquo;&lt;/a>;}else if(_0x3744e8){_0x30b075=_0x19882c&lt;a href="null,%27counter%27">&amp;lsquo;getCookie&amp;rsquo;&lt;/a>;}else{_0x19882c&lt;a href="">&amp;lsquo;removeCookie&amp;rsquo;&lt;/a>;}};_0x2667ef();}(_0x1491,0x7b));var _0x1f81=function(_0x2c0c46,_0x5b2ac3){_0x2c0c46=_0x2c0c46-0x0;var _0x3b87dc=_0x1491[_0x2c0c46];if(_0x1f81[&amp;lsquo;initialized&amp;rsquo;]===undefined){(function(){var _0xb97df9=typeof window!==&amp;lsquo;undefined&amp;rsquo;?window:typeof process===&amp;lsquo;object&amp;rsquo;&amp;amp;&amp;amp;typeof require===&amp;lsquo;function&amp;rsquo;&amp;amp;&amp;amp;typeof global===&amp;lsquo;object&amp;rsquo;?global:this;var _0x1acb97=&amp;lsquo;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&amp;rsquo;;_0xb97df9[&amp;lsquo;atob&amp;rsquo;]||(_0xb97df9[&amp;lsquo;atob&amp;rsquo;]=function(_0x3fcea8){var _0x1ee370=String(_0x3fcea8)&lt;a href="https://ng-tech.icu/=&amp;#43;$/,%27%27">&amp;lsquo;replace&amp;rsquo;&lt;/a>;for(var _0x1d8de6=0x0,_0x22ae7a,_0x2206eb,_0x131a86=0x0,_0x675d6d=&amp;rsquo;&amp;rsquo;;_0x2206eb=_0x1ee370&lt;a href="_0x131a86&amp;#43;&amp;#43;">&amp;lsquo;charAt&amp;rsquo;&lt;/a>;~_0x2206eb&amp;amp;&amp;amp;(_0x22ae7a=_0x1d8de6%0x4?_0x22ae7a&lt;em>0x40+_0x2206eb:_0x2206eb,_0x1d8de6++%0x4)?_0x675d6d+=String&lt;a href="0xff&amp;amp;%5c_0x22ae7a%3e%3e%28-0x2*%5c_0x1d8de6&amp;amp;0x6%29">&amp;lsquo;fromCharCode&amp;rsquo;&lt;/a>:0x0){_0x2206eb=_0x1acb97&lt;a href="_0x2206eb">&amp;lsquo;indexOf&amp;rsquo;&lt;/a>;}return _0x675d6d;});}());var _0x3e5e2d=function(_0x17adfb,_0x13df9b){var _0x377757=[],_0xaaa979=0x0,_0x3b3a8a,_0x4dab2b=&amp;rsquo;&amp;rsquo;,_0x25adf3=&amp;rsquo;&amp;rsquo;;_0x17adfb=atob(_0x17adfb);for(var _0x3c558f=0x0,_0x1d2ebf=_0x17adfb[&amp;rsquo;length&amp;rsquo;];_0x3c558f&amp;lt;_0x1d2ebf;_0x3c558f++){_0x25adf3+=&amp;rsquo;%&amp;rsquo;+(&amp;lsquo;00&amp;rsquo;+_0x17adfb&lt;a href="_0x3c558f">&amp;lsquo;charCodeAt&amp;rsquo;&lt;/a>&lt;a href="0x10">&amp;rsquo;toString&amp;rsquo;&lt;/a>)&lt;a href="-0x2">&amp;lsquo;slice&amp;rsquo;&lt;/a>;}_0x17adfb=decodeURIComponent(_0x25adf3);for(var _0x1f2b2f=0x0;_0x1f2b2f&amp;lt;0x100;_0x1f2b2f++){_0x377757[_0x1f2b2f]=_0x1f2b2f;}for(_0x1f2b2f=0x0;_0x1f2b2f&amp;lt;0x100;_0x1f2b2f++){_0xaaa979=(_0xaaa979+_0x377757[_0x1f2b2f]+_0x13df9b&lt;a href="_0x1f2b2f%25_0x13df9b[%27length%27]">&amp;lsquo;charCodeAt&amp;rsquo;&lt;/a>)%0x100;_0x3b3a8a=_0x377757[_0x1f2b2f];_0x377757[_0x1f2b2f]=_0x377757[_0xaaa979];_0x377757[_0xaaa979]=_0x3b3a8a;}_0x1f2b2f=0x0;_0xaaa979=0x0;for(var _0x2e1891=0x0;_0x2e1891&amp;lt;_0x17adfb[&amp;rsquo;length&amp;rsquo;];_0x2e1891++){_0x1f2b2f=(_0x1f2b2f+0x1)%0x100;_0xaaa979=(_0xaaa979+_0x377757[_0x1f2b2f])%0x100;_0x3b3a8a=_0x377757[_0x1f2b2f];_0x377757[_0x1f2b2f]=_0x377757[_0xaaa979];_0x377757[_0xaaa979]=_0x3b3a8a;_0x4dab2b+=String&lt;a href="_0x17adfb[%27charCodeAt%27]%28_0x2e1891%29%5e_0x377757[%28_0x377757[_0x1f2b2f]&amp;#43;_0x377757[_0xaaa979]%29%250x100]">&amp;lsquo;fromCharCode&amp;rsquo;&lt;/a>;}return _0x4dab2b;};_0x1f81[&amp;lsquo;rc4&amp;rsquo;]=_0x3e5e2d;_0x1f81[&amp;lsquo;data&amp;rsquo;]={};_0x1f81[&amp;lsquo;initialized&amp;rsquo;]=!![];}var _0x7cb0ee=_0x1f81[&amp;lsquo;data&amp;rsquo;][_0x2c0c46];if(_0x7cb0ee===undefined){if(_0x1f81[&amp;lsquo;once&amp;rsquo;]===undefined){var _0x6c2e85=function(_0x3bde69){this[&amp;lsquo;rc4Bytes&amp;rsquo;]=_0x3bde69;this[&amp;lsquo;states&amp;rsquo;]=[0x1,0x0,0x0];this[&amp;rsquo;newState&amp;rsquo;]=function(){return&amp;rsquo;newState&amp;rsquo;;};this[&amp;lsquo;firstState&amp;rsquo;]=&amp;rsquo;\x5cw+\x20&lt;/em>\x5c(\x5c)\x20*{\x5cw+\x20*&amp;rsquo;;this[&amp;lsquo;secondState&amp;rsquo;]=&amp;rsquo;[\x27|\x22].+[\x27|\x22];?\x20*}&amp;rsquo;;};_0x6c2e85[&amp;lsquo;prototype&amp;rsquo;][&amp;lsquo;checkstate&amp;rsquo;]=function(){var _0x204954=new RegExp(this[&amp;lsquo;firstState&amp;rsquo;]+this[&amp;lsquo;secondState&amp;rsquo;]);return this&lt;a href="_0x204954[%27test%27]%28this[%27newState%27][%27toString%27]%28%29%29?--this[%27states%27][0x1]:--this[%27states%27][0x0]">&amp;lsquo;runState&amp;rsquo;&lt;/a>;};_0x6c2e85[&amp;lsquo;prototype&amp;rsquo;][&amp;lsquo;runstate&amp;rsquo;]=function(_0x1c9de0){if(!Boolean(~_0x1c9de0)){return _0x1c9de0;}return this&lt;a href="this[%27rc4Bytes%27]">&amp;lsquo;getState&amp;rsquo;&lt;/a>;};_0x6c2e85[&amp;lsquo;prototype&amp;rsquo;][&amp;lsquo;getstate&amp;rsquo;]=function(_0xa6641f){for(var _0x19f84b=0x0,_0xa22262=this[&amp;lsquo;states&amp;rsquo;][&amp;rsquo;length&amp;rsquo;];_0x19f84b&amp;lt;_0xa22262;_0x19f84b++){this[&amp;lsquo;states&amp;rsquo;]&lt;a href="Math[%27round%27]%28%3cMath[%27random%27]%28%29%3e%29">&amp;lsquo;push&amp;rsquo;&lt;/a>;_0xa22262=this[&amp;lsquo;states&amp;rsquo;][&amp;rsquo;length&amp;rsquo;];}return _0xa6641f(this[&amp;lsquo;states&amp;rsquo;][0x0]);};new _0x6c2e85(_0x1f81)&lt;a href="">&amp;lsquo;checkState&amp;rsquo;&lt;/a>;_0x1f81[&amp;lsquo;once&amp;rsquo;]=!![];}_0x3b87dc=_0x1f81&lt;a href="_0x3b87dc,_0x5b2ac3">&amp;lsquo;rc4&amp;rsquo;&lt;/a>;_0x1f81[&amp;lsquo;data&amp;rsquo;][_0x2c0c46]=_0x3b87dc;}else{_0x3b87dc=_0x7cb0ee;}return _0x3b87dc;};setInterval(function(){var _0x5904a4={&amp;lsquo;EIaeO&amp;rsquo;:function _0x5b0577(_0x10167c){return _0x10167c();}};_0x5904a4[_0x1f81(&amp;lsquo;0x0&amp;rsquo;,&amp;rsquo;\x61\x4b\x6d\x35&amp;rsquo;)];},0xfa0);var _0xf3d9f8={},_0x311965={};(function(_0x109ee7,_0x3a5cb7){var _0x4db5e5={&amp;rsquo;nsJoa&amp;rsquo;:_0x1f81(&amp;lsquo;0x1&amp;rsquo;,&amp;rsquo;\x24\x42\x34\x4e&amp;rsquo;),&amp;lsquo;wNhrV&amp;rsquo;:function _0x495ba2(_0x4d9e7c){return _0x4d9e7c();},&amp;rsquo;ePCTb&amp;rsquo;:_0x1f81(&amp;lsquo;0x2&amp;rsquo;,&amp;rsquo;\x73\x71\x34\x36&amp;rsquo;),&amp;lsquo;ARHHO&amp;rsquo;:function _0xc16e7b(_0x52bb36,_0x5aa21b,_0x1eda73){return _0x52bb36(_0x5aa21b,_0x1eda73);},&amp;lsquo;zPDXW&amp;rsquo;:_0x1f81(&amp;lsquo;0x3&amp;rsquo;,&amp;rsquo;\x54\x33\x31\x48&amp;rsquo;),&amp;lsquo;udoaA&amp;rsquo;:function _0x3ca0e8(_0x59461b,_0x986648){return _0x59461b!==_0x986648;},&amp;lsquo;VJyxZ&amp;rsquo;:_0x1f81(&amp;lsquo;0x4&amp;rsquo;,&amp;rsquo;\x49\x31\x67\x42&amp;rsquo;),&amp;lsquo;pHYVG&amp;rsquo;:_0x1f81(&amp;lsquo;0x5&amp;rsquo;,&amp;rsquo;\x4d\x49\x65\x64&amp;rsquo;)};var _0x3d0d31=_0x4db5e5[_0x1f81(&amp;lsquo;0x6&amp;rsquo;,&amp;rsquo;\x57\x33\x63\x67&amp;rsquo;)]&lt;a href="%27%5cx7c%27">_0x1f81(&amp;lsquo;0x7&amp;rsquo;,&amp;rsquo;\x21\x79\x23\x57&amp;rsquo;)&lt;/a>,_0x36a8d7=0x0;while(!![]){switch(_0x3d0d31[_0x36a8d7++]){case&amp;rsquo;\x30&amp;rsquo;:_0x4db5e5&lt;a href="_0x140713">_0x1f81(&amp;lsquo;0x8&amp;rsquo;,&amp;rsquo;\x53\x5a\x5d\x41&amp;rsquo;)&lt;/a>;continue;case&amp;rsquo;\x31&amp;rsquo;:var _0x440a30=function(){var _0x28e28f={&amp;lsquo;KFHDo&amp;rsquo;:function _0x543e69(_0xd28702,_0x203ba9){return _0x578ff0&lt;a href="_0xd28702,_0x203ba9">_0x1f81(&amp;lsquo;0x9&amp;rsquo;,&amp;rsquo;\x69\x72\x58\x46&amp;rsquo;)&lt;/a>;},&amp;lsquo;juCTS&amp;rsquo;:_0x578ff0[_0x1f81(&amp;lsquo;0xa&amp;rsquo;,&amp;rsquo;\x4e\x67\x44\x72&amp;rsquo;)],&amp;lsquo;EegXm&amp;rsquo;:function _0x478322(_0x3fc71c){return _0x578ff0&lt;a href="_0x3fc71c">_0x1f81(&amp;lsquo;0xb&amp;rsquo;,&amp;rsquo;\x79\x6d\x76\x5b&amp;rsquo;)&lt;/a>;}};var _0x333865=!![];return function(_0x3bb96b,_0x442e92){var _0x24e638=_0x333865?function(){if(_0x442e92){if(_0x28e28f&lt;a href="_0x28e28f[_0x1f81%28%270xd%27,%27%5cx6b%5cx63%5cx74%5cx71%27%29],_0x28e28f[_0x1f81%28%270xe%27,%27%5cx4d%5cx44%5cx5d%5cx61%27%29]">_0x1f81(&amp;lsquo;0xc&amp;rsquo;,&amp;rsquo;\x58\x76\x64\x55&amp;rsquo;)&lt;/a>){_0x28e28f&lt;a href="_0x1c3a01">_0x1f81(&amp;lsquo;0xf&amp;rsquo;,&amp;rsquo;\x66\x23\x50\x39&amp;rsquo;)&lt;/a>;}else{var _0x291809=_0x442e92&lt;a href="_0x3bb96b,arguments">_0x1f81(&amp;lsquo;0x10&amp;rsquo;,&amp;rsquo;\x61\x4b\x6d\x35&amp;rsquo;)&lt;/a>;_0x442e92=null;return _0x291809;}}}:function(){};_0x333865=![];return _0x24e638;};}();continue;case&amp;rsquo;\x32&amp;rsquo;:_0x3a5cb7[_0x1f81(&amp;lsquo;0x11&amp;rsquo;,&amp;rsquo;\x53\x5a\x5d\x41&amp;rsquo;)]=_0x4db5e5[_0x1f81(&amp;lsquo;0x12&amp;rsquo;,&amp;rsquo;\x5a\x48\x46\x76&amp;rsquo;)];continue;case&amp;rsquo;\x33&amp;rsquo;:var _0x140713=_0x4db5e5&lt;a href="%5c_0x440a30,this,function%28%29%7bvar%c2%a0_0x1d6f1a=%7b%27MznFK%27:function%c2%a0_0x3bf0b2%28%5c_0x248b68,%5c_0x503ce0%29%7breturn%c2%a0_0x248b68===%5c_0x503ce0;%7d,%27FlVOS%27:%5c_0x1f81%28%270x14%27,%27%5cx5a%5cx48%5cx46%5cx76%27%29,%27kwWHJ%27:%5c_0x1f81%28%270x15%27,%27%5cx4d%5cx49%5cx65%5cx64%27%29,%27BECPd%27:function%c2%a0_0x1540a3%28%5c_0x4cad0,%5c_0x5e5d32%29%7breturn%c2%a0_0x4cad0!==%5c_0x5e5d32;%7d,%27hLxQa%27:%5c_0x1f81%28%270x16%27,%27%5cx54%5cx63%5cx67%5cx78%27%29,%27sikBg%27:%5c_0x1f81%28%270x17%27,%27%5cx21%5cx79%5cx23%5cx57%27%29,%27pGEbE%27:function%c2%a0_0x476f96%28%5c_0x5d9eb1,%5c_0x36dc90%29%7breturn%c2%a0_0x5d9eb1===%5c_0x36dc90;%7d,%27PfnSJ%27:%5c_0x1f81%28%270x18%27,%27%5cx73%5cx71%5cx34%5cx36%27%29,%27LlkSs%27:%5c_0x1f81%28%270x19%27,%27%5cx6b%5cx63%5cx74%5cx71%27%29%7d;if%28%5c_0x1d6f1a[%5c_0x1f81%28%270x1a%27,%27%5cx57%5cx6d%5cx78%5cx76%27%29]%28%3c_0x1d6f1a[_0x1f81%28%270x1b%27,%27%5cx6b%5cx63%5cx74%5cx71%27%29],_0x1d6f1a[_0x1f81%28%270x1c%27,%27%5cx77%5cx72%5cx48%5cx74%27%29]%3e%29%29%7b%7delse%7bvar%c2%a0_0x31f4ee=function%28%29%7b%7d;var%c2%a0_0x46e439=%5c_0x1d6f1a[_0x1f81%28%270x1d%27,%27%5cx38%5cx43%5cx39%5cx5b%27%29]%28typeof%c2%a0window,%5c_0x1d6f1a[_0x1f81%28%270x1e%27,%27%5cx4c%5cx39%5cx21%5cx4c%27%29]%29?window:%5c_0x1d6f1a[_0x1f81%28%270x1f%27,%27%5cx68%5cx75%5cx24%5cx54%27%29]%28typeof%c2%a0process,%5c_0x1d6f1a[_0x1f81%28%270x20%27,%27%5cx4d%5cx49%5cx65%5cx64%27%29]%29&amp;amp;&amp;amp;%5c_0x1d6f1a[_0x1f81%28%270x21%27,%27%5cx49%5cx64%5cx26%5cx45%27%29]%28typeof%c2%a0require,%5c_0x1d6f1a[_0x1f81%28%270x22%27,%27%5cx73%5cx71%5cx34%5cx36%27%29]%29&amp;amp;&amp;amp;%5c_0x1d6f1a[_0x1f81%28%270x23%27,%27%5cx6b%5cx63%5cx74%5cx71%27%29]%28typeof%c2%a0global,%5c_0x1d6f1a[_0x1f81%28%270x24%27,%27%5cx4c%5cx39%5cx21%5cx4c%27%29]%29?global:this;if%28!%5c_0x46e439[_0x1f81%28%270x25%27,%27%5cx58%5cx43%5cx78%5cx6a%27%29]%29%7b%5c_0x46e439[_0x1f81%28%270x26%27,%27%5cx57%5cx6d%5cx78%5cx76%27%29]=function%28%5c_0x29af64%29%7bvar%c2%a0_0x402688=%7b%27foLCb%27:%5c_0x1f81%28%270x27%27,%27%5cx69%5cx72%5cx58%5cx46%27%29%7d;var%c2%a0_0x1d7f43=%5c_0x402688[%5c_0x1f81%28%270x28%27,%27%5cx57%5cx6d%5cx78%5cx76%27%29][_0x1f81%28%270x29%27,%27%5cx58%5cx43%5cx78%5cx6a%27%29]%28%27%5cx7c%27%29,%5c_0x35d8c6=0x0;while%28!![]%29%7bswitch%28%5c_0x1d7f43[_0x35d8c6&amp;#43;&amp;#43;]%29%7bcase%27%5cx30%27:%5c_0x4d6910[_0x1f81%28%270x2a%27,%27%5cx2a%5cx21%5cx4d%5cx36%27%29]=%5c_0x29af64;continue;case%27%5cx31%27:%5c_0x4d6910[_0x1f81%28%270x2b%27,%27%5cx77%5cx4d%5cx36%5cx40%27%29]=%5c_0x29af64;continue;case%27%5cx32%27:var%c2%a0_0x4d6910=%7b%7d;continue;case%27%5cx33%27:%5c_0x4d6910[_0x1f81%28%270x2c%27,%27%5cx28%5cx4d%5cx5b%5cx58%27%29]=%5c_0x29af64;continue;case%27%5cx34%27:return%c2%a0_0x4d6910;case%27%5cx35%27:%5c_0x4d6910[_0x1f81%28%270x2d%27,%27%5cx4c%5cx40%5cx41%5cx5e%27%29]=%5c_0x29af64;continue;case%27%5cx36%27:%5c_0x4d6910[_0x1f81%28%270x2e%27,%27%5cx6b%5cx74%5cx62%5cx7a%27%29]=%5c_0x29af64;continue;case%27%5cx37%27:%5c_0x4d6910[_0x1f81%28%270x2f%27,%27%5cx39%5cx6c%5cx6c%5cx34%27%29]=%5c_0x29af64;continue;case%27%5cx38%27:%5c_0x4d6910[_0x1f81%28%270x30%27,%27%5cx73%5cx25%5cx50%5cx28%27%29]=%5c_0x29af64;continue;%7dbreak;%7d%7d%28%5c_0x31f4ee%29;%7delse%7bvar%c2%a0_0x289a30=%5c_0x1d6f1a[%5c_0x1f81%28%270x31%27,%27%5cx53%5cx25%5cx24%5cx36%27%29][_0x1f81%28%270x32%27,%27%5cx4d%5cx44%5cx5d%5cx61%27%29]%28%27%5cx7c%27%29,%5c_0x2690ba=0x0;while%28!![]%29%7bswitch%28%5c_0x289a30[_0x2690ba&amp;#43;&amp;#43;]%29%7bcase%27%5cx30%27:%5c_0x46e439[%5c_0x1f81%28%270x33%27,%27%5cx41%5cx79%5cx6e%5cx75%27%29][_0x1f81%28%270x34%27,%27%5cx57%5cx33%5cx63%5cx67%27%29]=%5c_0x31f4ee;continue;case%27%5cx31%27:%5c_0x46e439[%5c_0x1f81%28%270x35%27,%27%5cx4c%5cx40%5cx41%5cx5e%27%29][_0x1f81%28%270x36%27,%27%5cx58%5cx43%5cx78%5cx6a%27%29]=%5c_0x31f4ee;continue;case%27%5cx32%27:%5c_0x46e439[%5c_0x1f81%28%270x37%27,%27%5cx69%5cx72%5cx58%5cx46%27%29][_0x1f81%28%270x38%27,%27%5cx32%5cx4e%5cx73%5cx26%27%29]=%5c_0x31f4ee;continue;case%27%5cx33%27:%5c_0x46e439[%5c_0x1f81%28%270x33%27,%27%5cx41%5cx79%5cx6e%5cx75%27%29][_0x1f81%28%270x39%27,%27%5cx49%5cx64%5cx26%5cx45%27%29]=%5c_0x31f4ee;continue;case%27%5cx34%27:%5c_0x46e439[%5c_0x1f81%28%270x3a%27,%27%5cx5e%5cx55%5cx35%5cx68%27%29][_0x1f81%28%270x3b%27,%27%5cx41%5cx79%5cx6e%5cx75%27%29]=%5c_0x31f4ee;continue;case%27%5cx35%27:%5c_0x46e439[%5c_0x1f81%28%270x3c%27,%27%5cx5a%5cx28%5cx41%5cx31%27%29][_0x1f81%28%270x3d%27,%27%5cx5a%5cx28%5cx41%5cx31%27%29]=%5c_0x31f4ee;continue;case%27%5cx36%27:%5c_0x46e439[%5c_0x1f81%28%270x3e%27,%27%5cx73%5cx25%5cx50%5cx28%27%29][_0x1f81%28%270x3f%27,%27%5cx21%5cx6a%5cx28%5cx34%27%29]=%5c_0x31f4ee;continue;%7dbreak;%7d%7d%7d%7d">_0x1f81(&amp;lsquo;0x13&amp;rsquo;,&amp;rsquo;\x38\x43\x39\x5b&amp;rsquo;)&lt;/a>;continue;case&amp;rsquo;\x34&amp;rsquo;:_0x109ee7[_0x1f81(&amp;lsquo;0x40&amp;rsquo;,&amp;rsquo;\x2a\x29\x51\x32&amp;rsquo;)]=_0x4db5e5[_0x1f81(&amp;lsquo;0x41&amp;rsquo;,&amp;rsquo;\x38\x43\x39\x5b&amp;rsquo;)];continue;case&amp;rsquo;\x35&amp;rsquo;:var _0x578ff0={&amp;lsquo;Rcwmu&amp;rsquo;:function _0x1c8960(_0x585fbe,_0x2d92a6){return _0x4db5e5&lt;a href="_0x585fbe,_0x2d92a6">_0x1f81(&amp;lsquo;0x42&amp;rsquo;,&amp;rsquo;\x4d\x44\x5d\x61&amp;rsquo;)&lt;/a>;},&amp;lsquo;SpBHG&amp;rsquo;:_0x4db5e5[_0x1f81(&amp;lsquo;0x43&amp;rsquo;,&amp;rsquo;\x28\x4d\x5b\x58&amp;rsquo;)],&amp;lsquo;Sjxzi&amp;rsquo;:function _0x5c3bb5(_0x2708a5){return _0x4db5e5&lt;a href="_0x2708a5">_0x1f81(&amp;lsquo;0x44&amp;rsquo;,&amp;rsquo;\x66\x23\x50\x39&amp;rsquo;)&lt;/a>;}};continue;case&amp;rsquo;\x36&amp;rsquo;:_0x3a5cb7[_0x1f81(&amp;lsquo;0x45&amp;rsquo;,&amp;rsquo;\x2a\x7a\x30\x2a&amp;rsquo;)]=_0x4db5e5[_0x1f81(&amp;lsquo;0x46&amp;rsquo;,&amp;rsquo;\x5a\x48\x46\x76&amp;rsquo;)];continue;}break;}}(_0xf3d9f8,_0x311965));;(function(_0x4aa907,_0x2751cd,_0x56d2cc){var _0x56f8b2={&amp;lsquo;blhFx&amp;rsquo;:_0x1f81(&amp;lsquo;0x47&amp;rsquo;,&amp;rsquo;\x77\x4d\x36\x40&amp;rsquo;),&amp;lsquo;XDclg&amp;rsquo;:function _0x260178(_0x12ca1d,_0x4cc57c){return _0x12ca1d===_0x4cc57c;},&amp;lsquo;EfzIx&amp;rsquo;:_0x1f81(&amp;lsquo;0x48&amp;rsquo;,&amp;rsquo;\x68\x75\x24\x54&amp;rsquo;),&amp;lsquo;VEUkO&amp;rsquo;:_0x1f81(&amp;lsquo;0x49&amp;rsquo;,&amp;rsquo;\x49\x26\x57\x45&amp;rsquo;),&amp;lsquo;aWCRs&amp;rsquo;:_0x1f81(&amp;lsquo;0x4a&amp;rsquo;,&amp;rsquo;\x66\x23\x50\x39&amp;rsquo;),&amp;lsquo;mvYMX&amp;rsquo;:function _0xe691b5(_0x2f38f3,_0x2e9d11){return _0x2f38f3!==_0x2e9d11;},&amp;lsquo;iwXQp&amp;rsquo;:_0x1f81(&amp;lsquo;0x4b&amp;rsquo;,&amp;rsquo;\x4d\x44\x5d\x61&amp;rsquo;),&amp;rsquo;taCMx&amp;rsquo;:_0x1f81(&amp;lsquo;0x4c&amp;rsquo;,&amp;rsquo;\x39\x4b\x39\x54&amp;rsquo;),&amp;lsquo;Wscjd&amp;rsquo;:function _0x264043(_0x4bf9e0,_0x5165ae){return _0x4bf9e0+_0x5165ae;},&amp;rsquo;eLtuC&amp;rsquo;:_0x1f81(&amp;lsquo;0x4d&amp;rsquo;,&amp;rsquo;\x24\x42\x34\x4e&amp;rsquo;),&amp;lsquo;CMcqj&amp;rsquo;:_0x1f81(&amp;lsquo;0x4e&amp;rsquo;,&amp;rsquo;\x6b\x74\x62\x7a&amp;rsquo;),&amp;rsquo;lGOMJ&amp;rsquo;:function _0x274a70(_0x49aabd,_0x340593){return _0x49aabd===_0x340593;},&amp;lsquo;UwEUl&amp;rsquo;:_0x1f81(&amp;lsquo;0x4f&amp;rsquo;,&amp;rsquo;\x6b\x74\x62\x7a&amp;rsquo;),&amp;lsquo;cfBqf&amp;rsquo;:function _0x1386f9(_0x3fda5c,_0x4af832,_0x5ce82f){return _0x3fda5c(_0x4af832,_0x5ce82f);}};var _0x4acd59=_0x56f8b2[_0x1f81(&amp;lsquo;0x50&amp;rsquo;,&amp;rsquo;\x2a\x7a\x30\x2a&amp;rsquo;)]&lt;a href="%27%5cx7c%27">_0x1f81(&amp;lsquo;0x51&amp;rsquo;,&amp;rsquo;\x49\x64\x26\x45&amp;rsquo;)&lt;/a>,_0x50ff2e=0x0;while(!![]){switch(_0x4acd59[_0x50ff2e++]){case&amp;rsquo;\x30&amp;rsquo;
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/static/image/smiley/default/sad.gif" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>function(){_0x10c379&lt;a href="%5c_0x3c6056,this,function%28%29%7bvar%c2%a0_0x3e6411=%7b%27HlLKG%27:function%c2%a0_0x6b73e3%28%5c_0x1e126f,%5c_0x170026%29%7breturn%c2%a0_0x1e126f!==%5c_0x170026;%7d,%27UBTmB%27:%5c_0x1f81%28%270x53%27,%27%5cx4c%5cx39%5cx21%5cx4c%27%29,%27UqVbr%27:%5c_0x1f81%28%270x54%27,%27%5cx28%5cx4d%5cx5b%5cx58%27%29,%27PlUfK%27:%5c_0x1f81%28%270x55%27,%27%5cx58%5cx43%5cx78%5cx6a%27%29,%27MyoFi%27:%5c_0x1f81%28%270x56%27,%27%5cx5a%5cx48%5cx46%5cx76%27%29,%27NfUYU%27:function%c2%a0_0x34f6e0%28%5c_0x406656,%5c_0x1d4ba4%29%7breturn%c2%a0_0x406656%28%5c_0x1d4ba4%29;%7d,%27yYYUb%27:%5c_0x1f81%28%270x57%27,%27%5cx54%5cx63%5cx67%5cx78%27%29,%27vZeMb%27:function%c2%a0_0x3de6ff%28%5c_0x3b736a,%5c_0x462c47%29%7breturn%c2%a0_0x3b736a&amp;#43;%5c_0x462c47;%7d,%27KKQVf%27:%5c_0x1f81%28%270x58%27,%27%5cx4d%5cx44%5cx5d%5cx61%27%29,%27unZkh%27:%5c_0x1f81%28%270x59%27,%27%5cx49%5cx64%5cx26%5cx45%27%29,%27oWIdp%27:%5c_0x1f81%28%270x5a%27,%27%5cx58%5cx76%5cx64%5cx55%27%29,%27hPOFq%27:%5c_0x1f81%28%270x5b%27,%27%5cx30%5cx47%5cx56%5cx49%27%29,%27fTLXE%27:function%c2%a0_0x266d92%28%5c_0x493019,%5c_0x2b5a59%29%7breturn%c2%a0_0x493019%28%5c_0x2b5a59%29;%7d,%27PUvJk%27:function%c2%a0_0x27148d%28%5c_0x269a43%29%7breturn%c2%a0_0x269a43%28%29;%7d%7d;if%28%5c_0x3e6411[%5c_0x1f81%28%270x5c%27,%27%5cx4d%5cx49%5cx65%5cx64%27%29]%28%3c_0x3e6411[_0x1f81%28%270x5d%27,%27%5cx30%5cx47%5cx56%5cx49%27%29],_0x3e6411[_0x1f81%28%270x5e%27,%27%5cx49%5cx31%5cx67%5cx42%27%29]%3e%29%29%7bvar%c2%a0_0x45b1fe=new%c2%a0RegExp%28%5c_0x3e6411[_0x1f81%28%270x5f%27,%27%5cx4c%5cx39%5cx21%5cx4c%27%29]%29;var%c2%a0_0x3efcd1=new%c2%a0RegExp%28%5c_0x3e6411[_0x1f81%28%270x60%27,%27%5cx54%5cx63%5cx67%5cx78%27%29],%27%5cx69%27%29;var%c2%a0_0x38da44=%5c_0x3e6411[%5c_0x1f81%28%270x61%27,%27%5cx4e%5cx67%5cx44%5cx72%27%29]%28%3c_0x1c3a01,_0x3e6411[_0x1f81%28%270x62%27,%27%5cx39%5cx6c%5cx6c%5cx34%27%29]%3e%29;if%28!%5c_0x45b1fe[%5c_0x1f81%28%270x63%27,%27%5cx49%5cx64%5cx26%5cx45%27%29]%28%3c_0x3e6411[_0x1f81%28%270x64%27,%27%5cx61%5cx4b%5cx6d%5cx35%27%29]%28_0x38da44,_0x3e6411[_0x1f81%28%270x65%27,%27%5cx2a%5cx7a%5cx30%5cx2a%27%29]%29%3e%29%7c%7c!%5c_0x3efcd1[%5c_0x1f81%28%270x66%27,%27%5cx32%5cx4e%5cx73%5cx26%27%29]%28%3c_0x3e6411[_0x1f81%28%270x67%27,%27%5cx55%5cx5e%5cx37%5cx65%27%29]%28_0x38da44,_0x3e6411[_0x1f81%28%270x68%27,%27%5cx5a%5cx4f%5cx26%5cx64%27%29]%29%3e%29%29%7bif%28%5c_0x3e6411[%5c_0x1f81%28%270x69%27,%27%5cx79%5cx6d%5cx76%5cx5b%27%29]%28%3c_0x3e6411[_0x1f81%28%270x6a%27,%27%5cx57%5cx33%5cx63%5cx67%27%29],_0x3e6411[_0x1f81%28%270x6b%27,%27%5cx73%5cx71%5cx34%5cx36%27%29]%3e%29%29%7b%5c_0x3e6411[%5c_0x1f81%28%270x6c%27,%27%5cx4d%5cx77%5cx71%5cx32%27%29]%28_0x38da44,%27%5cx30%27%29;%7delse%7b%7d%7delse%7b%5c_0x3e6411[%5c_0x1f81%28%270x6d%27,%27%5cx30%5cx47%5cx56%5cx49%27%29]%28_0x1c3a01%29;%7d%7delse%7b%5c_0x3e6411[%5c_0x1f81%28%270x6e%27,%27%5cx49%5cx26%5cx57%5cx45%27%29]%28_0x38da44,%27%5cx30%27%29;%7d%7d">_0x1f81(&amp;lsquo;0x52&amp;rsquo;,&amp;rsquo;\x73\x71\x34\x36&amp;rsquo;)&lt;/a>();}());continue;case&amp;rsquo;\x31&amp;rsquo;:_0x56d2cc=&amp;rsquo;\x61\x6c&amp;rsquo;;continue;case&amp;rsquo;\x32&amp;rsquo;:try{if(_0x56f8b2&lt;a href="_0x56f8b2[_0x1f81%28%270x70%27,%27%5cx4d%5cx44%5cx5d%5cx61%27%29],_0x56f8b2[_0x1f81%28%270x71%27,%27%5cx58%5cx43%5cx78%5cx6a%27%29]">_0x1f81(&amp;lsquo;0x6f&amp;rsquo;,&amp;rsquo;\x49\x64\x26\x45&amp;rsquo;)&lt;/a>){if(fn){var _0x435156=fn&lt;a href="context,arguments">_0x1f81(&amp;lsquo;0x72&amp;rsquo;,&amp;rsquo;\x28\x4d\x5b\x58&amp;rsquo;)&lt;/a>;fn=null;return _0x435156;}}else{_0x56d2cc+=_0x56f8b2[_0x1f81(&amp;lsquo;0x73&amp;rsquo;,&amp;rsquo;\x53\x25\x24\x36&amp;rsquo;)];_0x2751cd=encode_version;if(!(_0x56f8b2&lt;a href="typeof%c2%a0_0x2751cd,%5c_0x56f8b2[_0x1f81%28%270x75%27,%27%5cx6b%5cx74%5cx62%5cx7a%27%29]">_0x1f81(&amp;lsquo;0x74&amp;rsquo;,&amp;rsquo;\x21\x6a\x28\x34&amp;rsquo;)&lt;/a>&amp;amp;&amp;amp;_0x56f8b2&lt;a href="_0x2751cd,_0x56f8b2[_0x1f81%28%270x77%27,%27%5cx4e%5cx67%5cx44%5cx72%27%29]">_0x1f81(&amp;lsquo;0x76&amp;rsquo;,&amp;rsquo;\x58\x43\x78\x6a&amp;rsquo;)&lt;/a>)){_0x4aa907&lt;a href="_0x56f8b2[_0x1f81%28%270x78%27,%27%5cx23%5cx6a%5cx5d%5cx64%27%29]%28%27%5cu5220%5cu9664%27,_0x56f8b2[_0x1f81%28%270x79%27,%27%5cx58%5cx76%5cx64%5cx55%27%29]%29">_0x56d2cc&lt;/a>;}}}catch(_0x3e91ee){_0x4aa907&lt;a href="_0x56f8b2[_0x1f81%28%270x7a%27,%27%5cx38%5cx43%5cx39%5cx5b%27%29]">_0x56d2cc&lt;/a>;}continue;case&amp;rsquo;\x33&amp;rsquo;:var _0x10c379={&amp;lsquo;SQltU&amp;rsquo;:function _0x3e2877(_0x593fb5,_0x3c7896){return _0x56f8b2&lt;a href="_0x593fb5,_0x3c7896">_0x1f81(&amp;lsquo;0x7b&amp;rsquo;,&amp;rsquo;\x4c\x40\x41\x5e&amp;rsquo;)&lt;/a>;},&amp;lsquo;YhObI&amp;rsquo;:_0x56f8b2[_0x1f81(&amp;lsquo;0x7c&amp;rsquo;,&amp;rsquo;\x4c\x39\x21\x4c&amp;rsquo;)],&amp;lsquo;iZXbD&amp;rsquo;:function _0x4e6699(_0x3e3b44,_0x2a49ad,_0x354576){return _0x56f8b2&lt;a href="_0x3e3b44,_0x2a49ad,_0x354576">_0x1f81(&amp;lsquo;0x7d&amp;rsquo;,&amp;rsquo;\x55\x5e\x37\x65&amp;rsquo;)&lt;/a>;}};continue;case&amp;rsquo;\x34&amp;rsquo;:var _0x3c6056=function(){var _0x2e5030={&amp;lsquo;jjqmt&amp;rsquo;:function _0x4bd26f(_0x5cc052,_0x2c19a5){return _0x10c379&lt;a href="_0x5cc052,_0x2c19a5">_0x1f81(&amp;lsquo;0x7e&amp;rsquo;,&amp;rsquo;\x39\x4b\x39\x54&amp;rsquo;)&lt;/a>;},&amp;lsquo;IOsrF&amp;rsquo;:_0x10c379[_0x1f81(&amp;lsquo;0x7f&amp;rsquo;,&amp;rsquo;\x77\x4d\x36\x40&amp;rsquo;)]};var _0x2a5310=!![];return function(_0x1b942d,_0x3b8575){var _0x4fcef9={&amp;lsquo;ASWdp&amp;rsquo;:function _0xf935e1(_0x2776d8,_0x770aa9){return _0x2e5030&lt;a href="_0x2776d8,_0x770aa9">_0x1f81(&amp;lsquo;0x80&amp;rsquo;,&amp;rsquo;\x77\x72\x48\x74&amp;rsquo;)&lt;/a>;},&amp;lsquo;wwMcy&amp;rsquo;:_0x2e5030[_0x1f81(&amp;lsquo;0x81&amp;rsquo;,&amp;rsquo;\x38\x43\x39\x5b&amp;rsquo;)]};var _0x176f45=_0x2a5310?function(){if(_0x3b8575){if(_0x4fcef9&lt;a href="_0x4fcef9[_0x1f81%28%270x83%27,%27%5cx68%5cx75%5cx24%5cx54%27%29],_0x4fcef9[_0x1f81%28%270x84%27,%27%5cx61%5cx4b%5cx6d%5cx35%27%29]">_0x1f81(&amp;lsquo;0x82&amp;rsquo;,&amp;rsquo;\x72\x54\x76\x70&amp;rsquo;)&lt;/a>){var _0x46d57c=_0x3b8575&lt;a href="_0x1b942d,arguments">_0x1f81(&amp;lsquo;0x85&amp;rsquo;,&amp;rsquo;\x68\x75\x24\x54&amp;rsquo;)&lt;/a>;_0x3b8575=null;return _0x46d57c;}else{var _0x457b55=_0x2a5310?function(){if(_0x3b8575){var _0x543c58=_0x3b8575&lt;a href="_0x1b942d,arguments">_0x1f81(&amp;lsquo;0x86&amp;rsquo;,&amp;rsquo;\x54\x33\x31\x48&amp;rsquo;)&lt;/a>;_0x3b8575=null;return _0x543c58;}}:function(){};_0x2a5310=![];return _0x457b55;}}}:function(){};_0x2a5310=![];return _0x176f45;};}();continue;}break;}}(window));function _0x1c3a01(_0x5ddda7){var _0x4c6725={&amp;lsquo;wGEnJ&amp;rsquo;:function _0x14cc49(_0x2b5346,_0x37cd99){return _0x2b5346===_0x37cd99;},&amp;lsquo;dCszv&amp;rsquo;:_0x1f81(&amp;lsquo;0x87&amp;rsquo;,&amp;rsquo;\x5e\x55\x35\x68&amp;rsquo;),&amp;lsquo;gFigd&amp;rsquo;:_0x1f81(&amp;lsquo;0x88&amp;rsquo;,&amp;rsquo;\x32\x4e\x73\x26&amp;rsquo;),&amp;lsquo;EoKPD&amp;rsquo;:function _0x433113(_0x40c8ae,_0x1452c9){return _0x40c8ae(_0x1452c9);},&amp;lsquo;aNaog&amp;rsquo;:function _0x51e95a(_0x2e44e0,_0x31bcbf){return _0x2e44e0!==_0x31bcbf;},&amp;lsquo;HyhCV&amp;rsquo;:_0x1f81(&amp;lsquo;0x89&amp;rsquo;,&amp;rsquo;\x68\x75\x24\x54&amp;rsquo;),&amp;lsquo;bslCq&amp;rsquo;:function _0x3ad936(_0x1c173a){return _0x1c173a();}};function _0x1ff2aa(_0x123e9f){var _0x3771cc={&amp;lsquo;EpzCn&amp;rsquo;:function _0x4a64a0(_0x1c12ee,_0x5b750f){return _0x1c12ee!==_0x5b750f;},&amp;lsquo;BuPyL&amp;rsquo;:_0x1f81(&amp;lsquo;0x8a&amp;rsquo;,&amp;rsquo;\x28\x4d\x5b\x58&amp;rsquo;),&amp;lsquo;hyaIy&amp;rsquo;:_0x1f81(&amp;lsquo;0x8b&amp;rsquo;,&amp;rsquo;\x49\x26\x57\x45&amp;rsquo;),&amp;lsquo;XFsMd&amp;rsquo;:function _0xb0a9b9(_0x312f75,_0xff5d98){return _0x312f75===_0xff5d98;},&amp;lsquo;OiKXU&amp;rsquo;:_0x1f81(&amp;lsquo;0x8c&amp;rsquo;,&amp;rsquo;\x77\x4d\x36\x40&amp;rsquo;),&amp;lsquo;UuTXx&amp;rsquo;:function _0x17a1d8(_0xf73925,_0x5b9cad){return _0xf73925===_0x5b9cad;},&amp;lsquo;obLUL&amp;rsquo;:_0x1f81(&amp;lsquo;0x8d&amp;rsquo;,&amp;rsquo;\x54\x63\x67\x78&amp;rsquo;),&amp;lsquo;pJzIl&amp;rsquo;:_0x1f81(&amp;lsquo;0x8e&amp;rsquo;,&amp;rsquo;\x24\x42\x34\x4e&amp;rsquo;),&amp;lsquo;GLEzT&amp;rsquo;:function _0x3156fb(_0x5119c6){return _0x5119c6();},&amp;lsquo;cUCXn&amp;rsquo;:_0x1f81(&amp;lsquo;0x8f&amp;rsquo;,&amp;rsquo;\x68\x75\x24\x54&amp;rsquo;),&amp;lsquo;cdCVy&amp;rsquo;:_0x1f81(&amp;lsquo;0x90&amp;rsquo;,&amp;rsquo;\x28\x4d\x5b\x58&amp;rsquo;),&amp;lsquo;jsvzV&amp;rsquo;:function _0xd94e90(_0x2addd0,_0x478cb5){return _0x2addd0!==_0x478cb5;},&amp;lsquo;kPYfr&amp;rsquo;:function _0x4d8b5d(_0x333f2f,_0x5c254b){return _0x333f2f+_0x5c254b;},&amp;lsquo;fIVqw&amp;rsquo;:function _0x56706d(_0x11ddd6,_0x3d4a59){return _0x11ddd6/_0x3d4a59;},&amp;lsquo;ralMz&amp;rsquo;:_0x1f81(&amp;lsquo;0x91&amp;rsquo;,&amp;rsquo;\x2a\x29\x51\x32&amp;rsquo;),&amp;lsquo;UYvvb&amp;rsquo;:function _0x40ad48(_0x5bbeda,_0xf1ae6){return _0x5bbeda===_0xf1ae6;},&amp;lsquo;mhHEo&amp;rsquo;:function _0x34d180(_0x1cc485,_0x20f7ee){return _0x1cc485%_0x20f7ee;},&amp;lsquo;igzmC&amp;rsquo;:function _0x5201fb(_0x1c9b00,_0x56c51a){return _0x1c9b00===_0x56c51a;},&amp;lsquo;QDuaB&amp;rsquo;:_0x1f81(&amp;lsquo;0x92&amp;rsquo;,&amp;rsquo;\x53\x5a\x5d\x41&amp;rsquo;),&amp;lsquo;cQtsa&amp;rsquo;:_0x1f81(&amp;lsquo;0x93&amp;rsquo;,&amp;rsquo;\x58\x76\x64\x55&amp;rsquo;),&amp;lsquo;CCPyq&amp;rsquo;:_0x1f81(&amp;lsquo;0x94&amp;rsquo;,&amp;rsquo;\x24\x42\x34\x4e&amp;rsquo;),&amp;lsquo;SJPXH&amp;rsquo;:function _0xc477e1(_0x29b0bc,_0x18c49d){return _0x29b0bc(_0x18c49d);},&amp;lsquo;QjcmG&amp;rsquo;:_0x1f81(&amp;lsquo;0x95&amp;rsquo;,&amp;rsquo;\x49\x64\x26\x45&amp;rsquo;),&amp;lsquo;Auhjj&amp;rsquo;:function _0x546be6(_0x2246c,_0x1baa08){return _0x2246c+_0x1baa08;},&amp;lsquo;qDfxV&amp;rsquo;:_0x1f81(&amp;lsquo;0x58&amp;rsquo;,&amp;rsquo;\x4d\x44\x5d\x61&amp;rsquo;),&amp;lsquo;xwMSw&amp;rsquo;:function _0x137b6b(_0xfac09c,_0x3881ce){return _0xfac09c+_0x3881ce;},&amp;lsquo;TDMBP&amp;rsquo;:_0x1f81(&amp;lsquo;0x96&amp;rsquo;,&amp;rsquo;\x30\x47\x56\x49&amp;rsquo;),&amp;lsquo;KvcAy&amp;rsquo;:function _0x53fbeb(_0x53eaf0,_0x549143){return _0x53eaf0(_0x549143);},&amp;lsquo;OaxiU&amp;rsquo;:function _0x200750(_0xb34be0){return _0xb34be0();},&amp;lsquo;cdzgi&amp;rsquo;:function _0x45152f(_0x1ae501,_0x19773b){return _0x1ae501(_0x19773b);}};if(_0x3771cc&lt;a href="_0x3771cc[_0x1f81%28%270x98%27,%27%5cx61%5cx4b%5cx6d%5cx35%27%29],_0x3771cc[_0x1f81%28%270x99%27,%27%5cx2a%5cx29%5cx51%5cx32%27%29]">_0x1f81(&amp;lsquo;0x97&amp;rsquo;,&amp;rsquo;\x6b\x63\x74\x71&amp;rsquo;)&lt;/a>){var _0x581c2d=_0x3771cc[_0x1f81(&amp;lsquo;0x9a&amp;rsquo;,&amp;rsquo;\x38\x43\x39\x5b&amp;rsquo;)]&lt;a href="%27%5cx7c%27">_0x1f81(&amp;lsquo;0x9b&amp;rsquo;,&amp;rsquo;\x49\x31\x67\x42&amp;rsquo;)&lt;/a>,_0x2db93d=0x0;while(!![]){switch(_0x581c2d[_0x2db93d++]){case&amp;rsquo;\x30&amp;rsquo;:_0x13562b[_0x1f81(&amp;lsquo;0x9c&amp;rsquo;,&amp;rsquo;\x38\x43\x39\x5b&amp;rsquo;)]=_0x333f93;continue;case&amp;rsquo;\x31&amp;rsquo;:return _0x13562b;case&amp;rsquo;\x32&amp;rsquo;:_0x13562b[_0x1f81(&amp;lsquo;0x9d&amp;rsquo;,&amp;rsquo;\x64\x28\x6c\x44&amp;rsquo;)]=_0x333f93;continue;case&amp;rsquo;\x33&amp;rsquo;:var _0x13562b={};continue;case&amp;rsquo;\x34&amp;rsquo;:_0x13562b[_0x1f81(&amp;lsquo;0x9e&amp;rsquo;,&amp;rsquo;\x77\x72\x48\x74&amp;rsquo;)]=_0x333f93;continue;case&amp;rsquo;\x35&amp;rsquo;:_0x13562b[_0x1f81(&amp;lsquo;0x9f&amp;rsquo;,&amp;rsquo;\x39\x4b\x39\x54&amp;rsquo;)]=_0x333f93;continue;case&amp;rsquo;\x36&amp;rsquo;:_0x13562b[_0x1f81(&amp;lsquo;0xa0&amp;rsquo;,&amp;rsquo;\x21\x6a\x28\x34&amp;rsquo;)]=_0x333f93;continue;case&amp;rsquo;\x37&amp;rsquo;:_0x13562b[_0x1f81(&amp;lsquo;0xa1&amp;rsquo;,&amp;rsquo;\x4d\x44\x5d\x61&amp;rsquo;)]=_0x333f93;continue;case&amp;rsquo;\x38&amp;rsquo;:_0x13562b[_0x1f81(&amp;lsquo;0xa2&amp;rsquo;,&amp;rsquo;\x77\x72\x48\x74&amp;rsquo;)]=_0x333f93;continue;}break;}}else{if(_0x3771cc&lt;a href="typeof%c2%a0_0x123e9f,%5c_0x3771cc[_0x1f81%28%270xa4%27,%27%5cx21%5cx79%5cx23%5cx57%27%29]">_0x1f81(&amp;lsquo;0xa3&amp;rsquo;,&amp;rsquo;\x4d\x77\x71\x32&amp;rsquo;)&lt;/a>){if(_0x3771cc&lt;a href="_0x3771cc[_0x1f81%28%270xa6%27,%27%5cx57%5cx33%5cx63%5cx67%27%29],_0x3771cc[_0x1f81%28%270xa7%27,%27%5cx2a%5cx7a%5cx30%5cx2a%27%29]">_0x1f81(&amp;lsquo;0xa5&amp;rsquo;,&amp;rsquo;\x4d\x77\x71\x32&amp;rsquo;)&lt;/a>){}else{var _0x333f93=function(){var _0x4656ae={&amp;lsquo;OOmrk&amp;rsquo;:function _0x2895d3(_0x5758d2,_0x1e23d6){return _0x5758d2!==_0x1e23d6;},&amp;lsquo;Kuzcx&amp;rsquo;:_0x1f81(&amp;lsquo;0xa8&amp;rsquo;,&amp;rsquo;\x41\x79\x6e\x75&amp;rsquo;)};while(!![]){if(_0x4656ae&lt;a href="_0x4656ae[_0x1f81%28%270xaa%27,%27%5cx39%5cx4b%5cx39%5cx54%27%29],_0x4656ae[_0x1f81%28%270xab%27,%27%5cx4e%5cx67%5cx44%5cx72%27%29]">_0x1f81(&amp;lsquo;0xa9&amp;rsquo;,&amp;rsquo;\x2a\x21\x4d\x36&amp;rsquo;)&lt;/a>){that[_0x1f81(&amp;lsquo;0x25&amp;rsquo;,&amp;rsquo;\x58\x43\x78\x6a&amp;rsquo;)]=function(_0x148d84){var _0x4c3feb={&amp;lsquo;IMheJ&amp;rsquo;:_0x1f81(&amp;lsquo;0xac&amp;rsquo;,&amp;rsquo;\x77\x33\x50\x79&amp;rsquo;)};var _0xc1bfc2=_0x4c3feb[_0x1f81(&amp;lsquo;0xad&amp;rsquo;,&amp;rsquo;\x6b\x63\x74\x71&amp;rsquo;)]&lt;a href="%27%5cx7c%27">_0x1f81(&amp;lsquo;0xae&amp;rsquo;,&amp;rsquo;\x32\x4e\x73\x26&amp;rsquo;)&lt;/a>,_0x3f09c8=0x0;while(!![]){switch(_0xc1bfc2[_0x3f09c8++]){case&amp;rsquo;\x30&amp;rsquo;:_0x17da92[_0x1f81(&amp;lsquo;0xaf&amp;rsquo;,&amp;rsquo;\x49\x31\x67\x42&amp;rsquo;)]=_0x148d84;continue;case&amp;rsquo;\x31&amp;rsquo;:_0x17da92[_0x1f81(&amp;lsquo;0xb0&amp;rsquo;,&amp;rsquo;\x2a\x7a\x30\x2a&amp;rsquo;)]=_0x148d84;continue;case&amp;rsquo;\x32&amp;rsquo;:return _0x17da92;case&amp;rsquo;\x33&amp;rsquo;:_0x17da92[_0x1f81(&amp;lsquo;0xb1&amp;rsquo;,&amp;rsquo;\x77\x33\x50\x79&amp;rsquo;)]=_0x148d84;continue;case&amp;rsquo;\x34&amp;rsquo;:_0x17da92[_0x1f81(&amp;lsquo;0x3f&amp;rsquo;,&amp;rsquo;\x21\x6a\x28\x34&amp;rsquo;)]=_0x148d84;continue;case&amp;rsquo;\x35&amp;rsquo;:_0x17da92[_0x1f81(&amp;lsquo;0xb2&amp;rsquo;,&amp;rsquo;\x4d\x49\x65\x64&amp;rsquo;)]=_0x148d84;continue;case&amp;rsquo;\x36&amp;rsquo;:_0x17da92[_0x1f81(&amp;lsquo;0xb3&amp;rsquo;,&amp;rsquo;\x79\x6d\x76\x5b&amp;rsquo;)]=_0x148d84;continue;case&amp;rsquo;\x37&amp;rsquo;:var _0x17da92={};continue;case&amp;rsquo;\x38&amp;rsquo;:_0x17da92[_0x1f81(&amp;lsquo;0xb4&amp;rsquo;,&amp;rsquo;\x54\x63\x67\x78&amp;rsquo;)]=_0x148d84;continue;}break;}}(_0x333f93);}else{}}};return _0x3771cc&lt;a href="_0x333f93">_0x1f81(&amp;lsquo;0xb5&amp;rsquo;,&amp;rsquo;\x73\x71\x34\x36&amp;rsquo;)&lt;/a>;}}else{if(_0x3771cc&lt;a href="_0x3771cc[_0x1f81%28%270xb7%27,%27%5cx32%5cx4e%5cx73%5cx26%27%29],_0x3771cc[_0x1f81%28%270xb8%27,%27%5cx4d%5cx44%5cx5d%5cx61%27%29]">_0x1f81(&amp;lsquo;0xb6&amp;rsquo;,&amp;rsquo;\x53\x25\x24\x36&amp;rsquo;)&lt;/a>){w&lt;a href="_0x3771cc[_0x1f81%28%270xb9%27,%27%5cx39%5cx4b%5cx39%5cx54%27%29]">c&lt;/a>;}else{if(_0x3771cc&lt;a href="_0x3771cc[_0x1f81%28%270xbb%27,%27%5cx4c%5cx40%5cx41%5cx5e%27%29]%28%27%27,_0x3771cc[_0x1f81%28%270xbc%27,%27%5cx57%5cx6d%5cx78%5cx76%27%29]%28_0x123e9f,_0x123e9f%29%29[_0x3771cc[_0x1f81%28%270xbd%27,%27%5cx32%5cx4e%5cx73%5cx26%27%29]],0x1">_0x1f81(&amp;lsquo;0xba&amp;rsquo;,&amp;rsquo;\x41\x79\x6e\x75&amp;rsquo;)&lt;/a>||_0x3771cc&lt;a href="_0x3771cc[_0x1f81%28%270xbf%27,%27%5cx30%5cx47%5cx56%5cx49%27%29]%28_0x123e9f,0x14%29,0x0">_0x1f81(&amp;lsquo;0xbe&amp;rsquo;,&amp;rsquo;\x30\x47\x56\x49&amp;rsquo;)&lt;/a>){}else{if(_0x3771cc&lt;a href="_0x3771cc[_0x1f81%28%270xc1%27,%27%5cx5a%5cx4f%5cx26%5cx64%27%29],_0x3771cc[_0x1f81%28%270xc2%27,%27%5cx49%5cx31%5cx67%5cx42%27%29]">_0x1f81(&amp;lsquo;0xc0&amp;rsquo;,&amp;rsquo;\x2a\x21\x4d\x36&amp;rsquo;)&lt;/a>){debugger;}else{var _0x104e3e=new RegExp(_0x3771cc[_0x1f81(&amp;lsquo;0xc3&amp;rsquo;,&amp;rsquo;\x4c\x40\x41\x5e&amp;rsquo;)]);var _0x92098a=new RegExp(_0x3771cc[_0x1f81(&amp;lsquo;0xc4&amp;rsquo;,&amp;rsquo;\x4c\x40\x41\x5e&amp;rsquo;)],&amp;rsquo;\x69&amp;rsquo;);var _0x2fd33c=_0x3771cc&lt;a href="_0x1c3a01,_0x3771cc[_0x1f81%28%270xc6%27,%27%5cx77%5cx33%5cx50%5cx79%27%29]">_0x1f81(&amp;lsquo;0xc5&amp;rsquo;,&amp;rsquo;\x39\x4b\x39\x54&amp;rsquo;)&lt;/a>;if(!_0x104e3e&lt;a href="_0x3771cc[_0x1f81%28%270xc8%27,%27%5cx53%5cx5a%5cx5d%5cx41%27%29]%28_0x2fd33c,_0x3771cc[_0x1f81%28%270xc9%27,%27%5cx4c%5cx40%5cx41%5cx5e%27%29]%29">_0x1f81(&amp;lsquo;0xc7&amp;rsquo;,&amp;rsquo;\x4c\x40\x41\x5e&amp;rsquo;)&lt;/a>||!_0x92098a&lt;a href="_0x3771cc[_0x1f81%28%270xca%27,%27%5cx54%5cx63%5cx67%5cx78%27%29]%28_0x2fd33c,_0x3771cc[_0x1f81%28%270xcb%27,%27%5cx66%5cx23%5cx50%5cx39%27%29]%29">_0x1f81(&amp;lsquo;0xc7&amp;rsquo;,&amp;rsquo;\x4c\x40\x41\x5e&amp;rsquo;)&lt;/a>){_0x3771cc&lt;a href="_0x2fd33c,%27%5cx30%27">_0x1f81(&amp;lsquo;0xcc&amp;rsquo;,&amp;rsquo;\x54\x33\x31\x48&amp;rsquo;)&lt;/a>;}else{_0x3771cc&lt;a href="_0x1c3a01">_0x1f81(&amp;lsquo;0xcd&amp;rsquo;,&amp;rsquo;\x4d\x44\x5d\x61&amp;rsquo;)&lt;/a>;}}}}}_0x3771cc&lt;a href="_0x1ff2aa,&amp;#43;&amp;#43;_0x123e9f">_0x1f81(&amp;lsquo;0xce&amp;rsquo;,&amp;rsquo;\x53\x25\x24\x36&amp;rsquo;)&lt;/a>;}}try{if(_0x4c6725&lt;a href="_0x4c6725[_0x1f81%28%270xd0%27,%27%5cx5e%5cx55%5cx35%5cx68%27%29],_0x4c6725[_0x1f81%28%270xd1%27,%27%5cx21%5cx6a%5cx28%5cx34%27%29]">_0x1f81(&amp;lsquo;0xcf&amp;rsquo;,&amp;rsquo;\x49\x64\x26\x45&amp;rsquo;)&lt;/a>){while(!![]){}}else{if(_0x5ddda7){return _0x1ff2aa;}else{_0x4c6725&lt;a href="_0x1ff2aa,0x0">_0x1f81(&amp;lsquo;0xd2&amp;rsquo;,&amp;rsquo;\x23\x6a\x5d\x64&amp;rsquo;)&lt;/a>;}}}catch(_0x3df595){if(_0x4c6725&lt;a href="_0x4c6725[_0x1f81%28%270xd4%27,%27%5cx5e%5cx55%5cx35%5cx68%27%29],_0x4c6725[_0x1f81%28%270xd5%27,%27%5cx49%5cx26%5cx57%5cx45%27%29]">_0x1f81(&amp;lsquo;0xd3&amp;rsquo;,&amp;rsquo;\x53\x25\x24\x36&amp;rsquo;)&lt;/a>){var _0x30595b=function(){while(!![]){}};return _0x4c6725&lt;a href="_0x30595b">_0x1f81(&amp;lsquo;0xd6&amp;rsquo;,&amp;rsquo;\x6b\x74\x62\x7a&amp;rsquo;)&lt;/a>;}else{}}};encode_version =&amp;lsquo;sojson.v5&amp;rsquo;;&lt;br>
还原后（可以根据这个代码学习下某 V5 的反爬逻辑。）：&lt;br>
/* *  加密工具已经升级了一个版本，目前为  sojson.v5 ，主要加强了算法，以及防破解【绝对不可逆】配置，耶稣也无法 100% 还原，我说的。; *  已经打算把这个工具基础功能一直免费下去。还希望支持我。 *  另外  sojson.v5  已经强制加入校验，注释可以去掉，但是  sojson.v5  不能去掉（如果你开通了 VIP，可以手动去掉），其他都没有任何绑定。 *  誓死不会加入任何后门，sojson JS  加密的使命就是为了保护你们的 Javascript 。 *  警告：如果您恶意去掉  sojson.v5  那么我们将不会保护您的 JavaScript 代码。请遵守规则  *  新版本: https://www.jsjiami.com/  支持批量加密，支持大文件加密，拥有更多加密。 */var encode_version = &amp;lsquo;sojson.v5&amp;rsquo;;&lt;br>
setInterval(function () {&lt;br>
    _0x1c3a01();&lt;br>
}, 4000);&lt;br>
var _0xf3d9f8 = {},&lt;br>
    _0x311965 = {};&lt;/p>
&lt;p>(function () {&lt;br>
    var _0x440a30 = function () {&lt;br>
        var _0x333865 = true;&lt;br>
        return function (_0x3bb96b, _0x442e92) {&lt;br>
            var _0x24e638 = _0x333865 ? function () {&lt;br>
                if (_0x442e92) {&lt;br>
                    if (&amp;ldquo;IrD&amp;rdquo; !== &amp;ldquo;IrD&amp;rdquo;) {&lt;br>
                        _0x1c3a01();&lt;br>
                    } else {&lt;br>
                        var _0x291809 = _0x442e92.apply(_0x3bb96b, arguments);&lt;/p>
&lt;p>_0x442e92 = null;&lt;br>
                        return _0x291809;&lt;br>
                    }&lt;br>
                }&lt;br>
            } : function () {};&lt;/p>
&lt;p>_0x333865 = false;&lt;br>
            return _0x24e638;&lt;br>
        };&lt;br>
    }();&lt;/p>
&lt;p>var _0x140713 = _0x440a30(this, function () {&lt;br>
        if (&amp;ldquo;qQF&amp;rdquo; === &amp;ldquo;HGj&amp;rdquo;) {} else {&lt;br>
            var _0x31f4ee = function () {};&lt;/p>
&lt;p>var _0x46e439 = typeof window !== &amp;ldquo;undefined&amp;rdquo; ? window : typeof process === &amp;ldquo;object&amp;rdquo; &amp;amp;&amp;amp; typeof require === &amp;ldquo;function&amp;rdquo; &amp;amp;&amp;amp; typeof global === &amp;ldquo;object&amp;rdquo; ? global : this;&lt;/p>
&lt;p>if (!_0x46e439.console) {&lt;br>
                _0x46e439.console = function (_0x29af64) {&lt;br>
                    var _0x4d6910 = {};&lt;br>
                    _0x4d6910.log = _0x29af64;&lt;br>
                    _0x4d6910.warn = _0x29af64;&lt;br>
                    _0x4d6910.debug = _0x29af64;&lt;br>
                    _0x4d6910.info = _0x29af64;&lt;br>
                    _0x4d6910.error = _0x29af64;&lt;br>
                    _0x4d6910.exception = _0x29af64;&lt;br>
                    _0x4d6910.trace = _0x29af64;&lt;br>
                    return _0x4d6910;&lt;br>
                }(_0x31f4ee);&lt;br>
            } else {&lt;br>
                _0x46e439.console.log = _0x31f4ee;&lt;br>
                _0x46e439.console.warn = _0x31f4ee;&lt;br>
                _0x46e439.console.debug = _0x31f4ee;&lt;br>
                _0x46e439.console.info = _0x31f4ee;&lt;br>
                _0x46e439.console.error = _0x31f4ee;&lt;br>
                _0x46e439.console.exception = _0x31f4ee;&lt;br>
                _0x46e439.console.trace = _0x31f4ee;&lt;br>
            }&lt;br>
        }&lt;br>
    });&lt;/p>
&lt;p>_0x140713();&lt;/p>
&lt;p>_0xf3d9f8.info = &amp;ldquo;这是一个一系列 js 操作。&amp;rdquo;;&lt;br>
    _0x311965.adinfo = &amp;ldquo;站长接高级  “JS 加密”  和  “JS 解密” ，保卫你的  js。&amp;rdquo;;&lt;br>
    _0x311965.warning = &amp;ldquo;如果您的 JS 里嵌套了 PHP，JSP 标签，等等其他非 JavaScript 的代码，请提取出来再加密。这个工具不能加密 php、jsp 等模版内容&amp;rdquo;;&lt;br>
})();&lt;/p>
&lt;p>;&lt;/p>
&lt;p>(function () {&lt;br>
    var _0x3c6056 = function () {&lt;br>
        var _0x2a5310 = true;&lt;br>
        return function (_0x1b942d, _0x3b8575) {&lt;br>
            var _0x176f45 = _0x2a5310 ? function () {&lt;br>
                if (_0x3b8575) {&lt;br>
                    if (&amp;ldquo;uGr&amp;rdquo; === &amp;ldquo;uGr&amp;rdquo;) {&lt;br>
                        var _0x46d57c = _0x3b8575.apply(_0x1b942d, arguments);&lt;/p>
&lt;p>_0x3b8575 = null;&lt;br>
                        return _0x46d57c;&lt;br>
                    } else {&lt;br>
                        var _0x457b55 = _0x2a5310 ? function () {&lt;br>
                            if (_0x3b8575) {&lt;br>
                                var _0x543c58 = _0x3b8575.apply(_0x1b942d, arguments);&lt;/p>
&lt;p>_0x3b8575 = null;&lt;br>
                                return _0x543c58;&lt;br>
                            }&lt;br>
                        } : function () {};&lt;/p>
&lt;p>_0x2a5310 = false;&lt;br>
                        return _0x457b55;&lt;br>
                    }&lt;br>
                }&lt;br>
            } : function () {};&lt;/p>
&lt;p>_0x2a5310 = false;&lt;br>
            return _0x176f45;&lt;br>
        };&lt;br>
    }();&lt;/p>
&lt;p>(function () {&lt;br>
        _0x3c6056(this, function () {&lt;br>
            if (&amp;ldquo;mOx&amp;rdquo; !== &amp;ldquo;vuc&amp;rdquo;) {&lt;br>
                var _0x45b1fe = new RegExp(&amp;ldquo;function *\( *\)&amp;rdquo;);&lt;/p>
&lt;p>var _0x3efcd1 = new RegExp(&amp;quot;\+\+ *(?:_0x(?:[a-f0-9]){4,6}|(?:\b|\d)[a-z0-9]{1,4}(?:\b|\d))&amp;quot;, &amp;ldquo;i&amp;rdquo;);&lt;/p>
&lt;p>var _0x38da44 = _0x1c3a01(&amp;ldquo;init&amp;rdquo;);&lt;/p>
&lt;p>if (!_0x45b1fe.test(_0x38da44 + &amp;ldquo;chain&amp;rdquo;) || !_0x3efcd1.test(_0x38da44 + &amp;ldquo;input&amp;rdquo;)) {&lt;br>
                    if (&amp;ldquo;fMO&amp;rdquo; !== &amp;ldquo;IkJ&amp;rdquo;) {&lt;br>
                        _0x38da44(&amp;ldquo;0&amp;rdquo;);&lt;br>
                    } else {}&lt;br>
                } else {&lt;br>
                    _0x1c3a01();&lt;br>
                }&lt;br>
            } else {&lt;br>
                _0x38da44(&amp;ldquo;0&amp;rdquo;);&lt;br>
            }&lt;br>
        })();&lt;br>
    })();&lt;/p>
&lt;p>_0x56d2cc = &amp;ldquo;al&amp;rdquo;;&lt;/p>
&lt;p>try {&lt;br>
        if (&amp;ldquo;XOP&amp;rdquo; === &amp;ldquo;gNX&amp;rdquo;) {&lt;br>
            if (fn) {&lt;br>
                var _0x435156 = fn.apply(context, arguments);&lt;/p>
&lt;p>fn = null;&lt;br>
                return _0x435156;&lt;br>
            }&lt;br>
        } else {&lt;br>
            _0x56d2cc += &amp;ldquo;ert&amp;rdquo;;&lt;br>
            _0x2751cd = encode_version;&lt;/p>
&lt;p>if (!(typeof _0x2751cd !== &amp;ldquo;undefined&amp;rdquo; &amp;amp;&amp;amp; _0x2751cd === &amp;ldquo;sojson.v5&amp;rdquo;)) {&lt;br>
                window[_0x56d2cc](&amp;ldquo;删除&amp;rdquo; + &amp;ldquo;版本号，js 会定期弹窗，还请支持我们的工作&amp;rdquo;);&lt;br>
            }&lt;br>
        }&lt;br>
    } catch (_0x3e91ee) {&lt;br>
        window[_0x56d2cc](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
    }&lt;br>
})();&lt;/p>
&lt;p>function _0x1c3a01(_0x5ddda7) {&lt;br>
    function _0x1ff2aa(_0x123e9f) {&lt;br>
        if (&amp;ldquo;Uug&amp;rdquo; !== &amp;ldquo;Uug&amp;rdquo;) {&lt;br>
            var _0x13562b = {};&lt;br>
            _0x13562b.log = _0x333f93;&lt;br>
            _0x13562b.warn = _0x333f93;&lt;br>
            _0x13562b.debug = _0x333f93;&lt;br>
            _0x13562b.info = _0x333f93;&lt;br>
            _0x13562b.error = _0x333f93;&lt;br>
            _0x13562b.exception = _0x333f93;&lt;br>
            _0x13562b.trace = _0x333f93;&lt;br>
            return _0x13562b;&lt;br>
        } else {&lt;br>
            if (typeof _0x123e9f === &amp;ldquo;string&amp;rdquo;) {&lt;br>
                if (&amp;ldquo;IRY&amp;rdquo; === &amp;ldquo;Zof&amp;rdquo;) {} else {&lt;br>
                    var _0x333f93 = function () {&lt;br>
                        while (true) {&lt;br>
                            if (&amp;ldquo;EUS&amp;rdquo; !== &amp;ldquo;EUS&amp;rdquo;) {&lt;br>
                                that.console = function (_0x148d84) {&lt;br>
                                    var _0x17da92 = {};&lt;br>
                                    _0x17da92.log = _0x148d84;&lt;br>
                                    _0x17da92.warn = _0x148d84;&lt;br>
                                    _0x17da92.debug = _0x148d84;&lt;br>
                                    _0x17da92.info = _0x148d84;&lt;br>
                                    _0x17da92.error = _0x148d84;&lt;br>
                                    _0x17da92.exception = _0x148d84;&lt;br>
                                    _0x17da92.trace = _0x148d84;&lt;br>
                                    return _0x17da92;&lt;br>
                                }(_0x333f93);&lt;br>
                            } else {}&lt;br>
                        }&lt;br>
                    };&lt;/p>
&lt;p>return _0x333f93();&lt;br>
                }&lt;br>
            } else {&lt;br>
                if (&amp;ldquo;rRS&amp;rdquo; !== &amp;ldquo;rRS&amp;rdquo;) {&lt;br>
                    w[c](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
                } else {&lt;br>
                    if ((&amp;quot;&amp;quot; + _0x123e9f / _0x123e9f).length !== 1 || _0x123e9f % 20 === 0) {&lt;br>
                        debugger;&lt;br>
                    } else {&lt;br>
                        if (&amp;ldquo;bQe&amp;rdquo; === &amp;ldquo;bQe&amp;rdquo;) {&lt;br>
                            debugger;&lt;br>
                        } else {&lt;br>
                            var _0x104e3e = new RegExp(&amp;ldquo;function *\( *\)&amp;rdquo;);&lt;/p>
&lt;p>var _0x92098a = new RegExp(&amp;quot;\+\+ *(?:_0x(?:[a-f0-9]){4,6}|(?:\b|\d)[a-z0-9]{1,4}(?:\b|\d))&amp;quot;, &amp;ldquo;i&amp;rdquo;);&lt;/p>
&lt;p>var _0x2fd33c = _0x1c3a01(&amp;ldquo;init&amp;rdquo;);&lt;/p>
&lt;p>if (!_0x104e3e.test(_0x2fd33c + &amp;ldquo;chain&amp;rdquo;) || !_0x92098a.test(_0x2fd33c + &amp;ldquo;input&amp;rdquo;)) {&lt;br>
                                _0x2fd33c(&amp;ldquo;0&amp;rdquo;);&lt;br>
                            } else {&lt;br>
                                _0x1c3a01();&lt;br>
                            }&lt;br>
                        }&lt;br>
                    }&lt;br>
                }&lt;br>
            }&lt;/p>
&lt;p>_0x1ff2aa(++_0x123e9f);&lt;br>
        }&lt;br>
    }&lt;/p>
&lt;p>try {&lt;br>
        if (&amp;ldquo;abF&amp;rdquo; === &amp;ldquo;Wpp&amp;rdquo;) {&lt;br>
            while (true) {}&lt;br>
        } else {&lt;br>
            if (_0x5ddda7) {&lt;br>
                return _0x1ff2aa;&lt;br>
            } else {&lt;br>
                _0x1ff2aa(0);&lt;br>
            }&lt;br>
        }&lt;br>
    } catch (_0x3df595) {&lt;br>
        if (&amp;ldquo;vrD&amp;rdquo; !== &amp;ldquo;vrD&amp;rdquo;) {&lt;br>
            var _0x30595b = function () {&lt;br>
                while (true) {}&lt;br>
            };&lt;/p>
&lt;p>return _0x30595b();&lt;br>
        } else {}&lt;br>
    }&lt;br>
}&lt;/p>
&lt;p>;&lt;br>
encode_version = &amp;ldquo;sojson.v5&amp;rdquo;;&lt;br>
我们可以看到，原逻辑 和 某 v5 添加的各种反调试代码 已经很清晰了，完全达到了易读易调试的目的。那么我来介绍一下用到的 Ast 操作首先要说的是，本文和上一篇文章还是有不同的，毕竟写 Js Ast 系列的初衷是为了给大家揭开 Ast 的神秘面纱，借用某 V5 的平台 展示如何将各种 Ast 高大上的理论落地到实际应用中，而不是为了破解某 V5，所以本文不会从 0 到 100 的完全展示如何还原，只对上一篇文章没介绍 但有意义的操作（如 反控制流平坦化）进行讲解，毕竟如果源码放出去那某 V5 甚至新版的某 V6 都要受到一些影响。。。连大佬都用 obfuscator 进行演示，我还是不要头铁了。。。其实，如果这两篇文章的内容都掌握的话，那么你就完全有能力写出还原逻辑了，所以不要失望哦，哈哈。好了，那正式开始介绍。1，一堆 unicode 或 16 进制表示的代码看着头疼，怎么破？对 babel 来说，处理这类混淆很简单，编码混淆常见的有两种：字符串或数字：如下图&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzA0fDkyNTQ2YTZlfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>2.png&lt;/strong> &lt;em>(181.27 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzA0fDkyNTQ2YTZlfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzA1fDkyY2U3OWQyfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>3.png&lt;/strong> &lt;em>(65.42 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzA1fDkyY2U3OWQyfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>可以看到对应的 Ast Node 的 type 为 StringLiteral 或 NumericLiteral，而 value 属性中是真实值，extra 属性中是被混淆后的值，那么我们直接将这两个 type 的 extra 属性删掉，就会显示真实值了，代码如下：&lt;br>
traverse(&lt;strong>ast&lt;/strong>,{&lt;br>
    StringLiteral:delExtra,&lt;br>
    NumericLiteral:delExtra&lt;br>
})&lt;/p>
&lt;p>function delExtra(path) {&lt;br>
    var curNode = path.node;&lt;br>
    delete curNode.extra;&lt;br>
}&lt;br>
效果：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzA2fGM1ZjhmZThhfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>4.png&lt;/strong> &lt;em>(8.08 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzA2fGM1ZjhmZThhfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzA3fDYxOTdlMWRmfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>5.png&lt;/strong> &lt;em>(3.77 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzA3fDYxOTdlMWRmfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>2，上一篇评论中有建议是，像 _0x19882c[&amp;lsquo;removeCookie&amp;rsquo;]&lt;a href="">&amp;rsquo;tostring&amp;rsquo;&lt;/a> 应该转换成 _0x19882c.removeCookie.toString() 这样利于我们调试的格式，怎么处理？对于 Ast 的操作当然要先观察 Ast 的结构喽，我们来看一下结构：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzA4fGE4ZTgyZTlmfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>6.png&lt;/strong> &lt;em>(239.79 KB, 下载次数: 2)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzA4fGE4ZTgyZTlmfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>可以看到 type 为 MemberExpression，唯一的不同之处就是 computed 的值，那就很好办了，我们针对 type 为 MemberExpression 的节点，将其 computed 值改为 false 就好了，代码如下：traverse(ast,{&lt;br>
    MemberExpression:formatMember&lt;br>
})&lt;/p>
&lt;p>//  改变调用方式&lt;br>
function formatMember(path) {&lt;br>
    var curNode = path.node;&lt;br>
    if(!t.isStringLiteral(curNode.property))&lt;br>
        return;&lt;br>
    if(curNode.computed===undefined || !curNode.computed === true)&lt;br>
        return;&lt;br>
    curNode.property = t.identifier(curNode.property.value);&lt;br>
    curNode.computed = false;&lt;br>
}&lt;br>
3，让我们借某 V5 混淆 谈一下控制流平坦化 如何还原先看 控制流平坦化 后的代码是什么样子的：&lt;br>
var _0x289a30 = &amp;ldquo;4|6|2|3|1|5|0&amp;rdquo;.split(&amp;quot;|&amp;quot;),&lt;br>
    _0x2690ba = 0;&lt;br>
while (true) {&lt;br>
    switch (_0x289a30[_0x2690ba++]) {&lt;br>
        case &amp;ldquo;0&amp;rdquo;:&lt;br>
            _0x46e439.console.trace = _0x31f4ee;&lt;br>
            continue;&lt;br>
        case &amp;ldquo;1&amp;rdquo;:&lt;br>
            _0x46e439.console.error = _0x31f4ee;&lt;br>
            continue;&lt;br>
        case &amp;ldquo;2&amp;rdquo;:&lt;br>
            _0x46e439.console.debug = _0x31f4ee;&lt;br>
            continue;&lt;br>
        case &amp;ldquo;3&amp;rdquo;:&lt;br>
            _0x46e439.console.info = _0x31f4ee;&lt;br>
            continue;&lt;br>
        case &amp;ldquo;4&amp;rdquo;:&lt;br>
            _0x46e439.console.log = _0x31f4ee;&lt;br>
            continue;&lt;br>
        case &amp;ldquo;5&amp;rdquo;:&lt;br>
            _0x46e439.console.exception = _0x31f4ee;&lt;br>
            continue;&lt;br>
        case &amp;ldquo;6&amp;rdquo;:&lt;br>
            _0x46e439.console.warn = _0x31f4ee;&lt;br>
            continue;&lt;br>
    }&lt;br>
    break;&lt;br>
}&lt;br>
然后，我们再来分析下 Ast 的结构：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzA5fGRjZTIyYzk3fDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>7.png&lt;/strong> &lt;em>(120.92 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzA5fGRjZTIyYzk3fDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>结构很清晰，那我们想要还原的话，流程就很容易想到了，以本例来说，流程为： 0，我们拦截 type 为 WhileStatement 的 Ast 节点。1，准备一个临时数组。2，获取_0x289a30 数组。3，遍历_0x289a30 数组，依次取出对应的 SwitchCase 节点，将每个 SwitchCase 节点的 ExpressionStatement 添加到临时数组中，4，用临时数组替换掉 SwitchStatement 节点。5，删掉_0x289a30 所在的节点。让我们看一下代码：&lt;br>
traverse(ast, {&lt;br>
    WhileStatement: replaceWhile&lt;br>
})&lt;br>
function(path)&lt;br>
{&lt;br>
    //  判断是否是目标节点&lt;br>
    var node = path.node;&lt;br>
    if (!t.isBooleanLiteral(node.test) || node.test.value != true)&lt;br>
        return; &lt;br>
    if (!t.isBlockStatement(node.body))&lt;br>
        return;&lt;/p>
&lt;p>    var body = node.body.body;&lt;br>
    if (!t.isSwitchStatement(body[0]) || !t.isMemberExpression(body[0].discriminant) || !t.isBreakStatement(body[1]))&lt;br>
        return;&lt;/p>
&lt;p>    var swithStm = body[0];&lt;br>
    var arrName = swithStm.discriminant.object.name;&lt;/p>
&lt;p>    //  找到 path 节点的前一个兄弟节点，即_0x289a30 所在的节点，然后获取_0x289a30 数组&lt;br>
    var prevSiblingPath = path.getPrevSibling();&lt;br>
    var arrNode = prevSiblingPath.node.declarations.filter(declarator =&amp;gt; declarator.id.name == arrName)[0];&lt;br>
    var idxArr = arrNode.init.callee.object.value.split(&amp;rsquo;|&amp;rsquo;);&lt;/p>
&lt;p>    // SwitchCase 节点集合&lt;br>
    var caseList = swithStm.cases;&lt;br>
    var resultBody = [];&lt;/p>
&lt;p>    idxArr.map(targetIdx =&amp;gt; {&lt;br>
    var targetBody = caseList[targetIdx].consequent;&lt;br>
    //  删除 ContinueStatement 块 (continue 语句)&lt;br>
    if (t.isContinueStatement(targetBody[targetBody.length - 1]))&lt;br>
        targetBody.pop();&lt;br>
    resultBody = resultBody.concat(targetBody)&lt;br>
    });&lt;/p>
&lt;p>    //  多个节点替换一个节点的话使用 replaceWithMultiple 方法&lt;br>
    path.replaceWithMultiple(resultBody);&lt;/p>
&lt;p>    //  删除_0x289a30 所在的节点&lt;br>
    prevSiblingPath.remove();&lt;br>
}&lt;br>
还原后效果:&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzEwfDllYzExYzEwfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>8.png&lt;/strong> &lt;em>(25.86 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzEwfDllYzExYzEwfDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>很清晰，good。
4, 第一篇文章中提到了将自执行方法的实参替换到方法体内，但是这样还有一个问题，就是自执行函数变多之后，我们打断点比较麻烦，所以我们应该将实参为空的自执行函数转为顺序语句。下面我们来转换一下：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzExfGQ4YTQ5NzA1fDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>9.png&lt;/strong> &lt;em>(64.49 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzExfGQ4YTQ5NzA1fDE2NDY0MDczMzJ8MjIyMnwxNDk4&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-5-2 18:09 上传&lt;/p>
&lt;p>分析 Ast 结构后，我们可以想到，只需要拦截 type 为 ExpressionStatement 的 node 节点，然后判断条件符合后使用 BlockStatement 替换掉 ExpressionStatement 即可，代码如下:&lt;br>
//  替换空参数的自执行方法为顺序语句&lt;br>
traverse(ast,{&lt;br>
    ExpressionStatement:function (path) {&lt;br>
        let node = path.node;&lt;br>
        //  判断条件是否符合&lt;br>
        if (!t.isCallExpression(node.expression))&lt;br>
            return;&lt;br>
        if (node.expression.arguments !== undefined &amp;amp;&amp;amp; node.expression.arguments.length&amp;gt; 0)&lt;br>
            return;&lt;br>
        if (!t.isFunctionExpression(node.expression.callee))&lt;br>
            return;&lt;br>
        //  替换节点&lt;br>
        path.replaceWith(node.expression.callee.body);&lt;br>
    },&lt;br>
})&lt;br>
后记：&lt;br>
好了，讲解到这里，也算是把使用 Ast 还原 某 V5 的混淆 会使用到的逻辑 说了七七八八了，相信小伙伴们跟着走一遍的话, 完全有能力还原 本文开始时展示的那一长串代码，处理其他平台的混淆也不再是问题，所以暂时关于 Ast 的文章会告一段落。接下来我的重点是研究学习某数的反爬技巧，在这个 人均某数 的年代，我如果再不研究就跟不上潮流喽，如果有进展，在没有法律风险的情况下，我也会都分享出来的。比较可惜的是作用域管理没有实战的机会，但是听说处理某数的混淆会有作用域管理方面的需求，所以如果真的应用上的话，我还是会 借某数平台的逻辑写 Ast 第三部曲的，哈哈哈。
本文使用到的部分代码放到下面了，回复后再领哦，各位拜拜~。
&lt;a href="https://github.com/chencchen/webcrawler/tree/master/%E4%BD%BF%E7%94%A8ast%E5%AF%B9%E6%9F%90v5%E5%8A%A0%E5%AF%86%E8%BF%9B%E8%A1%8C%E8%BF%98%E5%8E%9F2" target="_blank" rel="noopener">https://github.com/chencchen/webcrawler/tree/master/%E4%BD%BF%E7%94%A8ast%E5%AF%B9%E6%9F%90v5%E5%8A%A0%E5%AF%86%E8%BF%9B%E8%A1%8C%E8%BF%98%E5%8E%9F2&lt;/a>&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1680&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>血音乐 大佬
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=106&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure> coder 不是说 sojson 站长会发律师函的吗
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=436&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>小 Gy tql
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=69&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>Jrb tql
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=725&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>Henryhaohao 666
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=698&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>vip tql
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1568&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>daisixuan 冲冲冲
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1311&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>北落师门 保存点赞收藏一波
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=478&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>菜鸡中的最菜 666&lt;/p></description></item><item><title>Js Ast 一部曲：高完整度还原某 V5 的加密</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%B8%80%E9%83%A8%E6%9B%B2%E9%AB%98%E5%AE%8C%E6%95%B4%E5%BA%A6%E8%BF%98%E5%8E%9F%E6%9F%90-v5-%E7%9A%84%E5%8A%A0%E5%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%B8%80%E9%83%A8%E6%9B%B2%E9%AB%98%E5%AE%8C%E6%95%B4%E5%BA%A6%E8%BF%98%E5%8E%9F%E6%9F%90-v5-%E7%9A%84%E5%8A%A0%E5%AF%86/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://bbs.nightteam.cn/forum.php?mod=viewthread&amp;amp;tid=1496&amp;amp;highlight=ast" target="_blank" rel="noopener">bbs.nightteam.cn&lt;/a>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1616&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>Nanda&lt;br>
声明：本文内容仅供学习交流，严禁用于商业用途，请于 24 小时内删除。
今天让我们玩一点有意思的东西，使用 &lt;strong>ast&lt;/strong> 解决某 v5 加密的 js 代码。
作为一个爬虫爱好者，可能你并不会使用 ast 处理混淆文件，但肯定是听过这个名字的，对吧？而且被传的神乎其神，又是编译原理，又是词法语法分析的。但实际上，底层的东西都已经有大佬封装好了，并不需要从头造轮子，而且 ast 对逆向工作中是真的很有效果！所以，最近我也是研究学习了一下，本次我就使用 babel 这一工具，为大家揭开 ast 的神秘面纱。
既然是第一部曲，主要是让大家初步了解 ast，所以我们选择一个常规难度就好了，加密配置如下图：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=Mjk0fDA3YjBlYjVkfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>image.png&lt;/strong> &lt;em>(153.86 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=Mjk0fDA3YjBlYjVkfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-4-30 01:43 上传&lt;/p>
&lt;p>先上前后代码对比吧，还原前：&lt;br>
/*&lt;br>
 *  加密工具已经升级了一个版本，目前为  sojson.v5 ，主要加强了算法，以及防破解【绝对不可逆】配置，耶稣也无法 100% 还原，我说的。;&lt;br>
 *  已经打算把这个工具基础功能一直免费下去。还希望支持我。
 *  另外  sojson.v5  已经强制加入校验，注释可以去掉，但是  sojson.v5  不能去掉（如果你开通了 VIP，可以手动去掉），其他都没有任何绑定。
 *  誓死不会加入任何后门，sojson JS  加密的使命就是为了保护你们的 Javascript 。
 *  警告：如果您恶意去掉  sojson.v5  那么我们将不会保护您的 JavaScript 代码。请遵守规则&lt;br>
 *  新版本: https://www.jsjiami.com/  支持批量加密，支持大文件加密，拥有更多加密。 */&lt;br>
;var encode_version = &amp;lsquo;sojson.v5&amp;rsquo;&lt;br>
  , jrkqk = &amp;rsquo;&amp;rsquo;&lt;br>
  , _0x3318 = [&amp;rsquo;eMO1woTDnRU=&amp;rsquo;, &amp;lsquo;6L6h5pmt5LuD5Lq85Lq857Gi5Ymtwqh55pCG5LyT44OQ&amp;rsquo;, &amp;lsquo;56us6ZaG5o2S6auk57ufDuKDp8KuwqzliYHlrpbig7NT5ZCXwrrigaJPw5bopp3lrb7ig4zCt+++heS/peWMheS+leeYlCB8w7bjga4=&amp;rsquo;, &amp;lsquo;Z3rCqsKQ&amp;rsquo;, &amp;lsquo;wq12EsOow7A=&amp;rsquo;, &amp;lsquo;wq3Di8Kpw63CisKZwr4=&amp;rsquo;, &amp;lsquo;RMOdwpc=&amp;rsquo;, &amp;lsquo;NTREw4FsCMKIQsKB&amp;rsquo;, &amp;lsquo;54qF5p+/5Y6E772jw5LDkeS8meWsjOafneW+uOepq++9pei9v+itk+aXt+aMh+aKgOS7rOealOW3seS8vw==&amp;rsquo;, &amp;lsquo;5Yis6Zia54ms5p225Y6H772nKMO85L2n5a+b5p+W5b2756iM&amp;rsquo;, &amp;lsquo;VMOBwofDtDscbsOBw7k=&amp;rsquo;, &amp;rsquo;eAglw6V9&amp;rsquo;, &amp;lsquo;dFUCw7LCsA==&amp;rsquo;, &amp;lsquo;wqzCij0=&amp;rsquo;, &amp;lsquo;5YuX6Zip54ig5p6p5Y+J772cwqbDpOS+guWvgeadpOW+reermQ==&amp;rsquo;];&lt;br>
(function(_0x1cab0b, _0x9fc93e) {&lt;br>
    var _0x50aee6 = function(_0x5f6b93) {&lt;br>
        while (&amp;ndash;_0x5f6b93) {&lt;br>
            _0x1cab0b&lt;a href="_0x1cab0b[%27shift%27]%28%29">&amp;lsquo;push&amp;rsquo;&lt;/a>;&lt;br>
        }&lt;br>
    };&lt;br>
    _0x50aee6(++_0x9fc93e);&lt;br>
}(_0x3318, 0x12d));&lt;br>
var _0x4d94 = function(_0x387cf0, _0x46d6a3) {&lt;br>
    _0x387cf0 = _0x387cf0 - 0x0;&lt;br>
    var _0x1c7cd3 = _0x3318[_0x387cf0];&lt;br>
    if (_0x4d94[&amp;lsquo;initialized&amp;rsquo;] === undefined) {&lt;br>
        (function() {&lt;br>
            var _0x9672bc = typeof window !== &amp;lsquo;undefined&amp;rsquo; ? window : typeof process === &amp;lsquo;object&amp;rsquo; &amp;amp;&amp;amp; typeof require === &amp;lsquo;function&amp;rsquo; &amp;amp;&amp;amp; typeof global === &amp;lsquo;object&amp;rsquo; ? global : this;&lt;br>
            var _0x47acfd = &amp;lsquo;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&amp;rsquo;;&lt;br>
            _0x9672bc[&amp;lsquo;atob&amp;rsquo;] || (_0x9672bc[&amp;lsquo;atob&amp;rsquo;] = function(_0x4f114b) {&lt;br>
                var _0xda79c1 = String(_0x4f114b)&lt;a href="https://ng-tech.icu/=&amp;#43;$/,">&amp;lsquo;replace&amp;rsquo;&lt;/a>;&lt;br>
                for (var _0x2456af = 0x0, _0xc64c02, _0x5e6923, _0x48f516 = 0x0, _0x448f43 = &amp;lsquo;&amp;rsquo;; _0x5e6923 = _0xda79c1&lt;a href="_0x48f516&amp;#43;&amp;#43;">&amp;lsquo;charAt&amp;rsquo;&lt;/a>; ~_0x5e6923 &amp;amp;&amp;amp; (_0xc64c02 = _0x2456af % 0x4 ? _0xc64c02 * 0x40 + _0x5e6923 : _0x5e6923,&lt;br>
                _0x2456af++ % 0x4) ? _0x448f43 += String&lt;a href="0xff%c2%a0&amp;amp;%c2%a0_0xc64c02%c2%a0%3e%3e%c2%a0%28-0x2%c2%a0*%c2%a0_0x2456af%c2%a0&amp;amp;%c2%a00x6%29">&amp;lsquo;fromCharCode&amp;rsquo;&lt;/a> : 0x0) {&lt;br>
                    _0x5e6923 = _0x47acfd&lt;a href="_0x5e6923">&amp;lsquo;indexOf&amp;rsquo;&lt;/a>;&lt;br>
                }&lt;br>
                return _0x448f43;&lt;br>
            }&lt;br>
            );&lt;br>
        }());&lt;br>
        var _0x15dca8 = function(_0xa971bc, _0x5e580d) {&lt;br>
            var _0x2a7b0e = [], _0x18c27c = 0x0, _0x8cce7, _0x21fe1e = &amp;lsquo;&amp;rsquo;, _0x21ee82 =&amp;rsquo;&amp;rsquo;;&lt;br>
            _0xa971bc = atob(_0xa971bc);&lt;br>
            for (var _0x465e88 = 0x0, _0x1826b5 = _0xa971bc[&amp;rsquo;length&amp;rsquo;]; _0x465e88 &amp;lt; _0x1826b5; _0x465e88++) {&lt;br>
                _0x21ee82 += &amp;lsquo;%&amp;rsquo; + (&amp;lsquo;00&amp;rsquo; + _0xa971bc&lt;a href="_0x465e88">&amp;lsquo;charCodeAt&amp;rsquo;&lt;/a>&lt;a href="0x10">&amp;rsquo;toString&amp;rsquo;&lt;/a>)&lt;a href="-0x2">&amp;lsquo;slice&amp;rsquo;&lt;/a>;&lt;br>
            }&lt;br>
            _0xa971bc = decodeURIComponent(_0x21ee82);&lt;br>
            for (var _0x559b8b = 0x0; _0x559b8b &amp;lt; 0x100; _0x559b8b++) {&lt;br>
                _0x2a7b0e[_0x559b8b] = _0x559b8b;&lt;br>
            }&lt;br>
            for (_0x559b8b = 0x0; _0x559b8b &amp;lt; 0x100; _0x559b8b++) {&lt;br>
                _0x18c27c = (_0x18c27c + _0x2a7b0e[_0x559b8b] + _0x5e580d&lt;a href="%5c_0x559b8b%c2%a0%25%c2%a0_0x5e580d[%27length%27]">&amp;lsquo;charCodeAt&amp;rsquo;&lt;/a>) % 0x100;&lt;br>
                _0x8cce7 = _0x2a7b0e[_0x559b8b];&lt;br>
                _0x2a7b0e[_0x559b8b] = _0x2a7b0e[_0x18c27c];&lt;br>
                _0x2a7b0e[_0x18c27c] = _0x8cce7;&lt;br>
            }&lt;br>
            _0x559b8b = 0x0;&lt;br>
            _0x18c27c = 0x0;&lt;br>
            for (var _0x325076 = 0x0; _0x325076 &amp;lt; _0xa971bc[&amp;rsquo;length&amp;rsquo;]; _0x325076++) {&lt;br>
                _0x559b8b = (_0x559b8b + 0x1) % 0x100;&lt;br>
                _0x18c27c = (_0x18c27c + _0x2a7b0e[_0x559b8b]) % 0x100;&lt;br>
                _0x8cce7 = _0x2a7b0e[_0x559b8b];&lt;br>
                _0x2a7b0e[_0x559b8b] = _0x2a7b0e[_0x18c27c];&lt;br>
                _0x2a7b0e[_0x18c27c] = _0x8cce7;&lt;br>
                _0x21fe1e += String&lt;a href="%5c_0xa971bc[%27charCodeAt%27]%28_0x325076%29%c2%a0%5e%c2%a0_0x2a7b0e[%28%5c_0x2a7b0e[_0x559b8b]%c2%a0&amp;#43;%c2%a0_0x2a7b0e[_0x18c27c]%29%c2%a0%25%c2%a00x100]">&amp;lsquo;fromCharCode&amp;rsquo;&lt;/a>;&lt;br>
            }&lt;br>
            return _0x21fe1e;&lt;br>
        };&lt;br>
        _0x4d94[&amp;lsquo;rc4&amp;rsquo;] = _0x15dca8;&lt;br>
        _0x4d94[&amp;lsquo;data&amp;rsquo;] = {};&lt;br>
        _0x4d94[&amp;lsquo;initialized&amp;rsquo;] = !![];&lt;br>
    }&lt;br>
    var _0x281020 = _0x4d94[&amp;lsquo;data&amp;rsquo;][_0x387cf0];&lt;br>
    if (_0x281020 === undefined) {&lt;br>
        if (_0x4d94[&amp;lsquo;once&amp;rsquo;] === undefined) {&lt;br>
            _0x4d94[&amp;lsquo;once&amp;rsquo;] = !![];&lt;br>
        }&lt;br>
        _0x1c7cd3 = _0x4d94&lt;a href="%5c_0x1c7cd3,%c2%a0_0x46d6a3">&amp;lsquo;rc4&amp;rsquo;&lt;/a>;&lt;br>
        _0x4d94[&amp;lsquo;data&amp;rsquo;][_0x387cf0] = _0x1c7cd3;&lt;br>
    } else {&lt;br>
        _0x1c7cd3 = _0x281020;&lt;br>
    }&lt;br>
    return _0x1c7cd3;&lt;br>
};&lt;br>
var a = {}&lt;br>
  , b = {};&lt;br>
(function(_0x117d09, _0x110647) {&lt;br>
    var _0x4845bf = {&lt;br>
        &amp;lsquo;XhuzS&amp;rsquo;: _0x4d94(&amp;lsquo;0x0&amp;rsquo;, &amp;lsquo;W7bQ&amp;rsquo;),&lt;br>
        &amp;lsquo;iUTPo&amp;rsquo;: _0x4d94(&amp;lsquo;0x1&amp;rsquo;, &amp;lsquo;]2T3&amp;rsquo;)&lt;br>
    };&lt;br>
    _0x117d09[_0x4d94(&amp;lsquo;0x2&amp;rsquo;, &amp;lsquo;WIC5&amp;rsquo;)] = _0x4845bf[&amp;lsquo;XhuzS&amp;rsquo;];&lt;br>
    _0x110647[&amp;lsquo;adinfo&amp;rsquo;] = _0x4845bf[_0x4d94(&amp;lsquo;0x3&amp;rsquo;, &amp;lsquo;Wka7&amp;rsquo;)];&lt;br>
    _0x110647[_0x4d94(&amp;lsquo;0x4&amp;rsquo;, &amp;lsquo;D8d!&amp;rsquo;)] = &amp;lsquo;如果您的 JS 里嵌套了 PHP，JSP 标签，等等其他非 JavaScript 的代码，请提取出来再加密。这个工具不能加密 php、jsp 等模版内容&amp;rsquo;;&lt;br>
}(a, b));&lt;br>
;(function(_0x182aaa, _0x4c3590, _0x55392e) {&lt;br>
    var _0x4b40d0 = {&lt;br>
        &amp;lsquo;gTfic&amp;rsquo;: _0x4d94(&amp;lsquo;0x5&amp;rsquo;, &amp;lsquo;oqkX&amp;rsquo;),&lt;br>
        &amp;lsquo;GXIQH&amp;rsquo;: function _0x38020c(_0x65ebe0, _0x2dc82b) {&lt;br>
            return _0x65ebe0 === _0x2dc82b;&lt;br>
        },&lt;br>
        &amp;lsquo;xyVxG&amp;rsquo;: _0x4d94(&amp;lsquo;0x6&amp;rsquo;, &amp;lsquo;JsgM&amp;rsquo;),&lt;br>
        &amp;lsquo;qeHKL&amp;rsquo;: function _0x3e069c(_0x501f24, _0x41e6d1) {&lt;br>
            return _0x501f24 + _0x41e6d1;&lt;br>
        },&lt;br>
        &amp;lsquo;EkYag&amp;rsquo;: _0x4d94(&amp;lsquo;0x7&amp;rsquo;, &amp;lsquo;^7hL&amp;rsquo;),&lt;br>
        &amp;lsquo;YZgLH&amp;rsquo;: _0x4d94(&amp;lsquo;0x8&amp;rsquo;, &amp;lsquo;g@wB&amp;rsquo;)&lt;br>
    };&lt;br>
    _0x55392e = &amp;lsquo;al&amp;rsquo;;&lt;br>
    try {&lt;br>
        _0x55392e += _0x4b40d0[&amp;lsquo;gTfic&amp;rsquo;];&lt;br>
        _0x4c3590 = encode_version;&lt;br>
        if (!(typeof _0x4c3590 !== _0x4d94(&amp;lsquo;0x9&amp;rsquo;, &amp;lsquo;oqkX&amp;rsquo;) &amp;amp;&amp;amp; _0x4b40d0&lt;a href="%5c_0x4c3590,%c2%a0_0x4b40d0[%27xyVxG%27]">_0x4d94(&amp;lsquo;0xa&amp;rsquo;, &amp;lsquo;M*Wm&amp;rsquo;)&lt;/a>)) {&lt;br>
            _0x182aaa&lt;a href="_0x4b40d0[_0x4d94%28%270xb%27," title="7glO">_0x55392e&lt;/a>](&amp;lsquo;删除&amp;rsquo;, _0x4b40d0[&amp;lsquo;EkYag&amp;rsquo;]));&lt;br>
        }&lt;br>
    } catch (_0x781e53) {&lt;br>
        if (&amp;lsquo;aYN&amp;rsquo; === _0x4d94(&amp;lsquo;0xc&amp;rsquo;, &amp;lsquo;^7hL&amp;rsquo;)) {&lt;br>
            _0x182aaa&lt;a href="_0x4d94%28%270xd%27," title="9z79">_0x55392e&lt;/a>);&lt;br>
        } else {&lt;br>
            _0x182aaa&lt;a href="_0x4b40d0[_0x4d94%28%270xe%27," title="oqkX">_0x55392e&lt;/a>]);&lt;br>
        }&lt;br>
    }&lt;br>
}(window));&lt;br>
;encode_version = &amp;lsquo;sojson.v5&amp;rsquo;;&lt;br>
还原后：&lt;br>
/* *  加密工具已经升级了一个版本，目前为  sojson.v5 ，主要加强了算法，以及防破解【绝对不可逆】配置，耶稣也无法 100% 还原，我说的。; &lt;br>
*  已经打算把这个工具基础功能一直免费下去。还希望支持我。 &lt;br>
*  另外  sojson.v5  已经强制加入校验，注释可以去掉，但是  sojson.v5  不能去掉（如果你开通了 VIP，可以手动去掉），其他都没有任何绑定。 &lt;br>
*  誓死不会加入任何后门，sojson JS  加密的使命就是为了保护你们的 Javascript 。
 *  警告：如果您恶意去掉  sojson.v5  那么我们将不会保护您的 JavaScript 代码。请遵守规则  &lt;br>
 *  新版本: https://www.jsjiami.com/  支持批量加密，支持大文件加密，拥有更多加密。 &lt;br>
 */&lt;/p>
&lt;p>var a = {},&lt;br>
    b = {};&lt;/p>
&lt;p>(function () {&lt;br>
    a[&amp;ldquo;info&amp;rdquo;] = &amp;ldquo;这是一个一系列 js 操作。&amp;rdquo;;&lt;br>
    b[&amp;lsquo;adinfo&amp;rsquo;] = &amp;ldquo;站长接高级  “JS 加密”  和  “JS 解密” ，保卫你的  js。&amp;rdquo;;&lt;br>
    b[&amp;ldquo;warning&amp;rdquo;] = &amp;lsquo;如果您的 JS 里嵌套了 PHP，JSP 标签，等等其他非 JavaScript 的代码，请提取出来再加密。这个工具不能加密 php、jsp 等模版内容&amp;rsquo;;&lt;br>
})();&lt;/p>
&lt;p>;&lt;/p>
&lt;p>(function () {&lt;br>
    _0x55392e = &amp;lsquo;al&amp;rsquo;;&lt;/p>
&lt;p>try {&lt;br>
        _0x55392e += &amp;ldquo;ert&amp;rdquo;;&lt;br>
        _0x4c3590 = encode_version;&lt;/p>
&lt;p>if (!(typeof _0x4c3590 !== &amp;ldquo;undefined&amp;rdquo; &amp;amp;&amp;amp; _0x4c3590 === &amp;ldquo;sojson.v5&amp;rdquo;)) {&lt;br>
            window[_0x55392e](&amp;lsquo;删除&amp;rsquo; + &amp;ldquo;版本号，js 会定期弹窗，还请支持我们的工作&amp;rdquo;);&lt;br>
        }&lt;br>
    } catch (_0x781e53) {&lt;br>
        if (&amp;lsquo;aYN&amp;rsquo; === &amp;ldquo;aYN&amp;rdquo;) {&lt;br>
            window[_0x55392e](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
        } else {&lt;br>
            window[_0x55392e](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
        }&lt;br>
    }&lt;br>
})();&lt;/p>
&lt;p>;&lt;br>
encode_version = &amp;lsquo;sojson.v5&amp;rsquo;;&lt;br>
是不是感觉效果很显著，那就认真看看本文是怎么实现的吧，哈哈。
下面我来介绍下还原流程&lt;br>
0，你肯定是要了解 ast 的概念和 babel 这一工具的具体使用的，我推荐几个链接，多读几遍肯定大有收获：&lt;br>
a&amp;gt;&lt;a href="https://github.com/yacan8/blog/blob/master/posts/JavaScript%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91AST.md" target="_blank" rel="noopener">https://github.com/yacan8/blog/blob/master/posts/JavaScript%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91AST.md&lt;/a>：这是基础，多翻几遍，最好背过，才能更得心应手的使用 babel。
b&amp;gt;&lt;a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/&lt;/a> :  可视化的显示 ast 结构，开发时必不可少。
1，分析结构&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MjkxfDA2MmQyOWVhfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>image.png&lt;/strong> &lt;em>(39.3 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MjkxfDA2MmQyOWVhfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-4-30 01:43 上传&lt;/p>
&lt;p>总体，程序可分为两部分，上面是参数加密及转换的部分，在本例中，以_0x4d94 方法为出口，供下半部分调用，所以我们不用管上面，直接复制到 js 模块里然后导出_0x4d94 方法就好了。如下图所示：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MjkzfGFkOWRlYzU4fDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>image.png&lt;/strong> &lt;em>(32.57 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MjkzfGFkOWRlYzU4fDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-4-30 01:43 上传&lt;/p>
&lt;p>2，结构已经清楚了，那我们就先用_0x4d94 方法把加密替换一下吧。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=Mjk1fDc4NDgzNmEyfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>image.png&lt;/strong> &lt;em>(83.59 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=Mjk1fDc4NDgzNmEyfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-4-30 01:43 上传&lt;/p>
&lt;p>用到的依赖（babel 基础网上很多，我就不讲了哦，直接说代码了。）：&lt;br>
const parser = require(&amp;quot;@babel/parser&amp;quot;);&lt;br>
const template = require(&amp;quot;@babel/template&amp;quot;).default;&lt;br>
const traverse = require(&amp;quot;@babel/traverse&amp;quot;).default;&lt;br>
const t = require(&amp;quot;@babel/types&amp;quot;);&lt;br>
const generator = require(&amp;quot;@babel/generator&amp;quot;).default;&lt;/p>
&lt;p>const path = require(&amp;lsquo;path&amp;rsquo;);&lt;br>
const fs = require(&amp;lsquo;fs&amp;rsquo;)&lt;br>
引入_0x4d94 方法：&lt;br>
const {decryptStr, decryptStrFnName} = require(&amp;rsquo;./module&amp;rsquo;);&lt;br>
读取原始 js 文件 &amp;amp;&amp;amp; 转为 ast 语法树 &amp;amp;&amp;amp; 遍历语法树寻找使用_0x4d94 方法的地方 &amp;amp;&amp;amp; 替换 一气呵成！&lt;br>
//  使用 parse 将 js 转为 ast 语法树&lt;br>
const ast = parser.parse(jsStr);&lt;/p>
&lt;p>//  使用 traverse 遍历语法树，因为方法的调用为 CallExpression 类型，所以我们只对 type 为 CallExpression 的节点进行处理。
//  类型的查看方式看代码后面的图。
traverse(ast,{&lt;br>
    CallExpression:funToStr&lt;br>
})&lt;/p>
&lt;p>function funToStr(path) {&lt;br>
    var curNode = path.node;&lt;/p>
&lt;p>if(curNode.callee.name === decryptStrFnName &amp;amp;&amp;amp; curNode.arguments.length === 2)&lt;br>
    {&lt;br>
        var strC = decryptStr(curNode.arguments[0].value, curNode.arguments[1].value);&lt;/p>
&lt;p>// 将匹配到的位置   的   方法调用   使用 replaceWith 方法   替换为字符串。
        path.replaceWith(t.stringLiteral(strC))&lt;/p>
&lt;p>}&lt;br>
}&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=Mjk3fDRmNGU2NDU5fDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>image.png&lt;/strong> &lt;em>(149.68 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=Mjk3fDRmNGU2NDU5fDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-4-30 01:43 上传&lt;/p>
&lt;p>3, 进行到此，第一部分的代码已经完全无用了，我们把 ast 再转回 js 代码看一下效果:&lt;br>
使用 generator 将 ast 语法树转为 js 代码。
let {code} = generator(ast);&lt;/p>
&lt;p>console.log(code);&lt;br>
转后效果图：&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=Mjk4fGQyNTM2OTgzfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>image.png&lt;/strong> &lt;em>(73.22 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=Mjk4fGQyNTM2OTgzfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-4-30 01:43 上传&lt;/p>
&lt;p>嗯，已经清晰很多了，但是可以看到_0x4845bf 或_0x4b40d0 这种对象里 定义字符串或方法的混淆还需要处理，那就继续吧.&lt;br>
4，观察可见，调用方式如&lt;br>
_0x4b40d0&lt;a href="%27%e5%88%a0%e9%99%a4%27,%c2%a0_0x4b40d0[%27EkYag%27]">&amp;ldquo;qeHKL&amp;rdquo;&lt;/a>&lt;br>
或&lt;br>
_0x4b40d0[&amp;lsquo;gTfic&amp;rsquo;]&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/forum.php?mod=attachment&amp;amp;aid=MzAwfDgxNTRhYzNlfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;noupdate=yes" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>image.png&lt;/strong> &lt;em>(127.45 KB, 下载次数: 0)&lt;/em>&lt;/p>
&lt;p>&lt;a href="forum.php?mod=attachment&amp;amp;aid=MzAwfDgxNTRhYzNlfDE2NDY0MDcyNjh8MjIyMnwxNDk2&amp;amp;nothumb=yes">下载附件&lt;/a>&lt;/p>
&lt;p>2020-4-30 01:43 上传&lt;/p>
&lt;p>可以看到这次是 VariableDeclarator 类型了，所以我们只对 type 为 VariableDeclarator 的节点进行处理，代码如下（有一点复杂，耐心看。。）：&lt;br>
traverse(ast,{&lt;br>
    VariableDeclarator:callToStr&lt;br>
})&lt;/p>
&lt;p>function callToStr(path) {&lt;br>
    var node = path.node;&lt;/p>
&lt;p>//  判断是否符合条件&lt;br>
    if (!t.isObjectExpression(node.init))&lt;br>
        return;&lt;/p>
&lt;p>var objPropertiesList = node.init.properties;&lt;/p>
&lt;p>if (objPropertiesList.length==0)&lt;br>
        return;&lt;/p>
&lt;p>var objName = node.id.name;&lt;/p>
&lt;p>//  对定义的各个   方法   或   字符串   依次在作用域内查找是否有调用&lt;br>
    objPropertiesList.forEach(prop =&amp;gt; {&lt;br>
        var key = prop.key.value;&lt;br>
        if(!t.isStringLiteral(prop.value))&lt;br>
        {&lt;br>
        //  对方法属性的遍历&lt;/p>
&lt;p>var retStmt = prop.value.body.body[0];&lt;/p>
&lt;p>//  该 path 的最近父节点             &lt;br>
            var fnPath = path.getFunctionParent();&lt;br>
            fnPath.traverse({&lt;br>
                CallExpression: function (_path) {&lt;br>
                    if (!t.isMemberExpression(_path.node.callee))&lt;br>
                        return;&lt;/p>
&lt;p>//  判断是否符合条件&lt;br>
                    var _node = _path.node.callee;&lt;br>
                    if (!t.isIdentifier(_node.object) || _node.object.name !== objName)&lt;br>
                        return;&lt;br>
                    if (!t.isStringLiteral(_node.property) || _node.property.value != key)&lt;br>
                        return;&lt;/p>
&lt;p>var args = _path.node.arguments;&lt;/p>
&lt;p>//  二元运算                     &lt;br>
                    if (t.isBinaryExpression(retStmt.argument) &amp;amp;&amp;amp; args.length===2)&lt;br>
                    {&lt;br>
                        _path.replaceWith(t.binaryExpression(retStmt.argument.operator, args[0], args[1]));&lt;br>
                    }&lt;br>
                    //  逻辑运算                     &lt;br>
                    else if(t.isLogicalExpression(retStmt.argument) &amp;amp;&amp;amp; args.length==2)&lt;br>
                    {&lt;br>
                        _path.replaceWith(t.logicalExpression(retStmt.argument.operator, args[0], args[1]));&lt;br>
                    }&lt;br>
                    //  函数调用                     &lt;br>
                    else if(t.isCallExpression(retStmt.argument) &amp;amp;&amp;amp; t.isIdentifier(retStmt.argument.callee))&lt;br>
                    {&lt;br>
                        _path.replaceWith(t.callExpression(args[0], args.slice(1)))&lt;br>
                    }&lt;br>
                }&lt;br>
            })&lt;br>
        }&lt;br>
        else{&lt;br>
        //  对字符串属性的遍历&lt;br>
            var retStmt = prop.value.value;&lt;/p>
&lt;p>//  该 path 的最近父节点             var fnPath = path.getFunctionParent();&lt;br>
            fnPath.traverse({&lt;br>
                MemberExpression:function (_path) {&lt;br>
                    var _node = _path.node;&lt;br>
                    if (!t.isIdentifier(_node.object) || _node.object.name !== objName)&lt;br>
                        return;&lt;br>
                    if (!t.isStringLiteral(_node.property) || _node.property.value != key)&lt;br>
                        return;&lt;/p>
&lt;p>_path.replaceWith(t.stringLiteral(retStmt))&lt;br>
                }&lt;br>
            })&lt;/p>
&lt;p>}&lt;/p>
&lt;p>});&lt;/p>
&lt;p>//  遍历过的对象无用了，直接删除。
    path.remove();&lt;br>
}&lt;br>
ok，经过上面的处理，那些对象也被干掉了，让我们将 ast 语法树转为 js 代码，看一下现在 js 代码的样子&lt;br>
/*&lt;br>
 *  加密工具已经升级了一个版本，目前为  sojson.v5 ，主要加强了算法，以及防破解【绝对不可逆】配置，耶稣也无法 100% 还原，我说的。;&lt;br>
 *  已经打算把这个工具基础功能一直免费下去。还希望支持我。
 *  另外  sojson.v5  已经强制加入校验，注释可以去掉，但是  sojson.v5  不能去掉（如果你开通了 VIP，可以手动去掉），其他都没有任何绑定。
 *  誓死不会加入任何后门，sojson JS  加密的使命就是为了保护你们的 Javascript 。
 *  警告：如果您恶意去掉  sojson.v5  那么我们将不会保护您的 JavaScript 代码。请遵守规则&lt;br>
 *  新版本: https://www.jsjiami.com/  支持批量加密，支持大文件加密，拥有更多加密。 */&lt;/p>
&lt;p>var a = {},&lt;br>
    b = {};&lt;br>
(function (_0x117d09, _0x110647) {&lt;br>
  _0x117d09[&amp;ldquo;info&amp;rdquo;] = &amp;ldquo;这是一个一系列 js 操作。&amp;rdquo;;&lt;br>
  _0x110647[&amp;lsquo;adinfo&amp;rsquo;] = &amp;ldquo;站长接高级  “JS 加密”  和  “JS 解密” ，保卫你的  js。&amp;rdquo;;&lt;br>
  _0x110647[&amp;ldquo;warning&amp;rdquo;] = &amp;lsquo;如果您的 JS 里嵌套了 PHP，JSP 标签，等等其他非 JavaScript 的代码，请提取出来再加密。这个工具不能加密 php、jsp 等模版内容&amp;rsquo;;&lt;br>
})(a, b);&lt;br>
;&lt;br>
(function (_0x182aaa, _0x4c3590, _0x55392e) {&lt;br>
  _0x55392e = &amp;lsquo;al&amp;rsquo;;&lt;br>
  try {&lt;br>
    _0x55392e += &amp;ldquo;ert&amp;rdquo;;&lt;br>
    _0x4c3590 = encode_version;&lt;br>
    if (!(typeof _0x4c3590 !== &amp;ldquo;undefined&amp;rdquo; &amp;amp;&amp;amp; _0x4c3590 === &amp;ldquo;sojson.v5&amp;rdquo;)) {&lt;br>
      _0x182aaa[_0x55392e](&amp;lsquo;删除&amp;rsquo; + &amp;ldquo;版本号，js 会定期弹窗，还请支持我们的工作&amp;rdquo;);&lt;br>
    }&lt;br>
  } catch (_0x781e53) {&lt;br>
    if (&amp;lsquo;aYN&amp;rsquo; === &amp;ldquo;aYN&amp;rdquo;) {&lt;br>
      _0x182aaa[_0x55392e](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
    } else {&lt;br>
      _0x182aaa[_0x55392e](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
    }&lt;br>
  }&lt;br>
})(window);&lt;br>
;&lt;br>
encode_version = &amp;lsquo;sojson.v5&amp;rsquo;;&lt;br>
5, 是不是已经一目了然了？但是还有点小问题，像自执行函数里 a,b 那样的参数是没什么实际意义的，参数多了还影响理解代码逻辑，所以最好直接替换到方法里面去，所以我们继续处理：&lt;br>
自执行函数的 type 是 ExpressionStatement，所以我们针对 ExpressionStatement 节点做处理：&lt;br>
traverse(ast,{&lt;br>
    ExpressionStatement:convParam&lt;br>
})&lt;/p>
&lt;p>function convParam(path) {&lt;br>
    var node = path.node;&lt;/p>
&lt;p>//  判断是否是我们想修改的节点&lt;br>
    if (!t.isCallExpression(node.expression))&lt;br>
        return;&lt;/p>
&lt;p>if (node.expression.arguments == undefined || node.expression.callee.params == undefined || node.expression.arguments.length&amp;gt; node.expression.callee.params.length)&lt;br>
        return;&lt;/p>
&lt;p>//  获取形参和实参&lt;br>
    var argumentList = node.expression.arguments;&lt;br>
    var paramList = node.expression.callee.params;&lt;br>
    //  实参可能会比形参少，所以我们对实参进行遍历，  查看当前作用域内是否有该实参的引用&lt;br>
    for (var i = 0; i&amp;lt;argumentList.length; i++)&lt;br>
    {&lt;br>
        var argumentName = argumentList*.name;&lt;br>
        var paramName = paramList*.name;&lt;/p>
&lt;p>path.traverse({&lt;br>
            MemberExpression:function (_path) {&lt;br>
                var _node = _path.node;&lt;br>
                if (!t.isIdentifier(_node.object) || _node.object.name !== paramName)&lt;br>
                    return;&lt;/p>
&lt;p>//  有对实参的引用则   将形参的名字改为实参的名字&lt;br>
                _node.object.name = argumentName;&lt;br>
            }&lt;br>
        });&lt;br>
    }&lt;br>
    //  删除实参和形参的列表。
    node.expression.arguments = [];&lt;br>
    node.expression.callee.params = [];&lt;br>
}&lt;br>
都搞定了，就是最开始展示的那个结果了。让我们再来看一下：&lt;br>
/* *  加密工具已经升级了一个版本，目前为  sojson.v5 ，主要加强了算法，以及防破解【绝对不可逆】配置，耶稣也无法 100% 还原，我说的。; *  已经打算把这个工具基础功能一直免费下去。还希望支持我。 *  另外  sojson.v5  已经强制加入校验，注释可以去掉，但是  sojson.v5  不能去掉（如果你开通了 VIP，可以手动去掉），其他都没有任何绑定。 *  誓死不会加入任何后门，sojson JS  加密的使命就是为了保护你们的 Javascript 。 *  警告：如果您恶意去掉  sojson.v5  那么我们将不会保护您的 JavaScript 代码。请遵守规则  *  新版本: https://www.jsjiami.com/  支持批量加密，支持大文件加密，拥有更多加密。 */var a = {},&lt;br>
    b = {};&lt;/p>
&lt;p>(function () {&lt;br>
    a[&amp;ldquo;info&amp;rdquo;] = &amp;ldquo;这是一个一系列 js 操作。&amp;rdquo;;&lt;br>
    b[&amp;lsquo;adinfo&amp;rsquo;] = &amp;ldquo;站长接高级  “JS 加密”  和  “JS 解密” ，保卫你的  js。&amp;rdquo;;&lt;br>
    b[&amp;ldquo;warning&amp;rdquo;] = &amp;lsquo;如果您的 JS 里嵌套了 PHP，JSP 标签，等等其他非 JavaScript 的代码，请提取出来再加密。这个工具不能加密 php、jsp 等模版内容&amp;rsquo;;&lt;br>
})();&lt;/p>
&lt;p>;&lt;/p>
&lt;p>(function () {&lt;br>
    _0x55392e = &amp;lsquo;al&amp;rsquo;;&lt;/p>
&lt;p>try {&lt;br>
        _0x55392e += &amp;ldquo;ert&amp;rdquo;;&lt;br>
        _0x4c3590 = encode_version;&lt;/p>
&lt;p>if (!(typeof _0x4c3590 !== &amp;ldquo;undefined&amp;rdquo; &amp;amp;&amp;amp; _0x4c3590 === &amp;ldquo;sojson.v5&amp;rdquo;)) {&lt;br>
            window[_0x55392e](&amp;lsquo;删除&amp;rsquo; + &amp;ldquo;版本号，js 会定期弹窗，还请支持我们的工作&amp;rdquo;);&lt;br>
        }&lt;br>
    } catch (_0x781e53) {&lt;br>
        if (&amp;lsquo;aYN&amp;rsquo; === &amp;ldquo;aYN&amp;rdquo;) {&lt;br>
            window[_0x55392e](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
        } else {&lt;br>
            window[_0x55392e](&amp;ldquo;删除版本号，js 会定期弹窗&amp;rdquo;);&lt;br>
        }&lt;br>
    }&lt;br>
})();&lt;/p>
&lt;p>;&lt;br>
encode_version = &amp;lsquo;sojson.v5&amp;rsquo;;&lt;br>
简单明了，这要是再看不懂就说不过去了吧!&lt;br>
结尾：至此，对该加密的还原就告一段落了，可以看到还原后的代码完全足够让我们愉快的 debug 了。第一部曲就讲这些了, 至于反控制流平坦化、作用域管理等等使用 babel 也可以轻易的解决，二部曲我可能会分享到这些。至于第二部曲是写该加密的 绝对不可逆配置 呢，还是写 jsfuck 的还原呢，我还没想好，各位也可以留言提建议。。没什么意外的话，应该会在 5.1 假期写完分享出来。源码放在下面了，回复后再看哦，省的我感觉像打单机，哈哈。
各位拜拜~&lt;br>
[ttreply]&lt;br>
&lt;a href="https://github.com/chencchen/webcrawler/tree/master/%E4%BD%BF%E7%94%A8ast%E5%AF%B9%E6%9F%90v5%E5%8A%A0%E5%AF%86%E8%BF%9B%E8%A1%8C%E8%BF%98%E5%8E%9F" target="_blank" rel="noopener">https://github.com/chencchen/webcrawler/tree/master/%E4%BD%BF%E7%94%A8ast%E5%AF%B9%E6%9F%90v5%E5%8A%A0%E5%AF%86%E8%BF%9B%E8%A1%8C%E8%BF%98%E5%8E%9F&lt;/a>&lt;br>
[/ttreply]&lt;br>
__
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1842&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>damen nb
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=196&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>yzr nb
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=823&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>fu9852531 厉害
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=191&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>frank mark
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1449&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure> 努努 赞赞赞，楼主写的很详细    你并不是一个人在战斗
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=617&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>franky 优秀，正想入门这一块
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=9&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>花儿谢了 great
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=245&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure> 丶 Fallenoringash 秀啊
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.nightteam.cn/uc_server/avatar.php?uid=1&amp;amp;size=middle" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure> sml2h3 非常值得学习借鉴的案例&lt;/p></description></item><item><title>js 破解之补浏览器环境的两种监控方式</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%A1%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%A1%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzU5ODgyOTUzNw==&amp;amp;mid=2247484039&amp;amp;idx=1&amp;amp;sn=0de1ee2e3d201b4b5e2823c1b7975b5a&amp;amp;chksm=febf7209c9c8fb1fb4f8feedd37e223a35887526548564462bd846cc41b954541fe53ac5e0ed&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0302cSUvBnRqvw2ComEobKZP&amp;amp;sharer_sharetime=1646203623636&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>1，首先要说的肯定是 Proxy 了，介绍就不说了，直接上代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>window = new Proxy(global, {
get: function (target, key, receiver) {
console.log(&amp;#34;window.get&amp;#34;, key, target[key]);
if (key==&amp;#34;location&amp;#34;){
location = new Proxy(target[key], {
get: function (_target, _key, _receiver) {
console.log(&amp;#34;window.get&amp;#34;, key, _key, _target[_key]);
if (_key==&amp;#34;port&amp;#34;){console.log(&amp;#34;关注公众号【妄为写代码】&amp;#34;)}
return _target[_key];
}
})
}
return target[key];
},
set: function (target, key, value, receiver) {
console.log(&amp;#34;window.set&amp;#34;, key, value);
target[key] = value;
}
});
window.a = {};
window.a;
window.location = {a: 2};
window.location.a;
window.b = {a: 2};
window.b.a;
location.port;
console.log(&amp;#34;--------------&amp;#34;);
window.location.port;
&lt;/code>&lt;/pre>&lt;p>node 环境执行结果：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/PicMqQs6T6MNerXH5LUe0WPbwcutymn72M4H3yicw6ibWh4NYhQyOrqScX6zZvMLNBt3P5nSHRQ4gI6hmOtKqqzDQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>重点关注【嵌套 Proxy】和【重复 Proxy】&lt;/p>
&lt;p>2，对象属性的 hook 方式&lt;/p>
&lt;p>在浏览器中执行：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/PicMqQs6T6MNerXH5LUe0WPbwcutymn72NpUd6aVfbRdf5j3icqr0EsEPM49wmyjY77pYNADx5DRlxibqTEvC4HsQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/PicMqQs6T6MNerXH5LUe0WPbwcutymn72C2ydR961aTluSG8ibICClkNiaUJypLI0FHGxJCwtXP5l1XZl6S3hU0cw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>重点关注【未在固定范围的新增属性】和【对比两种方式的 location.port】和【多层属性的获取 window.location.port】&lt;/p>
&lt;p>3，这个监控的作用就不用说了吧，就是大家常说的缺哪补哪需要用到的，现在补环境的场景越来越多了，一些知名 js 反爬产品，就可以用这个思路，环境补的好，可以到处用，还能省好多事，一举多得。&lt;/p>
&lt;p>嗯，我也准备学大家开始【佛系】社群运营了，大家可以扫码进群一起交流技术，nice to meet you.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/PicMqQs6T6MNerXH5LUe0WPbwcutymn72c05JlHHVWUoEQCabAghOvicFz9OsF3lbH8h5uDm0W7ZJYDYiav5CeawQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>mtgsig2.1 版本之 a5 算法分析</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/mtgsig2.1-%E7%89%88%E6%9C%AC%E4%B9%8B-a5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/mtgsig2.1-%E7%89%88%E6%9C%AC%E4%B9%8B-a5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s/bfGvUyIN8aS4Y1KkOWwRpQ" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>新年快乐~&lt;/strong>&lt;/p>
&lt;p>&lt;strong>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxsSicZX0U5A0kYxlgR1aAP24lT9ibv1OyHIkUpcUyDJ1nvaenSUFhnp9g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/strong>&lt;/p>
&lt;p>搞过 mtgsig 的应该都知道，a0 代表算法版本，a1 可以理解为 mt 系每个 app 的标识码，此文章所用 app 和版本是 dp10.52.15&lt;/p>
&lt;p>简单说一下怎么定位 a5 的加密入口以及算法还原&lt;/p>
&lt;p>首先这里用的指令执行模拟框架还是 unidbg&lt;/p>
&lt;p>补环境不再说了，直接放出完整调用代码&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.xxx;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.api.ApplicationInfo;
import com.github.unidbg.linux.android.dvm.array.ArrayObject;
import com.github.unidbg.linux.android.dvm.array.ByteArray;
import com.github.unidbg.linux.android.dvm.wrapper.DvmInteger;
import com.github.unidbg.linux.android.dvm.wrapper.DvmLong;
import com.github.unidbg.linux.file.SimpleFileIO;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
public class Mtgsig extends AbstractJni implements IOResolver {
private final AndroidEmulator emulator;
private final VM vm;
private final Module module;
private static final String APP_PACKAGE_NAME = &amp;#34;com.xxx.v1&amp;#34;;
Mtgsig() {
emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(APP_PACKAGE_NAME).build(); // 创建模拟器实例，要模拟32位或者64位，在这里区分
final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口
memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析
vm = emulator.createDalvikVM(new File(&amp;#34;unidbg-android\\src\\test\\java\\com\\xxx\\xxx\xxx.apk&amp;#34;)); // 创建Android虚拟机
vm.setVerbose(true); // 设置是否打印Jni调用细节
vm.setJni(this);
DalvikModule dm = vm.loadLibrary(new File(&amp;#34;unidbg-android\\src\\test\\java\\com\\xxx\\xxx\\xxx.so&amp;#34;), true);
emulator.getSyscallHandler().addIOResolver(this);
module = dm.getModule();
dm.callJNI_OnLoad(emulator);
}
public static void main(String[] args) {
Mtgsig test = new Mtgsig();
test.HookByConsoleDebugger();
test.hookrc4();
test.hookrc4_key();
test.hookbase64();
test.hookbase64_ret();
test.callInit();
test.callMain();
}
public void callInit(){
List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(10);
list.add(vm.getJNIEnv()); // 第一个参数是env
list.add(0); // 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。
list.add(1);
ArrayObject myobject = new ArrayObject(null);
vm.addLocalObject(myobject);
// 完整的参数2
list.add(vm.addLocalObject(myobject));
module.callFunction(emulator, 0x4305, list.toArray());
};
public void callMain(){
List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(10);
list.add(vm.getJNIEnv()); // 第一个参数是env
list.add(0); // 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0，一般用不到。
list.add(2);
StringObject input2_1 = new StringObject(vm, &amp;#34;4069cb78-e02b-45f6-9f0a-b34ddccf389c&amp;#34;);
String input=&amp;#34;GET /localpush.bin cityid=4&amp;#34;;
ByteArray input2_2 = new ByteArray(vm, input.getBytes(StandardCharsets.UTF_8));
DvmInteger input2_3 = DvmInteger.valueOf(vm, 2);
vm.addLocalObject(input2_1);
vm.addLocalObject(input2_2);
vm.addLocalObject(input2_3);
// 完整的参数2
list.add(vm.addLocalObject(new ArrayObject(input2_1, input2_2, input2_3)));
Number number = module.callFunction(emulator, 0x4305, list.toArray())[0];
StringObject result = (StringObject) ((DvmObject[])((ArrayObject)vm.getObject(number.intValue())).getValue())[0];
System.out.println(result.getValue());
};
public void hookrc4(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x88F80 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
int length = ctx.getIntArg(3);
Pointer out = ctx.getPointerArg(2);
ctx.push(out);
Inspector.inspect(ctx.getPointerArg(1).getByteArray(0, length),&amp;#34;rc4 input&amp;#34;);
};
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer output = ctx.pop();
byte[] outputhex = output.getByteArray(0, 193);
Inspector.inspect(outputhex, &amp;#34;hook rc4 结果&amp;#34;);
}
});
hookZz.disable_arm_arm64_b_branch();
}
public void hookrc4_key(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x88EEA + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
int length = ctx.getIntArg(2);
Pointer arg1 = ctx.getPointerArg(1);
// ctx.push(ctx.getR2Pointer());
Pointer out1 = ctx.getPointerArg(0);
ctx.push(out1);
Inspector.inspect(arg1.getByteArray(0, length),&amp;#34;rc4 key input&amp;#34;);
};
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer output = ctx.pop();
System.out.println(output);
byte[] outputhex = output.getByteArray(0, 256);
Inspector.inspect(outputhex, &amp;#34;hook rc4 key 结果&amp;#34;);
}
});
hookZz.disable_arm_arm64_b_branch();
}
public void hookbase64(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0xB468 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
int length = ctx.getIntArg(2);
Pointer out = ctx.getPointerArg(0);
ctx.push(out);
Inspector.inspect(ctx.getPointerArg(1).getByteArray(0, length),&amp;#34;base64 input&amp;#34;);
};
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
}
});
hookZz.disable_arm_arm64_b_branch();
}
public void hookbase64_ret(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x8C8E0 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
int length = ctx.getIntArg(2);
Pointer out = ctx.getPointerArg(1);
ctx.push(out);
Inspector.inspect(ctx.getPointerArg(1).getByteArray(0, length),&amp;#34;base64 结果&amp;#34;);
};
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
}
});
hookZz.disable_arm_arm64_b_branch();
}
public void HookByConsoleDebugger(){
Debugger debugger = emulator.attach();
debugger.addBreakPoint(module.base+0x88EEA+1);//rc4 key
debugger.addBreakPoint(module.base+0x88F80+1);//rc4
// debugger.addBreakPoint(module.base+0xB468);//base64
//trace a5 baseb4的地址
//emulator.traceWrite(0x40335300L,0x40335300L+0xc0L);
}
@Override
public DvmObject&amp;lt;?&amp;gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) {
switch (signature){
case &amp;#34;com/meituan/android/common/mtguard/NBridge-&amp;gt;getClassLoader()Ljava/lang/ClassLoader;&amp;#34;:{
return vm.resolveClass(&amp;#34;java/lang/ClassLoader&amp;#34;).newObject(signature);
}
case &amp;#34;java/lang/ClassLoader-&amp;gt;main2(I[Ljava/lang/Object;)Ljava/lang/Object;&amp;#34;:{
int num = vaList.getIntArg(0);
System.out.println(&amp;#34;fuck Num:&amp;#34;+num);
switch (num){
case 1:{
return new StringObject(vm, &amp;#34;com.dianping.v1&amp;#34;);
}
case 4:{
return new StringObject(vm, &amp;#34;ms_com.dianping.v1.png&amp;#34;);
}
case 5:{
return new StringObject(vm, &amp;#34;ppd_com.dianping.v1.xbt&amp;#34;);
}
case 2:{
DvmObject&amp;lt;?&amp;gt; context = vm.resolveClass(&amp;#34;android/content/Context&amp;#34;).newObject(null);// context
return context;
}
case 6:{
return new StringObject(vm, &amp;#34;5.4.11&amp;#34;);
}
case 51:{
return new StringObject(vm, &amp;#34;2&amp;#34;);
}
case 3:{
DvmObject&amp;lt;?&amp;gt; context = vm.resolveClass(&amp;#34;android/content/Context&amp;#34;).newObject(null);// context
return context;
}
case 8:{
return new StringObject(vm, &amp;#34;&amp;#34;);
}
case 40:{
return new StringObject(vm, &amp;#34;&amp;#34;);
}
}
break;
}
case &amp;#34;java/lang/ClassLoader-&amp;gt;main1(I[Ljava/lang/Object;)Ljava/lang/Object;&amp;#34;:{
int num = vaList.getIntArg(0);
System.out.println(&amp;#34;fuck Num:&amp;#34;+num);
switch (num){
case 49:{
return new StringObject(vm, &amp;#34;5.1.12&amp;#34;);
}
}
break;
}
case &amp;#34;java/lang/System-&amp;gt;getProperty(Ljava/lang/String;)Ljava/lang/String;&amp;#34;:{
String propertyKey = vm.getObject(vaList.getObjectArg(0).hashCode()).getValue().toString();
System.out.println(propertyKey);
switch (propertyKey){
case &amp;#34;http.proxyHost&amp;#34;:{
return new StringObject(vm, &amp;#34;&amp;#34;);
}
case &amp;#34;https.proxyHost&amp;#34;:{
return new StringObject(vm, &amp;#34;&amp;#34;);
}
}
break;
}
case &amp;#34;android/os/SystemProperties-&amp;gt;get(Ljava/lang/String;)Ljava/lang/String;&amp;#34;:{
String propertyKey = vm.getObject(vaList.getObjectArg(0).hashCode()).getValue().toString();
System.out.println(propertyKey);
switch (propertyKey){
case &amp;#34;ro.build.id&amp;#34;:{
return new StringObject(vm, &amp;#34;OPR6.170623.010&amp;#34;);
}
case &amp;#34;persist.sys.usb.config&amp;#34;:{
return new StringObject(vm, &amp;#34;diag,serial_cdev,rmnet,adb&amp;#34;);
}
case &amp;#34;sys.usb.config&amp;#34;:{
return new StringObject(vm, &amp;#34;ptp,adb&amp;#34;);
}
case &amp;#34;sys.usb.state&amp;#34;:{
return new StringObject(vm, &amp;#34;ptp,adb&amp;#34;);
}
}
break;
}
case &amp;#34;java/util/UUID-&amp;gt;randomUUID()Ljava/util/UUID;&amp;#34;:{
return vm.resolveClass(&amp;#34;java/util/UUID&amp;#34;).newObject(UUID.randomUUID());
}
case &amp;#34;java/lang/Long-&amp;gt;valueOf(J)Ljava/lang/Long;&amp;#34;:{
return DvmLong.valueOf(vm, vaList.getLongArg(0));
}
case &amp;#34;java/lang/String-&amp;gt;format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, String.format(vaList.getObjectArg(0).getValue().toString(), vaList.getIntArg(1)));
}
}
return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);
}
@Override
public DvmObject&amp;lt;?&amp;gt; callObjectMethodV(BaseVM vm, DvmObject&amp;lt;?&amp;gt; dvmObject, String signature, VaList vaList) {
switch (signature){
case &amp;#34;java/lang/ClassLoader-&amp;gt;loadClass(Ljava/lang/String;)Ljava/lang/Class;&amp;#34;:{
return dvmObject.getObjectType();
}
case &amp;#34;android/content/pm/PackageManager-&amp;gt;getApplicationInfo(Ljava/lang/String;I)Landroid/content/pm/ApplicationInfo;&amp;#34;:{
return new ApplicationInfo(vm);
}
case &amp;#34;java/util/UUID-&amp;gt;toString()Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, dvmObject.getValue().toString());
}
}
return super.callObjectMethodV(vm, dvmObject, signature, vaList);
}
@Override
public DvmObject&amp;lt;?&amp;gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) {
switch (signature){
case &amp;#34;java/io/File-&amp;gt;&amp;lt;init&amp;gt;(Ljava/lang/String;)V&amp;#34;:{
return vm.resolveClass(&amp;#34;java/io/File&amp;#34;).newObject(new File(vaList.getObjectArg(0).toString()));
}
case &amp;#34;java/lang/Integer-&amp;gt;&amp;lt;init&amp;gt;(I)V&amp;#34;:
int input = vaList.getIntArg(0);
return DvmInteger.valueOf(vm, input);
}
return super.newObjectV(vm, dvmClass, signature, vaList);
}
@Override
public boolean callBooleanMethodV(BaseVM vm, DvmObject&amp;lt;?&amp;gt; dvmObject, String signature, VaList vaList) {
switch (signature){
case &amp;#34;java/io/File-&amp;gt;canRead()Z&amp;#34;:{
return false;
}
}
return super.callBooleanMethodV(vm, dvmObject, signature, vaList);
}
@Override
public DvmObject&amp;lt;?&amp;gt; getObjectField(BaseVM vm, DvmObject&amp;lt;?&amp;gt; dvmObject, String signature) {
switch (signature){
case &amp;#34;android/content/pm/ApplicationInfo-&amp;gt;sourceDir:Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, &amp;#34;/data/app/com.dianping.v1-BVuX2sFQfuNmRz85qE2NuA==/base.apk&amp;#34;);
}
}
return super.getObjectField(vm, dvmObject, signature);
}
@Override
public int getStaticIntField(BaseVM vm, DvmClass dvmClass, String signature) {
switch (signature){
case &amp;#34;android/content/pm/PackageManager-&amp;gt;GET_SIGNATURES:I&amp;#34;:{
return 64;
}
}
return super.getStaticIntField(vm, dvmClass, signature);
}
@Override
public int getIntField(BaseVM vm, DvmObject&amp;lt;?&amp;gt; dvmObject, String signature) {
switch (signature){
case &amp;#34;android/content/pm/PackageInfo-&amp;gt;versionCode:I&amp;#34;:{
return 1100110203;
}
}
return super.getIntField(vm, dvmObject, signature);
}
@Override
public DvmObject&amp;lt;?&amp;gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) {
switch (signature){
case &amp;#34;android/os/Build-&amp;gt;BRAND:Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, &amp;#34;OPPO&amp;#34;);//品牌
}
case &amp;#34;android/os/Build-&amp;gt;TYPE:Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, &amp;#34;user&amp;#34;);
}
case &amp;#34;android/os/Build-&amp;gt;HARDWARE:Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, &amp;#34;OPM1.171019.011&amp;#34;);//硬件
}
case &amp;#34;android/os/Build-&amp;gt;MODEL:Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, &amp;#34;OPPO R11st&amp;#34;);//型号
}
case &amp;#34;android/os/Build-&amp;gt;TAGS:Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, &amp;#34;release-keys&amp;#34;);
}
case &amp;#34;android/os/Build$VERSION-&amp;gt;RELEASE:Ljava/lang/String;&amp;#34;:{
return new StringObject(vm, &amp;#34;9&amp;#34;);
}
}
return super.getStaticObjectField(vm, dvmClass, signature);
}
@Override
public long callStaticLongMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) {
switch (signature){
case &amp;#34;java/lang/System-&amp;gt;currentTimeMillis()J&amp;#34;:{
return System.currentTimeMillis();
}
}
return super.callStaticLongMethodV(vm, dvmClass, signature, vaList);
}
@Override
public FileResult resolve(Emulator emulator, String pathname, int oflags) {
                           这里成包名
if ((&amp;#34;/data/app/com.xxx.v1-BVuX2sFQfuNmRz85qE2NuA==/base.apk&amp;#34;).equals(pathname)) {
            return FileResult.success(new SimpleFileIO(oflags, new File(&amp;#34;unidbg-android\\src\\test\\java\\com\\xxx\\xxx\\base.apk&amp;#34;), pathname));
}
return null;
}
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>mtgsig = {
&amp;#34;a0&amp;#34;:&amp;#34;2.1&amp;#34;,
&amp;#34;a1&amp;#34;:&amp;#34;4069cb78-e02b-45f6-9f0a-b34ddccf389c&amp;#34;,
&amp;#34;a3&amp;#34;:4,
&amp;#34;a4&amp;#34;:1641007666,
&amp;#34;a5&amp;#34;:&amp;#34;SWeM8hCznbxfdTxJtc0KHSzzKXqYFjfTl0UX+7wJk1DDJpB6VVJk/z/nOY4AgFnNPQA9BrwNNfDMYuaiAtIF65ZTLlIiSrFeSKTl1OZnpXzP1FvxE7IOT8lt9vqAkVjldJteCLcNt0hCVGHgpLtSixrX4nnLBa0xx6VDq8D7l+ZuDj6LwbwhfQrTywSliZrBFMNSw7QCBwufpLeZGln+I4Gg4xO4hB78x2QpnuGoGzCQ59Bvpfsb2DYwraeRb7Il&amp;#34;,
&amp;#34;a6&amp;#34;:0,
&amp;#34;a7&amp;#34;:&amp;#34;5R12uldnp3hSXPr7QbCyuHdMCrky7li1vGm/mSt+YyAm7r5b5MqI/SlCC8BSeXZq7tAbvMxK3aXI7ZxNMosia7BaRbVILxHDVxFHrN2tRTI=&amp;#34;,
&amp;#34;a8&amp;#34;:&amp;#34;DAD724885614A2FEFE4680911D321F89911FC9D29FA7F306DC6AEE1F&amp;#34;,
&amp;#34;a9&amp;#34;:&amp;#34;90aa5e3cGg12eitjwSfAQq77re9bzPGk5gYYnXaseK0nggfQbPVktUMdgequOmVsVNUpcP1b0ceoAHDyorGl5cekKABAErse+EP0QwwIVhofmRHst0S59pj/B5h8htH+zosxunRrK0hNZJmvoh1xRBkKHq6jquk3GIKtPf7RXCXwXxN0yS3qqcdFZO2Wep4V8va5C/TkjB0YC6u4mJz/brXx3F/KYX3Z9PaGtyRGZpaRpgKBLxVUKJWA8dwT9MgNB466bfm3XrFyYnHw0sbrgDFaMM5rile4hvzHef+08TjJ3ycIOJT0kFLZOC4c3QVftWm31epg&amp;#34;,
&amp;#34;a10&amp;#34;:&amp;#34;{}&amp;#34;,
&amp;#34;x0&amp;#34;:1,
&amp;#34;a2&amp;#34;:&amp;#34;52516f82cfdd639bc05dbed46add0c59&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>上面是 undbg 调用出来的 mtgsig，会发现每次调用 a2, a4, a5, a7 都会不一样, 这样很难分析，所以我们第一件事先修改 undbg 中的时间获取函数，让函数返回固定值，看看有什么效果（并不是所有案例都可以）此图放错应修改 gettimeofday，可以在 src/main/java/com/github/unidbg/unix/UnixSyscallHandler.java 中修改&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxLqibsOcFwdbyMfR34SYdH6yWybgDUL311PC0WwzNmEPUbdbJPuCXueQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这样修改后每次调用 a2, a4, a5, a7 都是固定的&lt;/p>
&lt;p>然后我们看 a5 这种密文，一看就是 base64 输出方式，那就 hook 住 base64 的函数验证下&lt;/p>
&lt;p>**怎么找 base64 编码函数？&lt;br>
**&lt;/p>
&lt;p>老方法：ida 打开 shift + f12 搜索 ABCDE&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxju9pN1M2sXKPm1xic5ib2O1AWVibbib4KRgvYp5t0Umib5aicQkdPEP7W6ew/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>双击第一个结果&lt;/p>
&lt;p>快捷键 x 查看交叉引用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxBKBphRTsyyThDGQvmRjXMyfjHkW7P3jrFMC6NgYKIf4xxt94zxOzkQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>双击第一个结果&lt;/p>
&lt;p>f5&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall sub_B468(int a1, int a2, signed int a3)
{
int v3; // r4
int v4; // r0
_BYTE *v5; // r6
int v6; // r5
int v7; // r2
int v8; // r0
int v9; // r4
int v10; // r2
char v11; // r1
int v12; // r1
int v13; // r0
_DWORD *v14; // r0
int v16; // [sp+4h] [bp-24h]
signed int v17; // [sp+8h] [bp-20h]
int v18; // [sp+Ch] [bp-1Ch]
int v19; // [sp+10h] [bp-18h]
char v20; // [sp+14h] [bp-14h]
int v21; // [sp+18h] [bp-10h]
v3 = a1;
if ( !a2 || !a3 )
{
v12 = sub_370C(_stack_chk_guard) + 132;
v13 = v3;
LABEL_13:
sub_8C608(v13, v12);
return _stack_chk_guard - v21;
}
v19 = a2;
v18 = a1;
v17 = a3;
v4 = sub_98230(a3 + 2, 3u);
v5 = malloc((4 * v4 | 1) + 1);
if ( !v5 )
{
v12 = sub_370C(0) + 132;
v13 = v3;
goto LABEL_13;
}
v6 = 0;
sub_2A514();
v7 = v17;
v16 = v5;
v8 = v19;
if ( v17 &amp;gt;= 3 )
{
v6 = 0;
do
{
*v5 = aAbcdefghijklmn[*(v8 + v6) &amp;gt;&amp;gt; 2];
v5[1] = aAbcdefghijklmn[(*(v8 + v6 + 1) &amp;gt;&amp;gt; 4) | 16 * *(v8 + v6) &amp;amp; 0x30];
v5[2] = aAbcdefghijklmn[(*(v8 + v6 + 2) &amp;gt;&amp;gt; 6) | 4 * *(v8 + v6 + 1) &amp;amp; 0x3C];
v5[3] = aAbcdefghijklmn[*(v8 + v6 + 2) &amp;amp; 0x3F];
v8 = v19;
v5 += 4;
v6 += 3;
}
while ( v6 &amp;lt; v17 - 2 );
v7 = v17;
}
if ( v6 &amp;gt;= v7 )
{
v14 = v3;
}
else
{
v9 = v7;
*v5 = aAbcdefghijklmn[*(v8 + v6) &amp;gt;&amp;gt; 2];
v10 = 16 * *(v8 + v6) &amp;amp; 0x30;
if ( v6 == v9 - 1 )
{
v5[1] = aAbcdefghijklmn[v10];
v11 = 61;
}
else
{
v5[1] = aAbcdefghijklmn[(*(v8 + v6 + 1) &amp;gt;&amp;gt; 4) | v10];
v11 = aAbcdefghijklmn[4 * *(v8 + v6 + 1) &amp;amp; 0x3C];
}
v14 = v18;
v5[3] = 61;
v5[2] = v11;
v5 += 4;
}
*v5 = 0;
sub_8C8E0(v14, v16, &amp;amp;v5[~v16 + 1], &amp;amp;v20);
free(v16);
return _stack_chk_guard - v21;
}
&lt;/code>&lt;/pre>&lt;p>这函数里有 base64 编码流程，看上去没魔改，编码的结果是放在 v5，v5=v16,v16 传给 sub_bc8e0, 但还是要验证下 base64 魔改没，a5 走不走这个函数也要验证&lt;/p>
&lt;p>所以 hook 一把梭&lt;/p>
&lt;p>hook sub_B468 和 sub_8C8E0&lt;/p>
&lt;pre tabindex="0">&lt;code> public static void main(String[] args) {
        Mtgsig test = new Mtgsig();
        test.hookbase64();
test.hookbase64_ret();
        test.callInit();      
        test.callMain();
}
&lt;/code>&lt;/pre>&lt;p>结果在运行日志里找到了 a5 的密文&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxBupsHkW6Tuvs9OOAPGiaYGIGib2bAdXrU8lrPvGxU1y6JkrgdMiaPjxAw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到 base64 的入参是乱码，所以肯定是某种算法加密后的字节流，&lt;/p>
&lt;p>把这个入参经过标准 base64 编码之后发现和 unidbg 算出来的结果一致，说明没有魔改&lt;/p>
&lt;p>所以下一步我们要顺藤摸瓜，找到这个某算法&lt;/p>
&lt;p>&lt;strong>定位某算法&lt;/strong>&lt;/p>
&lt;p>方法很多，我用 trace，因为 unidbg 的地址随机化是关闭的，也就是说，你模拟执行一千次，加密结果存放的内存地址是不会变的，所以可以监控某个地址块的读写操作，从而找到操作地址的地方&lt;/p>
&lt;p>console debugger 在 0xB468 处打个断点&lt;/p>
&lt;pre tabindex="0">&lt;code>    public void HookByConsoleDebugger(){
        Debugger debugger = emulator.attach();
        debugger.addBreakPoint(module.base+0xB468);
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxNIH1eSnJXYvDKAgGVeQgicFGXkFZ3lLicTlYk27wibEupyhwgvLQmcLRQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到 r1 寄存器存放的是某算法加密后的字节流，r2 是长度，那么我们 trace 这个地址的写入，看是哪个地址操作了这个地址&lt;/p>
&lt;pre tabindex="0">&lt;code>    public void HookByConsoleDebugger(){
Debugger debugger = emulator.attach();
debugger.addBreakPoint(module.base+0xB468);
//trace a5 baseb4 输入的地址
        emulator.traceWrite(0x40335300L,0x40335300L+0xc0L);
}
&lt;/code>&lt;/pre>&lt;p>注意地址是 long 类型，不加 L 是 trace 不了的&lt;/p>
&lt;p>然后运行&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxRaPCvN4iaCDGKrCdBx4UO4yRfaxmWzCiarffNQeUK7IKfhica7SibWoujQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有结果了，后边的地址就是我们要的东西&lt;/p>
&lt;p>ida g 跳到 0x88fdc&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall sub_88F80(int result, _BYTE *a2, _BYTE *a3, signed int a4)
{
int v4; // r4
int v5; // r5
char v6; // ST0C_1
_BYTE *v7; // [sp+0h] [bp-28h]
_BYTE *v8; // [sp+4h] [bp-24h]
if ( a4 &amp;gt;= 1 )
{
v8 = (result + 257);
v7 = (result + 256);
do
{
LOBYTE(v4) = *v7 + 1;
*v7 = v4;
v4 = v4;
LOBYTE(v5) = *v8 + *(result + v4);
*v8 = v5;
v6 = *(result + v4);
v5 = v5;
*(result + v4) = *(result + v5);
*(result + v5) = v6;
*a3 = *a2 ^ *(result + ((*(result + *v8) + *(result + *v7)) &amp;amp; 0xFF));
--a4;
++a3;
++a2;
}
while ( a4 );
}
return result;
}
&lt;/code>&lt;/pre>&lt;p>特征很明显，有经验的一看就知道是 rc4（boss 直聘那篇也是这个&lt;/p>
&lt;p>hook&lt;/p>
&lt;pre tabindex="0">&lt;code> public static void main(String[] args) {
        Mtgsig test = new Mtgsig();
test.HookByConsoleDebugger();
        test.hookrc4();
test.callInit();
        test.callMain();
}
&lt;/code>&lt;/pre>&lt;p>结果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxKEAYpmibrE4EGZnnEbKyx33BQZbG9LtKGYGEwibzSLLlulicwUIZeibBBQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>入参开头是 789c， 是 zlib 压缩算法特征&lt;/p>
&lt;pre tabindex="0">&lt;code>import zlib
print(zlib.decompress(bytes.fromhex(&amp;#34;789c9591bb0e83300c45ffc5338e72f382f22d594a2b550ca59dba20febd7696ba4895e88038d738768e5869028db45642a5b11257ea2a05c3d1706adc303744e3625a7ac343e3d4f8f4390a6f7a60f72298ae6838d9a66c3ed8d5514f88898ef7dd3f466c94f880121b253ee6c4568a7f5af14e6bdba8a329d0087945f5a229c90fbb3ceeee3a9f97e7bcdcdc0bda94a50cef7270c89a8b66782f4ff0512bbd8c29494a7d2945f2b0cba75d869711d92587b600f88e722b0ab4bd0143e08309&amp;#34;)).decode())
&lt;/code>&lt;/pre>&lt;p>现在明文知道了 还要知道 rc4 的 key，key 一般在另一个函数里，通过 key 生成 S 盒&lt;/p>
&lt;p>sub_88F80 按 x 交叉引用 可以到这里&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSx3ctvACmD9HAo5wXiaT72QFPDbcGZrL8hRAbZLXr45WK7Lr26IsPPmQg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall sub_88EEA(int a1, int key, int key_len, int a4)
{
int ret; // r6
int v5; // r0
int v6; // r5
int v7; // r4
int v8; // r1
int v9; // r0
int v10; // r1
int result; // r0
int v12; // r4
int v13; // r5
int v14; // ST00_4
int v15; // r1
int v16; // r1
int key1; // [sp+8h] [bp-18h]
int v18; // [sp+Ch] [bp-14h]
ret = a1;
v5 = 0;
do
{
*(ret + v5) = v5;
++v5;
}
while ( 256 != v5 );
key1 = key;
*(ret + 257) = 0;
*(ret + 256) = 0;
v18 = key_len;
if ( a4 )
{
v6 = 0;
v7 = 0;
do
{
sub_982CC(v6, key_len);
v9 = *(key1 + v8);
v10 = *(ret + v6);
key_len = v18;
v7 = (v6 + v7 + v10 + v9) &amp;amp; 0xFF;
*(ret + v6) = *(ret + v7);
*(ret + v7) = v10;
++v6;
result = 256;
}
while ( 256 != v6 );
}
else
{
v12 = 0;
LOBYTE(result) = 0;
do
{
v13 = *(ret + v12);
v14 = result + v13;
sub_982CC(v12, key_len);
result = v14 + *(key1 + v15);
v16 = (v14 + *(key1 + v15)) &amp;amp; 0xFF;
*(ret + v12) = *(ret + v16);
key_len = v18;
*(ret + v16) = v13;
++v12;
}
while ( 256 != v12 );
}
return result;
}
&lt;/code>&lt;/pre>&lt;p>hook sub_88EEA&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxUVvDV0MzFzVdn6NibxhX2pwtAkGxgUohbM9PaPgKNcQCGKAM4mTRFmw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>key 是 mtgsig[&amp;lsquo;a1&amp;rsquo;] + mtgsig[&amp;lsquo;a3&amp;rsquo;] + mtgsig[&amp;lsquo;a4&amp;rsquo;]&lt;/p>
&lt;p>打开逆向之友，看看是否魔改了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxibHhibhqzsDjzDsmxtymwGlq1xfOqQe0OeicQgpUF1ySIYgu6Pqc5nebQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>oh shit 标准加密出来结果不对，经过验证，确实是魔改了&lt;/p>
&lt;p>魔改的是密钥生成 S 的部分，huok 这个函数的返回值就是 S 盒，可以发现和标准算法生成的 S 盒不一样&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxKPiaHmO9lwITicsRRAADoKFDZMPx7CnWib919jReibqicvTRicWt68Zl57Aw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>两个分支，因为我之前搞过 1.5 和 2.0 的， 我发现之前版本是只有下面的分支，下面的是标准 rc4 &lt;/p>
&lt;p>现在因为 a4=1 所以走的上面的分支&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxiaCNnibmVtYXnLvgcTEOicIPSnXYoSblWNlianpLiaahnKYks5spIGowE8A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后经过我野兽般的眼神和嗅觉，呵，不就这里多 + 了个变量吗&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxBfow7teWPibGWm5Vp6UJ3h0DoOodca4JEqOlyOuRqJrOzebobiby9OMQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>好了 知道了&lt;/p>
&lt;p>先搞一份 rc4 py 源码，rc4 原理这个作者也讲的很好&lt;/p>
&lt;pre tabindex="0">&lt;code>https://www.biaodianfu.com/rc4.html
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>import base64
import zlib
MOD = 256
def KSA(key):
    key_length = len(key)
S = list(range(MOD))
j=0
    for i in range(MOD):
j = (j + S[i] + key[i % key_length]) % MOD
S[i], S[j] = S[j], S[i]
return S
def PRGA(S):
i = 0
j = 0
while True:
i = (i + 1) % MOD
j = (j + S[i]) % MOD
S[i], S[j] = S[j], S[i] # swap values
K = S[(S[i] + S[j]) % MOD]
yield K
def get_keystream(key):
S = KSA(key)
return PRGA(S)
def encrypt_logic(key, text)-&amp;gt;bytes:
if isinstance(key, bytes):
key = [c for c in key]
else:
key = [ord(c) for c in key]
keystream = get_keystream(key)
res = []
for c in text:
val = c ^ next(keystream)
res.append(val)
return bytes(res)
def encrypt(key, plaintext)-&amp;gt;bytes:
if isinstance(plaintext,bytes):
plaintext = [c for c in plaintext]
else:
plaintext = [ord(c) for c in plaintext]
return encrypt_logic(key, plaintext)
def decrypt(key, ciphertext)-&amp;gt;bytes:
ciphertext = base64.b64decode(ciphertext.encode())
res = encrypt_logic(key, ciphertext)
return res
&lt;/code>&lt;/pre>&lt;p>改秘钥 key 生成 S 盒的部分&lt;/p>
&lt;pre tabindex="0">&lt;code>def KSA(key):
    key_length = len(key)
S = list(range(MOD))
j=0
    for i in range(MOD):
        #多加了个 i 看到没？？？
        j = (i(我是混进来的) + j + S[i] + key[i % key_length]) % MOD
S[i], S[j] = S[j], S[i]
return S
&lt;/code>&lt;/pre>&lt;p>完整 py 代码&lt;/p>
&lt;pre tabindex="0">&lt;code># -*- coding: utf-8 -*-
import base64
import zlib
MOD = 256
def KSA(key):
key_length = len(key)
# create the array &amp;#34;S&amp;#34;
S = list(range(MOD)) # [0,1,2, ... , 255]
j=0
for i in range(MOD):
# print(hex(key[i % key_length]))
j = (i + j + S[i] + key[i % key_length]) % MOD
S[i], S[j] = S[j], S[i] # swap values
return S
def PRGA(S):
i = 0
j = 0
while True:
i = (i + 1) % MOD
j = (j + S[i]) % MOD
S[i], S[j] = S[j], S[i] # swap values
K = S[(S[i] + S[j]) % MOD]
yield K
def get_keystream(key):
S = KSA(key)
return PRGA(S)
def encrypt_logic(key, text)-&amp;gt;bytes:
if isinstance(key, bytes):
key = [c for c in key]
else:
key = [ord(c) for c in key]
keystream = get_keystream(key)
res = []
for c in text:
val = c ^ next(keystream)
res.append(val)
return bytes(res)
def encrypt(key, plaintext)-&amp;gt;bytes:
if isinstance(plaintext,bytes):
plaintext = [c for c in plaintext]
else:
plaintext = [ord(c) for c in plaintext]
return encrypt_logic(key, plaintext)
def decrypt(key, ciphertext)-&amp;gt;bytes:
ciphertext = base64.b64decode(ciphertext.encode())
res = encrypt_logic(key, ciphertext)
return res
def a5_decrypt(mtgsig):
xina5key = f&amp;#34;{mtgsig[&amp;#39;a1&amp;#39;]}{mtgsig[&amp;#39;a3&amp;#39;]}{mtgsig[&amp;#39;a4&amp;#39;]}&amp;#34;
a5_str = decrypt(xina5key, mtgsig[&amp;#39;a5&amp;#39;])
a5_str = zlib.decompress(a5_str).decode()
print(a5_str)
return a5_str
def a5_encrypt(mtgsig):
xina5key = f&amp;#34;{mtgsig[&amp;#39;a1&amp;#39;]}{mtgsig[&amp;#39;a3&amp;#39;]}{mtgsig[&amp;#39;a4&amp;#39;]}&amp;#34;
a5_str =r&amp;#39;{&amp;#34;b1&amp;#34;:&amp;#34;{\&amp;#34;1\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;2\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;3\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;4\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;5\&amp;#34;:\&amp;#34;1\&amp;#34;,\&amp;#34;6\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;7\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;8\&amp;#34;:\&amp;#34;4\&amp;#34;,\&amp;#34;9\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;10\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;11\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;12\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;13\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;14\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;15\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;16\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;33\&amp;#34;:{\&amp;#34;0\&amp;#34;:0,\&amp;#34;1\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;2\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;3\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;4\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;5\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;6\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;7\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;8\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;9\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;10\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;11\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;12\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;13\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;14\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;15\&amp;#34;:\&amp;#34;-\&amp;#34;,\&amp;#34;16\&amp;#34;:\&amp;#34;-\&amp;#34;}}&amp;#34;,&amp;#34;b2&amp;#34;:1,&amp;#34;b3&amp;#34;:0,&amp;#34;b4&amp;#34;:&amp;#34;com.dianping.v1&amp;#34;,&amp;#34;b5&amp;#34;:&amp;#34;10.52.15&amp;#34;,&amp;#34;b6&amp;#34;:&amp;#34;1100110203&amp;#34;,&amp;#34;b7&amp;#34;:1641007666,&amp;#34;b8&amp;#34;:1641007666,&amp;#34;b9&amp;#34;:1641007666,&amp;#34;b10&amp;#34;:&amp;#34;5.4.11&amp;#34;,&amp;#34;b11&amp;#34;:&amp;#34;5.4.11&amp;#34;,&amp;#34;b12&amp;#34;:&amp;#34;2&amp;#34;}&amp;#39;
a5_str = zlib.compress(a5_str.encode())
a5 = encrypt(xina5key,a5_str)
# hexdump(a5)
print(base64.b64encode(a5).decode())
return base64.b64encode(a5).decode()
def main():
a5_decrypt(mtgsig)
a5_encrypt(mtgsig)
if __name__ == &amp;#39;__main__&amp;#39;:
mtgsig = {&amp;#34;a0&amp;#34;:&amp;#34;2.1&amp;#34;,
&amp;#34;a1&amp;#34;:&amp;#34;4069cb78-e02b-45f6-9f0a-b34ddccf389c&amp;#34;,
&amp;#34;a3&amp;#34;:4,
&amp;#34;a4&amp;#34;:1641007666,
&amp;#34;a5&amp;#34;:&amp;#34;SWeM8hCznbxfdTxJtc0KHSzzKXqYFjfTl0UX+7wJk1DDJpB6VVJk/z/nOY4AgFnNPQA9BrwNNfDMYuaiAtIF65ZTLlIiSrFeSKTl1OZnpXzP1FvxE7IOT8lt9vqAkVjldJteCLcNt0hCVGHgpLtSixrX4nnLBa0xx6VDq8D7l+ZuDj6LwbwhfQrTywSliZrBFMNSw7QCBwufpLeZGln+I4Gg4xO4hB78x2QpnuGoGzCQ59Bvpfsb2DYwraeRb7Il&amp;#34;,
&amp;#34;a6&amp;#34;:0,
&amp;#34;a7&amp;#34;:&amp;#34;5R12uldnp3hSXPr7QbCyuHdMCrky7li1vGm/mSt+YyAm7r5b5MqI/SlCC8BSeXZq7tAbvMxK3aXI7ZxNMosia7BaRbVILxHDVxFHrN2tRTI=&amp;#34;,
&amp;#34;a8&amp;#34;:&amp;#34;DAD724885614A2FEFE4680911D321F89911FC9D29FA7F306DC6AEE1F&amp;#34;,
&amp;#34;a9&amp;#34;:&amp;#34;90aa5e3cGg12eitjwSfAQq77re9bzPGk5gYYnXaseK0nggfQbPVktUMdgequOmVsVNUpcP1b0ceoAHDyorGl5cekKABAErse+EP0QwwIVhofmRHst0S59pj/B5h8htH+zosxunRrK0hNZJmvoh1xRBkKHq6jquk3GIKtPf7RXCXwXxN0yS3qqcdFZO2Wep4V8va5C/TkjB0YC6u4mJz/brXx3F/KYX3Z9PaGtyRGZpaRpgKBLxVUKJWA8dwT9MgNB466bfm3XrFyYnHw0sbrgDFaMM5rile4hvzHef+08TjJ3ycIOJT0kFLZOC4c3QVftWm31epg&amp;#34;,
&amp;#34;a10&amp;#34;:&amp;#34;{}&amp;#34;,
&amp;#34;x0&amp;#34;:1,
&amp;#34;a2&amp;#34;:&amp;#34;52516f82cfdd639bc05dbed46add0c59&amp;#34;
}
main()
&lt;/code>&lt;/pre>&lt;p>a5 完结，下篇讲讲 a9  a9 也是魔改了标准算法，应该是 Blowfish 或者 Twofishs 算法，不过因为对这算法不熟悉，愣是不知道魔改了哪里，一气之下 (走投无路
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxqP1jBmibofdMdWea65gblzUwVgYTe3n5jsjC0deJkx0Rl3wbuaHoJmg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>) 撸了一遍汇编，后面有空再研究研究算法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxGMW7icptL9MV5FAC3OXNv8Dxh7x1KLOMuAic6nHtMf9roIWsicWzVLhicg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>不过汇编更 6 了 
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxQt7dBdXRpp0sWpEN0swibBH5jAtbby9gr2Kl4GuXq5OBcTibMpb4w2zA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>翻译到三分之一我就觉得这样好傻逼 一部分简单指令可以自动化转成 py 代码，然后就加快了速度~&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSx3CPIwgPiaI394vE6NPCKrczl2F6Wem2iaLeicFT6wy7tOOSGvVMia2uFGg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>哦还有 a2，a2 还是跟 mtgsig2.0 的一样&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4Bmp6OCwibuCVX7LWFIibicSxXNYrw3ukRg0NDiblf9stuBzvroLUjHrCibAibROWCnGRZQX6ibx4NOvXaQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>Protobuf 协议逆向解析 - APP 爬虫</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/protobuf-%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90-app-%E7%88%AC%E8%99%AB-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/protobuf-%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90-app-%E7%88%AC%E8%99%AB-/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://www.yuanrenxue.com/app-crawl/parse-protobuf.html" target="_blank" rel="noopener">www.yuanrenxue.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在做 APP 抓取时，会发现有的 APP Response 回来的数据有 “加密”。不知道返回的内容是什么。&lt;/p>
&lt;/blockquote>
&lt;p>在做 APP 抓取时，会发现有的 APP Response 回来的数据有 “加密”。不知道返回的内容是什么。&lt;/p>
&lt;p>本文偏长，理论基础偏多。&lt;/p>
&lt;p>如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398723.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress2-1583398724.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如上，内容不是明文的，没办法解析数据。&lt;/p>
&lt;p>APP 常见的对数据加密有三种情况：&lt;/p>
&lt;p>第一种是，用诸如 AES 这类加密算法对数据加密，然后在 APP 里用 key 进行解密，这类的数据解密的难度不是很大，弄清楚是用的什么加密算法就能反解。&lt;/p>
&lt;p>第二种是，用 “私有” 协议把数据序列化，只有了解该协议的细节才有可能把数据反序列化出来。这个的难度较大，没有功底，头发撸白都不一定撸出来。游戏和大厂 APP 盛行搞一个自己的私有协议来交换数据。&lt;/p>
&lt;p>第三种是，用第三方厂商的协议来数据序列化，自己搞不出来私有协议的就选用第三方厂商的。比如用 Google 的 Protobuf ，来做数据序列化，也就是数据 “加密”。&lt;/p>
&lt;p>&lt;strong>今天聊的就是第三种，Protobuf 的数据反解析。&lt;/strong>&lt;/p>
&lt;p>先来看一个 Protobuf ，做数据序列化的直观例子。&lt;/p>
&lt;p>比如一个 APP 的 Response 原先是以 json 格式返回的：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这样很容易被解析，用 Protobuf 把上面数据序列化再传输就变成类似这样：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725-1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这张图片只是样例这样就没法直接解析数据，如果了解 Protobuf 协议的话就能加快反解速度。&lt;/p>
&lt;p>所以还得从头来聊 Protobuf 。&lt;/p>
&lt;h2 id="一什么是-protobuf-">一、什么是 Protobuf ？&lt;/h2>
&lt;p>Protobuf 是 Google 开发的一套数据存储传输协议，跟 xml 和 json 一样的，都是用来储存和传输数据的。 因为 Protobuf 能够把数据压缩得很小，所以传输数据就比 xml 和 json 快几倍，Protobuf 解析数据的速度也比它两快，所以在数据网络传输上，用 Protobuf 而不用 json 就有点受欢迎了。&lt;/p>
&lt;p>不过 Protobuf 储存、压缩、传输效率比 json 好，付出的代价就是用法麻烦，不像 json.loads() json.dumps() 一下就搞定了这么简单。Protobuf 有一套自己的语法。不了解 Protobuf 协议语法和用法的话也无法反解数据。&lt;/p>
&lt;p>&lt;strong>先了解下 Protobuf 序列化和反序列化的整个流程：&lt;/strong>&lt;/p>
&lt;p>&lt;strong>1.1. 先定义一个 Protobuf 语法文件（ .proto 文件）&lt;/strong>&lt;/p>
&lt;p>该语法文件用来说明要传输哪些字段、字段的数据类型、数据间的嵌套关系这些。比如一个 APP 要返回的数据有电话号码，姓名，年龄这三个字段，你就需要把这三个字段定义在 .proto 文件里，并且指明他们的数据类型，比如姓名和电话是字符串， 年龄是整型。&lt;/p>
&lt;p>&lt;strong>1.2. 使用 Protobuf 提供的工具编译该语法文件。&lt;/strong>&lt;/p>
&lt;p>用工具编译 .proto 文件的目的是，把 .proto 文件编译成代码，工具会根据该 .proto 文件自动生产代码。 这个代码就是用来做数据序列化和反序列化的。&lt;/p>
&lt;p>&lt;strong>1.3. 服务端用第 2 步中的代码，把 “明文” 数据序列化，变成 “密文” 后，返回给 APP。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>1.4. APP 客户端用第 2 步中的代码，把 “密文” 数据反序列化，就 “解密” 成明文拉。&lt;/strong>&lt;/p>
&lt;p>理论说多了很迷糊，再整个完整的直观例子：&lt;/p>
&lt;h2 id="二protobuf-正向开发流程">二、Protobuf 正向开发流程&lt;/h2>
&lt;p>2.1. 先配置 Protobuf 环境 &lt;a href="https://github.com/protocolbuffers/protobuf/releases/" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases/&lt;/a>&lt;/p>
&lt;p>在 Google 官方 github 地址下载 Protobuf  。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress8-1583398725.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>下载一个 Protobuf 编译器和一个调用编译器的接口程序，我们这里用 Python 版的。如上图，箭头所示，解压 protoc.win64.zip 里有个 protoc 命令就是编译器。PS：注意要给 protoc 配置上环境变量，不然没法全局调用该命令。&lt;/p>
&lt;p>解压 protobuf-python-3.11.4.zip 这是 Python 模块，cd 到 python 目录里运行 Python setup.py build 和 Python setup.py install 安装 Python 模块。Python 编辑器里运行 import google.protobuf 可以检测是否安装成功。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress4-1583398726.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>example 目录里有官方写好的 Python 示例程序 和 示例 .proto 文件。&lt;/p>
&lt;p>2.2. 写一个 .proto 语法文件语法文件怎么写，要根据具体的传输数据来定制，&lt;/p>
&lt;p>比如按照 example 里的示例，如果要传输的数据是如下格式：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398730.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>那么定义的 .proto 语法文件就如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398731.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这样就定义好了一个 .proto 语法文件，语法文件如何定义要根据传输数据的不同而变。更全的 protobuf 语法 可以看这个，有网友翻译成了中文版的。https://colobu.com/2017/03/16/Protobuf3-language-guide/&lt;/p>
&lt;p>2.3. 使用第一步中下载的 protoc 编译器来编译 .proto 文件&lt;/p>
&lt;p>protoc –python_out=. addressbook.proto&lt;/p>
&lt;p>上述表示把 addressbook.proto 文件编译成 Python 版的。如果文件语法错误，在编译的时候会有提示。编译完后，会多出一个. py 文件&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress1-1583398731.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们就可以调用这个 .py 来序列化上面的数据。2.4. 开始序列化数据&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress5-1583398732.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>print 里输出的就是序列化（“加密”）后的数据。2.5. 对序列化后的数据进行反序列化（“解密”）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398732.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>反序列化就把数据又还原啦。&lt;/p>
&lt;p>上述过程就是一个完整的正向数据 protobuf 序列化过程。我们可以看出来，主要是定义一个 .proto 文件，然后把它编译生成代码。 后面就主要用这个代码来做序列化和反序列化工作。&lt;/p>
&lt;h2 id="三逆向解析-protobuf">三、逆向解析 Protobuf&lt;/h2>
&lt;p>正向过程比较轻松，因为对方即有 .proto 文件，也有序列化代码，也知道要传输的数据样式。但是逆向这个过程，APP 里是没有 .proto 文件的，APP 里是有反序列化的代码，但是看得也头晕。那该怎么办呢？&lt;/p>
&lt;p>借助工具，我们使用上面下载的 protoc 编译工具，这个工具提供反解析参数&lt;/p>
&lt;p>protoc –decode_raw &amp;lt; people.bin&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398732.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如上，使用 –decode_raw 参数就能把序列化后的数据，反序列化（解密）出来。上面只是把数据还原了，那如果我们要完全把 .proto 文件也还原出来该怎么办呢？&lt;/p>
&lt;p>如果 APP 发送 request 的数据要先序列化后再发送给服务端的话，那爬虫要做的事情就不只反序列化，还要能序列化。做序列化是一个正向的过程，按照上面流程，必须先要有 .proto 文件才行。&lt;/p>
&lt;p>所以继续还原 .proto 文件，还原 .proto 是个体力活和细致活。就是参照反解析出来的数据，还原出 .proto 文件。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress9-1583398733.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>上面这张图是关键，看懂了就能还原出来。上图左边是反解析出来的数据，中中间是参照左边写出来的 .proto 文件，右边是人家原本的 .proto 文件。左边和中间图对比可以看出，就是根据左边的字段，挨个把字段重新定义出来就 OK 啦。&lt;/p>
&lt;p>遇到 “{” 就定义一个 message。中间和右边图对比可以看出，变量的名字是无关紧要的，数据类型还原正确就行。变量赋值的那些 1，2，3 是标识号，message 里同一层级的标识号不能重复，一般是按照变量顺序从 1 开始递增。标识号的数字是个关键，数字写错了反解析出来的数据会不对。这样就把 .proto 文件还原出来了，然后按照正向流程又去编译，就可以使用它去序列化（“加密”）和反序列化（“解密”）APP 数据了。&lt;/p>
&lt;p>&lt;strong>APP 逆向抓取相关阅读&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.yuanrenxue.com/app-crawl/app-crawl-1.html" target="_blank" rel="noopener">爬虫之 - 某生鲜 APP 加密参数逆向分析&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.yuanrenxue.com/crawler/frida-call-so-directly.html" target="_blank" rel="noopener">搞定某 APP 的 TCP 抓包，并实现 Hook 抓取&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.yuanrenxue.com/crawler/crawl-app-frida-rpc.html" target="_blank" rel="noopener">不还原 token 算法抓取 APP 最简单的 Hook 方法&lt;/a>&lt;/p>
&lt;p>&lt;strong>PS: 再广而告之一声&lt;/strong>&lt;/p>
&lt;p>我有在系统性的教爬虫技术 APP 逆向抓取技术 JS 高阶逆向技术群控抓取技术&lt;/p>
&lt;p>利用爬虫技术年挣 10 万被动收入的思维和实践方法如果你想爬虫技术进阶，或找一份不错的爬虫工作，我想是能够有帮助的。感兴趣可以加我私人微信，备注：学习。PS，费用不便宜，非诚勿扰。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398733.jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2019/05/yrx_banner_pic.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;em>我的公众号：&lt;strong>猿人学 Python&lt;/strong> 上会分享更多心得体会，敬请关注。&lt;/em>&lt;/p>
&lt;p>&lt;em>*** 版权申明: 若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***&lt;/em>&lt;/p></description></item><item><title>Proxy 代理（二次修改）</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/proxy-%E4%BB%A3%E7%90%86%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/proxy-%E4%BB%A3%E7%90%86%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzIyMjQ3OTE5MA==&amp;amp;mid=2247483738&amp;amp;idx=1&amp;amp;sn=1d53007e7805d88e5841a582718f0e16&amp;amp;chksm=e82d9763df5a1e75e59b27c3b6772b78eeb2b9ccd219df09362b8a4ac7f455766d8e76f6b362&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=030205ef041Dql3QXB3GY2bT&amp;amp;sharer_sharetime=1646203661515&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="proxy二次修改">Proxy（二次修改）&lt;/h3>
&lt;blockquote>
&lt;p>&lt;code>Proxy&lt;/code> 二次封装，js 逆向补环境，修复了昨天的 &lt;strong>bug&lt;/strong>，挺尴尬的&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>(function () {
function set_traverse_object(tarrget, obj, recursion_layers) {
recursion_layers -= 1;
console.log();
for (let prop in obj) {
const value = obj[prop];
const tg_name = `${tarrget}.${prop.toString()}`;
const value_type = get_value_type(value);
if (value &amp;amp;&amp;amp; value_type === &amp;#34;object&amp;#34; &amp;amp;&amp;amp; recursion_layers &amp;gt;= 1) {
set_traverse_object(tg_name, value, recursion_layers);
continue
}
if (value &amp;amp;&amp;amp; value.toString() !== &amp;#39;[object Object]&amp;#39;) {
console.log(`setter hook-&amp;gt;${tg_name}; value-&amp;gt; ${value}; typeof-&amp;gt; ${value_type}`);
continue
}
console.log(`setter hook-&amp;gt;${tg_name}; value-&amp;gt; ${value}; typeof-&amp;gt; ${value_type}\n`)
}
}
function new_handel(target_name, obj, number) {
returnnewProxy(obj, my_handler(target_name, number))
}
function get_value_type(value) {
if (Array.isArray(value)) {
return&amp;#39;Array&amp;#39;
}
returntypeof value;
}
function my_handler(target_name, number) {
return {
set: function (obj, prop, value) {
const value_type = get_value_type(value);
const tg_name = `${target_name}.${prop.toString()}`;
if (value &amp;amp;&amp;amp; value_type === &amp;#34;object&amp;#34;) {
set_traverse_object(tg_name, value, number)
} else {
console.log(`setter hook-&amp;gt;${tg_name}; value-&amp;gt; ${value}; typeof-&amp;gt; ${value_type}`)
}
returnReflect.set(obj, prop, value);
},
get: function (obj, prop) {
const tg_name = `${target_name}.${prop.toString()}`;
const value = Reflect.get(obj, prop);
let value_type = get_value_type(value);
if (value &amp;amp;&amp;amp; value_type === &amp;#39;object&amp;#39;) {
return new_handel(tg_name, value, number)
}
console.log(`getter hook-&amp;gt;${tg_name}; value-&amp;gt; ${value}; typeof-&amp;gt; ${value_type}\n`);
return value
}
}
}
window = newProxy(window, my_handler(Object.keys({window})[0], 30));
}());
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>代理效果如下，深层代理，更直观&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>getter hook-&amp;gt;window.document.cookie; value-&amp;gt; undefined; typeof-&amp;gt; undefined
getter hook-&amp;gt;window.location.href; value-&amp;gt; https://mobile.pinduoduo.com/; typeof-&amp;gt; string
getter hook-&amp;gt;window.location.port; value-&amp;gt; ; typeof-&amp;gt; string
{ addEventListener: [Function: addEventListener] } addEventListener
getter hook-&amp;gt;window.document.addEventListener; value-&amp;gt; function () {
}; typeof-&amp;gt; function
getter hook-&amp;gt;window.document.addEventListener; value-&amp;gt; function () {
}; typeof-&amp;gt; function
getter hook-&amp;gt;window.document.addEventListener; value-&amp;gt; function () {
}; typeof-&amp;gt; function
&lt;/code>&lt;/pre></description></item><item><title>Python 爬虫进阶必备 _ Js 逆向之补环境到底是在补什么？</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/python-%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6%E5%BF%85%E5%A4%87-_-js-%E9%80%86%E5%90%91%E4%B9%8B%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8%E8%A1%A5%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/python-%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6%E5%BF%85%E5%A4%87-_-js-%E9%80%86%E5%90%91%E4%B9%8B%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8%E8%A1%A5%E4%BB%80%E4%B9%88/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651266047&amp;amp;idx=1&amp;amp;sn=932ec5044b283d470b385c9a685dc940&amp;amp;chksm=8d315f90ba46d686a561f7deb39e4b5fa4b871fba992acf60b1db39587411960adf78c1b0d21&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0310h4xceCx0N4owVhhkjB1Z&amp;amp;sharer_sharetime=1646881346407&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Official Account&lt;/p>
&lt;p>点击上方 “咸鱼学 Python”，选择 “加为星标”&lt;/p>
&lt;p>第一时间关注 Python 技术干货！&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGd3RW99kP9ia4yiauaWyNoHLx7XNqa4RIOmicSq7CBD7rg0fdXqwcyzblVA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="序言">序言&lt;/h2>
&lt;p>之前我就发过一篇文章，提了一嘴关于我理解的爬虫的本质&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651261597&amp;amp;idx=1&amp;amp;sn=67d62f684c19f5a5fa3c1fe2ed396f3c&amp;amp;chksm=8d314ef2ba46c7e42d036544b88afeb78dc06b91b11264ebe8aa060b05f5402f230f3159425a&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>面试官问我会不会 APP 抓包, 我..&lt;/strong>&lt;/a>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdkusbkWWqBDRk3hWRJiaeDlsqIbHtjb15uMXJNClib6L0YjsqVPJ8lH2A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>虽然当时的主题写的是 App 爬虫，不过并不妨碍的我们理解爬虫。&lt;/p>
&lt;p>今天写的 Js 逆向之补环境，就可以理解是在 Js 环境下精进我们的 &amp;ldquo;骗术&amp;rdquo;&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;p>大家在看文章之前应该都清楚，Node 环境和浏览器环境是完全不同的，平台有很多的检测点可以发现我们是在浏览器运行 Js 还是在 Node 环境下运行 Js&lt;/p>
&lt;p>补环境做的就是尽可能根据网页上的 Js 完善本地的 Node 环境，让 Js 运行在 Node 中像浏览器一样正常运行，最高境界当然是 Js 拿来套上环境就跑，不过可以说是道阻且长
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdrXV9kU0obXL9xiakXgl28RzVpriajgUPUPz9a2squVnDu0gmiaCHKR3hA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>。&lt;/p>
&lt;h3 id="window">window&lt;/h3>
&lt;p>最基本的补环境是公众号早期的文章，例如下面的几篇文章&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651261622&amp;amp;idx=1&amp;amp;sn=bb1f04ec80c9aeec17ca5b47083b1094&amp;amp;chksm=8d314ed9ba46c7cf36913e31456ad5afcff5b28cc1bdc54e34836a658cb6ac1ccfa88750c856&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>实战案例浅析 JS 加密 - DES 与 Base64&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651261627&amp;amp;idx=1&amp;amp;sn=1f58708b5e2dd7adb5f6f160b842d15e&amp;amp;chksm=8d314ed4ba46c7c255344847f7547f790a5ab8abf487d0810059ef8baa7350d7f9f47469a8ff&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>实战案例浅析 JS 加密 - RSA 与 XXTEA&lt;/strong>&lt;/a>&lt;/p>
&lt;p>这些个文章中大家经常遇到的是&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#39;window&amp;#39; is not defined
&lt;/code>&lt;/pre>&lt;p>那像这样的报错提示应该如何处理？&lt;/p>
&lt;p>Node 环境下一般如下定义&lt;/p>
&lt;pre tabindex="0">&lt;code>window = global;
&lt;/code>&lt;/pre>&lt;p>如果只是单单缺少了&lt;code>window&lt;/code>这一个变量的定义，像上面这样报错自然就消失了。&lt;/p>
&lt;h3 id="document">document&lt;/h3>
&lt;p>除了&lt;code>window&lt;/code>之外，我们经常还遇到类似下面这些文章中的情况&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651261831&amp;amp;idx=1&amp;amp;sn=ac2024651406cac642c606f7336abffc&amp;amp;chksm=8d314fe8ba46c6fe967ac2d320ca9a29df2b43e12707599b7c0196fab255bcfbd265db4aa727&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>JS 逆向 | 助力新手 , 两个 JS 逆向喂饭教程&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651261852&amp;amp;idx=1&amp;amp;sn=addc60b8639d89c0d3aba0077608810a&amp;amp;chksm=8d314ff3ba46c6e5caee83bf5688c75367deb602d826625074c4ad5457942935da036f5f86f8&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>JS 逆向 | 助力新手 , 再来一套喂饭教程！&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651265241&amp;amp;idx=1&amp;amp;sn=10de82ee0ebe9b511b3ac44b39ed4436&amp;amp;chksm=8d315cb6ba46d5a0b86634c371cb4cf00dcb1ccff1e81e658e476d32f332c729164f334c80e9&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>Python 爬虫进阶必备 | 某采购网站 cookie 加密分析（仿加速乐）&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651265644&amp;amp;idx=1&amp;amp;sn=e6d272d5d2d61f0303cb745fc160c825&amp;amp;chksm=8d315e03ba46d715c47bd010324da6cf02537a79f265b7f3253bfb71211bb8997ec736a40637&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>Python 爬虫进阶必备 | 某常见 cookie 加密算法逻辑分析 （加速乐 - jsl）&lt;/strong>&lt;/a>&lt;/p>
&lt;p>这些网站我们一般称之为&lt;code>加速乐&lt;/code>，因为标志性的 cookie 参数是以&lt;code>jsl&lt;/code>开头，而这种类型的加密一般操纵的是&lt;code>document.cookie&lt;/code>这个参数&lt;/p>
&lt;p>那像这样的&lt;code>document&lt;/code>应该怎么补？&lt;/p>
&lt;p>在没有检测只是为了能让 js 运行不报错的情况下，我是这样写的&lt;/p>
&lt;pre tabindex="0">&lt;code>var document = {
    cookie:&amp;#34;xxxxxx&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>或者像下面这样写&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdrKia41KeqX8NHb42dlHaaicVNhdtda9B948NibzXNNbMWSqX0LYKAwdCw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>那么这样写就一定保险吗？&lt;/p>
&lt;p>不一定。开头就已经提及，要根据网页上的 Js 完善本地的 Node 环境，所以只要网页上的 Js 不检测我们这么写也没毛病&lt;/p>
&lt;p>那么检测的 Js 长什么样？&lt;/p>
&lt;h3 id="objectgetownpropertydescriptor">Object.getOwnPropertyDescriptor&lt;/h3>
&lt;p>这里可以参考之前写的关于某乎的分析文章&lt;/p>
&lt;p>&lt;a href="http://mp.weixin.qq.com/s?__biz=MzIwNDI1NjUxMg==&amp;amp;mid=2651265603&amp;amp;idx=1&amp;amp;sn=2ff71d1d4b6c294812b2d6dba93cfc52&amp;amp;chksm=8d315e2cba46d73a32b5cb492d69c4968d7aeb28dbfed75a4e579273bbf1bf0e285a9f9b0499&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">&lt;strong>Python 爬虫进阶必备 | 某著名人均百万问答社区 header 参数加密逻辑分析&lt;/strong>&lt;/a>&lt;/p>
&lt;p>这里&lt;code>Header&lt;/code>中的&lt;code>x-zse-96&lt;/code>的加密逻辑之前看过文章的，通过插桩调试应该可以看到下面这样的代码&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdoSLaMzkDnD7KFicVibGfiadSteDxftRrEvFcViaoAYePC5foJc3FxaSNiaw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个东西是个啥？&lt;/p>
&lt;p>官方定义是这样的&lt;/p>
&lt;blockquote>
&lt;p>“&lt;/p>
&lt;p>&lt;strong>&lt;code>Object.getOwnPropertyDescriptor()&lt;/code>&lt;/strong> 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）&lt;/p>
&lt;/blockquote>
&lt;p>通过描述有点晦涩，你可以这样理解，如果是自己构造的对象，例如&lt;/p>
&lt;pre tabindex="0">&lt;code>var navigator = {
    platform:&amp;#34;win32&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>就没办法通过这样的检测&lt;/p>
&lt;p>这里是检测对象的属性是不是自己赋值给他的&lt;/p>
&lt;p>这里打印下刚刚的例子看看有啥不一样的地方&lt;/p>
&lt;p>先是我们自己写的例子&lt;/p>
&lt;pre tabindex="0">&lt;code>var navigator1 = {
    platform:&amp;#34;win32&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdFDwLB8UC0tde2HRSPfhp1OznHfGlverh8Y1w8zkmHgMC585EljRCww/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>再看看浏览器里面是啥样的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGd2KDltnNwK46RUTXnxbFoCwJ5YrhrWrzic7CXsPwdSibtcepX88OWbaVg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以对于这样的代码检测，我们应该如何构造呢？&lt;/p>
&lt;p>这里站在前人的肩膀上，写一下&lt;/p>
&lt;pre tabindex="0">&lt;code>var Navigator = function() {};
Navigator.prototype = {&amp;#34;platform&amp;#34;: &amp;#34;win32&amp;#34;};
navigator = new Navigator();
# 只针对检测 Navigator 原型链的写法
&lt;/code>&lt;/pre>&lt;p>这样就可以通过上面的原型链检测了&lt;/p>
&lt;p>这里的&lt;code>platform&lt;/code>是&lt;code>Navigator&lt;/code>上的属性，在使用 new 实例化后，navigator.platform 取到的是继承自&lt;code>Navigator&lt;/code>的属性值，而不是直接赋予该对象的属性，所以得到的结果和浏览器是一样的。&lt;/p>
&lt;p>这样看是不是很简单，但是像某乎的校验用到了很多次&lt;code>getOwnPropertyDescriptor&lt;/code>，就需要一个个插桩调试他检测了什么对象的什么属性，相当恶心。&lt;/p>
&lt;p>那么又回到上面的代码，这里用到的&lt;code>prototype&lt;/code>又是个啥？&lt;/p>
&lt;h3 id="prototype-与-_-_-_proto_-_-_">prototype 与 _ _ &lt;em>proto&lt;/em> _ _&lt;/h3>
&lt;p>首先先上一张图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdBj8hzqLkPMic93rDzSFko0dHgeR0gibgX6ibBnJW7WTwgtuk3EaNMlawA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>是不是很懵逼，懵逼就对了，我们是搞爬虫的，知道个大概意思就行了。&lt;/p>
&lt;p>我们需要知道的是 prototype 与 _ _ &lt;em>proto&lt;/em> _ _ 咋对应起来就行了&lt;/p>
&lt;p>按照官方的说法&lt;/p>
&lt;blockquote>
&lt;p>“&lt;/p>
&lt;p>在 JS 里，万物皆对象。方法（Function）是对象，方法的原型 (Function.prototype) 是对象。因此，它们都会具有对象共有的特点。即：对象具有属性_ _ &lt;em>proto&lt;/em> _ _，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>方法（Function）这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做 constructor，这个属性包含了一个指针，指回原构造函数。&lt;/p>
&lt;/blockquote>
&lt;p>理解大概的意思（别被搞晕了）可以得出下面这行代码&lt;/p>
&lt;pre tabindex="0">&lt;code> xxx.__proto__ == yyy.prototype
&lt;/code>&lt;/pre>&lt;p>这里我们需要用到谷歌浏览器验证一下我们的想法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdpZKticgP4DefLeD8YIibIPicaDoYiaZ9t95yylWDkBDq2B8iaoR3JzLrFfA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有一定基础的同学知道，浏览器里 window 是由 Window 实例而来的，那么 Window 是怎么来的？&lt;/p>
&lt;p>我们在浏览器的控制台里看看&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdhROVMLS5nnGpLKFOEtfrhtJ8JYYwmXLGsicS3HwB003ibMYSAtibIqoRQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdib6rB9ElHKBRhk0cSXribdpLibmXI3UMpSu6VY7Igzn22a1ncLy3tgKJg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到原来我们之前以为简简单单就构造出来的 window 和 navigator 这么复杂&lt;/p>
&lt;p>这样一看像我们上面直接使用&lt;code>var&lt;/code>定义的方法去补环境就很容易被识别&lt;/p>
&lt;p>例如&lt;/p>
&lt;pre tabindex="0">&lt;code>var window1 = {
    bbb:&amp;#34;xxxx&amp;#34;
};
# 在浏览器里没法定义 window 这里用 window1 做个样子
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdsIgTVQWzh8YwNnXiajaZuVbAOUDRRvjeoLH0DzDWgGW9mzfKPiblO5EA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里&lt;code>window1&lt;/code>的结果和我们上面浏览器中&lt;code>window&lt;/code>的输出结果大相径庭。&lt;/p>
&lt;p>不仅仅是&lt;code>window&lt;/code>，包括&lt;code>document&lt;/code>以及&lt;code>navigator&lt;/code>等等囊括&lt;code>DOM&lt;/code>、&lt;code>BOM&lt;/code>、&lt;code>worker&lt;/code>、网络请求这些的方方面面都需要我们一个一个分析他的&lt;code>__proto__&lt;/code>以及属性是定义在自己的&lt;code>prototype&lt;/code>上还是继承自上一层。&lt;/p>
&lt;p>这里就又涉及了关于上述各类的继承关系，这里分享我找到的一张&lt;code>DOM&lt;/code>中各类的继承关系图，希望对大家补环境有所帮助&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/jqCHqBaKLl3otEQDnoxAQADQN6DsyiaGdVMg7HOu8oia2AwGHGt8SmiayPmz2SOibxIuoK1eV32ysdhQbcBdOFkt7g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>这篇文章我的定义并不是关于补环境的总纲或者是总述，只能说是掀起了补环境神秘面纱的一角，希望大家多多交流，不断完善自己的环境框架，做到一键通杀~&lt;/p>
&lt;p>还有就是关于文章中如果描述不准确的地方，欢迎在留言区指正，大家共同进步。&lt;/p>
&lt;p>以上就是本次的全部内容了，咱们下次再会~&lt;/p>
&lt;p>&lt;strong>Peace and Love&lt;/strong>&lt;/p></description></item><item><title>unidbg 算法还原术 · 某民宿 app 篇 · 上卷</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8A%E5%8D%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8A%E5%8D%B7/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA5NDE1OQ==&amp;amp;mid=2247484931&amp;amp;idx=1&amp;amp;sn=74582e0037883ae013790dc533abb64a&amp;amp;chksm=9f8bb723a8fc3e3514cd422bf5c47230742e58a223d9cd3b0f97e6470255ed4d4f7315dac2cd&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0302Y5N5n4xB46iTyRX63oRx&amp;amp;sharer_sharetime=1646203557665&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>本来打算一篇写完的，发现太长，加上我拖延症严重，等到写好不知猴年马月，遂拆成 3 篇;&lt;/p>
&lt;p>第一篇模拟执行，第二篇签名加密算法还原，第三篇 body 加密算法还原；&lt;/p>
&lt;p>&lt;strong>以前的我&lt;/strong>：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3xBMR1a091Vb8Zxc7LcpA3Q6GDeLSF6NYbVPaAygKTuwSZh0Dk1IqPw/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>现在的我：&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3wwia1uOgibv9l3txQaMYIUic4HpoefGKIy9d9xpGDgnBDcXmJEONBuNtQ/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>样本：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>aHR0cHM6Ly93d3cud2FuZG91amlhLmNvbS9hcHBzLzEyMzU5NjMvaGlzdG9yeV92MjQy
&lt;/code>&lt;/pre>&lt;p>&lt;strong>抓包信息：&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6rWzGly01TibGEvCI3EPqwl4VeVcCialdU5m6nwonvmdISic0j1uba4o2rG5FKkaSNv2iaQ6D9slsibpQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6rWzGly01TibGEvCI3EPqwlg7h0DMIz64LK2wBCPZmDVdCRtbO6KkuMzWvtibibLBvqicwfdRhPAFgyg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>需要搞定的是签名和 body 加密;&lt;/p>
&lt;p>X-TJH：签名;&lt;/p>
&lt;p>Kf64g3&amp;hellip;&amp;hellip;：请求 body;&lt;/p>
&lt;p>&lt;strong>jadx 定位参数；&lt;/strong>&lt;/p>
&lt;p>具体就不说了，很容易定位到在这里;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6rWzGly01TibGEvCI3EPqwlCTTIK9URlgBkdPZh5xLbSTsqjJdSXFw8atDdrhQ2JiaQKexn8fvNpyQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>签名是 encrypt 函数生成的，body 是 bodyEncrypt 生成的;&lt;/p>
&lt;p>&lt;strong>模拟调用&lt;/strong>&lt;/p>
&lt;p>先用 fida 主动调用一波（参数当然是 hook 这个函数得到的，但是被我截断了，方便后边算法分析）;&lt;/p>
&lt;p>没毛病我们再来用 unidbg；&lt;/p>
&lt;p>&lt;strong>frida-rpc encrypt:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>function call_encrypt(){
    Java.perform(function () {
        var Gundam = Java.use(&amp;#34;com.tujia.gundam.Gundam&amp;#34;);
var StrCls = Java.use(&amp;#39;java.lang.String&amp;#39;);
var arg0_str =&amp;#34;&amp;#34;;
var arg0 = StrCls.$new(arg0_str);
var arg1_str = &amp;#34;Mozilla/5.0 (Linux; Android 8.1.0; OPPO R11st Build/OPM1.171019.011; wv)&amp;#34;
var arg1 = StrCls.$new(arg1_str);
var arg2_str = &amp;#34;LON=null;LAT=null;CID=226809753;LAC=42272;&amp;#34;
var arg2 = StrCls.$new(arg2_str);
var arg3_str = &amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;abTests\&amp;#34;:{\&amp;#34;T_login_831\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;},\&amp;#34;searchhuojia\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;listfilter_227\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;T_renshu_292\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;Tlisttest_45664\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;Tlist_168\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;T_LIST27620\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;}}},\&amp;#34;client\&amp;#34;:{\&amp;#34;abTest\&amp;#34;:{},\&amp;#34;abTests\&amp;#34;:{},\&amp;#34;adTest\&amp;#34;:{\&amp;#34;m1\&amp;#34;:\&amp;#34;Color OS V5.2.1\&amp;#34;,\&amp;#34;m2\&amp;#34;:\&amp;#34;\&amp;#34;}&amp;#34;
var arg3 = StrCls.$new(arg3_str);
        var arg4 = arg3.getBytes().length;
        var arg5 = 1630845461;
var ret = Gundam.encrypt(arg0,arg1,arg2,arg3,arg4,arg5);
        console.log(&amp;#34;#encrypt ret:&amp;#34; + ret);
} );
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>&lt;strong>frida-rpc&lt;/strong> bodyEncrypt:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>function call_bodyEncrypt(){
Java.perform(function () {
var Gundam = Java.use(&amp;#34;com.tujia.gundam.Gundam&amp;#34;);
var StrCls = Java.use(&amp;#39;java.lang.String&amp;#39;);
var arg0 = &amp;#39;1&amp;#39;;
var arg1 = 1630808396;
var arg2_str = &amp;#34;YM0A2TMAIEWA3xMAMM1xTjQEUYGD0wZAYAh32AdgQATDzAZNZA33WAEIZAzzhAMMNAzyTDAkZMzTizYOYN11TTgMRcDThyNMZO44GTIAVQGDi5OONN2wWGMMUVWj1iMNOYxxGmUU&amp;#34;;
var arg2 = StrCls.$new(arg2_str)
var arg3 = arg2.length();
var arg4_str = &amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;activityTask\&amp;#34;:{},\&amp;#34;defa&amp;#34;//&amp;#39;{&amp;#34;code&amp;#34;:null,&amp;#34;parameter&amp;#34;:{&amp;#34;activityTask&amp;#34;:{},&amp;#34;defaultKeyword&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;abTest&amp;#34;:{&amp;#34;AppSearchHouseList&amp;#34;:&amp;#34;B&amp;#34;,&amp;#34;listabtest8&amp;#34;:&amp;#34;B&amp;#34;},&amp;#34;returnNavigations&amp;#34;:true,&amp;#34;returnFilterConditions&amp;#34;:true,&amp;#34;specialKeyType&amp;#34;:0,&amp;#34;returnGeoConditions&amp;#34;:true,&amp;#34;abTests&amp;#34;:{&amp;#34;T_login_831&amp;#34;:{&amp;#34;s&amp;#34;:true,&amp;#34;v&amp;#34;:&amp;#34;A&amp;#34;},&amp;#34;searchhuojiatujia&amp;#34;:{&amp;#34;s&amp;#34;:true,&amp;#34;v&amp;#34;:&amp;#34;D&amp;#34;},&amp;#34;listfilter_227&amp;#34;:{&amp;#34;s&amp;#34;:true,&amp;#34;v&amp;#34;:&amp;#34;D&amp;#34;},&amp;#34;T_renshu_292&amp;#34;:{&amp;#34;s&amp;#34;:true,&amp;#34;v&amp;#34;:&amp;#34;D&amp;#34;},&amp;#34;Tlisttest_45664&amp;#34;:{&amp;#34;s&amp;#34;:true,&amp;#34;v&amp;#34;:&amp;#34;C&amp;#34;},&amp;#34;Tlist_168&amp;#34;:{&amp;#34;s&amp;#34;:true,&amp;#34;v&amp;#34;:&amp;#34;C&amp;#34;},&amp;#34;T_LIST27620&amp;#34;:{&amp;#34;s&amp;#34;:false,&amp;#34;v&amp;#34;:&amp;#34;A&amp;#34;}},&amp;#34;pageSize&amp;#34;:10,&amp;#34;excludeUnitIdSet&amp;#34;:null,&amp;#34;historyConditions&amp;#34;:[],&amp;#34;searchKeyword&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;url&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;isDirectSearch&amp;#34;:false,&amp;#34;sceneCondition&amp;#34;:null,&amp;#34;returnAllConditions&amp;#34;:true,&amp;#34;searchId&amp;#34;:null,&amp;#34;pageIndex&amp;#34;:0,&amp;#34;onlyReturnTotalCount&amp;#34;:false,&amp;#34;conditions&amp;#34;:[{&amp;#34;type&amp;#34;:2,&amp;#34;value&amp;#34;:&amp;#34;2021-09-05&amp;#34;},{&amp;#34;type&amp;#34;:3,&amp;#34;value&amp;#34;:&amp;#34;2021-09-06&amp;#34;},{&amp;#34;label&amp;#34;:&amp;#34;广州&amp;#34;,&amp;#34;type&amp;#34;:1,&amp;#34;value&amp;#34;:&amp;#34;45&amp;#34;}]},&amp;#34;client&amp;#34;:{&amp;#34;abTest&amp;#34;:{},&amp;#34;abTests&amp;#34;:{},&amp;#34;adTest&amp;#34;:{&amp;#34;m1&amp;#34;:&amp;#34;Color OS V5.2.1&amp;#34;,&amp;#34;m2&amp;#34;:&amp;#34;ade40419318f085ff21b4776f2eef21f&amp;#34;,&amp;#34;m3&amp;#34;:&amp;#34;armeabi-v7a&amp;#34;,&amp;#34;m4&amp;#34;:&amp;#34;armeabi&amp;#34;,&amp;#34;m5&amp;#34;:&amp;#34;100&amp;#34;,&amp;#34;m6&amp;#34;:&amp;#34;2&amp;#34;,&amp;#34;m7&amp;#34;:&amp;#34;2&amp;#34;},&amp;#34;api_level&amp;#34;:260,&amp;#34;appFP&amp;#34;:&amp;#34;qA/Ch2zqjORBz90YV34sUZpcFXFV6vzhmAISdTjYAFeqMBTtMUukzQFXqkDokr+sMau0bWClwjtk36nbrVBWVtKF9gYuplycneojVw1pIsBYHtUa5n0jFF50c6v1MBvzWJZFk/SirrTIzpJd4mMJ/J4F23BfgLbda7zzJhI8bpXMmglTI9M0hz5X3MMi5uS+/dt6ErjrDv44vY4Y8/1r5dahiujqI90q8/BWuNDxVqp2vGN5XILei7rc/JicoO6S+upWlrY/oAqkMhdmAbh1Anzjd/AZ7Q4HQubQJhsQNSL/T86A6uW0oC+mJHwOLnP8HKN0q2Fu3rTcKZ+Prbs/dcBHaWJi1C1tHZFza2O+1gUQTgvg+Kq57BvE6IjEhveT&amp;#34;,&amp;#34;appId&amp;#34;:&amp;#34;com.tujia.hotel&amp;#34;,&amp;#34;appVersion&amp;#34;:&amp;#34;260_260&amp;#34;,&amp;#34;appVersionUpdate&amp;#34;:&amp;#34;rtag-20210803-183436-zhengyuan&amp;#34;,&amp;#34;batteryStatus&amp;#34;:&amp;#34;full&amp;#34;,&amp;#34;buildTag&amp;#34;:&amp;#34;rtag-20210803-183436-zhengyuan&amp;#34;,&amp;#34;buildVersion&amp;#34;:&amp;#34;8.38.0&amp;#34;,&amp;#34;ccid&amp;#34;:&amp;#34;51742042410923060391&amp;#34;,&amp;#34;channelCode&amp;#34;:&amp;#34;qq&amp;#34;,&amp;#34;crnVersion&amp;#34;:&amp;#34;254&amp;#34;,&amp;#34;devModel&amp;#34;:&amp;#34;OPPO R11st&amp;#34;,&amp;#34;devToken&amp;#34;:&amp;#34;18071adc03d2b69cdfa&amp;#34;,&amp;#34;devType&amp;#34;:2,&amp;#34;dtt&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;electricity&amp;#34;:&amp;#34;100&amp;#34;,&amp;#34;flutterPkgId&amp;#34;:&amp;#34;277&amp;#34;,&amp;#34;gps&amp;#34;:null,&amp;#34;kaTest&amp;#34;:{&amp;#34;k1&amp;#34;:&amp;#34;2_1_2&amp;#34;,&amp;#34;k2&amp;#34;:&amp;#34;sdm660&amp;#34;,&amp;#34;k3&amp;#34;:&amp;#34;ubuntu-16&amp;#34;,&amp;#34;k4&amp;#34;:&amp;#34;R11st_11_A.43_200402&amp;#34;,&amp;#34;k5&amp;#34;:&amp;#34;OPPO/R11st/R11s:8.1.0/OPM1.171019.011/1577198226:user/release-keys&amp;#34;,&amp;#34;k6&amp;#34;:&amp;#34;R11st&amp;#34;,&amp;#34;k7&amp;#34;:&amp;#34;OPM1.171019.011&amp;#34;},&amp;#34;latitude&amp;#34;:&amp;#34;23.105868&amp;#34;,&amp;#34;locale&amp;#34;:&amp;#34;zh-CN&amp;#34;,&amp;#34;longitude&amp;#34;:&amp;#34;113.470269&amp;#34;,&amp;#34;networkType&amp;#34;:&amp;#34;1&amp;#34;,&amp;#34;osVersion&amp;#34;:&amp;#34;8.1.0&amp;#34;,&amp;#34;platform&amp;#34;:&amp;#34;1&amp;#34;,&amp;#34;salt&amp;#34;:&amp;#34;YM0A2TMAIEWA3xMAMM1xTjQEUYGD0wZAYAh32AdgQATDzAZNZA33WAEIZAzzhAMMNAzyTDAkZMzTizYOYN11TTgMRcDThyNMZO44GTIAVQGDi5OONN2wWGMMUVWj1iMNOYxxGmUU&amp;#34;,&amp;#34;screenInfo&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;sessionId&amp;#34;:&amp;#34;a3e57f1c-03a8-3bc4-8709-fb36e7698ae4_1630806934108&amp;#34;,&amp;#34;tId&amp;#34;:&amp;#34;21090509553913313246&amp;#34;,&amp;#34;tbTest&amp;#34;:{&amp;#34;j1&amp;#34;:&amp;#34;11d890e2&amp;#34;,&amp;#34;j2&amp;#34;:&amp;#34;R11s&amp;#34;,&amp;#34;j3&amp;#34;:&amp;#34;OPPO R11st&amp;#34;,&amp;#34;j4&amp;#34;:&amp;#34;OPPO&amp;#34;,&amp;#34;j5&amp;#34;:&amp;#34;OPPO&amp;#34;,&amp;#34;j6&amp;#34;:&amp;#34;unknown&amp;#34;,&amp;#34;j7&amp;#34;:&amp;#34;qcom&amp;#34;,&amp;#34;j8&amp;#34;:&amp;#34;2.1.0 (ART)&amp;#34;},&amp;#34;traceid&amp;#34;:&amp;#34;1630808396402_1630808396176_1630807074415&amp;#34;,&amp;#34;uID&amp;#34;:&amp;#34;a3e57f1c-03a8-3bc4-8709-fb36e7698ae4&amp;#34;,&amp;#34;version&amp;#34;:&amp;#34;260&amp;#34;,&amp;#34;wifi&amp;#34;:null,&amp;#34;wifimac&amp;#34;:&amp;#34;i5ZQ9aI14FDr9VMJ/ECIg7KAOE+Xev1/CrFoa53WLbE=&amp;#34;},&amp;#34;psid&amp;#34;:&amp;#34;d5a4fc67-5e67-47af-81e2-bac409860287&amp;#34;,&amp;#34;type&amp;#34;:null,&amp;#34;user&amp;#34;:null,&amp;#34;usid&amp;#34;:null}&amp;#39;
var arg4 = StrCls.$new(arg4_str)
var arg5 =arg4.getBytes().length;
var myRc = Gundam.bodyEncrypt(arg0,arg1,arg2,arg3,arg4,arg5);
        console.log(&amp;#34;#bodyEncrypt ret:&amp;#34; + ret);
} );
}
&lt;/code>&lt;/pre>&lt;p>发现和 hook 的结果一致，那就来用 unidbg 模拟执行；&lt;/p>
&lt;p>&lt;strong>unidbg&lt;/strong> &lt;strong>encrypt:&lt;/strong>&lt;/p>
&lt;p>unidbg 补环境简单说一下（想要补的又快又好，还是得看龙哥得 csdn 和星球
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopscqPSEb8nUyhupqiagFTbwe1Rvzialiagk8fVXbjcYgtmbLfMVtHsicIJyg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopscqPSEb8nUyhupqiagFTbwe1Rvzialiagk8fVXbjcYgtmbLfMVtHsicIJyg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>）;&lt;/p>
&lt;pre tabindex="0">&lt;code>csdn:https://blog.csdn.net/qq_38851536
星球：https://t.zsxq.com/2F2J6au
&lt;/code>&lt;/pre>&lt;p>首先先运行 JNI_OnLoad （如下代码第 40 行）&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.test;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.array.ByteArray;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.MemoryBlock;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import java.io.File;
import java.io.FileNotFoundException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
public class Test extends AbstractJni {
private final AndroidEmulator emulator;
private final VM vm;
private final Module module;
private static final String APP_PACKAGE_NAME = &amp;#34;com.xxx.hotel&amp;#34;;
Test() {
emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(APP_PACKAGE_NAME).build();
final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口
            memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析
            vm = emulator.createDalvikVM(new File(&amp;#34;xxx.apk&amp;#34;)); // 创建Android虚拟机 报错用绝对路径
vm.setVerbose(true); // 设置是否打印Jni调用细节
            vm.setJni(this);
            DalvikModule dm = vm.loadLibrary(new File(&amp;#34;unidbg-android\\src\\test\\java\\com\\tujia\\libxxx_encrypt.so&amp;#34;), true);//报错用绝对路径
            module = dm.getModule();
            dm.callJNI_OnLoad(emulator);
        }
public static void main(String[] args) throws FileNotFoundException {
        Test test = new Test();
}
}
&lt;/code>&lt;/pre>&lt;p>运行发现报错;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsObF0ZmKXxYsjPEKesqVYrMezBCibib4J0zx6vbZDBGemZnhUcFGEQe3w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为啥呢，因为 unidbg 没有实现这个类，我们得喂给它;&lt;/p>
&lt;p>补充的代码逻辑可以写到 AbstractJni.java 类 367 行那里;&lt;/p>
&lt;p>（截图别骂了后面有完整代码）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopskAlH4tNbxhyROdU8IhFzwlYiajIv7Ugf1p3iatQAlalfO0CJEG8MyEmQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也可以在我们的 Test 类中补，因为 Test 类继承了 AbstractJNI（上面的 26 行）;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsov3w9z5QgkYFnYjdUD4zqYCedJLyYBooiaxyFxowwQjPDYDO2AYgXPA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里为了方便演示，我都补到 Test 类中;&lt;/p>
&lt;p>补完一个就运行一次，看报错来补;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsibx8QUBY3oEAN8E6FVbeV7sK2v28NhBOJYAB1xXlE91VDh03RHysYUQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEops1GglC8XFgLEniaGy7hH4Dn9ZkYSzNmwbgHob8k8P7IFguEL4Im2Tplw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsb3KBr5Zv5hPl5rANLusg81usNDlsCkMsHbywm297MKsUicpjQs7uyaQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsu0oJeDtaicYv5Q00MSFUKRON9LUHPXV0TKqEFHdrRBqbgOxGnyAiaJXA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsGH5KILefJa6VibVjoicKQy28C59pHEQswYdzTpLCdscib3do5W9zGqxCw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsSrns70YcaL7mNAECWGvOibr4ly12m6IX1YkwHdiaFc4Qibg0eUvklQWrg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsUAHbSLbYWo4GaurdPEf16LjXHKSsgdVoTdib3FI69V2PBZabsPTicIMg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopscq5Yr2CO7hAgHicXLNmLS79pnZpcYyf19boUlz40ccJb1iccB6lZrJbA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>补完这个 JNI_OnLoad 就能运行成功了;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsZlCEhfwiaUht2XW98lQSfTWGnKxSmqzFMdt6CPXyMibqeeVTBNtG7SDw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看日志都知道它是在做签名校验咯；&lt;/p>
&lt;p>最后附上 JNI_OnLoad 能成功运行的完整代码；&lt;/p>
&lt;p>（友情提示：标红的类 ALT + 回车可以快速导入（不会有人不知道吧
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopscqPSEb8nUyhupqiagFTbwe1Rvzialiagk8fVXbjcYgtmbLfMVtHsicIJyg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>））；&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tujia;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.array.ByteArray;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.MemoryBlock;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import java.io.File;
import java.io.FileNotFoundException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
public class Test extends AbstractJni {
private final AndroidEmulator emulator;
private final VM vm;
private final Module module;
private static final String APP_PACKAGE_NAME = &amp;#34;com.tujia.hotel&amp;#34;;
Test() {
emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(APP_PACKAGE_NAME).build();
final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口
memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析
vm = emulator.createDalvikVM(new File(&amp;#34;tujia.apk&amp;#34;)); // 创建Android虚拟机
vm.setVerbose(true); // 设置是否打印Jni调用细节
vm.setJni(this);
            DalvikModule dm = vm.loadLibrary(new File(&amp;#34;unidbg-master\\unidbg-android\\src\\test\\java\\com\\tujia\\libtujia_encrypt.so&amp;#34;), true);
            module = dm.getModule();
dm.callJNI_OnLoad(emulator);
}
@Override
public DvmObject&amp;lt;?&amp;gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) {
switch (signature) {
case &amp;#34;com/tujia/hotel/TuJiaApplication-&amp;gt;getInstance()Lcom/tujia/hotel/TuJiaApplication;&amp;#34;: {
return vm.resolveClass(&amp;#34;com/tujia/hotel/TuJiaApplication&amp;#34;).newObject(signature);
}
case &amp;#34;java/security/MessageDigest-&amp;gt;getInstance(Ljava/lang/String;)Ljava/security/MessageDigest;&amp;#34;:{
StringObject type = varArg.getObjectArg(0);
System.out.println(type);
String name = &amp;#34;&amp;#34;;
if (&amp;#34;\&amp;#34;SHA1\&amp;#34;&amp;#34;.equals(type.toString())) {
name = &amp;#34;SHA1&amp;#34;;
} else {
name = type.toString();
System.out.println(&amp;#34;else name: &amp;#34; + name);
}
try {
return vm.resolveClass(&amp;#34;java/security/MessageDigest&amp;#34;).newObject(MessageDigest.getInstance(name));
} catch (NoSuchAlgorithmException e) {
e.printStackTrace();
}
}
}
return super.callStaticObjectMethod(vm, dvmClass, signature, varArg);
}
public DvmObject&amp;lt;?&amp;gt; callObjectMethod(BaseVM vm, DvmObject&amp;lt;?&amp;gt; dvmObject, String signature, VarArg varArg) {
switch (signature){
case &amp;#34;com/tujia/hotel/TuJiaApplication-&amp;gt;getPackageName()Ljava/lang/String;&amp;#34;:{
return new StringObject(vm,&amp;#34;com.tujia.hotel&amp;#34;);
}
case &amp;#34;com/tujia/hotel/TuJiaApplication-&amp;gt;getPackageManager()Landroid/content/pm/PackageManager;&amp;#34;:{
return vm.resolveClass(&amp;#34;android/content/pm/PackageManager&amp;#34;).newObject(signature);
}
case &amp;#34;java/security/MessageDigest-&amp;gt;digest([B)[B&amp;#34;:{
MessageDigest messageDigest = (MessageDigest) dvmObject.getValue();
byte[] input = (byte[]) varArg.getObjectArg(0).getValue();
byte[] result = messageDigest.digest(input);
return new ByteArray(vm,result);
}
}
return super.callObjectMethod(vm, dvmObject, signature, varArg);
}
public static void main(String[] args) throws FileNotFoundException {
        Test test = new Test();
}
}
&lt;/code>&lt;/pre>&lt;p>然后我们来主动调用 encrypt 函数；&lt;/p>
&lt;p>之前呢，我都是这样调用的：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void call_encrypt() {
DvmClass Native=vm.resolveClass(&amp;#34;com/tujia/gundam/Gundam&amp;#34;);
String methodSign = &amp;#34;encrypt(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IJ)Ljava/lang/String;&amp;#34;;
Object arg0 = vm.addLocalObject(new StringObject(vm, &amp;#34;&amp;#34;));
String arg1_str = &amp;#34;Mozilla/5.0 (Linux; Android 8.1.0; OPPO R11st Build/OPM1.171019.011; wv)&amp;#34;;
Object arg1 = vm.addLocalObject(new StringObject(vm, arg1_str));
String arg2_str = &amp;#34;LON=null;LAT=null;CID=226809753;LAC=42272;&amp;#34;;
Object arg2 = vm.addLocalObject(new StringObject(vm, arg2_str));
String arg3_str =&amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;abTests\&amp;#34;:{\&amp;#34;T_login_831\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;},\&amp;#34;searchhuojia\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;listfilter_227\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;T_renshu_292\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;Tlisttest_45664\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;Tlist_168\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;T_LIST27620\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;}}},\&amp;#34;client\&amp;#34;:{\&amp;#34;abTest\&amp;#34;:{},\&amp;#34;abTests\&amp;#34;:{},\&amp;#34;adTest\&amp;#34;:{\&amp;#34;m1\&amp;#34;:\&amp;#34;Color OS V5.2.1\&amp;#34;,\&amp;#34;m2\&amp;#34;:\&amp;#34;\&amp;#34;}&amp;#34;;
Object arg3 = vm.addLocalObject(new StringObject(vm, arg3_str));
int arg4 = arg3_str.getBytes(StandardCharsets.UTF_8).length;
long arg5 = 1630845461L;
Object ret = Native.callStaticJniMethodObject(emulator, methodSign, arg0,arg1,arg2,arg3,arg4,arg5);
System.out.println(&amp;#34;call_encrypt ret:&amp;#34;+((DvmObject) ret).getValue());
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>String methodSign = &amp;#34;encrypt(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IJ)Ljava/lang/String;&amp;#34;;
&lt;/code>&lt;/pre>&lt;p>这个是 smali 的写法 (先用 apktool 反编译 apk, 然后在 smail 文件夹里根据类名找）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEopsCPlTGY8JQq4ibicasewhGxERtact0gOSkADYtTUx35McLOJC4oKZ8zDg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>现在呢，在龙哥的熏陶下，都是这样调用;&lt;/p>
&lt;pre tabindex="0">&lt;code>public void call_encrypt() {
        List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
DvmClass Native=vm.resolveClass(&amp;#34;com/tujia/gundam/Gundam&amp;#34;);
DvmObject&amp;lt;?&amp;gt; jclass =Native.newObject(null);
Object arg0 = vm.addLocalObject(new StringObject(vm, &amp;#34;&amp;#34;));
String arg1_str = &amp;#34;Mozilla/5.0 (Linux; Android 8.1.0; OPPO R11st Build/OPM1.171019.011; wv)&amp;#34;;
Object arg1 = vm.addLocalObject(new StringObject(vm, arg1_str));
String arg2_str = &amp;#34;LON=null;LAT=null;CID=226809753;LAC=42272;&amp;#34;;
Object arg2 = vm.addLocalObject(new StringObject(vm, arg2_str));
String arg3_str =&amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;abTests\&amp;#34;:{\&amp;#34;T_login_831\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;},\&amp;#34;searchhuojia\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;listfilter_227\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;T_renshu_292\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;Tlisttest_45664\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;Tlist_168\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;T_LIST27620\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;}}},\&amp;#34;client\&amp;#34;:{\&amp;#34;abTest\&amp;#34;:{},\&amp;#34;abTests\&amp;#34;:{},\&amp;#34;adTest\&amp;#34;:{\&amp;#34;m1\&amp;#34;:\&amp;#34;Color OS V5.2.1\&amp;#34;,\&amp;#34;m2\&amp;#34;:\&amp;#34;\&amp;#34;}&amp;#34;;
Object arg3 = vm.addLocalObject(new StringObject(vm, arg3_str));
int arg4 = arg3_str.getBytes(StandardCharsets.UTF_8).length;
long arg5 = 1630845461L;
        list.add(vm.getJNIEnv()); //第一个参数都是JNIEnv
list.add(vm.addLocalObject(jclass));//第一个参数都是jclass
list.add(arg0);
list.add(arg1);
list.add(arg2);
list.add(arg3);
list.add(arg4);
        list.add(arg5);
Number number = module.callFunction(emulator, 0x36a9, list.toArray())[0];
String result = vm.getObject(number.intValue()).getValue().toString();
        System.out.println(&amp;#34;result: &amp;#34; + result);
}
&lt;/code>&lt;/pre>&lt;p>22 行 0x36a9 是啥？&lt;/p>
&lt;p>是 encrypt 函数的在 so 文件中的偏移地址;&lt;/p>
&lt;p>哪里得到的？&lt;/p>
&lt;p>上面成功运行完 JNI_OnLoad，会显示动态注册的函数地址;&lt;/p>
&lt;pre tabindex="0">&lt;code>RegisterNative(com/tujia/gundam/Gundam, encrypt(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IJ)Ljava/lang/String;, RX@0x400036a9[libtujia_encrypt.so]0x36a9)
RegisterNative(com/tujia/gundam/Gundam, bodyEncrypt(Ljava/lang/String;JLjava/lang/String;ILjava/lang/String;I)Ljava/lang/String;, RX@0x4000380d[libtujia_encrypt.so]0x380d)
&lt;/code>&lt;/pre>&lt;p>两种方法，结果都是一样的；任君选择；&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH51SmQ6OU118e9dtylhEops4ib0G7Epctgav9meAWKSPdJxjD2J4zFanKeOsP8JicNF7pN0bmNPa6FA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>ps：如果还有人用的是老版本的 unidbg（比如在写这篇以前的我）;&lt;/p>
&lt;p>结果可能是下图的结果，应该是老版本第 6 个参数长整型参数有 bug，导致第六个参数是 0;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5kiaGuPzfFvDLZIutvMYQc9ctWl52uicvKCkxPQUS4Zd6HGRYzjymHzibB6DwrMSDqnMXHQqpVSFuwg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>解决办法：拥抱新版本
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5kiaGuPzfFvDLZIutvMYQc9goCicsYe6pF1dibKwVNzsU7Ud5OiaSeymDk4jI9To4Nw4r7HUN7AbFDnQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>;&lt;/p>
&lt;pre tabindex="0">&lt;code>https://github.com/zhkl0228/unidbg
&lt;/code>&lt;/pre>&lt;p>bodyEncrypt 同理不再细说;&lt;/p>
&lt;p>&lt;strong>完整代码:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.tujia;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.array.ByteArray;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.MemoryBlock;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import java.io.File;
import java.io.FileNotFoundException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
public class Test extends AbstractJni {
private final AndroidEmulator emulator;
private final VM vm;
private final Module module;
private static final String APP_PACKAGE_NAME = &amp;#34;com.tujia.hotel&amp;#34;;
Test() {
emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(APP_PACKAGE_NAME).build();
final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口
memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析
vm = emulator.createDalvikVM(new File(&amp;#34;D:\\qxp\\Frida_hook\\Encrypt\\tujia.apk&amp;#34;)); // 创建Android虚拟机
vm.setVerbose(true); // 设置是否打印Jni调用细节
vm.setJni(this);
DalvikModule dm = vm.loadLibrary(new File(&amp;#34;D:\\qxp\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\tujia\\libtujia_encrypt.so&amp;#34;), true);
module = dm.getModule();
Debugger debugger = emulator.attach();
// debugger.addBreakPoint(module.base + 0x415C );
dm.callJNI_OnLoad(emulator);
}
@Override
public DvmObject&amp;lt;?&amp;gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) {
switch (signature) {
case &amp;#34;com/tujia/hotel/TuJiaApplication-&amp;gt;getInstance()Lcom/tujia/hotel/TuJiaApplication;&amp;#34;: {
return vm.resolveClass(&amp;#34;com/tujia/hotel/TuJiaApplication&amp;#34;).newObject(signature);
}
case &amp;#34;java/security/MessageDigest-&amp;gt;getInstance(Ljava/lang/String;)Ljava/security/MessageDigest;&amp;#34;:{
StringObject type = varArg.getObjectArg(0);
System.out.println(type);
String name = &amp;#34;&amp;#34;;
if (&amp;#34;\&amp;#34;SHA1\&amp;#34;&amp;#34;.equals(type.toString())) {
name = &amp;#34;SHA1&amp;#34;;
} else {
name = type.toString();
System.out.println(&amp;#34;else name: &amp;#34; + name);
}
try {
return vm.resolveClass(&amp;#34;java/security/MessageDigest&amp;#34;).newObject(MessageDigest.getInstance(name));
} catch (NoSuchAlgorithmException e) {
e.printStackTrace();
}
}
}
return super.callStaticObjectMethod(vm, dvmClass, signature, varArg);
}
public DvmObject&amp;lt;?&amp;gt; callObjectMethod(BaseVM vm, DvmObject&amp;lt;?&amp;gt; dvmObject, String signature, VarArg varArg) {
switch (signature){
case &amp;#34;com/tujia/hotel/TuJiaApplication-&amp;gt;getPackageName()Ljava/lang/String;&amp;#34;:{
return new StringObject(vm,&amp;#34;com.tujia.hotel&amp;#34;);
}
case &amp;#34;com/tujia/hotel/TuJiaApplication-&amp;gt;getPackageManager()Landroid/content/pm/PackageManager;&amp;#34;:{
return vm.resolveClass(&amp;#34;android/content/pm/PackageManager&amp;#34;).newObject(signature);
}
case &amp;#34;java/security/MessageDigest-&amp;gt;digest([B)[B&amp;#34;:{
MessageDigest messageDigest = (MessageDigest) dvmObject.getValue();
byte[] input = (byte[]) varArg.getObjectArg(0).getValue();
byte[] result = messageDigest.digest(input);
return new ByteArray(vm,result);
}
}
return super.callObjectMethod(vm, dvmObject, signature, varArg);
}
public void call_encrypt() {
List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
DvmClass Native=vm.resolveClass(&amp;#34;com/tujia/gundam/Gundam&amp;#34;);
DvmObject&amp;lt;?&amp;gt; jclass =Native.newObject(null);
Object arg0 = vm.addLocalObject(new StringObject(vm, &amp;#34;&amp;#34;));
String arg1_str = &amp;#34;Mozilla/5.0 (Linux; Android 8.1.0; OPPO R11st Build/OPM1.171019.011; wv)&amp;#34;;
Object arg1 = vm.addLocalObject(new StringObject(vm, arg1_str));
String arg2_str = &amp;#34;LON=null;LAT=null;CID=226809753;LAC=42272;&amp;#34;;
Object arg2 = vm.addLocalObject(new StringObject(vm, arg2_str));
String arg3_str =&amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;abTests\&amp;#34;:{\&amp;#34;T_login_831\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;},\&amp;#34;searchhuojia\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;listfilter_227\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;T_renshu_292\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;Tlisttest_45664\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;Tlist_168\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;T_LIST27620\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;}}},\&amp;#34;client\&amp;#34;:{\&amp;#34;abTest\&amp;#34;:{},\&amp;#34;abTests\&amp;#34;:{},\&amp;#34;adTest\&amp;#34;:{\&amp;#34;m1\&amp;#34;:\&amp;#34;Color OS V5.2.1\&amp;#34;,\&amp;#34;m2\&amp;#34;:\&amp;#34;\&amp;#34;}&amp;#34;;
Object arg3 = vm.addLocalObject(new StringObject(vm, arg3_str));
int arg4 = arg3_str.getBytes(StandardCharsets.UTF_8).length;
long arg5 = 1630845461L;
list.add(vm.getJNIEnv());
list.add(vm.addLocalObject(jclass));
list.add(arg0);
list.add(arg1);
list.add(arg2);
list.add(arg3);
list.add(arg4);
list.add(arg5);
Number number = module.callFunction(emulator, 0x36a9, list.toArray())[0];
String result = vm.getObject(number.intValue()).getValue().toString();
System.out.println(&amp;#34;result: &amp;#34; + result);
// DvmClass Native=vm.resolveClass(&amp;#34;com/tujia/gundam/Gundam&amp;#34;);
// String methodSign = &amp;#34;encrypt(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IJ)Ljava/lang/String;&amp;#34;;
// Object arg0 = vm.addLocalObject(new StringObject(vm, &amp;#34;&amp;#34;));
// String arg1_str = &amp;#34;Mozilla/5.0 (Linux; Android 8.1.0; OPPO R11st Build/OPM1.171019.011; wv)&amp;#34;;
// Object arg1 = vm.addLocalObject(new StringObject(vm, arg1_str));
// String arg2_str = &amp;#34;LON=null;LAT=null;CID=226809753;LAC=42272;&amp;#34;;
// Object arg2 = vm.addLocalObject(new StringObject(vm, arg2_str));
// String arg3_str =&amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;abTests\&amp;#34;:{\&amp;#34;T_login_831\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;},\&amp;#34;searchhuojia\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;listfilter_227\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;T_renshu_292\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;Tlisttest_45664\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;Tlist_168\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;T_LIST27620\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;}}},\&amp;#34;client\&amp;#34;:{\&amp;#34;abTest\&amp;#34;:{},\&amp;#34;abTests\&amp;#34;:{},\&amp;#34;adTest\&amp;#34;:{\&amp;#34;m1\&amp;#34;:\&amp;#34;Color OS V5.2.1\&amp;#34;,\&amp;#34;m2\&amp;#34;:\&amp;#34;\&amp;#34;}&amp;#34;;
// Object arg3 = vm.addLocalObject(new StringObject(vm, arg3_str));
// int arg4 = arg3_str.getBytes(StandardCharsets.UTF_8).length;
// long arg5 = 1630845461L;
// Object ret = Native.callStaticJniMethodObject(emulator, methodSign, arg0,arg1,arg2,arg3,arg4,arg5);
// System.out.println(&amp;#34;call_encrypt ret:&amp;#34;+((DvmObject) ret).getValue());
}
public void get_bodyencrypt() throws FileNotFoundException {
List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
DvmClass Native=vm.resolveClass(&amp;#34;com/tujia/gundam/Gundam&amp;#34;);
DvmObject&amp;lt;?&amp;gt; jclass =Native.newObject(null);
String arg0_str = &amp;#34;1&amp;#34;;
Object arg0 = vm.addLocalObject(new StringObject(vm, arg0_str));
long arg1 = 1630808396L;
String arg2_str = &amp;#34;YM0A2TMAIEWA3xMAMM1xTjQEUYGD0wZAYAh32AdgQATDzAZNZA33WAEIZAzzhAMMNAzyTDAkZMzTizYOYN11TTgMRcDThyNMZO44GTIAVQGDi5OONN2wWGMMUVWj1iMNOYxxGmUU&amp;#34;;
Object arg2 = vm.addLocalObject(new StringObject(vm, arg2_str));
int arg3 = arg2_str.getBytes(StandardCharsets.UTF_8).length;
String arg4_str = &amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;activityTask\&amp;#34;:{},\&amp;#34;defa&amp;#34;;//&amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;activityTask\&amp;#34;:{},\&amp;#34;defaultKeyword\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;abTest\&amp;#34;:{\&amp;#34;AppSearchHouseList\&amp;#34;:\&amp;#34;B\&amp;#34;,\&amp;#34;listabtest8\&amp;#34;:\&amp;#34;B\&amp;#34;},\&amp;#34;returnNavigations\&amp;#34;:true,\&amp;#34;returnFilterConditions\&amp;#34;:true,\&amp;#34;specialKeyType\&amp;#34;:0,\&amp;#34;returnGeoConditions\&amp;#34;:true,\&amp;#34;abTests\&amp;#34;:{\&amp;#34;T_login_831\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;},\&amp;#34;searchhuojiatujia\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;listfilter_227\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;T_renshu_292\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;Tlisttest_45664\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;Tlist_168\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;T_LIST27620\&amp;#34;:{\&amp;#34;s\&amp;#34;:false,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;}},\&amp;#34;pageSize\&amp;#34;:10,\&amp;#34;excludeUnitIdSet\&amp;#34;:null,\&amp;#34;historyConditions\&amp;#34;:[],\&amp;#34;searchKeyword\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;url\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;isDirectSearch\&amp;#34;:false,\&amp;#34;sceneCondition\&amp;#34;:null,\&amp;#34;returnAllConditions\&amp;#34;:true,\&amp;#34;searchId\&amp;#34;:null,\&amp;#34;pageIndex\&amp;#34;:0,\&amp;#34;onlyReturnTotalCount\&amp;#34;:false,\&amp;#34;conditions\&amp;#34;:[{\&amp;#34;type\&amp;#34;:2,\&amp;#34;value\&amp;#34;:\&amp;#34;2021-09-05\&amp;#34;},{\&amp;#34;type\&amp;#34;:3,\&amp;#34;value\&amp;#34;:\&amp;#34;2021-09-06\&amp;#34;},{\&amp;#34;label\&amp;#34;:\&amp;#34;大理州\&amp;#34;,\&amp;#34;type\&amp;#34;:1,\&amp;#34;value\&amp;#34;:\&amp;#34;36\&amp;#34;}]},\&amp;#34;client\&amp;#34;:{\&amp;#34;abTest\&amp;#34;:{},\&amp;#34;abTests\&amp;#34;:{},\&amp;#34;adTest\&amp;#34;:{\&amp;#34;m1\&amp;#34;:\&amp;#34;Color OS V5.2.1\&amp;#34;,\&amp;#34;m2\&amp;#34;:\&amp;#34;ade40419318f085ff21b4776f2eef21f\&amp;#34;,\&amp;#34;m3\&amp;#34;:\&amp;#34;armeabi-v7a\&amp;#34;,\&amp;#34;m4\&amp;#34;:\&amp;#34;armeabi\&amp;#34;,\&amp;#34;m5\&amp;#34;:\&amp;#34;100\&amp;#34;,\&amp;#34;m6\&amp;#34;:\&amp;#34;2\&amp;#34;,\&amp;#34;m7\&amp;#34;:\&amp;#34;5\&amp;#34;},\&amp;#34;api_level\&amp;#34;:260,\&amp;#34;appFP\&amp;#34;:\&amp;#34;qA/Ch2zqjORBz90YV34sUZpcFXFV6vzhmAISdTjYAFeqMBTtMUukzQFXqkDokr+sMau0bWClwjtk36nbrVBWVrjmrPTCkXFIraNHdgRVW/QT6g4eLWuM3hhP8qsWgGnrErk2KA+GFxr/OBRMYfV4l0v+TYUDZ5k4bUCUawafdLY5b3aC02SuOrqjW3jjrXiB/dt6ErjrDv44vY4Y8/1r5Z6ut/2BmcErxM37MniKpW6EZc8F4CjJ9S1KRTtEPJ2Kkd2Sd8602jqdgtssJ6QKXyx2+qsKvybydVe+zSTXQGn/T86A6uW0oC+mJHwOLnP8HKN0q2Fu3rTcKZ+Prbs/dcBHaWJi1C1tHZFza2O+1gUQTgvg+Kq57BvE6IjEhveT\&amp;#34;,\&amp;#34;appId\&amp;#34;:\&amp;#34;com.tujia.hotel\&amp;#34;,\&amp;#34;appVersion\&amp;#34;:\&amp;#34;260_260\&amp;#34;,\&amp;#34;appVersionUpdate\&amp;#34;:\&amp;#34;rtag-20210803-183436-zhengyuan\&amp;#34;,\&amp;#34;batteryStatus\&amp;#34;:\&amp;#34;full\&amp;#34;,\&amp;#34;buildTag\&amp;#34;:\&amp;#34;rtag-20210803-183436-zhengyuan\&amp;#34;,\&amp;#34;buildVersion\&amp;#34;:\&amp;#34;8.38.0\&amp;#34;,\&amp;#34;ccid\&amp;#34;:\&amp;#34;51742042410923060391\&amp;#34;,\&amp;#34;channelCode\&amp;#34;:\&amp;#34;qq\&amp;#34;,\&amp;#34;crnVersion\&amp;#34;:\&amp;#34;254\&amp;#34;,\&amp;#34;devModel\&amp;#34;:\&amp;#34;OPPO R11st\&amp;#34;,\&amp;#34;devToken\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;devType\&amp;#34;:2,\&amp;#34;dtt\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;electricity\&amp;#34;:\&amp;#34;100\&amp;#34;,\&amp;#34;flutterPkgId\&amp;#34;:\&amp;#34;277\&amp;#34;,\&amp;#34;gps\&amp;#34;:null,\&amp;#34;kaTest\&amp;#34;:{\&amp;#34;k1\&amp;#34;:\&amp;#34;2_1_2\&amp;#34;,\&amp;#34;k2\&amp;#34;:\&amp;#34;sdm660\&amp;#34;,\&amp;#34;k3\&amp;#34;:\&amp;#34;ubuntu-16\&amp;#34;,\&amp;#34;k4\&amp;#34;:\&amp;#34;R11st_11_A.43_200402\&amp;#34;,\&amp;#34;k5\&amp;#34;:\&amp;#34;OPPO/R11st/R11s:8.1.0/OPM1.171019.011/1577198226:user/release-keys\&amp;#34;,\&amp;#34;k6\&amp;#34;:\&amp;#34;R11st\&amp;#34;,\&amp;#34;k7\&amp;#34;:\&amp;#34;OPM1.171019.011\&amp;#34;},\&amp;#34;latitude\&amp;#34;:\&amp;#34;23.105714\&amp;#34;,\&amp;#34;locale\&amp;#34;:\&amp;#34;zh-CN\&amp;#34;,\&amp;#34;longitude\&amp;#34;:\&amp;#34;113.470271\&amp;#34;,\&amp;#34;networkType\&amp;#34;:\&amp;#34;1\&amp;#34;,\&amp;#34;osVersion\&amp;#34;:\&amp;#34;8.1.0\&amp;#34;,\&amp;#34;platform\&amp;#34;:\&amp;#34;1\&amp;#34;,\&amp;#34;salt\&amp;#34;:\&amp;#34;ZMmADTBAMIzAzxMAYMkxWjVEFY2TkwNMZAh2WAdAFATzmAZMYA3wTAEckAzT2AMMMAz52DAIZMzThzYMMN1xWTgYMcDD0yNNMO41zTIQUQGDx5OOZN2wDGMMEVWjziMNZYxxDmUA\&amp;#34;,\&amp;#34;screenInfo\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;sessionId\&amp;#34;:\&amp;#34;a3e57f1c-03a8-3bc4-8709-fb36e7698ae4_1630844995950\&amp;#34;,\&amp;#34;tId\&amp;#34;:\&amp;#34;21090509553913313246\&amp;#34;,\&amp;#34;tbTest\&amp;#34;:{\&amp;#34;j1\&amp;#34;:\&amp;#34;11d890e2\&amp;#34;,\&amp;#34;j2\&amp;#34;:\&amp;#34;R11s\&amp;#34;,\&amp;#34;j3\&amp;#34;:\&amp;#34;OPPO R11st\&amp;#34;,\&amp;#34;j4\&amp;#34;:\&amp;#34;OPPO\&amp;#34;,\&amp;#34;j5\&amp;#34;:\&amp;#34;OPPO\&amp;#34;,\&amp;#34;j6\&amp;#34;:\&amp;#34;unknown\&amp;#34;,\&amp;#34;j7\&amp;#34;:\&amp;#34;qcom\&amp;#34;,\&amp;#34;j8\&amp;#34;:\&amp;#34;2.1.0 (ART)\&amp;#34;},\&amp;#34;traceid\&amp;#34;:\&amp;#34;1630845462612_1630845462444_1630845358749\&amp;#34;,\&amp;#34;uID\&amp;#34;:\&amp;#34;a3e57f1c-03a8-3bc4-8709-fb36e7698ae4\&amp;#34;,\&amp;#34;version\&amp;#34;:\&amp;#34;260\&amp;#34;,\&amp;#34;wifi\&amp;#34;:null,\&amp;#34;wifimac\&amp;#34;:\&amp;#34;i5ZQ9aI14FDr9VMJ/ECIg7KAOE+Xev1/CrFoa53WLbE=\&amp;#34;},\&amp;#34;psid\&amp;#34;:\&amp;#34;76938405-a463-464a-9c49-752022daf516\&amp;#34;,\&amp;#34;type\&amp;#34;:null,\&amp;#34;user\&amp;#34;:null,\&amp;#34;usid\&amp;#34;:null}&amp;#34;;
Object arg4 = vm.addLocalObject(new StringObject(vm, arg4_str));
int arg5 = arg4_str.getBytes(StandardCharsets.UTF_8).length;
list.add(vm.getJNIEnv());
list.add(vm.addLocalObject(jclass));
list.add(arg0);
list.add(arg1);
list.add(arg2);
list.add(arg3);
list.add(arg4);
list.add(arg5);
Number number = module.callFunction(emulator, 0x380c+1, list.toArray())[0];
String result = vm.getObject(number.intValue()).getValue().toString();
System.out.println(&amp;#34;result: &amp;#34; + result);
}
public static void main(String[] args) throws FileNotFoundException {
Test test = new Test();
test.call_encrypt();
test.get_bodyencrypt();
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>算法还原&lt;/strong>&lt;/p>
&lt;p>&lt;strong>encrypt:&lt;/strong>&lt;/p>
&lt;p>签名是 40 位长度的 16 进制字符串，很快想到是 sha1；让我们来 see see 是不是;&lt;/p>
&lt;p>把 so 文件扔进 ida；按 g 跳到 0x36a9（为什么搜这个？划上去再看一遍）;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3F74kVDHBesTjOWlJmbibvND4tdXAsxnvmRQgnPgWjpwYhQE22KJGuug/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>静态分析一波;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3u79uLibZOrrqVVDSYfQfdaMBRorAmAEYicHgluA26pL9zxMWQxBYzSDg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3uS8r51ibxIxErlYiaIrLlwo8GPWQJUlT21zTrynrRRIFNKhYSQqGKgnA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>EncodeHTTP 函数好长, 我们从下往上看;&lt;/p>
&lt;p>欲知后事如何&lt;/p>
&lt;p>请看下回分解&lt;/p></description></item><item><title>unidbg 算法还原术 · 某民宿 app 篇 · 下卷</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8B%E5%8D%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8B%E5%8D%B7/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA5NDE1OQ==&amp;amp;mid=2247485139&amp;amp;idx=1&amp;amp;sn=6875f205e642ef27880c8935e7756217&amp;amp;chksm=9f8bb7f3a8fc3ee592dc4320a8996179b975214319ad8ba1434dff2c3c90f6bbbcc26137dd6a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1030u3BXGR0GFJ5hM59qxMBf&amp;amp;sharer_sharetime=1635588940320&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3xBMR1a091Vb8Zxc7LcpA3Q6GDeLSF6NYbVPaAygKTuwSZh0Dk1IqPw/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3wwia1uOgibv9l3txQaMYIUic4HpoefGKIy9d9xpGDgnBDcXmJEONBuNtQ/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall bodyEncrypt(JNIEnv *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
JNIEnv *v10; // r4
int v11; // r6
int v12; // r5
int v13; // r11
char *v14; // r9
int v15; // ST14_4
int v16; // r6
int v17; // r10
size_t v18; // r0
int v19; // r8
void *v20; // r5
int v21; // r4
int result; // r0
int v23; // [sp+1Ch] [bp-24h]
int v24; // [sp+20h] [bp-20h]
v10 = a1;
v11 = a9;
v12 = a3;
v13 = a7;
if ( !a9 )
v11 = ((*a1)-&amp;gt;NewStringUTF)(a1, &amp;amp;unk_13ECB);
if ( !a7 )
v13 = ((*v10)-&amp;gt;NewStringUTF)(v10, &amp;amp;unk_13ECB);
if ( !v12 )
v12 = ((*v10)-&amp;gt;NewStringUTF)(v10, &amp;amp;unk_13ECB);
v14 = ((*v10)-&amp;gt;GetStringUTFChars)(v10, v12, 0);
v15 = v11;
v16 = ((*v10)-&amp;gt;GetStringUTFChars)(v10, v11, 0);
v17 = ((*v10)-&amp;gt;GetStringUTFChars)(v10, v13, 0);
v23 = 0;
v18 = strlen(v14);
v19 = j_tj_crypt(v14, v18, a5, a6, v17, a8, v16, a10, &amp;amp;v23);
((*v10)-&amp;gt;ReleaseStringUTFChars)(v10, v12, v14);
((*v10)-&amp;gt;ReleaseStringUTFChars)(v10, v13, v17);
((*v10)-&amp;gt;ReleaseStringUTFChars)(v10, v15, v16);
if ( v19 )
{
v20 = j_tjtxtutf8(v19, v23, 10);
v21 = ((*v10)-&amp;gt;NewStringUTF)(v10, v20);
free(v20);
}
else
{
v21 = ((*v10)-&amp;gt;NewStringUTF)(v10, &amp;amp;unk_13ECB);
}
result = _stack_chk_guard - v24;
if ( _stack_chk_guard == v24 )
result = v21;
return result;
}
&lt;/code>&lt;/pre>&lt;p>流程如下&lt;/p>
&lt;pre tabindex="0">&lt;code>v19 = j_tj_crypt(v14, v18, a5, a6, v17, a8, v16, a10, &amp;amp;v23);
v20 = j_tjtxtutf8(v19, v23, 10);
v21 = ((*v10)-&amp;gt;NewStringUTF)(v10, v20);
result = v21;
return result;
&lt;/code>&lt;/pre>&lt;p>v19 是经过加密函数 j_tj_crypt  加密后生成的 bytes，再经过 j_tjtxtutf8（上篇知道第三个参数为 10 的时候是标准的 base64）base64 编码&lt;/p>
&lt;p>可以打个断点验证下&lt;/p>
&lt;p>j_tjtxtutf8：&lt;/p>
&lt;p>0x38FC 下个断点&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4kBzMcllIeOMlWyRbvalfyvBhkSRRbxNX9aG2JVzbGNpvPAicTqbWcRcFv4riaoiawcDiaxr477qqSSQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>打印 r0 的值，长度是 0x31&lt;/p>
&lt;p>mr0 0x31&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4kBzMcllIeOMlWyRbvalfyz6blLggE2nic2lUDZ4DSe4xhTHZ0xgj1JNHhBj76eQ1ru5nyWgEfQFQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>blr 添加函数结束后断点&lt;/p>
&lt;p>c 跳到下个断点&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4kBzMcllIeOMlWyRbvalfyME1ZsG6CLcS9Rwib9emVuoqL5mOia855LibWJFdULLYbONmJ0O4rpM9ww/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>逆向之友验证&lt;/p>
&lt;pre tabindex="0">&lt;code>https://gchq.github.io/CyberChef
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4kBzMcllIeOMlWyRbvalfyK73yjet1iafSVibtlwvGUoHlxiaribZskWia2IoODgHRzzY4YlSQvRkQQIQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>没毛病，接下来看 j_tj_crypt 是怎么生成 v19 的&lt;/p>
&lt;p>进到 tj_crypt 函数&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4QXibVXWOQF6KOgCffrcxgKsAzVOA46uNDEI857Cg9ibn2F9Mfjtlvib2eYErqhQdG1kdUwiczXMAkww/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看到熟悉的 key 了&lt;/p>
&lt;p>然后这些 &amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo; 是代表加密模式&lt;/p>
&lt;p>stmcmp 是 c 函数&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4QXibVXWOQF6KOgCffrcxgKGNjtslMXkPyEDYCNrQtRss9XtQ6kXmz0QuU3DEyCzEXmjetmvRJhcA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也就是根据第一个参数的值才决定用哪种加密&lt;/p>
&lt;p>我们可以在 unidbg 上修改第一个参数的值，可以看到三种加密的结果是不一样的&lt;/p>
&lt;pre tabindex="0">&lt;code> public void get_bodyencrypt() throws FileNotFoundException {
List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
DvmClass Native=vm.resolveClass(&amp;#34;com/tujia/gundam/Gundam&amp;#34;);
DvmObject&amp;lt;?&amp;gt; jclass =Native.newObject(null);
String arg0_str = &amp;#34;1&amp;#34;;
Object arg0 = vm.addLocalObject(new StringObject(vm, arg0_str));
long arg1 = 1630808396L;
String arg2_str = &amp;#34;YM0A2TMAIEWA3xMAMM1xTjQEUYGD0wZAYAh32AdgQATDzAZNZA33WAEIZAzzhAMMNAzyTDAkZMzTizYOYN11TTgMRcDThyNMZO44GTIAVQGDi5OONN2wWGMMUVWj1iMNOYxxGmUU&amp;#34;;
Object arg2 = vm.addLocalObject(new StringObject(vm, arg2_str));
int arg3 = arg2_str.getBytes(StandardCharsets.UTF_8).length;
String arg4_str = &amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;activityTask\&amp;#34;:{},\&amp;#34;defa&amp;#34;;//&amp;#34;{\&amp;#34;code\&amp;#34;:null,\&amp;#34;parameter\&amp;#34;:{\&amp;#34;activityTask\&amp;#34;:{},\&amp;#34;defaultKeyword\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;abTest\&amp;#34;:{\&amp;#34;AppSearchHouseList\&amp;#34;:\&amp;#34;B\&amp;#34;,\&amp;#34;listabtest8\&amp;#34;:\&amp;#34;B\&amp;#34;},\&amp;#34;returnNavigations\&amp;#34;:true,\&amp;#34;returnFilterConditions\&amp;#34;:true,\&amp;#34;specialKeyType\&amp;#34;:0,\&amp;#34;returnGeoConditions\&amp;#34;:true,\&amp;#34;abTests\&amp;#34;:{\&amp;#34;T_login_831\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;},\&amp;#34;searchhuojiatujia\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;listfilter_227\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;T_renshu_292\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;D\&amp;#34;},\&amp;#34;Tlisttest_45664\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;Tlist_168\&amp;#34;:{\&amp;#34;s\&amp;#34;:true,\&amp;#34;v\&amp;#34;:\&amp;#34;C\&amp;#34;},\&amp;#34;T_LIST27620\&amp;#34;:{\&amp;#34;s\&amp;#34;:false,\&amp;#34;v\&amp;#34;:\&amp;#34;A\&amp;#34;}},\&amp;#34;pageSize\&amp;#34;:10,\&amp;#34;excludeUnitIdSet\&amp;#34;:null,\&amp;#34;historyConditions\&amp;#34;:[],\&amp;#34;searchKeyword\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;url\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;isDirectSearch\&amp;#34;:false,\&amp;#34;sceneCondition\&amp;#34;:null,\&amp;#34;returnAllConditions\&amp;#34;:true,\&amp;#34;searchId\&amp;#34;:null,\&amp;#34;pageIndex\&amp;#34;:0,\&amp;#34;onlyReturnTotalCount\&amp;#34;:false,\&amp;#34;conditions\&amp;#34;:[{\&amp;#34;type\&amp;#34;:2,\&amp;#34;value\&amp;#34;:\&amp;#34;2021-09-05\&amp;#34;},{\&amp;#34;type\&amp;#34;:3,\&amp;#34;value\&amp;#34;:\&amp;#34;2021-09-06\&amp;#34;},{\&amp;#34;label\&amp;#34;:\&amp;#34;大理州\&amp;#34;,\&amp;#34;type\&amp;#34;:1,\&amp;#34;value\&amp;#34;:\&amp;#34;36\&amp;#34;}]},\&amp;#34;client\&amp;#34;:{\&amp;#34;abTest\&amp;#34;:{},\&amp;#34;abTests\&amp;#34;:{},\&amp;#34;adTest\&amp;#34;:{\&amp;#34;m1\&amp;#34;:\&amp;#34;Color OS V5.2.1\&amp;#34;,\&amp;#34;m2\&amp;#34;:\&amp;#34;ade40419318f085ff21b4776f2eef21f\&amp;#34;,\&amp;#34;m3\&amp;#34;:\&amp;#34;armeabi-v7a\&amp;#34;,\&amp;#34;m4\&amp;#34;:\&amp;#34;armeabi\&amp;#34;,\&amp;#34;m5\&amp;#34;:\&amp;#34;100\&amp;#34;,\&amp;#34;m6\&amp;#34;:\&amp;#34;2\&amp;#34;,\&amp;#34;m7\&amp;#34;:\&amp;#34;5\&amp;#34;},\&amp;#34;api_level\&amp;#34;:260,\&amp;#34;appFP\&amp;#34;:\&amp;#34;qA/Ch2zqjORBz90YV34sUZpcFXFV6vzhmAISdTjYAFeqMBTtMUukzQFXqkDokr+sMau0bWClwjtk36nbrVBWVrjmrPTCkXFIraNHdgRVW/QT6g4eLWuM3hhP8qsWgGnrErk2KA+GFxr/OBRMYfV4l0v+TYUDZ5k4bUCUawafdLY5b3aC02SuOrqjW3jjrXiB/dt6ErjrDv44vY4Y8/1r5Z6ut/2BmcErxM37MniKpW6EZc8F4CjJ9S1KRTtEPJ2Kkd2Sd8602jqdgtssJ6QKXyx2+qsKvybydVe+zSTXQGn/T86A6uW0oC+mJHwOLnP8HKN0q2Fu3rTcKZ+Prbs/dcBHaWJi1C1tHZFza2O+1gUQTgvg+Kq57BvE6IjEhveT\&amp;#34;,\&amp;#34;appId\&amp;#34;:\&amp;#34;com.tujia.hotel\&amp;#34;,\&amp;#34;appVersion\&amp;#34;:\&amp;#34;260_260\&amp;#34;,\&amp;#34;appVersionUpdate\&amp;#34;:\&amp;#34;rtag-20210803-183436-zhengyuan\&amp;#34;,\&amp;#34;batteryStatus\&amp;#34;:\&amp;#34;full\&amp;#34;,\&amp;#34;buildTag\&amp;#34;:\&amp;#34;rtag-20210803-183436-zhengyuan\&amp;#34;,\&amp;#34;buildVersion\&amp;#34;:\&amp;#34;8.38.0\&amp;#34;,\&amp;#34;ccid\&amp;#34;:\&amp;#34;51742042410923060391\&amp;#34;,\&amp;#34;channelCode\&amp;#34;:\&amp;#34;qq\&amp;#34;,\&amp;#34;crnVersion\&amp;#34;:\&amp;#34;254\&amp;#34;,\&amp;#34;devModel\&amp;#34;:\&amp;#34;OPPO R11st\&amp;#34;,\&amp;#34;devToken\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;devType\&amp;#34;:2,\&amp;#34;dtt\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;electricity\&amp;#34;:\&amp;#34;100\&amp;#34;,\&amp;#34;flutterPkgId\&amp;#34;:\&amp;#34;277\&amp;#34;,\&amp;#34;gps\&amp;#34;:null,\&amp;#34;kaTest\&amp;#34;:{\&amp;#34;k1\&amp;#34;:\&amp;#34;2_1_2\&amp;#34;,\&amp;#34;k2\&amp;#34;:\&amp;#34;sdm660\&amp;#34;,\&amp;#34;k3\&amp;#34;:\&amp;#34;ubuntu-16\&amp;#34;,\&amp;#34;k4\&amp;#34;:\&amp;#34;R11st_11_A.43_200402\&amp;#34;,\&amp;#34;k5\&amp;#34;:\&amp;#34;OPPO/R11st/R11s:8.1.0/OPM1.171019.011/1577198226:user/release-keys\&amp;#34;,\&amp;#34;k6\&amp;#34;:\&amp;#34;R11st\&amp;#34;,\&amp;#34;k7\&amp;#34;:\&amp;#34;OPM1.171019.011\&amp;#34;},\&amp;#34;latitude\&amp;#34;:\&amp;#34;23.105714\&amp;#34;,\&amp;#34;locale\&amp;#34;:\&amp;#34;zh-CN\&amp;#34;,\&amp;#34;longitude\&amp;#34;:\&amp;#34;113.470271\&amp;#34;,\&amp;#34;networkType\&amp;#34;:\&amp;#34;1\&amp;#34;,\&amp;#34;osVersion\&amp;#34;:\&amp;#34;8.1.0\&amp;#34;,\&amp;#34;platform\&amp;#34;:\&amp;#34;1\&amp;#34;,\&amp;#34;salt\&amp;#34;:\&amp;#34;ZMmADTBAMIzAzxMAYMkxWjVEFY2TkwNMZAh2WAdAFATzmAZMYA3wTAEckAzT2AMMMAz52DAIZMzThzYMMN1xWTgYMcDD0yNNMO41zTIQUQGDx5OOZN2wDGMMEVWjziMNZYxxDmUA\&amp;#34;,\&amp;#34;screenInfo\&amp;#34;:\&amp;#34;\&amp;#34;,\&amp;#34;sessionId\&amp;#34;:\&amp;#34;a3e57f1c-03a8-3bc4-8709-fb36e7698ae4_1630844995950\&amp;#34;,\&amp;#34;tId\&amp;#34;:\&amp;#34;21090509553913313246\&amp;#34;,\&amp;#34;tbTest\&amp;#34;:{\&amp;#34;j1\&amp;#34;:\&amp;#34;11d890e2\&amp;#34;,\&amp;#34;j2\&amp;#34;:\&amp;#34;R11s\&amp;#34;,\&amp;#34;j3\&amp;#34;:\&amp;#34;OPPO R11st\&amp;#34;,\&amp;#34;j4\&amp;#34;:\&amp;#34;OPPO\&amp;#34;,\&amp;#34;j5\&amp;#34;:\&amp;#34;OPPO\&amp;#34;,\&amp;#34;j6\&amp;#34;:\&amp;#34;unknown\&amp;#34;,\&amp;#34;j7\&amp;#34;:\&amp;#34;qcom\&amp;#34;,\&amp;#34;j8\&amp;#34;:\&amp;#34;2.1.0 (ART)\&amp;#34;},\&amp;#34;traceid\&amp;#34;:\&amp;#34;1630845462612_1630845462444_1630845358749\&amp;#34;,\&amp;#34;uID\&amp;#34;:\&amp;#34;a3e57f1c-03a8-3bc4-8709-fb36e7698ae4\&amp;#34;,\&amp;#34;version\&amp;#34;:\&amp;#34;260\&amp;#34;,\&amp;#34;wifi\&amp;#34;:null,\&amp;#34;wifimac\&amp;#34;:\&amp;#34;i5ZQ9aI14FDr9VMJ/ECIg7KAOE+Xev1/CrFoa53WLbE=\&amp;#34;},\&amp;#34;psid\&amp;#34;:\&amp;#34;76938405-a463-464a-9c49-752022daf516\&amp;#34;,\&amp;#34;type\&amp;#34;:null,\&amp;#34;user\&amp;#34;:null,\&amp;#34;usid\&amp;#34;:null}&amp;#34;;
Object arg4 = vm.addLocalObject(new StringObject(vm, arg4_str));
int arg5 = arg4_str.getBytes(StandardCharsets.UTF_8).length;
list.add(vm.getJNIEnv());
list.add(vm.addLocalObject(jclass));
list.add(arg0);
list.add(arg1);
list.add(arg2);
list.add(arg3);
list.add(arg4);
list.add(arg5);
Number number = module.callFunction(emulator, 0x380c+1, list.toArray())[0];
String result = vm.getObject(number.intValue()).getValue().toString();
System.out.println(&amp;#34;result: &amp;#34; + result);
}
&lt;/code>&lt;/pre>&lt;p>当 String arg0_str = &amp;ldquo;1&amp;rdquo;&lt;/p>
&lt;p>结果为&lt;/p>
&lt;pre tabindex="0">&lt;code>2uEIVLrtvmHQ72DYG1+fFcCSo5obEd62UMKP+O7zFRx+K6u3FhLY0f3gYdZds/BMRA==
&lt;/code>&lt;/pre>&lt;p>当 String arg0_str = &amp;ldquo;2&amp;rdquo;&lt;/p>
&lt;p>结果为&lt;/p>
&lt;pre tabindex="0">&lt;code>NO3dVW0Fr4yk5Xxoc64Nn903e6sSZK3Uif1TB8dHmVVlXXqzMuteseCb4hfd1/WUQFyHPmxIIRM86pCkymjlgQ==
&lt;/code>&lt;/pre>&lt;p>当 String arg0_str = &amp;ldquo;3&amp;rdquo;&lt;/p>
&lt;p>结果为&lt;/p>
&lt;pre tabindex="0">&lt;code>HAT5BvN81B8PjW69r1sqCvf0cwN/Pey9XoAWBnkuGYEeVpqWTDBuyei8kaZ00XTJig/SKP4qThHwuGgWmlr4fg==
&lt;/code>&lt;/pre>&lt;p>开始逐一击破&lt;/p>
&lt;p>&lt;strong>加密模式 1&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4QXibVXWOQF6KOgCffrcxgK5jqNJqBMPAYwU7VHXCVkqEbxjlibJqNib3MBWj2QGnozQYSAS3d2ILEQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>strncmp &amp;ldquo;1&amp;rdquo; 和 v10 比较，v10=1 所以相等返回 0，!0 则是 true&lt;/p>
&lt;p>所以跳到 LABEL_17&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWI2icu8ccmwjNcPWEUo2ZLn2qqxtD5KUYjTGvrN4pbQ2VVQVJkicXoLYLA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有三个函数，分别是 sub_3880、sub_302C、j_CCCrypt&lt;/p>
&lt;p>显而易见，加密逻辑在 j_CCCrypt 函数里，而且因为最后 return 的 v11=v22，v22 就是放解密结果的地方&lt;/p>
&lt;p>hook CCCrypt:&lt;/p>
&lt;pre tabindex="0">&lt;code> public void hook_CCCrypt(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x4480 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
int arg0 = ctx.getIntArg(0);
int arg1 = ctx.getIntArg(1);
                int arg2 = ctx.getIntArg(2);
Pointer arg3 = ctx.getPointerArg(3);
byte[] arg3_ = arg3.getByteArray(0, ctx.getIntArg(4));
int arg4 = ctx.getIntArg(4);
int arg5 = ctx.getIntArg(5);
                String arg6 = ctx.getPointerArg(6).getString(0);
int arg7 = ctx.getIntArg(7);
Pointer arg8 = ctx.getPointerArg(8);
int arg9 = ctx.getIntArg(9);
System.out.println(&amp;#34;arg0:&amp;#34;+arg0);
System.out.println(&amp;#34;arg1:&amp;#34;+arg1);
System.out.println(&amp;#34;arg2:&amp;#34;+arg2);
Inspector.inspect(arg3_, &amp;#34;arg3&amp;#34;);
System.out.println(&amp;#34;arg4:&amp;#34;+arg4);
System.out.println(&amp;#34;arg5:&amp;#34;+arg5);
System.out.println(&amp;#34;arg6:&amp;#34;+arg6);
                System.out.println(&amp;#34;arg7:&amp;#34;+arg7);
ctx.push(arg8);
                ctx.push(arg9);
            };
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
                int length=ctx.pop();
Pointer output = ctx.pop();
byte[] outputhex = output.getByteArray(0, length);
Inspector.inspect(outputhex, &amp;#34;CCCrypt ret&amp;#34;);
}
});
hookZz.disable_arm_arm64_b_branch();
}
&lt;/code>&lt;/pre>&lt;p>hook 结果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIcMAtV76Nico7rLvuial1xlcvvvrQXOBicUluYW9qDkYj0tT8oPsWSOK8g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>大胆一点猜，arg3(v4) 就是密钥，是 sub_302C 函数生成的&lt;/p>
&lt;p>arg6(a7) 就是明文，是什么加密还不知道，反正 99% 是对称加密&lt;/p>
&lt;p>这时候是先看密钥怎么生成的还是先找出是什么加密算法呢？&lt;/p>
&lt;p>都可以，我喜欢倒着推，所以先看 CCCrypt，双击进入函数&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAHtr5I62m4IGmyKLF5auKcldIiaiaw6uet42WmvN665y62K6eC63j5dT1g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>显而易见  j_CCCryptorCreate 是加密的初始化函数&lt;/p>
&lt;p>双击进去 &lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall CCCryptorCreate(int a1, unsigned int a2, void *a3, int a4, int a5, int a6, _DWORD *a7)
{
unsigned int v7; // r5
void **v8; // r8
int v9; // r9
void *v10; // r11
int v11; // r10
int v12; // r4
size_t v14; // r4
_BYTE *v15; // r0
int v16; // r0
void *v17; // [sp+10h] [bp-28h]
size_t v18; // [sp+14h] [bp-24h]
int v19; // [sp+18h] [bp-20h]
v11 = a1;
v12 = 0xFFFFEF34;
if ( a7 )
{
v7 = a2;
if ( a2 &amp;lt;= 5 )
{
v9 = a4;
v10 = a3;
v8 = off_1EB14[a2];
v12 = (*v8)(a1);
if ( !v12 )
goto LABEL_6;
}
}
while ( _stack_chk_guard != v19 )
{
LABEL_6:
v17 = v10;
v14 = v18 + 20;
v18 = v14;
v15 = malloc(v14);
if ( v15 )
{
v10 = v15;
*(v15 + 1) = v14;
*(v15 + 2) = v11;
*(v15 + 3) = v7;
*(v15 + 4) = v8;
*v15 = 1;
v16 = (v8[1])(v15 + 20, v11, v7, v17, v9, a5, a6);
if ( v16 )
{
v12 = v16;
free(v10);
}
else
{
v12 = 0;
*a7 = v10;
}
}
else
{
v12 = -4302;
}
}
return v12;
}
&lt;/code>&lt;/pre>&lt;p>这里伪代码看着有点懵？看上去好像没函数? 但是这里不对劲？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAHVdqQTCaGsI2Mlb8elWicib3dBjVufVurFMKPbnBLRCbmpDeNHibuyk5yg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里 v8[1] 应该是个函数地址？后边是参数？&lt;/p>
&lt;p>那 v8[1] 的地址是多少呢？&lt;/p>
&lt;p>按 tab，转成汇编再看看&lt;/p>
&lt;pre tabindex="0">&lt;code>.text:00004274 EXPORT CCCryptorCreate
.text:00004274 CCCryptorCreate ; CODE XREF: j_CCCryptorCreate+8↑j
.text:00004274 ; DATA XREF: LOAD:00000450↑o ...
.text:00004274
.text:00004274 anonymous_0 = -0x34
.text:00004274 var_28 = -0x28
.text:00004274 var_24 = -0x24
.text:00004274 var_20 = -0x20
.text:00004274 anonymous_1 = 8
.text:00004274 arg_8 = 0x10
.text:00004274
.text:00004274 ; __unwind {
.text:00004274 PUSH {R4-R7,LR}
.text:00004276 ADD R7, SP, #0xC
.text:00004278 PUSH.W {R1-R11}
.text:0000427C MOV R10, R0
.text:0000427E LDR R0, =(__stack_chk_guard_ptr - 0x4284)
.text:00004280 ADD R0, PC ; __stack_chk_guard_ptr
.text:00004282 LDR R6, [R0] ; __stack_chk_guard
.text:00004284 LDR R0, [R6]
.text:00004286 STR R0, [SP,#0x38+var_20]
.text:00004288 LDR R0, =0xFFFFEF32
.text:0000428A ADDS R4, R0, #2
.text:0000428C LDR R0, [R7,#arg_8]
.text:0000428E CBZ R0, loc_42B2
.text:00004290 MOV R5, R1
.text:00004292 CMP R1, #5
.text:00004294 BHI loc_42B2
.text:00004296 LDR R0, =(off_1EB14 - 0x42A2) ; r0=0x1EB14 - 0x42A2 = 0x1A872
.text:00004298 MOV R9, R3
.text:0000429A MOV R11, R2
.text:0000429C ADD R2, SP, #0x38+var_24
.text:0000429E ADD R0, PC ; off_1EB14
.text:000042A0 MOV R1, R5
.text:000042A2 LDR.W R8, [R0,R5,LSL#2]
.text:000042A6 MOV R0, R10
.text:000042A8 LDR.W R3, [R8]
.text:000042AC BLX R3
.text:000042AE MOV R4, R0
.text:000042B0 CBZ R0, loc_42C8
.text:000042B2
.text:000042B2 loc_42B2 ; CODE XREF: CCCryptorCreate+1A↑j
.text:000042B2 ; CCCryptorCreate+20↑j ...
.text:000042B2 LDR R0, [R6]
.text:000042B4 LDR R1, [SP,#0x38+var_20]
.text:000042B6 SUBS R0, R0, R1
.text:000042B8 ITTTT EQ
.text:000042BA MOVEQ R0, R4
.text:000042BC ADDEQ SP, SP, #0x1C
.text:000042BE POPEQ.W {R8-R11}
.text:000042C2 POPEQ {R4-R7,PC}
.text:000042C4 BLX __stack_chk_fail
.text:000042C8 ; ---------------------------------------------------------------------------
.text:000042C8
.text:000042C8 loc_42C8 ; CODE XREF: CCCryptorCreate+3C↑j
.text:000042C8 LDR R0, [SP,#0x38+var_24]
.text:000042CA STR.W R11, [SP,#0x38+var_28]
.text:000042CE ADD.W R4, R0, #0x14
.text:000042D2 STR R4, [SP,#0x38+var_24]
.text:000042D4 MOV R0, R4 ; size
.text:000042D6 BLX malloc
.text:000042DA CBZ R0, loc_4312
.text:000042DC MOV R11, R0
.text:000042DE LDRD.W R1, R0, [R7,#8]
.text:000042E2 MOVS R2, #1
.text:000042E4 STRD.W R4, R10, [R11,#4]
.text:000042E8 STRD.W R5, R8, [R11,#0xC]
.text:000042EC STRB.W R2, [R11]
.text:000042F0 MOV R2, R5
.text:000042F2 LDR.W R4, [R8,#4]
.text:000042F6 LDR R3, [SP,#0x38+var_28]
.text:000042F8 STRD.W R9, R1, [SP]
.text:000042FC MOV R1, R10
.text:000042FE STR R0, [SP,#0x38+anonymous_0+4]
.text:00004300 ADD.W R0, R11, #0x14
.text:00004304 BLX R4
.text:00004306 CBZ R0, loc_4316
.text:00004308 MOV R4, R0
.text:0000430A MOV R0, R11 ; ptr
.text:0000430C BLX free
.text:00004310 B loc_42B2
.text:00004312 ; ---------------------------------------------------------------------------
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAHLibOUuywicYraD9dRD8laMIwXA5tTxATMSJnwymibNc4GicPtXdERIr1Ag/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>按 tab 键，可以看到对应的汇编是这行，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAHTRmUOtGk4tqESIdrNcuicCr3wbfLFGqyGT0ibiaKrkRsbHb06Kiawb16jg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>汇编: BLX  R4&lt;/p>
&lt;pre tabindex="0">&lt;code>指令BLX
指令的格式为：BLX 目标地址BLX
指令从ARM 指令集跳转到指令中所指定的目标地址，
并将处理器的工作状态有ARM 状态切换到Thumb 状态。
&lt;/code>&lt;/pre>&lt;p>显而易见，这里是动态跳转的，也就是说 R4 的地址是计算出来的，不是写死的，所以我们得知道 R4 是多少；&lt;/p>
&lt;p>这里有两种方法获得 R4 的值：&lt;/p>
&lt;p>第一种方法很简单，用 unidbg 或 frida inline hook 0x4304，看 r4 寄存器的值不就行了嘛？&lt;/p>
&lt;p>第二种方法就是静态分析，手动计算出来不就行了嘛？&lt;/p>
&lt;p>先挑战一下第二种方法看看能出来不？&lt;/p>
&lt;p>R4 哪来的？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWI87A4xEjgiaU8GGejzWEWVQ3MR0ZFYgWd6ibPGQDpL3uSS5qzCgpBicZaQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>.text:000042F2 LDR.W R4, [R8,#4]
即：R4 = [R8 + 0x4] []代表取R8+R4的指针
&lt;/code>&lt;/pre>&lt;p>R8 哪来的？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWI6m5BT2GpRSibWFBkVUkvBiawSfn89Ro86vm2iabOtj1RAM8OAABQL3qIQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>.text:000042A2 LDR.W R8, [R0,R5,LSL#2]
即：R8 = [R0 + (R5&amp;lt;&amp;lt;2)] ，[]代表取R0+(R5&amp;lt;&amp;lt;2)的指针
&lt;/code>&lt;/pre>&lt;p>R0 哪来的？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWISIqsvQH2AKMqibKyOiaiaotlOAU68uibbpCibzjz5Rz866X6HQZWJXibfXJQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>.text:0000429E ADD R0, PC ; off_1EB14
即：R0 = R0+PC   这里ida已经算出R0=0x1EB14
&lt;/code>&lt;/pre>&lt;p>R5 哪来的？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIkrhQeHJMhxPdNCiaFiaAtV4TryI8fcLguInQs5pKGlDfqjssCJanA9aw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>.text:00004290 MOV R5, R1
R5=R1 也就是函数的第二个参数,最后追到tj_crypt函数里的v25=v17 = 4
if ( !strncmp(&amp;#34;1&amp;#34;, v10, n) )
{
v16 = v9;
v17 = 4;
LABEL_15:
v25 = v17;
v9 = 0;
goto LABEL_17;
}
&lt;/code>&lt;/pre>&lt;p>流程：&lt;/p>
&lt;pre tabindex="0">&lt;code>.text:00004290 MOV R5, R1
.text:0000429E ADD R0, PC ; off_1EB14
.text:000042A2 LDR.W R8, [R0,R5,LSL#2]
.text:000042F2 LDR.W R4, [R8,#4]
&lt;/code>&lt;/pre>&lt;p>R5 = 4&lt;/p>
&lt;p>R0 = 0x1EB14&lt;/p>
&lt;p>R8 = [R0+(4&amp;laquo;2)] = [0x1EB24]&lt;/p>
&lt;p>R4 = [R8+4]&lt;/p>
&lt;p>[0x1EB24] 表示取 0x1EB24 的指针，也就是指向的地址，怎么看&lt;/p>
&lt;p>Ida 中按 g 输入 0x1EB24，回车&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAH3WLgG9zbRtxfZwbDkhTgglrp6GicRvXiajwZz6nSIXRV3Hh8ObXYBiaog/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>双击 ccRC4Callouts&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAHiaiaXwyVxYfyPkianZKAMLiapjv1rVbF6rm6xP1KTJlb00iaJAYmO4xMCdA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>0x1EC3C 就是 0x1EB24 的指针&lt;/p>
&lt;p>所以 R8 = 0x1EC3C&lt;/p>
&lt;p>最后 R4 = [R8+0x4] = [0x1EC3C+4] = [0x1EC40]&lt;/p>
&lt;p>[0x1EC40] 表示取 0x1EC40 的指针，就是 0x4E89&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAHzsyynEYWxdP5ibQ7eJIwhz6PgP3PR73GjkxIpuUapT2QgHiaE1OcSSXQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>第二种获取 R4 地址得方法很简单&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIj4nZUQ8htC2icoKPzysfWHUnqzMVMSiavMWueHAZ9LO1MCJ3kwlxdvrA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>hook 0x4304&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x4304);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWINvsgACiclz64F7KfgaEsRhz4J9XGJJzwibOAcXTMic3TW5mH70OxLcFibQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>笑死，直接就出来了，还静态分析个毛&lt;/p>
&lt;p>所以 BLX R4 最终等价于 BLX 0x4E89&lt;/p>
&lt;p>ida 中按 g 输入 0x4E89 跳转，也可以双击 sub_4E88&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6j2r8xlLLamev2aSYplQAHdicYKANK8auPia4lxBG80u95hRR6VykM329Z9icL2sgAaooSTsRkiauu3Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>咦，显而易见这是 rc4 算法初始化密钥的函数&lt;/p>
&lt;p>Hook 这个函数就能拿到 rc4 的密钥&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIJc2I6FjBcWHdW4DYv0L6jVricXwWCG7BibxUzqX6nsA2pkUibkFHTS6icw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>打个断点&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0xC244);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWI8rIqXibJZ4oDJ1Ctd40NGySPjaenU86VUziaS1PUORpNVCblbOEuq4vA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>查看 r2 的值&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIiadPh4NUmKC5CKGf7QCic6Az2jDXnOQxDlKPuGlGzShY1jOibwMeoTyrQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>密钥是：f4c7fc5d61bdff1914c383b340958ef1&lt;/p>
&lt;p>没毛病吧！就是上面说的 V9&lt;/p>
&lt;p>然后最终加密的函数呢？&lt;/p>
&lt;p>回到 CCCrypt 函数&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIibnoBdVtAFZhziaxBiaaaVKPzvQLV8X0yHy6gT65dbAec26ibS5ttxCEqw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>v12 = (*(*(v21 + 16) + 12))(v21 + 20);
&lt;/code>&lt;/pre>&lt;p>有经验了，这一行一看跟上面差不多嘛，看看汇编&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIZU7YQaibDCBNWF1HFeO7C0uqZTAuFoCQNkTr8P3fI4o0d2zmpuB1Stg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>BLX R4&lt;/p>
&lt;p>R4 地址又是算出来的，直接用 unidbg hook 拿到地址&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x453A);
&lt;/code>&lt;/pre>&lt;p>运行&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWInU9QhOmP3e7g3JoDB8WB2OF1Wv33a8tp99VzgrW2oL5Um2tCYCxh3Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>BLX R4 等价于 BLX 0x4ea5 &lt;/p>
&lt;p>ida 中按 g 输入 0x4ea5  跳转&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIaaJ3iaT1a3vVIKPnLhVOibMnbmCMmlocibc05h4JKble1bZfl1OVGeYNg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFWdgIeHCd7j1zZ6fotroN4VECNrEdW4bo0Nicca7kZlMmHvyYib3ZCZTw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>二话不说 hook 这个函数&lt;/p>
&lt;pre tabindex="0">&lt;code> public void hook_CC_RC4(){
//rc4密钥
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0xBEC8 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer arg0 = ctx.getPointerArg(3);
int arg1 = ctx.getIntArg(1);
Pointer arg2 = ctx.getPointerArg(2);
System.out.println(&amp;#34;arg1:&amp;#34;+arg1);
System.out.println(&amp;#34;arg2:&amp;#34;+arg2.getString(0));
ctx.push(arg0);
ctx.push(arg1);
            };
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
int length=ctx.pop();
// System.out.println(length);
Pointer output = ctx.pop();
byte[] outputhex = output.getByteArray(0, length);
Inspector.inspect(outputhex, &amp;#34;CC_RC4 ret&amp;#34;);
}
});
        hookZz.disable_arm_arm64_b_branch();
}
&lt;/code>&lt;/pre>&lt;p>hook 结果：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIBNVtvI6I0NEOicMqbhAEFiaic0P4NJ9qep1OatsGGceXuSCoxnB56c0ng/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看来前面猜的都没错嘛,&lt;/p>
&lt;p>现在就用逆向之友看看这个 rc4 是不是标准的 rc4 了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWICAOibwcFYaB36C8tyCOp5vPBDTqkw2Zx2A43AZrRX2De6jV4r2jOVNA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>没毛病&lt;/p>
&lt;p>现在明文知道了，也就是 bodyencrypt 的 第五个参数，&lt;/p>
&lt;p>加密方式也知道了，对称算法 rc4&lt;/p>
&lt;p>最后就要解决密钥是怎么生成的&lt;/p>
&lt;p>&lt;strong>rc4 key&lt;/strong>&lt;/p>
&lt;p>回到 tj_crypt，LABEL_17&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWINIxPfMmcPs9uBZgIjC2WVa80u5E2NsLqK5DEG2ZQ81QwosYyp5GJNw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>显而易见！&lt;/p>
&lt;p>我们要进入 sub_302 的身体里去探索&lt;/p>
&lt;pre tabindex="0">&lt;code>char *__fastcall sub_302C(int a1, int a2, int a3, int a4)
{
int v4; // r8
char *result; // r0
int v6; // r4
int v7; // r9
char *v8; // r6
v4 = a1;
result = 0;
if ( a2 )
{
v6 = a4;
if ( a4 )
{
v7 = a3;
v8 = malloc(0x15u);
result = 0;
*(v8 + 13) = 0;
*v8 = 0LL;
*(v8 + 1) = 0LL;
*(v8 + 17) = 0;
if ( v8 )
{
j_CCHmac(0, v7, v6, v4);
sub_33E4(v8, 20);
result = v8;
}
}
}
return result;
}
&lt;/code>&lt;/pre>&lt;p>先 hook 一下，看看参数和结果&lt;/p>
&lt;pre tabindex="0">&lt;code> public void hook_sub_302C(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x302C + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer arg0 = ctx.getPointerArg(0);
int arg1 = ctx.getIntArg(1);
int arg3 = ctx.getIntArg(3);
Pointer arg2 = ctx.getPointerArg(2);
System.out.println(&amp;#34;arg0:&amp;#34;+arg0.getString(0));
System.out.println(&amp;#34;arg1:&amp;#34;+arg1);
System.out.println(&amp;#34;arg2:&amp;#34;+arg2.getString(0));
System.out.println(&amp;#34;arg3:&amp;#34;+arg3);
};
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer output = ctx.getR0Pointer();
byte[] outputhex = output.getByteArray(0, 128);
Inspector.inspect(outputhex, &amp;#34;sub_302C ret&amp;#34;);
}
});
hookZz.disable_arm_arm64_b_branch();
}
&lt;/code>&lt;/pre>&lt;p>显而易见是个 hmac 哈希编码&lt;/p>
&lt;p>hook 结果：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAF0c21kFm3IJ5TQ7LM9wpj0U2Kz3uJeHTXWCE6N53SqFNicUABN9Yu8LQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>arg0 是明文，可以发现是由 arg2_str+arg1 拼接而来&lt;/p>
&lt;p>哪个函数拼接的？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFA7CX5jKTeRIGhkcXC6XdUkb07qJBMmkTPjRnDeficPTN4siahAoYLdsA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFVEeRgTzNJVicv8zuq2I3yliby7TIZPic6yIS1JHh14MQvKHicRh4W0d4eg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFwjsmdJpO4DxKthicibAQZDpjGqeHNnxIcWQdnrQmdcuvvyDhTjUEQ4QQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>arg2 是密钥，结果是长度 20 个字节（00 00 00 00 是结束标志），可以盲猜是 hmacsha1，然后去逆向之友看看是不是 hmacsha1&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWI6skLQEicEscQJcLfUtsOfiadayLuTBW0YN10oSokFPfGxatQfXm1bl5A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>咦，不对呢，但是可以发现 hmacsha1 的结果出现在这里&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWI595uBNN3TOW4fYKE0Vm5sCyCl1Vhsa9R9ibdiaKGibTyaDkvb5kd2MdDQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>j_CCHmac 下面还有个 sub_33E4(v8, 20)&lt;/p>
&lt;p>应该是 sub_33E4 搞得鬼&lt;/p>
&lt;p>hook hook 看&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIXqpRnJT9QvYug0ylfx221mkHa0ibLOXU9Nlf5Gb3GZdFcfNHk31dE5g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这次没错了&lt;/p>
&lt;p>如果猜不出是 hmacsha1，那就进入 j_CCHmac、CCHmac&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall CCHmac(int a1, int a2, int a3, int a4, int a5, int a6)
{
int v6; // r11
int v7; // r4
char v9; // [sp+4h] [bp-194h]
int v10; // [sp+Ch] [bp-18Ch]
void (__fastcall *v11)(int *, int, int); // [sp+160h] [bp-38h]
int v12; // [sp+184h] [bp-14h]
int v13; // [sp+188h] [bp-10h]
v13 = v6;
v7 = a4;
j_CCHmacInit(&amp;amp;v9, a1, a2, a3);
v11(&amp;amp;v10, v7, a5);
j_CCHmacFinal(&amp;amp;v9, a6);
return _stack_chk_guard - v12;
}
&lt;/code>&lt;/pre>&lt;p>显而易见，又是个 init、update、Final 流程，在中卷已经说了，忘了的回去看看&lt;/p>
&lt;p>进入 j_CCHmacInit、CCHmacInit&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIgnHqqHv9H8C5hb8xWP3LynDicrNkzNn1iabzibibxLXcqs7YsGeYWDWJzQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看到有个控制流，根据 a2 的值来决定走哪个分支&lt;/p>
&lt;p>这里 a2 是 0&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIAU615QtliaVOLECuN8gUX8zpvFVWEUWh7NicEHb5dSQM30F94bCOh6mQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以进到这里&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIsfSibOcw7dfexkWNKiae829B5nSlXZe7lztic3Z4v93u3g0NvlE8npJibA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到初始化常量&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIJ56hG6Y0gUgKfFM6zciam7kjc3WTia2hyT2adFzy0OvUicW1P9PK3A8OQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>回到上面&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIAXdlXwGAwMh8IqtMMOkoj1EH6hvvuibywp4KUZsBnibKNhCuaRhZJAaw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里的 v11 又是动态跳转，要看的自己 hook 下，不在细说&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWI7mZkpYQ5pstYNyuWDw9MgRTrQETfVdb57c4D0JVlviatfprluJS3ib1w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>再回到上面，解决这个函数&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6TasXnTSrq21cYUkEIRGWIyGicV25ZgUMPmfrqRerMPBxvrz9gQudLKjykfMNpLFiaR8XicQ4cCGkaQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>进入 sub_33E4 函数&lt;/p>
&lt;pre tabindex="0">&lt;code>const char *__fastcall sub_33E4(const char *result, unsigned int a2)
{
unsigned int v2; // r6
const char *v3; // r9
_BYTE *v4; // r4
int v5; // r2
int v6; // r3
signed int v7; // r2
const char *v8; // r0
const char *v9; // r1
int v10; // r3
char v11; // t1
char v12; // t1
int v13; // r2
_BYTE *v14; // r0
int v15; // r1
_BYTE *v16; // r3
char v17; // r5
if ( a2 &amp;gt;= 2 )
{
v2 = a2;
v3 = result;
result = strlen(result);
if ( result &amp;gt;= v2 )
{
v4 = malloc(v2 + 1);
_aeabi_memclr(v4, v2 + 1, v5, v6);
v7 = 1;
v8 = &amp;amp;v3[v2 - 1];
v9 = v3;
while ( 1 )
{
v10 = &amp;amp;v4[v7];
if ( v9 &amp;gt;= v8 )
break;
v11 = *v9++;
*(v10 - 1) = v11;
v12 = *v8--;
v4[v7] = v12;
v7 += 2;
}
if ( v8 == v9 )
*(v10 - 1) = *v9;
v13 = v2 - 1;
v14 = v3 + 1;
v15 = 0;
while ( 1 )
{
v16 = &amp;amp;v4[v15];
if ( &amp;amp;v4[v15] &amp;gt;= &amp;amp;v4[v13] )
break;
v17 = v4[v13--];
*(v14 - 1) = v17;
++v15;
*v14 = *v16;
v14 += 2;
}
if ( v13 == v15 )
*(v14 - 1) = v4[v15];
result = j_free(v4);
}
}
return result;
}
&lt;/code>&lt;/pre>&lt;p>就是对 hmacsha1 编码后的 byte 移位&lt;/p>
&lt;p>看着 ida 反编译的伪代码不好翻译，可以伪代码为主，汇编为辅助去还原；&lt;/p>
&lt;p>也可以汇编为主，伪代码和 unidbg 动态调试为辅助去还原；&lt;/p>
&lt;p>都不会的还有个更简单的，只需要多搞几组数据对比下，找出规律自己实现就行了；&lt;/p>
&lt;p>放出伪代码为主，汇编辅助的代码&lt;/p>
&lt;pre tabindex="0">&lt;code>import hashlib
import hmac
from hexdump import hexdump
def CCHmac(key:str,input_str:str)-&amp;gt;bytes:
hmacsha1_ret = hmac.new(key.encode(), input_str.encode(), hashlib.sha1).digest()
return hmacsha1_ret
def sub_33E4(hmacsha1_ret:bytes,size=20)-&amp;gt;bytes:
v4 = [0 for i in range(size)]
v5 = 1
v6 = size
v7 = 0
while (1):
if (v7 &amp;gt;= v6):
break
v9 = hmacsha1_ret[v7]
v7 += 1
v4[v5 - 1] = v9
v6 -= 1
v10 = v6
v4[v5] = hmacsha1_ret[v10]
v5 += 2
if v6 == v7:
hmacsha1_ret = v4
v11 = size
v13 = 0
v12 = 1
v4 = [0 for i in range(size)]
while (1):
if (v13 &amp;gt;= v11):
break
v11 -= 1
v10 = v11
v4[v12 - 1] = hmacsha1_ret[v10]
v9 = hmacsha1_ret[v13]
v13 += 1
v4[v12] = v9
        v12 += 2
return bytes(v4)[:16]
if __name__ == &amp;#39;__main__&amp;#39;:
input_str = &amp;#34;YM0A2TMAIEWA3xMAMM1xTjQEUYGD0wZAYAh32AdgQATDzAZNZA33WAEIZAzzhAMMNAzyTDAkZMzTizYOYN11TTgMRcDThyNMZO44GTIAVQGDi5OONN2wWGMMUVWj1iMNOYxxGmUU1630808396&amp;#34;
Hmackey = &amp;#34;dGp******dG8K&amp;#34;
v9 = CCHmac(Hmackey,input_str)
key = sub_33E4(v9,20)
    hexdump(key)
&lt;/code>&lt;/pre>&lt;p> rc4 自己写&lt;/p>
&lt;p>&lt;strong>加密模式 2&lt;/strong>&lt;/p>
&lt;p>&lt;strong>其实后面两种加密模式流程都差不多，简单说一下吧。。文章已经太长了&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAF483jRbCkDwI6Kr6LrCltWjIjdbXP5Q9RRbsDibRrNDo0RFm0Ou33rgg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里改成 2&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFUviaZp1wVJ1EUPMWJAssrGgbwribKbbqNcDrM821DDJNfwfkHOxkUpeA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后根据上面模式 1 分析的可以知道这个 v25 就是 R5（就忘了？划上去看）&lt;/p>
&lt;p>R5=v25=v17=0&lt;/p>
&lt;p>R8, [R0,R5,LSL#2]&lt;/p>
&lt;p>即：R8=[R0+(0&amp;laquo;2)]=[0x1EB14]&lt;/p>
&lt;p>同理可得 0x1EB14 的指针是 0x1EB2C&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFKRHTicjeGdLAlItMB4EjVA5wtPkeJNPP5rxGBdoOvAWMmtgf1Hnt8hw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>R4=[R8+4]&lt;/p>
&lt;p>最后 R4=[R8+0x4]=[0x1EB2C+4] = [0x1EB30]&lt;/p>
&lt;p>[0x1EB30] 表示取 0x1EB30 的指针，就是 0x4829&lt;/p>
&lt;p>不信的话用 unidbg 打个断点&lt;/p>
&lt;p>还是这个地方&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFdObEqtXsf9icow6BW3WicIkVAicLz3c5pae1pSEbe8ic3V9KV4MHBEgZEw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x4304);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFKzniakxtVKtDd4qSR5JSe6eSw0IQ4cHBibVuNyW01PDdrYfjib9Opicc5Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>废话不多说，直接 g 0x4829 跳过去&lt;/p>
&lt;pre tabindex="0">&lt;code>signed int __fastcall sub_4828(int a1, int a2, int a3, char a4, int a5, unsigned int a6, int a7)
{
int v7; // r5
char v8; // r8
int v9; // r6
char *v10; // r0
signed int v11; // r4
int *v12; // r6
char v13; // r3
int v14; // r12
v7 = a1;
v8 = a4;
v9 = a2;
v10 = sub_4DE0(a3);
v11 = -4300;
if ( a5 &amp;amp;&amp;amp; v10 &amp;amp;&amp;amp; *((_DWORD *)v10 + 2) &amp;lt;= a6 &amp;amp;&amp;amp; *((_DWORD *)v10 + 3) &amp;gt;= a6 )
{
*(_DWORD *)v7 = v10;
if ( v9 == 1 )
{
v12 = (int *)(v10 + 40);
*(_DWORD *)(v7 + 4) = *((_DWORD *)v10 + 8);
v13 = 0;
}
else
{
if ( v9 )
return v11;
v12 = (int *)(v10 + 36);
*(_DWORD *)(v7 + 4) = *((_DWORD *)v10 + 7);
v13 = 1;
}
v14 = *v12;
*(_BYTE *)(v7 + 49) = v8 &amp;amp; 1;
*(_BYTE *)(v7 + 48) = v13;
*(_DWORD *)(v7 + 8) = v14;
if ( v8 &amp;amp; 2 )
{
*(_WORD *)(v7 + 50) = 0;
}
else
{
*(_BYTE *)(v7 + 50) = 1;
if ( v10[16] )
*(_BYTE *)(v7 + 51) = 0;
else
*(_BYTE *)(v7 + 51) = 1;
}
*(_DWORD *)(v7 + 28) = 0;
if ( !(*((int (__fastcall **)(int))v10 + 5))(v7 + 52) )
{
if ( *(_BYTE *)(v7 + 50) )
sub_4E0C((unsigned __int8 *)v7, (int *)a7);
v11 = 0;
}
}
return v11;
}
&lt;/code>&lt;/pre>&lt;p>这函数里只有 sub_4DE0 跟 sub_4E0C 两个函数，sub_4DE0 很短没什么信息&lt;/p>
&lt;p>那肯定就再 sub_4E0C 函数里了&lt;/p>
&lt;p>进去&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall sub_4E0C(unsigned __int8 *a1, int *a2)
{
int *v2; // r3
JNIEnv *v3; // r2
int v4; // r1
int v5; // r2
int v7; // [sp+0h] [bp-30h]
__int64 v8; // [sp+8h] [bp-28h]
__int64 v9; // [sp+10h] [bp-20h]
__int64 v10; // [sp+18h] [bp-18h]
int v11; // [sp+24h] [bp-Ch]
v2 = a2;
v3 = *a1;
if ( *(*a1 + 16) )
{
if ( !a2 )
{
v2 = &amp;amp;v7;
*&amp;amp;v7 = 0LL;
v8 = 0LL;
v9 = 0LL;
v10 = 0LL;
}
(v3[6])(a1 + 52, a1[48], v2);
}
else
{
v4 = (a1 + 12);
if ( !a1[48] )
v4 = (a1 + 32);
v5 = *(v3 + 4);
if ( v2 )
_aeabi_memmove(v4, v2, v5);
else
_aeabi_memclr(v4, v5, v5, 0);
}
return _stack_chk_guard - v11;
}
&lt;/code>&lt;/pre>&lt;p>(v3[6])(a1 + 52, a1[48], v2);&lt;/p>
&lt;p>这一行很熟悉了吧，看汇编&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFqa9cUCWia9oCwLdYjvA5tcgebE2cjV4FpVyO2UtEiaZzOW6d4hKu0rtg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>直接 hook，静态分析个毛，早 hook 早发表&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x4E40);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFQdE78wCiaIicaduGMzbDo42SRIqaBXTvia8sPWibJiczNN8o6Mib3ey81RIw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>g 0x11a51&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFMOupiaLXRRLXRadsMyoWBZhzdiberfgUeqgFic2JNzicwT3uHpVOPHxbOw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>显而易见，这是 aes 算法，设置 iv 的地方&lt;/p>
&lt;p>hook&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAF8rOl0Gw48PR2XTiaC2hlfrrO7TXDsbhsoYtr8QmTicJSVDPHUd3zU9Ew/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x11A50);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFyFGbgFFfYYLAMDAHgNdqK8ibuIXrHpdMMsNdHPxNiaY96icx2OFRUlKRg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>打印 iv&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFRG1RwPKr38Ktq3u4SltaZZ4jUChypAgLaVicfQmZ8D4m7Vzfw88by6Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>那 aes 的 key 是哪里初始化的？一般是先初始化 key 再 iv，前面是不是漏掉了什么关键的地方? 回去看看&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFQ6rLySzo59RmEZibHibLreQn0xZg1MCFaEWjQ8giciakpialuoPPOUXQMEg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>噢这里还有这 BLX&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFdRaqiaRV1DPW93MhanCu0VeeeIK6CuYskq6IEBHSyLiclv1kA82Uv69w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>hook 之&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFAtueKZ16fKAibseL85b2jHzgco1L73EBV2h1xUa88KtEZa3KUDnibNYg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>ida g 0x119e9&lt;/p>
&lt;p>unidbg b 0x119e9 &lt;/p>
&lt;p>c&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFLgCCicUWgx8NAFWzmhc9tAvZyh8L0yKLuzribnM8cRJiaSDz1bqdQiawZw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFy0jfHOobB6LNMP689mQZK9wXHNX7Zt8tDBPKq54XQVRW73xSniaIVJw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>进去&lt;/p>
&lt;p>hook 之&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAF0icOM8bUgNUACodPD8rcRmMgrjToxsAprlrkQ56jriciaC6SvcnYfYykQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>b0xE398 &lt;/p>
&lt;p>c&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFx2Wd9qzWbeuHFtBcibG5vQ7ibT945mBiasWVHPibVKicibI2Lz2hWBc38ePQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>打印 r0&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFXnlH0YJXVVuowFgczhb6F71wC3mYWhPdDsQFLZjh0t4Vdq5m0gtq7Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到这个 key 跟 rc4 的 key 是一样的&lt;/p>
&lt;pre tabindex="0">&lt;code>加密方式:aes_cbc
明文:{&amp;#34;code&amp;#34;:null,&amp;#34;parameter&amp;#34;:{&amp;#34;activityTask&amp;#34;:{},&amp;#34;defa
aes_key:f4c7fc5d61bdff1914c383b340958ef1
aes_iv:00000000000000000000000000000000
&lt;/code>&lt;/pre>&lt;p>逆向之友验证&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFPy5VAknia6kDibVyrYRCw8b1NwqBCva0ib2xIyyUD4qF6EFooPkdLcG3A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>没毛病&lt;/p>
&lt;p>还想知道 aes_encrypt 在哪的&lt;/p>
&lt;p>hook 这里&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFCqw8zIzbZYRGRZtVcicbFc9ib7yb7tOZFYuTJqnzLOT23ojtK4fTEcibA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>拿到 R4 地址&lt;/p>
&lt;p>再 hook 这里 &lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFVXmV3hUvTia9fT50qkiaBLFkHYlxeCyHXzVUhkx4AbnZ2rXC3PupfEPg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>拿到 R5 地址&lt;/p>
&lt;p>就是了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFm7LhibqcZhZgjuia37P9jwZFESye2PoDAXrccPb0MAOolxRFW74ZNUzA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>加密模式 3&lt;/strong>&lt;/p>
&lt;p>&lt;strong>跟模式 2 一样是 aes_cbc, 只是 iv 不一样，所以只说 iv 的生成&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFWdj4PYsP4jK5yrODlN4Btficia24K3wicMI8gu1rOMKOjkFicLDN4q50pA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>改成 3&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFT5SEPYbUuXYf9OvHWiajCaKMaf3Kl2YYHefdlicQ1rptboJIe3fRWl5g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看样子就是比模式二多走了一个 sub_302c，&lt;/p>
&lt;pre tabindex="0">&lt;code>public void hook_sub_302C(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x302C + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer arg0 = ctx.getPointerArg(0);
int arg1 = ctx.getIntArg(1);
int arg3 = ctx.getIntArg(3);
Pointer arg2 = ctx.getPointerArg(2);
System.out.println(&amp;#34;arg0:&amp;#34;+arg0.getString(0));
System.out.println(&amp;#34;arg1:&amp;#34;+arg1);
System.out.println(&amp;#34;arg2:&amp;#34;+arg2.getString(0));
System.out.println(&amp;#34;arg3:&amp;#34;+arg3);
};
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer output = ctx.getR0Pointer();
byte[] outputhex = output.getByteArray(0, 128);
Inspector.inspect(outputhex, &amp;#34;sub_302C ret&amp;#34;);
}
});
hookZz.disable_arm_arm64_b_branch();
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFiaTVWJyps8q6gbMmdnk6bTicGVs3doauo8gqg7Eo6IfhCpnCaPSu8wQQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后后边的流程就跟模式二就没区别了，就不说了&lt;/p>
&lt;p>hook aes_cc_set_iv&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x11A50);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFUV3efpPAwLZZibDoDnlwraj0o6Kia9a6MZDEVCwicAEaAoAtGJHk1ibXGA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFISIPad3msBcucwHTDU6lQdnhmhUlIicvuyuQlLGs9AFGzY3Hb4o9o0Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到这个 iv 就是第一次 sub_302c 生成的值&lt;/p>
&lt;p>这个 iv 和 key 的生成方式都是一样的，只是明文少了个时间戳而已&lt;/p>
&lt;pre tabindex="0">&lt;code>加密方式:aes_cbc
明文:{&amp;#34;code&amp;#34;:null,&amp;#34;parameter&amp;#34;:{&amp;#34;activityTask&amp;#34;:{},&amp;#34;defa
aes_key:f4c7fc5d61bdff1914c383b340958ef1
aes_iv:7b53e03485ddbbcf07bd9698718abc8a
&lt;/code>&lt;/pre>&lt;p>逆向之友验证&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFJmY27BCqict3TuRMbtiac1EwaKq3wFrrsRU0A9I6qp1dDaVvDtgGXpHQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这些都是标准的算法，遇到魔改算法的时候，就需要对算法的原理非常熟悉了，这时就需要看这个男人的密码学专栏
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFq4QzFib1kyspVcM3vKMgBeMpibmicPOGMznxribZZvM63aGs71P9g24Qvw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFb6P5cAm09YK4FXXmeQsdoK5kFtUQibrEnKJgPBwPtoia6OTlnUYy6s3g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAFMbJr6icmbiallGwbX4rjWuLJeBPSyug2vxIpL0YzULgmH3GlLbVnfSNA/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>&lt;strong>完结！&lt;/strong>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>饮茶去了&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH6Tsm0MiceegNzEQmZCyXVAF3ctIAJQuhYibVRPyjnmTiclzkxEPr8HMgL3kTnM8TgK3tJibF2X6SB6qA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>unidbg 算法还原术 · 某民宿 app 篇 · 中卷</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%AD%E5%8D%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%AD%E5%8D%B7/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA5NDE1OQ==&amp;amp;mid=2247485004&amp;amp;idx=1&amp;amp;sn=069bc22bc51804156ae4195d85cc83fc&amp;amp;chksm=9f8bb76ca8fc3e7ac35ead494f6365f5d34d7b4775e627b5b3aa339b275f62d7e690873f7e96&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=10131nsND0h4vAvW6oFb8k7g&amp;amp;sharer_sharetime=1634055434006&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>上回说到 EncodeHTTP 函数&lt;/p>
&lt;p>伪代码又臭又长，看不懂没关系，从下往上看；找关键的函数；&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy3HYOh1bIyDDFvNq4dWRWpVPD0xvE5geBD8rtzcW6T6zK4XTJTAQJDGg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而且之前猜测是 sha1 算法，那我们找找 sha1 的特征；&lt;/p>
&lt;p>伪代码虽然很长，但是函数还是没几个的，都点进去看看&lt;/p>
&lt;p>tjtxtutf8 看上去很像 base64，后边验证&lt;/p>
&lt;p>tjcreate 函数里面有点东西&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH7Gwg06nY3t8zv0Pz9icqpy33wDQAenUUrtM4s3U8pGkamNQCXPHKHoqu9oKeeawbgbfJk4Qo75t0Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有个 sha1 的特征，为什么？&lt;/p>
&lt;p>哈希算法最明显的特征就是初始化链接常量 (幻数) 和固定常数 K 值&lt;/p>
&lt;p>&lt;strong>初始化链接常量 (幻数)&lt;/strong>&lt;/p>
&lt;p>md5 算法有 4 个初始化链接常量&lt;/p>
&lt;pre tabindex="0">&lt;code>A=0x01234567，B=0x89abcdef，C=0xfedcba98，D=0x76543210
&lt;/code>&lt;/pre>&lt;p>但考虑到内存数据存储大小端的问题我们将其赋值为：&lt;/p>
&lt;pre tabindex="0">&lt;code>A=0x67452301，B=0xefcdab89，C=0x98badcfe，D=0x10325476
&lt;/code>&lt;/pre>&lt;p>sha1 是 md5 的亲兄弟，比 md5 多了一个初始化链接常量;&lt;/p>
&lt;pre tabindex="0">&lt;code>A=0x67452301，B=0xefcdab89，C=0x98badcfe，D=0x10325476，E=0xCA62C1D6
&lt;/code>&lt;/pre>&lt;p>&lt;strong>k 值&lt;/strong>&lt;/p>
&lt;p>md5 k 值取值 （64 个，对应 64 步运算）&lt;/p>
&lt;pre tabindex="0">&lt;code>constTable=[
0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf,
0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af,
0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
0xd62f105d, 0x2441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6,
0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8,
0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,
0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039,
0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97,
0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391]
&lt;/code>&lt;/pre>&lt;p>sha1 k 值取值（4 个 k 值，每个 k 值对应 20 步运算）&lt;/p>
&lt;pre tabindex="0">&lt;code>第1轮 0≤t≤19步  Kt=0x5A827999 
第2轮 20≤t≤39步 Kt=0x6ED9EBA1
第3轮 40≤t≤59步 Kt=0x8F188CDC  
第4轮 60≤t≤7步  Kt=0xCA62C1D6 
&lt;/code>&lt;/pre>&lt;p>回到 ida&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH42GylcEhBjdBbp7pLyu7kLfOW5HtibXLPLiaxWx5Ls4Qr8zIqbpEwq3ibXQed08ZG2PjNDdZ51RgsMA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个 0xCA62C1D6 就是 sha1 的 k 值之一，所以说这个函数有 sha1 的特征&lt;/p>
&lt;p>而在工程标准化中，哈希加密一般分为 Init、Update、Final 三步&lt;/p>
&lt;p>简单来说：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Init 是一个初始化函数，初始化核心变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Update 是主计算过程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Final 整理和填写输出结果&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>tjcreate 函数可以看作是第一步的 Init; 但是其他四个常量哪去了呢？&lt;/p>
&lt;p>看汇编就知道了 (这些汇编划到最下面有解释)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH42GylcEhBjdBbp7pLyu7kLIny2iaicBhWdI77HNkia94awdgFmLUqb2J1gYSC00tRXQgyRDTl03hwBQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为啥还是少了一个幻数&lt;/p>
&lt;p>因为 ida 把 2C70 识别成函数了，我们手动修改它的数据类型&lt;/p>
&lt;p>鼠标移到 sub_2C70 处，按 d&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH42GylcEhBjdBbp7pLyu7kLEolSjsvklEPujaiaqAxWfpgibQeSgf7BTfIicfzicHJaEhNIUg8NXwqatQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>再按 d 转成 word&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH42GylcEhBjdBbp7pLyu7kLSLKcibRY7RwDS1nb8tVEd34HE7V5yibzrnD0vqXMOYZOaDJ7yEdTRteA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>再按 d 转成 dword&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH42GylcEhBjdBbp7pLyu7kLMsoBqjS1iavTX851aptIlyywfSLDBJJG5EovyjPkOqJoUJOicNSHlbjg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后找下面的 Update 和 Final&lt;/p>
&lt;p>tjreset 函数可以看作是第二步的 Update&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall tjreset(signed __int64 a1, int a2)
{
int v2; // r4
_BYTE *v3; // r5
int v4; // r6
v2 = a2;
v3 = (_BYTE *)HIDWORD(a1);
v4 = a1;
while ( v2 )
{
*(_BYTE *)(v4 + *(_DWORD *)(v4 + 64)) = *v3;
*(_BYTE *)(v4 + *(_DWORD *)(v4 + 64)) ^= 0x21u;
LODWORD(a1) = *(_DWORD *)(v4 + 64) + 1;
*(_DWORD *)(v4 + 64) = a1;
if ( (_DWORD)a1 == 64 )
{
j_tjupdate(v4, v4);
*(_DWORD *)(v4 + 64) = 0;
a1 = *(_QWORD *)(v4 + 72) + 512LL;
*(_QWORD *)(v4 + 72) = a1;
}
++v3;
--v2;
}
return a1;
}
&lt;/code>&lt;/pre>&lt;p>一般来说只要 hook 这个函数，拿到入参，就能拿到明文&lt;/p>
&lt;p>我们先用 frida 来试试，&lt;/p>
&lt;pre tabindex="0">&lt;code>function myhexdump(name, hexdump_obj, len_obj){
console.log(&amp;#34;-------------------&amp;#34;+ name.toString()+&amp;#34;-------------------\\n&amp;#34;);
console.log(hexdump(hexdump_obj,{
length:len_obj
}) );
console.log(&amp;#34;-------------------ENDEND-------------------\\n&amp;#34;)
}
function tjreset() {
      var pointer = Module.findBaseAddress(&amp;#34;libtujia_encrypt.so&amp;#34;).add(0x2C94 + 1);
Interceptor.attach(pointer,
{
onEnter: function (args) {
myhexdump(&amp;#34;tjreset arg0:&amp;#34;, args[0], 128)
this.buffer = args[0];
myhexdump(&amp;#39;tjreset arg1:&amp;#39;, args[1], parseInt(args[2]))
console.log(&amp;#39;tjreset arg2:&amp;#39; + parseInt(args[2]));
},
onLeave: function (retval) {
myhexdump(&amp;#34;tjreset ret:&amp;#34;, this.buffer, 16)
}
}
);
}
&lt;/code>&lt;/pre>&lt;p>注意：这里 ida 识别函数参数个数错了，实际应该是三个参数，看汇编就知道了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IVdrFxIibnRdm38WZ8U6ib6YQbwYkCfDoBhLxKibVC5OGmGRmSGs7GkrUA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>R0、R1、R2 分别对应参数 1、2、3&lt;/p>
&lt;p>开始 hook&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IuVm1cciaibUpqbVqop3URGmqVpFicnibkwrHE9B6ic89PK3o15PuI657kNg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>unidbg hook:&lt;/p>
&lt;pre tabindex="0">&lt;code>public void hook2c94(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x2C94 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer arg1 = ctx.getPointerArg(1);
int length = ctx.getIntArg(2);
Pointer out = ctx.getPointerArg(0);
ctx.push(out);
ctx.push(length);
                Inspector.inspect(arg1.getByteArray(0, length),&amp;#34;tjreset arg1&amp;#34;);
            };
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
int length =ctx.pop();
Pointer output = ctx.pop();
byte[] outputhex = output.getByteArray(0, length);
Inspector.inspect(outputhex, &amp;#34;tjreset ret&amp;#34;);
}
});
        hookZz.disable_arm_arm64_b_branch();
}
public static void main(String[] args) throws FileNotFoundException {
Test test = new Test();
    test.hook2c94();//要在函数调用之前hook，不然hook个p
test.call_encrypt();
// test.get_bodyencrypt();
}
&lt;/code>&lt;/pre>&lt;p>unidbg 的输出跟 frida 是一样的：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IOC3yZyyDLWemsoNPiaktB6bQHtB1qo9xJ6ib967ZjNXLWdVGF7UgWApA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一般情况来说 tjreset arg1 的值就是明文&lt;/p>
&lt;p>打开逆向之友，去碰碰运气&lt;/p>
&lt;pre tabindex="0">&lt;code>https://gchq.github.io/CyberChef/
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8Ie9CdD076acjSwMEhpL1Se8mBVgTLl9p5KsUaBwHR10nyr0uESHich2A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>结果对不上，难道 sha1 魔改了？？&lt;/p>
&lt;p>莫急，冷静分析，再看下伪代码，和标准的有没有啥区别&lt;/p>
&lt;p>发现 13 行有个异或不对劲，标准算法没这一步&lt;/p>
&lt;pre tabindex="0">&lt;code>*(_BYTE *)(v4 + *(_DWORD *)(v4 + 64)) ^= 0x21u;
&lt;/code>&lt;/pre>&lt;p>这是把 tjreset arg1 先异或了 0x21 再进行下面的计算&lt;/p>
&lt;p>那我们再用 CyberChef 试试&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8ImaC0IdKnKH2ceVoAHptfZ9ltROoUVSSw4upQeicPRHqd8iaInK8MmibtA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH7AOnSA7XXltmdUNPcicEzTQXhtLXzpMia52PAPiaP3UicE9Vr7yNY3YG8mAaZHaYALibQRXIvCdBIroxA/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看看明文是啥呢&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IGiacbRnfXHAaWJ8tT8kmLSzD56W9HjqenKGTsfI1AWCaD4XXnGF0hHA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看着是 base64 编码，结合之前猜测 tjtxtutf8 就是 base64，那就解码看看吧&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8I0VSMTTuA0LefqB6RAEOfC9rZzfNFbUHKa4OqWPj9HsCicwicLmcL75gw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>哦？明文出来了，茅塞顿开&lt;/p>
&lt;p>所以这个明文组成就是：&lt;/p>
&lt;p>1.#arg1_str#arg5# 固定字符串 #arg2_str#arg3_str 的字符串排序&lt;/p>
&lt;ol start="2">
&lt;li>字符串反转&lt;/li>
&lt;/ol>
&lt;p>3.base64 编码&lt;/p>
&lt;p>不过&lt;/p>
&lt;p>有人说了，我就是看不出这有个异或 0x21，你就说咋办吧。。而且这样逆向出来明文好像是靠蒙的，没有成就感啊&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IGWMByiaXezfYkCuoB1aDwU9rrnrU54NcKCNSdiaHHHygKGp6wbwib6KPg/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>行，再露一手&lt;/p>
&lt;p>来看看 18 行的 j_tjupdate 函数&lt;/p>
&lt;pre tabindex="0">&lt;code>int __fastcall tjupdate(int a1, int a2)
{
int i; // r3
int v3; // r1
char *v4; // r5
int v5; // r2
int v6; // r3
int v7; // r5
int v8; // r10
int v9; // r1
int v10; // r6
int v11; // r11
int v12; // r3
int v13; // r0
int v14; // r2
int v15; // r4
int v16; // r3
int v17; // r5
int v18; // r0
int v19; // r6
int v20; // r1
int v21; // r8
int v22; // r0
int v23; // r2
int v24; // r6
int v25; // r2
int v26; // r12
int v27; // r3
int v28; // r0
int v29; // r4
int v30; // r5
int v31; // r3
int v32; // r0
int v33; // r1
__int64 v34; // r3
int v36; // [sp+4h] [bp-17Ch]
int v37; // [sp+8h] [bp-178h]
int v38; // [sp+Ch] [bp-174h]
int v39; // [sp+10h] [bp-170h]
int v40; // [sp+14h] [bp-16Ch]
int v41; // [sp+1Ch] [bp-164h]
char v42[320]; // [sp+20h] [bp-160h]
char _70[320]; // [sp+70h] [bp-110h]
char _C0[320]; // [sp+C0h] [bp-C0h]
char _110[320]; // [sp+110h] [bp-70h]
int v46; // [sp+160h] [bp-20h]
for ( i = 0; i != 64; i += 4 )
*(_DWORD *)&amp;amp;v42[i] = bswap32(*(_DWORD *)(a2 + i));
v3 = 0;
while ( v3 != 256 )
{
v4 = &amp;amp;v42[v3];
v5 = *(_DWORD *)&amp;amp;v42[v3 + 8] ^ *(_DWORD *)&amp;amp;v42[v3 + 32] ^ *(_DWORD *)&amp;amp;v42[v3 + 52];
v6 = *(_DWORD *)&amp;amp;v42[v3];
v3 += 4;
*((_DWORD *)v4 + 16) = __ROR4__(v5 ^ v6, 31);
}
v8 = *(_QWORD *)(a1 + 80) &amp;gt;&amp;gt; 32;
v7 = *(_QWORD *)(a1 + 80);
v9 = *(_DWORD *)(a1 + 100);
v10 = 0;
v12 = *(_DWORD *)(a1 + 92);
v11 = *(_DWORD *)(a1 + 96);
v41 = a1;
v38 = *(_DWORD *)(a1 + 88);
v13 = *(_DWORD *)(a1 + 88);
v14 = v12;
v37 = v12;
v40 = v7;
v39 = v8;
v36 = v11;
while ( 1 )
{
v15 = v14;
v14 = v13;
v16 = v7;
if ( v10 == 20 )
break;
v17 = *(_DWORD *)&amp;amp;v42[4 * v10];
v18 = (v13 &amp;amp; v8 | v15 &amp;amp; ~v8) + v11 + __ROR4__(v16, 27) + v9;
++v10;
v11 = v15;
v7 = v17 + v18;
v13 = __ROR4__(v8, 2);
v8 = v16;
}
v19 = 0;
while ( 1 )
{
v20 = v15;
v15 = v14;
v21 = v16;
if ( v19 == 20 )
break;
v22 = *(_DWORD *)&amp;amp;_70[4 * v19++];
v23 = (v14 ^ v8 ^ v20) + __ROR4__(v16, 27) + v11;
v11 = v20;
v16 = v23 + *(_DWORD *)(v41 + 104) + v22;
v14 = __ROR4__(v8, 2);
v8 = v21;
}
v24 = 0;
while ( 1 )
{
v25 = v20;
v20 = v15;
v26 = v21;
if ( v24 == 20 )
break;
v15 = __ROR4__(v8, 2);
v27 = *(_DWORD *)&amp;amp;_C0[4 * v24];
v28 = (v25 &amp;amp; v20 ^ (v25 ^ v20) &amp;amp; v8) + v11 + __ROR4__(v21, 27) + *(_DWORD *)(v41 + 108);
++v24;
v8 = v21;
v21 = v28 + v27;
v11 = v25;
}
v29 = 0;
while ( 1 )
{
v30 = v25;
v25 = v20;
v31 = v26;
if ( v29 == 20 )
break;
v32 = *(_DWORD *)&amp;amp;_110[4 * v29++];
v33 = (v20 ^ v8 ^ v30) + __ROR4__(v26, 27) + v11;
v11 = v30;
v26 = v33 + *(_DWORD *)(v41 + 112) + v32;
v20 = __ROR4__(v8, 2);
v8 = v31;
}
LODWORD(v34) = v26 + v40;
HIDWORD(v34) = v39 + v8;
*(_QWORD *)(v41 + 80) = v34;
*(_DWORD *)(v41 + 88) = v20 + v38;
*(_DWORD *)(v41 + 92) = v37 + v30;
*(_DWORD *)(v41 + 96) = v36 + v11;
return _stack_chk_guard - v46;
}
&lt;/code>&lt;/pre>&lt;p>这个函数就是 sha1 的一个明文分组计算过程，啥是明文分组呢，简单来说就是你要加密的明文如果很长很长，就要把明文分组，每一组是 512bit，也就是 64 字节长度，不足的要填充，填充规则如下&lt;/p>
&lt;pre tabindex="0">&lt;code>1 在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。
2 在这个结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二
进制表示的填充前信息长度超过64位，则取低64位。
经过这两步的处理，信息的位长=N*512+448+64=(N+1）*512，即长度恰好是512的整数倍。
这样做的原因是为满足后面处理中对信息长度的要求。
&lt;/code>&lt;/pre>&lt;p>要讲明白还是有点难（为了不误人子弟）大家感兴趣的自己搜资料研究；&lt;/p>
&lt;p>回到 tjupdate 函数&lt;/p>
&lt;p>每一个分组进行 4 轮变换，每一轮计算 20 步，伪代码也很明显（78 行、94 行、109 行、125 行）&lt;/p>
&lt;p>我们 hook 这个函数，就能知道每一轮的明文；&lt;/p>
&lt;pre tabindex="0">&lt;code>function tjupdate() {
      var pointer = Module.findBaseAddress(&amp;#34;libtujia_encrypt.so&amp;#34;).add(0x2AB4 + 1);
Interceptor.attach(pointer,
{
onEnter: function (args) {
                  myhexdump(&amp;#34;update arg0:&amp;#34;, args[1], 64)
                  console.log(&amp;#34;update arg0:&amp;#34;+Memory.readUtf8String(args[1]))
},
              onLeave: function (retval) {
              }
}
      );
&lt;/code>&lt;/pre>&lt;p>unidbg hook：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void hook_2AB4(){
        IHookZz hookZz = HookZz.getInstance(emulator); 
        hookZz.enable_arm_arm64_b_branch(); 
hookZz.wrap(module.base + 0x2AB4 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer text = ctx.getPointerArg(1);
byte[] texthex = text.getByteArray(0, 64);
Inspector.inspect(texthex, &amp;#34;block&amp;#34;);
};
@Override
// 方法执行后
public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
}
});
hookZz.disable_arm_arm64_b_branch();
};
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IoKVOVJzuQpxbjHOGicCZeopT3w8GQ7wSujKBibT9J0ibyjkJP4kg14rCA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后把每次的明文拼接起来，就是整个的明文&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IVsov6JbDlCkNGHiazE7Ce12SOh7yibgaJ6zGOEYqR4QVCBwokhsQ4l8A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后再 sha1，是不是一样？&lt;/p>
&lt;p>话说回来，Final 还没看呢，Final 是最后整理输出的，&lt;/p>
&lt;p>有些情况不参与计算，有些情况参与计算，也就是 tjget 函数了, 在这个案例里是参与了计算的&lt;/p>
&lt;p>hook 一个&lt;/p>
&lt;pre tabindex="0">&lt;code>function tjget() {
var pointer = Module.findExportByName(&amp;#34;libtujia_encrypt.so&amp;#34;,&amp;#39;tjget&amp;#39;);
      console.log(&amp;#39;case tjget:&amp;#39; + pointer);
Interceptor.attach(pointer,
{
              onEnter: function (args) {
this.buffer = args[1];
},
onLeave: function (retval) {
myhexdump(&amp;#34;tjget 结果：&amp;#34;, this.buffer, 20)
}
}
);
}
&lt;/code>&lt;/pre>&lt;p>unidbg hook：&lt;/p>
&lt;pre tabindex="0">&lt;code> public void hook_2CEA(){
IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz
hookZz.wrap(module.base + 0x2CEA + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
@Override
// 方法执行前
            public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer arg1 = ctx.getPointerArg(1);
ctx.push(arg1);
};
@Override
// 方法执行后
            public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
Pointer output = ctx.pop();
byte[] outputhex = output.getByteArray(0, 20);
Inspector.inspect(outputhex, &amp;#34;tjget ret&amp;#34;);
}
});
        hookZz.disable_arm_arm64_b_branch();
}
&lt;/code>&lt;/pre>&lt;p>hook 结果：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IAia8hIC7rLZ6GLmZorrtVicxdCRerEkvkUB482WY9QmevFYkmJecOyGw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>明文的生成&lt;/strong>&lt;/p>
&lt;p>分析完最后一步的标准算法，回过头来分析明文的生成&lt;/p>
&lt;p>看看具体实现的代码：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IQibsia3NlKY42jUwbKNSc9QUW5eC268YxrOwiceohLcicUeGo4ypU8G8Rw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>首先这里生成了固定的 key，&lt;/p>
&lt;p>这里用 unidbg 的另一种 hook 方式&lt;/p>
&lt;p>在这个地方下个断点&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IficjSEPrSf94gVbJWIZmHuC9pJTwh0wdng8DZnMx0evtGmMdTicUic1XQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code> public void HookByConsoleDebugger() {
        Debugger debugger = emulator.attach();
        //在module.base+0x3108地址处添加一个断点
        debugger.addBreakPoint(module.base+0x3108);
}
public static void main(String[] args) throws FileNotFoundException {
Test test = new Test();
//test.hook2c94();
// test.hook_2AB4();
test.HookByConsoleDebugger();
test.call_encrypt();
// test.get_bodyencrypt();
}
&lt;/code>&lt;/pre>&lt;p>运行，程序会断下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IiconIbURy6ozHUKhqxgfMxMkKjgVyhyfw0SsEqic92jYMelACFPvre6w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里的 r0 寄存器存放的是参数 1 的值，r1 是参数 2，r3 是参数 3&lt;/p>
&lt;p>怎么查看 r0 的值呢&lt;/p>
&lt;p>输入：mr0&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8I8z5t3iboojjJN3unuX8Wo1mKxu1xemIvXWro7JGoJEjrOUX6sE8pr5w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也可以输入地址：m0xbffff65c&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IIDQLZhHam42GM83GSHqt8JiafLhmypW1Gwk1wGichiacESAFGiclPHULJA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>默认 size 是 112，可以指定长度&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IIglibS7jgiboV8iajOd9qOuV9jnWq34hKwKWbhucqyEdCrJxOe9y3axlw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以这里的参数 1 是 tjhchk&lt;/p>
&lt;p>返回值怎么看呢，根据 arm 汇编的约定，返回值会放到 r0&lt;/p>
&lt;p>这下面几个地址都可以&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8Ij1uC6kicPeFXkuvogFS5fLibNfqiaX9nVDrZwTPPczaElHWEoRc3zy7Mg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在 0x310C 加个断点，命令：b0x310C&lt;/p>
&lt;p>然后按 c（跳到下一个断点）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8ItibhAmS6zMvXq3xrwl7icjAfF2LPDhahxOV4wxcLicHX7rsv7WMkCRuiaw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后查看 r0 的值&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IZ4NxdiaD9qwNX4quZIPlicgsESfEGexiag493VquichpQRCK5rMFcsMqPQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>验证后发现是标准的 base64&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8ILE41sQahfzt48xT4K18NmgBJUqcXl23DhwVK7qicSqrLUzCL4jVwr2A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还有一种方法能获取返回值&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8I3Uzbn1MtEFl0KYNFXdjib9eiaBNk4RPTseuKNsP6b3WXnOJRwmnasMqg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>0x291C 下个断点 (函数具体实现的地址)&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x291C);
&lt;/code>&lt;/pre>&lt;p>重新运行程序&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IgPfiaAsRBqBmskyFOXUwyjVuFzv1wQUpWFOibevSN1PblS1mwuDV4Ffg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这时 r0 一样是 tjhchk&lt;/p>
&lt;p>然后输入命令 blr，blr 会在函数返回的地方下一个断点&lt;/p>
&lt;p>c（跳到一下个断点）&lt;/p>
&lt;p>查看 r0 的值&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IoWwXy7O7Qdj6Wuew5PKjUQLibG9ia7c8o9AzesoMmygICPPd3Cuoz89A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>生成了 key；然后往下看&lt;/p>
&lt;p>可以看到很多地方都在异或 0x21&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8Iys1HVKfWPASYPx9iblmsVTnvNkskScQHbhTEricZFnBzIBhNhcq29ZDQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这些都是把各个参数先异或 0x21，再拼接，最后是在 j_tjsplittxt 函数做字符串翻转&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IHoZKq1JnpzyPXGIZdAJgh0AX5qDBCZgV7ibYXUwlGUdaicUQberPASdQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>来打个断点瞧瞧&lt;/p>
&lt;pre tabindex="0">&lt;code>debugger.addBreakPoint(module.base+0x2DEC);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IDl6QpE4nOH0tHreDkpjafNfq6icxtKwKibjnBrpgFEd1K55yyLAEsqJw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个参数 1 是乱码，我们把他异或 0x21 试试呢&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IdVb87jC2ruYWWxlZXndgL9cZibGxe7H9bDwoYrKJicFyMIl7WgZrzx1g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里就已经拼接好了嘛&lt;/p>
&lt;p>看看返回值，blr，c&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IicibZYub2z5MxA3tuwsFNYWEDllOqZrwbtKHx6YDldrgFr2X0aOwe4KQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里的返回值在 r8，我猜是因为在 Thumb 程序中，只能使用 r4~r7 来保存局部变量&lt;/p>
&lt;p>直接 mr8 是不行的，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8Izhw5aIH48OO6laLbXpAQIdrLpprmAKEfxOqZhxAAExSwfw4KhtAXCw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以我们 m0x40223180&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IOUzMZnBd7jqCiceMXhhUKzicfw2icnjdax1b8aEkB0ZjWh4cZWMeybaFA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>或者输入 s，单步调试，让它把 r8 赋值到 r0&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IibXVFvtKrm6VfBqZ1TQsI6xKShI9YlFe47L3uR4Z8gw0uXDS6u1tp7A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8Ic26v1gaDF9KQ4xEIEibpURtBQnfLg2xYTFagHUjneUNj6zPhoYQLJZA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后把这个值异或 0x21&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IX58JCuWibnLGwDIETCzOibMONPfQLtZ1yhVk1pFbr7lxlrX7UoHgs7pA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后又是 base64&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8IbY8icH8VWwcQtGian8AGiaqzW6pgdGQGQSQITlz5OnaylwhGNOVJicCQXA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>上面那个调用第三个参数是 10，这里是 30，有何大咪咪呢？&lt;/p>
&lt;p>进去看看&lt;/p>
&lt;p>编码之前参数 3 不等于 10 的时候编码之前把明文异或 0x21&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8I2fQLeTBOaZg5xJasP3w6jvZGCvibP3DBkCONhoqnWK0orxLCxvnTq7A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>编码之后参数 3 不等于 10 的时候把明文异或 0x21&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8Iw4yIzEO71Xx88siaicv4r4aH8lna5zpkxC0qxXssiaX6ia20FhdbIAeT9A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以总结下来就是，&lt;/p>
&lt;ol>
&lt;li>
&lt;p>每个参数和固定的 key 分别异或 0x21（有个参数要排序）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拼接&lt;/p>
&lt;/li>
&lt;li>
&lt;p>翻转（j_tjsplittxt）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>异或 0x21（tjtxtutf8）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>base64 编码（tjtxtutf8）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>异或 0x21（tjtxtutf8）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>异或 0x21（j_tjreset）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sha1（j_tjreset）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>发现没有，4 次异或 0x21，等于就是没有异或。。所以可以简化成 3 步&lt;/p>
&lt;ol>
&lt;li>
&lt;p>参数拼接（有个参数要排序）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>翻转&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sha1&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>剩下就是写代码了。。&lt;/p>
&lt;p>下篇 body 分析再见&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/icBZkwGO7uH4CSjdGEGiabI6rw0gJY5e8I3qibNB54S5D95gqNibiaqWgibgFQ8GFkKrktyLzrBica2X00YMSFJJ0294g/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>彩蛋&lt;/strong>&lt;/p>
&lt;p>初始化链接常数加载汇编指令解析&lt;/p>
&lt;p>0x2C48 下个断点  blr  c  查看 r0&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH42GylcEhBjdBbp7pLyu7kLsOEvIgmm516UKMJywsBDea11jxic8MJUueVZVA4UwicjJcq24h11ianIg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>上面说了转成小端就是 sha1 五个幻数&lt;/p>
&lt;pre tabindex="0">&lt;code>0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476 0xC3DEE1F0
&lt;/code>&lt;/pre>&lt;p>看看汇编是怎么加载的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH42GylcEhBjdBbp7pLyu7kLlwFTTYUODtGibt5YbAM6qKUfv8OWB2Q9LlShRC4ibaaEiaeFrHXF4kGzw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>ADR R1, dword_2C80
&lt;/code>&lt;/pre>&lt;p>adr 用来加载地址，而且是相对地址寻址&lt;/p>
&lt;p>dword 修饰一个操作数为 Double Word，即 4 字节&lt;/p>
&lt;p>即 0x2C80 地址放到 R1&lt;/p>
&lt;p>看看内存中的值&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5EUJXagGDvgbWxZEhwib58o5bofiaQqtdXdlUsT6tVMNXO4TyxJyJLBM3JsZAsMIHhicCx5M6ETmcbg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后就是下面的两行&lt;/p>
&lt;pre tabindex="0">&lt;code>VLD1.64 {D16-D17}, [R1]
VST1.64 {D16-D17}, [R0]
&lt;/code>&lt;/pre>&lt;p>V 开头表示是 NEON 指令&lt;/p>
&lt;p>什么是 NEON（抄的）&lt;/p>
&lt;pre tabindex="0">&lt;code>Arm NEON 技术是针对 Arm Cortex-A 系列和 Cortex-R52 处理器的高级 SIMD（单指令多数据）架构扩展。
具有NEON技术的处理器都会配备了32个64位的寄存器和16个128位的寄存器,它们分别被标识为(D0-D31),(Q0-Q15)
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>vld1.64 {d16, d17}, [r1]
将r1内存中的数据映射到d16, d17寄存器上面。这样就可以直接通过d16, d17寄存器来操作数据,64表示一个寄存器有64位(8个16进制)
&lt;/code>&lt;/pre>&lt;p>在这里就是把 r1 中的 01 23 45 67 89 AB CD EF 放到 d16 寄存器，FE DC BA 98 76 54 32 10 放到 d17 寄存器&lt;/p>
&lt;pre tabindex="0">&lt;code>vst1.64 {d16, d17}, [r0]
将d16, d17寄存器中的数据映射回r0内存中，这样就可以通过打印r0来看到结果
&lt;/code>&lt;/pre>&lt;p>在这里就是把 d16(01 23 45 67 89 AB CD EF) 放到 r0 寄存器，d17(FE DC BA 98 76 54 32 10) 放到 r0 寄存器&lt;/p>
&lt;p>之后呢在 tjupdate 函数里，加载出来使用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5EUJXagGDvgbWxZEhwib58ojm7RI8TdiaOCsXcNZGexHKmicoSWnGYJL5iaHQaF1sQvducaib33CEx6icA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>汇编&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5EUJXagGDvgbWxZEhwib58obiaNM13OH2EqZiafxIbo0oLjibvSjibcGqgmlVW1wuIbRicxvIicibQBCCZrA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>重点说下这个地方&lt;/p>
&lt;pre tabindex="0">&lt;code>LDMIA.W R11, {R2,R3,R11}
LDMIA指令，IA表示每次传送后地址加4,W修饰一个操作数为Double Word，即4字节
&lt;/code>&lt;/pre>&lt;p>R11 在 unidbg 中是 sp&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5EUJXagGDvgbWxZEhwib58oxLPWQGEIDwib5yf3sZGqGf1Pib01ZbXOl3GbYq8ibAV7jNuQRJl5uTSOg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5EUJXagGDvgbWxZEhwib58ogNvrO98yoPLfTeTtto9Md3yw0B8JbicvMqWm2F2OHm65qdVVareKlRQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>依次把 FE DC BA 98 放到 R2; 76 54 32 10 放到 R3&lt;/p>
&lt;p>按 s&lt;/p>
&lt;p>可以看到 R2、R3 已经被重新赋值 (小端)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/icBZkwGO7uH5EUJXagGDvgbWxZEhwib58o1GlwIzUmhGpahGHsFky7qBdTInDrg3v8W16AmuIIZj9Zg2ukYuaJ4w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其他的地方可以自己动态调试看看&lt;/p></description></item><item><title>大猿搜题 sign so 加密参数分析｜unidbg</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%A4%A7%E7%8C%BF%E6%90%9C%E9%A2%98-sign-so-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90unidbg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%A4%A7%E7%8C%BF%E6%90%9C%E9%A2%98-sign-so-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90unidbg/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg2NjcxNzE3NQ==&amp;amp;mid=2247483906&amp;amp;idx=1&amp;amp;sn=712447f635fb957b0f7d47d7333b865a&amp;amp;chksm=ce47de9af930578c2c3e4181b64de465be78bcc9096731eb6f3eb599768e69f70755bb3bff2e&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0302EmxYsDsZprkUyCAuJRqP&amp;amp;sharer_sharetime=1646203747659&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">前言&lt;/h1>
&lt;blockquote>
&lt;p>❝&lt;/p>
&lt;p>「样本: &lt;a href="https://www.wandoujia.com/apps/6526244" target="_blank" rel="noopener">https://www.wandoujia.com/apps/6526244&lt;/a>」&lt;br>
「版本: 11.4.3」&lt;/p>
&lt;p>❞&lt;/p>
&lt;/blockquote>
&lt;h1 id="charles">charles&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3ia14OibwPCCXjEYiaoy6qQT6SdicUibSWGia7hHsYS6HYkIqAiaHC3pL7Nl5Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>随便一个接口 &lt;code>sign&lt;/code> 参数&lt;/p>
&lt;p>「这个 app 有 360 加固，需要先脱壳」&lt;/p>
&lt;h1 id="dump-dex">dump dex&lt;/h1>
&lt;p>「使用的 yang 神的 frida-dump &lt;a href="https://github.com/lasting-yang/frida_dump" target="_blank" rel="noopener">https://github.com/lasting-yang/frida_dump&lt;/a>」&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3vhaSbCvKCicqNHKczbkzibml3OpNPnkwodVRK2icggHwuQqJZ0Fica7vicA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>主要如果报了这个错误，需要给 &lt;code>app&lt;/code> 文件的读权限&lt;/p>
&lt;pre tabindex="0">&lt;code>import os
import zipfile
import argparse
def rename_class(path):
    files = os.listdir(path)
    dex_index = 0
    if path.endswith(&amp;#39;/&amp;#39;):
        path = path[:-1]
        print(path)
    for i in range(len(files)):
        if files[i].endswith(&amp;#39;.dex&amp;#39;):
            old_name = path + &amp;#39;/&amp;#39; + files[i]
            if dex_index == 0:
                new_name = path + &amp;#39;/&amp;#39; + &amp;#39;classes.dex&amp;#39;
            else:
                new_name = path + &amp;#39;/&amp;#39; + &amp;#39;classes%d.dex&amp;#39; % dex_index
            dex_index += 1
            if os.path.exists(new_name):
                continue
            os.rename(old_name, new_name)
    print(&amp;#39;[*] 重命名完毕&amp;#39;)
def extract_META_INF_from_apk(apk_path, target_path):
    r = zipfile.is_zipfile(apk_path)
    if r:
        fz = zipfile.ZipFile(apk_path, &amp;#39;r&amp;#39;)
        for file in fz.namelist():
            if file.startswith(&amp;#39;META-INF&amp;#39;):
                fz.extract(file, target_path)
    else:
        print(&amp;#39;[-] %s 不是一个APK文件&amp;#39; % apk_path)
def zip_dir(dirname, zipfilename):
    filelist = []
    if os.path.isfile(dirname):
        if dirname.endswith(&amp;#39;.dex&amp;#39;):
            filelist.append(dirname)
    else:
        for root, dirs, files in os.walk(dirname):
            for dir in dirs:
                # if dir == &amp;#39;META-INF&amp;#39;:
                # print(&amp;#39;dir:&amp;#39;, os.path.join(root, dir))
                filelist.append(os.path.join(root, dir))
            for name in files:
                # print(&amp;#39;file:&amp;#39;, os.path.join(root, name))
                filelist.append(os.path.join(root, name))
    z = zipfile.ZipFile(zipfilename, &amp;#39;w&amp;#39;, zipfile.ZIP_DEFLATED)
    for tar in filelist:
        arcname = tar[len(dirname):]
        if (&amp;#39;META-INF&amp;#39; in arcname or arcname.endswith(&amp;#39;.dex&amp;#39;)) and &amp;#39;.DS_Store&amp;#39; not in arcname:
            # print(tar + &amp;#34; --&amp;gt;rar: &amp;#34; + arcname)
            z.write(tar, arcname)
    print(&amp;#39;[*] APK打包成功，你可以拖入APK进行分析啦！&amp;#39;)
    z.close()
if __name__ == &amp;#39;__main__&amp;#39;:
    args = {
        &amp;#39;dex_path&amp;#39;: &amp;#39;/Users/admin/Desktop/project/user/user-frida-hook/hook/frida_dump_dex/unpack/xiaoyuansouti&amp;#39;,
        &amp;#39;apk_path&amp;#39;: &amp;#39;/Volumes/T7/android/android-file/xiaoyuansouti-11.4.3.apk&amp;#39;,
        &amp;#39;output&amp;#39;: &amp;#39;/Volumes/T7/android/android-file/xiaoyuansouti-new-11.4.3.apk&amp;#39;
    }
    rename_class(args[&amp;#39;dex_path&amp;#39;])
    extract_META_INF_from_apk(args[&amp;#39;apk_path&amp;#39;], args[&amp;#39;dex_path&amp;#39;])
    zip_dir(args[&amp;#39;dex_path&amp;#39;], args[&amp;#39;output&amp;#39;])
&lt;/code>&lt;/pre>&lt;p>脱完壳之后再使用以上脚本，合并 &lt;code>dex&lt;/code> 生成新的 &lt;code>apk&lt;/code> 文件，在反编译&lt;/p>
&lt;h1 id="java-层分析">java 层分析&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3vH4wUGvx5TFiax3uVibibatdDhqb8zK3r9DALFsOsLTYgx8wM7AZIialzg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>全局搜索 &lt;code>sign&lt;/code> 关键词，定位到这个函数 &lt;code>com.fenbi.android.leo.imgsearch.sdk.network.intercepto.SignInterceptor.intercept&lt;/code>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3oMNTOicel2n2Rb7dtPeFFtMzllNQVia2ZctF4m3gXmCJiakzxstxY7ZdQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>继续往下分析，来到了这里 &lt;code>com.fenbi.android.solar.util.bn&lt;/code>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB31V59nHpHbZdh79icP7jdZyK9DZ3hiaOz8pMNaiahtJ0pwe4hRMuwnQoIg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在继续就来到了 &lt;code>native&lt;/code> 函数处，会调用这个三个函数&lt;/p>
&lt;h1 id="frida-hook">frida hook&lt;/h1>
&lt;pre tabindex="0">&lt;code>function getProcessId() {
    var androidProcess = Java.use(&amp;#39;android.os.Process&amp;#39;);
    return &amp;#39;processId: &amp;#39; + androidProcess.myTid() + &amp;#39; - &amp;#39;;
}
function printLog() {
    var result = &amp;#39;&amp;#39;;
    for (var i = 0; i &amp;lt; arguments.length; i++) {
        result += arguments[i] + &amp;#39; &amp;#39;;
    }
    console.log(getProcessId(), result)
}
function hook() {
    var eClass = Java.use(&amp;#39;com.fenbi.android.solar.util.e&amp;#39;);
    eClass.zcvsd1wr2t.implementation = function (a, b, c, d) {
        printLog(&amp;#39;eClass.zcvsd1wr2t.a: &amp;#39;, a);
        printLog(&amp;#39;eClass.zcvsd1wr2t.c: &amp;#39;, c);
        printLog(&amp;#39;eClass.zcvsd1wr2t.c: &amp;#39;, c);
        printLog(&amp;#39;eClass.zcvsd1wr2t.d: &amp;#39;, d);
        var res = this.zcvsd1wr2t(a, b, c, d);
        printLog(&amp;#39;eClass.zcvsd1wr2t.res: &amp;#39;, res);
        return res;
    }
    eClass.awi6d8sdfe.implementation = function (a, b, c, d) {
        printLog(&amp;#39;eClass.awi6d8sdfe.a: &amp;#39;, a);
        printLog(&amp;#39;eClass.awi6d8sdfe.c: &amp;#39;, c);
        printLog(&amp;#39;eClass.awi6d8sdfe.c: &amp;#39;, c);
        printLog(&amp;#39;eClass.awi6d8sdfe.d: &amp;#39;, d);
        var res = this.awi6d8sdfe(a, b, c, d);
        printLog(&amp;#39;eClass.awi6d8sdfe.res: &amp;#39;, res);
        return res;
    }
    eClass.fxc3fs3red.implementation = function (a, b, c, d) {
        printLog(&amp;#39;eClass.fxc3fs3red.a: &amp;#39;, a);
        printLog(&amp;#39;eClass.fxc3fs3red.c: &amp;#39;, c);
        printLog(&amp;#39;eClass.fxc3fs3red.c: &amp;#39;, c);
        printLog(&amp;#39;eClass.fxc3fs3red.d: &amp;#39;, d);
        var res = this.fxc3fs3red(a, b, c, d);
        printLog(&amp;#39;eClass.fxc3fs3red.res: &amp;#39;, res);
        return res;
    }
}
Java.perform(function () {
    hook();
})
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB33xPSvWKseWurvBuqKobNM0cxvWetatl70mF6eYjyH9vP3faGDo0Z9A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>执行脚本，结果保存到文件里，函数都 &lt;code>hook&lt;/code> 成功&lt;/p>
&lt;h1 id="unidbg">unidbg&lt;/h1>
&lt;p>「老规矩，先搭建架子」&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.xiayu.xiaoyuansouti;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.AbstractJni;
import com.github.unidbg.linux.android.dvm.DalvikModule;
import com.github.unidbg.linux.android.dvm.DvmClass;
import com.github.unidbg.linux.android.dvm.VM;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.virtualmodule.android.AndroidModule;
import java.io.File;
import java.io.IOException;
public class GetSign_v1143Test extends AbstractJni {
    private final AndroidEmulator emulator;
    private final VM vm;
    private final Module module;
    public DvmClass EClass;
    public String apkPath = &amp;#34;/Volumes/T7/android/android-file/xiaoyuansouti-11.4.3.apk&amp;#34;;
    GetSign_v1143Test() {
        emulator = AndroidEmulatorBuilder.for32Bit().build();
        final Memory memory = emulator.getMemory();
        memory.setLibraryResolver(new AndroidResolver(23));
        vm = emulator.createDalvikVM(new File(apkPath));
        vm.setVerbose(true);
        DalvikModule dm = vm.loadLibrary(&amp;#34;RequestEncoder&amp;#34;, true);
        vm.setJni(this);
        module = dm.getModule();
        dm.callJNI_OnLoad(emulator);
        EClass = vm.resolveClass(&amp;#34;com/fenbi/android/solar/util/e&amp;#34;);
    }
    public static void main(String[] args) {
        GetSign_v1143Test getSign_v1143Test = new GetSign_v1143Test();
        
        getSign_v1143Test.destroy();
    }
    private void destroy() {
        try {
            emulator.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB32IEubBibQAKXZrK95xU0KOMX22wlicemJ31cDYLDrQbTPMNwyzyhV0sw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>跑起来，成功报错，&lt;code>libandroid.so&lt;/code> 咱们加一下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3Wxa6ahWhbKDtWovYIPMVtkZYmezMF0rsE0M4Qtqe5mzBHI4wdkeo4g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>加上在跑起来，这次报了环境错误，补上就 OK 了&lt;/p>
&lt;pre tabindex="0">&lt;code>public void call_zcvsd1wr2t() {
    String methodId = &amp;#34;zcvsd1wr2t(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;)Ljava/lang/String;&amp;#34;;
    EClass.callStaticJniMethodObject(
            emulator, methodId,
            new StringObject(vm, &amp;#34;/ape-news/android/news&amp;#34;),
            new StringObject(vm, &amp;#34;0&amp;#34;),
            0,
            new StringObject(vm, &amp;#34;&amp;#34;)
    );
}
&lt;/code>&lt;/pre>&lt;p>直接来 &lt;code>call&lt;/code> 目标函数&lt;/p>
&lt;p>「中间省略一部分补环境操作。。。。。。」&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3Oia2JX3SyA765gyWCV8JsSZqm71VGE3jFfpW6Ix4gwvLOjR2ZjknQ8g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个错误，要求返回 &lt;code>Signature array&lt;/code>，这是获取 &lt;code>app&lt;/code> 签名，需要返回 &lt;code>array&lt;/code> 注意不要直接 &lt;code>vm.resolveClass(&amp;quot;[android/content/pm/Signature&amp;quot;)&lt;/code> 可以使用 &lt;code>ArrayObject&lt;/code> 构建返回，这样可以避免很多问题&lt;/p>
&lt;pre tabindex="0">&lt;code>CertificateMeta[] certificateMetas = vm.getSignatures();
DvmObject&amp;lt;?&amp;gt;[] dvmObjects = new DvmObject[certificateMetas.length];
for (int i = 0; i &amp;lt; certificateMetas.length; i++) {
    dvmObjects[i] = vm.resolveClass(&amp;#34;android/content/pm/Signature&amp;#34;).newObject(certificateMetas[i]);
}
return new ArrayObject(dvmObjects);
&lt;/code>&lt;/pre>&lt;p>具体代码如上，补上继续跑起来&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB32UZPoIic41DYnkcPlicPtfqsqQUrqCaEKOD97PBMDsuB9ia3fGIyZibicLw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个是调用 &lt;code>Signature.toChars&lt;/code> 函数，返回 &lt;code>char[]&lt;/code> 数据&lt;/p>
&lt;pre tabindex="0">&lt;code>CertificateMeta certificateMeta = (CertificateMeta) dvmObject.getValue();
byte[] bytes = certificateMeta.getData();
DvmObject&amp;lt;?&amp;gt;[] dvmObjects = new DvmObject[bytes.length];
for (int i = 0; i &amp;lt; bytes.length; i++) {
    dvmObjects[i] = vm.resolveClass(&amp;#34;C&amp;#34;).newObject((char) bytes[i]);
}
return new ArrayObject(dvmObjects);
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3lF8VwpEK7dmjkgksBs1zichV9hkUlhI0iafHENJR5JlMgFenz7EjEPrg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>补完，在跑起来，发现又报错了，不知道啥错误，点进 &lt;code>handler&lt;/code> 里看看&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3ibt3TX2ajTYKrDVSlr4FNHiajLDcwnLf5nKgiahXC3LGLLXm8pvDzs0pg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>是个未实现的 &lt;code>jni&lt;/code> 函数，那咱们就去实现一下，参照 &lt;code>GetxxxxArrayElements&lt;/code> 代码逻辑，写一个&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3pSLTqITC2tzoIK3hMu0js8DopFCbXuNsUIhkH6UJAstDt6J6AEwX0g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>比如这个 &lt;code>GetIntArrayElements&lt;/code> 函数逻辑，通过 &lt;code>getObject&lt;/code> 获取对象，在调用 &lt;code>_GetArrayCritical&lt;/code> 函数，但是 &lt;code>char[]&lt;/code> 没有实现对应的 &lt;code>CharArray&lt;/code>，有两种方法&lt;/p>
&lt;ul>
&lt;li>
&lt;p>1、自己根据 &lt;code>GetxxxxArrayElements&lt;/code> 逻辑写一个&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2、实现 &lt;code>CharArray&lt;/code> 跟其他的 &lt;code>xxxArray&lt;/code> 逻辑保持一致&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>推荐方法 2，这样写后面可以避免很多问题（龙哥的精讲课里也提到过，基本数据的构建最好使用 unidbg 提供的 class）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3hSgTJUGE1CdiczSLkhoibNeqRicvc4aBlIcbticshGicxbuJdFOKqXWl7GQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>新建个 &lt;code>CharArray&lt;/code> 文件，代码直接复制其他的 &lt;code>array&lt;/code> 改改数据类型就 OK 了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3KbIdtT97Fr87pwxIXhECvibQ4x6wrf0QKh9KgibuIVkd0TpJE80mMgBw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>刚刚的环境，咱们使用 &lt;code>CharArray&lt;/code> 来构建&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3kBq0kTFyO1QLteicbJydQqicxYD7LW5kPnMCibib6KpTGSVBdwQl8eOKqg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;code>jni&lt;/code> 这里也是使用，同样的逻辑返回，继续跑起来，还会报个错误&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB394iaLpAw8k17nBGxrvb6DZ2viawhywAC7TbUgzncyHXpWuBdK1e50veA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里在 &lt;code>write&lt;/code> 的时候，循环调用 &lt;code>setChar&lt;/code> 函数即可&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/MWQJibR3pCZ8e0djy9O5wmvFHHlWWXbB3a0viaemWcw7x8ZWqeFOAfBoLOJQRKNic5FibyOY10l3X8KVuZzzl5aFhg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后在补个环境，也是成功运行出了结果&lt;/p></description></item><item><title>分享一个 Android 通用 svc 跟踪以及 hook 方案——Frida-Seccomp</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA-android-%E9%80%9A%E7%94%A8-svc-%E8%B7%9F%E8%B8%AA%E4%BB%A5%E5%8F%8A-hook-%E6%96%B9%E6%A1%88frida-seccomp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA-android-%E9%80%9A%E7%94%A8-svc-%E8%B7%9F%E8%B8%AA%E4%BB%A5%E5%8F%8A-hook-%E6%96%B9%E6%A1%88frida-seccomp/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://bbs.pediy.com/thread-271815.htm" target="_blank" rel="noopener">bbs.pediy.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[原创] 分享一个 Android 通用 svc 跟踪以及 hook 方案——Frida-Seccomp&lt;/p>
&lt;/blockquote>
&lt;h1 id="一个android通用svc跟踪以及hook方案frida-seccomp一个-android-通用-svc-跟踪以及-hook-方案frida-seccomp">&lt;a href="#%e4%b8%80%e4%b8%aaandroid%e9%80%9a%e7%94%a8svc%e8%b7%9f%e8%b8%aa%e4%bb%a5%e5%8f%8ahook%e6%96%b9%e6%a1%88%e2%80%94%e2%80%94frida-seccomp">&lt;/a>一个 Android 通用 svc 跟踪以及 hook 方案——Frida-Seccomp&lt;/h1>
&lt;h1 id="效果效果">&lt;a href="#%e6%95%88%e6%9e%9c%ef%bc%9a">&lt;/a>效果：&lt;/h1>
&lt;h2 id="对-openat-进行跟踪">对 openat 进行跟踪&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.pediy.com/upload/attach/202203/903162_55EERQXHHTXD4FW.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="对-recvfrom-进行跟踪">对 recvfrom 进行跟踪&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.pediy.com/upload/attach/202203/903162_AE84XGKCDB8RBY6.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;br>
&lt;strong>在这里感谢珍惜大佬介绍的 seccomp 机制，推荐一波珍惜大佬的课程能学到很多有趣的骚操作。&lt;/strong>&lt;/p>
&lt;h1 id="什么是-seccomp">什么是 seccomp&lt;/h1>
&lt;p>&lt;a href="http://pollux.cc/2019/09/22/seccomp%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%20&amp;amp;%202019ByteCTF%20VIP/#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%BA%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%A6%81%E7%94%A8execve%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">seccomp 沙箱机制介绍文章&lt;/a>&lt;br>
seccomp 是 Linux 内核提供的一种应用程序沙箱机制，主要通过限制进程的系统调用来完成部分沙箱隔离功能。seccomp-bpf 是 seccomp 的一个扩展，它可以通过配置来允许应用程序调用其他的系统调用。&lt;/p>
&lt;h1 id="如何和-frida-结合">如何和 frida 结合&lt;/h1>
&lt;h2 id="基本原理">基本原理&lt;/h2>
&lt;pre tabindex="0">&lt;code>这是一个bpf规则：
struct sock_filter filter[] = {
        BPF_STMT(BPF_LD + BPF_W + BPF_ABS,
                 (offsetof(struct seccomp_data, nr))),
        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 1),
        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRAP),
        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
};
&lt;/code>&lt;/pre>&lt;p>seccomp 的具体用法可以参考「&lt;strong>什么是 seccomp&lt;/strong>」中的 seccomp 介绍文章。当返回规则设置为「SECCOMP_RET_TRAP」，目标系统调用时 seccomp 会产生一个 SIGSYS 系统信号并软中断，这时就可以通过捕获这个 SIGSYS 信号获得 svc 调用和打印具体参数。&lt;/p>
&lt;h2 id="如何脚本化安装-seccomp-规则呢">如何脚本化安装 seccomp 规则呢&lt;/h2>
&lt;p>这里使用 Frida 的 API「CModule」，CModule 提供强大的动态编译功能可以让你在 JS 中写 C，&lt;br>
&lt;strong>frida 文档中的示例&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const cm = new CModule(`
#include void hello(void) {
  printf(&amp;#34;Hello World from CModule\\n&amp;#34;);
}
`);
const hello = new NativeFunction(cm.hello, &amp;#39;void&amp;#39;, []);
hello();
&lt;/code>&lt;/pre>&lt;h2 id="如何捕获异常">如何捕获异常&lt;/h2>
&lt;p>使用 Frida 的 API「&lt;strong>Process.setExceptionHandler&lt;/strong>」即可捕获异常并在自己写的回调中进行数据处理。
数据处理的逻辑解释写在注释里啦。&lt;/p>
&lt;pre tabindex="0">&lt;code>// 异常处理
    Process.setExceptionHandler(function (details) {
        const current_off = details.context.pc - 4;
        // 判断是否是seccomp导致的异常 读取opcode 010000d4 == svc 0
        if (details.message == &amp;#34;system error&amp;#34; &amp;amp;&amp;amp; details.type == &amp;#34;system&amp;#34; &amp;amp;&amp;amp; hex(ptr(current_off).readByteArray(4)) == &amp;#34;010000d4&amp;#34;) {
            // 上锁避免多线程问题
            lock(syscall_thread_ptr)
            // 获取x8寄存器中的调用号
            const nr = details.context.x8.toString(10);
            let loginfo = &amp;#34;\n==================&amp;#34;
            loginfo += `\nSVC[${syscalls[nr][1]}|${nr}] ==&amp;gt; PC:${addrToString(current_off)} P${Process.id}-T${Process.getCurrentThreadId()}`
            // 构造线程syscall调用参数
            const args = Memory.alloc(7 * 8)
            args.writePointer(details.context.x8)
            let args_reg_arr = {}
            for (let index = 0; index &amp;lt; 6; index++) {
                eval(`args.add(8 * (index + 1)).writePointer(details.context.x${index})`)
                eval(`args_reg_arr[&amp;#34;arg${index}&amp;#34;] = details.context.x${index}`)
            }
            // 获取手动堆栈信息
            loginfo += &amp;#34;\n&amp;#34; + stacktrace(ptr(current_off), details.context.fp, details.context.sp).map(addrToString).join(&amp;#39;\n&amp;#39;)
            // 打印传参
            loginfo += &amp;#34;\nargs = &amp;#34; + JSON.stringify(args_reg_arr)
            // 调用线程syscall 赋值x0寄存器
            details.context.x0 = call_task(syscall_thread_ptr, args, 0)
            loginfo += &amp;#34;\nret = &amp;#34; + details.context.x0.toString()
            // 打印信息
            call_thread_log(loginfo)
            // 解锁
            unlock(syscall_thread_ptr)
            return true;
        }
        return false;
    })
&lt;/code>&lt;/pre>&lt;h2 id="还有什么坑">还有什么坑&lt;/h2>
&lt;h3 id="1syscall-调用-resume">1.syscall 调用 resume&lt;/h3>
&lt;h4 id="问题描述">问题描述&lt;/h4>
&lt;p>根据 Frida 文档介绍「&lt;strong>setExceptionHandler&lt;/strong>」捕获异常后只需要让回调返回 true 就会 resume 原本的线程，但是其只是跳过了 svc 指令继续执行，实际上并不会执行 svc，这时候如果不执行 syscall 轻则导致 APP 数据异常，重则导致 APP 直接崩溃。所以在异常的回调中需要手动调用了 syscall 并赋值给 x0。
但这时候会发生个新的问题，因为在主线程开启 seccomp 后，主线程和其后创建出来的线程都会被 seccomp 规则约束，在异常处理函数直接调用 syscall 同样会被 seccomp 约束再次抛出异常，就形成了” 死锁 “了。&lt;/p>
&lt;h4 id="如何解决">如何解决&lt;/h4>
&lt;p>可以注意到上面 “死锁” 部分描述，那我们在主线程被约束前，提前创建一个线程，这个线程就是不被约束的，同时受到线程池启发，我们让这个 syscall 线程循环接受任务，就能完成在一个没有约束的线程里进行 syscall 调用。&lt;/p>
&lt;h3 id="2-堆栈回溯">2. 堆栈回溯&lt;/h3>
&lt;h4 id="问题描述-1">问题描述&lt;/h4>
&lt;p>直接使用 Frida 的 API「&lt;strong>Thread.backtrace&lt;/strong>」很容易导致崩溃，原因可能是 seccomp 规则或者「prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)」导致的权限收紧和 Frida 实现堆栈回溯功能冲突。&lt;/p>
&lt;h4 id="如何解决-1">如何解决&lt;/h4>
&lt;p>手动实现堆栈回溯，原理是 Arm64 中每个函数都会在函数头部位置对 x29、x30 寄存器存入栈中，所以可以对 x29 不断读取往上回溯，最后得到完整的堆栈信息。
&lt;strong>实现&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>function stacktrace(pc, fp, sp) {
    let n = 0, stack_arr = [], fp_c = fp;
    stack_arr[n++] = pc;
    const mem_region = call_thread_read_maps(sp);
    while (n &amp;lt; MAX_STACK_TRACE_DEPTH) {
        if (parseInt(fp_c.toString()) &amp;lt; parseInt(sp.toString()) || fp_c &amp;lt; mem_region.start || fp_c &amp;gt; mem_region.end) {
            break
        }
        let next_fp = fp_c.readPointer()
        let lr = fp_c.add(8).readPointer()
        fp_c = next_fp
        stack_arr[n++] = lr
    }
    return stack_arr;
}
&lt;/code>&lt;/pre>&lt;h3 id="3processfindmodulebyaddressprocessenumeratemodules类的-api-导致崩溃或找不到-module-信息">3.「&lt;strong>Process.findModuleByAddress&lt;/strong>」「&lt;strong>Process.enumerateModules&lt;/strong>」类的 API 导致崩溃或找不到 Module 信息&lt;/h3>
&lt;h4 id="问题描述-2">问题描述&lt;/h4>
&lt;p>疑似同坑 2 的原因&lt;/p>
&lt;h4 id="如何解决-2">如何解决&lt;/h4>
&lt;p>在 CModule 中手动实现了通过地址查 soinfo 信息「base, size, soname」等&lt;/p>
&lt;h3 id="4write-调用约束下调用-frida-的-apisend崩溃">4.write 调用约束下调用 Frida 的 API「send」崩溃&lt;/h3>
&lt;h4 id="问题描述-3">问题描述&lt;/h4>
&lt;p>同坑 2 的原因&lt;/p>
&lt;h4 id="如何解决-3">如何解决&lt;/h4>
&lt;p>直接改用 syscall 线程使用「&lt;strong>__android_print_log&lt;/strong>」打印信息&lt;/p>
&lt;h1 id="还可以实现什么">还可以实现什么&lt;/h1>
&lt;p>在调用线程 syscall 前后可以更改传参、返回值、地址等更改，达到 HOOK 的效果&lt;/p>
&lt;h1 id="github">GITHUB&lt;/h1>
&lt;p>&lt;strong>求 star&lt;/strong>&lt;br>
&lt;a href="https://github.com/Abbbbbi/Frida-Seccomp" target="_blank" rel="noopener">https://github.com/Abbbbbi/Frida-Seccomp&lt;/a>&lt;/p>
&lt;h1 id="如何使用">如何使用&lt;/h1>
&lt;pre tabindex="0">&lt;code>pip3 install frida
python3 multi_frida_seccomp.py
&lt;/code>&lt;/pre>&lt;p>log 信息可以在 logcat 过滤 “seccomp” 查看&lt;br>
同时也自动保存到了「包名&lt;em>pid&lt;/em>时间戳」文件夹内（支持多进程）&lt;br>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://bbs.pediy.com/upload/attach/202203/903162_DSYWMSBGQMMVBJ8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;a href="https://job.kanxue.com/position-read-1104.htm" target="_blank" rel="noopener">【公告】看雪团队招聘安全工程师，将兴趣和工作融合在一起！看雪 20 年安全圈的口碑，助你快速成长！&lt;/a>&lt;/p>
&lt;p>&lt;a href="forum-161-1-117.htm">#基础理论&lt;/a> &lt;a href="forum-161-1-119.htm">#NDK 分析&lt;/a> &lt;a href="forum-161-1-125.htm">#HOOK 注入&lt;/a> &lt;a href="forum-161-1-126.htm">#系统相关&lt;/a> &lt;a href="forum-161-1-128.htm">#工具脚本&lt;/a>&lt;/p></description></item><item><title>某乎请求头签名算法分析</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E4%B9%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E4%B9%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTY3MTc2Mg==&amp;amp;mid=2247483704&amp;amp;idx=1&amp;amp;sn=8e08162f0768fa6a793de5d761eff369&amp;amp;chksm=c00d8d85f77a04939dd5ce0481c8a8ca4426c25c7a1cd037f4568803f479bef2b355b80e6ee5&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0201FpqYNSfgJft3lH6ugVUI&amp;amp;sharer_sharetime=1646873400933&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>小小白在这里给各位大佬拜个年了，祝各位大佬新年快乐，大吉大利，身体健康，技术更上一层楼&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文章中所有内容仅供学习交流，不可用于任何商业用途和非法用途，否则后果自负，如有侵权，请联系作者立即删除！&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="网站">网站&lt;/h2>
&lt;p>aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD90eXBlPWNvbnRlbnQmcT1weXRob24=&lt;/p>
&lt;p>加密定位&lt;/p>
&lt;p>需要分析的接口以及加密参数 x-zse-96 如下图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqP261tbMCynIBPQt7MibYoTg7w6oaJE391znh2kuGgvV1geA26cmTuicQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>直接搜关键字 x-zse-96，发现一个文件，点进去&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_jpg/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqianSPE7iccYfRAmChrT8Pb5fr7uh6ASNwrvuudHicaPP5kuOcTMMSkCGw/640?wx_fmt=jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>格式化后再搜索 x-zse-96，发现两个可疑入口，分别是这两个&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqibEE3P1z6zLKZgPX2wv25BwZxibQHQHV49ux1B4oKicGUEOnDou35IvUA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqsyAnqgTljo9eq82vpN3EsulzjxAFK65IoLJQlibFoRrcg2cF5dwaWVQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>重新刷新网站，可以看到断点断在下图这个地方，选中执行函数可以发现加密入口就是这里&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqibF7O8e1MYGeHWDJ30Anzhbuc3RVVjSRJK0xLEyfJwiaMZqkXwc7l4Ow/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>加密分析&lt;/p>
&lt;p>s 明文数据：&lt;/p>
&lt;pre tabindex="0">&lt;code>s = &amp;#39;101_3_2.0+&amp;#39;(版本号) +
    &amp;#39;/api/v4/search_v3?t=general&amp;amp;q=python&amp;amp;correction=1&amp;amp;offset=0&amp;amp;limit=20&amp;amp;filter_fields=&amp;amp;lc_idx=0&amp;amp;show_all_topics=0&amp;amp;search_source=Normal+&amp;#39;(接口后缀) +
    &amp;#39;&amp;#34;AIAf1GdgbRSPTtoYPsJrpvRp_MB-_8SxwGQ=|1643717522&amp;#34;&amp;#39;(dc0 cookie)
&lt;/code>&lt;/pre>&lt;p>第一层加密&lt;/p>
&lt;pre tabindex="0">&lt;code> l()(s) = &amp;#39;7dd6414484df2c210ddbb996c55cf64c&amp;#39; -&amp;gt; md5_str
&lt;/code>&lt;/pre>&lt;p>根据 js 逆向的一些小经验，32 位密文很容易想到 md5 签名加密，拿到在线 md5 加密测试网站去试试&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqmDktpMQiakWPUtWAbZ5sxcHJV5hLXSXQuIs8WkHUz5WFRPJgViaImNpA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>perfect，完美对应上，由此可知，第一层加密就是原生的 md5 加密&lt;/p>
&lt;p>第二层加密&lt;/p>
&lt;pre tabindex="0">&lt;code>a()(md5_str) = &amp;#39;a0xqSQe8cLYfSHYyThxBHD90k0xxN9xqf_tqr6UqH9Op&amp;#39;
&lt;/code>&lt;/pre>&lt;p>选中 a()，点进去，会进入到这个函数，加密参数正是第一层加密得到的 md5 字符串，如图所示&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqicQ18dvO6q7hh3Nkh67FnK8N4pezrRpR6Q3MJLlnaIzCyk8gzwz8exQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后就单步跟，跟到这里就先别跟了，这里正是 jsvmp 循环一条条执行指令的地方，下面的代码会根据时间来检测调试&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqElkf0BictGG3jAZ4xicVZmX4icAyibp5yUMH2puf8pBHBZfyx6Od8Jiboqg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后就在 35865 行打上 log 输出断点，把 this.C 索引值跟 this 对象里面的值都给打印出来，注意要把 window 除去，不然会缺数据，索引值方便后序调试可用&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;索引：&amp;#34;, this.C, &amp;#34; 值：&amp;#34;, JSON.stringify(this, function(key, value) {if (value == window) {return undefined} return value})
&lt;/code>&lt;/pre>&lt;p>慢慢等待输出结束，掉头发的逆向之路就可以开始了&lt;/p>
&lt;p>直接在输出的 log 日志里面搜索加密生成的密文&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqqBedKV7Or179TRnwf5tVblVYTiaTyNb7PV77MgliaT6HTExzPCc40BxQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个 vmp 生成的加密参数是分成 11 组来计算的，每 4 个一组&lt;/p>
&lt;p>这里面有一个固定不变的字符串，就是这个玩意&lt;/p>
&lt;pre tabindex="0">&lt;code>fix_str = &amp;#34;RuPtXwxpThIZ0qyz_9fYLCOV8B1mMGKs7UnFHgN3iDaWAJE-Qrk2ecSo6bjd4vl5&amp;#34;
&lt;/code>&lt;/pre>&lt;p>拿第一部分 a0xq 举个例子，看看他是如何生成的，其他的都差不多&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqnkKicqyvUDjf4jEiabbYtHe2hiaUEQzBzryR0w5E5nm82QibjU7iciaeuhEQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>fix_str[13] = &amp;lsquo;q&amp;rsquo;&lt;/p>
&lt;p>q 就是这样来的，每一个字符都是通过索引那个固定字符串得到的，所以，接下来，就该来寻找索引下标是怎么生成的，向上寻找，看到这个&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPq2WS6CopzpBAXicVGIhzONuUCJmzMy6HtU6VNs6eicyLmwibk4ORLs4vSQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>3433258 &amp;raquo; 18 = 13&lt;/p>
&lt;p>这里的 18 是固定的，其实判断是不是固定的数字，只需要对比两个控制台里面 log 输出的对应分析就可以很清楚的知道哪些是固定不变的了&lt;/p>
&lt;p>再来搜索 3433258 这个数字怎么来的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqGCD3GB5xTEDU7sYdxKozljpbPYJvrDONwBqia4eD90drKfic4lfiaAhoQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以很清晰的看得到，下面这几种运算都可以得到这个数字，那怎么判断是哪一种运算得到的，我的办法是：调试&lt;/p>
&lt;pre tabindex="0">&lt;code>1. 25386 + 3407872 = 3433258
2. 25386 ^ 3407872 = 3433258
3. 25386 | 3407872 = 3433258
&lt;/code>&lt;/pre>&lt;p>重新打开一个浏览器打开链接，在 log 输出相同地方换上一个条件断点，断点的条件是 this.C = 342，具体跟进去看看他到底是进行的什么运算&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqPFfM2tE8tHVwt5WCCUs24IVqL0fplic07c9KSzCkia2Sv1Xib29vOeBBg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里这一步我就直接说了，是第三种，| 运算得到的，知道运算符之后，又要去分析两个参与运算的值是怎么得到的，这里就需要慢慢去一步步去逆向搜索分析了，所有参与运算的值都可以用这种同样的方法搜索分析得到&lt;/p>
&lt;p>这部分所有的运算流程都在下面了，请各位大佬们自行慢慢对比 log 输出去参悟，理解&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqlSua5j0qpucYCb4k33FK0eVLwQfYPCdy6KYj55phlME30owTVAnVaw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后验证：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqJzhLgSsIW2WyP9xgeOPovrUIrwJibwkGuVO81toNlGI3dJu2EQVNTrg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqic5ibgIQVlBOjYKCP6VTalmSUMUrxLsXv5P5c2T76feqnZmDyHhaW45A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以发现，算法还原下来只有短短的 50 几行，而且最后本地生成的加密参数跟浏览器生成的完全一致，完结撒花
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqqozA2Q2bROFIyQf9pNECcly4F8z9gvicniciagmbt63mYSdsBKFfyDxFw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqqozA2Q2bROFIyQf9pNECcly4F8z9gvicniciagmbt63mYSdsBKFfyDxFw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/EiaqCy3pb5k3LlZI6mUqIP5k6v7cPBHPqqozA2Q2bROFIyQf9pNECcly4F8z9gvicniciagmbt63mYSdsBKFfyDxFw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>某咖啡 app 加密参数分析进阶版</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E5%92%96%E5%95%A1-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6%E7%89%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E5%92%96%E5%95%A1-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6%E7%89%88/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzIxOTQ1OTA0Ng==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=dab3441a211bc568bcc8a94a34857e1f&amp;amp;chksm=97dbbf8da0ac369b34ff82796b00273fb2f9e397b31c98d4a1ecfc2aac6f7bdc2d4a305cda35&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0302sQN7FCkfK824hr7fDsXH&amp;amp;sharer_sharetime=1646203681892&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>仅供学习研究 。请勿用于非法用途，本人将不承担任何法律责任。&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>app 某某咖啡&lt;/p>
&lt;/li>
&lt;li>
&lt;p>v4.4.0&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="mitmproxy-抓包">mitmproxy 抓包&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicjccdL8L6WkeY7vEMaLCr1qqmXxYNVG2hZ8tWGuwfPHibNiahSpv0USvg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="java-分析">java 分析&lt;/h2>
&lt;p>定位到 CryptoHelper 类的名为 md5_crypt 的 native 静态方法。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicqUbian9FmyyvYBHN3T4SJ9NiaHicSicklDq0hkqqicNZBuTp5F1uVx6WDxQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="frida-hook">frida hook&lt;/h2>
&lt;p>脚本如下所示&lt;/p>
&lt;pre tabindex="0">&lt;code>function hook() {
    Java.perform(function() {
    var CryptoHelper = Java.use(&amp;#39;com.l*****e.safeboxlib.CryptoHelper&amp;#39;);
    CryptoHelper.md5_crypt.implementation = function (x, y) {
        console.log(&amp;#39;md5_crypt_x&amp;#39;, bytes2str(x));
        console.log(&amp;#39;md5_crypt_y&amp;#39;, y);
        var result = this.md5_crypt(x, y);
        console.warn(&amp;#39;md5_crypt_ret&amp;#39;, bytes2str(result));
        return result;
        };
  }
  }
&lt;/code>&lt;/pre>&lt;p>我们可以看到，hook 的结果和抓包结果一致&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpiczCo3k1WFSYeef3I3fgoyicnAtoWejRBP2tk2OjCtSV0mo5UvYDQlmFA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="so-分析">so 分析&lt;/h2>
&lt;p>使用 lasting-yang 的脚本 hook_RegisterNatives&lt;/p>
&lt;p>脚本地址：https://github.com/lasting-yang/frida_hook_libart&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicZRkq410XCxicOhDf5L8v8O5MwBlxPWYCIHfOEibh2caJdZCk17hApdgw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>使用开源的 cutter 到 so 去一探究竟，我们搜索上图中的偏移 0x1a981，来到 android_native_md5 函数。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpiclwgufef4e9yAbO66DcRMPa0PrND9Meh91VOswzWJJefaic4EEqM56AA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>经过一番分析，应该是 md5 加密完之后，还有一个 bytesToInt 的逻辑。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpic850QMsGxmicFMuEbrKnmlQKcttaf9OJ2LIRqGMMOEDKaI5fX639yOuA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="unidbg">unidbg&lt;/h2>
&lt;p>去年的文章里用 frida 就能搞定了，这次我们用 lilac、qinless、qxp 等大佬极力推荐的神器 unidbg 进行辅助分析。&lt;/p>
&lt;p>首先是搭建架子&lt;/p>
&lt;pre tabindex="0">&lt;code>package com.*;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Module;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.array.ByteArray;
import com.github.unidbg.linux.android.dvm.array.IntArray;
import com.github.unidbg.linux.android.dvm.wrapper.DvmInteger;
import com.github.unidbg.memory.Memory;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
public class Md5Crypt440 extends AbstractJni {
    private final AndroidEmulator emulator;
    private final Module module;
    private final VM vm;
    public String apkPath = &amp;#34;/Users/darbra/Downloads/apk/com.*/temp.apk&amp;#34;;
    public String soPath2 = &amp;#34;/Users/darbra/Downloads/apk/com.*/lib/armeabi-v7a/libcryptoDD.so&amp;#34;;
    Md5Crypt440() {
        emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&amp;#34;com.*&amp;#34;).build();
        final Memory memory = emulator.getMemory();
        memory.setLibraryResolver(new AndroidResolver(23));
        vm = emulator.createDalvikVM(new File(apkPath));
        vm.setVerbose(true);
        vm.setJni(this);
        DalvikModule dm2 = vm.loadLibrary(new File(soPath2), true);
        dm2.callJNI_OnLoad(emulator);
        module = dm2.getModule();
    }
    public void call() {
        String methodId = &amp;#34;md5_crypt([BI)[B&amp;#34;;
        DvmClass SigEntity = vm.resolveClass(&amp;#34;com/luckincoffee/safeboxlib/CryptoHelper&amp;#34;);
        String fakeInput1 = &amp;#34;cid=210101;q=j***=;uid=***&amp;#34;;
        ByteArray inputByteArray1 = new ByteArray(vm, fakeInput1.getBytes(StandardCharsets.UTF_8));
        DvmObject ret = SigEntity.callStaticJniMethodObject(
                emulator, methodId,
                inputByteArray1,
                1
        );
        byte [] strByte = (byte[]) ret.getValue();
        String strString = new String(strByte);
        System.out.println(&amp;#34;callObject执行结果:&amp;#34;+ strString);
    }
    public static void main(String[] args) {
        Md5Crypt440 getSig = new Md5Crypt440();
        getSig.call();
        getSig.destroy();
    }
    private void destroy() {
        try {
            emulator.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code>&lt;/pre>&lt;p>值得注意的是，这个 app 不用补任何环境，非常轻松地就运行出了结果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpic9bNKxxFpZ0EQ6VLKPT2GcHz9ficdbkPCQgrBkNjljLhGIxpmicj3paVg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>结果和抓包、frida 完全一致。&lt;/p>
&lt;p>我们在 md5 函数打个断点。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicq13rMv8DMjy2rUIbKhFY0AvypXt4bOxaeiavy519N8DM1Z5yDeHjPIw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;pre tabindex="0">&lt;code>public void HookByConsoleDebugger(){
    Debugger debugger = emulator.attach();
    debugger.addBreakPoint(module.base+0x13E3C);
}
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicW9iaUZoVjarou5mHG56Hy7pj8qiapAQJDZ09eft7oKuaicIVlzJFIU2kg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>输入 mr0，我们可以看到第一个参数就是明文，但不够完整。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicBCgITQmoibrLF7ianKHamPThz18PoaRfP9g2WcjiaE3fGGFuLJEAl7icdA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>接着输入 mr0 0x100，后面可以跟的是大小。我们欣喜地发现，之前的那坨明文后面加了个 salt 值，d******9&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpiciaeiaQ5Vpvo7VMicG4CicZR1hSNn7Ds2BYPgXVxMibqjT6ZSzMMoJpoErng/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>参数 2，r1=0xef=239，我们去 cyberchef 看看这个明文长度是否为 239&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicIKpTN1BuXD6VBx36418grWJXPZDndO8XKpxsZia0lEnHVByhWsmAMFg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>果不其然是的。&lt;/p>
&lt;p>接着输入 mr2，查看第三个参数。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicrwU6C0lviaAAaEQh478y7Uz1QVjsSNgnGe3p0OBmMcZDBvVYLQAHdSw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看情况参数 3 不出重大意外是 buffer，所以我们需要 hook 它的返回值。在这里我们先记下 r2 的地址 &amp;mdash;&amp;raquo;&amp;gt; 0xbffff5d8。&lt;/p>
&lt;p>我们使用 blr 命令用于在函数返回时设置一个一次性断点，然后 c 运行函数，它在返回处断下来。&lt;/p>
&lt;p>接着输入刚刚记录下来的 m0xbffff5d8&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1acjmOUUvfhcLB6de0OCba2n84qxWpT7NO89jsib4bVGLibwNW3TWYSOxYCl1iar6GL0ahdNfxXJGjCg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们去 cyberchef 进行验证，完全正确！&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1awrIic90ricvhRkstywCbTpicibEoicicuu5cFk4BL0znibUqFbD54whFmqbCokXtwhBiaib04icePuDSIbn9A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>md5 步骤解决了，接着查看 bytesToInt。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1acjmOUUvfhcLB6de0OCba2TZCPPyxnzpJSAN3qdXpwWxU6hWl85FGxlCd83bmIL2y2gtIZoBpugA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们在 0x13924 那里进行 hook 操作&lt;/p>
&lt;pre tabindex="0">&lt;code>public void hookBytesToInt() {
        IHookZz hookZz = HookZz.getInstance(emulator);
        hookZz.wrap(module.base + 0x13924 + 1, new WrapCallback&amp;lt;HookZzArm32RegisterContext&amp;gt;() {
            @Override
            public void preCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
                Inspector.inspect(ctx.getR0Pointer().getByteArray(0, 0x10), &amp;#34;参数1&amp;#34;);
                System.out.println(&amp;#34;参数2-&amp;gt;&amp;gt;&amp;#34; + ctx.getR1Int());
            };
            @Override
            public void postCall(Emulator&amp;lt;?&amp;gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) {
                System.out.println(&amp;#34;返回值-&amp;gt;&amp;gt;&amp;#34; + ctx.getR0Int());
            }
        });
    }
&lt;/code>&lt;/pre>&lt;p>我们看一下输出结果了，四个输出值都能对应上最后的 sign 结果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1acjmOUUvfhcLB6de0OCba29YghiaA0PWIXmASUOicKMIgOLY6kLJl207b8zFnDicHCY9qfvcRPxCTfA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其中的正负号处理应该是对应的如下逻辑&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1acjmOUUvfhcLB6de0OCba2rK63Wl0ibewXSvHz4eV5ZELhO5fkJSkiaJxXN7WBPMWibibeEW9VmtOv3A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们写个小脚本还原下，与之前的抓包、frida、unidbg 都一致，大功告成。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/8ib9picwJag1acjmOUUvfhcLB6de0OCba2T5AuxrMzyOuXw7EZBnHfG3nuTXKO9HoiayBibqDKZwp8MorOaKwW4T5Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在本人 github.com/darbra/sign 有更多的一些思路交流，如果对朋友们有所帮助，不甚欣喜。&lt;/p></description></item><item><title>逆向分析反调试 + ollvm 混淆的 Crackme</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95-+-ollvm-%E6%B7%B7%E6%B7%86%E7%9A%84-crackme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95-+-ollvm-%E6%B7%B7%E6%B7%86%E7%9A%84-crackme/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzUxMjE3Nzc3Mw==&amp;amp;mid=2247484051&amp;amp;idx=1&amp;amp;sn=967c66798db322e049a1548eb4af3131&amp;amp;chksm=f9692191ce1ea887861845a74f73b46ad24c32b91d5e337e46c14de0b8ac0b7a5bce5155d9fe&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0302JrksiN3jOHoRNvUMAIWI&amp;amp;sharer_sharetime=1646204024692&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>    最近学了点 ollvm 相关的分析方法, 正好之前朋友发我一个小 demo 拿来练练手.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5ibCiaXqPAKcsrib2lgxrAEqRdia2uVMFF8WY2obaW9cG0YdibnPam7gY1gA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    看上去很简单 就是找 flag 用 jadx 打开发现加壳了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5ickQcQc8PWLakzy75BW2hYjqTibBHZPqLRibWkXb2LbYHfH4bwBYIibIXQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    然后想试试直接用 fridadexdump 脱壳的时候发现 frida 上就崩了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5DehcibeZ27XEcibnc7dd6D6MS6O2wrUapMl2MDPRnwGgSshWiaOl1kFoQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    上葫芦娃的 strongfrida 直接重启了!&amp;hellip;.&lt;/p>
&lt;p>    这只能去过反调试了, 打开 so 找了下. init 和. initarray(反调试常见位置, so 比较早的加载时机)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V58lVHF7KIBcAFJVWBP3k9vpsvf0GtKjR3YaDujibnmLrD8JhOf2xeHWg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    ctrl+s 打开 initarray 里面有两个奇怪的函数 decode, 这就是 ollvm 默认的字符串加密&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5KPTdaibwIw0tKtvrMibowyBBXVyD3YQHib7AhJsW5Tlic11icqF8wOplMIA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    导出函数中搜索 init 找到里面也有函数定义, 创建了一个线程执行反调试函数, 进入这个函数看到字符串都被加密了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5gCWsexicez4OjpgCBMXJ2CVWlvbzy25OYD3ictaZ0ic6JKxS5huqCy6HQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    看了下代码 有个 kill 函数, 一开始就 hook kill 函数不让他自杀, 发现没用&amp;hellip;&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5GkT8IVsjdv49BQGaZCjEM0n0jOtdHJ1ibToiao3LG5DGcz64mibNcjAOQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    然后我继续找了下发现有个 strstr 函数 这有点可疑, 拿来比较字符串的, 直接 hook 一波&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5vpjD5GNPuiacZIdcicwmicQYCiakCgjicV4cricNzJkLPvnwTAcOJrn5KsjQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    从代码中得知 str2 是我们要关心的对象, 是个 char * 类型直接 readCstring 打印&lt;/p>
&lt;p>    然后发现出现很多 frida 然后进程就崩了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5iadHgKkzm4fNrLYXiavhZ7T8OUaTRHhGu5pFDORMPicrkrCG4jvsHic3Vw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    所以接下来就有两种方法 直接 hook pthread 不让这个线程起来 和 hook strstr, 我这就直接 hook str 了.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V508Sj9MPCkZNrRIsTgTyw0hwjVbheSU9qQy0ngia2B3VUhYiaaMficnhoQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    然后就不崩了, 可以愉快的 frida 了~&lt;/p>
&lt;p>    先拖个壳, Fridadexdump 一波 (可以直接 fart 脱的全, 但是懒的刷机, 直接用这个了..),hook events 定位&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5V6spHicpuDWpAk92tpJACHNuVpm0dsRhaTUFjicQ2riaicNAgYw8R1s1sw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5YCWmCGiclOcJic13XsJqEN5rNkylqOqBtIrEJAHxrttZWpQCen0edCXA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    oncreate 直接是 native 化了 应该是 360 的 vmp, 这里肯定不是让你逆 360 的 vmp, 盲猜一波就是 check 方法, 先 hook 一下.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V53IZQr0nYInQrJyFXq0HajQtia64HM9sw5YRmX0b6iaLBPxmjcY04NuFA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    直接返回 false, 应该是 true 就会拿到 flag, 为了不每次都手动输入 直接写个主动调用.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5icvqImdg12BtYSbSeHmtXjLx7AWzMCbqBujUibggyasV1DQC2ktFZn0Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    接下来去看 so 了, 导出函数就这几个.. 肯定是动态注册, 先直接 hook&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5L2pwojyHxz4OicTW7n68ANsdtqBm2E1SpZuZC9H9UfChicnmqEW4mbiaA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V53xk5eYAHJdlrtraMb1qNz1kpuHDQQADpIqNDTskMjkqRdjxJ0B06pg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    hook 到了偏移, 去 so 看一下&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5GPASEJotibrHGFmm6oHc66eNKpXc8FUliaecuiadwPCwwEQTuM9rbbJxw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    改了些名字后 操作流程就是将输入的 jstring 转为 char* 然后判断长度是否为 20 看到很多都是 unk_开头的, 这些就是被 ollvm 加密后的字符串, 要怎么看他解密后的内容呢? 因为他加载到内存的时候肯定是解密状态, 直接读这个地址打印 cstring 就可以得到解密后的字符串了.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5QmF37PaDev6IvFwF01npBKuibI9a4TL6hAr8Im8gft6yEVEdT8vJbYw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    然后继续改名, 改完名字就是这样&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5ve5BvsHOtyvdcYKLxPcFNXUOGH4k88XD0VkZ1ANJMiciawQibns1wJsOQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    发现他重新对 check 的方法进行了动态注册, 然后 sub_1234 里面也进行了动态注册里面嵌套了好几次动态注册, 然后用 strcmp 比较 输入的值和 &amp;amp;unk_5100(解密后为 kanxue) 如果相等那就返回 true. 但是输入要 20 个字符 kanxue 只有 6 个字符, 我们 hook 一下这个比较的地方看看,&lt;/p>
&lt;p>    直接 hook strcmp 蹦的比较厉害, 我选择 inlinehook, 按 tab 切换到汇编, 打开 opcode,s1 的值给到了 R0 我选择在 0x1564 进行 hook, 因为是 2 个 opcode 所以为 thumb 指令, 需要地址 + 1&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5kAsQ41iaghSeT1weTBaJ9PyeExM2icgIn45Qyv9yNmbsoWckPwp8xVlg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5x18joVCW7ZhUNbyEzje1oIygzAPxSYF162wNyoUxRFk53cNbwGYBrw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5Vjz5RaRQticxKETWhMc6DZmDYZPJI24ZqCINgwN9UtAxHOByjuedOlw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    我们输入了 kanxue00000000000000,hexdump 打印 s1, 发现 s1 就是 kanxue, 但是程序没提示通过, 然后 hook registernative hook 到他又进行了 2 次动态注册, 根据这个地址 我们往前找&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5UfWl8n0Eian5s9LEGSibVWtibEBJaQT2pBkqQ9fG1hau7Ie8C6zUlU71Q/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5fPsvHdDkvw0DnFIbibZ0BKgp7FYZtuwz1SMaicxOsvrkAFaU3hTBoQsQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    发现第二次动态注册的和最开始的代码很像, 第三次就短了很多, 然后仔细一看第二次动态注册中又注册了 sub_1148, 原来就是嵌套了 3 次动态注册, 注册了 3 个函数, 根据一开始的分析 对 strcmp 这里的字符串解密&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5icqp3Uucia5qQ9qI5icdIwVmJjluiaznjbWqxickDj9zO9viaf73AFx4L6tg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后分别 inlinehook 剩下几个 strcmp 验证下!&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5EXXagDTuNNX2R25qw4lQEevAHQB9augyp6XlscIbQI0zSvKz4nQH5g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    发现第二次比较是输入的 8 个 0 这样区分不了是第几个输入, 我们用 abcd 来实验, 输入 kanxueabcdefghieklfn 20 个字符&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5rT32Kzc0KrusvQCXLhu80IWhhBoEUSenmyDK4DDoX1g0EQ2uiakm8xg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    是 abcdefgh 这 8 个, 所以是加到 kanxue 后面的, 然后真正的字符串之前我们已经解密了, 是 unk_50F7(即为 training), 然后后面猜也猜得到剩下 6 个字符是之前解密的 unk_5096(即为 course) 为了保证严谨性, 我就在 inlinehook 一次&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5dricfDbxuF8qt2mYfL2LcsILHsRjE76QQZJesPVAZsNibDJvJpRvhAzQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    果然就是我们最后六位进行比较 所以答案前面的解密的字符合起来, 就是 kanxuetrainingcourse&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5sx24KmxUY18Z4icG6OHQricRUYZiaqoBow3EroiblAkXLKdq1amPqnFe6g/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/J7WeDiaX8bpQs6E5OK6eLtbgvvYxp95V5KQEm4z50x8KLbg8bywfMOicgphTLlicqX8E9fK2nF8eRAybUUiaaiaqxpA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>    这里有个 bug 每次输错都要重启一次, 不然到最后答案就变成 course 或者 trainingcourse 了~&lt;/p></description></item><item><title>爬虫之 - 某生鲜 APP 加密参数逆向分析</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E7%88%AC%E8%99%AB%E4%B9%8B-%E6%9F%90%E7%94%9F%E9%B2%9C-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E7%88%AC%E8%99%AB%E4%B9%8B-%E6%9F%90%E7%94%9F%E9%B2%9C-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://www.yuanrenxue.com/app-crawl/app-crawl-1.html" target="_blank" rel="noopener">www.yuanrenxue.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文是跟我学习爬虫的小伙伴：彭良怀的投稿，稿费是 500。&lt;/p>
&lt;/blockquote>
&lt;p>PS：他在北京，有看上的老板可以私信我，为人也不错。&lt;/p>
&lt;p>学了一段时间 APP 逆向，刚刚入门，我以某生鲜 APP 为例，记录一下逆向过程和一些知识点。为了不影响对方的利益，我文中特意隐去了该 APP 的名字信息，本文仅供学习交流，请勿用作其他用途。&lt;/p>
&lt;p>使用到的工具如下：&lt;/p>
&lt;ul>
&lt;li>一部 root 后的安卓手机，模拟器也可以&lt;/li>
&lt;li>抓包工具：Charles&lt;/li>
&lt;li>查壳工具：APK Messenger&lt;/li>
&lt;li>APK 反编译工具：jadx-gui 1.1&lt;/li>
&lt;li>SO 文件分析工具：IDA_Pro_v7.0&lt;/li>
&lt;li>Hook 框架：frida&lt;/li>
&lt;/ul>
&lt;h3 id="二抓包分析">&lt;strong>二、抓包分析&lt;/strong>&lt;/h3>
&lt;p>首先手机配置好代理，打开 APP，用 Charles 抓一下包，还好直接就抓到了，如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress10-1582206573.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到很多的请求参数，翻页再抓包一次，把两次抓到的参数进行比对，看看哪些参数固定，哪些是变化的。这么多参数，要是自己用肉眼看，那就太费劲了，而且还容易看漏，所以直接用在线文本对比工具吧，我用的是这个网站：https://qqe2.com/word/diff，把两次抓包的参数复制上去，如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress1-1582206574.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>不同的参数都高亮出来了，一目了然。我简单分析如下：&lt;/p>
&lt;ul>
&lt;li>signKey：密文，长度 32 位，可能为 MD5、HmacMD5 加密或随机 UUID&lt;/li>
&lt;li>signKeyV1：密文，长度 64 位，可能为 SHA256、HmacSHA256 加密&lt;/li>
&lt;li>t：13 位时间戳&lt;/li>
&lt;li>traceId：等于 deviceId （固定的设备 ID）加两个 13 位时间戳&lt;/li>
&lt;li>currentPage：页码&lt;/li>
&lt;li>lastStoreId：上一页最后一家店铺 ID&lt;/li>
&lt;/ul>
&lt;p>其他固定参数很好理解，我就不阐述了。通过模拟请求验证，修改任意参数的值都无法获取数据，所以推测 signKey 和 signKeyV1 是由其他请求参数加密生成的。那接下来就去看看 java 代码吧。&lt;/p>
&lt;h3 id="三java-层分析">&lt;strong>三、Java 层分析&lt;/strong>&lt;/h3>
&lt;h4 id="1-查壳">&lt;strong>1. 查壳&lt;/strong>&lt;/h4>
&lt;p>在反编译 apk 之前，首先查下壳，因为加壳（加固）后的 apk 直接反编译是看不到有用信息的。查壳工具很多，这里我使用的是 APK Messenger，打开后，直接将 apk 包拖入界面，即可看到有没有加壳，如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress8-1582206574.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>结果疑似无壳，接下来就可以使用 jadx 反编译 apk 了。需要注意的是，查壳功能的实现往往只是遍历 APK 内文件和目录，以加固厂商（腾讯、360、阿里、百度、梆梆等）的常用文件名作为判断特征，比如百度的加固一般在 lib 目录下有一个 libbaiduprotest.so 文件，但有可能人家使用了新的名字，所以查壳有一定的误判率。你还可以在 Apk Messenger 中查看、增加或编辑加固的判别特征。&lt;/p>
&lt;h4 id="2-分析关键-java-代码">&lt;strong>2. 分析关键 Java 代码&lt;/strong>&lt;/h4>
&lt;p>用 jadx 打开 apk ，反编译为 java 代码，然后按 Ctrl + Shift + F 全局搜索 signKeyV1，直接可以定位到如下代码：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress0-1582206574.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这段代码很好理解，明显是在组装参数，可以从中得出以下信息：&lt;/p>
&lt;ul>
&lt;li>t 为当前时间戳；&lt;/li>
&lt;li>subVersion 为当前 APP 版本号；&lt;/li>
&lt;li>signKey 是由 k 方法生成的；&lt;/li>
&lt;li>signKeyV1 等于 KEY_NEW_SIGN， KEY_NEW_SIGN 又是由 k2 方法生成的；&lt;/li>
&lt;li>传入方法 k2 的参数为 formatQueryParaMap 方法的返回值；&lt;/li>
&lt;li>方法 k 和 k2 都在 native 层，加载的是 libjdpdj.so 文件；&lt;/li>
&lt;/ul>
&lt;h4 id="3-分析-formatqueryparamap-方法">&lt;strong>3. 分析 formatQueryParaMap 方法&lt;/strong>&lt;/h4>
&lt;p>k 和 k2 都在 native 层，我们还是先看看 formatQueryParaMap 方法吧，按住 Ctrl 键同时鼠标左键点击 formatQueryParaMap 即可跳转到该方法，如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress5-1582206575.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这段代码也好理解，传入该方法的第一个参数为 Map 类型，类似 Python 中的字典，它先根据 key 进行排序，然后再把 value 用 &amp;amp; 字符进行拼接（functionId 的值除外 ），用 Python 代码实现如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>def formatQueryParaMap(param: dict) -&amp;gt; str:
return &amp;#39;&amp;amp;&amp;#39;.join(param[k] for k in sorted(param.keys()) if k != &amp;#39;functionId&amp;#39;)
&lt;/code>&lt;/pre>&lt;h4 id="4-hook-formatqueryparamap-方法">&lt;strong>4. Hook formatQueryParaMap 方法&lt;/strong>&lt;/h4>
&lt;p>如果看不懂或不想分析 formatQueryParaMap()  也没关系，我们直接用 frida hook 一下这个方法，看看它的输入和输出，也能反向推测出这个方法是做什么的，hook 代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>Java.perform(function () {
var util = Java.use(&amp;#39;jd.net.ASCIISortUtil&amp;#39;);
util.formatQueryParaMap.implementation = function (arg1, arg2) {
console.log(&amp;#39;param1: &amp;#39;, arg1);
console.log(&amp;#39;param2: &amp;#39;, arg2);
var result = this.formatQueryParaMap(arg1, arg2);
console.log(&amp;#39;return: &amp;#39;, result);
return result;
};
})
&lt;/code>&lt;/pre>&lt;p>打印结果如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress6-1582206575.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>很明显，param1 就是最开始抓包到的那些请求参数，那么我们就知道了方法 k2 的输入参数要怎么构造了，接下来分析方法 k 、 k2 是怎么加密的，就不得不分析 .so 文件了。&lt;/p>
&lt;h4 id="5-关于反调试">&lt;strong>5. 关于反调试&lt;/strong>&lt;/h4>
&lt;p>这里提一下，该 APP 有反调试，开启 frida-server 后 ，启动 APP 就立即闪退，可别急着去破解它的反调试，即找到反调试的地方干掉后重新打包签名，可这样做就很麻烦了，不知道得掉多少头发。还好，先启动 APP 等进入主界面后再启动 frida-server，就能正常进行 hook 了，虽然偶尔还是会被强制闪退，但频率不高，影响不大。&lt;/p>
&lt;h3 id="四native-层分析">&lt;strong>四、Native 层分析&lt;/strong>&lt;/h3>
&lt;p>通过 Java 层的分析知道 ，signKey 和 signKeyV1 分别是方法 k 和 k2 生成的，而这两个方法又是定义在 native 层的，那么就得先找到 k、k2 在 native 层中对应的函数，然后再分析具体的加密过程。为了便于理解，我先讲知识点，再讲操作。&lt;/p>
&lt;h4 id="1-静态注册和动态注册">&lt;strong>1. 静态注册和动态注册&lt;/strong>&lt;/h4>
&lt;p>因为 java 层和 native 层的代码往往相互调用，使用的是一种叫 JNI (Java Native Interface)  的技术，在 java 层中调用 native 函数之前, 要对 java 中 native 关键字定义的方法进行注册，注册方式有两种：静态注册和动态注册。下面简单介绍一下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>静态注册：&lt;/p>
&lt;p>静态注册是通过固定格式方法名进行关联，命名规则如下：&lt;/p>
&lt;blockquote>
&lt;p>native 函数名 = Java + 包名 + 类名 + 方法名&lt;/p>
&lt;/blockquote>
&lt;p>例如，包名: com.example.test，类名：jd.net.z，方法名：k&lt;/p>
&lt;p>如果是静态注册的话，那么 native 中的函数名就该为：Java_com_example_test_jd_net_z_k&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态注册：&lt;/p>
&lt;p>动态注册是通过 RegisterNative()  这个 JNI 函数动态添加映射关系来进行关联的，这种方式可以随便命名函数名，比较灵活。其申明示例如下：&lt;/p>
&lt;/li>
&lt;li>
&lt;pre tabindex="0">&lt;code>jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod* methods, jint nMethods)
&lt;/code>&lt;/pre>&lt;p>第 1 个参数是 JNIEnv 指针，所有 JNI 函数第一个参数都是它；&lt;/p>
&lt;p>第 2 个参数 clazz 是注册方法对应 Java 层中的类，由 FindClass 函数获取；&lt;/p>
&lt;p>第 3 个参数 methods 是一个数组，其中包含了注册方法结构体信息，我们可以从中找到注册前后的方法名，所以我们注意这个参数就行了；&lt;/p>
&lt;p>第 4 个参数 nMethods 是动态注册方法的数量。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="2-找到-kk2-对应的-native-函数">&lt;strong>2. 找到 k、k2 对应的  native  函数&lt;/strong>&lt;/h4>
&lt;p>知道了 native 函数的两种注册方式，那就开始具体的操作吧。用 IDA 打开 libjdpdj.so 文件，切换到 Exports 窗口，我们先按照静态注册的命名规则搜索：Java，并没有搜到，那么便是动态注册了。&lt;/p>
&lt;p>因为 JNI_OnLoad()  是加载 so 文件的初始函数，可以从中找到 RegisterNative()。那么搜索 JNI_OnLoad ，双击进入，按 F5 把汇编转成伪 C 代码，你会发现并没有找到 RegisterNative，别急，这是因为 IDA 不能准确的识别函数声明或变量类型，反编译不完全正确造成的，但我们可手动将其还原。&lt;/p>
&lt;p>凡是看到类似  (_(_DWORD _)v2 + 860))(v2, …)  这种代码的其实都是 JNI 函数，我们选中参数 v2 后按 Y 键会弹出窗口，输入 JNIEnv * ，点击 OK 即可还原函数名，还原后如下所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress5-1582206575.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>根据前面的介绍，我们只需要看第 3 个参数即可，双击  &amp;amp;off_117004 跳转到如下汇编代码：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress4-1582206575.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>从 117004 偏移量那一行开始，每 3 行为一个结构体，一共 8 个。我们看第一个，其第一行右边的注释 “k” 就是 java 层的方法名，第二行为 JNI 字段描述符，描述了该方法的参数类型和返回值类型，第三行就是我们要找的动态注册后的函数名，可以看到为：gk；同样的，”k2″ 对应的就是：gk2。&lt;/p>
&lt;p>搜搜看，这就很容易找到了：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress9-1582206576.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>不过有些 APP 为了防止被静态分析，对注册函数做了混淆，通过这种方式并不能直接找到，这里我就不讨论了，遇到的童鞋可以参考赵四这篇博客：http://www.520monkey.com/archives/1289&lt;/p>
&lt;h4 id="3-jni-静态调试的一些技巧">&lt;strong>3. JNI 静态调试的一些技巧&lt;/strong>&lt;/h4>
&lt;p>在分析 gk 函数之前我先谈谈静态分析 native 函数的一些技巧和个人经验。&lt;/p>
&lt;h5 id="1-批量还原-jni-函数名">(1) 批量还原 JNI 函数名&lt;/h5>
&lt;p>native 函数中经常会用到很多的 JNI 函数，而 IDA 并不能很好的识别，每次我们都要一个个手动修改未免太麻烦了点，所以我介绍一个可以批量转换的方式：&lt;/p>
&lt;ul>
&lt;li>按 Ctrl + F9 ，选择 jni.h 头文件导入&lt;/li>
&lt;li>导入成功后，鼠标左键点击其中一个 JNI 函数的参数，然后右键选择 Convert to Struct *&lt;/li>
&lt;li>在弹出的 Select a structure 窗口中 选择 _JNIEnv，点击 OK&lt;/li>
&lt;/ul>
&lt;p>这样就可以把当前打开的 native 函数里面所有 JNI 函数名一次性还原了。注意 jni.h 头文件第一导入会报错，需要根据报错信息修改 jni.h 对应的代码。&lt;/p>
&lt;h5 id="2-强制调出函数参数">(2) 强制调出函数参数&lt;/h5>
&lt;p>有时会遇到 IDA 反编译出来的函数连参数都没有，如下面的 GetArrayLength 函数后面的参数为空：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress3-1582206576.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这时需要鼠标左键点击该函数，然后鼠标右键选择 Force call type ，就能强制把参数调出来。&lt;/p>
&lt;h5 id="3-常用快捷键">(3) 常用快捷键&lt;/h5>
&lt;ul>
&lt;li>
&lt;p>shift + F12：查看 so 文件中所有常量字符串的值；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tab 键：汇编和伪 C 代码之间相互切换；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/ 键：添加注释；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>N 键：变量重命名；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>X 键：查看某变量的所有引用；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>= 键：消除冗余的中间变量；&lt;/p>
&lt;p>由于 IDA 反编译出来总是会有很多冗余的中间变量，如：&lt;/p>
&lt;p>v2 = v1;&lt;br>
result = encrypt(v2);&lt;/p>
&lt;p>选中 v2，按键盘上的 = 键，再点击 OK，即可消除中间变量 v2：&lt;/p>
&lt;p>result = encrypt(v1);&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="4-静态调试思路">(4) 静态调试思路&lt;/h5>
&lt;ul>
&lt;li>
&lt;p>根据函数入参，至上而下分析&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据函数返回值，至下而上分析&lt;/p>
&lt;/li>
&lt;li>
&lt;p>寻找关键的函数进行分析，一般可以把函数分为以下几种：&lt;/p>
&lt;p>① 标准库函数：如 strlen()，计算字符串的长度，见名知意；&lt;/p>
&lt;p>② JNI 函数：如 FindClass()，调用 Java 中的类，JNI 函数一般也是见名知意；&lt;/p>
&lt;p>③ 用户自定义的函数：如 MD5::MD5()，一看就知道是 MD5 加密，这类需特别注意；&lt;/p>
&lt;p>④ IDA 命名的函数：如 sub&lt;em>567C()，IDA 会对没有名字的函数自动命名，命名规则就是 sub&lt;/em> + 函数地址，这类函数也是重点。&lt;/p>
&lt;p>从追求效率的角度来说，最好先找关键函数，看看有没有常见的加密函数名，找到后直接用 frida hook，一些简单的往往能够一击中的，快速破解。从学技术的角度来说，可以多尝试一行一行代码地分析，锻炼看代码的能力。当然复杂点的还不得不分析 arm 指令，要是被混淆后就更加难了，难的我也不会，以后多练多学吧。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="4-静态分析-gk-函数">&lt;strong>4. 静态分析 gk 函数&lt;/strong>&lt;/h4>
&lt;p>接下来开始具体操作吧，双击 gk 函数后看到汇编 arm 指令，按 F5 键反汇编为伪 C 代码，并把 JNI 函数名还原。我这里就不一一分析每行代码了，直接先找关键函数，很容易就找到如下代码：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress6-1582206576.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>很明显是 MD5 加密，MD5Init()  是一个初始化函数，MD5Update()  才是 MD5 的主计算过程，所以直接 hook MD5Update() ，用 frida hook native 层函数得需要找到目标函数的绝对地址，而目标函数可能是导出函数，也可能是未导出函数，我先分别介绍一下怎么获取他们的地址吧：&lt;/p>
&lt;p>获取导出函数的绝对地址:&lt;/p>
&lt;p>// JNI_OnLoad 肯定是导出函数, 可直接根据名字获取&lt;/p>
&lt;pre tabindex="0">&lt;code>var onload_addr = Module.getExportByName(&amp;#39;libjdpdj.so&amp;#39;, &amp;#39;JNI_OnLoad&amp;#39;);
&lt;/code>&lt;/pre>&lt;p>获取未导出函数的绝对地址，我列举以下 3 种方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>方式一：&lt;/p>
&lt;/li>
&lt;li>
&lt;pre tabindex="0">&lt;code>var onload_addr = Module.getExportByName(&amp;#39;libjdpdj.so&amp;#39;, &amp;#39;JNI_OnLoad&amp;#39;);
var base_addr = parseInt(onload_addr ) - parseInt(&amp;#39;0x34D6C&amp;#39;);
var md5_update_addr = ptr(base_addr + parseInt(&amp;#39;0x34E18&amp;#39;));
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>方式二：&lt;/p>
&lt;/li>
&lt;li>
&lt;pre tabindex="0">&lt;code>var onload_addr = Module.getExportByName(&amp;#39;libjdpdj.so&amp;#39;, &amp;#39;JNI_OnLoad&amp;#39;);
var md5_update_addr = onload_addr.sub(0x34D6C).add(0x34E18);
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>方式三：&lt;/p>
&lt;/li>
&lt;li>
&lt;pre tabindex="0">&lt;code>var md5_update_addr = Module.findBaseAddress(&amp;#34;libjdpdj.so&amp;#34;).add(0x34E18 + 1);
&lt;/code>&lt;/pre>&lt;p>方式一看注释很好理解，方式二其实就是方式一的简化，用 frida 提供的的 add()  和 sub()  函数进行地址的加减。方式三是进一步简化，但是用这种方式一定要记得对地址 +1，为什么要 +1 呢？我引用赵四的原话解释吧：&lt;/p>
&lt;blockquote>
&lt;p>因为 thumb 和 arm 指令的区分，地址最后一位的奇偶性来进行标志&lt;/p>
&lt;/blockquote>
&lt;p>获取未导出函数地址的方式也完全适用于导出函数，所以不管导出还是未导出，我都用方式三获取，代码简单优雅。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>那么我们 hook MD5Update()  的代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>var pointer = Module.findBaseAddress(&amp;#34;libjdpdj.so&amp;#34;).add(0x34E18 + 1);
console.log(&amp;#39;MD5Update pointer:&amp;#39;, pointer);
Interceptor.attach(pointer, {
onEnter: function(args) {
console.log(&amp;#39;参数1:&amp;#39;, args[0]);
console.log(&amp;#39;参数2:&amp;#39;, Memory.readCString(args[1]));
console.log(&amp;#39;参数3:&amp;#39;, parseInt(args[2]));
console.log(&amp;#39;----------------&amp;#39;);
},
onLeave: function(retval) {
}
})
&lt;/code>&lt;/pre>&lt;p>hook 的时候我们同时对其抓包，以便验证，hook 打印的结果如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>MD5Update pointer: 0xaed5ae19
参数1: 0xbef0eb8c
参数2: {&amp;#34;city&amp;#34;:&amp;#34;重庆市&amp;#34;,&amp;#34;latitude&amp;#34;:29.57252,&amp;#34;longitude&amp;#34;:106.53355,&amp;#34;address&amp;#34;:&amp;#34;观音桥&amp;#34;, &amp;#34;coordType&amp;#34;:&amp;#34;2&amp;#34;,&amp;#34;channelId&amp;#34;:&amp;#34;4037&amp;#34;,&amp;#34;appVersion&amp;#34;:&amp;#34;7.4.0&amp;#34;,&amp;#34;platform&amp;#34;:&amp;#34;2&amp;#34;,&amp;#34;currentPage&amp;#34;:1, &amp;#34;pageSize&amp;#34;:10,&amp;#34;areaCode&amp;#34;:4,&amp;#34;ref&amp;#34;:&amp;#34;home&amp;#34;,&amp;#34;ctp&amp;#34;:&amp;#34;channel&amp;#34;}923047ae3f8d11d8b19aeb9f3d1bc002
参数3: 259
&lt;/code>&lt;/pre>&lt;p>—————-&lt;/p>
&lt;p>可以看到参数 2 为部分请求参数再上加尾部的盐值，这便是加密前的原文。我们把它拿去用 MD5 在线加密一下，其结果和抓包到的 signKey 进行对比，经验证完全相同，那么 signKey 被一击中的，具体的代码都不用去分析了。其实服务器并没有对该参数进行校验，我们直接生成一个随机的 32 位字符就行，我这里主要是讲一下方法。&lt;/p>
&lt;h4 id="5-静态分析-gk2-函数">&lt;strong>5. 静态分析 gk2 函数&lt;/strong>&lt;/h4>
&lt;p>然后再来看 gk2 函数，同样首先找有没有常见的加密，很快在最后几行看到如下代码：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress0-1582206576.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>很明显是 hmac_sha256 加密，看到它有 6 个参数，往上追溯可知，第 1 个参数 s 为加密前的字符串，第 2 个参数 v23 为 s 的长度，这里 v23 – 32 说明加密前需要去掉最后 32 个字符，第 3 个参数为密钥，第 4 个参数是密钥的长度，最后两个参数没有什么操作，不用管。那么我们就直接用 frida hook hmac_sha256 函数，打印一下参数看看，代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>var pointer = Module.findBaseAddress(&amp;#34;libjdpdj.so&amp;#34;).add(0x361B8 + 1);
console.log(&amp;#34;hmac_sha256 pointer: &amp;#34;, pointer);
Interceptor.attach(pointer, {
onEnter: function(args) {
console.log(&amp;#34;参数1:&amp;#34;, Memory.readUtf8String(args[0]));
console.log(&amp;#34;参数2:&amp;#34;, parseInt(args[1]));
console.log(&amp;#34;参数3:&amp;#34;, Memory.readCString(args[2]));
console.log(&amp;#34;参数4:&amp;#34;, parseInt(args[3]));
console.log(&amp;#39;---------------&amp;#39;);
},
onLeave:function(retval){
}
});
&lt;/code>&lt;/pre>&lt;p>hook 的时候我们同时对其抓包，以便验证，hook 打印的结果如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress3-1582206576-1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>参数 1 去掉末尾的 32 位字符就是入参，参数 3 是密钥，于是把入参拿去用 HmacSHA256 加密一下，其结果再和抓包到 signKeyV1 进行对比，经验证完全相同，由此 signKeyV1 也被一击中的。&lt;/p>
&lt;p>抱着学习的心态再去分析一下伪 C 代码，具体分析过程我就不介绍了，就说一下大致的逻辑：&lt;/p>
&lt;ul>
&lt;li>先调用 java 层的 getsign 方法获取基础 key，&lt;/li>
&lt;li>对基础 key 每个字符的 ASCII 码进行修改，同时拼接到输入参数的尾部，&lt;/li>
&lt;li>取出入参尾部的 32 位作为密钥，&lt;/li>
&lt;li>最后对输入参数进行 hmac_sha256 加密，通过指针返回加密结果。&lt;/li>
&lt;/ul>
&lt;p>逆向到这儿就结束了，后面用 python 实现不难，我就不贴代码了，关键过程讲清楚了就行。&lt;/p>
&lt;h4 id="6-native-函数的参数">&lt;strong>6. native 函数的参数&lt;/strong>&lt;/h4>
&lt;p>我再啰嗦一下，native 函数要比 java 层对应方法多 2 个参数，它们前两个参数是固定的，第 1 个参数为 JNIEnv 指针；第 2 个为 jobject 或 jclass；从第 3 个参数开始才是 java 层传递过来的。比如：gk()  函数的申明如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress9-1582206576-1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其中 a3 才是 java 层 k()  方法的参数。前两个参数之所以是 int 类型，前面也说过，是因为 IDA 经常不能正确识别参数类型，这里按 Y 键手动转换一下，或者直接忽略，没什么影响。&lt;/p>
&lt;h3 id="五总结">&lt;strong>五、总结&lt;/strong>&lt;/h3>
&lt;p>本篇文章的案例 APP 也是大厂开发的，而我们对其 java 层和 native 层的加密函数分析都不难，没有复杂难懂的逻辑，也没有混淆，只有个鸡肋的反调试，直接静态分析加 frida hook 就搞定了。其实目前市面上大多数 APP 的加密参数都能通过这种方式搞定，当然很难的也不少，学习逆向是个无底洞，但我们做爬虫的不要怕逆向，我们只是逆向它的那个加密参数而已，先要有信心，多学习多实操多总结，一点点深入，会学有所成。共勉！&lt;/p>
&lt;p>再次跨一下这篇文章，非常不错，继续接受投稿，稿费还不错 300-500 / 篇，快来投稿吧。&lt;/p>
&lt;p>PS，给自己广告一下：我继续在教爬虫，真正的爬虫技术。教 APP 逆向抓取 / JS 逆向抓取 / 大规模爬虫框架设计 / 利用爬虫技术做被动收入。&lt;/p>
&lt;p>感兴趣的加我微信私聊，备注：爬虫。&lt;/p>
&lt;p>最近打算建一个爬虫技术交流群，感兴趣的也可以加我。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://www.yuanrenxue.com/wp-content/uploads/2020/02/beepress7-1582206577.jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>深度剖析 ja3 指纹及突破</title><link>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90-ja3-%E6%8C%87%E7%BA%B9%E5%8F%8A%E7%AA%81%E7%A0%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90-ja3-%E6%8C%87%E7%BA%B9%E5%8F%8A%E7%AA%81%E7%A0%B4/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzU0MjUwMTA2OQ==&amp;amp;mid=2247484649&amp;amp;idx=1&amp;amp;sn=42eb5319db1ca830ca81d75218e4c0e4&amp;amp;chksm=fb18f54bcc6f7c5de60395d03650aa7c6a30e37407989c604c31ffa1076d071a32afcb0556c4&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0310Lj90mCDiRI2ZAIpqT7T4&amp;amp;sharer_sharetime=1646874335522&amp;amp;sharer_shareid=56da189f782ce62249ab4f6494feca50&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd" target="_blank" rel="noopener">mp.weixin.qq.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>是的，我重新发了，没想到一不小心就过了这么久了，发现这期间有天赋的大佬们现在对于 tls 指纹研究得比我还透彻了，真的强啊。有种感觉 tls 未来会出现一个单独的派系。&lt;/p>
&lt;p>文章较之前有部分改动，对理解 ja3 来说不影响的。因为某大佬看了我的文章后说我的方法其实不是完美突破，所以完美两个字没了。可能有朋友会说 &amp;quot; 你这不是在炒冷饭吗？没意思”，不不，完全没这想法。我想的是**：**&lt;/p>
&lt;p>&lt;strong>1. 为了留存备份，等我老了可以给子孙后代看，这个是我写的。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2. 以后大家不用再拿着那个 pdf 私下转发了。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>3. 之前明明答应过给朋友转载的，所以现在重发兑现下承诺。&lt;/strong>&lt;/p>
&lt;p>**4. 还是有些朋友一搞不定某站就说是 ja3 指纹，所以重发可以拿来参考下什么是 tls，现在用 tls 指纹的网站可真的不多啊。
**&lt;/p>
&lt;p>&lt;strong>5. 其实之前有几个朋友希望我能重新发且&lt;/strong>开启付费**，那就发吧，付费就没必要了，毕竟也不是靠这个过日子的。**&lt;/p>
&lt;p>之前发过 ja3 相关的文章可以作为初期了解：&lt;a href="http://mp.weixin.qq.com/s?__biz=MzU0MjUwMTA2OQ==&amp;amp;mid=2247484137&amp;amp;idx=1&amp;amp;sn=ccfa46a45a09e7fde284dfba281fd719&amp;amp;chksm=fb18f34bcc6f7a5d49ee3050887aa909708ede268cb5046bcd80d43ffdc7c9f948d428c65ec4&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JS 逆向之猿人学第十九题突破 ja3 指纹验证&lt;/a> ，再来看本篇文章，篇幅略长，如果赶时间的朋友，可以跳过接下来的理论概念介绍，可以直接从后面的【如何突破 ja3】开始看&lt;/p>
&lt;p>Official Account&lt;/p>
&lt;h2 id="到底什么是-ja3">到底什么是 ja3&lt;/h2>
&lt;h3 id="简介">简介&lt;/h3>
&lt;p>git:https://github.com/salesforce/ja3&lt;/p>
&lt;p>官方解释：&lt;/p>
&lt;blockquote>
&lt;p>JA3 是一种创建 SSL/TLS 客户端指纹的方法，它应该易于在任何平台上生成，并且可以轻松共享以用于威胁情报&lt;/p>
&lt;/blockquote>
&lt;p>更权威的介绍文章：https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967&lt;/p>
&lt;p>浓缩一下大概意思就是：&lt;/p>
&lt;blockquote>
&lt;p>JA3 是一种对传输层安全应用程序进行指纹识别的方法。它于 2017 年 6 月首次发布在 GitHub 上，是 Salesforce 研究人员 John Althouse、Jeff Atkinson 和 Josh Atkins 的作品。创建的 JA3 TLS/SSL 指纹可以在应用程序之间重叠，但仍然是一个很好的妥协指标 (IoC)。指纹识别是通过创建客户端问候消息的 5 个十进制字段的哈希来实现的，该消息在 TLS/SSL 会话的初始阶段发送。&lt;/p>
&lt;/blockquote>
&lt;p>这&amp;hellip;..，2017 年就有了，我是 2021 年才通过阅读青南大佬的文章知道有这么个东西。&lt;/p>
&lt;p>然后我猜，ja3 名字的由来，是因为有 3 个研究人员，且他们的姓名缩写都是 ja&lt;/p>
&lt;h3 id="ja3-的由来">ja3 的由来&lt;/h3>
&lt;p>其实，John Althouse 自己说过，官方解释：&lt;/p>
&lt;blockquote>
&lt;p>对这个 TLS 客户端进行指纹识别的主要概念来自 Lee Brotherston 2015 年的研究（https://blog.squarelemon.com/tls-fingerprinting/）和他的 DerbyCon 演讲（https://www.youtube.com/watch?v=XX0FRAy2Mec）。如果不是 Lee ，就不会有 JA3 的出现&lt;/p>
&lt;/blockquote>
&lt;h3 id="ja3-如何工作的">ja3 如何工作的&lt;/h3>
&lt;p>原文解释的很好了，官方解释：&lt;/p>
&lt;blockquote>
&lt;p>TLS 及其前身 SSL 用于为常见应用程序和恶意软件加密通信，以确保数据安全，因此可以隐藏在噪音中。要启动 TLS 会话，客户端将在 TCP 3 次握手之后发送 TLS 客户端 Hello 数据包。此数据包及其生成方式取决于构建客户端应用程序时使用的包和方法。服务器如果接受 TLS 连接，将使用基于服务器端库和配置以及 Client Hello 中的详细信息制定的 TLS Server Hello 数据包进行响应。由于 TLS 协商以明文形式传输，因此可以使用 TLS Client Hello 数据包中的详细信息来指纹和识别客户端应用程序&lt;/p>
&lt;/blockquote>
&lt;p>更多更专业的，如果很感兴趣，劳烦移步 John Althouse 发表的文章：&lt;/p>
&lt;p>&lt;a href="https://engineering.salesforce.com/open-sourcing-ja3-92c9e53c3c41" target="_blank" rel="noopener">https://engineering.salesforce.com/open-sourcing-ja3-92c9e53c3c41&lt;/a>&lt;/p>
&lt;p>感觉看了上面的话，是不是有点似懂非懂的感觉，没事，听我慢慢说，来个图吧，要来图的话，先来个三次握手的吧，老图了，相信各位朋友也都看烦了，我也看烦了，因为这图都传包浆了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqwECf0Z0zwKSbiatYPDkPRELcNIneuS2iasumIG676Picicpia1yBcPIqaZw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>详细的三次握手流程解释我就不说了，网上能查到的太多了，我就不献丑解释了，本篇文章的重点也不是它&lt;/p>
&lt;p>那么按照 ja 开发者自述，是在三次握手之后，客户端向服务端发起 client hello 包，这个包里带了客户端这边的一些特征发给服务端，服务端拿来解析数据包，然后回发一个 hello 给客户端，之后再进行 ssl 数据交互，下面这个图，就是 John Althouse 自己画的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_gif/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqc6R25IHBd7ORubcC0zHwGNqBKN3ibuhHI0pBGPaMNLr7pWibToTNzKIw/640?wx_fmt=gif" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>怎么说？画的很传神很易懂对吧？&lt;/p>
&lt;p>更多原文解释，请看这里：https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967&lt;/p>
&lt;p>John Althouse 有关 ja3 的 ppt 讲义，上面的动图就是 ppt 文件里的，费了老大劲搞到的：链接: &lt;a href="https://pan.baidu.com/s/1pfQwRwg3tbOT2Y2nQZYoAA" target="_blank" rel="noopener">https://pan.baidu.com/s/1pfQwRwg3tbOT2Y2nQZYoAA&lt;/a>   提取码: ptj6 （链接失效了可以联系我）&lt;/p>
&lt;h3 id="识别原理">识别原理&lt;/h3>
&lt;p>以下 John Althouse 的文章里的：&lt;/p>
&lt;blockquote>
&lt;p>1.JA3 不是简单地查看使用的证书，而是解析在 SSL 握手期间发送的 TLS 客户端 hello 数据包中设置的多个字段。然后可以使用生成的指纹来识别、记录、警报和 / 或阻止特定流量。
2.JA3 在 SSL 握手中查看客户端 hello 数据包以收集 SSL 版本和支持的密码列表。如果客户端支持，它还将使用所有支持的 SSL 扩展、所有支持的椭圆曲线，最后是椭圆曲线点格式。这些字段以逗号分隔，多个值用短划线分隔（例如，每个支持的密码将在它们之间用短划线列出）&lt;/p>
&lt;ol start="3">
&lt;li>JA3 方法用于收集 Client Hello 数据包中以下字段的字节的十进制值：版本、接受的密码、扩展列表、椭圆曲线和椭圆曲线格式。然后按顺序将这些值连接在一起，使用 “,” 分隔每个字段，使用 “-” 分隔每个字段中的每个值&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>其中第一条，也解释了我前一篇请求时尝试提交一个 ssl 证书为啥没有用的，第二条，服务端会在 3 次握手之后，收到客户端过来的 hello 包，然后解包，收集版本、接受的密码、扩展列表、椭圆曲线和椭圆曲线格式，在这时候就可以拿着 ja3 指纹去比对，哪些是限制了，哪些没有限制的，当确实有在限制名单里，就针对处理，当没有在限制名单里也返回一个 hello，接着再继续 ssl&lt;/p>
&lt;h4 id="ja3-已收录指纹--黑名单">ja3 已收录指纹 / 黑名单&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://sslbl.abuse.ch/blacklist/sslblacklist.csv" target="_blank" rel="noopener">https://sslbl.abuse.ch/blacklist/sslblacklist.csv&lt;/a>  这个没有更新了只有上百条&lt;/li>
&lt;li>&lt;a href="https://github.com/salesforce/ja3/blob/master/lists/osx-nix-ja3.csv" target="_blank" rel="noopener">https://github.com/salesforce/ja3/blob/master/lists/osx-nix-ja3.csv&lt;/a>   这个不是很全，只有上百条&lt;/li>
&lt;li>&lt;a href="https://ja3er.com/getAllUasJson" target="_blank" rel="noopener">https://ja3er.com/getAllUasJson&lt;/a>   这个一直在更新，十几万条&lt;/li>
&lt;li>&lt;a href="https://ja3er.com/getAllHashesJson" target="_blank" rel="noopener">https://ja3er.com/getAllHashesJson&lt;/a>  同上，只是给定标注字段不同&lt;/li>
&lt;/ul>
&lt;p>我猜测，ja3er.com 里的十几万 ja3 指纹，就是所有人访问过该网站的客户端（浏览器或者语言请求库）的指纹，有一条算一条的收集&lt;/p>
&lt;h3 id="案例解释">案例解释&lt;/h3>
&lt;p>前面说了一堆理论概念，我们做开发的，如果只有概念没有实操或者例子解释是不够的，所以，来个案例，还是猿人学 19 题，同时继续祭出 wireshark 方便分析，先浏览器访问网站，拿到 ip，&lt;strong>提示一下，你们可别拿着 ip 去干人网站哈，挺好的一个爬虫练习平台，否则后果自负&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqG9Dqax9hBj8iaQQxDT44g0WC1nRJ9ImscRtXDEic8lcIv5z10CeqGSag/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这边 wireshark 显示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqx7IGMblK3Oeicb0TbU8lEGDdZE6ZP6IyFotav9QyMKrt18WHyx0FWVg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>此时你会看到很多的数据数据包，过滤一下，直接在过滤器位置输入 ip.，就会有很多指令提示和历史记录&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqrYm2vZrH8carSDRRSfxnmv456DHNqQpVOlicAZa9Ie9ZLFIQrBLcUiag/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>全部的命令是啥意思这里就不多说了，更多的可以百度，只介绍几个这里会用到的命令：&lt;/p>
&lt;blockquote>
&lt;p>ip.dst_host 就是目标地址，这里你可以理解为就是访问网站的服务端地址&lt;/p>
&lt;p>ip.src_host 就是源地址，这里你可以理解为就是你正在操作的电脑的 ip，这个 ip 大多是局域网 ip&lt;/p>
&lt;p>ip.host 跟上面一样，但是不会区分是 src 还是 dst，只要有指定地址的都会过滤出来&lt;/p>
&lt;/blockquote>
&lt;p>给定过滤指令，回车，此时有可能你输入过滤命令之后，看不到有任何数据包，小问题，可能你打开 wireshark 完了，没抓到包，重新刷新下网页就行了，此时就看到如下的数据：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqPHBMgPmyn7iaW5CG59CYVq8u26ib3vNTRibmAoqSDzn3UBMcPGf2ibeAWw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>注意看，最开始的 6 个数据包就是上面说的流程，前三个是三次握手，第四个开始到第 6 个就是 ja3 的 hello 数据包，个人感觉这段过程也很像三次握手，再后续的数据包就是实质的 ssl 数据交互了，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqVS6uDnknFSc8WX2KxjGovK9tAUMqibK0vl9GwKNoe0Xk9H1NNVwhzyQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有了这个，看看 ja3 指纹到底是啥样的，双击这个 client hello，然后服务端返回的 sever hello 就不看了，此时不需要看，忘掉它吧&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqsU3W4YC5cgteqjRdWCsDEI13zMsbmuyCibY3PUd8rEPsj7WkZ6ibTTRw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>展开 client hello：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqlkn6eUymDqic6KHVgvDwoQSQpgiamPkBaJIsYQ6uicHcRichPicyNErGIBw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>滑到最后，就能看到 ja3 指纹了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqzcWwzuusORbJRicd7TlJU8agY5521Hb6lyR8UdlFE4o5fWX7n2B3oBQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后，看 JA3 Fullstring：&lt;/p>
&lt;blockquote>
&lt;p>771,43690-4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,64250-0-23-65281-10-11-35-16-5-13-18-51-45-43-27-17513-51914-21,51914-29-23-24,0&lt;/p>
&lt;/blockquote>
&lt;p>对应：&lt;/p>
&lt;blockquote>
&lt;p>TLSVersion,Ciphers,Extensions,EllipticCurves,EllipticCurvePointFormats&lt;/p>
&lt;/blockquote>
&lt;p>以【,】分割，第一个数，771，根据官方解释，就是 ssl/tls 版本，也就是这个：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqOsdGx3FXBjfq10pGicXWrG4KYzgJTNlNoI0Mm9CkLBVP5HJAX8XxWfQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>python 终端跑一下，0x0303 就是 771，对上了：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqg5tmajkAiayeYq8mWdhBYOc6iaTFzhV0pJQLwRlV3e5vdcs45GceiagfA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>后续的就不细说了，直接看&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqlslZwdjZzPf48XUcW8iaicHovINlsAdjgtoLnNbdyibSTwEjVgS3B40iaw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>ja3 图 1&lt;/p>
&lt;p>细心的你发现了，我截图这里是没有第四个数相关的套件，  但是 ja 自己的文章里是有第四个数 EllipticCurves 相关的：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqeB6dn9wcgPaFTjpvpKT4HrQbiaW9JybOXq2l48gclzcmsONkIQStctg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其实不是没有的，是现在第四个参数由 EllipticCurves 改成了 supported_groups&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqWa5sgggeMwViaXVUu47Olhiaiac2E5HYoSpHictHDhcqhSibambBrnztUdw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>ja3 图 2&lt;/p>
&lt;p>注：ja3 图 1 是公司电脑，ja3 图 2 是家里电脑，所以看着 ja3 字段有点不一样，tls 版本也不一样&lt;/p>
&lt;p>说到版本，纠正下我前一篇给的说明，&lt;strong>ja3 指纹不是一定在 tls1.3 上支持的，上面的截图各位朋友应该也看得到，tls1.2 也支持的，不过也确实是需要 wireshark 的最新版才能看到 ja3 指纹&lt;/strong>&lt;/p>
&lt;p>有关第三个数 Extensions 扩展列表，感兴趣的可以看看更详细的解释：https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml&lt;/p>
&lt;p>实际的案例作为 ja3 概念解释就到这里了。&lt;/p>
&lt;h2 id="如何突破-ja3">如何突破 ja3&lt;/h2>
&lt;p>终于到了大家都很感兴趣的环节，怎么破它了。&lt;/p>
&lt;p>完全突破 tls，我知道的有两种**，一种是 hello 包 hook 改写，一种是自编译 openssl 重新改默认的指纹**&lt;/p>
&lt;h3 id="python-半突破">python 半突破&lt;/h3>
&lt;p>在上一篇的解决方案里，修改 cipher 里的加密算法即可，也就是 TLSVersion,Ciphers,Extensions,EllipticCurves,EllipticCurvePointFormats 里的【Ciphers】，&lt;/p>
&lt;p>有关 ciphers 相关套接字的，可以看看 openssl 的官方解释：https://www.openssl.org/docs/man1.1.1/man1/ciphers.html，，并且华为官网的 waf 介绍里也有不同 tls 版本对应的套接字：https://support.huaweicloud.com/bestpractice-waf/waf_06_0012.html&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqDGD9mUBN2Af3C6jgdByJBANTX2PrFA6gGwpPOicCnReI0F5MJKLrTTg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也就是说，我们要想改，可以直接复制上面的套件覆盖下即可，例如：&lt;/p>
&lt;blockquote>
&lt;pre tabindex="0">&lt;code>urllib3.util.ssl_.DEFAULT_CIPHERS = &amp;#39;EECDH+AESGCMEDH+AESGCM&amp;#39;
&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>但是，相信对这个 tls 有过相关经验的大佬来说，其实在调试 requests 请求时，调试到这个 http/client.py 文件库里时，就能看到，在开始 connect 时 http 版本直接写死成了 1.0，还有这个建立连接的 tunnel_headers，代码给了个空值&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqEU5Ks4oYSjlsWe4UN3iaYZ0eibv3b8ia3xWfwT10tDox8VVDqZ4dEPQjA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqbzmLgMy5QUnhzkxfEKA1nU4Ef8icTrtREhckoN3lUicIlsCNyiaIUqMew/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如果你再配上 fiddler 或者 charles 抓包看的时候，明显能看到，在 python 发送实际请求前的 CONNECT 请求如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqJ3FJuxAnazmUVH15ibLOQbickUTj23ibYX1fciag53tlZvoV2DiaYBnweUg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而浏览器的这个 CONNECT 请求是 http1.1，且 headers 是有值的，如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqHEqSYXUj4HZJs5lsaqoEcAw217AJFjggBIMiaRmUcRvFjn3Kd4ghlcA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以，这很明显的差异好吗？是很容易被识别到的&lt;/p>
&lt;p>而且根据我多方查阅，加上咨询了各位大佬之后，&lt;strong>python 目前只能改 Ciphers&lt;/strong> &lt;strong>里面的算法套件，来生成非默认的 ja3 指纹，然后可以骗过检测不是太高的反爬机制。&lt;/strong>&lt;/p>
&lt;p>但是其他的 Extensions,EllipticCurves,EllipticCurvePointFormats 是没法改的，原因是   **python 跟 openssl 没有很直接的联系，python 发 https 请求最后还是借助 openssl 库暴露出来的方法，&lt;strong>也就是的 ssl_.py 里的方法 create_urllib3_context&lt;/strong>，因为 openssl 库对外提供的方法或者接口是没办法这么高度自定义的，****Ciphers 部分也最多能改改算法，都不能给个自己定义的算法进去的，**而 chrome 可以访问是因为 chrome 有自己的 ssl，且 chrome 肯定是不会被禁止的（闹呢，禁止了浏览器正常用户怎么访问？）&lt;/p>
&lt;p>也就是说这是 python 自身的缺陷了？所以我之前测试时不管用 requests，httpx，还是 aiohttp 都不行，因为这三个库底层都借助了 openssl 库发请求。&lt;/p>
&lt;p>假如这种反爬手段满天飞的时候，python 层面还没有成型的方案解决怎么办？&lt;/p>
&lt;p>WTF？python 的业务方向中引以为傲的爬虫居然有缺陷？而且这个问题非常致命啊，感觉被降维打击了，伤心的是目前还没法改变局面，你说焦虑不焦虑？&lt;/p>
&lt;p>那有朋友估计会想问，“那为啥之前猿人学 19 题可以过？” ，那是因为 19 题检测的不严，&lt;strong>只要 ja3 指纹长度小于等于浏览器的指纹长度都可以过&lt;/strong>，但其实还有很多特征的可以检测到的，来，看图，还是上次的图，看最后一个数有很大区别的，这个我在上一篇的结尾里也把这个问题抛出来了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqoL3dhy57aic0ONRBZeahmHt5DJt9icG1d3GNpvgIgKcv5HaPwR8s4g0w/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这么明显的特征，如果是一个实际的网站案例，你觉得他会放过你吗？&lt;/p>
&lt;p>所以目前 python 针对 tls 指纹的有两个缺陷，&lt;strong>第一个发起 CONNECT 请求时 http1.0 被写死，headers 为空（当然这个可以改源码临时解决），第二个指纹没法完全自定义，有很多特征被识别&lt;/strong>&lt;/p>
&lt;p>说到这里，有朋友可能不信，口说无凭，这次来个实际的案例，一个大佬给我的某网站&lt;/p>
&lt;p>浏览器打开（抱歉，我必须马赛克马到位），正常访问是这样的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqfYMbQH8r3NW3603rqRzgrngF6yfAEWWIiahrBREAGxSZibuG2NgmAnBg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>python 代码，这里我用之前介绍的简写形式了，只加这两行，其他地方不用改就行的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqY1QTqvNgiaEwozq4Czk6lS3nZ7QibvBQCFethEw8IqG3TcjT6u2vwr4A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXXInn8icXtHoGQflRGUCiasAqGickic1AkRJibzKb5U23QONMzb99yhicvOfqfXknCrLFKapLn9mBFEuvuw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>运行时发现程序卡住且一直没有响应的状态，测试得知原因是这个网站强制验证了 http2.0 的问题，requests 暂不支持 http2 被该服务器识别一直不响应结果导致卡住。&lt;/p>
&lt;p>那换成 httpx，（有关 httpx 详细的代码如何突破 ja3 的，可以看我之前写的这篇：python 爬虫 - requests、httpx、aiohttp、scrapy 突破 ja3 指纹识别  ）&lt;/p>
&lt;p>发现运行还是不行的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOq9ne8DBcXANf7ZUicI75pScMc0PxgicjzQCdGwZOO7M5yKRZQuqC2x0hg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>怎么改都不成功的，这个就是实际例子说明了，这是 python 语言层面的问题啊，难道 python 真的有缺陷？&lt;/p>
&lt;h3 id="golang-之-ja3transport-库突破-ja3">golang 之 ja3transport 库突破 ja3&lt;/h3>
&lt;p>之后在蔡老板朋友圈里，青南大佬评论中说了是可以替换 ja3 指纹的，我请教青南大佬之后，他给了我一个方案，用 golang 突破，原文链接：&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&amp;amp;mid=2648981779&amp;amp;idx=1&amp;amp;sn=fda89c1ad8237456e734b4d6ac06df1b&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener">一日一技：Golang 如何突破 JA3?&lt;/a>&lt;/p>
&lt;p>核心就是，代码里加了第三方库，ja3transport，这个库可以直接伪造 ja3，刺不刺激？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqs0BEwHNE1p78Qckjobwm9g6TDdtOoiaHCcV9wjKnssEic5RRESJoNYYg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一执行，一看，就发现真的改变了 ja3 指纹，惊呆！激动！刺激！兴奋！&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqsRUtR7o5CRGdsT35DmtnX68HY897qBicv52iaOm6ibbaCj10mPFYKRKfw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>大概的看了下 ja3transport 的介绍，它在发起请求的时候，会将请求的 client hello 数据包里的 ja3 指纹修改为我们自己的给定的，这样就达到了修改 JA3 指纹的目的，妙啊&lt;/p>
&lt;h4 id="ja3transport-简介">ja3transport 简介&lt;/h4>
&lt;p>这个大佬给了一段解释：&lt;/p>
&lt;blockquote>
&lt;p>JA3 的问题在于它仅比基于用户代理字符串的指纹识别客户端好一点。到目前为止，用户代理字符串比 TLS ClientHello 数据包更容易更改。JA3 签名的参数仍由 TLS 客户端控制，因此不能作为可信的信息来源。在 Jeff 和 John 的 ShmooCon 谈话中，他们提到 JA3 不是灵丹妙药。他们提出的颠覆 JA3 检测的方法是使用操作系统的 HTTPS 客户端绕过 TLS 客户端特定的 JA3 签名。我们提出了另一种通过制作与其他 TLS 客户端（如浏览器）匹配的 ClientHello 数据包来破坏 JA3 检测的方法&lt;/p>
&lt;/blockquote>
&lt;h4 id="ja3transport-突破原理">ja3transport 突破原理&lt;/h4>
&lt;p>官方解释：&lt;/p>
&lt;blockquote>
&lt;p>要想颠覆 JA3，需要修改 5 个 JA3 参数，可以在 Refraction Networking 的 utls 项目 ClientHelloSpec 提供的 struct 中修改。该包允许用户构建和执行 ClientHello 握手。第一个参数，TLS 版本，可以用和成员修改。第二个参数，可用密码套件，可以通过更新成员来更改。第三个参数 TLS 扩展可以通过更新成员来更改。参数的一个问题是所有参数都必须遵循 TLSVersionMinTLSVersionMaxCipherSuitesExtensionsExtensionsTLSExtension 界面。第四个和第五个参数，椭圆曲线和椭圆曲线点格式，分别是 TLS 扩展 SupportedCurvesExtension 和 的一部分 SupportedPointsExtension&lt;/p>
&lt;p>我们不是根据 JA3 字符串创建客户端，而是可以生成与 Web 浏览器等良性签名匹配的 JA3 签名。有一些预设允许 JA3 签名匹配 Chrome 或 Firefox，甚至更多。我们仅限于屏蔽使用 Go 可用的相同扩展的应用程序。例如，如果 Chrome 使用 Go 不支持的扩展程序，我们无法屏蔽它。屏蔽密码套件比较棘手，因为任何密码套件都可以进行广告，即使它没有实现。如果执行握手的服务器接受客户端通告但实际上并不支持的密码套件，则会出现问题。只要服务器接受实际支持的密码套件，虚假宣传比可用密码套件多的密码套件就不是问题&lt;/p>
&lt;p>Go 的 net/http 库有一个名为 Transport. 传输结构负责编写如何将数据包发送到目标服务器。由于 JA3 的签名是基于 ClientHello 数据包的，我们可以进行 TLS 握手，让 Go 完成剩下的工作。该 Transport 对象是一个参数 http.Client 结构其中大部分进入开发人员都很熟悉。通过生成 Transport 结构体，我们的库应该可以与任何现有的 Go 项目无缝协作&lt;/p>
&lt;/blockquote>
&lt;p>浓缩下梗概，意思就是在 go 构建请求，三次握手之后，到实际要发起 client hello 包之前，ja3transport 把数据包拦截了，即上面说的 hello 包 hook 的方法，然后把原来的 ja3 指纹修改成了自传递的 ja3 字段发出 client hello，服务端就认了，然后就通过了。&lt;/p>
&lt;p>太牛逼了，他不是直接修改的 tls 里的那五个数组套件，因为 ja3transport 作者自己也说了，要想突破 ja3，他认为的方法和选择的方法也是避开了直接改 5 个 JA3 参数，而是&lt;strong>在 5 个 JA3 参数创建好之后进行拦截替换&lt;/strong>&lt;/p>
&lt;p>那么也就是说，其实 golang 跟 python 比也并没有在语言上占有很大优势，唯一就是 golang 多了这么一群人提前就研究并写好了这个第三方库，而 python 没法解决只是还没有人写出能够拦截数据包并替换 ja3 指纹的库，也就是这个并不是 python 的缺陷啊。当然，如果你急于求得结果，我建议你还是学一下 golang 来解决问题。&lt;/p>
&lt;p>更多的解释请看原文：https://medium.com/cu-cyber/impersonating-ja3-fingerprints-b9f555880e42&lt;/p>
&lt;h4 id="ja3transport-后续问题">ja3transport 后续问题&lt;/h4>
&lt;p>作者也说了，如果你随意地伪造 ja3，假如服务端通过一些方式得知你客户端访问进程跟实际的 ja3 不匹配，那应该也会屏蔽你&lt;/p>
&lt;blockquote>
&lt;p>我们能想到的最简单的检测改进是将 JA3 签名与生成 TLS ClientHello 数据包的进程映像配对。如果有客户端生成与 Firefox 匹配的 JA3 签名，但该进程不是 Firefox，则可能会发生一些奇怪的事情&lt;/p>
&lt;/blockquote>
&lt;h4 id="ja3transport-缺陷">ja3transport 缺陷&lt;/h4>
&lt;p>但是，用这个库 ja3transport 执行的刚才那个案例网站的时候发现报了如下错，提示就是说这个服务器不支持版本 304 的协议&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOq2IBJAT441arTEeeTlruVibdunmqYQWcqOGBeBPJuF3sNtRqO0L6UibUA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>tls: server selected unsupported protocol version 304&lt;/p>
&lt;/blockquote>
&lt;p>一搜这个报错，就看到有个大佬说是因为不支持 http2.0 导致的：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOq6nCZWLu5UebRRYRYfYX8NquoGdV6oKx9AHqoc5H5XZibz8TjjVg0Tew/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对啊，这个网站上面它强制 http2 了，那也就是说，&lt;strong>ja3transport 不支持 http2.0，这就是他的缺陷啊&lt;/strong>&lt;/p>
&lt;h3 id="golang-之-cycletls-库-http20ja3-指纹突破">golang 之 CycleTLS 库 http2.0+ja3 指纹突破&lt;/h3>
&lt;p>那只要能解决 http2 这个问题，是不是就破了这个站呢？再看上面这个大佬发的日期：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqeKoNm3SLU6O9LkJC0UaLzZAibUjNrRXe8ibw46g919e3V4l2w5v8KP2A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>7 May，那现在已经过去这么久了，大胆猜测一下，是不是这个大佬已经解决了呢？此时估计有朋友应该回想，“你这个人怎么这么不严谨，什么都靠猜吗？上一篇解决猿人学 19 题删一大片 cipher 加密算法解决问题也是猜的”&lt;/p>
&lt;p>哈哈哈，是啊，因为我个人觉得，爬虫跟前后端开发还是有点区别的，前后端开发，按照我的理解，讲究的逻辑严密，事先考虑各个层面的问题，尽量少 bug 然后服务能够长期稳定运行，但是爬虫的话，有时候没思路的情况下真的是大胆猜测出来的，我现在的思维已经转向这个方面了，虽然以前也干过后端开发，但是思维已经回不去了。&lt;/p>
&lt;p>我开始尝试了这个库：git 地址：https://github.com/Danny-Dasilva/CycleTLS，真的就是抱着试一试的心态，执行，结果真的跟浏览器访问一样的，搞定，牛逼！&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOq04XWV4SQe8xvGKkiaRTuhekoKSnDF4LnbJ6bBfkhks3uLAPEhrdz3kQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>代码就不贴了，git 地址上有。&lt;/p>
&lt;p>所以，也就是说，之前用的库 github.com/CUCyber/ja3transport，不够适合当下场景 http2+ja3 双重验证&lt;/p>
&lt;p>这辈子没想到搞了几年爬虫逆向开发会为了解决 ja3 问题去学 golang
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOq5uicMXicZDSoTq2I4w0UoD6B5MDibvM2RVAwFbKLVKaUxYyP11kkVf5gg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="nodejs">nodejs&lt;/h3>
&lt;p>还是用上面大佬 Danny-Dasilva 的 CycleTLS 库即可，他也开发了 node 的库：https://github.com/Danny-Dasilva/CycleTLS#example-cycletls-request-jsts&lt;/p>
&lt;p>直接 npm install cycletls，然后照着案例的代码来就行了，可能对于大部分爬虫开发来说，node 相对 golang 来说会更熟悉一点的。&lt;/p>
&lt;h3 id="验证-python-指纹">验证 python 指纹&lt;/h3>
&lt;p>既然已经可以随意改了对吧，那我改成 python 默认的指纹访问下这个网站看看呢？我下面只改了 ja3 指纹，看运行结果，果然是被拉黑了，哈哈哈哈&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqEJFgYvg9Ljib3GGNQdCwpwCzQPo8t4wYIvGmASWDdfYvALOU5qStZtw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="换接口验证">换接口验证&lt;/h3>
&lt;p>为了验证真的成功了，哈哈，该严谨的地方确实得严谨一点，还是用的 golang，我换了另一个接口地址执行，确实有结果了。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqsWORicR3PLvtpMg05EZhtoXFMDm6iaaBias3QcNtd5NDdA3JSTUC90wlA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="用-wireshark-做最后的验证">用 wireshark 做最后的验证&lt;/h3>
&lt;p>那边 go 程序在执行，还是这个被马死的目标，这边 wireshark 抓包看结果，是的，相信你也看出猫腻了，它居然发了两次 client hello 包&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqM0jQFHrb5ZQF0CVKlVqfQLXZnfWMW6APCnQBKnibnmAhiaRtic8RXQrUw/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而之前我们看到的，比如猿人学 19 题，内部题 22，29 题的那个，实际只会发一次的，这里发两次就很奇怪，然后，这两次发出去的 ja3 指纹还不一样：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOq4dIJicB1bdNBEXXaVl1662zC6ibO7Bv9H2CjRcNDagWaYStdyPSIssQA/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>哪里不一样，以逗号作为分割，除了第一个数和最后一个数，其他的字段的开头一个数组都不一样（以【-】作为分割）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqRbQKZyswD9yNIJ9y5IVCNR04KaxsjWnTJibtzLicGu8JEWyO8MScnicwg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>然后，此时此刻，我们先去 ja3 官网看看浏览器本来的指纹呢？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqWwyUBrXdCh6fqzEnWuZvUga9fLAsp7iaicHHaKzs8qa6Y2ecVkPnjQww/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>chrome 访问 ja3 官网返回得到的：&lt;br>
　　　　 771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,0-23-65281-10-11-35-16-5-13-18-51-45-43-27-21,29-23-24,0&lt;/p>
&lt;p>chrome 访问目标网站用 wireshark 抓包得到：&lt;/p>
&lt;p>第一个：&lt;br>
　　　　 771,43690-4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,60138-0-23-65281-10-11-35-16-5-13-18-51-45-43-27-17513-51914-41,14906-29-23-24,0&lt;/p>
&lt;p>第二个：&lt;br>
　　　　 771,10794-4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,14906-0-23-65281-10-11-35-16-5-13-18-51-45-43-27-17513-2570-21,60138-29-23-24,0&lt;/p>
&lt;/blockquote>
&lt;p>仔细对比之后，也就刚好多了标记的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqHrSBG6OXesb0hAQs7N6WaW4pVia73zCdMLoqpDbdlmLKNjxTiaZAWscg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>去掉上面标记出来的，其实第一个和第二个是一样的，仅仅是这个被我马赛克马死的平台是这样，我猜应该是这个平台自己多加了一层握手流程，所以会有 2 个 client hello，具体为啥有两个不纠结了，我也不是该平台的开发，也没法得知具体原因，不重要了，能获取数据就行了。&lt;/p>
&lt;p>不过等等，突然有个疑问？为啥 wireshark 的 ja3 指纹，同一个 golang 脚本啊，就算两个 client hello，也应该是两个一样的 ja3 指纹啊，为了进一步分析，先用浏览器访问 ja3 后，同时看看 wireshark 抓包的是啥，这？我该信哪个？怎么 wireshark 多了点其他的东西&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqYUG9eEwb4Nv5xMOFoBxDTkWJJo4xVpd75jhtHD4qwJSnzDm3tD9aaQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这引出了一个新的问题，哪个才是对的&lt;/p>
&lt;h3 id="ja3-到底存在吗">ja3 到底存在吗？ &lt;/h3>
&lt;p>按理来说，应该信 ja3 官方，因为这玩意儿就是别人搞出来的，那既然如此，是 wireshark 在搞事咯？（此时此刻突然想起了学生时代的一个数学逻辑题，假如你是侦探，现在有几个嫌疑人，已知里面有个人说了谎，从几个嫌疑人的供词里找出真凶。。。扯远了）&lt;/p>
&lt;p>为了进一步确认这个问题，根据青南大佬给文章的方案，可以伪造 ja3 指纹，那此时此刻，试下吧，现在的逻辑就是，我用一个我已知的指纹去请求 ja3，然后看看 ja3 官方的返回，再看 wireshark 的 ja3 指纹对比，如果 wireshark 里的 ja3 不全等于我们自定义的 ja3，那就确认是 wireshark 在他喵的搞事了&lt;/p>
&lt;p>首先澄清，没作弊哈，我用的第一个，跟我浏览器里的 ja3 是不一样的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqiafibYI8QFVvuJyjJjb0KYMBxtdAI9NEg8V5YqvoibFB4FZRPMoMvenJQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里我用的 ja3transport 库了，因为 ja3 官网没有强制 HTTP2 了，运行下面的代码，发现返回的确实改变了的，且值正是我们给定的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOq5uYfA6L1yLXRTaunIOwv0gNEnC3r1QpflJZibuhuYqJeH6XDu9PUic4A/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>再看 wireshark 这边：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOql3I1L5TLCoyPyIU28lkVQOl3tt1AeiceH5a5JXYGF4unrWk0AE7cgiaQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>发现也是自定义的那个值，没有奇怪的数组了&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqrSMgFOdWiab31w2LicqAibftWxnGviaBFSbmT3XRwAQicMG7ibrYbxicys9Rg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>相信有朋友会问，这就奇怪了，为啥这里又一样了？难道 wireshark 没有骗我们？啊这。。。，不是吧，忘了吗？&lt;strong>ja3transport 这个库会在在三次握手后，即将发起 client hello 数据包时，拦截这个包，然后把自定义的 ja3 指纹替换原有的啊&lt;/strong>，这是 ja3transport 库的原理，所以，这里 wireshark 能跟我们给定的 ja3 指纹对应上&lt;/p>
&lt;p>那么，也就是说，&lt;strong>wireshark 有一套的自己的 ja3 指纹解析套件解析并显示了，但是这个解析套件跟 ja3 官网是不一样的，所以显示不一样&lt;/strong>。当然这是我经过多次分析推理得出来的结论，查了 wireshark 的文档，暂时没找到相关的介绍和解释，姑且这么理解吧，肯定信 ja3 官方不能信 wireshark 啊，毕竟这 ja3 是别人搞出来的。&lt;/p>
&lt;p>而且仔细看下面这个图，我鼠标放到 ja3 上面的时候，下面的进制数据并不会对应显示&lt;/p>
&lt;p>&lt;em>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqk4Qbd5X6IVuSVnaANkicJDAH9yfstpXcicviayt7pKLgXfd1NIjFEF1Jg/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/em>&lt;/p>
&lt;p>用微信好友 chao 的话，&amp;ldquo;所有真实的信息都有二进制的数据，而 wireshark 的 ja3 都没有对应的二进制数据&amp;rdquo;&lt;/p>
&lt;p>所以我跟 chao 讨论之后，认为 &lt;strong>ja3 其实并不存在&lt;/strong>（上一次这么醍醐灌顶还是读到《三体》里的那句台词 &amp;ldquo;物理学不存在&amp;rdquo;，不好意思又扯远了。。。），或者说 ja3 并不是实质性存在的字符，而是通过 TLSVersion,Ciphers,Extensions,EllipticCurves,EllipticCurvePointFormats 这五个 tls 组件根据自己的加密算法另类存在的，因为 wireshark 都能通过自己的解析逻辑解析显示啊。以上推论仅代表个人观点，有误请指正&lt;/p>
&lt;h2 id="需要注意的点">需要注意的点&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>有没有发现，其实 ja3 在 2017 年就有了，据我了解，有很多公司的开发正在研究中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有了一个 ja3，那我觉得后续肯定会出现升级版或者替代版了，红蓝对抗，反爬与反反爬，一直在对抗中进步，是好是坏，只能用时间来判定了。很多新东西靠自己一个人摸索是没法走到更远的，好比这个 ja3，如果一开始没有 Lee Brotherston 大佬在 2015 公开讲解，也就不会有这么牛逼的 ja3 指纹出现了，很喜欢微信好友 Regionover 在一篇文章里的一句话：【&lt;strong>故事要留给过去，但成长要用于分享&lt;/strong>】&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外，希望国内外能有大神可以仿照这个 ja3transport 库或者 CycleTLS 库写一个 python 的库出来，唉，我自己也想写出来啊，过去这么久了，我也在看原理，还得花时间研究啊。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="后续怎么继续学习-tls-指纹">后续怎么继续学习 tls 指纹&lt;/h2>
&lt;ol>
&lt;li>练习题：猿人学外部题 19 题，内部题 22，29，32 题，32 题是 app 版的 tls 指纹校验，强的一批，网洛者练习平台第 9 题（这个题正常的浏览器都会返回假数据，作者看了一会儿我的文章一晚上就搞了这道题出来，强的一批），只提示下，有几页假数据。&lt;/li>
&lt;li>志远大佬的最新课程里有 tls 指纹的，感兴趣可以整一个。他的方法就是自编译 openssl&lt;/li>
&lt;li>感兴趣可以读下 openssl 源码&lt;/li>
&lt;/ol>
&lt;h2 id="之前说的-tls-指纹研究怎么样了">之前说的 tls 指纹研究怎么样了&lt;/h2>
&lt;p>说来惭愧，搞了这么久，也没搞出个所以然来，我越去了解，就越觉得这个东西不是那么容易的，资料太少，全靠摸索，只能慢慢来了，因为我想实现的是完全自定义 tls 指纹，这个想法说实话，越来越觉得难实现了，不过一有空就在研究的。不仅研究突破 tls，也在研究怎么利用它更好实现反爬，欢迎有兴趣的朋友一起讨论。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>真诚感谢一路下来认识的大佬们。以上都是个人见解，如果有误还望指正，有任何问题，我很乐意跟各位大佬们交流，我微信 id：**geekbyte，**备注来意&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外应有些朋友的建议建了个群，里面很多大佬，安全渗透，爬虫，web+app 逆向，前后端开发，ios 开发的大佬都有，已满 200 人，想进群的可以加我微信&lt;/p>
&lt;/li>
&lt;li>
&lt;p>推荐下蔡老板的星球，web 逆向必须学的 ast 技术。他虽然不在爬虫圈，但是在爬虫圈一直有他的传说，我能有今天，能认识这么多大佬，很大一部分原因是因为他。真的很感谢蔡老板。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://mmbiz.qpic.cn/mmbiz_png/l4m5icTfxSXVdsh5VoUbWiaqGic0IY8QrOqVIMaqte2XCqqSic1Ly70VdlwQ6qZc9zJcBM1nicxwIu5ibZgyWmCxibuGQ/640?wx_fmt=png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item></channel></rss>