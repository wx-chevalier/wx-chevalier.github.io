<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="本文由 简悦 SimpRead 转码， 原文地址 blog.seeflower.dev Be patient. Lilac，又名：白龙~ 龙哥往往一语中的，给我带来了莫大的帮助，非常感谢 本文旨在对 getByte 算法进行分析与还原，仅供学习交流 本文不会提供完整算法脚本 本文将涉及以下内容： OLLVM 虚假控"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/"><meta property="og:title" content="getByte 算法分析与还原 - SeeFlowerX | Next-gen Tech Edu"><meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 blog.seeflower.dev Be patient. Lilac，又名：白龙~ 龙哥往往一语中的，给我带来了莫大的帮助，非常感谢 本文旨在对 getByte 算法进行分析与还原，仅供学习交流 本文不会提供完整算法脚本 本文将涉及以下内容： OLLVM 虚假控"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>getByte 算法分析与还原 - SeeFlowerX | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=82221d9b19ed49a5f58cc25f1c26eb13><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">999.参考资料</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ida13f9287bee731f41102d5bd6b06508c")' href=#ida13f9287bee731f41102d5bd6b06508c aria-expanded=false aria-controls=ida13f9287bee731f41102d5bd6b06508c aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/>逆向工程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ida13f9287bee731f41102d5bd6b06508c aria-expanded=false aria-controls=ida13f9287bee731f41102d5bd6b06508c><i class="fa-solid fa-angle-down" id=caret-ida13f9287bee731f41102d5bd6b06508c></i></a></div><ul class="nav docs-sidenav collapse show" id=ida13f9287bee731f41102d5bd6b06508c><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id86bfc41c09c9dc360469558f7d6c003b")' href=#id86bfc41c09c9dc360469558f7d6c003b aria-expanded=false aria-controls=id86bfc41c09c9dc360469558f7d6c003b aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>99.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id86bfc41c09c9dc360469558f7d6c003b aria-expanded=false aria-controls=id86bfc41c09c9dc360469558f7d6c003b><i class="fa-solid fa-angle-right" id=caret-id86bfc41c09c9dc360469558f7d6c003b></i></a></div><ul class="nav docs-sidenav collapse" id=id86bfc41c09c9dc360469558f7d6c003b><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-%E6%98%A5%E8%8A%82%E5%AE%89%E5%8D%93%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/>【2021 春节】安卓中级题逆向总结</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E8%BD%AC%E8%BD%BDunidbg-hook-%E5%A4%A7%E5%85%A8-seeflowerx/>【转载】Unidbg Hook 大全 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-%E6%9F%90%E5%AE%89%E5%8D%93-crackme-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>2022 某安卓 Crackme 流程分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/app-%E9%80%86%E5%90%91-%E5%B9%B3%E5%A4%B4%E5%93%A5%E5%AE%9E%E6%88%98%E6%9F%90%E5%86%9C%E4%BA%A7%E5%93%81-app/>app 逆向 平头哥实战（某农产品 app）</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/>Frida Android hook _ Sakura の blog</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/>frida 免 root hook</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/>getByte 算法分析与还原 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%BA%8C%E9%83%A8%E6%9B%B2%E6%9F%90-v5-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86-%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/>Js Ast 二部曲：某 V5 “绝对不可逆加密” 一探究竟</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%B8%80%E9%83%A8%E6%9B%B2%E9%AB%98%E5%AE%8C%E6%95%B4%E5%BA%A6%E8%BF%98%E5%8E%9F%E6%9F%90-v5-%E7%9A%84%E5%8A%A0%E5%AF%86/>Js Ast 一部曲：高完整度还原某 V5 的加密</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%A1%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F/>js 破解之补浏览器环境的两种监控方式</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/mtgsig2.1-%E7%89%88%E6%9C%AC%E4%B9%8B-a5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>mtgsig2.1 版本之 a5 算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/protobuf-%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90-app-%E7%88%AC%E8%99%AB-/>Protobuf 协议逆向解析 - APP 爬虫</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/proxy-%E4%BB%A3%E7%90%86%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9/>Proxy 代理（二次修改）</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/python-%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6%E5%BF%85%E5%A4%87-_-js-%E9%80%86%E5%90%91%E4%B9%8B%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8%E8%A1%A5%E4%BB%80%E4%B9%88/>Python 爬虫进阶必备 _ Js 逆向之补环境到底是在补什么？</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8A%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 上卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8B%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 下卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%AD%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 中卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%A4%A7%E7%8C%BF%E6%90%9C%E9%A2%98-sign-so-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90unidbg/>大猿搜题 sign so 加密参数分析｜unidbg</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA-android-%E9%80%9A%E7%94%A8-svc-%E8%B7%9F%E8%B8%AA%E4%BB%A5%E5%8F%8A-hook-%E6%96%B9%E6%A1%88frida-seccomp/>分享一个 Android 通用 svc 跟踪以及 hook 方案——Frida-Seccomp</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E4%B9%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>某乎请求头签名算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E5%92%96%E5%95%A1-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6%E7%89%88/>某咖啡 app 加密参数分析进阶版</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95-+-ollvm-%E6%B7%B7%E6%B7%86%E7%9A%84-crackme/>逆向分析反调试 + ollvm 混淆的 Crackme</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E7%88%AC%E8%99%AB%E4%B9%8B-%E6%9F%90%E7%94%9F%E9%B2%9C-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/>爬虫之 - 某生鲜 APP 加密参数逆向分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90-ja3-%E6%8C%87%E7%BA%B9%E5%8F%8A%E7%AA%81%E7%A0%B4/>深度剖析 ja3 指纹及突破</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idebb5db8060bce97b3f0cd1ac08912ddf")' href=#idebb5db8060bce97b3f0cd1ac08912ddf aria-expanded=false aria-controls=idebb5db8060bce97b3f0cd1ac08912ddf aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>999.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idebb5db8060bce97b3f0cd1ac08912ddf aria-expanded=false aria-controls=idebb5db8060bce97b3f0cd1ac08912ddf><i class="fa-solid fa-angle-down" id=caret-idebb5db8060bce97b3f0cd1ac08912ddf></i></a></div><ul class="nav docs-sidenav collapse show" id=idebb5db8060bce97b3f0cd1ac08912ddf><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-%E6%98%A5%E8%8A%82%E5%AE%89%E5%8D%93%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/>【2021 春节】安卓中级题逆向总结</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E8%BD%AC%E8%BD%BDunidbg-hook-%E5%A4%A7%E5%85%A8-seeflowerx/>【转载】Unidbg Hook 大全 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-%E6%9F%90%E5%AE%89%E5%8D%93-crackme-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>2022 某安卓 Crackme 流程分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/app-%E9%80%86%E5%90%91-%E5%B9%B3%E5%A4%B4%E5%93%A5%E5%AE%9E%E6%88%98%E6%9F%90%E5%86%9C%E4%BA%A7%E5%93%81-app/>app 逆向 平头哥实战（某农产品 app）</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/>Frida Android hook _ Sakura の blog</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/>frida 免 root hook</a></li><li class="child level active"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/>getByte 算法分析与还原 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%BA%8C%E9%83%A8%E6%9B%B2%E6%9F%90-v5-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86-%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/>Js Ast 二部曲：某 V5 “绝对不可逆加密” 一探究竟</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%B8%80%E9%83%A8%E6%9B%B2%E9%AB%98%E5%AE%8C%E6%95%B4%E5%BA%A6%E8%BF%98%E5%8E%9F%E6%9F%90-v5-%E7%9A%84%E5%8A%A0%E5%AF%86/>Js Ast 一部曲：高完整度还原某 V5 的加密</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%A1%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F/>js 破解之补浏览器环境的两种监控方式</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/mtgsig2.1-%E7%89%88%E6%9C%AC%E4%B9%8B-a5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>mtgsig2.1 版本之 a5 算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/protobuf-%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90-app-%E7%88%AC%E8%99%AB-/>Protobuf 协议逆向解析 - APP 爬虫</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/proxy-%E4%BB%A3%E7%90%86%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9/>Proxy 代理（二次修改）</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/python-%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6%E5%BF%85%E5%A4%87-_-js-%E9%80%86%E5%90%91%E4%B9%8B%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8%E8%A1%A5%E4%BB%80%E4%B9%88/>Python 爬虫进阶必备 _ Js 逆向之补环境到底是在补什么？</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8A%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 上卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8B%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 下卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%AD%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 中卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%A4%A7%E7%8C%BF%E6%90%9C%E9%A2%98-sign-so-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90unidbg/>大猿搜题 sign so 加密参数分析｜unidbg</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA-android-%E9%80%9A%E7%94%A8-svc-%E8%B7%9F%E8%B8%AA%E4%BB%A5%E5%8F%8A-hook-%E6%96%B9%E6%A1%88frida-seccomp/>分享一个 Android 通用 svc 跟踪以及 hook 方案——Frida-Seccomp</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E4%B9%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>某乎请求头签名算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E5%92%96%E5%95%A1-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6%E7%89%88/>某咖啡 app 加密参数分析进阶版</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95-+-ollvm-%E6%B7%B7%E6%B7%86%E7%9A%84-crackme/>逆向分析反调试 + ollvm 混淆的 Crackme</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E7%88%AC%E8%99%AB%E4%B9%8B-%E6%9F%90%E7%94%9F%E9%B2%9C-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/>爬虫之 - 某生鲜 APP 加密参数逆向分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90-ja3-%E6%8C%87%E7%BA%B9%E5%8F%8A%E7%AA%81%E7%A0%B4/>深度剖析 ja3 指纹及突破</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#算法稳定主动调用>算法稳定主动调用</a><ul><li><a href=#获取输入输出参数>获取输入输出参数</a></li><li><a href=#frida-稳定主动调用>frida 稳定主动调用</a></li></ul></li><li><a href=#so-分析准备>so 分析准备</a><ul><li><a href=#ollvm-bcf-反混淆>OLLVM-BCF 反混淆</a></li><li><a href=#cutter-搭配使用>cutter 搭配使用</a></li></ul></li><li><a href=#返回结果追踪定位>返回结果追踪定位</a><ul><li><a href=#jnitrace-定位-setbytearrayregion-调用>jnitrace 定位 SetByteArrayRegion 调用</a></li><li><a href=#更优雅的-jni-追踪>更优雅的 jni 追踪</a></li></ul></li><li><a href=#返回结果反向推导与追踪>返回结果反向推导与追踪</a><ul><li><a href=#sha256-算法还原>SHA256 算法还原</a></li><li><a href=#hmac-sha256-算法还原>HMAC-SHA256 算法还原</a></li><li><a href=#salsa20-算法还原>Salsa20 算法还原</a></li></ul></li><li><a href=#返回结果构成总结>返回结果构成总结</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>getByte 算法分析与还原 - SeeFlowerX</h1><div class=article-style><blockquote><p>本文由 <a href=http://ksria.com/simpread/ target=_blank rel=noopener>简悦 SimpRead</a> 转码， 原文地址 <a href=https://blog.seeflower.dev/archives/54/ target=_blank rel=noopener>blog.seeflower.dev</a></p></blockquote><blockquote><p>Be patient.</p></blockquote><ul><li>Lilac，又名：<a href=https://blog.csdn.net/qq_38851536 target=_blank rel=noopener>白龙~</a></li></ul><p>龙哥往往一语中的，给我带来了莫大的帮助，非常感谢</p><p>本文旨在对 getByte 算法进行分析与还原，仅供学习交流</p><p>本文不会提供完整算法脚本</p><p>本文将涉及以下内容：</p><ul><li>OLLVM 虚假控制流 (OLLVM-BCF) 反混淆</li><li>cutter 反编译</li><li>md5 算法识别</li><li>SHA256 算法还原——魔数修改</li><li>Salsa20 算法还原——逻辑魔改</li><li>trace_natives 与 frida-trace 搭配使用</li><li>findhash 使用</li><li>gettimeofday 和 lrand48</li><li>~unidbg 模拟调用 (下一篇文章)~</li></ul><p><strong>！！！为了节省版面，文章中重复的 hook 代码会省略掉，复现时请记得自行补充</strong></p><table><thead><tr><th>名称</th><th>物料</th><th>补充</th></tr></thead><tbody><tr><td>目标方法</td><td>getByte</td><td>-</td></tr><tr><td>目标类</td><td>com.tencent.starprotocol.ByteData</td><td>-</td></tr><tr><td>目标 so</td><td>libpoxy_star.so</td><td>md5: 889415fb8e886dfdc3fdd405c105d262</td></tr><tr><td>目标 apk</td><td>com.tencent.qqlive_V8.3.95.26016.apk</td><td>md5: 6d6cd9c0b36c49f17d0f204cf917774e</td></tr><tr><td>frida-server</td><td><a href=https://github.com/frida/frida/releases/tag/14.2.18 target=_blank>frida-server-14.2.18-android-arm64</a></td><td>-</td></tr><tr><td>python</td><td>3.8.5</td><td>由 miniconda 创建</td></tr><tr><td>IDA</td><td>IDA Pro 7.5</td><td><a href=https://down.52pojie.cn/Tools/Disassemblers/IDA_Pro_v7.5_Portable.zip target=_blank>爱盘地址</a></td></tr><tr><td>CyberChef</td><td>CyberChef</td><td><a href=https://gchq.github.io/CyberChef target=_blank>在线地址</a></td></tr><tr><td>findhash</td><td>findhash</td><td><a href=https://github.com/Pr0214/findhash target=_blank>Github 地址</a></td></tr><tr><td>trace_natives</td><td>trace_natives</td><td><a href=https://github.com/Pr0214/trace_natives target=_blank>Github 地址</a></td></tr><tr><td>jnitrace</td><td>jnitrace</td><td><a href=https://github.com/chame1eon/jnitrace target=_blank>Github 地址</a></td></tr><tr><td>JNI-Frida-Hook</td><td>JNI-Frida-Hook</td><td><a href=https://github.com/Areizen/JNI-Frida-Hook target=_blank>Github 地址</a></td></tr><tr><td>hook_RegisterNatives</td><td>hook_RegisterNatives</td><td><a href=https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_RegisterNatives.js target=_blank>Github 地址</a></td></tr><tr><td>cutter</td><td>cutter</td><td><a href=https://cutter.re/ target=_blank>官方地址</a></td></tr><tr><td>测试 ROM</td><td>QQ1B.200205.002</td><td><del>能跑 frida 就行</del></td></tr></tbody></table><ul><li>物料 <a href=https://gofile.io/d/bqu3Hd target=_blank rel=noopener>https://gofile.io/d/bqu3Hd</a></li></ul><h2 id=算法稳定主动调用>算法稳定主动调用</h2><p>此处稳定意为固定输入、固定输出</p><h3 id=获取输入输出参数>获取输入输出参数</h3><p>已知目标方法是<code>com.tencent.starprotocol.ByteData.getByte</code>，要触发这个地方的调用很简单，APP 随便打开一个视频即可</p><p>首先用 objection 看一眼</p><pre tabindex=0><code>android hooking watch class_method com.tencent.starprotocol.ByteData.getByte --dump-args --dump-return
</code></pre><p>结果如下（部分参数已和谐）</p><pre tabindex=0><code>(agent) [466367] Called com.tencent.starprotocol.ByteData.getByte(android.content.Context, long, long, long, long, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
(agent) [466367] Arguments com.tencent.starprotocol.ByteData.getByte(com.tencent.qqlive.ona.base.QQLiveApplicationWrapper@bdbc6ce, 1, 0, 0, 0, [Ljava.lang.String;@6e859e6, , ce****************************b2, [B@a368b27)
(agent) [466367] Return Value: [object Object]
</code></pre><p>显然 objection 不能直接得到全部参数具体内容，需要手动写个 hook 脚本</p><p>首先准备两个 hexdump 函数</p><pre tabindex=0><code>function jhexdump(array) {
    if(!array) return;
    console.log(&#34;---------jhexdump start---------&#34;);
    var ptr = Memory.alloc(array.length);
    for(var i = 0; i &lt; array.length; ++i)
        Memory.writeS8(ptr.add(i), array[i]);
    console.log(hexdump(ptr, {offset: 0, length: array.length, header: false, ansi: false}));
    console.log(&#34;---------jhexdump end---------&#34;);
}
function dumpByteArray(obj){
    console.log(&#34;---------dumpByteArray start---------&#34;);
    let obj_ptr = ptr(obj.$h).readPointer();
    let buf_ptr = obj_ptr.add(Process.pointerSize * 3);
    let size = obj_ptr.add(Process.pointerSize * 2).readU32();
    console.log(hexdump(buf_ptr, {offset: 0, length: size, header: false, ansi: false}));
    console.log(&#34;---------dumpByteArray end---------&#34;);
}
</code></pre><p>打印参数</p><p>e.g. <code>frida -U -n com.tencent.qqlive -l agent/poxy_star.js -o agent/poxy_star.log</code></p><pre tabindex=0><code>function getByte_LogArgs(){
    Java.perform(function(){
        let gson = Java.use(&#39;com.google.gson.Gson&#39;);
        let ByteDataCls = Java.use(&#34;com.tencent.starprotocol.ByteData&#34;);
        ByteDataCls.getByte.overload(&#34;android.content.Context&#34;, &#34;long&#34;, &#34;long&#34;, &#34;long&#34;, &#34;long&#34;, &#34;java.lang.Object&#34;, &#34;java.lang.Object&#34;, &#34;java.lang.Object&#34;, &#34;java.lang.Object&#34;).implementation = function(context, num1, num2, num3, num4, obj1, obj2, obj3, obj4){
            console.log(context, num1, num2, num3, num4);
            console.log(&#34;obj1&#34;, obj1.$className, gson.$new().toJson(obj1))
            console.log(&#34;obj2&#34;, obj2.$className, gson.$new().toJson(obj2))
            console.log(&#34;obj3&#34;, obj3.$className, gson.$new().toJson(obj3))
            console.log(&#34;obj4&#34;, obj4.$className, gson.$new().toJson(obj4))
            dumpByteArray(obj4);
            let resp = this.getByte(context, num1, num2, num3, num4, obj1, obj2, obj3, obj4)
            jhexdump(resp);
            return resp
        }
    })
}

setImmediate(getByte_LogArgs);
</code></pre><p>点击视频，得到下面的结果</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_00-06-26.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_00-06-26.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>参数拿到后就可以开始主动调用了</p><h3 id=frida-稳定主动调用>frida 稳定主动调用</h3><p>经过测试，发现传入参数固定，返回结果并不固定，这是因为原算法用到了 <strong>lrand48</strong> 和 <strong>gettimeofday</strong></p><p>这是怎么发现的呢</p><p>~<strong>当然是根据经验测出来的</strong>~</p><p>一般遇到传入参数固定但是结果变化，统统往<strong>时间</strong>、<strong>随机数</strong>上靠</p><p>这里先认为是假设，下面进行验证</p><h4 id=固定-lrand48-和-gettimeofday-返回>固定 lrand48 和 gettimeofday 返回</h4><p><strong>lrand48</strong> 定义如下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_10-58-22.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_10-58-22.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>那么这里直接将返回设置位<code>7</code></p><p>这里提一点，为了和其他可能为 0 的参数进行区分，建议这里<strong>尽量不要设置为 0</strong></p><p><strong>gettimeofday</strong> 定义如下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-12-21.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-12-21.png alt loading=lazy data-zoomable></div></div></figure></a></p><blockquote><p>定义函数 int gettimeofday (struct timeval <em>tv, struct timezone</em> tz);<br>函数说明 gettimeofday() 会把目前的时间有 tv 所指的结构返回，当地时区的信息则放到 tz 所指的结构中。</p></blockquote><p>类型信息</p><pre tabindex=0><code>typedef long __kernel_long_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_suseconds_t;
struct timeval {
    __kernel_time_t tv_sec;
    __kernel_suseconds_t tv_usec;
};
</code></pre><p>根据上述信息，那么只需要在 <strong>gettimeofday</strong> 返回时向参数一写入两个 long 类型的数即可，分别代表秒数、微秒数</p><h4 id=验证>验证</h4><p>另外对于图中马赛克的参数，经过测试，确定改变它们不影响最终结果，后面使用特定固定值</p><p>于是编写如下完整的稳定主动调用脚本</p><pre tabindex=0><code>function freeze_funcs(){
    let lrand48_addr = Module.findExportByName(&#34;libc.so&#34;, &#34;lrand48&#34;);
    Interceptor.attach(lrand48_addr, {onLeave: function(retval){retval.replace(7)}});
    let tm_s = 1626403551;
    let tm_us = 5151606;
    let gettimeofday_addr = Module.findExportByName(&#34;libc.so&#34;, &#34;gettimeofday&#34;);
    Interceptor.attach(gettimeofday_addr, {
        onEnter: function(args) {
            this.tm_ptr = args[0];
        },
        onLeave:function(retval){
            this.tm_ptr.writeLong(tm_s);
            this.tm_ptr.add(0x4).writeLong(tm_us);
        }
    });
}

function call_getByte(){
    Java.perform(function(){
        let LongCls = Java.use(&#34;java.lang.Long&#34;);
        let StringCls = Java.use(&#34;java.lang.String&#34;);
        let ReflectArrayCls  = Java.use(&#39;java.lang.reflect.Array&#39;)
        let ByteDataCls = Java.use(&#34;com.tencent.starprotocol.ByteData&#34;);
        let ctx = Java.use(&#39;android.app.ActivityThread&#39;).currentApplication().getApplicationContext();
        let num_1 = LongCls.$new(1).longValue();
        let num_2 = LongCls.$new(0).longValue();
        let num_3 = LongCls.$new(0).longValue();
        let num_4 = LongCls.$new(0).longValue();
        let obj1 = ReflectArrayCls.newInstance(StringCls.class, 9);
        ReflectArrayCls.set(obj1, 0, &#34;dl_10303&#34;);
        ReflectArrayCls.set(obj1, 1, &#34;1&#34;);
        ReflectArrayCls.set(obj1, 2, &#34;66666666666666666666666666666666&#34;);
        ReflectArrayCls.set(obj1, 3, &#34;getCKey&#34;);
        ReflectArrayCls.set(obj1, 4, &#34;888888888888888888888888888888888888&#34;);
        ReflectArrayCls.set(obj1, 5, &#34;1626403551515&#34;);
        ReflectArrayCls.set(obj1, 6, &#34;&#34;);
        ReflectArrayCls.set(obj1, 7, &#34;8.3.95.26016&#34;);
        ReflectArrayCls.set(obj1, 8, &#34;com.tencent.qqlive&#34;);
        let obj2 = StringCls.$new(&#34;&#34;);
        let obj3 = StringCls.$new(&#34;66666666666666666666666666666666&#34;);
        let obj4 = Java.array(&#39;B&#39;, [49,54,50,54,52,48,51,53,53,49,44,110,48,48,51,57,101,121,49,109,109,100,44,110,117,108,108]);
        let ByteDataIns = ByteDataCls.getInstance()
        let byte = ByteDataIns.getByte(ctx, num_1, num_2, num_3, num_4, obj1, obj2, obj3, obj4);
        jhexdump(byte);
        Interceptor.detachAll();
    })
}

freeze_funcs();
call_getByte();
</code></pre><p>现在得到固定的返回了</p><pre tabindex=0><code>---------jhexdump start---------
b6abddd8  68 65 68 61 00 00 00 01 01 00 00 00 00 00 00 00  heha............
b6abdde8  00 00 00 03 08 00 00 00 00 44 a7 2c da 00 00 00  .........D.,....
b6abddf8  01 00 00 00 96 00 01 00 08 00 00 01 7a ad 34 cb  ............z.4.
b6abde08  37 00 02 00 0a 68 68 68 68 68 68 69 69 69 68 00  7....hhhhhhiiih.
b6abde18  03 00 04 01 00 00 01 00 05 00 04 01 00 00 01 00  ................
b6abde28  04 00 04 00 00 00 00 00 06 00 04 01 00 00 04 00  ................
b6abde38  07 00 04 01 00 00 02 00 08 00 04 01 00 00 03 00  ................
b6abde48  09 00 20 45 4f 2a db 77 40 90 33 9f e2 58 8c 2f  .. EO*.w@.3..X./
b6abde58  c6 4a 3d ce 7a c7 30 7d ce ac 0b aa b6 18 b3 6f  .J=.z.0}.......o
b6abde68  41 74 d3 00 0a 00 10 cd b5 df 89 f5 2d 25 05 4b  At..........-%.K
b6abde78  85 81 f6 cf af 1e fb 00 0b 00 10 fb 08 ad 5f af  .............._.
b6abde88  a8 93 35 2d 13 cb 93 27 e8 f7 fd                 ..5-...&#39;...
---------jhexdump end---------
</code></pre><h2 id=so-分析准备>so 分析准备</h2><p>通过反编译 apk，可以知道<code>getByte</code>是一个 native 函数，熟练打开 IDA、拖入 so、搜索导出函数</p><p>不好意思，没有</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-36-11.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-36-11.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>再看看字符串</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-07.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-07.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>动态注册跑不了了</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-58.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-37-58.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>直接就是 <a href=https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_RegisterNatives.js target=_blank rel=noopener><strong>hook_RegisterNatives</strong></a></p><pre tabindex=0><code>[RegisterNatives] java_class: com.tencent.starprotocol.ByteData name: getByte sig: (Landroid/content/Context;JJJJLjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)[B fnPtr: 0x90c969ad module_name: libpoxy_star.so module_base: 0x90c89000 offset: 0xd9ad
[RegisterNatives] java_class: com.tencent.starprotocol.ByteData name: putByte sig: (Landroid/content/Context;JJJJLjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)I fnPtr: 0x90caa995 module_name: libpoxy_star.so module_base: 0x90c89000 offset: 0x21995
</code></pre><p>好了，让我们看看<code>sub_D9AC</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-49-09.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_11-49-09.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>似乎有点麻烦，很多分支&mldr;&mldr;</p><p>此刻是不是头都大了，再看看 so 大小，828KB，发现了什么没有</p><p>就动态注册了两个方法，并且没有其他静态注册的方法，so 文件却如此之大</p><p>显然 so 有混淆</p><p>好在反编译代码中有迹可循，可以看到反编译结果有很多下面这样的判断</p><pre tabindex=0><code>((dword_C2C04 ^ dword_C2C08 ^ 0x100011AA) &amp; 0x5120FBAA) == -1964041611
</code></pre><p>如果你经验丰富，一眼就能看出来这是 <strong>BCF(Bogus Control Flow)</strong>，即虚假控制流</p><p>~吐槽：我是算法还原完了才知道这个点，哎，心累&mldr;~</p><h3 id=ollvm-bcf-反混淆>OLLVM-BCF 反混淆</h3><p>这烦人的 BCF 自然是有方案处理的，具体请参考下面这篇文章</p><ul><li><a href=https://bbs.pediy.com/thread-257213.htm target=_blank rel=noopener>Hex-Rays: 十步杀一人，两步秒 OLLVM-BCF</a></li></ul><p>简单来说就是将 data 段数据的<code>Write</code>属性去掉，然后重新 F5 即可，IDA 会自动完成 BCF 的优化</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-02-25.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-02-25.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>这是优化后的结果，是不是非常非常清晰了</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-05-08.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-05-08.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>知道这个操作后，简直事半功倍，基本上不用去手动 hook 确定走向了</p><p>看雪还有一些关于 BCF 反混淆的文章，经过测试还是 IDA 来的快，效果相对更好&mldr;</p><h3 id=cutter-搭配使用>cutter 搭配使用</h3><p>即使进行了 BCF 反混淆操作</p><p>IDA 反编译出来的代码阅读有些问题，比如看不懂变量传递关系</p><p>表现为函数传入参数在确定要走的那个分支里面没有被直接或者间接调用</p><p>好在 cutter 的反编译结果至少是能看出来的</p><p>以<code>sub_AA924</code>为例</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-19-09.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-19-09.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>大致可以推测出来数据处理在最后一个 case 进行</p><p>但是<code>*(_BYTE *)(*v10 + *v8)</code>和 a1 什么关系实在是看不懂，v5 和 a1 又有什么关系？</p><p>这也许要直接阅读汇编代码才能看出其中关系了，或者这是某种特定的形式</p><p>实在不行也可以 hook 来确定，毕竟动态的是准确的</p><p>或者这是一个我还没学习到的知识点</p><p>好在 cutter 可以帮上忙</p><p>根据下图的标注，可以知道 a1 就是<code>piStack44</code>了</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-37-11.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-37-11.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>而对于后面的<code>puStack52</code>，也能根据下面的标注推测出每一轮 + 1，等于是挨个取 a1 处的内容</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-39-46.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_12-39-46.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>如果只看 IDA，可能就比较懵了&mldr;</p><p>所以搭配使用效果更佳</p><h2 id=返回结果追踪定位>返回结果追踪定位</h2><p>按照常规思路，一般是看 native 函数的返回，然后追踪结果的生成过程</p><p>先打印一波 so 的结果</p><pre tabindex=0><code>function jbhexdump(array) {
    console.log(&#34;---------jbhexdump start---------&#34;);
    let env = Java.vm.getEnv();
    let size = env.getArrayLength(array);
    let data = env.getByteArrayElements(array);
    console.log(hexdump(data, {offset: 0, length: size, header: false, ansi: false}));
    env.releaseByteArrayElements(array, data, 0);
    console.log(&#34;---------jbhexdump end---------&#34;);
}

function inline_hook(){
    let base_addr = Module.getBaseAddress(&#34;libpoxy_star.so&#34;);
    Interceptor.attach(base_addr.add(0xD9AC).add(1), {
        onLeave: function (retval) {
            console.log(`onLeave sub_D9AC`);
            jbhexdump(retval);
        }
    });
}

freeze_funcs();
inline_hook();
call_getByte();
</code></pre><p>日志如下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-24-29.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-24-29.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><strong>一 模 一 样</strong></p><p>是否反向查看函数，挨个跟踪定位算法呢，答案是否</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-29-11.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_13-29-11.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>在已经有 BCF 反混淆的加持下，依然可以看到函数嵌套函数，如果没有足够的精力，可能是难以定位算法的</p><p>既然 so 结尾返回的是 jbyteArray，那么可以通过 hook SetByteArrayRegion 实现快速定位</p><h3 id=jnitrace-定位-setbytearrayregion-调用>jnitrace 定位 SetByteArrayRegion 调用</h3><p>jnitrace 如果以 spawn 模式可能难以追踪，这里采用 attach 模式</p><p>具体操作是打开 APP 后一小会儿执行命令，同时注意脚本中主动调用时机</p><pre tabindex=0><code>jnitrace -l libpoxy_star.so -m attach -a poxy_star.js com.tencent.qqlive
</code></pre><p><a href=https://blog.seeflower.dev/images/oCam_2021_07_16_13_56_04_790.gif target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/oCam_2021_07_16_13_56_04_790.gif alt loading=lazy data-zoomable></div></div></figure></a></p><p>可以看到有一个<code>SetByteArrayRegion</code>内容和最终结果一样，地址是 <strong>0x13d79</strong></p><p>另外可以通过<code>-o</code>选项设置追踪结果</p><p>这就是调用的位置了，位于<code>sub_13C7C</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-03-00.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-03-00.png alt loading=lazy data-zoomable></div></div></figure></a></p><h3 id=更优雅的-jni-追踪>更优雅的 jni 追踪</h3><p>前面提到可以直接用 jnitrace 进行 jni 函数调用追踪，但是不太方便</p><p>只想在主动调用某个函数之间进行追踪怎么办呢</p><p>参考<code>JNI-Frida-Hook</code>这个项目，可以发现实现原理很简单，拿到 jni 函数的地址然后 hook 就行了</p><p>下面是一个简单的案例，这样会灵活很多</p><pre tabindex=0><code>let jni_struct_array = [
    &#34;reserved0&#34;, &#34;reserved1&#34;, &#34;reserved2&#34;, &#34;reserved3&#34;, &#34;GetVersion&#34;, &#34;DefineClass&#34;, &#34;FindClass&#34;, &#34;FromReflectedMethod&#34;, &#34;FromReflectedField&#34;, &#34;ToReflectedMethod&#34;, &#34;GetSuperclass&#34;, &#34;IsAssignableFrom&#34;, &#34;ToReflectedField&#34;, &#34;Throw&#34;, &#34;ThrowNew&#34;,
    &#34;ExceptionOccurred&#34;, &#34;ExceptionDescribe&#34;, &#34;ExceptionClear&#34;, &#34;FatalError&#34;, &#34;PushLocalFrame&#34;, &#34;PopLocalFrame&#34;, &#34;NewGlobalRef&#34;, &#34;DeleteGlobalRef&#34;, &#34;DeleteLocalRef&#34;, &#34;IsSameObject&#34;, &#34;NewLocalRef&#34;, &#34;EnsureLocalCapacity&#34;, &#34;AllocObject&#34;, &#34;NewObject&#34;,
    &#34;NewObjectV&#34;, &#34;NewObjectA&#34;, &#34;GetObjectClass&#34;, &#34;IsInstanceOf&#34;, &#34;GetMethodID&#34;, &#34;CallObjectMethod&#34;, &#34;CallObjectMethodV&#34;, &#34;CallObjectMethodA&#34;, &#34;CallBooleanMethod&#34;, &#34;CallBooleanMethodV&#34;, &#34;CallBooleanMethodA&#34;, &#34;CallByteMethod&#34;, &#34;CallByteMethodV&#34;,
    &#34;CallByteMethodA&#34;, &#34;CallCharMethod&#34;, &#34;CallCharMethodV&#34;, &#34;CallCharMethodA&#34;, &#34;CallShortMethod&#34;, &#34;CallShortMethodV&#34;, &#34;CallShortMethodA&#34;, &#34;CallIntMethod&#34;, &#34;CallIntMethodV&#34;, &#34;CallIntMethodA&#34;, &#34;CallLongMethod&#34;, &#34;CallLongMethodV&#34;, &#34;CallLongMethodA&#34;,
    &#34;CallFloatMethod&#34;, &#34;CallFloatMethodV&#34;, &#34;CallFloatMethodA&#34;, &#34;CallDoubleMethod&#34;, &#34;CallDoubleMethodV&#34;, &#34;CallDoubleMethodA&#34;, &#34;CallVoidMethod&#34;, &#34;CallVoidMethodV&#34;, &#34;CallVoidMethodA&#34;, &#34;CallNonvirtualObjectMethod&#34;, &#34;CallNonvirtualObjectMethodV&#34;,
    &#34;CallNonvirtualObjectMethodA&#34;, &#34;CallNonvirtualBooleanMethod&#34;, &#34;CallNonvirtualBooleanMethodV&#34;, &#34;CallNonvirtualBooleanMethodA&#34;, &#34;CallNonvirtualByteMethod&#34;, &#34;CallNonvirtualByteMethodV&#34;, &#34;CallNonvirtualByteMethodA&#34;, &#34;CallNonvirtualCharMethod&#34;,
    &#34;CallNonvirtualCharMethodV&#34;, &#34;CallNonvirtualCharMethodA&#34;, &#34;CallNonvirtualShortMethod&#34;, &#34;CallNonvirtualShortMethodV&#34;, &#34;CallNonvirtualShortMethodA&#34;, &#34;CallNonvirtualIntMethod&#34;, &#34;CallNonvirtualIntMethodV&#34;, &#34;CallNonvirtualIntMethodA&#34;,
    &#34;CallNonvirtualLongMethod&#34;, &#34;CallNonvirtualLongMethodV&#34;, &#34;CallNonvirtualLongMethodA&#34;, &#34;CallNonvirtualFloatMethod&#34;, &#34;CallNonvirtualFloatMethodV&#34;, &#34;CallNonvirtualFloatMethodA&#34;, &#34;CallNonvirtualDoubleMethod&#34;, &#34;CallNonvirtualDoubleMethodV&#34;,
    &#34;CallNonvirtualDoubleMethodA&#34;, &#34;CallNonvirtualVoidMethod&#34;, &#34;CallNonvirtualVoidMethodV&#34;, &#34;CallNonvirtualVoidMethodA&#34;, &#34;GetFieldID&#34;, &#34;GetObjectField&#34;, &#34;GetBooleanField&#34;, &#34;GetByteField&#34;, &#34;GetCharField&#34;, &#34;GetShortField&#34;, &#34;GetIntField&#34;,
    &#34;GetLongField&#34;, &#34;GetFloatField&#34;, &#34;GetDoubleField&#34;, &#34;SetObjectField&#34;, &#34;SetBooleanField&#34;, &#34;SetByteField&#34;, &#34;SetCharField&#34;, &#34;SetShortField&#34;, &#34;SetIntField&#34;, &#34;SetLongField&#34;, &#34;SetFloatField&#34;, &#34;SetDoubleField&#34;, &#34;GetStaticMethodID&#34;,
    &#34;CallStaticObjectMethod&#34;, &#34;CallStaticObjectMethodV&#34;, &#34;CallStaticObjectMethodA&#34;, &#34;CallStaticBooleanMethod&#34;, &#34;CallStaticBooleanMethodV&#34;, &#34;CallStaticBooleanMethodA&#34;, &#34;CallStaticByteMethod&#34;, &#34;CallStaticByteMethodV&#34;, &#34;CallStaticByteMethodA&#34;,
    &#34;CallStaticCharMethod&#34;, &#34;CallStaticCharMethodV&#34;, &#34;CallStaticCharMethodA&#34;, &#34;CallStaticShortMethod&#34;, &#34;CallStaticShortMethodV&#34;, &#34;CallStaticShortMethodA&#34;, &#34;CallStaticIntMethod&#34;, &#34;CallStaticIntMethodV&#34;, &#34;CallStaticIntMethodA&#34;, &#34;CallStaticLongMethod&#34;,
    &#34;CallStaticLongMethodV&#34;, &#34;CallStaticLongMethodA&#34;, &#34;CallStaticFloatMethod&#34;, &#34;CallStaticFloatMethodV&#34;, &#34;CallStaticFloatMethodA&#34;, &#34;CallStaticDoubleMethod&#34;, &#34;CallStaticDoubleMethodV&#34;, &#34;CallStaticDoubleMethodA&#34;, &#34;CallStaticVoidMethod&#34;,
    &#34;CallStaticVoidMethodV&#34;, &#34;CallStaticVoidMethodA&#34;, &#34;GetStaticFieldID&#34;, &#34;GetStaticObjectField&#34;, &#34;GetStaticBooleanField&#34;, &#34;GetStaticByteField&#34;, &#34;GetStaticCharField&#34;, &#34;GetStaticShortField&#34;, &#34;GetStaticIntField&#34;, &#34;GetStaticLongField&#34;,
    &#34;GetStaticFloatField&#34;, &#34;GetStaticDoubleField&#34;, &#34;SetStaticObjectField&#34;, &#34;SetStaticBooleanField&#34;, &#34;SetStaticByteField&#34;, &#34;SetStaticCharField&#34;, &#34;SetStaticShortField&#34;, &#34;SetStaticIntField&#34;, &#34;SetStaticLongField&#34;, &#34;SetStaticFloatField&#34;,
    &#34;SetStaticDoubleField&#34;, &#34;NewString&#34;, &#34;GetStringLength&#34;, &#34;GetStringChars&#34;, &#34;ReleaseStringChars&#34;, &#34;NewStringUTF&#34;, &#34;GetStringUTFLength&#34;, &#34;GetStringUTFChars&#34;, &#34;ReleaseStringUTFChars&#34;, &#34;GetArrayLength&#34;, &#34;NewObjectArray&#34;, &#34;GetObjectArrayElement&#34;,
    &#34;SetObjectArrayElement&#34;, &#34;NewBooleanArray&#34;, &#34;NewByteArray&#34;, &#34;NewCharArray&#34;, &#34;NewShortArray&#34;, &#34;NewIntArray&#34;, &#34;NewLongArray&#34;, &#34;NewFloatArray&#34;, &#34;NewDoubleArray&#34;, &#34;GetBooleanArrayElements&#34;, &#34;GetByteArrayElements&#34;, &#34;GetCharArrayElements&#34;,
    &#34;GetShortArrayElements&#34;, &#34;GetIntArrayElements&#34;, &#34;GetLongArrayElements&#34;, &#34;GetFloatArrayElements&#34;, &#34;GetDoubleArrayElements&#34;, &#34;ReleaseBooleanArrayElements&#34;, &#34;ReleaseByteArrayElements&#34;, &#34;ReleaseCharArrayElements&#34;, &#34;ReleaseShortArrayElements&#34;,
    &#34;ReleaseIntArrayElements&#34;, &#34;ReleaseLongArrayElements&#34;, &#34;ReleaseFloatArrayElements&#34;, &#34;ReleaseDoubleArrayElements&#34;, &#34;GetBooleanArrayRegion&#34;, &#34;GetByteArrayRegion&#34;, &#34;GetCharArrayRegion&#34;, &#34;GetShortArrayRegion&#34;, &#34;GetIntArrayRegion&#34;,
    &#34;GetLongArrayRegion&#34;, &#34;GetFloatArrayRegion&#34;, &#34;GetDoubleArrayRegion&#34;, &#34;SetBooleanArrayRegion&#34;, &#34;SetByteArrayRegion&#34;, &#34;SetCharArrayRegion&#34;, &#34;SetShortArrayRegion&#34;, &#34;SetIntArrayRegion&#34;, &#34;SetLongArrayRegion&#34;, &#34;SetFloatArrayRegion&#34;,
    &#34;SetDoubleArrayRegion&#34;, &#34;RegisterNatives&#34;, &#34;UnregisterNatives&#34;, &#34;MonitorEnter&#34;, &#34;MonitorExit&#34;, &#34;GetJavaVM&#34;, &#34;GetStringRegion&#34;, &#34;GetStringUTFRegion&#34;, &#34;GetPrimitiveArrayCritical&#34;, &#34;ReleasePrimitiveArrayCritical&#34;, &#34;GetStringCritical&#34;,
    &#34;ReleaseStringCritical&#34;, &#34;NewWeakGlobalRef&#34;, &#34;DeleteWeakGlobalRef&#34;, &#34;ExceptionCheck&#34;, &#34;NewDirectByteBuffer&#34;, &#34;GetDirectBufferAddress&#34;, &#34;GetDirectBufferCapacity&#34;, &#34;GetObjectRefType&#34;
]

function getJNIFunctionAdress(func_name){
    
    let jnienv_addr = Java.vm.getEnv().handle.readPointer()
    let offset = jni_struct_array.indexOf(func_name) * Process.pointerSize;
    return Memory.readPointer(jnienv_addr.add(offset))
}

function hook_jni(func_name){
    let listener = null;
    switch (func_name){
        case &#34;SetByteArrayRegion&#34;:
            listener = Interceptor.attach(getJNIFunctionAdress(func_name), {
                onEnter: function(args){
                    console.log(`env-&gt;${func_name} called from ${Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&#34;\n&#34;)}`);
                    this.arg_array = args[1];
                },
                onLeave: function(retval){
                    jbhexdump(this.arg_array);
                    console.log(&#34;SetByteArrayRegion onLeave&#34;);
                }
            })
        default:
            listener = Interceptor.attach(getJNIFunctionAdress(func_name), {
                onEnter: function(args){
                    console.log(`env-&gt;${func_name} called from ${Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&#34;\n&#34;)}`);
                }
            })
    }
    return listener;
}

function inline_hook(){
    let base_addr = Module.getBaseAddress(&#34;libpoxy_star.so&#34;);
    Interceptor.attach(base_addr.add(0xD9AC).add(1), {
        onEnter: function(args){
            this.hook_jni_interceptor = hook_jni(&#34;SetByteArrayRegion&#34;);
        },
        onLeave: function (retval) {
            this.hook_jni_interceptor.detach();
            console.log(`onLeave sub_D9AC`);
            jbhexdump(retval);
        }
    });
}

freeze_funcs();
inline_hook();
call_getByte();
</code></pre><p>这样追踪更方便，符合需求，输出结果如下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-26-48.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-26-48.png alt loading=lazy data-zoomable></div></div></figure></a></p><h2 id=返回结果反向推导与追踪>返回结果反向推导与追踪</h2><p>那就这个时候开始反向追踪了吗</p><p>不，让我们把它的调用流程图也弄出来</p><p>祭出 <a href=https://github.com/Pr0214/trace_natives target=_blank rel=noopener><strong>trace_natives</strong></a>，导入 IDA 插件，拿到要 trace 的函数列表</p><p><strong>frida-trace</strong> 一把梭，注意，为了得到调用层次分明的日志，这里直接重定向到文件</p><pre tabindex=0><code>frida-trace -UF -O libpoxy_star_1626418239.txt &gt; star_trace.log
</code></pre><p>建议先执行一次上面的命令，让它自动生成 js，停掉</p><p>然后去目标 js 加一个返回时的日志打印，再重新运行</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-58-37.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-58-37.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>第一次执行命令的时候比较慢，因为要生成 js，后面就很快了</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-55-24.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_14-55-24.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>然后执行主动调用脚本</p><p>得到记录后，找到添加的返回日志，把进入<code>sub_D9AD</code>到这里之间的内容单独拿出来</p><p>为什么这里是<code>sub_D9AD</code>而不是<code>sub_D9AC</code>请查阅 trace_natives 的 README</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-03-43.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-03-43.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>去除不相关的记录后依然有 1w + 行</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-10-00.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-10-00.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>当然还有办法精简，前面已经知道在进入<code>sub_13C7C</code>的时候，就已经产生最终结果了</p><p>那么只要<code>sub_13C7C</code>之前的记录即可</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-12-41.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-12-41.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>很好，现在只剩 1000 + 的记录了</p><p>根据调用记录，可以大致确定<code>sub_13C7C</code>由<code>sub_11AC0</code>调用</p><p>另外发现<code>sub_11AC0</code>所在位置非常靠前，说明它应该是运算的核心位置</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-15-03.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-15-03.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-18-46.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-18-46.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>现在可以反向追踪了，先看下最后这几个函数</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-23-35.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-23-35.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>并没有什么有用的信息，再往前是一个比较长的调用</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-25-21.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-25-21.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><code>sub_ABD9C</code>中只有两个函数调用</p><ul><li><code>sub_ABDBC</code></li><li><code>sub_AAE88</code></li></ul><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-27-42.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-27-42.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>这个时候，先看看参数内容，因为很有可能<code>sub_AAE88</code>之前就已经出现最终结果了</p><p>如果是这样就可以不分析<code>sub_AAE88</code>了</p><p>hook 代码如下</p><pre tabindex=0><code>function inline_hook(){
    let hook_flag = false;
    let base_addr = Module.getBaseAddress(&#34;libpoxy_star.so&#34;);
    Interceptor.attach(base_addr.add(0xD9AC).add(1), {
        onEnter: function(args){
            hook_flag = true;
            this.hook_jni_interceptor = hook_jni(&#34;SetByteArrayRegion&#34;);
        },
        onLeave: function (retval) {
            hook_flag = false;
            this.hook_jni_interceptor.detach();
            console.log(`onLeave sub_D9AC`);
            jbhexdump(retval);
        }
    });

    Interceptor.attach(base_addr.add(0xAAE88).add(1), {
        onEnter: function (args) {
            if(hook_flag){
                console.log(`call sub_AAE88`);
                this.arg_0 = args[0];
                console.log(&#34;sub_AAE88 arg_0&#34;, hexdump(args[0].readPointer()));
            }
        },
        onLeave: function (retval) {
            console.log(&#34;sub_AAE88 onLeave arg_0&#34;, hexdump(this.arg_0.readPointer()));
        }
    });
    Interceptor.attach(base_addr.add(0xABDBC).add(1), {
        onEnter: function (args) {
            if(hook_flag){
                console.log(`call sub_ABDBC`);
                this.arg_0 = args[0];
                console.log(&#34;sub_ABDBC arg_0&#34;, hexdump(args[0].readPointer()));
            }
        },
        onLeave: function (retval) {
            console.log(&#34;sub_ABDBC onLeave arg_0&#34;, hexdump(this.arg_0.readPointer()));
        }
    });
}
</code></pre><p>通过对比可以发现进入<code>sub_AAE88</code>时数据头部还不完整，但是后面的部分是一致的</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-37-27.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-37-27.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>仔细观察头部数据发现三个可疑点</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-41-53.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-41-53.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>首先是前四个字节，这会不会是什么校验呢</p><p>答案是否，可以通过变化传入参数确定这个位置是固定值</p><p>其次是 0x96，为何怀疑它，因为根据经验，一字节或两字节不为 0 前面为 0 的数据，很可能是后面数据的长度</p><blockquote><p>0x96 = 150 = 11 + 8 * 16 + 11</p></blockquote><p><code>96</code>起到<code>f7 d0</code>这里，长度刚好是 150，那没跑了，就是长度值</p><p>剩下一个<code>44 a7 2c da</code>，这有可能是什么呢</p><p>逆向常常需要靠经验和猜测，既然确定 0x96 是长度，那它后面应该就是一个完整的数据块</p><p>那么猜测它是后面数据的校验，提到数据校验，相信大家都会想到 <strong>CRC32</strong></p><p>用 <strong>CyberChef</strong> 验证一下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-51-39.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-51-39.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>猜测正确</p><p>那么头部前面还有一些<code>01 02 03 00</code>可能是什么呢</p><p>首先在最开始已经将随机数固定为<code>7</code>了，那么基本可以排除它们和随机数无关</p><p>可能是时间吗，显然可能性不大，而且可以通过变化传入参数，可以发现除了 CRC32 部分，其他内容不变</p><p>这样一来可以推测是一些固定或者变化比较简单的运算，那么先把它放一边吧</p><p>现在分析<code>sub_ABDBC</code>函数</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-57-43.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_15-57-43.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>可以看到里面有好几个重复函数，不多说，直接 hook 看参数内容</p><p>先看<code>sub_AC214</code>，参数内容都比较简单</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-00-47.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-00-47.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>然后是<code>sub_AD1D0</code>，参数内容也是最终结果里面的</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-21-36.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-21-36.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>根据以上信息，除去头部，对照内容后整理如下</p><table><thead><tr><th>tag</th><th>length</th><th>payload</th><th>func</th></tr></thead><tbody><tr><td>00 01</td><td>00 08</td><td>00 00 01 7a ad 34 cb 37</td><td>sub_AC214</td></tr><tr><td>00 02</td><td>00 0a</td><td>68 68 68 68 68 68 69 69 69 68</td><td>sub_AD1D0</td></tr><tr><td>00 03</td><td>00 04</td><td>01 00 00 01</td><td>sub_AC214</td></tr><tr><td>00 05</td><td>00 04</td><td>01 00 00 01</td><td>sub_AC214</td></tr><tr><td>00 04</td><td>00 04</td><td>00 00 00 00</td><td>sub_AC214</td></tr><tr><td>00 06</td><td>00 04</td><td>01 00 00 04</td><td>sub_AC214</td></tr><tr><td>00 07</td><td>00 04</td><td>01 00 00 02</td><td>sub_AC214</td></tr><tr><td>00 08</td><td>00 04</td><td>01 00 00 03</td><td>sub_AC214</td></tr><tr><td>00 09</td><td>00 20</td><td>45 4f 2a db 77 40 90 33 9f e2 58 8c 2f c6 4a 3d ce 7a c7 30 7d ce ac 0b aa b6 18 b3 6f 41 74 d3</td><td>sub_AD1D0</td></tr><tr><td>00 0a</td><td>00 10</td><td>cd b5 df 89 f5 2d 25 05 4b 85 81 f6 cf af 1e fb</td><td>sub_AD1D0</td></tr><tr><td>00 0b</td><td>00 10</td><td>fb 08 ad 5f af a8 93 35 2d 13 cb 93 27 e8 f7 fd</td><td>sub_AD1D0</td></tr></tbody></table><p><strong>第一个参数</strong>是什么呢，通过测试可以发现当<code>gettimeofday</code>返回固定，这个值就固定</p><p>是不是和时间有关系呢，答案是 yes</p><blockquote><p>0x0000017aad34cb37 = 1626403556151</p></blockquote><p>固定的时间代码片段如下</p><pre tabindex=0><code>let tm_s = 1626403551;
let tm_us = 5151606;
</code></pre><p>Q: 似乎有些对不上，这是什么问题呢<br>A: tm_us 是微秒，显然这里是 5.151606s，超过 1s 了</p><p>将<code>tm_us</code>改为<code>151606</code>，重新整理</p><table><thead><tr><th>tag</th><th>length</th><th>payload</th><th>func</th></tr></thead><tbody><tr><td>00 01</td><td>00 08</td><td>00 00 01 7a ad 34 b7 af</td><td>sub_AC214</td></tr><tr><td>00 02</td><td>00 0a</td><td>68 68 68 68 68 68 69 69 69 68</td><td>sub_AD1D0</td></tr><tr><td>00 03</td><td>00 04</td><td>01 00 00 01</td><td>sub_AC214</td></tr><tr><td>00 05</td><td>00 04</td><td>01 00 00 01</td><td>sub_AC214</td></tr><tr><td>00 04</td><td>00 04</td><td>00 00 00 00</td><td>sub_AC214</td></tr><tr><td>00 06</td><td>00 04</td><td>01 00 00 04</td><td>sub_AC214</td></tr><tr><td>00 07</td><td>00 04</td><td>01 00 00 02</td><td>sub_AC214</td></tr><tr><td>00 08</td><td>00 04</td><td>01 00 00 03</td><td>sub_AC214</td></tr><tr><td>00 09</td><td>00 20</td><td>ab a3 29 3c be 3f 85 56 42 c6 91 8c 0c e8 e2 a6 06 16 ff 83 47 44 ca c3 26 6d 6f 0c e4 3e c6 64</td><td>sub_AD1D0</td></tr><tr><td>00 0a</td><td>00 10</td><td>ea 36 73 53 c0 ac 2f 60 c7 96 68 ee f1 36 2d 3b</td><td>sub_AD1D0</td></tr><tr><td>00 0b</td><td>00 10</td><td>23 9e 8e 64 9b 2d 17 c7 56 af 13 57 d9 46 5d 41</td><td>sub_AD1D0</td></tr></tbody></table><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-42-44.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_16-42-44.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><strong>第二个参数</strong>是什么呢，通过变化传入参数等，观察结果可以知道是 lrand48 相关的</p><p>即原始数据应该是<code>aaaaaabbba</code>，它们的 ascii 码加上随机数就是第二个参数了</p><p><strong>第三到八个参数</strong>是什么呢，通过变化传入参数，可以确定任何参数都与它们无关，它们都是固定值</p><p><strong>第九个参数</strong>是什么呢，观察长度，发现它是 64 位的，并且变化随机数、时间都会引起改变</p><ul><li>修改时间的末尾三位不影响第九个参数</li><li>修改 getByte 除<code>obj4</code>外的参数不影响第九个参数</li></ul><p>那么说明这个参数和随机数、时间、obj4 相关</p><p>obj4 长度 27，随机数看第二个参数应该是有 10 个，时间长度是 8，加起来长度 45</p><p>结果是 64 位，那么是 AES 吗，答案是否，因为 AES 结果必然是 16 整数倍，而</p><blockquote><p>45 + 16 &lt; 64</p></blockquote><p>所以基本排除掉 AES，那么还有什么是 32 位呢</p><p>如果你经验丰富，那么肯定会想到 <strong>SHA256</strong> 在输入参数小于 64 的时候结果必然是 64 位</p><p>当然并不排除其他可能性，但目前看 <strong>SHA256</strong> 可能性最高</p><p><strong>第十和十一个参数又是什么呢</strong>，对剩下的函数一一查看，结果如下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-12-30.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-12-30.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>可以看出基本上和最后三个参数没有什么关系，32 位的话那么可能的算法就很多了，最值得怀疑的当然是最常见的 md5 了</p><p>虽然暂时不知道第九、十、十一参数算法，但是到这里<code>sub_ABDBC</code>完成分析了</p><p>那么现在应该看<code>sub_ABD9C</code>之前的函数了，即<code>sub_139A4</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-17-20.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-17-20.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>Interceptor.attach(base_addr.add(0x139A4).add(1), {
    onLeave: function (retval) {
        console.log(&#34;sub_139A4 retval&#34;, retval.readPointer());
    }
});
</code></pre><p>通过测试发现它的返回结果是<code>sub_ABDBC</code>的参数一，也就是放最终结果的地址</p><p>反编译代码中也没有其他特殊处理，那么可以跳过这个函数了</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-22-20.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-22-20.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>然后看<code>sub_AFAC4</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-25-55.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-25-55.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>也和结果没有什么关系</p><p>再往前看，可以发现是一个比较长的调用，这个函数就是<code>sub_5BF0</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-26-58.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-26-58.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>该函数主要调用了三个函数，<code>sub_6794</code>和<code>sub_68DC</code>和<code>sub_691C</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-28-53.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-28-53.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>先简单看下对应的反编译代码，发现前两个是 jni 相关的调用，最后一个<code>sub_691C</code>比较复杂</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-37-30.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-37-30.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>不管那么多，先把<code>sub_691C</code>的参数 hook 一下看看</p><p>然后并没有发现什么特别的东西&mldr;</p><p>进入<code>sub_691C</code>很快就会进入一个非常长的调用，结合之前猜测的 SHA256 和 md5，这里极有可能是两者之一</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-42-43.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-42-43.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>是时候祭出 <a href=https://github.com/Pr0214/findhash target=_blank rel=noopener><strong>findhash</strong></a> 了，运行插件，最终结果如下</p><pre tabindex=0><code>***************************在二进制文件中检索hash算法常量************************************
0xc9d3c:padding used in hashing algorithms (0x80 0 ... 0)
0xbd8bc:SHA256 / SHA224 K tabke
0x33ff9:函数sub_33FF8疑似哈希函数运算部分。
0x68d09:函数sub_68D08疑似哈希函数，包含初始化魔数的代码。
0x82485:函数sub_82484疑似哈希函数，包含初始化魔数的代码。
0x99a35:函数sub_99A34疑似哈希函数，包含初始化魔数的代码。
0xaae89:函数sub_AAE88疑似哈希函数，包含初始化魔数的代码。
***************************存在以下可疑的字符串************************************
0xbd1a0:/proc/self/cmdline
0xbd56c:/proc/self/cmdline
0xbda25:/proc/self/cmdline
***********************************************************************************
花费 41.270039081573486 秒，因为会对全部函数反编译，所以比较耗时间哈
</code></pre><p>对比调用日志，发现<code>sub_68D08</code>和<code>sub_82484</code>就在其中</p><p>另外<code>sub_AAE88</code>已经分析过了，这里检测到的应该是 <strong>CRC32</strong></p><p>先看看大量被调用的<code>sub_BB1A0</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-51-28.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-51-28.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>原来和算法无关&mldr; 那把它去除掉</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-49-18.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-49-18.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><code>sub_82484</code>离<code>sub_691C</code>不是很远，<code>sub_68D08</code>则稍微后面一点</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-55-24.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-55-24.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-56-15.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-56-15.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>那现在优先看看它们，<code>sub_82484</code>这显然是 SHA256 的魔数</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-57-30.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_17-57-30.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>为什么这么说呢，对比标准的 SHA256 算法就知道了嘛&mldr;</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-00-09.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-00-09.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>经过对比可以知道 init 这里的魔数有些不一样</p><p>插件还提示了<code>0xbd8bc:SHA256 / SHA224 K tabke</code>，看一下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-01-32.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-01-32.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>经过对比发现 K 表没有改变，另外发现 K 表就在 init 之后被使用</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-03-24.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-03-24.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>基本上可以推测是只改了魔数的 SHA256 算法，现在看看<code>sub_862B4</code></p><p>对比下一般的调用，是不是一模一样呢</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-08-06.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-08-06.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-07-07.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-07-07.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>把数据和返回 hook 一下</p><pre tabindex=0><code>Interceptor.attach(base_addr.add(0x82648).add(1), {
    onEnter: function (args) {
        console.log(`call sub_82648`);
        console.log(&#34;arg_1&#34;, hexdump(args[1].readByteArray(args[2].toUInt32())))
        console.log(&#34;arg_2&#34;, args[2].toUInt32())
    }
});
Interceptor.attach(base_addr.add(0x84890).add(1), {
    onEnter: function (args) {
        this.arg_1 = args[1];
    },
    onLeave: function (retval) {
        console.log(`sub_84890 onLeave`);
        console.log(&#34;arg_1&#34;, hexdump(this.arg_1))
    }
});
</code></pre><p>确认无误</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-15-09.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-15-09.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>算法还原参考 <strong>SHA256 算法还原</strong>小节，确认是仅修改了魔数的 SHA256 算法</p><p>但是传入数据显然还不是明文，来看看<code>sub_862B4</code>的调用函数<code>sub_864F0</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-24-09.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-24-09.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>可以看到只有两个 memcpy 动作，应该不涉及数据的修改</p><p>再看<code>sub_864F0</code>的调用函数<code>sub_85A40</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-26-09.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-26-09.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>没错，连续调用了两次<code>sub_864F0</code>，而<code>sub_864F0</code>内会调用<code>sub_862B4</code>等做 SHA256 运算</p><p>再看下 hook 结果，可以看出第一轮的 SHA256 结果被放到了第二轮 SHA256 的明文末尾</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-28-30.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-28-30.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>另外第一轮明文和第二轮明文中有大量重复的字符，是<code>sub_85A40</code>里面的明文字符串</p><pre tabindex=0><code>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\6666666666666666666666666666666666666666666666666666666666666666
</code></pre><p>这两个字符的 ASCII 分别是 0x5C 和 0x36</p><p>另外还能观察到第二轮明文里面的重复字符前面是 0x14 长度，刚好是 10 位</p><p>综合上述信息，可以推测实际上这是一个<code>HMAC-SHA256</code>算法，搜一个标准实现</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-44-37.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-44-37.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>这个可能看起来不太清晰，看这个</p><ul><li><a href=https://github.com/bitcoin/bitcoin/blob/master/src/crypto/hmac_sha256.cpp target=_blank rel=noopener>https://github.com/bitcoin/bitcoin/blob/master/src/crypto/hmac_sha256.cpp</a></li></ul><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-47-11.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-47-11.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>另外还有部分异或操作，另外可以确定没有走这里的<code>sub_862B4</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-52-42.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_18-52-42.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>现在看看传入参数，可以看到<code>sub_85A40</code>的 a2 应该是有内容的</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-07-42.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-07-42.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>并且后面和 v20 相与，根据这一点来看，属于稍稍修改过的<code>HMAC-SHA256</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-09-25.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-09-25.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>看看<code>sub_85A40</code>的 a2 是什么吧</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-11-36.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-11-36.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>刚好它是 0x14 长度，这和前面提到的那个内容匹配上了</p><p>再看看其他参数</p><pre tabindex=0><code>Interceptor.attach(base_addr.add(0x85A40).add(1), {
    onEnter: function (args) {
        console.log(`call sub_85A40`);
        console.log(&#34;sub_85A40 arg_1&#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
        console.log(&#34;sub_85A40 arg_2&#34;, args[2]);
        console.log(&#34;sub_85A40 arg_3&#34;, hexdump(args[3].readByteArray(args[4].toUInt32())));
        console.log(&#34;sub_85A40 arg_4&#34;, args[4]);
    }
});
</code></pre><p>出现了熟悉的内容，a2 应该是 key，a4 应该是明文</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-25-21.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-25-21.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-27-26.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-27-26.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>综合上述信息，可以进行还原了，具体参见 <strong>HMAC-SHA256 算法还原</strong>小节</p><p>至此参数九算法还原完成</p><p>上面都是基于<code>sub_82484</code>函数所推导的内容，现在可以看<code>sub_68D08</code>了，毕竟它也是被怀疑的哈希函数</p><p>查看反编译代码，显然这应该是一个 md5 函数，并且没有更改魔数</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-34-13.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-34-13.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>根据调用记录和已有信息，有理由推断就是这两个位置计算了出 md5 作为最终结果的</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-35-30.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-35-30.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>查看<code>sub_9DB88</code>，又是熟悉的样式</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-39-33.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-39-33.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>Interceptor.attach(base_addr.add(0x68E44).add(1), {
    onEnter: function (args) {
        console.log(`call sub_68E44`);
        console.log(&#34;sub_68E44 arg_1&#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
        console.log(&#34;sub_68E44 arg_2&#34;, args[2]);
    }
});
Interceptor.attach(base_addr.add(0x6D628).add(1), {
    onEnter: function (args) {
        this.arg_0 = args[0];
    },
    onLeave: function (retval) {
        console.log(&#34;sub_6D628 retval&#34;, hexdump(this.arg_0));
    }
});
</code></pre><p>看到了 md5 明文和返回结果</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-44-50.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-44-50.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>经过验证确定是标准的 md5</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-47-38.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-47-38.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>那么现在的问题就剩 md5 明文怎么来的了，接着看<code>sub_9DB88</code>调用</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-50-54.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-50-54.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>先看<code>sub_A70F4</code>，反编译代码如下，那么接着看<code>sub_A605C</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-51-57.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_19-51-57.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>对它的参数进行 hook</p><pre tabindex=0><code>Interceptor.attach(base_addr.add(0xA605C).add(1), {
    onEnter: function (args) {
        console.log(`call sub_A605C`);
        this.arg_6 = args[6];
        console.log(&#34;sub_A605C arg_1&#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
        console.log(&#34;sub_A605C arg_2&#34;, args[2]);
        console.log(&#34;sub_A605C arg_3&#34;, args[3]);
        console.log(&#34;sub_A605C arg_4&#34;, args[4]);
        console.log(&#34;sub_A605C arg_5&#34;, args[5]);
        console.log(&#34;sub_A605C arg_6&#34;, hexdump(args[6]));
        console.log(&#34;sub_A605C arg_7&#34;, hexdump(args[7].readByteArray(args[8].toUInt32())));
        console.log(&#34;sub_A605C arg_8&#34;, args[8]);
    },
    onLeave: function (retval) {
        console.log(&#34;sub_A605C retval&#34;, hexdump(this.arg_6));
    }
});
</code></pre><p>结果如下，可以看到有一个 0x14 长度的 key，即 HMAC-SHA256 用到的 key</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-01-55.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-01-55.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>0x23 长度的明文内容，返回结果就是后续 md5 的内容</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-05-12.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-05-12.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>那么现在参数十一的运算逻辑如下</p><blockquote><p>结果 = md5(转换函数 (明文 + key))</p></blockquote><p><code>sub_A605C</code>涉及两个运算，一个是<code>sub_A4550</code>，另外是一些位运算</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-08-45.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-08-45.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><code>sub_A4550</code>反编译结果如下，看起来想某种算法，经过检索，最终可以确定是 <strong>Salsa20</strong> 算法</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-15-12.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-15-12.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>魔数如下，不过对比标准算法后发现有很大差异</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-17-04.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-17-04.png alt loading=lazy data-zoomable></div></div></figure></a></p><ul><li><a href=https://botan.randombit.net/doxygen/salsa20_8cpp_source.html target=_blank rel=noopener>https://botan.randombit.net/doxygen/salsa20_8cpp_source.html</a></li></ul><p>这个代码看着可能吃力，可以看这个版本的</p><ul><li><a href=https://github.com/Daeinar/salsa20/blob/master/salsa.py target=_blank rel=noopener>https://github.com/Daeinar/salsa20/blob/master/salsa.py</a></li></ul><p>差异表现为以下几点</p><ul><li><p>state 数组的顺序不一样</p></li><li><p>_round 运算内的逻辑不一样，表现为</p><ul><li><p>原算法两个数先相加，结果循环左移，左移结果与另外的数异或</p></li><li><p>魔改算法分两种情况</p><ul><li>两个数相加 -> 结果与新的数相异或 -> 结果循环左移 -> 最终结果</li><li>两个数相加 -> 结果与新的数做<code>(a & ~b) | (b & ~a)</code>运算 -> 结果循环左移 -> 最终结果</li></ul></li></ul></li><li><p>_round 运算结束后，要交换 state 内数据，魔改算法没有这个过程</p></li><li><p>10 轮_round 运算</p></li></ul><p>基于上述结果重写了魔改后的 Salsa20 算法，其余信息参见 <strong>Salsa20 算法还原</strong>小节</p><p>至此参数十一算是还原完成了，可能会有疑问，key 怎么来的，不急后面有</p><p>现在开始看<code>sub_9CD48</code>，也就是对应参数十的计算过程</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-30-56.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-30-56.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>根据已有信息，可以知道<code>sub_9DB88</code>是 md5，那么看<code>sub_9C1F0</code></p><pre tabindex=0><code>Interceptor.attach(base_addr.add(0x9C1F0).add(1), {
    onEnter: function (args) {
        console.log(`call sub_9C1F0`);
        this.arg_3 = args[3];
        console.log(&#34;sub_9C1F0 arg_1&#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
        console.log(&#34;sub_9C1F0 arg_2&#34;, args[2]);
        console.log(&#34;sub_9C1F0 arg_3&#34;, hexdump(args[3]));
    },
    onLeave: function (retval) {
        console.log(&#34;sub_9C1F0 retval&#34;, hexdump(this.arg_3));
    }
});
</code></pre><p>似乎是明文传入，然后直接拿到了后续待 md5 的内容</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-35-45.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-35-45.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>顺便 hook 下<code>sub_9B980</code></p><pre tabindex=0><code>Interceptor.attach(base_addr.add(0x9B980).add(1), {
    onEnter: function (args) {
        console.log(`call sub_9B980`);
        this.arg_0 = args[0];
        console.log(&#34;sub_9B980 arg_0&#34;, hexdump(args[0]));
        console.log(&#34;sub_9B980 arg_1&#34;, hexdump(args[1].readByteArray(args[2].toUInt32())));
        console.log(&#34;sub_9B980 arg_2&#34;, args[2]);
    },
    onLeave: function (retval) {
        console.log(&#34;sub_9B980 retval&#34;, hexdump(this.arg_0));
    }
});
</code></pre><p>又一个熟悉的数据出现了，同时可以看到<code>sub_9B980</code>的参数一在函数结束后有了内容</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-39-10.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-39-10.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>先看看<code>sub_9C1F0</code>的转换</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-47-59.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-47-59.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>可以看到主要运算就是一系列位运算，简单分析如下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-50-15.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-50-15.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>这里比较简单，现在看<code>sub_9B980</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-52-03.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-52-03.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>这里和前面类似</p><p>综合以上信息编写还原算法如下</p><pre tabindex=0><code>def init_state(key: list):
    index = 0
    state = [_ for _ in range(256)]
    key = (key * ((256 // len(key)) + 1))[:256]
    for i in range(256):
        index = (index + key[i] + state[i]) % 256
        state[i], state[index] = state[index], state[i]
    return state


def enccypt_data(ori_data: bytes, key: list):
    state = init_state(key)
    index_1 = 0
    index_2 = 0
    _ori_data = [0] * len(ori_data)
    for offset, num in enumerate(list(ori_data)):
        index_1 = (index_1 + 1) % 256
        index_2 = (index_2 + state[index_1]) % 256
        tmp = state[index_1]
        state[index_1] = state[index_2]
        state[index_2] = tmp
        key_index = (state[index_2] + state[index_1]) &amp; 0xff
        _ori_data[offset] = (num &amp; ~state[key_index]) | (state[key_index] &amp; ~num)
    return bytes(_ori_data)


if __name__ == &#39;__main__&#39;:
    import binascii
    import hashlib
    key = binascii.a2b_hex(&#39;4f274c3f286b54372a40612428095143565e3140&#39;)
    data = binascii.a2b_hex(&#39;313632363430333535312c6e303033396579316d6d642c6e756c6c0000017aad34b7af&#39;)
    enc_data = enccypt_data(data, key)
    assert &#39;ea367353c0ac2f60c79668eef1362d3b&#39; == hashlib.new(&#39;md5&#39;, enc_data).hexdigest(), &#34;测试失败&#34;
    print(&#39;测试成功&#39;)
</code></pre><p>至此参数十也完成还原，现在就剩一个问题，<code>4f274c3f286b54372a40612428095143565e3140</code>从何处来</p><p>已知进行 HMAC-SHA256 转换时就出现了这个 key 了，key 是<code>sub_85A40</code>的传入参数，那么接着它往前看</p><p>结果它的调用函数<code>sub_86CD4</code>再向前似乎不太一样了</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-04-02.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-04-02.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>这是怎么回事呢</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-16.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-16.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>先看看调用日志，<code>sub_86CD4</code>同级前一个函数是<code>sub_8D970</code></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-57.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-05-57.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>果然这里暗藏玄机</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-11-08.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-11-08.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><code>sub_8DB6C</code>内部则是另一个跳转，显然这里没有跳，而是跳转到<code>sub_86CD4</code>了</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-12-24.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-12-24.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>看<code>sub_8D970</code>的调用处，结合上面的分析，这里 v16 经过<code>sub_8D970</code>后应该是拿到了<code>sub_86CD4</code>地址，但是实际没有产生调用</p><p>根据下面的 v7 定位到调用处</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-21-52.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-21-52.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>如图</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-24-04.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-24-04.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>通过 hook<code>sub_86CD4</code>参数可以知道其 a2 就是 key</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-25-53.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-25-53.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>那么应该定位 ptr 来源</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-27-23.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-27-23.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>然后能找到一个相关的地方</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-28-51.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-28-51.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>对<code>sub_87DD8</code>参数打印，结果如下</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-32-41.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-32-41.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>好起来了！参数二是明文，参数三在函数结束后就是 key</p><p><code>sub_87DD8</code>内两处关键位置，注意到<code>sub_89BF4</code>两次调用，且有一个参数是 10</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-35-42.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-35-42.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>通过 hook<code>sub_89BF4</code>的参数，可以发现该函数的功能是将传参数二末尾两位数据移动到头部</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-41-45.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-41-45.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>然后搜索 hex 发现它是一个硬编码的 key</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-44-59.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-44-59.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-45-59.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-45-59.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>是的，它在这里</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-46-43.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-46-43.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>IDA 看半天也看不出来参数怎么来的</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-52-56.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-52-56.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>用 cutter 看看</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-55-46.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_22-55-46.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>很好！</p><p>结合<code>sub_87DD8</code>末尾的位运算，现在可以编写 key 转换代码了</p><pre tabindex=0><code>def gen_key(rand_data: bytes = b&#39;hhhhhhiiih&#39;):
    data = list(binascii.a2b_hex(&#39;286b54372a4061244c3f&#39;))
    init_data_1 = data[-2:] + data[:-2]
    data = list(binascii.a2b_hex(&#39;392b3e365829264f4061&#39;))
    init_data_2 = data[-2:] + data[:-2]
    _rand_data = [num_1 ^ num_2 for num_1, num_2 in zip(list(rand_data), list(init_data_2))]
    init_data = _rand_data[-2:] + init_data_1 + _rand_data[:-2]
    print(&#39;key&#39;, bytes(init_data).hex())
    return init_data
</code></pre><h3 id=sha256-算法还原>SHA256 算法还原</h3><ul><li><a href=https://github.com/keanemind/Python-SHA-256 target=_blank rel=noopener>https://github.com/keanemind/Python-SHA-256</a></li></ul><p>将这个标准 SHA256 算法中的魔数修改，测试一下</p><p>修改部分伪代码如下</p><pre tabindex=0><code>def generate_hash(message: bytearray) -&gt; bytearray:
    
    h0 = 0x6A09E669
    h1 = 0xBB67AE87
    h2 = 0x3C6BF372
    h3 = 0xA54FF53A
    h5 = 0x9B25688C
    h4 = 0x511E527F
    h6 = 0x1F73D9AB
    h7 = 0x5BD0CD19
    

if __name__ == &#39;__main__&#39;:
    import binascii
    data = binascii.a2b_hex(b&#39;137b10637437086b761c3d7874550d1f0a026d1c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5caac3b82136d0d55907e5607db20a7da7e996d5d083c1edaa1c27252212c954ff&#39;)
    assert &#39;aba3293cbe3f855642c6918c0ce8e2a60616ff834744cac3266d6f0ce43ec664&#39; == generate_hash(data).hex(), &#39;测试失败&#39;
    print(&#39;测试成功&#39;)
</code></pre><p>测试通过</p><h3 id=hmac-sha256-算法还原>HMAC-SHA256 算法还原</h3><pre tabindex=0><code>def hmac_generate_hash(init_data: bytes, ori_data: bytes):
    init_data_1 = [0x36] * 64
    init_data_2 = [0x5C] * 64
    for index, (num_1, num_2) in enumerate(zip(init_data, init_data_1)):
        init_data_1[index] = num_1 ^ num_2
    for index, (num_1, num_2) in enumerate(zip(init_data, init_data_2)):
        init_data_2[index] = ((num_1 &amp; 0xE5) + (~num_1 &amp; 0x1A)) ^ ((num_2 &amp; 0xE5) + (~num_2 &amp; 0x1A))
    tmp_result = generate_hash(bytes(init_data_1) + ori_data)
    result = generate_hash(bytes(init_data_2) + tmp_result)
    return result

if __name__ == &#39;__main__&#39;:
    import binascii
    key = binascii.a2b_hex(&#39;4f274c3f286b54372a40612428095143565e3140&#39;)
    data = binascii.a2b_hex(&#39;313632363430333535312c6e303033396579316d6d642c6e756c6c0000017aad34b7af&#39;)
    assert &#39;aba3293cbe3f855642c6918c0ce8e2a60616ff834744cac3266d6f0ce43ec664&#39; == hmac_generate_hash(key, data).hex(), &#39;测试失败&#39;
    print(&#39;测试成功&#39;)
</code></pre><p>测试通过</p><h3 id=salsa20-算法还原>Salsa20 算法还原</h3><p>还原不易，相信看到这里的人应该都会了，就贴个关键部分截图吧</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-26-32.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_20-26-32.png alt loading=lazy data-zoomable></div></div></figure></a></p><h2 id=返回结果构成总结>返回结果构成总结</h2><p>表中的明文由<code>getByte传入参数obj4</code>和<code>gettimeofday返回结果</code>构成</p><p>hex 如下</p><blockquote><p>313632363430333535312c6e303033396579316d6d642c6e756c6c0000017aad34b7af</p></blockquote><table><thead><tr><th>tag</th><th>length</th><th>payload</th><th>说明</th></tr></thead><tbody><tr><td>-</td><td>-</td><td>68 65 68 61</td><td>固定值</td></tr><tr><td>-</td><td>-</td><td>00 00 00 01 01 00 00 00</td><td>固定值 后半部分由前半部分翻转得到</td></tr><tr><td>-</td><td>-</td><td>00 00 00 00 00</td><td>未修改</td></tr><tr><td>-</td><td>-</td><td>00 00 03 08</td><td>固定值 由 sub_175B4 产生</td></tr><tr><td>-</td><td>-</td><td>00 00 00 00</td><td>固定值</td></tr><tr><td>-</td><td>-</td><td>00 00 00 00</td><td>未修改</td></tr><tr><td>-</td><td>-</td><td>4b 46 ba a2</td><td>后续数据 CRC32</td></tr><tr><td>-</td><td>-</td><td>00 00 00 01</td><td>固定值</td></tr><tr><td>-</td><td>-</td><td>00 00 00 96</td><td>后续数据长度</td></tr><tr><td>00 01</td><td>00 08</td><td>00 00 01 7a ad 34 b7 af</td><td>gettimeofday</td></tr><tr><td>00 02</td><td>00 0a</td><td>68 68 68 68 68 68 69 69 69 68</td><td>10 位 (不完全) 随机种子</td></tr><tr><td>00 03</td><td>00 04</td><td>01 00 00 01</td><td>固定值</td></tr><tr><td>00 05</td><td>00 04</td><td>01 00 00 01</td><td>固定值</td></tr><tr><td>00 04</td><td>00 04</td><td>00 00 00 00</td><td>固定值</td></tr><tr><td>00 06</td><td>00 04</td><td>01 00 00 04</td><td>固定值</td></tr><tr><td>00 07</td><td>00 04</td><td>01 00 00 02</td><td>固定值</td></tr><tr><td>00 08</td><td>00 04</td><td>01 00 00 03</td><td>固定值</td></tr><tr><td>00 09</td><td>00 20</td><td>ab a3 29 3c be 3f 85 56 42 c6 91 8c 0c e8 e2 a6 06 16 ff 83 47 44 ca c3 26 6d 6f 0c e4 3e c6 64</td><td>HMAC-SHA256(随机种子 key, 明文)</td></tr><tr><td>00 0a</td><td>00 10</td><td>ea 36 73 53 c0 ac 2f 60 c7 96 68 ee f1 36 2d 3b</td><td>md5(数据交换运算 (随机种子 key, 明文))</td></tr><tr><td>00 0b</td><td>00 10</td><td>23 9e 8e 64 9b 2d 17 c7 56 af 13 57 d9 46 5d 41</td><td>md5(明文 ^ (Salsa20(随机种子 key, 固定数据)))</td></tr></tbody></table><p>补充</p><p><a href=https://blog.seeflower.dev/images/Snipaste_2021-07-16_23-11-24.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://blog.seeflower.dev/images/Snipaste_2021-07-16_23-11-24.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>其他部分固定值在<code>sub_AAE88</code>产生，就不展开了</p><ul><li><a href=https://gist.github.com/SeeFlowerX/373101e86529ae04807f634b87ac4c7c target=_blank rel=noopener>https://gist.github.com/SeeFlowerX/373101e86529ae04807f634b87ac4c7c</a></li></ul><p>感谢龙哥！</p></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>上一页</div><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/ rel=next>frida 免 root hook</a></div><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%BA%8C%E9%83%A8%E6%9B%B2%E6%9F%90-v5-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86-%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/ rel=prev>Js Ast 二部曲：某 V5 “绝对不可逆加密” 一探究竟</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>