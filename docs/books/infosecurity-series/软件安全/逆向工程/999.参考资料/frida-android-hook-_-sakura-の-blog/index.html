<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="本文由 简悦 SimpRead 转码， 原文地址 eternalsakura13.com 建了一个知识星球：天问之路如果想学习二进制安全，或者和我交流，欢迎来这里找我 w Frida 环境 https://github.com/frida/frida pyenvpython 全版本随机切换，这里提供&mldr;&mldr; 建了一个知识星球：天问之路 如"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/"><meta property="og:title" content="Frida Android hook _ Sakura の blog | Next-gen Tech Edu"><meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 eternalsakura13.com 建了一个知识星球：天问之路如果想学习二进制安全，或者和我交流，欢迎来这里找我 w Frida 环境 https://github.com/frida/frida pyenvpython 全版本随机切换，这里提供&mldr;&mldr; 建了一个知识星球：天问之路 如"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>Frida Android hook _ Sakura の blog | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=624bcf311ae89d785b4c946e51385757><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">999.参考资料</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ida13f9287bee731f41102d5bd6b06508c")' href=#ida13f9287bee731f41102d5bd6b06508c aria-expanded=false aria-controls=ida13f9287bee731f41102d5bd6b06508c aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/>逆向工程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ida13f9287bee731f41102d5bd6b06508c aria-expanded=false aria-controls=ida13f9287bee731f41102d5bd6b06508c><i class="fa-solid fa-angle-down" id=caret-ida13f9287bee731f41102d5bd6b06508c></i></a></div><ul class="nav docs-sidenav collapse show" id=ida13f9287bee731f41102d5bd6b06508c><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id86bfc41c09c9dc360469558f7d6c003b")' href=#id86bfc41c09c9dc360469558f7d6c003b aria-expanded=false aria-controls=id86bfc41c09c9dc360469558f7d6c003b aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>99.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id86bfc41c09c9dc360469558f7d6c003b aria-expanded=false aria-controls=id86bfc41c09c9dc360469558f7d6c003b><i class="fa-solid fa-angle-right" id=caret-id86bfc41c09c9dc360469558f7d6c003b></i></a></div><ul class="nav docs-sidenav collapse" id=id86bfc41c09c9dc360469558f7d6c003b><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-%E6%98%A5%E8%8A%82%E5%AE%89%E5%8D%93%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/>【2021 春节】安卓中级题逆向总结</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E8%BD%AC%E8%BD%BDunidbg-hook-%E5%A4%A7%E5%85%A8-seeflowerx/>【转载】Unidbg Hook 大全 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-%E6%9F%90%E5%AE%89%E5%8D%93-crackme-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>2022 某安卓 Crackme 流程分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/app-%E9%80%86%E5%90%91-%E5%B9%B3%E5%A4%B4%E5%93%A5%E5%AE%9E%E6%88%98%E6%9F%90%E5%86%9C%E4%BA%A7%E5%93%81-app/>app 逆向 平头哥实战（某农产品 app）</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/>Frida Android hook _ Sakura の blog</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/>frida 免 root hook</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/>getByte 算法分析与还原 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%BA%8C%E9%83%A8%E6%9B%B2%E6%9F%90-v5-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86-%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/>Js Ast 二部曲：某 V5 “绝对不可逆加密” 一探究竟</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%B8%80%E9%83%A8%E6%9B%B2%E9%AB%98%E5%AE%8C%E6%95%B4%E5%BA%A6%E8%BF%98%E5%8E%9F%E6%9F%90-v5-%E7%9A%84%E5%8A%A0%E5%AF%86/>Js Ast 一部曲：高完整度还原某 V5 的加密</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%A1%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F/>js 破解之补浏览器环境的两种监控方式</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/mtgsig2.1-%E7%89%88%E6%9C%AC%E4%B9%8B-a5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>mtgsig2.1 版本之 a5 算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/protobuf-%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90-app-%E7%88%AC%E8%99%AB-/>Protobuf 协议逆向解析 - APP 爬虫</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/proxy-%E4%BB%A3%E7%90%86%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9/>Proxy 代理（二次修改）</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/python-%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6%E5%BF%85%E5%A4%87-_-js-%E9%80%86%E5%90%91%E4%B9%8B%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8%E8%A1%A5%E4%BB%80%E4%B9%88/>Python 爬虫进阶必备 _ Js 逆向之补环境到底是在补什么？</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8A%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 上卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8B%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 下卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%AD%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 中卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%A4%A7%E7%8C%BF%E6%90%9C%E9%A2%98-sign-so-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90unidbg/>大猿搜题 sign so 加密参数分析｜unidbg</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA-android-%E9%80%9A%E7%94%A8-svc-%E8%B7%9F%E8%B8%AA%E4%BB%A5%E5%8F%8A-hook-%E6%96%B9%E6%A1%88frida-seccomp/>分享一个 Android 通用 svc 跟踪以及 hook 方案——Frida-Seccomp</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E4%B9%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>某乎请求头签名算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E5%92%96%E5%95%A1-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6%E7%89%88/>某咖啡 app 加密参数分析进阶版</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95-+-ollvm-%E6%B7%B7%E6%B7%86%E7%9A%84-crackme/>逆向分析反调试 + ollvm 混淆的 Crackme</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E7%88%AC%E8%99%AB%E4%B9%8B-%E6%9F%90%E7%94%9F%E9%B2%9C-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/>爬虫之 - 某生鲜 APP 加密参数逆向分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90-ja3-%E6%8C%87%E7%BA%B9%E5%8F%8A%E7%AA%81%E7%A0%B4/>深度剖析 ja3 指纹及突破</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idebb5db8060bce97b3f0cd1ac08912ddf")' href=#idebb5db8060bce97b3f0cd1ac08912ddf aria-expanded=false aria-controls=idebb5db8060bce97b3f0cd1ac08912ddf aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>999.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idebb5db8060bce97b3f0cd1ac08912ddf aria-expanded=false aria-controls=idebb5db8060bce97b3f0cd1ac08912ddf><i class="fa-solid fa-angle-down" id=caret-idebb5db8060bce97b3f0cd1ac08912ddf></i></a></div><ul class="nav docs-sidenav collapse show" id=idebb5db8060bce97b3f0cd1ac08912ddf><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-%E6%98%A5%E8%8A%82%E5%AE%89%E5%8D%93%E4%B8%AD%E7%BA%A7%E9%A2%98%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/>【2021 春节】安卓中级题逆向总结</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E8%BD%AC%E8%BD%BDunidbg-hook-%E5%A4%A7%E5%85%A8-seeflowerx/>【转载】Unidbg Hook 大全 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2022-%E6%9F%90%E5%AE%89%E5%8D%93-crackme-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/>2022 某安卓 Crackme 流程分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/app-%E9%80%86%E5%90%91-%E5%B9%B3%E5%A4%B4%E5%93%A5%E5%AE%9E%E6%88%98%E6%9F%90%E5%86%9C%E4%BA%A7%E5%93%81-app/>app 逆向 平头哥实战（某农产品 app）</a></li><li class="child level active"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-android-hook-_-sakura-%E3%81%AE-blog/>Frida Android hook _ Sakura の blog</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/>frida 免 root hook</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/getbyte-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F-seeflowerx/>getByte 算法分析与还原 - SeeFlowerX</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%BA%8C%E9%83%A8%E6%9B%B2%E6%9F%90-v5-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86-%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F/>Js Ast 二部曲：某 V5 “绝对不可逆加密” 一探究竟</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-ast-%E4%B8%80%E9%83%A8%E6%9B%B2%E9%AB%98%E5%AE%8C%E6%95%B4%E5%BA%A6%E8%BF%98%E5%8E%9F%E6%9F%90-v5-%E7%9A%84%E5%8A%A0%E5%AF%86/>Js Ast 一部曲：高完整度还原某 V5 的加密</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/js-%E7%A0%B4%E8%A7%A3%E4%B9%8B%E8%A1%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F/>js 破解之补浏览器环境的两种监控方式</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/mtgsig2.1-%E7%89%88%E6%9C%AC%E4%B9%8B-a5-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>mtgsig2.1 版本之 a5 算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/protobuf-%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90-app-%E7%88%AC%E8%99%AB-/>Protobuf 协议逆向解析 - APP 爬虫</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/proxy-%E4%BB%A3%E7%90%86%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9/>Proxy 代理（二次修改）</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/python-%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6%E5%BF%85%E5%A4%87-_-js-%E9%80%86%E5%90%91%E4%B9%8B%E8%A1%A5%E7%8E%AF%E5%A2%83%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8%E8%A1%A5%E4%BB%80%E4%B9%88/>Python 爬虫进阶必备 _ Js 逆向之补环境到底是在补什么？</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8A%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 上卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%8B%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 下卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/unidbg-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E6%9C%AF-%E6%9F%90%E6%B0%91%E5%AE%BF-app-%E7%AF%87-%E4%B8%AD%E5%8D%B7/>unidbg 算法还原术 · 某民宿 app 篇 · 中卷</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%A4%A7%E7%8C%BF%E6%90%9C%E9%A2%98-sign-so-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90unidbg/>大猿搜题 sign so 加密参数分析｜unidbg</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA-android-%E9%80%9A%E7%94%A8-svc-%E8%B7%9F%E8%B8%AA%E4%BB%A5%E5%8F%8A-hook-%E6%96%B9%E6%A1%88frida-seccomp/>分享一个 Android 通用 svc 跟踪以及 hook 方案——Frida-Seccomp</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E4%B9%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>某乎请求头签名算法分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%9F%90%E5%92%96%E5%95%A1-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90%E8%BF%9B%E9%98%B6%E7%89%88/>某咖啡 app 加密参数分析进阶版</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95-+-ollvm-%E6%B7%B7%E6%B7%86%E7%9A%84-crackme/>逆向分析反调试 + ollvm 混淆的 Crackme</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E7%88%AC%E8%99%AB%E4%B9%8B-%E6%9F%90%E7%94%9F%E9%B2%9C-app-%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/>爬虫之 - 某生鲜 APP 加密参数逆向分析</a></li><li class="child level"><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90-ja3-%E6%8C%87%E7%BA%B9%E5%8F%8A%E7%AA%81%E7%A0%B4/>深度剖析 ja3 指纹及突破</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#建了一个知识星球天问之路-建了一个知识星球天问之路建了一个知识星球天问之路><a href=#%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%EF%BC%9A%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF title=建了一个知识星球：天问之路></a>建了一个知识星球：天问之路</a></li><li><a href=#frida环境-frida环境frida-环境><a href=#Frida%E7%8E%AF%E5%A2%83 title=Frida环境></a>Frida 环境</a><ul><li><a href=#pyenv-pyenvpyenv><a href=#pyenv title=pyenv></a>pyenv</a></li><li><a href=#frida安装-frida安装frida-安装><a href=#frida%E5%AE%89%E8%A3%85 title=frida安装></a>frida 安装</a></li><li><a href=#安装objection-安装objection安装-objection><a href=#%E5%AE%89%E8%A3%85objection title=安装objection></a>安装 objection</a></li><li><a href=#frida使用-frida使用frida-使用><a href=#frida%E4%BD%BF%E7%94%A8 title=frida使用></a>frida 使用</a></li><li><a href=#frida开发环境搭建-frida开发环境搭建frida-开发环境搭建><a href=#frida%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA title=frida开发环境搭建></a>frida 开发环境搭建</a></li></ul></li><li><a href=#frida基础-frida基础frida-基础><a href=#FRIDA%E5%9F%BA%E7%A1%80 title=FRIDA基础></a>FRIDA 基础</a><ul><li><a href=#frida查看当前存在的进程-frida查看当前存在的进程frida-查看当前存在的进程><a href=#frida%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E8%BF%9B%E7%A8%8B title=frida查看当前存在的进程></a>frida 查看当前存在的进程</a></li><li><a href=#frida打印参数和修改返回值-frida打印参数和修改返回值frida-打印参数和修改返回值><a href=#frida%E6%89%93%E5%8D%B0%E5%8F%82%E6%95%B0%E5%92%8C%E4%BF%AE%E6%94%B9%E8%BF%94%E5%9B%9E%E5%80%BC title=frida打印参数和修改返回值></a>frida 打印参数和修改返回值</a></li><li><a href=#frida寻找instance主动调用frida寻找instance主动调用frida-寻找-instance主动调用><a href=#frida%E5%AF%BB%E6%89%BEinstance%EF%BC%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E3%80%82%22frida%E5%AF%BB%E6%89%BEinstance%EF%BC%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E3%80%82%22></a>frida 寻找 instance，主动调用。</a></li><li><a href=#frida-rpc-frida-rpcfrida-rpc><a href=#frida-rpc title="frida rpc"></a>frida rpc</a></li><li><a href=#frida动态修改-frida动态修改frida-动态修改><a href=#frida%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9 title=frida动态修改></a>frida 动态修改</a></li><li><a href=#api-list-api-listapi-list><a href=#API-List title="API List"></a>API List</a></li></ul></li><li><a href=#frida动静态结合分析-frida动静态结合分析frida-动静态结合分析><a href=#Frida%E5%8A%A8%E9%9D%99%E6%80%81%E7%BB%93%E5%90%88%E5%88%86%E6%9E%90 title=Frida动静态结合分析></a>Frida 动静态结合分析</a><ul><li><a href=#objection-objectionobjection><a href=#Objection title=Objection></a>Objection</a></li><li><a href=#案例学习-案例学习案例学习><a href=#%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0 title=案例学习></a>案例学习</a></li></ul></li><li><a href=#frida-hook基础-一-frida-hook基础一frida-hook-基础-一><a href=#Frida-hook%E5%9F%BA%E7%A1%80-%E4%B8%80 title="Frida hook基础(一)"></a>Frida hook 基础 (一)</a><ul><li><a href=#frida-hook-打印参数返回值-设置返回值-主动调用-frida-hook--打印参数返回值设置返回值主动调用frida-hook--打印参数返回值--设置返回值--主动调用><a href=#Frida-hook-%E6%89%93%E5%8D%B0%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-%E8%AE%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E5%80%BC-%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8 title="Frida hook : 打印参数、返回值/设置返回值/主动调用"></a>Frida hook : 打印参数、返回值 / 设置返回值 / 主动调用</a></li><li><a href=#frida-hook-主动调用静态-非静态函数-以及-设置静态-非静态成员变量的值-frida-hook--主动调用静态非静态函数-以及-设置静态非静态成员变量的值frida-hook--主动调用静态--非静态函数-以及-设置静态--非静态成员变量的值><a href=#Frida-hook-%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81-%E9%9D%9E%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0-%E4%BB%A5%E5%8F%8A-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC title="Frida hook : 主动调用静态/非静态函数 以及 设置静态/非静态成员变量的值"></a>Frida hook : 主动调用静态 / 非静态函数 以及 设置静态 / 非静态成员变量的值</a></li><li><a href=#frida-hook-内部类枚举类的函数并hooktrace原型1-frida-hook--内部类枚举类的函数并hooktrace原型1frida-hook--内部类枚举类的函数并-hooktrace-原型-1><a href=#Frida-hook-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%E5%B9%B6hook%EF%BC%8Ctrace%E5%8E%9F%E5%9E%8B1 title="Frida hook : 内部类，枚举类的函数并hook，trace原型1"></a>Frida hook : 内部类，枚举类的函数并 hook，trace 原型 1</a></li><li><a href=#frida-hook-hook动态加载的dex与查找interface-frida-hook--hook动态加载的dex与查找interfacefrida-hook--hook-动态加载的-dex与查找-interface><a href=#Frida-hook-hook%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84dex%EF%BC%8C%E4%B8%8E%E6%9F%A5%E6%89%BEinterface%EF%BC%8C title="Frida hook : hook动态加载的dex，与查找interface，"></a>Frida hook : hook 动态加载的 dex，与查找 interface，</a></li><li><a href=#frida-hook-枚举classtrace原型2-frida-hook--枚举classtrace原型2frida-hook--枚举-classtrace-原型-2><a href=#Frida-hook-%E6%9E%9A%E4%B8%BEclass%EF%BC%8Ctrace%E5%8E%9F%E5%9E%8B2 title="Frida hook : 枚举class，trace原型2"></a>Frida hook : 枚举 class，trace 原型 2</a></li><li><a href=#frida-hook-搜索interface的具体实现类-frida-hook--搜索interface的具体实现类frida-hook--搜索-interface-的具体实现类><a href=#Frida-hook-%E6%90%9C%E7%B4%A2interface%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB title="Frida hook : 搜索interface的具体实现类"></a>Frida hook : 搜索 interface 的具体实现类</a></li></ul></li><li><a href=#frida-hook基础二-frida-hook基础二frida-hook-基础二><a href=#Frida-hook%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C title="Frida hook基础（二)"></a>Frida hook 基础（二)</a><ul><li><a href=#spawn-attach-spawnattachspawnattach><a href=#spawn-attach title=spawn/attach></a>spawn/attach</a></li><li><a href=#frida-hook-hook构造函数-打印栈回溯-frida-hook-hook构造函数打印栈回溯frida-hook-hook-构造函数--打印栈回溯><a href=#Frida-hook-hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%89%93%E5%8D%B0%E6%A0%88%E5%9B%9E%E6%BA%AF title="Frida hook :hook构造函数/打印栈回溯"></a>Frida hook :hook 构造函数 / 打印栈回溯</a></li><li><a href=#frida-hook-打印栈回溯-frida-hook--打印栈回溯frida-hook--打印栈回溯><a href=#Frida-hook-%E6%89%93%E5%8D%B0%E6%A0%88%E5%9B%9E%E6%BA%AF title="Frida hook : 打印栈回溯"></a>Frida hook : 打印栈回溯</a></li><li><a href=#frida-hook-手动加载dex并调用-frida-hook--手动加载dex并调用frida-hook--手动加载-dex-并调用><a href=#Frida-hook-%E6%89%8B%E5%8A%A8%E5%8A%A0%E8%BD%BDdex%E5%B9%B6%E8%B0%83%E7%94%A8 title="Frida hook : 手动加载dex并调用"></a>Frida hook : 手动加载 dex 并调用</a></li></ul></li><li><a href=#frida打印与参数构造-frida打印与参数构造frida-打印与参数构造><a href=#Frida%E6%89%93%E5%8D%B0%E4%B8%8E%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0 title=Frida打印与参数构造></a>Frida 打印与参数构造</a><ul><li><a href=#char-object-object-charobject-objectcharobject-object><a href=#char-Object-Object title="char[]/[Object Object]"></a>char[]/[Object Object]</a></li><li><a href=#byte-bytebyte><a href=#byte title=byte[]></a>byte[]</a></li><li><a href=#java-array构造-java-array构造java-array-构造><a href=#java-array%E6%9E%84%E9%80%A0 title="java array构造"></a>java array 构造</a></li><li><a href=#类的多态转型-java-cast-类的多态转型javacast类的多态转型--javacast><a href=#%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81%EF%BC%9A%E8%BD%AC%E5%9E%8B-Java-cast title=类的多态：转型/Java.cast></a>类的多态：转型 / Java.cast</a></li><li><a href=#interface-java-registerclass-interfacejavaregisterclassinterfacejavaregisterclass><a href=#interface-Java-registerClass title=interface/Java.registerClass></a>interface/Java.registerClass</a></li><li><a href=#成员内部类-匿名内部类-成员内部类匿名内部类成员内部类--匿名内部类><a href=#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB title=成员内部类/匿名内部类></a>成员内部类 / 匿名内部类</a></li><li><a href=#hook-enum-hook-enumhook-enum><a href=#hook-enum title="hook enum"></a>hook enum</a></li><li><a href=#打印hash-map-打印hash-map打印-hash-map><a href=#%E6%89%93%E5%8D%B0hash-map title="打印hash map"></a>打印 hash map</a></li><li><a href=#打印non-ascii-打印non-ascii打印-non-ascii><a href=#%E6%89%93%E5%8D%B0non-ascii title=打印non-ascii></a>打印 non-ascii</a></li></ul></li><li><a href=#frida-native-hook-ndk开发入门-frida-native-hook--ndk开发入门frida-native-hook--ndk-开发入门><a href=#Frida-native-hook-NDK%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8 title="Frida native hook : NDK开发入门"></a>Frida native hook : NDK 开发入门</a></li><li><a href=#frida-native-hook-jnienv和反射-frida-native-hook--jnienv和反射frida-native-hook--jnienv-和反射><a href=#Frida-native-hook-JNIEnv%E5%92%8C%E5%8F%8D%E5%B0%84 title="Frida native hook : JNIEnv和反射"></a>Frida native hook : JNIEnv 和反射</a><ul><li><a href=#以jni字符串来掌握基本的jnienv用法-以jni字符串来掌握基本的jnienv用法以-jni-字符串来掌握基本的-jnienv-用法><a href=#%E4%BB%A5jni%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E6%8E%8C%E6%8F%A1%E5%9F%BA%E6%9C%AC%E7%9A%84JNIEnv%E7%94%A8%E6%B3%95 title=以jni字符串来掌握基本的JNIEnv用法></a>以 jni 字符串来掌握基本的 JNIEnv 用法</a></li><li><a href=#java反射-java反射java-反射><a href=#Java%E5%8F%8D%E5%B0%84 title=Java反射></a>Java 反射</a></li></ul></li><li><a href=#frida反调试-frida反调试frida-反调试><a href=#Frida%E5%8F%8D%E8%B0%83%E8%AF%95 title=Frida反调试></a>Frida 反调试</a></li><li><a href=#frida-native-hook-符号hook-jniart-amp-libc-frida-native-hook--符号hook-jniartlibcfrida-native-hook--符号-hook-jniartlibc><a href=#Frida-native-hook-%E7%AC%A6%E5%8F%B7hook-JNI%E3%80%81art-amp-libc title="Frida native hook : 符号hook JNI、art&libc"></a>Frida native hook : 符号 hook JNI、art&libc</a><ul><li><a href=#native函数的java-hook及主动调用-native函数的java-hook及主动调用native-函数的-java-hook-及主动调用><a href=#Native%E5%87%BD%E6%95%B0%E7%9A%84Java-Hook%E5%8F%8A%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8 title="Native函数的Java Hook及主动调用"></a>Native 函数的 Java Hook 及主动调用</a></li><li><a href=#jni-h头文件导入-jnih头文件导入jnih头文件导入><a href=#jni-h%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5 title=jni.h头文件导入></a><code>jni.h</code>头文件导入</a></li><li><a href=#jni函数符号hook-jni函数符号hookjni-函数符号-hook><a href=#JNI%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7hook title=JNI函数符号hook></a>JNI 函数符号 hook</a></li><li><a href=#jni函数参数返回值打印和替换-jni函数参数返回值打印和替换jni-函数参数返回值打印和替换><a href=#JNI%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E6%89%93%E5%8D%B0%E5%92%8C%E6%9B%BF%E6%8D%A2 title=JNI函数参数、返回值打印和替换></a>JNI 函数参数、返回值打印和替换</a></li></ul></li><li><a href=#frida-native-hook-jni-onload-动态注册-inline-hook-native层调用栈打印-frida-native-hook--jni_onload动态注册inline_hooknative层调用栈打印frida-native-hook--jni_onload--动态注册--inline_hooknative-层调用栈打印><a href=#Frida-native-hook-JNI-Onload-%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C-inline-hook-native%E5%B1%82%E8%B0%83%E7%94%A8%E6%A0%88%E6%89%93%E5%8D%B0 title="Frida native hook : JNI_Onload/动态注册/inline_hook/native层调用栈打印"></a>Frida native hook : JNI_Onload / 动态注册 / inline_hook/native 层调用栈打印</a><ul><li><a href=#jni-onload-动态注册原理-jni_onload动态注册原理jni_onload--动态注册原理><a href=#JNI-Onload-%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86 title=JNI_Onload/动态注册原理></a>JNI_Onload / 动态注册原理</a></li><li><a href=#frida-hook-registernative-frida-hook-registernativefrida-hook-registernative><a href=#Frida-hook-RegisterNative title="Frida hook RegisterNative"></a>Frida hook RegisterNative</a></li><li><a href=#native层调用栈打印-native层调用栈打印native-层调用栈打印><a href=#native%E5%B1%82%E8%B0%83%E7%94%A8%E6%A0%88%E6%89%93%E5%8D%B0 title=native层调用栈打印></a>native 层调用栈打印</a></li><li><a href=#主动调用去进行方法参数替换-主动调用去进行方法参数替换主动调用去进行方法参数替换><a href=#%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%8E%BB%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%9B%BF%E6%8D%A2 title=主动调用去进行方法参数替换></a>主动调用去进行方法参数替换</a></li><li><a href=#inline-hook-inline-hookinline-hook><a href=#inline-hook title="inline hook"></a>inline hook</a></li></ul></li><li><a href=#frida-native-hook-frida-hook-native-app实战-frida-native-hook--frida-hook-native-app实战frida-native-hook--frida-hook-native-app-实战><a href=#Frida-native-hook-Frida-hook-native-app%E5%AE%9E%E6%88%98 title="Frida native hook : Frida hook native app实战"></a>Frida native hook : Frida hook native app 实战</a></li><li><a href=#frida-trace四件套-frida-trace四件套frida-trace-四件套><a href=#Frida-trace%E5%9B%9B%E4%BB%B6%E5%A5%97 title="Frida trace四件套"></a>Frida trace 四件套</a><ul><li><a href=#jni-trace-trace-jni-jni-trace--trace-jnijni-trace--trace-jni><a href=#jni-trace-trace-jni title="jni trace : trace jni"></a>jni trace : trace jni</a></li><li><a href=#strace-trace-syscall-strace--trace-syscallstrace--trace-syscall><a href=#strace-trace-syscall title="strace : trace syscall"></a>strace : trace syscall</a></li><li><a href=#frida-trace-trace-libc-or-more-frida-trace--trace-libcor-morefrida-trace--trace-libcor-more><a href=#frida-trace-trace-libc-or-more title="frida-trace : trace libc(or more)"></a>frida-trace : trace libc(or more)</a></li><li><a href=#hook-artmethod-trace-java函数调用-hook_artmethod--trace-java函数调用hook_artmethod--trace-java-函数调用><a href=#hook-artmethod-trace-java%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8 title="hook_artmethod : trace java函数调用"></a>hook_artmethod : trace java 函数调用</a></li><li><a href=#修改aosp源码打印-修改aosp源码打印修改-aosp-源码打印><a href=#%E4%BF%AE%E6%94%B9AOSP%E6%BA%90%E7%A0%81%E6%89%93%E5%8D%B0 title=修改AOSP源码打印></a>修改 AOSP 源码打印</a></li></ul></li><li><a href=#frida-native-hook-init-array开发和自动化逆向-frida-native-hook--init_array开发和自动化逆向frida-native-hook--init_array-开发和自动化逆向><a href=#Frida-native-hook-init-array%E5%BC%80%E5%8F%91%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E9%80%86%E5%90%91 title="Frida native hook : init_array开发和自动化逆向"></a>Frida native hook : init_array 开发和自动化逆向</a><ul><li><a href=#init-array原理-init_array原理init_array-原理><a href=#init-array%E5%8E%9F%E7%90%86 title=init_array原理></a>init_array 原理</a></li><li><a href=#ida静态分析init-array-ida静态分析init_arrayida-静态分析-init_array><a href=#IDA%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90init-array title=IDA静态分析init_array></a>IDA 静态分析 init_array</a></li><li><a href=#ida动态调试so-ida动态调试soida-动态调试-so><a href=#IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so title=IDA动态调试so></a>IDA 动态调试 so</a></li><li><a href=#init-array-amp-amp-jni-onload-自吐-init_array--jni_onload-自吐init_array--jni_onload-自吐><a href=#init-array-amp-amp-JNI-Onload-%E2%80%9C%E8%87%AA%E5%90%90%E2%80%9D title="init_array && JNI_Onload “自吐”"></a>init_array && JNI_Onload “自吐”</a></li><li><a href=#native层未导出函数主动调用任意符号和地址-native层未导出函数主动调用任意符号和地址native-层未导出函数主动调用任意符号和地址><a href=#native%E5%B1%82%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%EF%BC%88%E4%BB%BB%E6%84%8F%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%89 title=native层未导出函数主动调用（任意符号和地址）></a>native 层未导出函数主动调用（任意符号和地址）</a></li></ul></li><li><a href=#c-c-hook-cc-hookcc-hook><a href=#C-C-hook title="C/C++ hook"></a>C/C++ hook</a><ul><li><a href=#native-jni层参数打印和主动调用参数构造-nativejni层参数打印和主动调用参数构造nativejni-层参数打印和主动调用参数构造><a href=#Native-JNI%E5%B1%82%E5%8F%82%E6%95%B0%E6%89%93%E5%8D%B0%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0 title=Native/JNI层参数打印和主动调用参数构造></a>Native/JNI 层参数打印和主动调用参数构造</a></li><li><a href=#c-c-编成so并引入frida调用其中的函数-cc编成so并引入frida调用其中的函数cc-编成-so-并引入-frida-调用其中的函数><a href=#C-C-%E7%BC%96%E6%88%90so%E5%B9%B6%E5%BC%95%E5%85%A5Frida%E8%B0%83%E7%94%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0 title=C/C++编成so并引入Frida调用其中的函数></a>C/C++ 编成 so 并引入 Frida 调用其中的函数</a></li></ul></li><li><a href=#致谢-致谢致谢><a href=#%E8%87%B4%E8%B0%A2 title=致谢></a>致谢</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>Frida Android hook _ Sakura の blog</h1><div class=article-style><blockquote><p>本文由 <a href=http://ksria.com/simpread/ target=_blank rel=noopener>简悦 SimpRead</a> 转码， 原文地址 <a href=https://eternalsakura13.com/2020/07/04/frida/ target=_blank rel=noopener>eternalsakura13.com</a></p></blockquote><blockquote><p>建了一个知识星球：天问之路如果想学习二进制安全，或者和我交流，欢迎来这里找我 w Frida 环境 <a href=https://github.com/frida/frida target=_blank rel=noopener>https://github.com/frida/frida</a> pyenvpython 全版本随机切换，这里提供&mldr;&mldr;</p></blockquote><h2 id=建了一个知识星球天问之路-建了一个知识星球天问之路建了一个知识星球天问之路><a href=#%e5%bb%ba%e4%ba%86%e4%b8%80%e4%b8%aa%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83%ef%bc%9a%e5%a4%a9%e9%97%ae%e4%b9%8b%e8%b7%af title=建了一个知识星球：天问之路></a>建了一个知识星球：天问之路</h2><p>如果想学习二进制安全，或者和我交流，欢迎来这里找我 w<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2021-06-22-034815.jpg target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2021-06-22-034815.jpg alt loading=lazy data-zoomable></div></div></figure></a></p><h2 id=frida环境-frida环境frida-环境><a href=#Frida%e7%8e%af%e5%a2%83 title=Frida环境></a>Frida 环境</h2><p><a href=https://github.com/frida/frida target=_blank rel=noopener>https://github.com/frida/frida</a></p><h3 id=pyenv-pyenvpyenv><a href=#pyenv title=pyenv></a>pyenv</h3><p>python 全版本随机切换，这里提供 <a href=https://github.com/pyenv/pyenv#homebrew-on-macos target=_blank rel=noopener>macOS 上的配置方法</a></p><pre tabindex=0><code>brew update
brew install pyenv
echo -e &#39;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n  eval &#34;$(pyenv init -)&#34;\nfi&#39; &gt;&gt; ~/.bash_profile
</code></pre><pre tabindex=0><code>下载一个3.8.2，下载真的很慢，要慢慢等
pyenv install 3.8.2

pyenv versions
sakura@sakuradeMacBook-Pro:~$ pyenv versions
  system
* 3.8.2 (set by /Users/sakura/.python-version)
切换到我们装的
pyenv local 3.8.2
python -V
pip -V
原本系统自带的
python local system
python -V
</code></pre><p>另外当你需要临时禁用 pyenv 的时候<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134140.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134140.png alt loading=lazy data-zoomable></div></div></figure></a><br>把这个注释了然后另开终端就好了。</p><p>关于卸载某个 python 版本</p><pre tabindex=0><code>Uninstalling Python Versions
As time goes on, you will accumulate Python versions in your $(pyenv root)/versions directory.

To remove old Python versions, pyenv uninstall command to automate the removal process.

Alternatively, simply rm -rf the directory of the version you want to remove. You can find the directory of a particular Python version with the pyenv prefix command, e.g. pyenv prefix 2.6.8.
</code></pre><h3 id=frida安装-frida安装frida-安装><a href=#frida%e5%ae%89%e8%a3%85 title=frida安装></a>frida 安装</h3><p>如果直接按下述安装则会直接安装 frida 和 frida-tools 的最新版本。</p><pre tabindex=0><code>pip install frida-tools
frida --version
frida-ps --version
</code></pre><p>我们也可以自由安装旧版本的 frida，例如 12.8.0</p><pre tabindex=0><code>pyenv install 3.7.7
pyenv local 3.7.7
pip install frida==12.8.0
pip install frida-tools==5.3.0
</code></pre><p>老版本 frida 和对应关系<br>对应关系很好找<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134837.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-04-17-134837.png alt loading=lazy data-zoomable></div></div></figure></a></p><h3 id=安装objection-安装objection安装-objection><a href=#%e5%ae%89%e8%a3%85objection title=安装objection></a>安装 objection</h3><pre tabindex=0><code>pyenv local 3.8.2
pip install objection
objection -h
</code></pre><pre tabindex=0><code>pyenv local 3.7.7
pip install objection==1.8.4
objection -h
</code></pre><h3 id=frida使用-frida使用frida-使用><a href=#frida%e4%bd%bf%e7%94%a8 title=frida使用></a>frida 使用</h3><p>下载 frida-server 并解压，在这里下载 <a href=https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz target=_blank rel=noopener>frida-server-12.8.0</a></p><p>先 adb shell，然后切换到 root 权限, 把之前 push 进来的 frida server 改个名字叫 fs<br>然后运行 frida</p><pre tabindex=0><code>adb push /Users/sakura/Desktop/lab/alpha/tools/android/frida-server-12.8.0-android-arm64 /data/local/tmp
chmod +x fs
./fs
</code></pre><p>如果要监听端口，就</p><pre tabindex=0><code>./fs -l 0.0.0.0:8888
</code></pre><h3 id=frida开发环境搭建-frida开发环境搭建frida-开发环境搭建><a href=#frida%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba title=frida开发环境搭建></a>frida 开发环境搭建</h3><ol><li><p>安装</p><pre tabindex=0><code>git clone https://github.com/oleavr/frida-agent-example.git
cd frida-agent-example/
npm install
</code></pre></li><li><p>使用 vscode 打开此工程，在 agent 文件夹下编写 js，会有智能提示。</p></li><li><p><code>npm run watch</code>会监控代码修改自动编译生成 js 文件</p></li><li><p>python 脚本或者 cli 加载_agent.js<br><code>frida -U -f com.example.android --no-pause -l _agent.js</code></p></li></ol><p>下面是测试脚本</p><p><code>s1.js</code></p><pre tabindex=0><code>function main() {
    Java.perform(function x() {
        console.log(&#34;sakura&#34;)
    })
}
setImmediate(main)
</code></pre><p><code>loader.py</code></p><pre tabindex=0><code>import time
import frida

device8 = frida.get_device_manager().add_remote_device(&#34;192.168.0.9:8888&#34;)
pid = device8.spawn(&#34;com.android.settings&#34;)
device8.resume(pid)
time.sleep(1)
session = device8.attach(pid)
with open(&#34;si.js&#34;) as f:
    script = session.create_script(f.read())
script.load()
input() #等待输入
</code></pre><p>解释一下，这个脚本就是先通过<code>frida.get_device_manager().add_remote_device</code>来找到 device, 然后 spawn 方式启动 settings，然后 attach 到上面，并执行 frida 脚本。</p><h2 id=frida基础-frida基础frida-基础><a href=#FRIDA%e5%9f%ba%e7%a1%80 title=FRIDA基础></a>FRIDA 基础</h2><h3 id=frida查看当前存在的进程-frida查看当前存在的进程frida-查看当前存在的进程><a href=#frida%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e5%ad%98%e5%9c%a8%e7%9a%84%e8%bf%9b%e7%a8%8b title=frida查看当前存在的进程></a>frida 查看当前存在的进程</h3><p><code>frida-ps -U</code>查看通过 usb 连接的 android 手机上的进程。</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ frida-ps --help
Usage: frida-ps [options]

Options:
  --version             show program&#39;s version number and exit
  -h, --help            show this help message and exit
  -D ID, --device=ID    connect to device with the given ID
  -U, --usb             connect to USB device
  -R, --remote          connect to remote frida-server
  -H HOST, --host=HOST  connect to remote frida-server on HOST
  -a, --applications    list only applications
  -i, --installed       include all installed applications
</code></pre><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ frida-ps -U
  PID  Name
-----  ---------------------------------------------------
 3640  ATFWD-daemon
  707  adbd
  728  adsprpcd
26041  android.hardware.audio@2.0-service
  741  android.hardware.biometrics.fingerprint@
</code></pre><p>通过 grep 过滤就可以找到我们想要的包名。</p><h3 id=frida打印参数和修改返回值-frida打印参数和修改返回值frida-打印参数和修改返回值><a href=#frida%e6%89%93%e5%8d%b0%e5%8f%82%e6%95%b0%e5%92%8c%e4%bf%ae%e6%94%b9%e8%bf%94%e5%9b%9e%e5%80%bc title=frida打印参数和修改返回值></a>frida 打印参数和修改返回值</h3><pre tabindex=0><code>package myapplication.example.com.frida_demo;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {

    private String total = &#34;@@@###@@@&#34;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        while (true){

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            fun(50,30);
            Log.d(&#34;sakura.string&#34; , fun(&#34;LoWeRcAsE Me!!!!!!!!!&#34;));
        }
    }

    void fun(int x , int y ){
        Log.d(&#34;sakura.Sum&#34; , String.valueOf(x+y));
    }

    String fun(String x){
        total +=x;
        return x.toLowerCase();
    }

    String secret(){
        return total;
    }
}
</code></pre><pre tabindex=0><code>function main() {
    console.log(&#34;Enter the Script!&#34;);
    Java.perform(function x() {
        console.log(&#34;Inside Java perform&#34;);
        var MainActivity = Java.use(&#34;myapplication.example.com.frida_demo.MainActivity&#34;);
        // 重载找到指定的函数
        MainActivity.fun.overload(&#39;java.lang.String&#39;).implementation = function (str) {
            //打印参数
            console.log(&#34;original call : str:&#34; + str);
            //修改结果
            var ret_value = &#34;sakura&#34;;
            return ret_value;
        };
    })
}
setImmediate(main);
</code></pre><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ frida-ps -U | grep frida
8738  frida-helper-32
8897  myapplication.example.com.frida_demo

// -f是通过spawn，也就是重启apk注入js
sakura@sakuradeMacBook-Pro:~$ frida -U -f myapplication.example.com.frida_demo -l frida_demo.js
...
original call : str:LoWeRcAsE Me!!!!!!!!!
12-21 04:46:49.875 9594-9594/myapplication.example.com.frida_demo D/sakura.string: sakura
</code></pre><h3 id=frida寻找instance主动调用frida寻找instance主动调用frida-寻找-instance主动调用><a href=#frida%e5%af%bb%e6%89%beinstance%ef%bc%8c%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e3%80%82%22frida%e5%af%bb%e6%89%beinstance%ef%bc%8c%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e3%80%82%22></a>frida 寻找 instance，主动调用。</h3><pre tabindex=0><code>function main() {
    console.log(&#34;Enter the Script!&#34;);
    Java.perform(function x() {
        console.log(&#34;Inside Java perform&#34;);
        var MainActivity = Java.use(&#34;myapplication.example.com.frida_demo.MainActivity&#34;);
        //overload 选择被重载的对象
        MainActivity.fun.overload(&#39;java.lang.String&#39;).implementation = function (str) {
            //打印参数
            console.log(&#34;original call : str:&#34; + str);
            //修改结果
            var ret_value = &#34;sakura&#34;;
            return ret_value;
        };
        // 寻找类型为classname的实例
        Java.choose(&#34;myapplication.example.com.frida_demo.MainActivity&#34;, {
            onMatch: function (x) {
                console.log(&#34;find instance :&#34; + x);
                console.log(&#34;result of secret func:&#34; + x.secret());
            },
            onComplete: function () {
                console.log(&#34;end&#34;);
            }
        });
    });
}
setImmediate(main);
</code></pre><h3 id=frida-rpc-frida-rpcfrida-rpc><a href=#frida-rpc title="frida rpc"></a>frida rpc</h3><pre tabindex=0><code>function callFun() {
    Java.perform(function fn() {
        console.log(&#34;begin&#34;);
        Java.choose(&#34;myapplication.example.com.frida_demo.MainActivity&#34;, {
            onMatch: function (x) {
                console.log(&#34;find instance :&#34; + x);
                console.log(&#34;result of fun(string) func:&#34; + x.fun(Java.use(&#34;java.lang.String&#34;).$new(&#34;sakura&#34;)));
            },
            onComplete: function () {
                console.log(&#34;end&#34;);
            }
        })
    })
}
rpc.exports = {
    callfun: callFun
};
</code></pre><pre tabindex=0><code>import time
import frida

device = frida.get_usb_device()
pid = device.spawn([&#34;myapplication.example.com.frida_demo&#34;])
device.resume(pid)
time.sleep(1)
session = device.attach(pid)
with open(&#34;frida_demo_rpc_call.js&#34;) as f:
    script = session.create_script(f.read())

def my_message_handler(message, payload):
    print(message)
    print(payload)

script.on(&#34;message&#34;, my_message_handler)
script.load()

script.exports.callfun()
</code></pre><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/gitsource/frida-agent-example/agent$ python frida_demo_rpc_loader.py
begin
find instance :myapplication.example.com.frida_demo.MainActivity@1d4b09d
result of fun(string):sakura
end
</code></pre><h3 id=frida动态修改-frida动态修改frida-动态修改><a href=#frida%e5%8a%a8%e6%80%81%e4%bf%ae%e6%94%b9 title=frida动态修改></a>frida 动态修改</h3><p>即将手机上的 app 的内容发送到 PC 上的 frida python 程序，然后处理后返回给 app，然后 app 再做后续的流程，核心是理解<code>send/recv</code>函数</p><pre tabindex=0><code>&lt;TextView
        android:id=&#34;@+id/textView&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:text=&#34;please input username and password&#34;
        app:layout_constraintBottom_toBottomOf=&#34;parent&#34;
        app:layout_constraintLeft_toLeftOf=&#34;parent&#34;
        app:layout_constraintRight_toRightOf=&#34;parent&#34;
        app:layout_constraintTop_toTopOf=&#34;parent&#34; /&gt;


    &lt;EditText
        android:id=&#34;@+id/editText&#34;
        android:layout_width=&#34;fill_parent&#34;
        android:layout_height=&#34;40dp&#34;
        android:hint=&#34;username&#34;
        android:maxLength=&#34;20&#34;
        app:layout_constraintBottom_toBottomOf=&#34;parent&#34;
        app:layout_constraintEnd_toEndOf=&#34;parent&#34;
        app:layout_constraintHorizontal_bias=&#34;1.0&#34;
        app:layout_constraintStart_toStartOf=&#34;parent&#34;
        app:layout_constraintTop_toTopOf=&#34;parent&#34;
        app:layout_constraintVertical_bias=&#34;0.095&#34; /&gt;

    &lt;EditText
        android:id=&#34;@+id/editText2&#34;
        android:layout_width=&#34;fill_parent&#34;
        android:layout_height=&#34;40dp&#34;
        android:hint=&#34;password&#34;
        android:maxLength=&#34;20&#34;
        app:layout_constraintBottom_toBottomOf=&#34;parent&#34;
        app:layout_constraintTop_toTopOf=&#34;parent&#34;
        app:layout_constraintVertical_bias=&#34;0.239&#34; /&gt;

    &lt;Button
        android:id=&#34;@+id/button&#34;
        android:layout_width=&#34;100dp&#34;
        android:layout_height=&#34;35dp&#34;
        android:layout_gravity=&#34;right|center_horizontal&#34;
        android:text=&#34;提交&#34;
        android:visibility=&#34;visible&#34;
        app:layout_constraintBottom_toBottomOf=&#34;parent&#34;
        app:layout_constraintEnd_toEndOf=&#34;parent&#34;
        app:layout_constraintStart_toStartOf=&#34;parent&#34;
        app:layout_constraintTop_toTopOf=&#34;parent&#34;
        app:layout_constraintVertical_bias=&#34;0.745&#34; /&gt;
</code></pre><pre tabindex=0><code>public class MainActivity extends AppCompatActivity {

    EditText username_et;
    EditText password_et;
    TextView message_tv;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        password_et = (EditText) this.findViewById(R.id.editText2);
        username_et = (EditText) this.findViewById(R.id.editText);
        message_tv = ((TextView) findViewById(R.id.textView));

        this.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                if (username_et.getText().toString().compareTo(&#34;admin&#34;) == 0) {
                    message_tv.setText(&#34;You cannot login as admin&#34;);
                    return;
                }
                //hook target
                message_tv.setText(&#34;Sending to the server :&#34; + Base64.encodeToString((username_et.getText().toString() + &#34;:&#34; + password_et.getText().toString()).getBytes(), Base64.DEFAULT));

            }
        });

    }
}
</code></pre><p>先分析问题，我的最终目标是让 message_tv.setText 可以” 发送”username 为 admin 的 base64 字符串。
那肯定是 hook TextView.setText 这个函数。</p><pre tabindex=0><code>console.log(&#34;Script loaded successfully &#34;);
Java.perform(function () {
    var tv_class = Java.use(&#34;android.widget.TextView&#34;);
    tv_class.setText.overload(&#34;java.lang.CharSequence&#34;).implementation = function (x) {
        var string_to_send = x.toString();
        var string_to_recv;
        send(string_to_send); // send data to python code
        recv(function (received_json_object) {
            string_to_recv = received_json_object.my_data
            console.log(&#34;string_to_recv: &#34; + string_to_recv);
        }).wait(); //block execution till the message is received
        var my_string = Java.use(&#34;java.lang.String&#34;).$new(string_to_recv);
        this.setText(my_string);
    }
});
</code></pre><pre tabindex=0><code>import time
import frida
import base64

def my_message_handler(message, payload):
    print(message)
    print(payload)
    if message[&#34;type&#34;] == &#34;send&#34;:
        print(message[&#34;payload&#34;])
        data = message[&#34;payload&#34;].split(&#34;:&#34;)[1].strip()
        print( &#39;message:&#39;, message)
        #data = data.decode(&#34;base64&#34;)
        #data = data
        data = str(base64.b64decode(data))
        print( &#39;data:&#39;,data)
        user, pw = data.split(&#34;:&#34;)
        print( &#39;pw:&#39;,pw)
        #data = (&#34;admin&#34; + &#34;:&#34; + pw).encode(&#34;base64&#34;)
        data = str(base64.b64encode((&#34;admin&#34; + &#34;:&#34; + pw).encode()))
        print( &#34;encoded data:&#34;, data)
        script.post({&#34;my_data&#34;: data})  # send JSON object
        print( &#34;Modified data sent&#34;)

device = frida.get_usb_device()
pid = device.spawn([&#34;myapplication.example.com.frida_demo&#34;])
device.resume(pid)
time.sleep(1)
session = device.attach(pid)
with open(&#34;frida_demo2.js&#34;) as f:
    script = session.create_script(f.read())
script.on(&#34;message&#34;, my_message_handler)
script.load()
input()
</code></pre><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/gitsource/frida-agent-example/agent$ python frida_demo_rpc_loader2.py
Script loaded successfully
{&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;Sending to the server :c2FrdXJhOjEyMzQ1Ng==\n&#39;}
None
Sending to the server :c2FrdXJhOjEyMzQ1Ng==

message: {&#39;type&#39;: &#39;send&#39;, &#39;payload&#39;: &#39;Sending to the server :c2FrdXJhOjEyMzQ1Ng==\n&#39;}
data: b&#39;sakura:123456&#39;
pw: 123456&#39;
encoded data: b&#39;YWRtaW46MTIzNDU2Jw==&#39;
Modified data sent
string_to_recv: b&#39;YWRtaW46MTIzNDU2Jw==&#39;
</code></pre><p>参考链接：<a href=https://github.com/Mind0xP/Frida-Python-Binding target=_blank rel=noopener>https://github.com/Mind0xP/Frida-Python-Binding</a></p><h3 id=api-list-api-listapi-list><a href=#API-List title="API List"></a>API List</h3><ul><li><code>Java.choose(className: string, callbacks: Java.ChooseCallbacks): void</code><br>通过扫描 Java VM 的堆来枚举 className 类的 live instance。</li><li><code>Java.use(className: string): Java.Wrapper&lt;{}></code><br>动态为 className 生成 JavaScript Wrapper，可以通过调用<code>$new()</code>来调用构造函数来实例化对象。
在实例上调用<code>$dispose()</code>以对其进行显式清理，或者等待 JavaScript 对象被 gc。</li><li><code>Java.perform(fn: () => void): void</code><br>Function to run while attached to the VM.<br>Ensures that the current thread is attached to the VM and calls fn. (This isn’t necessary in callbacks from Java.)<br>Will defer calling fn if the app’s class loader is not available yet. Use Java.performNow() if access to the app’s classes is not needed.</li><li><code>send(message: any, data?: ArrayBuffer | number[]): void</code><br>任何 JSON 可序列化的值。
将 JSON 序列化后的 message 发送到您的基于 Frida 的应用程序，并包含 (可选) 一些原始二进制数据。
The latter is useful if you e.g. dumped some memory using NativePointer#readByteArray().</li><li><code>recv(callback: MessageCallback): MessageRecvOperation</code><br>Requests callback to be called on the next message received from your Frida-based application.<br>This will only give you one message, so you need to call recv() again to receive the next one.</li><li><code>wait(): void</code><br>堵塞，直到 message 已经 receive 并且 callback 已经执行完毕并返回</li></ul><h2 id=frida动静态结合分析-frida动静态结合分析frida-动静态结合分析><a href=#Frida%e5%8a%a8%e9%9d%99%e6%80%81%e7%bb%93%e5%90%88%e5%88%86%e6%9e%90 title=Frida动静态结合分析></a>Frida 动静态结合分析</h2><h3 id=objection-objectionobjection><a href=#Objection title=Objection></a>Objection</h3><ul><li>参考这篇文章<br><a href=https://www.anquanke.com/post/id/197657 target=_blank rel=noopener>实用 FRIDA 进阶：内存漫游、hook anywhere、抓包</a></li><li>objection<br><a href=https://pypi.org/project/objection/ target=_blank rel=noopener>https://pypi.org/project/objection/</a></li></ul><h4 id=objection启动并注入内存-objection启动并注入内存objection-启动并注入内存><a href=#objection%e5%90%af%e5%8a%a8%e5%b9%b6%e6%b3%a8%e5%85%a5%e5%86%85%e5%ad%98 title=objection启动并注入内存></a>objection 启动并注入内存</h4><p><code>objection -d -g package_name explore</code></p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ objection -d -g com.android.settings explore
[debug] Agent path is: /Users/sakura/.pyenv/versions/3.7.7/lib/python3.7/site-packages/objection/agent.js
[debug] Injecting agent...
Using USB device `Google Pixel`
[debug] Attempting to attach to process: `com.android.settings`
[debug] Process attached!
Agent injected and responds ok!

     _   _         _   _
 ___| |_|_|___ ___| |_|_|___ ___
| . | . | | -_|  _|  _| | . |   |
|___|___| |___|___|_| |_|___|_|_|
      |___|(object)inject(ion) v1.8.4

     Runtime Mobile Exploration
        by: @leonjza from @sensepost

[tab] for command suggestions
com.android.settings on (google: 8.1.0) [usb] #
</code></pre><h4 id=objection-memory-objection-memoryobjection-memory><a href=#objection-memory title="objection memory"></a>objection memory</h4><h5 id=查看内存中加载的module-memory-list-modules-查看内存中加载的module-memory-list-modules查看内存中加载的-module-memory-list-modules><a href=#%e6%9f%a5%e7%9c%8b%e5%86%85%e5%ad%98%e4%b8%ad%e5%8a%a0%e8%bd%bd%e7%9a%84module-memory-list-modules title="查看内存中加载的module memory list modules"></a>查看内存中加载的 module <code>memory list modules</code></h5><pre tabindex=0><code>com.android.settings on (google: 8.1.0) [usb] # memory list modules
Save the output by adding `--json modules.json` to this command
Name                                             Base          Size                  Path
-----------------------------------------------  ------------  --------------------  ---------------------------------------------------------------
app_process64                                    0x64ce143000  32768 (32.0 KiB)      /system/bin/app_process64
libandroid_runtime.so                            0x7a90bc3000  1990656 (1.9 MiB)     /system/lib64/libandroid_runtime.so
libbinder.so                                     0x7a9379f000  557056 (544.0 KiB)    /system/lib64/libbinder.so
</code></pre><h5 id=查看库的导出函数-memory-list-exports-libssl-so-查看库的导出函数-memory-list-exports-libsslso查看库的导出函数-memory-list-exports-libsslso><a href=#%e6%9f%a5%e7%9c%8b%e5%ba%93%e7%9a%84%e5%af%bc%e5%87%ba%e5%87%bd%e6%95%b0-memory-list-exports-libssl-so title="查看库的导出函数 memory list exports libssl.so"></a>查看库的导出函数 <code>memory list exports libssl.so</code></h5><pre tabindex=0><code>com.android.settings on (google: 8.1.0) [usb] # memory list exports libssl.so
Save the output by adding `--json exports.json` to this command
Type      Name                                                   Address
--------  -----------------------------------------------------  ------------
function  SSL_use_certificate_ASN1                               0x7c8ff006f8
function  SSL_CTX_set_dos_protection_cb                          0x7c8ff077b8
function  SSL_SESSION_set_ex_data                                0x7c8ff098f4
function  SSL_CTX_set_session_psk_dhe_timeout                    0x7c8ff0a754
function  SSL_CTX_sess_accept                                    0x7c8ff063b8
function  SSL_select_next_proto                                  0x7c8ff06a74
</code></pre><h5 id=dump内存空间-dump内存空间dump-内存空间><a href=#dump%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4 title=dump内存空间></a>dump 内存空间</h5><ul><li><p><code>memory dump all 文件名</code></p></li><li><p><code>memory dump from_base 起始地址 字节数 文件名</code></p><h5 id=搜索内存空间-搜索内存空间搜索内存空间><a href=#%e6%90%9c%e7%b4%a2%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4 title=搜索内存空间></a>搜索内存空间</h5><p><code>Usage: memory search "&lt;pattern eg: 41 41 41 ?? 41>" (--string) (--offsets-only)</code></p></li></ul><h4 id=objection-android-objection-androidobjection-android><a href=#objection-android title="objection android"></a>objection android</h4><h5 id=内存堆搜索实例-android-heap-search-instances-类名-内存堆搜索实例-android-heap-search-instances-类名内存堆搜索实例-android-heap-search-instances-类名><a href=#%e5%86%85%e5%ad%98%e5%a0%86%e6%90%9c%e7%b4%a2%e5%ae%9e%e4%be%8b-android-heap-search-instances-%e7%b1%bb%e5%90%8d title="内存堆搜索实例 android heap search instances 类名"></a>内存堆搜索实例 <code>android heap search instances 类名</code></h5><p>在堆上搜索类的实例</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ objection -g myapplication.example.com.frida_demo explore
Using USB device `Google Pixel`
Agent injected and responds ok!

[usb] # android heap search instances myapplication.example.com.frida_demo
.MainActivity
Class instance enumeration complete for myapplication.example.com.frida_demo.MainActivity
Handle    Class                                              toString()
--------  -------------------------------------------------  ---------------------------------------------------------
0x2102    myapplication.example.com.frida_demo.MainActivity  myapplication.example.com.frida_demo.MainActivity@5b1b0af
</code></pre><h5 id=调用实例的方法-android-heap-execute-实例id-实例方法-调用实例的方法-android-heap-execute-实例id-实例方法调用实例的方法-android-heap-execute-实例id-实例方法><a href=#%e8%b0%83%e7%94%a8%e5%ae%9e%e4%be%8b%e7%9a%84%e6%96%b9%e6%b3%95-android-heap-execute-%e5%ae%9e%e4%be%8bID-%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95 title="调用实例的方法 android heap execute 实例ID 实例方法"></a>调用实例的方法 <code>android heap execute 实例ID 实例方法</code></h5><h5 id=查看当前可用的activity或者service-android-hooking-list-activities-services-查看当前可用的activity或者service-android-hooking-list-activitiesservices查看当前可用的-activity-或者-service-android-hooking-list-activitiesservices><a href=#%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e5%8f%af%e7%94%a8%e7%9a%84activity%e6%88%96%e8%80%85service-android-hooking-list-activities-services title="查看当前可用的activity或者service android hooking list activities/services"></a>查看当前可用的 activity 或者 service <code>android hooking list activities/services</code></h5><h5 id=直接启动activity或者服务-android-intent-launch-activity-launch-service-activity-服务-直接启动activity或者服务-android-intent-launch_activitylaunch_service-activity服务直接启动-activity-或者服务-android-intent-launch_activitylaunch_service-activity服务><a href=#%e7%9b%b4%e6%8e%a5%e5%90%af%e5%8a%a8activity%e6%88%96%e8%80%85%e6%9c%8d%e5%8a%a1-android-intent-launch-activity-launch-service-activity-%e6%9c%8d%e5%8a%a1 title="直接启动activity或者服务 android intent launch_activity/launch_service activity/服务"></a>直接启动 activity 或者服务 <code>android intent launch_activity/launch_service activity/服务</code></h5><p><code>android intent launch_activity com.android.settings.DisplaySettings</code><br>这个命令比较有趣的是用在如果有些设计的不好，可能就直接绕过了密码锁屏等直接进去。</p><pre tabindex=0><code>com.android.settings on (google: 8.1.0) [usb] # android hooking list services
com.android.settings.SettingsDumpService
com.android.settings.TetherService
com.android.settings.bluetooth.BluetoothPairingService
</code></pre><h5 id=列出内存中所有的类-android-hooking-list-classes-列出内存中所有的类-android-hooking-list-classes列出内存中所有的类-android-hooking-list-classes><a href=#%e5%88%97%e5%87%ba%e5%86%85%e5%ad%98%e4%b8%ad%e6%89%80%e6%9c%89%e7%9a%84%e7%b1%bb-android-hooking-list-classes title="列出内存中所有的类 android hooking list classes"></a>列出内存中所有的类 <code>android hooking list classes</code></h5><h5 id=在内存中所有已加载的类中搜索包含特定关键词的类-android-hooking-search-classes-display-在内存中所有已加载的类中搜索包含特定关键词的类android-hooking-search-classes-display在内存中所有已加载的类中搜索包含特定关键词的类android-hooking-search-classes-display><a href=#%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e6%89%80%e6%9c%89%e5%b7%b2%e5%8a%a0%e8%bd%bd%e7%9a%84%e7%b1%bb%e4%b8%ad%e6%90%9c%e7%b4%a2%e5%8c%85%e5%90%ab%e7%89%b9%e5%ae%9a%e5%85%b3%e9%94%ae%e8%af%8d%e7%9a%84%e7%b1%bb%e3%80%82-android-hooking-search-classes-display title="在内存中所有已加载的类中搜索包含特定关键词的类。android hooking search classes display"></a>在内存中所有已加载的类中搜索包含特定关键词的类。<code>android hooking search classes display</code></h5><pre tabindex=0><code>com.android.settings on (google: 8.1.0) [usb] # android hooking search classes display
[Landroid.icu.text.DisplayContext$Type;
[Landroid.icu.text.DisplayContext;
[Landroid.view.Display$Mode;
android.hardware.display.DisplayManager
android.hardware.display.DisplayManager$DisplayListener
android.hardware.display.DisplayManagerGlobal
</code></pre><h5 id=内存中搜索指定类的所有方法-android-hooking-list-class-methods-类名-内存中搜索指定类的所有方法-android-hooking-list-class_methods-类名内存中搜索指定类的所有方法-android-hooking-list-class_methods-类名><a href=#%e5%86%85%e5%ad%98%e4%b8%ad%e6%90%9c%e7%b4%a2%e6%8c%87%e5%ae%9a%e7%b1%bb%e7%9a%84%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95-android-hooking-list-class-methods-%e7%b1%bb%e5%90%8d title="内存中搜索指定类的所有方法 android hooking list class_methods 类名"></a>内存中搜索指定类的所有方法 <code>android hooking list class_methods 类名</code></h5><pre tabindex=0><code>com.android.settings on (google: 8.1.0) [usb] # android hooking list class_methods java.nio.charset.Charset
private static java.nio.charset.Charset java.nio.charset.Charset.lookup(java.lang.String)
private static java.nio.charset.Charset java.nio.charset.Charset.lookup2(java.lang.String)
private static java.nio.charset.Charset java.nio.charset.Charset.lookupViaProviders(java.lang.String)
</code></pre><h5 id=在内存中所有已加载的类的方法中搜索包含特定关键词的方法-android-hooking-search-methods-display-在内存中所有已加载的类的方法中搜索包含特定关键词的方法-android-hooking-search-methods-display在内存中所有已加载的类的方法中搜索包含特定关键词的方法-android-hooking-search-methods-display><a href=#%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e6%89%80%e6%9c%89%e5%b7%b2%e5%8a%a0%e8%bd%bd%e7%9a%84%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95%e4%b8%ad%e6%90%9c%e7%b4%a2%e5%8c%85%e5%90%ab%e7%89%b9%e5%ae%9a%e5%85%b3%e9%94%ae%e8%af%8d%e7%9a%84%e6%96%b9%e6%b3%95-android-hooking-search-methods-display title="在内存中所有已加载的类的方法中搜索包含特定关键词的方法 android hooking search methods display"></a>在内存中所有已加载的类的方法中搜索包含特定关键词的方法 <code>android hooking search methods display</code></h5><p>知道名字开始在内存里搜就很有用</p><pre tabindex=0><code>com.android.settings on (google: 8.1.0) [usb] # android hooking search methods display
Warning, searching all classes may take some time and in some cases, crash the target application.
Continue? [y/N]: y
Found 5529 classes, searching methods (this may take some time)...
android.app.ActionBar.getDisplayOptions
android.app.ActionBar.setDefaultDisplayHomeAsUpEnabled
android.app.ActionBar.setDisplayHomeAsUpEnabled
</code></pre><h5 id=hook类的方法hook类里的所有方法-具体某个方法-hook类的方法hook类里的所有方法具体某个方法hook-类的方法hook-类里的所有方法--具体某个方法><a href=#hook%e7%b1%bb%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%88hook%e7%b1%bb%e9%87%8c%e7%9a%84%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95-%e5%85%b7%e4%bd%93%e6%9f%90%e4%b8%aa%e6%96%b9%e6%b3%95%ef%bc%89 title=hook类的方法（hook类里的所有方法/具体某个方法）></a>hook 类的方法（hook 类里的所有方法 / 具体某个方法）</h5><ul><li><p><code>android hooking watch class 类名</code><br>这样就可以 hook 这个类里面的所有方法，每次调用都会被 log 出来。</p></li><li><p><code>android hooking watch class 类名 --dump-args --dump-backtrace --dump-return</code><br>在上面的基础上，额外 dump 参数，栈回溯，返回值</p><pre tabindex=0><code>android hooking watch class xxx.MainActivity --dump-args --dump-backtrace --dump-return
</code></pre></li><li><p><code>android hooking watch class_method 方法名</code></p><pre tabindex=0><code>//可以直接hook到所有重载
android hooking watch class_method xxx.MainActivity.fun --dump-args --dump-backtrace --dump-return
</code></pre><h4 id=grep-trick和文件保存-grep-trick和文件保存grep-trick-和文件保存><a href=#grep-trick%e5%92%8c%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98 title="grep trick和文件保存"></a>grep trick 和文件保存</h4><p>objection log 默认是不能用 grep 过滤的，但是可以通过<code>objection run xxx | grep yyy的</code>方式，从终端通过管道来过滤。
用法如下</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ objection -g com.android.settings run memory list modules | grep libc
Warning: Output is not to a terminal (fd=1).
libcutils.so                                     0x7a94a1c000  81920 (80.0 KiB)      /system/lib64/libcutils.so
libc++.so                                        0x7a9114e000  983040 (960.0 KiB)    /system/lib64/libc++.so
libc.so                                          0x7a9249d000  892928 (872.0 KiB)    /system/lib64/libc.so
libcrypto.so                                     0x7a92283000  1155072 (1.1 MiB)     /system/lib64/libcrypto.so
</code></pre><p>有的命令后面可以通过<code>--json logfile</code>来直接保存结果到文件里。
有的可以通过查看<code>.objection</code>文件里的输出 log 来查看结果。</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/.objection$ cat *log | grep -i display
android.hardware.display.DisplayManager
android.hardware.display.DisplayManager$DisplayListener
android.hardware.display.DisplayManagerGlobal
</code></pre></li></ul><h3 id=案例学习-案例学习案例学习><a href=#%e6%a1%88%e4%be%8b%e5%ad%a6%e4%b9%a0 title=案例学习></a>案例学习</h3><h4 id=案例学习case1-仿vx数据库原型取证逆向分析-案例学习case1仿vx数据库原型取证逆向分析案例学习-case1仿-vx-数据库原型取证逆向分析><a href=#%e6%a1%88%e4%be%8b%e5%ad%a6%e4%b9%a0case1-%e3%80%8a%e4%bb%bfVX%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e5%9e%8b%e5%8f%96%e8%af%81%e9%80%86%e5%90%91%e5%88%86%e6%9e%90%e3%80%8b title=案例学习case1:《仿VX数据库原型取证逆向分析》></a>案例学习 case1:《仿 VX 数据库原型取证逆向分析》</h4><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1082706" target=_blank rel=noopener>附件链接</a><br><a href=https://github.com/nelenkov/android-backup-extractor target=_blank rel=noopener>android-backup-extractor 工具链接</a></p><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-100849.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-100849.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn$ java -version
java version &#34;1.8.0_141&#34;

sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn$ java -jar abe-all.jar unpack 1.ab 1.tar
0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% 11% 12% 13% 14% 15% 16% 17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% 34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% 51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% 68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% 85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100%
9097216 bytes written to 1.tar.

...
sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn/apps/com.example.yaphetshan.tencentwelcome$ ls
Encryto.db _manifest  a          db
</code></pre><p>装个夜神模拟器玩</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:/Applications/NoxAppPlayer.app/Contents/MacOS$ ./adb connect 127.0.0.1:62001
* daemon not running. starting it now on port 5037 *
adb E  5139 141210 usb_osx.cpp:138] Unable to create an interface plug-in (e00002be)
* daemon started successfully *
connected to 127.0.0.1:62001
sakura@sakuradeMacBook-Pro:/Applications/NoxAppPlayer.app/Contents/MacOS$ ./adb shell
dream2qltechn:/ # whoami
root
dream2qltechn:/ # uname -a
Linux localhost 4.0.9+ #222 SMP PREEMPT Sat Mar 14 18:24:36 HKT 2020 i686
</code></pre><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-120749.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-120749.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121130.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121130.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>肯定还是先定位目标字符串<code>Wait a Minute,What was happend?</code><br>jadx 搜索字符串<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121255.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121255.png alt loading=lazy data-zoomable></div></div></figure></a></p><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121403.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-121403.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>重点在 a() 代码里，其实是根据明文的 name 和 password，然后<code>aVar.a(a2 + aVar.b(a2, contentValues.getAsString("password"))).substring(0, 7)</code>再做一遍复杂的计算并截取 7 位当做密码，传入 getWritableDatabase 去解密 demo.db 数据库。</p><p>所以我们 hook 一下 getWritableDatabase 即可。</p><pre tabindex=0><code>frida-ps -U
...
5662  com.example.yaphetshan.tencentwelcome


objection -d -g com.example.yaphetshan.tencentwelcome explore
</code></pre><p>看一下源码</p><pre tabindex=0><code>package net.sqlcipher.database;
...
public abstract class SQLiteOpenHelper {
    ...
    public synchronized SQLiteDatabase getWritableDatabase(char[] cArr) {
</code></pre><p>也可以 objection search 一下这个 method</p><pre tabindex=0><code>...mple.yaphetshan.tencentwelcome on (samsung: 7.1.2) [usb] # android hooking search methods getWritableDatabase
Warning, searching all classes may take some time and in some cases, crash the target application.
Continue? [y/N]: y
Found 4650 classes, searching methods (this may take some time)...

android.database.sqlite.SQLiteOpenHelper.getWritableDatabase
...
net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase
</code></pre><p>hook 一下这个 method</p><pre tabindex=0><code>[usb] # android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase --dump-args --dump-backtrace --dump-return
- [incoming message] ------------------
{
  &#34;payload&#34;: &#34;Attempting to watch class \u001b[32mnet.sqlcipher.database.SQLiteOpenHelper\u001b[39m and method \u001b[32mgetWritableDatabase\u001b[39m.&#34;,
  &#34;type&#34;: &#34;send&#34;
}
- [./incoming message] ----------------
(agent) Attempting to watch class net.sqlcipher.database.SQLiteOpenHelper and method getWritableDatabase.
- [incoming message] ------------------
{
  &#34;payload&#34;: &#34;Hooking \u001b[32mnet.sqlcipher.database.SQLiteOpenHelper\u001b[39m.\u001b[92mgetWritableDatabase\u001b[39m(\u001b[31mjava.lang.String\u001b[39m)&#34;,
  &#34;type&#34;: &#34;send&#34;
}
- [./incoming message] ----------------
(agent) Hooking net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(java.lang.String)
- [incoming message] ------------------
{
  &#34;payload&#34;: &#34;Hooking \u001b[32mnet.sqlcipher.database.SQLiteOpenHelper\u001b[39m.\u001b[92mgetWritableDatabase\u001b[39m(\u001b[31m[C\u001b[39m)&#34;,
  &#34;type&#34;: &#34;send&#34;
}
- [./incoming message] ----------------
(agent) Hooking net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase([C)
- [incoming message] ------------------
{
  &#34;payload&#34;: &#34;Registering job \u001b[94mjytq1qeyllq\u001b[39m. Type: \u001b[92mwatch-method for: net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase\u001b[39m&#34;,
  &#34;type&#34;: &#34;send&#34;
}
- [./incoming message] ----------------
(agent) Registering job jytq1qeyllq. Type: watch-method for: net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase
...mple.yaphetshan.tencentwelcome on (samsung: 7.1.2) [usb] #
</code></pre><p>hook 好之后再打开这个 apk<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125545.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125545.png alt loading=lazy data-zoomable></div></div></figure></a><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125604.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125604.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>(agent) [1v488x28gcs] Called net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(java.lang.String)
...
(agent) [1v488x28gcs] Backtrace:
	net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(Native Method)
	com.example.yaphetshan.tencentwelcome.MainActivity.a(MainActivity.java:55)
	com.example.yaphetshan.tencentwelcome.MainActivity.onCreate(MainActivity.java:42)
	android.app.Activity.performCreate(Activity.java:6692)
...
(agent) [1v488x28gcs] Arguments net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(ae56f99)

...
...mple.yaphetshan.tencentwelcome on (samsung: 7.1.2) [usb] # jobs list
Job ID         Hooks  Type
-----------  -------  -----------------------------------------------------------------------------
1v488x28gcs        2  watch-method for: net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase
</code></pre><p>找到参数<code>ae56f99</code><br>剩下的就是用这个密码去打开加密的 db。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125824.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-125824.png alt loading=lazy data-zoomable></div></div></figure></a><br>然后 base64 解密一下就好了。</p><p>还有一种策略是主动调用, 基于数据流的主动调用分析是非常有意思的。
即自己去调用 a 函数以触发 getWritableDatabase 的数据库解密。
先寻找 a 所在类的实例，然后 hook getWritableDatabase，最终主动调用 a。
这里幸运的是 a 没有什么奇奇怪怪的参数需要我们传入，主动调用这种策略在循环注册等地方可能就会有需求 8.</p><pre tabindex=0><code>[usb] # android heap search instances com.example.yaphetshan.tencentwelcome.MainActivity
Class instance enumeration complete for com.example.yaphetshan.tencentwelcome.MainActivity
Handle    Class                                               toString()
--------  --------------------------------------------------  ----------------------------------------------------------
0x20078a  com.example.yaphetshan.tencentwelcome.MainActivity  com.example.yaphetshan.tencentwelcome.MainActivity@1528f80

 [usb] # android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase --dump-args --dump-backtrace --dump-return

[usb] # android heap execute 0x20078a a

(agent) [taupgwkum4h] Arguments net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase(ae56f99)
</code></pre><h4 id=案例学习case2-主动调用爆破密码-案例学习case2主动调用爆破密码案例学习-case2-主动调用爆破密码><a href=#%e6%a1%88%e4%be%8b%e5%ad%a6%e4%b9%a0case2-%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e7%88%86%e7%a0%b4%e5%af%86%e7%a0%81 title=案例学习case2:主动调用爆破密码></a>案例学习 case2: 主动调用爆破密码</h4><p><a href=https://bbs.pediy.com/thread-257745.htm target=_blank rel=noopener>附件链接</a></p><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-132438.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-27-132438.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>因为直接找<code>Unfortunately,note the right PIN :(</code>找不到，可能是把字符串藏在什么资源文件里了。
review 代码之后找到校验的核心函数，逻辑就是将 input 编码一下之后和密码比较，这肯定是什么不可逆的加密。</p><pre tabindex=0><code>public static boolean verifyPassword(Context context, String input) {
    if (input.length() != 4) {
        return false;
    }
    byte[] v = encodePassword(input);
    byte[] p = &#34;09042ec2c2c08c4cbece042681caf1d13984f24a&#34;.getBytes();
    if (v.length != p.length) {
        return false;
    }
    for (int i = 0; i &lt; v.length; i++) {
        if (v[i] != p[i]) {
            return false;
        }
    }
    return true;
}
</code></pre><p>这里就爆破一下密码。</p><pre tabindex=0><code>frida-ps -U | grep qualification
7660  org.teamsik.ahe17.qualification.easy

frida -U org.teamsik.ahe17.qualification.easy -l force.js
</code></pre><pre tabindex=0><code>function main() {
    Java.perform(function x() {
        console.log(&#34;In Java perform&#34;)
        var verify = Java.use(&#34;org.teamsik.ahe17.qualification.Verifier&#34;)
        var stringClass = Java.use(&#34;java.lang.String&#34;)
        var p = stringClass.$new(&#34;09042ec2c2c08c4cbece042681caf1d13984f24a&#34;)
        var pSign = p.getBytes()
        // var pStr = stringClass.$new(pSign)
        // console.log(parseInt(pStr))
        for (var i = 999; i &lt; 10000; i++){
            var v = stringClass.$new(String(i))
            var vSign = verify.encodePassword(v)
            if (parseInt(stringClass.$new(pSign)) == parseInt(stringClass.$new(vSign))) {
                console.log(&#34;yes: &#34; + v)
                break
            }
            console.log(&#34;not :&#34; + v)
        }
    })
}
setImmediate(main)
</code></pre><pre tabindex=0><code>...
not :9080
not :9081
not :9082
yes: 9083
</code></pre><p>这里注意 parseInt</p><h2 id=frida-hook基础-一-frida-hook基础一frida-hook-基础-一><a href=#Frida-hook%e5%9f%ba%e7%a1%80-%e4%b8%80 title="Frida hook基础(一)"></a>Frida hook 基础 (一)</h2><ul><li>调用静态函数和调用非静态函数</li><li>设置 (同名) 成员变量</li><li>内部类，枚举类的函数并 hook，trace 原型 1</li><li>查找接口，hook 动态加载 dex</li><li>枚举 class，trace 原型 2</li><li>objection 不能切换 classloader</li></ul><h3 id=frida-hook-打印参数返回值-设置返回值-主动调用-frida-hook--打印参数返回值设置返回值主动调用frida-hook--打印参数返回值--设置返回值--主动调用><a href=#Frida-hook-%e6%89%93%e5%8d%b0%e5%8f%82%e6%95%b0%e3%80%81%e8%bf%94%e5%9b%9e%e5%80%bc-%e8%ae%be%e7%bd%ae%e8%bf%94%e5%9b%9e%e5%80%bc-%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8 title="Frida hook : 打印参数、返回值/设置返回值/主动调用"></a>Frida hook : 打印参数、返回值 / 设置返回值 / 主动调用</h3><p>demo 就不贴了，还是先定位登录失败点，然后搜索字符串。</p><pre tabindex=0><code>public class LoginActivity extends AppCompatActivity {
    /* access modifiers changed from: private */
    public Context mContext;

    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        this.mContext = this;
        setContentView((int) R.layout.activity_login);
        final EditText editText = (EditText) findViewById(R.id.username);
        final EditText editText2 = (EditText) findViewById(R.id.password);
        ((Button) findViewById(R.id.login)).setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                String obj = editText.getText().toString();
                String obj2 = editText2.getText().toString();
                if (TextUtils.isEmpty(obj) || TextUtils.isEmpty(obj2)) {
                    Toast.makeText(LoginActivity.this.mContext, &#34;username or password is empty.&#34;, 1).show();
                } else if (LoginActivity.a(obj, obj).equals(obj2)) {
                    LoginActivity.this.startActivity(new Intent(LoginActivity.this.mContext, FridaActivity1.class));
                    LoginActivity.this.finishActivity(0);
                } else {
                    Toast.makeText(LoginActivity.this.mContext, &#34;Login failed.&#34;, 1).show();
                }
            }
        });
    }
</code></pre><p><code>LoginActivity.a(obj, obj).equals(obj2)</code>分析之后可得 obj2 来自 password，由从 username 得来的 obj，经过 a 函数运算之后得到一个值，这两个值相等则登录成功。
所以这里关键是 hook a 函数的参数，最简脚本如下。</p><pre tabindex=0><code>//打印参数、返回值
function Login(){
    Java.perform(function(){
        Java.use(&#34;com.example.androiddemo.Activity.LoginActivity&#34;).a.overload(&#39;java.lang.String&#39;, &#39;java.lang.String&#39;).implementation = function (str, str2){
            var result = this.a(str, str2);
            console.log(&#34;args0:&#34;+str+&#34; args1:&#34;+str2+&#34; result:&#34;+result);
            return result;
        }
    })
}
setImmediate(Login)
</code></pre><p>观察输入和输出, 这里也可以直接主动调用。</p><pre tabindex=0><code>function login() {
    Java.perform(function () {
        console.log(&#34;start&#34;)
        var login = Java.use(&#34;com.example.androiddemo.Activity.LoginActivity&#34;)
        var result = login.a(&#34;1234&#34;,&#34;1234&#34;)
        console.log(result)
    })
}
setImmediate(login)
</code></pre><pre tabindex=0><code>...
start
4e4feaea959d426155a480dc07ef92f4754ee93edbe56d993d74f131497e66fb
然后
adb shell input text &#34;4e4feaea959d426155a480dc07ef92f4754ee93edbe56d993d74f131497e66fb&#34;
</code></pre><p>接下来是第一关</p><pre tabindex=0><code>public abstract class BaseFridaActivity extends AppCompatActivity implements View.OnClickListener {
    public Button mNextCheck;

    public void CheckSuccess() {
    }

    public abstract String getNextCheckTitle();

    public abstract void onCheck();

    /* access modifiers changed from: protected */
    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        setContentView((int) R.layout.activity_frida);
        this.mNextCheck = (Button) findViewById(R.id.next_check);
        this.mNextCheck.setOnClickListener(this);
        Button button = this.mNextCheck;
        button.setText(getNextCheckTitle() + &#34;，点击进入下一关&#34;);
    }

    public void onClick(View view) {
        onCheck();
    }

    public void CheckFailed() {
        Toast.makeText(this, &#34;Check Failed!&#34;, 1).show();
    }
}
...

public class FridaActivity1 extends BaseFridaActivity {
    private static final char[] table = {&#39;L&#39;, &#39;K&#39;, &#39;N&#39;, &#39;M&#39;, &#39;O&#39;, &#39;Q&#39;, &#39;P&#39;, &#39;R&#39;, &#39;S&#39;, &#39;A&#39;, &#39;T&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;, &#39;D&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;o&#39;, &#39;d&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;j&#39;, &#39;i&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;y&#39;, &#39;z&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;6&#39;, &#39;5&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;};

    public String getNextCheckTitle() {
        return &#34;当前第1关&#34;;
    }

    public void onCheck() {
        try {
            if (a(b(&#34;请输入密码:&#34;)).equals(&#34;R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&#34;)) {
                CheckSuccess();
                startActivity(new Intent(this, FridaActivity2.class));
                finishActivity(0);
                return;
            }
            super.CheckFailed();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String a(byte[] bArr) throws Exception {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt;= bArr.length - 1; i += 3) {
            byte[] bArr2 = new byte[4];
            byte b = 0;
            for (int i2 = 0; i2 &lt;= 2; i2++) {
                int i3 = i + i2;
                if (i3 &lt;= bArr.length - 1) {
                    bArr2[i2] = (byte) (b | ((bArr[i3] &amp; 255) &gt;&gt;&gt; ((i2 * 2) + 2)));
                    b = (byte) ((((bArr[i3] &amp; 255) &lt;&lt; (((2 - i2) * 2) + 2)) &amp; 255) &gt;&gt;&gt; 2);
                } else {
                    bArr2[i2] = b;
                    b = 64;
                }
            }
            bArr2[3] = b;
            for (int i4 = 0; i4 &lt;= 3; i4++) {
                if (bArr2[i4] &lt;= 63) {
                    sb.append(table[bArr2[i4]]);
                } else {
                    sb.append(&#39;=&#39;);
                }
            }
        }
        return sb.toString();
    }

    public static byte[] b(String str) {
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            GZIPOutputStream gZIPOutputStream = new GZIPOutputStream(byteArrayOutputStream);
            gZIPOutputStream.write(str.getBytes());
            gZIPOutputStream.finish();
            gZIPOutputStream.close();
            byte[] byteArray = byteArrayOutputStream.toByteArray();
            try {
                byteArrayOutputStream.close();
                return byteArray;
            } catch (Exception e) {
                e.printStackTrace();
                return byteArray;
            }
        } catch (Exception unused) {
            return null;
        }
    }
}
</code></pre><p>关键函数在<code>a(b("请输入密码:")).equals("R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=")</code><br>这里应该直接 hook a，让其返回值为<code>R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=</code>就可以进入下一关了。</p><pre tabindex=0><code>function ch1() {
    Java.perform(function () {
        console.log(&#34;start&#34;)
        Java.use(&#34;com.example.androiddemo.Activity.FridaActivity1&#34;).a.implementation = function (x) {
            return &#34;R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&#34;
        }
    })
}
</code></pre><h3 id=frida-hook-主动调用静态-非静态函数-以及-设置静态-非静态成员变量的值-frida-hook--主动调用静态非静态函数-以及-设置静态非静态成员变量的值frida-hook--主动调用静态--非静态函数-以及-设置静态--非静态成员变量的值><a href=#Frida-hook-%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e9%9d%99%e6%80%81-%e9%9d%9e%e9%9d%99%e6%80%81%e5%87%bd%e6%95%b0-%e4%bb%a5%e5%8f%8a-%e8%ae%be%e7%bd%ae%e9%9d%99%e6%80%81-%e9%9d%9e%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc title="Frida hook : 主动调用静态/非静态函数 以及 设置静态/非静态成员变量的值"></a>Frida hook : 主动调用静态 / 非静态函数 以及 设置静态 / 非静态成员变量的值</h3><p>总结:</p><ul><li>静态函数直接 use class 然后调用方法，非静态函数需要先 choose 实例然后调用</li><li>设置成员变量的值，写法是<code>xx.value = yy</code>，其他方面和函数一样。</li><li>如果有一个成员变量和成员函数的名字相同，则在其前面加一个<code>_</code>，如<code>_xx.value = yy</code></li></ul><p>然后是第二关</p><pre tabindex=0><code>public class FridaActivity2 extends BaseFridaActivity {
    private static boolean static_bool_var = false;
    private boolean bool_var = false;

    public String getNextCheckTitle() {
        return &#34;当前第2关&#34;;
    }

    private static void setStatic_bool_var() {
        static_bool_var = true;
    }

    private void setBool_var() {
        this.bool_var = true;
    }

    public void onCheck() {
        if (!static_bool_var || !this.bool_var) {
            super.CheckFailed();
            return;
        }
        CheckSuccess();
        startActivity(new Intent(this, FridaActivity3.class));
        finishActivity(0);
    }
}
</code></pre><p>这一关的关键在于下面的 if 判断要为 false，则<code>static_bool_var</code>和<code>this.bool_var</code>都要为 true。</p><pre tabindex=0><code>if (!static_bool_var || !this.bool_var) {
            super.CheckFailed();
            return;
        }
</code></pre><p>这样就要调用<code>setBool_var</code>和<code>setStatic_bool_var</code>两个函数了。</p><pre tabindex=0><code>function ch2() {
    Java.perform(function () {
        console.log(&#34;start&#34;)
        var FridaActivity2 = Java.use(&#34;com.example.androiddemo.Activity.FridaActivity2&#34;)
        //hook静态函数直接调用
        FridaActivity2.setStatic_bool_var()
        //hook动态函数，找到instance实例，从实例调用函数方法
        Java.choose(&#34;com.example.androiddemo.Activity.FridaActivity2&#34;, {
            onMatch: function (instance) {
                instance.setBool_var()
            },
            onComplete: function () {
                console.log(&#34;end&#34;)
            }
        })
    })
}
setImmediate(ch2)
</code></pre><p>接下来是第三关</p><pre tabindex=0><code>public class FridaActivity3 extends BaseFridaActivity {
    private static boolean static_bool_var = false;
    private boolean bool_var = false;
    private boolean same_name_bool_var = false;

    public String getNextCheckTitle() {
        return &#34;当前第3关&#34;;
    }

    private void same_name_bool_var() {
        Log.d(&#34;Frida&#34;, static_bool_var + &#34; &#34; + this.bool_var + &#34; &#34; + this.same_name_bool_var);
    }

    public void onCheck() {
        if (!static_bool_var || !this.bool_var || !this.same_name_bool_var) {
            super.CheckFailed();
            return;
        }
        CheckSuccess();
        startActivity(new Intent(this, FridaActivity4.class));
        finishActivity(0);
    }
}
</code></pre><p>关键还是让<code>if (!static_bool_var || !this.bool_var || !this.same_name_bool_var)</code>为 false，则三个变量都要为 true</p><pre tabindex=0><code>function ch3() {
    Java.perform(function () {
        console.log(&#34;start&#34;)
        var FridaActivity3 = Java.use(&#34;com.example.androiddemo.Activity.FridaActivity3&#34;)
        FridaActivity3.static_bool_var.value = true

        Java.choose(&#34;com.example.androiddemo.Activity.FridaActivity3&#34;, {
            onMatch: function (instance) {
                instance.bool_var.value = true
                instance._same_name_bool_var.value = true
            },
            onComplete: function () {
                console.log(&#34;end&#34;)
            }
        })
    })
}
</code></pre><p>这里要注意类里有一个成员函数和成员变量都叫做<code>same_name_bool_var</code>，这种时候在成员变量前加一个<code>_</code>，修改值的形式为<code>xx.value = yy</code></p><h3 id=frida-hook-内部类枚举类的函数并hooktrace原型1-frida-hook--内部类枚举类的函数并hooktrace原型1frida-hook--内部类枚举类的函数并-hooktrace-原型-1><a href=#Frida-hook-%e5%86%85%e9%83%a8%e7%b1%bb%ef%bc%8c%e6%9e%9a%e4%b8%be%e7%b1%bb%e7%9a%84%e5%87%bd%e6%95%b0%e5%b9%b6hook%ef%bc%8ctrace%e5%8e%9f%e5%9e%8b1 title="Frida hook : 内部类，枚举类的函数并hook，trace原型1"></a>Frida hook : 内部类，枚举类的函数并 hook，trace 原型 1</h3><p>总结:</p><ul><li>对于内部类，通过<code>类名$内部类名</code>去 use 或者 choose</li><li>对 use 得到的 clazz 应用反射，如<code>clazz.class.getDeclaredMethods()</code>可以得到类里面声明的所有方法，即可以枚举类里面的所有函数。</li></ul><p>接下来是第四关</p><pre tabindex=0><code>public class FridaActivity4 extends BaseFridaActivity {
    public String getNextCheckTitle() {
        return &#34;当前第4关&#34;;
    }

    private static class InnerClasses {
        public static boolean check1() {
            return false;
        }

        public static boolean check2() {
            return false;
        }

        public static boolean check3() {
            return false;
        }

        public static boolean check4() {
            return false;
        }

        public static boolean check5() {
            return false;
        }

        public static boolean check6() {
            return false;
        }

        private InnerClasses() {
        }
    }

    public void onCheck() {
        if (!InnerClasses.check1() || !InnerClasses.check2() || !InnerClasses.check3() || !InnerClasses.check4() || !InnerClasses.check5() || !InnerClasses.check6()) {
            super.CheckFailed();
            return;
        }
        CheckSuccess();
        startActivity(new Intent(this, FridaActivity5.class));
        finishActivity(0);
    }
}
</code></pre><p>这一关的关键是让<code>if (!InnerClasses.check1() || !InnerClasses.check2() || !InnerClasses.check3() || !InnerClasses.check4() || !InnerClasses.check5() || !InnerClasses.check6())</code>中的所有 check 全部返回 true。</p><p>其实这里唯一的问题就是寻找内部类<code>InnerClasses</code>，对于内部类的 hook，通过<code>类名$内部类名</code>去 use。</p><pre tabindex=0><code>function ch4() {
    Java.perform(function () {
        var InnerClasses = Java.use(&#34;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&#34;)
        console.log(&#34;start&#34;)
        InnerClasses.check1.implementation = function () {
            return true
        }
        InnerClasses.check2.implementation = function () {
            return true
        }
        InnerClasses.check3.implementation = function () {
            return true
        }
        InnerClasses.check4.implementation = function () {
            return true
        }
        InnerClasses.check5.implementation = function () {
            return true
        }
        InnerClasses.check6.implementation = function () {
            return true
        }
    })
}
</code></pre><p>利用反射，获取类中的所有 method 声明，然后字符串拼接去获取到方法名，例如下面的 check1，然后就可以批量 hook，而不用像我上面那样一个一个写。</p><pre tabindex=0><code>var inner_classes = Java.use(&#34;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&#34;)
var all_methods = inner_classes.class.getDeclaredMethods();

...
public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check1(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check2(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check3(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check4(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check5(),public static boolean com.example.androiddemo.Activity.FridaActivity4$InnerClasses.check6()
</code></pre><h3 id=frida-hook-hook动态加载的dex与查找interface-frida-hook--hook动态加载的dex与查找interfacefrida-hook--hook-动态加载的-dex与查找-interface><a href=#Frida-hook-hook%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd%e7%9a%84dex%ef%bc%8c%e4%b8%8e%e6%9f%a5%e6%89%beinterface%ef%bc%8c title="Frida hook : hook动态加载的dex，与查找interface，"></a>Frida hook : hook 动态加载的 dex，与查找 interface，</h3><p>总结:</p><ul><li>通过<code>enumerateClassLoaders</code>来枚举加载进内存的 classloader，再<code>loader.findClass(xxx)</code>寻找是否包括我们想要的 interface 的实现类，最后通过<code>Java.classFactory.loader = loader</code>来切换 classloader，从而加载该实现类。</li></ul><p>第五关比较有趣，它的 check 函数是动态加载进来的。
java 里有 interface 的概念，是指一系列抽象的接口，需要类来实现。</p><pre tabindex=0><code>package com.example.androiddemo.Dynamic;

public interface CheckInterface {
    boolean check();
}
...

public class DynamicCheck implements CheckInterface {
    public boolean check() {
        return false;
    }
}
...
public class FridaActivity5 extends BaseFridaActivity {
    private CheckInterface DynamicDexCheck = null;
    ...
    public CheckInterface getDynamicDexCheck() {
        if (this.DynamicDexCheck == null) {
            loaddex();
        }
        return this.DynamicDexCheck;
    }

    /* access modifiers changed from: protected */
    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        loaddex();
        //this.DynamicDexCheck = (CheckInterface) new DexClassLoader(str, filesDir.getAbsolutePath(), (String) null, getClassLoader()).loadClass(&#34;com.example.androiddemo.Dynamic.DynamicCheck&#34;).newInstance();
    }

    public void onCheck() {
        if (getDynamicDexCheck() == null) {
            Toast.makeText(this, &#34;onClick loaddex Failed!&#34;, 1).show();
        } else if (getDynamicDexCheck().check()) {
            CheckSuccess();
            startActivity(new Intent(this, FridaActivity6.class));
            finishActivity(0);
        } else {
            super.CheckFailed();
        }
    }
}
</code></pre><p>这里有个 loaddex 其实就是先从资源文件加载 classloader 到内存里，再 loadClass DynamicCheck，创建出一个实例，最终调用这个实例的 check。
所以现在我们就要先枚举 class loader，找到能实例化我们要的 class 的那个 class loader，然后把它设置成 Java 的默认 class factory 的 loader。
现在就可以用这个 class loader 来使用<code>.use</code>去 import 一个给定的类。</p><pre tabindex=0><code>function ch5() {
    Java.perform(function () {
        // Java.choose(&#34;com.example.androiddemo.Activity.FridaActivity5&#34;,{
        //     onMatch:function(x){
        //         console.log(x.getDynamicDexCheck().$className)
        //     },onComplete:function(){}
        // })
        console.log(&#34;start&#34;)
        Java.enumerateClassLoaders({
            onMatch: function (loader) {
                try {
                    if(loader.findClass(&#34;com.example.androiddemo.Dynamic.DynamicCheck&#34;)){
                        console.log(&#34;Successfully found loader&#34;)
                        console.log(loader);
                        Java.classFactory.loader = loader ;
                    }
                }
                catch(error){
                    console.log(&#34;find error:&#34; + error)
                }
            },
            onComplete: function () {
                console.log(&#34;end1&#34;)
            }
        })
        Java.use(&#34;com.example.androiddemo.Dynamic.DynamicCheck&#34;).check.implementation = function () {
            return true
        }
        console.log(&#34;end2&#34;)
    })
}
setImmediate(ch5)
</code></pre><p>todo 有一个疑问<br><a href=https://github.com/frida/frida/issues/1049 target=_blank rel=noopener>https://github.com/frida/frida/issues/1049</a></p><h3 id=frida-hook-枚举classtrace原型2-frida-hook--枚举classtrace原型2frida-hook--枚举-classtrace-原型-2><a href=#Frida-hook-%e6%9e%9a%e4%b8%beclass%ef%bc%8ctrace%e5%8e%9f%e5%9e%8b2 title="Frida hook : 枚举class，trace原型2"></a>Frida hook : 枚举 class，trace 原型 2</h3><p>总结: 通过<code>Java.enumerateLoadedClasses</code>来枚举类，然后<code>name.indexOf(str)</code>过滤一下并 hook。</p><p>接下来是第六关</p><pre tabindex=0><code>import com.example.androiddemo.Activity.Frida6.Frida6Class0;
import com.example.androiddemo.Activity.Frida6.Frida6Class1;
import com.example.androiddemo.Activity.Frida6.Frida6Class2;

public class FridaActivity6 extends BaseFridaActivity {
    public String getNextCheckTitle() {
        return &#34;当前第6关&#34;;
    }

    public void onCheck() {
        if (!Frida6Class0.check() || !Frida6Class1.check() || !Frida6Class2.check()) {
            super.CheckFailed();
            return;
        }
        CheckSuccess();
        startActivity(new Intent(this, FridaActivity7.class));
        finishActivity(0);
    }
}
</code></pre><p>这关是 import 了一些类，然后调用类里的静态方法，所以我们枚举所有的类，然后过滤一下，并把过滤出来的结果 hook 上，改掉其返回值。</p><pre tabindex=0><code>function ch6() {
    Java.perform(function () {
        Java.enumerateLoadedClasses({
            onMatch: function (name, handle){
                if (name.indexOf(&#34;com.example.androiddemo.Activity.Frida6&#34;) != -1) {
                    console.log(&#34;name:&#34; + name + &#34; handle:&#34; + handle)
                    Java.use(name).check.implementation = function () {
                        return true
                    }
                }
            },
            onComplete: function () {
                console.log(&#34;end&#34;)
            }
        })
    })
}
</code></pre><h3 id=frida-hook-搜索interface的具体实现类-frida-hook--搜索interface的具体实现类frida-hook--搜索-interface-的具体实现类><a href=#Frida-hook-%e6%90%9c%e7%b4%a2interface%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e7%b1%bb title="Frida hook : 搜索interface的具体实现类"></a>Frida hook : 搜索 interface 的具体实现类</h3><p>利用反射得到类里面实现的 interface 数组，并打印出来。</p><pre tabindex=0><code>function more() {
    Java.perform(function () {
        Java.enumerateLoadedClasses({
            onMatch: function (class_name){
                if (class_name.indexOf(&#34;com.example.androiddemo&#34;) &lt; 0) {
                    return
                }
                else {
                    var hook_cls = Java.use(class_name)
                    var interfaces = hook_cls.class.getInterfaces()
                    if (interfaces.length &gt; 0) {
                        console.log(class_name + &#34;: &#34;)
                        for (var i in interfaces) {
                            console.log(&#34;\t&#34;, interfaces[i].toString())
                        }
                    }
                }
            },
            onComplete: function () {
                console.log(&#34;end&#34;)
            }
        })
    })
}
</code></pre><h2 id=frida-hook基础二-frida-hook基础二frida-hook-基础二><a href=#Frida-hook%e5%9f%ba%e7%a1%80%ef%bc%88%e4%ba%8c title="Frida hook基础（二)"></a>Frida hook 基础（二)</h2><ul><li>spawn/attach</li><li>各种主动调用</li><li>hook 函数和 hook 构造函数</li><li>调用栈 / 简单脚本</li><li>动态加载自己的 dex</li></ul><p>题目下载地址:<br><a href=https://github.com/tlamb96/kgb_messenger target=_blank rel=noopener>https://github.com/tlamb96/kgb_messenger</a></p><h3 id=spawn-attach-spawnattachspawnattach><a href=#spawn-attach title=spawn/attach></a>spawn/attach</h3><p>firda 的 - f 参数代表 span 启动<br><code>frida -U -f com.tlamb96.spetsnazmessenger -l frida_russian.js --no-pause</code></p><pre tabindex=0><code>/* access modifiers changed from: protected */
    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        setContentView((int) R.layout.activity_main);
        String property = System.getProperty(&#34;user.home&#34;);
        String str = System.getenv(&#34;USER&#34;);
        if (property == null || property.isEmpty() || !property.equals(&#34;Russia&#34;)) {
            a(&#34;Integrity Error&#34;, &#34;This app can only run on Russian devices.&#34;);
        } else if (str == null || str.isEmpty() || !str.equals(getResources().getString(R.string.User))) {
            a(&#34;Integrity Error&#34;, &#34;Must be on the user whitelist.&#34;);
        } else {
            a.a(this);
            startActivity(new Intent(this, LoginActivity.class));
        }
    }
}
</code></pre><p>这个题目比较简单，但是因为这个 check 是在<code>onCreate</code>里，所以 app 刚启动就自动检查，所以这里需要用 spawn 的方式去启动 frida 脚本 hook，而不是 attach。
这里有两个检查，一个是检查 property 的值，一个是检查 str 的值。
分别从<code>System.getProperty</code>和<code>System.getenv</code>里获取，hook 住这两个函数就行。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092212.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092212.png alt loading=lazy data-zoomable></div></div></figure></a><br>这里要注意从资源文件里找到<code>User</code>的值。</p><pre tabindex=0><code>function main() {
    Java.perform(function () {
        Java.use(&#34;java.lang.System&#34;).getProperty.overload(&#39;java.lang.String&#39;).implementation = function (str) {
            return &#34;Russia&#34;;
        }
        Java.use(&#34;java.lang.System&#34;).getenv.overload(&#39;java.lang.String&#39;).implementation = function(str){
            return &#34;RkxBR3s1N0VSTDFOR180UkNIM1J9Cg==&#34;;
        }
    })
}
setImmediate(main)
</code></pre><p>接下来进入到 login 功能</p><pre tabindex=0><code>public void onLogin(View view) {
        EditText editText = (EditText) findViewById(R.id.login_username);
        EditText editText2 = (EditText) findViewById(R.id.login_password);
        this.n = editText.getText().toString();
        this.o = editText2.getText().toString();
        if (this.n != null &amp;&amp; this.o != null &amp;&amp; !this.n.isEmpty() &amp;&amp; !this.o.isEmpty()) {
            if (!this.n.equals(getResources().getString(R.string.username))) {
                Toast.makeText(this, &#34;User not recognized.&#34;, 0).show();
                editText.setText(&#34;&#34;);
                editText2.setText(&#34;&#34;);
            } else if (!j()) {
                Toast.makeText(this, &#34;Incorrect password.&#34;, 0).show();
                editText.setText(&#34;&#34;);
                editText2.setText(&#34;&#34;);
            } else {
                i();
                startActivity(new Intent(this, MessengerActivity.class));
            }
        }
    }
...
    private boolean j() {
        String str = &#34;&#34;;
        for (byte b : this.m.digest(this.o.getBytes())) {
            str = str + String.format(&#34;%x&#34;, new Object[]{Byte.valueOf(b)});
        }
        return str.equals(getResources().getString(R.string.password));
    }
...
    private void i() {
        char[] cArr = {&#39;(&#39;, &#39;W&#39;, &#39;D&#39;, &#39;)&#39;, &#39;T&#39;, &#39;P&#39;, &#39;:&#39;, &#39;#&#39;, &#39;?&#39;, &#39;T&#39;};
        cArr[0] = (char) (cArr[0] ^ this.n.charAt(1));
        cArr[1] = (char) (cArr[1] ^ this.o.charAt(0));
        cArr[2] = (char) (cArr[2] ^ this.o.charAt(4));
        cArr[3] = (char) (cArr[3] ^ this.n.charAt(4));
        cArr[4] = (char) (cArr[4] ^ this.n.charAt(7));
        cArr[5] = (char) (cArr[5] ^ this.n.charAt(0));
        cArr[6] = (char) (cArr[6] ^ this.o.charAt(2));
        cArr[7] = (char) (cArr[7] ^ this.o.charAt(3));
        cArr[8] = (char) (cArr[8] ^ this.n.charAt(6));
        cArr[9] = (char) (cArr[9] ^ this.n.charAt(8));
        Toast.makeText(this, &#34;FLAG{&#34; + new String(cArr) + &#34;}&#34;, 1).show();
    }
</code></pre><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092522.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-29-092522.png alt loading=lazy data-zoomable></div></div></figure></a><br>从资源文件里找到 username, 密码则是要算一个 j() 函数，要让它返回 true，顺便打印一下 i 函数 toast 到界面的 flag。</p><pre tabindex=0><code>Java.use(&#34;com.tlamb96.kgbmessenger.LoginActivity&#34;).j.implementation = function () {
            return true
        }
...
Java.use(&#34;android.widget.Toast&#34;).makeText.overload(&#39;android.content.Context&#39;, &#39;java.lang.CharSequence&#39;, &#39;int&#39;).implementation = function (x, y, z) {
    var flag = Java.use(&#34;java.lang.String&#34;).$new(y)
    console.log(flag)
}
...
[Google Pixel::com.tlamb96.spetsnazmessenger]-&gt; FLAG{G&amp;qG13     R0}
</code></pre><h3 id=frida-hook-hook构造函数-打印栈回溯-frida-hook-hook构造函数打印栈回溯frida-hook-hook-构造函数--打印栈回溯><a href=#Frida-hook-hook%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0-%e6%89%93%e5%8d%b0%e6%a0%88%e5%9b%9e%e6%ba%af title="Frida hook :hook构造函数/打印栈回溯"></a>Frida hook :hook 构造函数 / 打印栈回溯</h3><p>总结:<br>hook 构造函数实现通过 use 取得类，然后<code>clazz.$init.implementation = callback</code> hook 构造函数。</p><p>我们先学习一下怎么 hook 构造函数。</p><pre tabindex=0><code>add(new com.tlamb96.kgbmessenger.b.a(R.string.katya, &#34;Archer, you up?&#34;, &#34;2:20 am&#34;, true));
...
package com.tlamb96.kgbmessenger.b;
public class a {
...
    public a(int i, String str, String str2, boolean z) {
        this.f448a = i;
        this.b = str;
        this.c = str2;
        this.d = z;
    }
...
}
</code></pre><p>用<code>$init</code>来 hook 构造函数</p><pre tabindex=0><code>Java.use(&#34;com.tlamb96.kgbmessenger.b.a&#34;).$init.implementation = function (i, str1, str2, z) {
            this.$init(i, str1, str2, z)
            console.log(i, str1, str2, z)
            printStack(&#34;com.tlamb96.kgbmessenger.b.a&#34;)
        }
</code></pre><h3 id=frida-hook-打印栈回溯-frida-hook--打印栈回溯frida-hook--打印栈回溯><a href=#Frida-hook-%e6%89%93%e5%8d%b0%e6%a0%88%e5%9b%9e%e6%ba%af title="Frida hook : 打印栈回溯"></a>Frida hook : 打印栈回溯</h3><p>打印栈回溯</p><pre tabindex=0><code>function printStack(name) {
    Java.perform(function () {
        var Exception = Java.use(&#34;java.lang.Exception&#34;);
        var ins = Exception.$new(&#34;Exception&#34;);
        var straces = ins.getStackTrace();
        if (straces != undefined &amp;&amp; straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, &#34;\\n&#34;);
            console.log(&#34;=============================&#34; + name + &#34; Stack strat=======================&#34;);
            console.log(replaceStr);
            console.log(&#34;=============================&#34; + name + &#34; Stack end=======================\r\n&#34;);
            Exception.$dispose();
        }
    });
}
</code></pre><p>输出就是这样</p><pre tabindex=0><code>[Google Pixel::com.tlamb96.spetsnazmessenger]-&gt; 2131558449 111 02:27 下午 false
=============================com.tlamb96.kgbmessenger.b.a Stack strat=======================
com.tlamb96.kgbmessenger.b.a.&lt;init&gt;(Native Method)
com.tlamb96.kgbmessenger.MessengerActivity.onSendMessage(Unknown Source:40)
java.lang.reflect.Method.invoke(Native Method)
android.support.v7.app.m$a.onClick(Unknown Source:25)
android.view.View.performClick(View.java:6294)
android.view.View$PerformClick.run(View.java:24770)
android.os.Handler.handleCallback(Handler.java:790)
android.os.Handler.dispatchMessage(Handler.java:99)
android.os.Looper.loop(Looper.java:164)
android.app.ActivityThread.main(ActivityThread.java:6494)
java.lang.reflect.Method.invoke(Native Method)
com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)
=============================com.tlamb96.kgbmessenger.b.a Stack end=======================
</code></pre><h3 id=frida-hook-手动加载dex并调用-frida-hook--手动加载dex并调用frida-hook--手动加载-dex-并调用><a href=#Frida-hook-%e6%89%8b%e5%8a%a8%e5%8a%a0%e8%bd%bddex%e5%b9%b6%e8%b0%83%e7%94%a8 title="Frida hook : 手动加载dex并调用"></a>Frida hook : 手动加载 dex 并调用</h3><p>总结：<br>编译出 dex 之后，通过<code>Java.openClassFile("xxx.dex").load()</code>加载，这样我们就可以正常通过<code>Java.use</code>调用里面的方法了。</p><p>现在我们来继续解决这个问题。</p><pre tabindex=0><code>public void onSendMessage(View view) {
    EditText editText = (EditText) findViewById(R.id.edittext_chatbox);
    String obj = editText.getText().toString();
    if (!TextUtils.isEmpty(obj)) {
        this.o.add(new com.tlamb96.kgbmessenger.b.a(R.string.user, obj, j(), false));
        this.n.c();
        if (a(obj.toString()).equals(this.p)) {
            Log.d(&#34;MessengerActivity&#34;, &#34;Successfully asked Boris for the password.&#34;);
            this.q = obj.toString();
            this.o.add(new com.tlamb96.kgbmessenger.b.a(R.string.boris, &#34;Only if you ask nicely&#34;, j(), true));
            this.n.c();
        }
        if (b(obj.toString()).equals(this.r)) {
            Log.d(&#34;MessengerActivity&#34;, &#34;Successfully asked Boris nicely for the password.&#34;);
            this.s = obj.toString();
            this.o.add(new com.tlamb96.kgbmessenger.b.a(R.string.boris, &#34;Wow, no one has ever been so nice to me! Here you go friend: FLAG{&#34; + i() + &#34;}&#34;, j(), true));
            this.n.c();
        }
        this.m.b(this.m.getAdapter().a() - 1);
        editText.setText(&#34;&#34;);
    }
}
</code></pre><p>新的一关是一个聊天框，分析一下代码可知，obj 是我们输入的内容，输入完了之后，加到一个<code>this.o</code>的 ArrayList 里。
关键的 if 判断就是<code>if (a(obj.toString()).equals(this.p))</code>和<code>if (b(obj.toString()).equals(this.r))</code>，所有 hook a 和 b 函数，让它们的返回值等于下面的字符串即可。</p><pre tabindex=0><code>private String p = &#34;V@]EAASB\u0012WZF\u0012e,a$7(&amp;am2(3.\u0003&#34;;
private String q;
private String r = &#34;\u0000dslp}oQ\u0000 dks$|M\u0000h +AYQg\u0000P*!M$gQ\u0000&#34;;
private String s;
</code></pre><p>但实际上这题比我想象中的还要麻烦，这题的逻辑上是如果通过了 a 和 b 这两个函数的计算，等于对应的值之后，会把用来计算的 obj 的值赋值给 q 和 s，然后根据这个 q 和 s 来计算出最终的 flag。
所以如果不逆向算法，通过 hook 的方式通过了 a 和 b 的计算，obj 的值还是错误的，也计算不出正确的 flag。</p><p>这样就逆向一下算法好了，先自己写一个 apk，用 java 去实现注册机。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004653.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004653.png alt loading=lazy data-zoomable></div></div></figure></a><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004915.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-004915.png alt loading=lazy data-zoomable></div></div></figure></a><br>可以直接把 class 文件转成 dex，不复述，我比较懒，所以我直接解压 apk 找到<code>classes.dex</code>，并 push 到手机上。
然后用 frida 加载这个 dex，并调用里面的方法。</p><pre tabindex=0><code>var dex = Java.openClassFile(&#34;/data/local/tmp/classes.dex&#34;).load();
        console.log(&#34;decode_P:&#34;+Java.use(&#34;myapplication.example.com.reversea.reverseA&#34;).decode_P());
        console.log(&#34;r_to_hex:&#34;+Java.use(&#34;myapplication.example.com.reversea.reverseA&#34;).r_to_hex());
...
...
decode_P:Boris, give me the password
r_to_hex:0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100
</code></pre><h2 id=frida打印与参数构造-frida打印与参数构造frida-打印与参数构造><a href=#Frida%e6%89%93%e5%8d%b0%e4%b8%8e%e5%8f%82%e6%95%b0%e6%9e%84%e9%80%a0 title=Frida打印与参数构造></a>Frida 打印与参数构造</h2><ul><li><p>数组 /(字符串) 对象数组 / gson/Java.array</p></li><li><p>对象 / 多态、强转 Java.cast / 接口 Java.register</p></li><li><p>泛型、List、Map、Set、迭代打印</p></li><li><p>non-ascii 、 child-gating、rpc 上传到 PC 上打印</p><h3 id=char-object-object-charobject-objectcharobject-object><a href=#char-Object-Object title="char[]/[Object Object]"></a>char[]/[Object Object]</h3><pre tabindex=0><code>Log.d(&#34;SimpleArray&#34;, &#34;onCreate: SImpleArray&#34;);
char arr[][] = new char[4][]; // 创建一个4行的二维数组
arr[0] = new char[] { &#39;春&#39;, &#39;眠&#39;, &#39;不&#39;, &#39;觉&#39;, &#39;晓&#39; }; // 为每一行赋值
arr[1] = new char[] { &#39;处&#39;, &#39;处&#39;, &#39;闻&#39;, &#39;啼&#39;, &#39;鸟&#39; };
arr[2] = new char[] { &#39;夜&#39;, &#39;来&#39;, &#39;风&#39;, &#39;雨&#39;, &#39;声&#39; };
arr[3] = new char[] { &#39;花&#39;, &#39;落&#39;, &#39;知&#39;, &#39;多&#39;, &#39;少&#39; };
Log.d(&#34;SimpleArray&#34;, &#34;-----横版-----&#34;);
for (int i = 0; i &lt; 4; i++) { // 循环4行
    Log.d(&#34;SimpleArraysToString&#34;, Arrays.toString(arr[i]));
    Log.d(&#34;SimpleStringBytes&#34;, Arrays.toString (Arrays.toString (arr[i]).getBytes()));
    for (int j = 0; j &lt; 5; j++) { // 循环5列
        Log.d(&#34;SimpleArray&#34;, Character.toString(arr[i][j])); // 输出数组中的元素
    }
    if (i % 2 == 0) {
        Log.d(&#34;SimpleArray&#34;, &#34;,&#34;);// 如果是一、三句，输出逗号
    } else {
        Log.d(&#34;SimpleArray&#34;, &#34;。&#34;);// 如果是二、四句，输出句号
    }
}
</code></pre><pre tabindex=0><code>Java.openClassFile(&#34;/data/local/tmp/r0gson.dex&#34;).load();
const gson = Java.use(&#39;com.r0ysue.gson.Gson&#39;);

Java.use(&#34;java.lang.Character&#34;).toString.overload(&#39;char&#39;).implementation = function(char){
    var result = this.toString(char);
    console.log(&#34;char,result&#34;,char,result);
    return result;
}

Java.use(&#34;java.util.Arrays&#34;).toString.overload(&#39;[C&#39;).implementation = function(charArray){
    var result = this.toString(charArray);
    console.log(&#34;charArray,result:&#34;,charArray,result)
    console.log(&#34;charArray Object Object:&#34;,gson.$new().toJson(charArray));
    return result;
}
</code></pre><p>这里的<code>[C</code>是 JNI 函数签名<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033242.jpg target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033242.jpg alt loading=lazy data-zoomable></div></div></figure></a><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033633.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-033633.png alt loading=lazy data-zoomable></div></div></figure></a></p></li></ul><h3 id=byte-bytebyte><a href=#byte title=byte[]></a>byte[]</h3><pre tabindex=0><code>Java.openClassFile(&#34;/data/local/tmp/r0gson.dex&#34;).load();
const gson = Java.use(&#39;com.r0ysue.gson.Gson&#39;);

Java.use(&#34;java.util.Arrays&#34;).toString.overload(&#39;[B&#39;).implementation = function(byteArray){
    var result = this.toString(byteArray);
    console.log(&#34;byteArray,result):&#34;,byteArray,result)
    console.log(&#34;byteArray Object Object:&#34;,gson.$new().toJson(byteArray));
    return result;
}
</code></pre><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-034053.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-06-30-034053.png alt loading=lazy data-zoomable></div></div></figure></a></p><h3 id=java-array构造-java-array构造java-array-构造><a href=#java-array%e6%9e%84%e9%80%a0 title="java array构造"></a>java array 构造</h3><p>如果不只是想打印出结果，而是要替换原本的参数，就要先自己构造出一个 charArray, 使用<code>Java.array</code>API</p><pre tabindex=0><code>/**
 * Creates a Java array with elements of the specified `type`, from a
 * JavaScript array `elements`. The resulting Java array behaves like
 * a JS array, but can be passed by reference to Java APIs in order to
 * allow them to modify its contents.
 *
 * @param type Type name of elements.
 * @param elements Array of JavaScript values to use for constructing the
 *                 Java array.
 */
function array(type: string, elements: any[]): any[];
</code></pre><pre tabindex=0><code>Java.use(&#34;java.util.Arrays&#34;).toString.overload(&#39;[C&#39;).implementation = function(charArray){
    var newCharArray = Java.array(&#39;char&#39;, [ &#39;一&#39;,&#39;去&#39;,&#39;二&#39;,&#39;三&#39;,&#39;里&#39; ]);
    var result = this.toString(newCharArray);
    console.log(&#34;newCharArray,result:&#34;,newCharArray,result)
    console.log(&#34;newCharArray Object Object:&#34;,gson.$new().toJson(newCharArray));
    var newResult = Java.use(&#39;java.lang.String&#39;).$new(Java.array(&#39;char&#39;, [ &#39;烟&#39;,&#39;村&#39;,&#39;四&#39;,&#39;五&#39;,&#39;家&#39;]))
    return newResult;
}
</code></pre><p>可以用来构造参数重发包，用在爬虫上。</p><h3 id=类的多态转型-java-cast-类的多态转型javacast类的多态转型--javacast><a href=#%e7%b1%bb%e7%9a%84%e5%a4%9a%e6%80%81%ef%bc%9a%e8%bd%ac%e5%9e%8b-Java-cast title=类的多态：转型/Java.cast></a>类的多态：转型 / Java.cast</h3><p>可以通过<code>getClass().getName().toString()</code>来查看当前实例的类型。
找到一个 instance，通过<code>Java.cast</code>来强制转换对象的类型。</p><pre tabindex=0><code>/**
 * Creates a JavaScript wrapper given the existing instance at `handle` of
 * given class `klass` as returned from `Java.use()`.
 *
 * @param handle An existing wrapper or a JNI handle.
 * @param klass Class wrapper for type to cast to.
 */
function cast(handle: Wrapper | NativePointerValue, klass: Wrapper): Wrapper;
</code></pre><pre tabindex=0><code>public class Water { // 水 类
    public static String flow(Water W) { // 水 的方法
        // SomeSentence
        Log.d(&#34;2Object&#34;, &#34;water flow: I`m flowing&#34;);
        return &#34;water flow: I`m flowing&#34;;
    }

    public String still(Water W) { // 水 的方法
        // SomeSentence
        Log.d(&#34;2Object&#34;, &#34;water still: still water runs deep!&#34;);
        return &#34;water still: still water runs deep!&#34;;
    }
}
...
public class Juice extends Water { // 果汁 类 继承了水类

    public String fillEnergy(){
        Log.d(&#34;2Object&#34;, &#34;Juice: i`m fillingEnergy!&#34;);
        return &#34;Juice: i`m fillingEnergy!&#34;;
    }
</code></pre><pre tabindex=0><code>var JuiceHandle = null ;
Java.choose(&#34;com.r0ysue.a0526printout.Juice&#34;,{
    onMatch:function(instance){
        console.log(&#34;found juice instance&#34;,instance);
        console.log(&#34;juice instance call fill&#34;,instance.fillEnergy());
        JuiceHandle = instance;
    },onComplete:function(){
        console.log(&#34;juice handle search completed!&#34;)
    }
})
console.log(&#34;Saved juice handle :&#34;,JuiceHandle);
var WaterHandle = Java.cast(JuiceHandle,Java.use(&#34;com.r0ysue.a0526printout.Water&#34;))
console.log(&#34;call Waterhandle still method:&#34;,WaterHandle.still(WaterHandle));
</code></pre><h3 id=interface-java-registerclass-interfacejavaregisterclassinterfacejavaregisterclass><a href=#interface-Java-registerClass title=interface/Java.registerClass></a>interface/Java.registerClass</h3><pre tabindex=0><code>public interface liquid {
    public String flow();
}
</code></pre><p>frida 提供能力去创建一个新的 java class</p><pre tabindex=0><code>/**
    * Creates a new Java class.
    *
    * @param spec Object describing the class to be created.
    */
function registerClass(spec: ClassSpec): Wrapper;
</code></pre><p>首先获取要实现的 interface，然后调用 registerClass 来实现 interface。</p><pre tabindex=0><code>Java.perform(function(){
        var liquid = Java.use(&#34;com.r0ysue.a0526printout.liquid&#34;);
        var beer = Java.registerClass({
            name: &#39;com.r0ysue.a0526printout.beer&#39;,
            implements: [liquid],
            methods: {
                flow: function () {
                    console.log(&#34;look, beer is flowing!&#34;)
                    return &#34;look, beer is flowing!&#34;;
                }
            }
        });
        console.log(&#34;beer.bubble:&#34;,beer.$new().flow())
    })
}
</code></pre><h3 id=成员内部类-匿名内部类-成员内部类匿名内部类成员内部类--匿名内部类><a href=#%e6%88%90%e5%91%98%e5%86%85%e9%83%a8%e7%b1%bb-%e5%8c%bf%e5%90%8d%e5%86%85%e9%83%a8%e7%b1%bb title=成员内部类/匿名内部类></a>成员内部类 / 匿名内部类</h3><p>看 smali 或者枚举出来的类。</p><h3 id=hook-enum-hook-enumhook-enum><a href=#hook-enum title="hook enum"></a>hook enum</h3><p>关于 java 枚举，从这篇文章了解。
<a href=https://www.cnblogs.com/jingmoxukong/p/6098351.html target=_blank rel=noopener>https://www.cnblogs.com/jingmoxukong/p/6098351.html</a></p><pre tabindex=0><code>enum Signal {
    GREEN, YELLOW, RED
}
public class TrafficLight {
    public static Signal color = Signal.RED;
    public static void main() {
        Log.d(&#34;4enum&#34;, &#34;enum &#34;+ color.getClass().getName().toString());
        switch (color) {
            case RED:
                color = Signal.GREEN;
                break;
            case YELLOW:
                color = Signal.RED;
                break;
            case GREEN:
                color = Signal.YELLOW;
                break;
        }
    }
}
</code></pre><pre tabindex=0><code>Java.perform(function(){
        Java.choose(&#34;com.r0ysue.a0526printout.Signal&#34;,{
            onMatch:function(instance){
                console.log(&#34;instance.name:&#34;,instance.name());
                console.log(&#34;instance.getDeclaringClass:&#34;,instance.getDeclaringClass());
            },onComplete:function(){
                console.log(&#34;search completed!&#34;)
            }
        })
    })
</code></pre><h3 id=打印hash-map-打印hash-map打印-hash-map><a href=#%e6%89%93%e5%8d%b0hash-map title="打印hash map"></a>打印 hash map</h3><pre tabindex=0><code>Java.perform(function(){
        Java.choose(&#34;java.util.HashMap&#34;,{
            onMatch:function(instance){
                if(instance.toString().indexOf(&#34;ISBN&#34;)!= -1){
                    console.log(&#34;instance.toString:&#34;,instance.toString());
                }
            },onComplete:function(){
                console.log(&#34;search complete!&#34;)
            }
        })
    })
</code></pre><h3 id=打印non-ascii-打印non-ascii打印-non-ascii><a href=#%e6%89%93%e5%8d%b0non-ascii title=打印non-ascii></a>打印 non-ascii</h3><p><a href=https://api-caller.com/2019/03/30/frida-note/#non-ascii target=_blank rel=noopener>https://api-caller.com/2019/03/30/frida-note/#non-ascii</a><br>类名非 ASCII 字符串时，先编码打印出来, 再用编码后的字符串去 hook.</p><pre tabindex=0><code>//场景hook cls.forName寻找目标类的classloader。
    cls.forName.overload(&#39;java.lang.String&#39;, &#39;boolean&#39;, &#39;java.lang.ClassLoader&#39;).implementation = function (arg1, arg2, arg3) {
        var clsName = cls.forName(arg1, arg2, arg3);
        console.log(&#39;oriClassName:&#39; + arg1)
        var base64Name = encodeURIComponent(arg1)
        console.log(&#39;encodeName:&#39; + base64Name);
        //通过日志确认base64后的非ascii字符串，下面对比并打印classloader
        //clsName为特殊字符o.ÎÉ«
        if (&#39;o.%CE%99%C9%AB&#39; == base64Name) {
            //打印classloader
            console.log(arg3);
        }
        return clsName;
    }
</code></pre><h2 id=frida-native-hook-ndk开发入门-frida-native-hook--ndk开发入门frida-native-hook--ndk-开发入门><a href=#Frida-native-hook-NDK%e5%bc%80%e5%8f%91%e5%85%a5%e9%97%a8 title="Frida native hook : NDK开发入门"></a>Frida native hook : NDK 开发入门</h2><p><a href=https://www.jianshu.com/p/87ce6f565d37 target=_blank rel=noopener>https://www.jianshu.com/p/87ce6f565d37</a></p><h2 id=frida-native-hook-jnienv和反射-frida-native-hook--jnienv和反射frida-native-hook--jnienv-和反射><a href=#Frida-native-hook-JNIEnv%e5%92%8c%e5%8f%8d%e5%b0%84 title="Frida native hook : JNIEnv和反射"></a>Frida native hook : JNIEnv 和反射</h2><h3 id=以jni字符串来掌握基本的jnienv用法-以jni字符串来掌握基本的jnienv用法以-jni-字符串来掌握基本的-jnienv-用法><a href=#%e4%bb%a5jni%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9d%a5%e6%8e%8c%e6%8f%a1%e5%9f%ba%e6%9c%ac%e7%9a%84JNIEnv%e7%94%a8%e6%b3%95 title=以jni字符串来掌握基本的JNIEnv用法></a>以 jni 字符串来掌握基本的 JNIEnv 用法</h3><pre tabindex=0><code>public native String stringWithJNI(String context);
...

extern &#34;C&#34;
JNIEXPORT jstring JNICALL
Java_myapplication_example_com_ndk_1demo_MainActivity_stringWithJNI(JNIEnv *env, jobject instance,
                                                                    jstring context_) {
    const char *context = env-&gt;GetStringUTFChars(context_, 0);

    int context_size = env-&gt;GetStringUTFLength(context_);

    if (context_size &gt; 0) {
        LOGD(&#34;%s\n&#34;, context);
    }

    env-&gt;ReleaseStringUTFChars(context_, context);

    return env-&gt;NewStringUTF(&#34;sakura1328&#34;);
}

12-26 22:30:00.548 15764-15764/myapplication.example.com.ndk_demo D/sakura1328: sakura
</code></pre><h3 id=java反射-java反射java-反射><a href=#Java%e5%8f%8d%e5%b0%84 title=Java反射></a>Java 反射</h3><p>总结: 多去读一下 java 的反射 API。</p><p><a href=https://www.jianshu.com/p/9be58ee20dee target=_blank rel=noopener>Java 高级特性——反射</a></p><ul><li>查找调用各种 API 接口、JNI、frida/xposed 原理的一部分</li><li>反射基本 API</li><li>反射修改访问控制、修改属性值</li><li>JNI so 调用反射进入 java 世界</li><li>xposed/Frida hook 原理</li></ul><p>这里其实有一个伏笔，就是为什么我们要 trace artmethod，hook artmethod 是因为有些 so 混淆得非常厉害，然后也就很难静态分析看出 so 里面调用了哪些 java 函数，也不是通过类似 JNI 的 GetMethodID 这样来调用的。
而是通过类似 findclass 这种方法先得到类，然后再反射调用 app 里面的某个 java 函数。</p><p>所以去 hook 它执行的位置，每一个 java 函数对于 Android 源码而言都是一个 artmethod 结构体，然后 hook 拿到 artmethod 实例以后调用类函数，打印这个函数的名称。</p><pre tabindex=0><code>public class MainActivity extends AppCompatActivity {

    private static final String TAG = &#34;sakura&#34;;

    // Used to load the &#39;native-lib&#39; library on application startup.
    static {
        System.loadLibrary(&#34;native-lib&#34;);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Example of a call to a native method
        TextView tv = (TextView) findViewById(R.id.sample_text);
        tv.setText(stringWithJNI(&#34;sakura&#34;));
//        Log.d(TAG, stringFromJNI());
//        Log.d(TAG, stringWithJNI(&#34;sakura&#34;));
        try {
            testClass();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }

    public void testClass() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Test sakuraTest = new Test();
        // 获得Class的方法（三种）
        Class testClazz = MainActivity.class.getClassLoader().loadClass(&#34;myapplication.example.com.ndk_demo.Test&#34;);
        Class testClazz2 = Class.forName(&#34;myapplication.example.com.ndk_demo.Test&#34;);
        Class testClazz3 = Test.class;
        Log.i(TAG, &#34;Classloader.loadClass-&gt;&#34; + testClazz);
        Log.i(TAG, &#34;Classloader.loadClass-&gt;&#34; + testClazz2);
        Log.i(TAG, &#34;Classloader.loadClass-&gt;&#34; + testClazz3.getName());

        // 获得类中属性相关的方法
        Field publicStaticField = testClazz3.getDeclaredField(&#34;publicStaticField&#34;);
        Log.i(TAG, &#34;testClazz3.getDeclaredField-&gt;&#34; + publicStaticField);

        Field publicField = testClazz3.getDeclaredField(&#34;publicField&#34;);
        Log.i(TAG, &#34;testClazz3.getDeclaredField-&gt;&#34; + publicField);

        //对于Field的get方法，如果是static，则传入null即可;如果不是，则需要传入一个类的实例
        String valueStaticPublic = (String) publicStaticField.get(null);
        Log.i(TAG, &#34;publicStaticField.get-&gt;&#34; + valueStaticPublic);

        String valuePublic = (String) publicField.get(sakuraTest);
        Log.i(TAG, &#34;publicField.get-&gt;&#34; + valuePublic);

        //对于private属性，需要设置Accessible
        Field privateStaticField = testClazz3.getDeclaredField(&#34;privateStaticField&#34;);
        privateStaticField.setAccessible(true);

        String valuePrivte = (String) privateStaticField.get(null);
        Log.i(TAG, &#34;modified before privateStaticField.get-&gt;&#34; + valuePrivte);

        privateStaticField.set(null, &#34;modified&#34;);

        valuePrivte = (String) privateStaticField.get(null);
        Log.i(TAG, &#34;modified after privateStaticField.get-&gt;&#34; + valuePrivte);

        Field[] fields = testClazz3.getDeclaredFields();
        for (Field i : fields) {
            Log.i(TAG, &#34;testClazz3.getDeclaredFields-&gt;&#34; + i);
        }

        // 获得类中method相关的方法
        Method publicStaticMethod = testClazz3.getDeclaredMethod(&#34;publicStaticFunc&#34;);
        Log.i(TAG, &#34;testClazz3.getDeclaredMethod-&gt;&#34; + publicStaticMethod);

        publicStaticMethod.invoke(null);

        Method publicMethod = testClazz3.getDeclaredMethod(&#34;publicFunc&#34;, java.lang.String.class);
        Log.i(TAG, &#34;testClazz3.getDeclaredMethod-&gt;&#34; + publicMethod);

        publicMethod.invoke(sakuraTest, &#34; sakura&#34;);
    }

    /**
     * A native method that is implemented by the &#39;native-lib&#39; native library,
     * which is packaged with this application.
     */
    public native String stringFromJNI();

    public native String stringWithJNI(String context);
}
...
public class Test {
    private static final String TAG = &#34;sakura_test&#34;;

    public static String publicStaticField = &#34;i am a publicStaticField&#34;;
    public String publicField = &#34;i am a publicField&#34;;

    private static String privateStaticField = &#34;i am a privateStaticField&#34;;
    private String privateField = &#34;i am a privateField&#34;;

    public static void publicStaticFunc() {
        Log.d(TAG, &#34;I`m from publicStaticFunc&#34;);
    }

    public void publicFunc(String str) {
        Log.d(TAG, &#34;I`m from publicFunc&#34; + str);
    }

    private static void privateStaticFunc() {
        Log.i(TAG, &#34;I`m from privateFunc&#34;);
    }

    private void privateFunc() {
        Log.i(TAG, &#34;I`m from privateFunc&#34;);
    }
}
...
...
12-26 23:57:11.784 17682-17682/myapplication.example.com.ndk_demo I/sakura: Classloader.loadClass-&gt;class myapplication.example.com.ndk_demo.Test
12-26 23:57:11.784 17682-17682/myapplication.example.com.ndk_demo I/sakura: Classloader.loadClass-&gt;class myapplication.example.com.ndk_demo.Test
12-26 23:57:11.784 17682-17682/myapplication.example.com.ndk_demo I/sakura: Classloader.loadClass-&gt;myapplication.example.com.ndk_demo.Test
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredField-&gt;public static java.lang.String myapplication.example.com.ndk_demo.Test.publicStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredField-&gt;public java.lang.String myapplication.example.com.ndk_demo.Test.publicField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: publicStaticField.get-&gt;i am a publicStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: publicField.get-&gt;i am a publicField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: modified before privateStaticField.get-&gt;i am a privateStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: modified after privateStaticField.get-&gt;modified
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&gt;private java.lang.String myapplication.example.com.ndk_demo.Test.privateField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&gt;public java.lang.String myapplication.example.com.ndk_demo.Test.publicField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&gt;private static final java.lang.String myapplication.example.com.ndk_demo.Test.TAG
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&gt;private static java.lang.String myapplication.example.com.ndk_demo.Test.privateStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredFields-&gt;public static java.lang.String myapplication.example.com.ndk_demo.Test.publicStaticField
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredMethod-&gt;public static void myapplication.example.com.ndk_demo.Test.publicStaticFunc()
12-26 23:57:11.785 17682-17682/myapplication.example.com.ndk_demo D/sakura_test: I`m from publicStaticFunc
12-26 23:57:11.786 17682-17682/myapplication.example.com.ndk_demo I/sakura: testClazz3.getDeclaredMethod-&gt;public void myapplication.example.com.ndk_demo.Test.publicFunc(java.lang.String)
12-26 23:57:11.786 17682-17682/myapplication.example.com.ndk_demo D/sakura_test: I`m from publicFunc sakura
</code></pre><p><code>memory list modules</code><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-065833.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-065833.png alt loading=lazy data-zoomable></div></div></figure></a></p><h2 id=frida反调试-frida反调试frida-反调试><a href=#Frida%e5%8f%8d%e8%b0%83%e8%af%95 title=Frida反调试></a>Frida 反调试</h2><p>这一节的主要内容就是关于反调试的原理和如何破解反调试，重要内容还是看文章理解即可。
因为我并不需要做反调试相关的工作，所以部分内容略过。</p><ul><li>Frida 反调试与反反调试基本思路<br>（Java 层 API、Native 层 API、Syscall)<ul><li><a href=https://github.com/qtfreet00/AntiFrida target=_blank rel=noopener>AntiFrida</a></li><li><a href=https://github.com/b-mueller/frida-detection-demo target=_blank rel=noopener>frida-detection-demo</a></li><li><a href=https://bbs.pediy.com/thread-217482.htm target=_blank rel=noopener>多种特征检测 Frida</a></li><li><a href=https://yq.aliyun.com/articles/71120 target=_blank rel=noopener>来自高维的对抗 - 逆向 TinyTool 自制</a></li><li><a href=https://bbs.pediy.com/thread-253868.htm target=_blank rel=noopener>Unicorn 在 Android 的应用</a></li></ul></li></ul><h2 id=frida-native-hook-符号hook-jniart-amp-libc-frida-native-hook--符号hook-jniartlibcfrida-native-hook--符号-hook-jniartlibc><a href=#Frida-native-hook-%e7%ac%a6%e5%8f%b7hook-JNI%e3%80%81art-amp-libc title="Frida native hook : 符号hook JNI、art&libc"></a>Frida native hook : 符号 hook JNI、art&libc</h2><h3 id=native函数的java-hook及主动调用-native函数的java-hook及主动调用native-函数的-java-hook-及主动调用><a href=#Native%e5%87%bd%e6%95%b0%e7%9a%84Java-Hook%e5%8f%8a%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8 title="Native函数的Java Hook及主动调用"></a>Native 函数的 Java Hook 及主动调用</h3><p>对 native 函数的 java 层 hook 和主动调用和普通 java 函数完全一致，略过。</p><h3 id=jni-h头文件导入-jnih头文件导入jnih头文件导入><a href=#jni-h%e5%a4%b4%e6%96%87%e4%bb%b6%e5%af%bc%e5%85%a5 title=jni.h头文件导入></a><code>jni.h</code>头文件导入</h3><p>导入 jni.h，先 search 一下这个文件在哪。</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/Library/Android/sdk$ find ./ -name &#34;jni.h&#34;
.//ndk-bundle/sysroot/usr/include/jni.h
</code></pre><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-103826.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-103826.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>Error /Users/sakura/Library/Android/sdk/ndk-bundle/sysroot/usr/include/jni.h,27: Can&#39;t open include file &#39;stdarg.h&#39;
Total 1 errors
Caching &#39;Exports&#39;... ok
</code></pre><p>报错，所以拷贝一份 jni.h 出来</p><p>将这两个头文件导入删掉<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104029.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104029.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>导入成功<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104113.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104113.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>现在就能识别_JNIEnv 了，如图<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104131.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-104131.png alt loading=lazy data-zoomable></div></div></figure></a></p><h3 id=jni函数符号hook-jni函数符号hookjni-函数符号-hook><a href=#JNI%e5%87%bd%e6%95%b0%e7%ac%a6%e5%8f%b7hook title=JNI函数符号hook></a>JNI 函数符号 hook</h3><p>先查看一下导出了哪些函数。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-102552.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-01-102552.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>extern &#34;C&#34; JNIEXPORT jstring JNICALL
Java_myapplication_example_com_ndk_1demo_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = &#34;Hello from C++&#34;;
    LOGD(&#34;sakura1328&#34;);
    return env-&gt;NewStringUTF(hello.c_str());
}
extern &#34;C&#34;
JNIEXPORT jstring JNICALL
Java_myapplication_example_com_ndk_1demo_MainActivity_stringWithJNI(JNIEnv *env, jobject instance,
                                                                    jstring context_) {
    const char *context = env-&gt;GetStringUTFChars(context_, 0);

    int context_size = env-&gt;GetStringUTFLength(context_);

    if (context_size &gt; 0) {
        LOGD(&#34;%s\n&#34;, context);
    }

    env-&gt;ReleaseStringUTFChars(context_, context);

    return env-&gt;NewStringUTF(&#34;sakura1328&#34;);
}
</code></pre><p>这里有几个需要的 API。</p><ul><li>首先是找到是否 so 被加载，通过<code>Process.enumerateModules()</code>, 这个 API 可以枚举被加载到内存的 modules。</li><li>然后通过<code>Module.findBaseAddress(module name)</code>来查找要 hook 的函数所在的 so 的基地址，如果找不到就返回 null。</li><li>然后可以通过<code>findExportByName(moduleName: string, exportName: string): NativePointer</code>来查找导出函数的绝对地址。如果不知道 moduleName 是什么，可以传入一个 null 进入，但是会花费一些时间遍历所有的 module。如果找不到就返回 null。</li><li>找到地址之后，就可以拦截 function/instruction 的执行。通过<code>Interceptor.attach</code>。使用方法见下代码。</li><li>另外为了将 jstring 的值打印出来，可以使用 jenv 的函数 getStringUtfChars，就像正常的写 native 程序一样。
<code>Java.vm.getEnv().getStringUtfChars(args[2], null).readCString()</code></li></ul><p>这里我是循环调用的 string_with_jni，如果不循环调用，那就要主动调用一下这个函数，或者 hook dlopen。
hook dlopen 的方法在<a href=https://github.com/lasting-yang/frida_dump/blob/master/dump_dex.js target=_blank rel=noopener>这个代码</a>可以参考。</p><pre tabindex=0><code>function hook_native() {
    // console.log(JSON.stringify(Process.enumerateModules()));
    var libnative_addr = Module.findBaseAddress(&#34;libnative-lib.so&#34;)
    console.log(&#34;libnative_addr is: &#34; + libnative_addr)

    if (libnative_addr) {
        var string_with_jni_addr = Module.findExportByName(&#34;libnative-lib.so&#34;,
        &#34;Java_myapplication_example_com_ndk_1demo_MainActivity_stringWithJNI&#34;)
        console.log(&#34;string_with_jni_addr is: &#34; + string_with_jni_addr)
    }

    Interceptor.attach(string_with_jni_addr, {
        onEnter: function (args) {
            console.log(&#34;string_with_jni args: &#34; + args[0], args[1], args[2])
            console.log(Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())
        },
        onLeave: function (retval) {
            console.log(&#34;retval:&#34;, retval)
            console.log(Java.vm.getEnv().getStringUtfChars(retval, null).readCString())
            var newRetval = Java.vm.getEnv().newStringUtf(&#34;new retval from hook_native&#34;);
            retval.replace(ptr(newRetval));
        }
    })
}
</code></pre><pre tabindex=0><code>libnative_addr is: 0x7a0842f000
string_with_jni_addr is: 0x7a08436194
[Google Pixel::myapplication.example.com.ndk_demo]-&gt; string_with_jni args: 0x7a106cc1c0 0x7ff0b71da4 0x7ff0b71da8
sakura
retval: 0x75
sakura1328
</code></pre><p>这里还写了一个 hook env 里的 GetStringUTFChars 的代码，和上面一样，不赘述了。</p><pre tabindex=0><code>function hook_art(){
    var addr_GetStringUTFChars = null;
    //console.log( JSON.stringify(Process.enumerateModules()));
    var symbols = Process.findModuleByName(&#34;libart.so&#34;).enumerateSymbols();
    for(var i = 0;i&lt;symbols.length;i++){
        var symbol = symbols[i].name;
        if((symbol.indexOf(&#34;CheckJNI&#34;)==-1)&amp;&amp;(symbol.indexOf(&#34;JNI&#34;)&gt;=0)){
            if(symbol.indexOf(&#34;GetStringUTFChars&#34;)&gt;=0){
                console.log(symbols[i].name);
                console.log(symbols[i].address);
                addr_GetStringUTFChars = symbols[i].address;
            }
        }
    }
    console.log(&#34;addr_GetStringUTFChars:&#34;, addr_GetStringUTFChars);
    Java.perform(function (){
        Interceptor.attach(addr_GetStringUTFChars, {
            onEnter: function (args) {
                console.log(&#34;addr_GetStringUTFChars OnEnter args[0],args[1]&#34;,args[0],args[1]);
                //console.log(hexdump(args[0].readPointer()));
                //console.log(Java.vm.tryGetEnv().getStringUtfChars(args[0]).readCString());
            }, onLeave: function (retval) {
                console.log(&#34;addr_GetStringUTFChars OnLeave&#34;,ptr(retval).readCString());
            }
        })
    })
}
</code></pre><h3 id=jni函数参数返回值打印和替换-jni函数参数返回值打印和替换jni-函数参数返回值打印和替换><a href=#JNI%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0%e3%80%81%e8%bf%94%e5%9b%9e%e5%80%bc%e6%89%93%e5%8d%b0%e5%92%8c%e6%9b%bf%e6%8d%a2 title=JNI函数参数、返回值打印和替换></a>JNI 函数参数、返回值打印和替换</h3><ul><li><p>libc 函数符号 hook</p></li><li><p>libc 函数参数、返回值打印和替换<br>hook libc 的也和上面的完全一样，也不赘述了。
所以看到这里，究其本质就是找到导出符号和它所在的 so 基地址了。</p><pre tabindex=0><code>function hook_libc(){
    var pthread_create_addr = null;
    var symbols = Process.findModuleByName(&#34;libc.so&#34;).enumerateSymbols();
    for(var i = 0;i&lt;symbols.length;i++){
        var symbol = symbols[i].name;

        if(symbol.indexOf(&#34;pthread_create&#34;)&gt;=0){
            //console.log(symbols[i].name);
            //console.log(symbols[i].address);
            pthread_create_addr = symbols[i].address;
        }

    }
    console.log(&#34;pthread_create_addr,&#34;,pthread_create_addr);
    Interceptor.attach(pthread_create_addr,{
        onEnter:function(args){
            console.log(&#34;pthread_create_addr args[0],args[1],args[2],args[3]:&#34;,args[0],args[1],args[2],args[3]);

        },onLeave:function(retval){
            console.log(&#34;retval is:&#34;,retval)
        }
    })
}
</code></pre></li></ul><h2 id=frida-native-hook-jni-onload-动态注册-inline-hook-native层调用栈打印-frida-native-hook--jni_onload动态注册inline_hooknative层调用栈打印frida-native-hook--jni_onload--动态注册--inline_hooknative-层调用栈打印><a href=#Frida-native-hook-JNI-Onload-%e5%8a%a8%e6%80%81%e6%b3%a8%e5%86%8c-inline-hook-native%e5%b1%82%e8%b0%83%e7%94%a8%e6%a0%88%e6%89%93%e5%8d%b0 title="Frida native hook : JNI_Onload/动态注册/inline_hook/native层调用栈打印"></a>Frida native hook : JNI_Onload / 动态注册 / inline_hook/native 层调用栈打印</h2><p><a href=https://github.com/android/ndk-samples target=_blank rel=noopener>https://github.com/android/ndk-samples</a></p><h3 id=jni-onload-动态注册原理-jni_onload动态注册原理jni_onload--动态注册原理><a href=#JNI-Onload-%e5%8a%a8%e6%80%81%e6%b3%a8%e5%86%8c%e5%8e%9f%e7%90%86 title=JNI_Onload/动态注册原理></a>JNI_Onload / 动态注册原理</h3><ul><li>JNI_Onload / 动态注册 / Frida hook RegisterNative<ul><li><a href=https://zhuanlan.kanxue.com/article-4482.htm target=_blank rel=noopener>JNI 与动态注册</a></li><li><a href=https://eternalsakura13.com/2018/02/08/jni2/ target=_blank rel=noopener>native 方法的动态注册</a></li><li><a href=https://github.com/lasting-yang/frida_hook_libart target=_blank rel=noopener>Frida hook art</a></li></ul></li></ul><p>详细的内容参见我写的文章，这里只给出栗子。</p><pre tabindex=0><code>Log.d(TAG,stringFromJNI2());
public native String stringFromJNI2();
</code></pre><pre tabindex=0><code>JNIEXPORT jstring JNICALL stringFromJNI2(
        JNIEnv *env,
        jclass clazz) {
    jclass testClass = env-&gt;FindClass(&#34;myapplication/example/com/ndk_demo/Test&#34;);
    jfieldID publicStaticField = env-&gt;GetStaticFieldID(testClass, &#34;publicStaticField&#34;,
                                                       &#34;Ljava/lang/String;&#34;);
    jstring publicStaticFieldValue = (jstring) env-&gt;GetStaticObjectField(testClass,
                                                                         publicStaticField);
    const char *value_ptr = env-&gt;GetStringUTFChars(publicStaticFieldValue, NULL);
    LOGD(&#34;now content is %s&#34;, value_ptr);
    std::string hello = &#34;Hello from C++ stringFromJNI2&#34;;
    return env-&gt;NewStringUTF(hello.c_str());
}
...
JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6);
    JNINativeMethod methods[] = {
            {&#34;stringFromJNI2&#34;, &#34;()Ljava/lang/String;&#34;, (void *) stringFromJNI2},
    };
    env-&gt;RegisterNatives(env-&gt;FindClass(&#34;myapplication/example/com/ndk_demo/MainActivity&#34;), methods,
                         1);
    return JNI_VERSION_1_6;
}
</code></pre><h3 id=frida-hook-registernative-frida-hook-registernativefrida-hook-registernative><a href=#Frida-hook-RegisterNative title="Frida hook RegisterNative"></a>Frida hook RegisterNative</h3><p>使用下面这个脚本来打印出 RegisterNatives 的参数，这里需要注意的是使用了 enumerateSymbolsSync, 它是 enumerateSymbols 的同步版本。
另外和我们之前通过<code>Java.vm.tryGetEnv().getStringUtfChars</code>来调用 env 里的方法不同。
这里则是通过将之前找到的 getStringUtfChars 函数地址和参数信息封装起来，直接调用，具体的原理我没有深入分析，先记住用法。
原理其实是一样的，都是<strong>根据符号找到地址，然后 hook 符号地址，然后打印参数</strong>。</p><pre tabindex=0><code>declare const NativeFunction: NativeFunctionConstructor;

interface NativeFunctionConstructor {
    new(address: NativePointerValue, retType: NativeType, argTypes: NativeType[], abiOrOptions?: NativeABI | NativeFunctionOptions): NativeFunction;
    readonly prototype: NativeFunction;
}
...
var funcGetStringUTFChars = new NativeFunction(addrGetStringUTFChars, &#34;pointer&#34;, [&#34;pointer&#34;, &#34;pointer&#34;, &#34;pointer&#34;]);
</code></pre><pre tabindex=0><code>var ishook_libart = false;

function hook_libart() {
    if (ishook_libart === true) {
        return;
    }
    var symbols = Module.enumerateSymbolsSync(&#34;libart.so&#34;);
    var addrGetStringUTFChars = null;
    var addrNewStringUTF = null;
    var addrFindClass = null;
    var addrGetMethodID = null;
    var addrGetStaticMethodID = null;
    var addrGetFieldID = null;
    var addrGetStaticFieldID = null;
    var addrRegisterNatives = null;
    var addrAllocObject = null;
    var addrCallObjectMethod = null;
    var addrGetObjectClass = null;
    var addrReleaseStringUTFChars = null;
    for (var i = 0; i &lt; symbols.length; i++) {
        var symbol = symbols[i];
        if (symbol.name == &#34;_ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPh&#34;) {
            addrGetStringUTFChars = symbol.address;
            console.log(&#34;GetStringUTFChars is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name == &#34;_ZN3art3JNI12NewStringUTFEP7_JNIEnvPKc&#34;) {
            addrNewStringUTF = symbol.address;
            console.log(&#34;NewStringUTF is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name == &#34;_ZN3art3JNI9FindClassEP7_JNIEnvPKc&#34;) {
            addrFindClass = symbol.address;
            console.log(&#34;FindClass is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name == &#34;_ZN3art3JNI11GetMethodIDEP7_JNIEnvP7_jclassPKcS6_&#34;) {
            addrGetMethodID = symbol.address;
            console.log(&#34;GetMethodID is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name == &#34;_ZN3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jclassPKcS6_&#34;) {
            addrGetStaticMethodID = symbol.address;
            console.log(&#34;GetStaticMethodID is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name == &#34;_ZN3art3JNI10GetFieldIDEP7_JNIEnvP7_jclassPKcS6_&#34;) {
            addrGetFieldID = symbol.address;
            console.log(&#34;GetFieldID is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name == &#34;_ZN3art3JNI16GetStaticFieldIDEP7_JNIEnvP7_jclassPKcS6_&#34;) {
            addrGetStaticFieldID = symbol.address;
            console.log(&#34;GetStaticFieldID is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name == &#34;_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi&#34;) {
            addrRegisterNatives = symbol.address;
            console.log(&#34;RegisterNatives is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name.indexOf(&#34;_ZN3art3JNI11AllocObjectEP7_JNIEnvP7_jclass&#34;) &gt;= 0) {
            addrAllocObject = symbol.address;
            console.log(&#34;AllocObject is at &#34;, symbol.address, symbol.name);
        }  else if (symbol.name.indexOf(&#34;_ZN3art3JNI16CallObjectMethodEP7_JNIEnvP8_jobjectP10_jmethodIDz&#34;) &gt;= 0) {
            addrCallObjectMethod = symbol.address;
            console.log(&#34;CallObjectMethod is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name.indexOf(&#34;_ZN3art3JNI14GetObjectClassEP7_JNIEnvP8_jobject&#34;) &gt;= 0) {
            addrGetObjectClass = symbol.address;
            console.log(&#34;GetObjectClass is at &#34;, symbol.address, symbol.name);
        } else if (symbol.name.indexOf(&#34;_ZN3art3JNI21ReleaseStringUTFCharsEP7_JNIEnvP8_jstringPKc&#34;) &gt;= 0) {
            addrReleaseStringUTFChars = symbol.address;
            console.log(&#34;ReleaseStringUTFChars is at &#34;, symbol.address, symbol.name);
        }
    }

    if (addrRegisterNatives != null) {
        Interceptor.attach(addrRegisterNatives, {
            onEnter: function (args) {
                console.log(&#34;[RegisterNatives] method_count:&#34;, args[3]);
                var env = args[0];
                var java_class = args[1];

                var funcAllocObject = new NativeFunction(addrAllocObject, &#34;pointer&#34;, [&#34;pointer&#34;, &#34;pointer&#34;]);
                var funcGetMethodID = new NativeFunction(addrGetMethodID, &#34;pointer&#34;, [&#34;pointer&#34;, &#34;pointer&#34;, &#34;pointer&#34;, &#34;pointer&#34;]);
                var funcCallObjectMethod = new NativeFunction(addrCallObjectMethod, &#34;pointer&#34;, [&#34;pointer&#34;, &#34;pointer&#34;, &#34;pointer&#34;]);
                var funcGetObjectClass = new NativeFunction(addrGetObjectClass, &#34;pointer&#34;, [&#34;pointer&#34;, &#34;pointer&#34;]);
                var funcGetStringUTFChars = new NativeFunction(addrGetStringUTFChars, &#34;pointer&#34;, [&#34;pointer&#34;, &#34;pointer&#34;, &#34;pointer&#34;]);
                var funcReleaseStringUTFChars = new NativeFunction(addrReleaseStringUTFChars, &#34;void&#34;, [&#34;pointer&#34;, &#34;pointer&#34;, &#34;pointer&#34;]);

                var clz_obj = funcAllocObject(env, java_class);
                var mid_getClass = funcGetMethodID(env, java_class, Memory.allocUtf8String(&#34;getClass&#34;), Memory.allocUtf8String(&#34;()Ljava/lang/Class;&#34;));
                var clz_obj2 = funcCallObjectMethod(env, clz_obj, mid_getClass);
                var cls = funcGetObjectClass(env, clz_obj2);
                var mid_getName = funcGetMethodID(env, cls, Memory.allocUtf8String(&#34;getName&#34;), Memory.allocUtf8String(&#34;()Ljava/lang/String;&#34;));
                var name_jstring = funcCallObjectMethod(env, clz_obj2, mid_getName);
                var name_pchar = funcGetStringUTFChars(env, name_jstring, ptr(0));
                var class_name = ptr(name_pchar).readCString();
                funcReleaseStringUTFChars(env, name_jstring, name_pchar);

                //console.log(class_name);

                var methods_ptr = ptr(args[2]);

                var method_count = parseInt(args[3]);
                for (var i = 0; i &lt; method_count; i++) {
                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));
                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));
                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));

                    var name = Memory.readCString(name_ptr);
                    var sig = Memory.readCString(sig_ptr);
                    var find_module = Process.findModuleByAddress(fnPtr_ptr);
                    console.log(&#34;[RegisterNatives] java_class:&#34;, class_name, &#34;name:&#34;, name, &#34;sig:&#34;, sig, &#34;fnPtr:&#34;, fnPtr_ptr, &#34;module_name:&#34;, find_module.name, &#34;module_base:&#34;, find_module.base, &#34;offset:&#34;, ptr(fnPtr_ptr).sub(find_module.base));

                }
            },
            onLeave: function (retval) { }
        });
    }

    ishook_libart = true;
}

hook_libart();
</code></pre><p>结果很明显的打印了出来，包括动态注册的函数的名字，函数签名，加载地址和在 so 里的偏移量，</p><pre tabindex=0><code>[RegisterNatives] java_class: myapplication.example.com.ndk_demo.MainActivity name: stringFromJNI2 sig: ()Ljava/lang/String; fnPtr: 0x79f8698484 module_name: libnative-lib.so module_base: 0x79f8691000 offset: 0x7484
</code></pre><p>最后测试一下 yang 开源的一个 hook art 的脚本，很有意思，trace 出了非常多的需要的信息。</p><pre tabindex=0><code>frida -U --no-pause -f package_name -l hook_art.js
...
[FindClass] name:myapplication/example/com/ndk_demo/Test
[GetStaticFieldID] name:publicStaticField, sig:Ljava/lang/String;
[GetStringUTFChars] result:i am a publicStaticField
[NewStringUTF] bytes:Hello from C++ stringFromJNI2
[GetStringUTFChars] result:sakura
</code></pre><h3 id=native层调用栈打印-native层调用栈打印native-层调用栈打印><a href=#native%e5%b1%82%e8%b0%83%e7%94%a8%e6%a0%88%e6%89%93%e5%8d%b0 title=native层调用栈打印></a>native 层调用栈打印</h3><p>直接使用 frida 提供的接口打印栈回溯。</p><pre tabindex=0><code>Interceptor.attach(f, {
  onEnter: function (args) {
    console.log(&#39;RegisterNatives called from:\n&#39; +
        Thread.backtrace(this.context, Backtracer.ACCURATE)
        .map(DebugSymbol.fromAddress).join(&#39;\n&#39;) + &#39;\n&#39;);
  }
});
</code></pre><p>效果如下, 我加到了 hook registerNative 的地方。</p><pre tabindex=0><code>[Google Pixel::myapplication.example.com.ndk_demo]-&gt; RegisterNatives called from:
0x7a100be03c libart.so!0xe103c
0x7a100be038 libart.so!0xe1038
0x79f85699a0 libnative-lib.so!_ZN7_JNIEnv15RegisterNativesEP7_jclassPK15JNINativeMethodi+0x44
0x79f85698e0 libnative-lib.so!JNI_OnLoad+0x90
0x7a102b9fd4 libart.so!_ZN3art9JavaVMExt17LoadNativeLibraryEP7_JNIEnvRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEP8_jobjectP8_jstringPS9_+0x638
0x7a08e3820c libopenjdkjvm.so!JVM_NativeLoad+0x110
0x70b921c4 boot.oat!oatexec+0xa81c4
</code></pre><h3 id=主动调用去进行方法参数替换-主动调用去进行方法参数替换主动调用去进行方法参数替换><a href=#%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e5%8e%bb%e8%bf%9b%e8%a1%8c%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e6%9b%bf%e6%8d%a2 title=主动调用去进行方法参数替换></a>主动调用去进行方法参数替换</h3><p>使用<code>Interceptor.replace</code>，不赘述。主要目的还是为了改掉函数原本的执行行为，而不是仅仅打印一些信息。</p><h3 id=inline-hook-inline-hookinline-hook><a href=#inline-hook title="inline hook"></a>inline hook</h3><p>inline hook 简单理解就是不是 hook 函数开始执行的地方，而是 hook 函数中间执行的指令<br>整体来说没什么区别，就是把找函数符号地址改成从 so 里找到偏移，然后加到 so 基地址上就行, 注意一下它的 attach 的 callback。</p><pre tabindex=0><code>/**
 * Callback to invoke when an instruction is about to be executed.
 */
type InstructionProbeCallback = (this: InvocationContext, args: InvocationArguments) =&gt; void;
type InvocationContext = PortableInvocationContext | WindowsInvocationContext | UnixInvocationContext;

interface PortableInvocationContext {
    /**
     * Return address.
     */
    returnAddress: NativePointer;

    /**
     * CPU registers. You may also update register values by assigning to these keys.
     */
    context: CpuContext;

    /**
     * OS thread ID.
     */
    threadId: ThreadId;

    /**
     * Call depth of relative to other invocations.
     */
    depth: number;

    /**
     * User-defined invocation data. Useful if you want to read an argument in `onEnter` and act on it in `onLeave`.
     */
    [x: string]: any;
}
...
...
interface Arm64CpuContext extends PortableCpuContext {
    x0: NativePointer;
    x1: NativePointer;
    x2: NativePointer;
    x3: NativePointer;
    x4: NativePointer;
    x5: NativePointer;
    x6: NativePointer;
    x7: NativePointer;
    x8: NativePointer;
    x9: NativePointer;
    x10: NativePointer;
    x11: NativePointer;
    x12: NativePointer;
    x13: NativePointer;
    x14: NativePointer;
    x15: NativePointer;
    x16: NativePointer;
    x17: NativePointer;
    x18: NativePointer;
    x19: NativePointer;
    x20: NativePointer;
    x21: NativePointer;
    x22: NativePointer;
    x23: NativePointer;
    x24: NativePointer;
    x25: NativePointer;
    x26: NativePointer;
    x27: NativePointer;
    x28: NativePointer;

    fp: NativePointer;
    lr: NativePointer;
}
</code></pre><p>我的 so 是自己编译的，具体的汇编代码如下, 总之这里很明显在 775C 时，x0 里保存的是一个指向”sakura” 这个字符串的指针。(其实我也不是很看得懂 arm64 了已经，就随便 hook 了一下)<br>所以 hook 这个指令，然后<code>Memory.readCString(this.context.x0);</code>打印出来，结果如下</p><pre tabindex=0><code>.text:000000000000772C ; __unwind {
.text:000000000000772C                 SUB             SP, SP, #0x40
.text:0000000000007730                 STP             X29, X30, [SP,#0x30+var_s0]
.text:0000000000007734                 ADD             X29, SP, #0x30
.text:0000000000007738 ; 6:   v6 = a1;
.text:0000000000007738                 MOV             X8, XZR
.text:000000000000773C                 STUR            X0, [X29,#var_8]
.text:0000000000007740 ; 7:   v5 = a3;
.text:0000000000007740                 STUR            X1, [X29,#var_10]
.text:0000000000007744                 STR             X2, [SP,#0x30+var_18]
.text:0000000000007748 ; 8:   v4 = (const char *)_JNIEnv::GetStringUTFChars(a1, a3, 0LL);
.text:0000000000007748                 LDUR            X0, [X29,#var_8]
.text:000000000000774C                 LDR             X1, [SP,#0x30+var_18]
.text:0000000000007750                 MOV             X2, X8
.text:0000000000007754                 BL              ._ZN7_JNIEnv17GetStringUTFCharsEP8_jstringPh ; _JNIEnv::GetStringUTFChars(_jstring *,uchar *)
.text:0000000000007758                 STR             X0, [SP,#0x30+var_20]
.text:000000000000775C ; 9:   if ( (signed int)_JNIEnv::GetStringUTFLength(v6, v5) &gt; 0 )
.text:000000000000775C                 LDUR            X0, [X29,#var_8]
.text:0000000000007760                 LDR             X1, [SP,#0x30+var_18]
</code></pre><pre tabindex=0><code>function inline_hook() {
    var libnative_lib_addr = Module.findBaseAddress(&#34;libnative-lib.so&#34;);
    if (libnative_lib_addr) {
        console.log(&#34;libnative_lib_addr:&#34;, libnative_lib_addr);
        var addr_775C = libnative_lib_addr.add(0x775C);
        console.log(&#34;addr_775C:&#34;, addr_775C);

        Java.perform(function () {
            Interceptor.attach(addr_775C, {
                onEnter: function (args) {
                    var name = this.context.x0.readCString()
                    console.log(&#34;addr_775C OnEnter :&#34;, this.returnAddress, name);
                },
                onLeave: function (retval) {
                     console.log(&#34;retval is :&#34;, retval)
                }
            })
        })
    }
}
setImmediate(inline_hook())
</code></pre><pre tabindex=0><code>Attaching...
libnative_lib_addr: 0x79fabe0000
addr_775C: 0x79fabe775c
TypeError: cannot read property &#39;apply&#39; of undefined
    at [anon] (../../../frida-gum/bindings/gumjs/duktape.c:56618)
    at frida/runtime/core.js:55
[Google Pixel::myapplication.example.com.ndk_demo]-&gt; addr_775C OnEnter : 0x79fabe7758 sakura
addr_775C OnEnter : 0x79fabe7758 sakura
</code></pre><p>到这里已经可以总结一下我目前的学习了，需要补充一些 frida api 的学习，比如 NativePointr 里居然有个 readCString，这些 API 是需要再看看的。</p><h2 id=frida-native-hook-frida-hook-native-app实战-frida-native-hook--frida-hook-native-app实战frida-native-hook--frida-hook-native-app-实战><a href=#Frida-native-hook-Frida-hook-native-app%e5%ae%9e%e6%88%98 title="Frida native hook : Frida hook native app实战"></a>Frida native hook : Frida hook native app 实战</h2><ul><li>破解 Frida 全端口检测的 native 层反调试<ul><li>hook libc 的 pthread_create 函数</li></ul></li><li>破解 TracePid 的 native 反调试<ul><li>target: <a href=https://gtoad.github.io/2017/06/25/Android-Anti-Debug/ target=_blank rel=noopener>https://gtoad.github.io/2017/06/25/Android-Anti-Debug/</a></li><li>solve : hook libc 的 fgets 函数</li></ul></li><li>native 层修改参数、返回值</li><li>静态分析<code>JNI_Onload</code></li><li>动态 trace 主动注册 & IDA 溯源</li><li>动态 trace JNI、libc 函数 & IDA 溯源</li><li>native 层主动调用、打调用栈</li><li>主动调用 libc 读写文件</li></ul><p>看下 logcat</p><pre tabindex=0><code>n/u0a128 for activity com.gdufs.xman/.MainActivity
12-28 05:53:26.898 26615 26615 V com.gdufs.xman: JNI_OnLoad()
12-28 05:53:26.898 26615 26615 V com.gdufs.xman: RegisterNatives() --&gt; nativeMethod() ok
12-28 05:53:26.898 26615 26615 D com.gdufs.xman m=: 0
12-28 05:53:26.980 26615 26615 D com.gdufs.xman m=: Xman
</code></pre><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101517.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101517.png alt loading=lazy data-zoomable></div></div></figure></a><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101821.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101821.png alt loading=lazy data-zoomable></div></div></figure></a><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101843.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-101843.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/gitsource/frida-agent-example/agent$ frida -U --no-pause -f com.gdufs.xman -l hook_reg.js
...
[Google Pixel::com.gdufs.xman]-&gt; [RegisterNatives] method_count: 0x3
[RegisterNatives] java_class: com.gdufs.xman.MyApp name: initSN sig: ()V fnPtr: 0xd4ddf3b1 module_name: libmyjni.so module_base: 0xd4dde000 offset: 0x13b1
[RegisterNatives] java_class: com.gdufs.xman.MyApp name: saveSN sig: (Ljava/lang/String;)V fnPtr: 0xd4ddf1f9 module_name: libmyjni.so module_base: 0xd4dde000 offset: 0x11f9
[RegisterNatives] java_class: com.gdufs.xman.MyApp name: work sig: ()V fnPtr: 0xd4ddf4cd module_name: libmyjni.so module_base: 0xd4dde000 offset: 0x14cd
</code></pre><p>结合一下看，只要 initSN 检查到<code>/sdcard/reg.dat</code>里是<code>EoPAoY62@ElRD</code>，应该就会给 m 设置成 1。
只要 m 的值是 1，就能走到 work() 函数的逻辑。</p><p>参考 <a href=https://frida.re/docs/javascript-api/#file target=_blank rel=noopener>frida 的 file api</a></p><pre tabindex=0><code>function main() {
    var file = new File(&#34;/sdcard/reg.dat&#34;,&#39;w&#39;)
    file.write(&#34;EoPAoY62@ElRD&#34;)
    file.flush()
    file.close()
}
setImmediate(main())
</code></pre><p>这样我们继续看 work 的逻辑<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120940.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120940.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>v2 是从 getValue 得到的，看上去就是 m 字段的值，此时应该是 1，一会 hook 一下看看。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-121012.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-121012.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>[NewStringUTF] bytes:输入即是flag,格式为xman{……}！
</code></pre><p>callWork 里又调用了 work 函数，死循环了。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120907.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-120907.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>那看来看去最后还是回到了 initSN，那其实我们看的顺序似乎错了。
理一下逻辑，n2 执行完保存到文件，然后 n1 check 一下，所以最后还是要逆 n2 的算法，pass。</p><h2 id=frida-trace四件套-frida-trace四件套frida-trace-四件套><a href=#Frida-trace%e5%9b%9b%e4%bb%b6%e5%a5%97 title="Frida trace四件套"></a>Frida trace 四件套</h2><h3 id=jni-trace-trace-jni-jni-trace--trace-jnijni-trace--trace-jni><a href=#jni-trace-trace-jni title="jni trace : trace jni"></a>jni trace : trace jni</h3><p><a href=https://github.com/chame1eon/jnitrace target=_blank rel=noopener>https://github.com/chame1eon/jnitrace</a></p><pre tabindex=0><code>pip install jnitrace

Requirement already satisfied: frida&gt;=12.5.0 in /Users/sakura/.pyenv/versions/3.7.7/lib/python3.7/site-packages (from jnitrace) (12.8.0)
Requirement already satisfied: colorama in /Users/sakura/.pyenv/versions/3.7.7/lib/python3.7/site-packages (from jnitrace) (0.4.3)
Collecting hexdump (from jnitrace)
  Downloading https://files.pythonhosted.org/packages/55/b3/279b1d57fa3681725d0db8820405cdcb4e62a9239c205e4ceac4391c78e4/hexdump-3.3.zip
Installing collected packages: hexdump, jnitrace
  Running setup.py install for hexdump ... done
  Running setup.py install for jnitrace ... done
Successfully installed hexdump-3.3 jnitrace-3.0.8
</code></pre><p>usage: <code>jnitrace [options] -l libname target</code><br>默认应该是 spawn 运行的，</p><ul><li><p><code>-m</code>来指定是<code>spawn</code>还是<code>attach</code></p></li><li><p><code>-b</code>指定是<code>fuzzy</code>还是<code>accurate</code></p></li><li><p><code>-i &lt;regex></code>指定一个正则表达式来过滤出方法名，例如<code>-i Get -i RegisterNatives</code>就会只打印出名字里包含 Get 或者 RegisterNatives 的 JNI methods。</p></li><li><p><code>-e &lt;regex></code>和<code>-i</code>相反，同样通过正则表达式来过滤，但这次会将指定的内容忽略掉。</p></li><li><p><code>-I &lt;string></code>trace 导出的方法，jnitrace 认为导出的函数应该是从 Java 端能够直接调用的函数，所以可以包括使用 RegisterNatives 来注册的函数，例如<code>-I stringFromJNI -I nativeMethod([B)V</code>，就包括导出名里有 stringFromJNI，以及使用 RegisterNames 来注册，并带有 nativeMethod([B)V 签名的函数。</p></li><li><p><code>-o path/output.json</code>，导出输出到文件里。</p></li><li><p><code>-p path/to/script.js</code>，用于在加载 jnitrace 脚本之前将指定路径的 Frida 脚本加载到目标进程中，这可以用于在 jnitrace 启动之前对抗反调试。</p></li><li><p><code>-a path/to/script.js</code>，用于在加载 jnitrace 脚本之后将指定路径的 Frida 脚本加载到目标进程中</p></li><li><p><code>--ignore-env</code>，不打印所有的 JNIEnv 函数</p></li><li><p><code>--ignore-vm</code>，不打印所有的 JavaVM 函数</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/Desktop/lab/alpha/tools/android/frida_learn/0620/0620/xman/resources/lib/armeabi-v7a$ jnitrace -l libmyjni.so com.gdufs.xman
Tracing. Press any key to quit...
Traced library &#34;libmyjni.so&#34; loaded from path &#34;/data/app/com.gdufs.xman-X0HkzLhbptSc0tjGZ3yQ2g==/lib/arm&#34;.

           /* TID 28890 */
    355 ms [+] JavaVM-&gt;GetEnv
    355 ms |- JavaVM*          : 0xefe99140
    355 ms |- void**           : 0xda13e028
    355 ms |:     0xeff312a0
    355 ms |- jint             : 65542
    355 ms |= jint             : 0

    355 ms ------------------------Backtrace------------------------
    355 ms |-&gt; 0xda13a51b: JNI_OnLoad+0x12 (libmyjni.so:0xda139000)


           /* TID 28890 */
    529 ms [+] JNIEnv-&gt;FindClass
    529 ms |- JNIEnv*          : 0xeff312a0
    529 ms |- char*            : 0xda13bdef
    529 ms |:     com/gdufs/xman/MyApp
    529 ms |= jclass           : 0x81    { com/gdufs/xman/MyApp }

    529 ms ------------------------Backtrace------------------------
    529 ms |-&gt; 0xda13a539: JNI_OnLoad+0x30 (libmyjni.so:0xda139000)


           /* TID 28890 */
    584 ms [+] JNIEnv-&gt;RegisterNatives
    584 ms |- JNIEnv*          : 0xeff312a0
    584 ms |- jclass           : 0x81    { com/gdufs/xman/MyApp }
    584 ms |- JNINativeMethod* : 0xda13e004
    584 ms |:     0xda13a3b1 - initSN()V
    584 ms |:     0xda13a1f9 - saveSN(Ljava/lang/String;)V
    584 ms |:     0xda13a4cd - work()V
    584 ms |- jint             : 3
    584 ms |= jint             : 0

    584 ms ------------------------Backtrace------------------------
    584 ms |-&gt; 0xda13a553: JNI_OnLoad+0x4a (libmyjni.so:0xda139000)


           /* TID 28890 */
    638 ms [+] JNIEnv-&gt;FindClass
    638 ms |- JNIEnv*          : 0xeff312a0
    638 ms |- char*            : 0xda13bdef
    638 ms |:     com/gdufs/xman/MyApp
    638 ms |= jclass           : 0x71    { com/gdufs/xman/MyApp }

    638 ms -----------------------Backtrace-----------------------
    638 ms |-&gt; 0xda13a377: setValue+0x12 (libmyjni.so:0xda139000)


           /* TID 28890 */
    688 ms [+] JNIEnv-&gt;GetStaticFieldID
    688 ms |- JNIEnv*          : 0xeff312a0
    688 ms |- jclass           : 0x71    { com/gdufs/xman/MyApp }
    688 ms |- char*            : 0xda13be04
    688 ms |:     m
    688 ms |- char*            : 0xda13be06
    688 ms |:     I
    688 ms |= jfieldID         : 0xf1165004    { m:I }

    688 ms -----------------------Backtrace-----------------------
    688 ms |-&gt; 0xda13a38d: setValue+0x28 (libmyjni.so:0xda139000)
</code></pre></li></ul><h3 id=strace-trace-syscall-strace--trace-syscallstrace--trace-syscall><a href=#strace-trace-syscall title="strace : trace syscall"></a>strace : trace syscall</h3><p><a href=https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html target=_blank rel=noopener>https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html</a></p><h3 id=frida-trace-trace-libc-or-more-frida-trace--trace-libcor-morefrida-trace--trace-libcor-more><a href=#frida-trace-trace-libc-or-more title="frida-trace : trace libc(or more)"></a>frida-trace : trace libc(or more)</h3><p><a href=https://frida.re/docs/frida-trace/ target=_blank rel=noopener>https://frida.re/docs/frida-trace/</a></p><p>Usage:<code>frida-trace [options] target</code></p><pre tabindex=0><code>frida-trace -U -i &#34;strcmp&#34; -f com.gdufs.xman
...
  5634 ms  strcmp(s1=&#34;fi&#34;, s2=&#34;es-US&#34;)
  5635 ms  strcmp(s1=&#34;da&#34;, s2=&#34;es-US&#34;)
  5635 ms  strcmp(s1=&#34;es&#34;, s2=&#34;es-US&#34;)
  5635 ms  strcmp(s1=&#34;eu-ES&#34;, s2=&#34;es-US&#34;)
  5635 ms  strcmp(s1=&#34;et-EE&#34;, s2=&#34;es-US&#34;)
  5635 ms  strcmp(s1=&#34;et-EE&#34;, s2=&#34;es-US&#34;)
</code></pre><ul><li>art trace: <a href=https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_artmethod.js target=_blank rel=noopener>hook artmethod</a></li></ul><h3 id=hook-artmethod-trace-java函数调用-hook_artmethod--trace-java函数调用hook_artmethod--trace-java-函数调用><a href=#hook-artmethod-trace-java%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8 title="hook_artmethod : trace java函数调用"></a>hook_artmethod : trace java 函数调用</h3><p><a href=https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_artmethod.js target=_blank rel=noopener>https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_artmethod.js</a></p><h3 id=修改aosp源码打印-修改aosp源码打印修改-aosp-源码打印><a href=#%e4%bf%ae%e6%94%b9AOSP%e6%ba%90%e7%a0%81%e6%89%93%e5%8d%b0 title=修改AOSP源码打印></a>修改 AOSP 源码打印</h3><p><a href=https://bbs.pediy.com/thread-255653-1.htm target=_blank rel=noopener>改 aosp 源码 trace 信息</a></p><h2 id=frida-native-hook-init-array开发和自动化逆向-frida-native-hook--init_array开发和自动化逆向frida-native-hook--init_array-开发和自动化逆向><a href=#Frida-native-hook-init-array%e5%bc%80%e5%8f%91%e5%92%8c%e8%87%aa%e5%8a%a8%e5%8c%96%e9%80%86%e5%90%91 title="Frida native hook : init_array开发和自动化逆向"></a>Frida native hook : init_array 开发和自动化逆向</h2><h3 id=init-array原理-init_array原理init_array-原理><a href=#init-array%e5%8e%9f%e7%90%86 title=init_array原理></a>init_array 原理</h3><p>常见的保护都会在 init_array 里面做，关于其原理，主要阅读以下文章即可。</p><ul><li><a href=https://www.cnblogs.com/bingghost/p/6297325.html target=_blank rel=noopener>IDA 调试 android so 的. init_array 数组</a></li><li><a href=https://www.dllhook.com/post/213.html target=_blank rel=noopener>Android NDK 中. init 段和. init_array 段函数的定义方式</a></li><li><a href=https://wooyun.js.org/drops/Android%20Linker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html target=_blank rel=noopener>Linker 学习笔记</a></li></ul><h3 id=ida静态分析init-array-ida静态分析init_arrayida-静态分析-init_array><a href=#IDA%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90init-array title=IDA静态分析init_array></a>IDA 静态分析 init_array</h3><pre tabindex=0><code>// 编译生成后在.init段 [名字不可更改]
extern &#34;C&#34; void _init(void) {
    LOGD(&#34;Enter init......&#34;);
}

// 编译生成后在.init_array段 [名字可以更改]
__attribute__((__constructor__)) static void sakura_init() {
    LOGD(&#34;Enter sakura_init......&#34;);
}
...
...
2016-12-29 16:51:23.017 5160-5160/com.example.ndk_demo D/sakura1328: Enter init......
2016-12-29 16:51:23.017 5160-5160/com.example.ndk_demo D/sakura1328: Enter sakura_init......
</code></pre><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161438.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161438.png alt loading=lazy data-zoomable></div></div></figure></a><br>IDA 快捷键<code>shift+F7</code>找到 segment，然后就可以找到<code>.init_array</code>段，然后就可以找到里面保存的函数地址。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161519.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161519.png alt loading=lazy data-zoomable></div></div></figure></a><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161601.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161601.png alt loading=lazy data-zoomable></div></div></figure></a><br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161613.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-02-161613.png alt loading=lazy data-zoomable></div></div></figure></a></p><h3 id=ida动态调试so-ida动态调试soida-动态调试-so><a href=#IDA%e5%8a%a8%e6%80%81%e8%b0%83%e8%af%95so title=IDA动态调试so></a>IDA 动态调试 so</h3><ul><li><p>打开要调试的 apk，找到入口</p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~/.gradle/caches$ adb shell dumpsys activity top | grep TASK
TASK com.android.systemui id=29 userId=0
TASK null id=26 userId=0
TASK com.example.ndk_demo id=161 userId=0
</code></pre></li><li><p>启动 apk, 并让设备将处于一个 Waiting For Debugger 的状态<br><code>adb shell am start -D -n com.example.ndk_demo/.MainActivity</code></p></li><li><p>执行 android_server64</p><pre tabindex=0><code>sailfish:/data/local/tmp # ./android_server64
IDA Android 64-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017
Listening on 0.0.0.0:23946...
</code></pre></li><li><p>新开一个窗口使用 forward 程序进行端口转发：<code>adb forward tcp:23946 tcp:23946</code></p></li></ul><p><code>adb forward tcp:&lt;本地机器的网络端口号> tcp:&lt;模拟器或是真机的网络端口号></code><br>例: adb [-d|-e|-s ] forward tcp:6100 tcp:7100 表示把本机的 6100 端口号与模拟器的 7100 端口建立起相关，当模拟器或真机向自己的 7100 端口发送了数据，那们我们可以在本机的 6100 端口读取其发送的内容，这是一个很关键的命令，以后我们使用 jdb 调试 apk 之前，就要用它先把目标进程和本地端口建立起关联</p><ul><li><p>打开 IDA，选择菜单 Debugger -> Attach -> Remote ARM Linux/Android debugger</p></li><li><p>打开 IDA，选择菜单 Debugger -> Process options, 填好，然后选择进程去 attach。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-082029.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-082029.png alt loading=lazy data-zoomable></div></div></figure></a></p></li><li><p>查看待调试的进程<code>adb jdwp</code></p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ adb jdwp
10436
</code></pre></li><li><p>转发端口<code>adb forward tcp:8700 jdwp:10436</code>，将该进程的调试端口和本机的 8700 绑定。</p></li><li><p>jdb 连接调试端口，从而让程序继续运行 <code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></p></li><li><p>找到断点并断下。</p></li></ul><p>打开 module<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095937.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095937.png alt loading=lazy data-zoomable></div></div></figure></a><br>找到 linker64<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095955.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-095955.png alt loading=lazy data-zoomable></div></div></figure></a><br>找到 call array 函数<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100022.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100022.png alt loading=lazy data-zoomable></div></div></figure></a><br>下断并按 F9 断下<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100042.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-100042.png alt loading=lazy data-zoomable></div></div></figure></a></p><p>最终我确实可以调试到<code>.init_array</code>的初始化，具体的代码分析见 <a href=https://wooyun.js.org/drops/Android%20Linker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html target=_blank rel=noopener>Linker 学习笔记</a>这里。</p><h3 id=init-array-amp-amp-jni-onload-自吐-init_array--jni_onload-自吐init_array--jni_onload-自吐><a href=#init-array-amp-amp-JNI-Onload-%e2%80%9c%e8%87%aa%e5%90%90%e2%80%9d title="init_array && JNI_Onload “自吐”"></a>init_array && JNI_Onload “自吐”</h3><h4 id=jni-onload-jni_onloadjni_onload><a href=#JNI-Onload title=JNI_Onload></a>JNI_Onload</h4><p>目标是找到动态注册的函数的地址，因为这种函数没有导出。</p><pre tabindex=0><code>JNINativeMethod methods[] = {
            {&#34;stringFromJNI2&#34;, &#34;()Ljava/lang/String;&#34;, (void *) stringFromJNI2},
    };
    env-&gt;RegisterNatives(env-&gt;FindClass(&#34;com/example/ndk_demo/MainActivity&#34;), methods,
                         1);
</code></pre><p>首先<code>jnitrace -m spawn -i "RegisterNatives" -l libnative-lib.so com.example.ndk_demo</code></p><pre tabindex=0><code>525 ms [+] JNIEnv-&gt;RegisterNatives
525 ms |- JNIEnv*          : 0x7a106cc1c0
525 ms |- jclass           : 0x89    { com/example/ndk_demo/MainActivity }
525 ms |- JNINativeMethod* : 0x7ff0b71120
525 ms |:     0x79f00d36b0 - stringFromJNI2()Ljava/lang/String;
</code></pre><p>然后<code>objection -d -g com.example.ndk_demo run memory list modules explore | grep demo</code></p><pre tabindex=0><code>sakura@sakuradeMacBook-Pro:~$ objection -d -g com.example.ndk_demo run memory list modules explore | grep demo
[debug] Attempting to attach to process: `com.example.ndk_demo`
Warning: Output is not to a terminal (fd=1).
base.odex                                        0x79f0249000  106496 (104.0 KiB)    /data/app/com.example.ndk_demo-HGAFhnKyKCSIpzn227pwXw==/oat/arm64/base.odex
libnative-lib.so                                 0x79f00c4000  221184 (216.0 KiB)    /data/app/com.example.ndk_demo-HGAFhnKyKCSIpzn227pwXw==/lib/arm64/libnative...
</code></pre><p>offset = 0x79f00d36b0 - 0x79f00c4000 = 0xf6b0</p><p>这样就找到了<br><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-122151.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-122151.png alt loading=lazy data-zoomable></div></div></figure></a></p><h4 id=init-array-init_arrayinit_array><a href=#init-array title=init_array></a>init_array</h4><p>没有支持 arm64，可以在安装 app 的时候<code>adb install --abi armeabi-v7a</code>强制让 app 运行在 32 位模式</p><p>这个脚本整体来说就是 hook callfunction，然后打印出 init_array 里面的函数地址和参数等。</p><p>从源码看，关键就是 call_array 这里调用的 call_function，第一个参数代表这是注册的 init_array 里面的 function，第二个参数则是 init_array 里存储的函数的地址。</p><pre tabindex=0><code>template &lt;typename F&gt;
static void call_array(const char* array_name __unused,
                       F* functions,
                       size_t count,
                       bool reverse,
                       const char* realpath) {
  if (functions == nullptr) {
    return;
  }

  TRACE(&#34;[ Calling %s (size %zd) @ %p for &#39;%s&#39; ]&#34;, array_name, count, functions, realpath);

  int begin = reverse ? (count - 1) : 0;
  int end = reverse ? -1 : count;
  int step = reverse ? -1 : 1;

  for (int i = begin; i != end; i += step) {
    TRACE(&#34;[ %s[%d] == %p ]&#34;, array_name, i, functions[i]);
    call_function(&#34;function&#34;, functions[i], realpath);
  }

  TRACE(&#34;[ Done calling %s for &#39;%s&#39; ]&#34;, array_name, realpath);
}
</code></pre><pre tabindex=0><code>function LogPrint(log) {
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds()

    hour &lt; 10 ? hour = &#34;0&#34; + hour : hour;
    minute &lt; 10 ? minute = &#34;0&#34; + minute : minute;
    second &lt; 10 ? second = &#34;0&#34; + second : second;
    mSecond &lt; 10 ? mSecond = &#34;00&#34; + mSecond : mSecond &lt; 100 ? mSecond = &#34;0&#34; + mSecond : mSecond;

    var time = hour + &#34;:&#34; + minute + &#34;:&#34; + second + &#34;:&#34; + mSecond;
    var threadid = Process.getCurrentThreadId();
    console.log(&#34;[&#34; + time + &#34;]&#34; + &#34;-&gt;threadid:&#34; + threadid + &#34;--&#34; + log);

}

function hooklinker() {
    var linkername = &#34;linker&#34;;
    var call_function_addr = null;
    var arch = Process.arch;
    LogPrint(&#34;Process run in:&#34; + arch);
    if (arch.endsWith(&#34;arm&#34;)) {
        linkername = &#34;linker&#34;;
    } else {
        linkername = &#34;linker64&#34;;
        LogPrint(&#34;arm64 is not supported yet!&#34;);
    }

    var symbols = Module.enumerateSymbolsSync(linkername);
    for (var i = 0; i &lt; symbols.length; i++) {
        var symbol = symbols[i];
        //LogPrint(linkername + &#34;-&gt;&#34; + symbol.name + &#34;---&#34; + symbol.address);
        if (symbol.name.indexOf(&#34;__dl__ZL13call_functionPKcPFviPPcS2_ES0_&#34;) != -1) {
            call_function_addr = symbol.address;
            LogPrint(&#34;linker-&gt;&#34; + symbol.name + &#34;---&#34; + symbol.address)

        }
    }

    if (call_function_addr != null) {
        var func_call_function = new NativeFunction(call_function_addr, &#39;void&#39;, [&#39;pointer&#39;, &#39;pointer&#39;, &#39;pointer&#39;]);
        Interceptor.replace(new NativeFunction(call_function_addr,
            &#39;void&#39;, [&#39;pointer&#39;, &#39;pointer&#39;, &#39;pointer&#39;]), new NativeCallback(function (arg0, arg1, arg2) {
            var functiontype = null;
            var functionaddr = null;
            var sopath = null;
            if (arg0 != null) {
                functiontype = Memory.readCString(arg0);
            }
            if (arg1 != null) {
                functionaddr = arg1;

            }
            if (arg2 != null) {
                sopath = Memory.readCString(arg2);
            }
            var modulebaseaddr = Module.findBaseAddress(sopath);
            LogPrint(&#34;after load:&#34; + sopath + &#34;--start call_function,type:&#34; + functiontype + &#34;--addr:&#34; + functionaddr + &#34;---baseaddr:&#34; + modulebaseaddr);
            if (sopath.indexOf(&#39;libnative-lib.so&#39;) &gt;= 0 &amp;&amp; functiontype == &#34;DT_INIT&#34;) {
                LogPrint(&#34;after load:&#34; + sopath + &#34;--ignore call_function,type:&#34; + functiontype + &#34;--addr:&#34; + functionaddr + &#34;---baseaddr:&#34; + modulebaseaddr);

            } else {
                func_call_function(arg0, arg1, arg2);
                LogPrint(&#34;after load:&#34; + sopath + &#34;--end call_function,type:&#34; + functiontype + &#34;--addr:&#34; + functionaddr + &#34;---baseaddr:&#34; + modulebaseaddr);

            }

        }, &#39;void&#39;, [&#39;pointer&#39;, &#39;pointer&#39;, &#39;pointer&#39;]));
    }
}

setImmediate(hooklinker)
</code></pre><p>我调试了一下 linker64，因为没有导出 call_function 的地址，所以不能直接 hook 符号名，而是要根据偏移去 hook，以后再说。
其实要看<code>init_array</code>，直接 shift+F7 去 segment 里面找<code>.init_array</code>段就可以了，这里主要是为了反反调试，因为可能反调试会加在 init_array 里，hook call_function 就可以让它不加载反调试程序。</p><h3 id=native层未导出函数主动调用任意符号和地址-native层未导出函数主动调用任意符号和地址native-层未导出函数主动调用任意符号和地址><a href=#native%e5%b1%82%e6%9c%aa%e5%af%bc%e5%87%ba%e5%87%bd%e6%95%b0%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%ef%bc%88%e4%bb%bb%e6%84%8f%e7%ac%a6%e5%8f%b7%e5%92%8c%e5%9c%b0%e5%9d%80%ef%bc%89 title=native层未导出函数主动调用（任意符号和地址）></a>native 层未导出函数主动调用（任意符号和地址）</h3><p>现在我想要主动调用 sakura_add 来打印值, 可以 ida 打开找符号，或者根据偏移，总之最终用这个 NativePointer 指针来初始化一个 NativeFunction 来调用。</p><pre tabindex=0><code>extern &#34;C&#34;
JNIEXPORT jint JNICALL
Java_com_example_ndk_1demo_MainActivity_sakuraWithInt(JNIEnv *env, jobject thiz, jint a, jint b) {
    // TODO: implement sakuraWithInt()
    return sakura_add(a,b);
}
...
int sakura_add(int a, int b){
    int sum = a+b;
    LOGD(&#34;sakura add a+b:&#34;,sum);
    return sum;
}
</code></pre><p><a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-142324.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-03-142324.png alt loading=lazy data-zoomable></div></div></figure></a></p><pre tabindex=0><code>function main() {
    var libnative_lib_addr = Module.findBaseAddress(&#34;libnative-lib.so&#34;);
    console.log(&#34;libnative_lib_addr is :&#34;, libnative_lib_addr);
    if (libnative_lib_addr) {
        var sakura_add_addr1 = Module.findExportByName(&#34;libnative-lib.so&#34;, &#34;_Z10sakura_addii&#34;);
        var sakura_add_addr2 = libnative_lib_addr.add(0x0F56C) ;
        console.log(&#34;sakura_add_addr1 &#34;, sakura_add_addr1);
        console.log(&#34;sakura_add_addr2 &#34;, sakura_add_addr2)
    }

    var sakura_add1 = new NativeFunction(sakura_add_addr1, &#34;int&#34;, [&#34;int&#34;, &#34;int&#34;]);
    var sakura_add2 = new NativeFunction(sakura_add_addr2, &#34;int&#34;, [&#34;int&#34;, &#34;int&#34;]);

    console.log(&#34;sakura_add1 result is :&#34;, sakura_add1(200, 33));
    console.log(&#34;sakura_add2 result is :&#34;, sakura_add2(100, 133));
}
setImmediate(main())
...
...
libnative_lib_addr is : 0x79fa1c5000
sakura_add_addr1  0x79fa1d456c
sakura_add_addr2  0x79fa1d456c
sakura_add1 result is : 233
sakura_add2 result is : 233
</code></pre><h2 id=c-c-hook-cc-hookcc-hook><a href=#C-C-hook title="C/C++ hook"></a>C/C++ hook</h2><p>//todo</p><h3 id=native-jni层参数打印和主动调用参数构造-nativejni层参数打印和主动调用参数构造nativejni-层参数打印和主动调用参数构造><a href=#Native-JNI%e5%b1%82%e5%8f%82%e6%95%b0%e6%89%93%e5%8d%b0%e5%92%8c%e4%b8%bb%e5%8a%a8%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0%e6%9e%84%e9%80%a0 title=Native/JNI层参数打印和主动调用参数构造></a>Native/JNI 层参数打印和主动调用参数构造</h3><p>jni 的基本类型要通过调用 jni 相关的 api 转化成 c++ 对象，才能打印和调用。
jni 主动调用的时候，参数构造有两种方式，一种是<code>Java.vm.getenv</code>，另一种是 hook 获取 env 之后来调用 jni 相关的 api 构造参数。</p><h3 id=c-c-编成so并引入frida调用其中的函数-cc编成so并引入frida调用其中的函数cc-编成-so-并引入-frida-调用其中的函数><a href=#C-C-%e7%bc%96%e6%88%90so%e5%b9%b6%e5%bc%95%e5%85%a5Frida%e8%b0%83%e7%94%a8%e5%85%b6%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0 title=C/C++编成so并引入Frida调用其中的函数></a>C/C++ 编成 so 并引入 Frida 调用其中的函数</h3><h2 id=致谢-致谢致谢><a href=#%e8%87%b4%e8%b0%a2 title=致谢></a>致谢</h2><p>本篇文章学到的内容来自且完全来自 r0ysue 的知识星球，推荐一下。
<a href=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-07-061015.png target=_blank rel=noopener><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://sakura-1252236262.cos.ap-beijing.myqcloud.com/2020-07-07-061015.png alt loading=lazy data-zoomable></div></div></figure></a></p></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>上一页</div><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/app-%E9%80%86%E5%90%91-%E5%B9%B3%E5%A4%B4%E5%93%A5%E5%AE%9E%E6%88%98%E6%9F%90%E5%86%9C%E4%BA%A7%E5%93%81-app/ rel=next>app 逆向 平头哥实战（某农产品 app）</a></div><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/infosecurity-series/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/frida-%E5%85%8D-root-hook/ rel=prev>frida 免 root hook</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>