<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>99.参考资料 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/mysql-series/4.%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%87%E4%BB%BD/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link><atom:link href="https://ng-tech.icu/books/mysql-series/4.%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%87%E4%BB%BD/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml"/><description>99.参考资料</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>99.参考资料</title><link>https://ng-tech.icu/books/mysql-series/4.%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%87%E4%BB%BD/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link></image><item><title>2020-heibaiying-MySQL 复制</title><link>https://ng-tech.icu/books/mysql-series/4.%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%87%E4%BB%BD/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-mysql-%E5%A4%8D%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/mysql-series/4.%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%87%E4%BB%BD/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-mysql-%E5%A4%8D%E5%88%B6/</guid><description>&lt;h1 id="mysql-复制">MySQL 复制&lt;/h1>
&lt;h2 id="一日志格式">一、日志格式&lt;/h2>
&lt;h3 id="11-二进制日志格式">1.1 二进制日志格式&lt;/h3>
&lt;p>MySQL 二进制日志是进行主从复制的基础，它记录了所有对 MySQL 数据库的修改事件，包括增删改查和表结构修改。当前 MySQL 一共支持三种二进制日志格式，可以通过 binlog-format 参数来进行控制，其可选值如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>STATEMENT&lt;/strong>：段格式。是 MySQL 最早支持的二进制日志格式。其记录的是实际执行修改的 SQL 语句，因此在进行批量修改时其所需要记录的数据量比较小，但对于 UUID() 或者其他依赖上下文的执行语句，可能会在主备上产生不一样的结果。&lt;/li>
&lt;li>&lt;strong>ROW&lt;/strong>：行格式，是 MySQL 5.7 版本之后默认的二进制日志格式。其记录的是修改前后的数据，因此在批量修改时其需要记录的数据量比较大，但其安全性比较高，不会导致主备出现不一致的情况。同时因为 ROW 格式是在从库上直接应用更改后的数据，其还能减少锁的使用。&lt;/li>
&lt;li>&lt;strong>MIXED&lt;/strong>：是以上两种日志的混合方式，默认采用段格式进行记录，当段格式不适用时 (如 UUID() )，则默认采用 ROW 格式。&lt;/li>
&lt;/ul>
&lt;p>通常在主备之间网络情况良好的时，可以优先考虑使用 ROW 格式，此时数据一致性最高，其次是 MIXED 格式。在设置 ROW 格式时，还有一个非常重要的参数 binlog_row_image ：&lt;/p>
&lt;h3 id="12-binlog_row_image">1.2 binlog_row_image&lt;/h3>
&lt;p>binlog_row_image 有以下三个可选值：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>full&lt;/strong>：默认值，记录行在修改前后所有列的值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>minimal&lt;/strong>：只记录修改涉及列的值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>noblob&lt;/strong>：与 full 类似，但如果 BLOB 或 TEXT 列没有修改，则不对其进行记录。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>binlog-format 和 binlog_row_image 的默认值可能在不同版本存在差异，可以使用以下命令进行查看。通常情况下，为了减少在主备复制中需要传输的数据量，可以将 binlog_row_image 的值设置为 minimal 或 noblob。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">show&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;binlog_format&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">show&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;binlog_row_image&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="二基于二进制日志的复制">二、基于二进制日志的复制&lt;/h2>
&lt;h3 id="21-复制原理">2.1 复制原理&lt;/h3>
&lt;p>MySQL 的复制原理如下图所示：&lt;/p>
&lt;ul>
&lt;li>主库首先将变更写入到自己的二进制日志中；&lt;/li>
&lt;li>备库会启动一个 IO 线程，然后主动去主库节点上获取变更日志，并写入到自己的中继日志中。&lt;/li>
&lt;li>之后从中继日志中读取变更事件，在从库上执行变更。&lt;/li>
&lt;li>当备库与主库数据状态一致，备库的 IO 线程就会进入睡眠。当主库再次发生变更时，其会向备库发出信号，唤醒 IO 线程并再次进行工作。&lt;/li>
&lt;/ul>
&lt;p>如果没有进行任何配置，主库在将变更写入到二进制日志后，就会返回对客户端的响应，因此默认情况下的复制是完全异步进行的，主备之间可能会短暂存在数据不一致的情况。&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/mysql-replication.jpg"/> &lt;/div>
&lt;h3 id="22-配置步骤">2.2 配置步骤&lt;/h3>
&lt;p>首先主节点需要开启二进制日志，并且在同一个复制环境下，主备节点的 server-id 需要不一样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="err">[mysqld]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">server-id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">226&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 开启二进制日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">log-bin&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">mysql-bin&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在备份节点配置中继日志：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="err">[mysqld]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">server-id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">227&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 配置中继日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">relay_log&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">mysql-relay-bin&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 为了保证数据的一致性，从节点应该设置为只读&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">read_only&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 以下两个配置代表是否开启二进制日志，如果该从节点还作为其他备库的主节点，则开启，否则不用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">log-bin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">mysql-bin&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 是否将中继节点收到的复制事件写到自己的二进制日志中&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">log_slave_updates&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>登录主节点 MySQL 服务，创建用于进行复制账号，并为其授予权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">CREATE USER &lt;span class="s1">&amp;#39;repl&amp;#39;&lt;/span>@&lt;span class="s1">&amp;#39;192.168.0.%&amp;#39;&lt;/span> IDENTIFIED WITH mysql_native_password BY &lt;span class="s1">&amp;#39;123456&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GRANT REPLICATION SLAVE on *.* TO &lt;span class="s1">&amp;#39;repl&amp;#39;&lt;/span>@&lt;span class="s1">&amp;#39;192.168.0.%&amp;#39;&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看主节点二进制日志的状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysql&amp;gt; SHOW MASTER STATUS&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+------------------+----------+--------------+------------------+-------------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> File &lt;span class="p">|&lt;/span> Position &lt;span class="p">|&lt;/span> Binlog_Do_DB &lt;span class="p">|&lt;/span> Binlog_Ignore_DB &lt;span class="p">|&lt;/span> Executed_Gtid_Set &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+------------------+----------+--------------+------------------+-------------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> mysql-bin.000001 &lt;span class="p">|&lt;/span> &lt;span class="m">887&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+------------------+----------+--------------+------------------+-------------------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基于日志和偏移量，建立复制链路：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">CHANGE MASTER TO &lt;span class="nv">MASTER_HOST&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;192.168.0.226&amp;#39;&lt;/span>,&lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">MASTER_USER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;repl&amp;#39;&lt;/span>, &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">MASTER_PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;123456&amp;#39;&lt;/span>,&lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">MASTER_LOG_FILE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;mysql-bin.000001&amp;#39;&lt;/span>,&lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">MASTER_LOG_POS&lt;/span>&lt;span class="o">=&lt;/span>887&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>开始复制：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">START SLAVE&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看从节点复制状态，主要参数有 Slave_IO_Running 和 Slave_SQL_Running，其状态都为 Yes 表示用于复制的 IO 进程已经开启。Seconds_Behind_Master 参数表示从节点复制的延迟量。此时可以在主库上进行任意更改，并在备库上查看情况。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysql&amp;gt; SHOW SLAVE STATUS&lt;span class="se">\G&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*************************** 1. row ***************************
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Slave_IO_State: Waiting &lt;span class="k">for&lt;/span> master to send event
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_Host: 192.168.0.226
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_User: repl
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_Port: &lt;span class="m">3306&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Connect_Retry: &lt;span class="m">60&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_Log_File: mysql-bin.000001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Read_Master_Log_Pos: &lt;span class="m">887&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Relay_Log_File: mysql-relay-bin.000002
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Relay_Log_Pos: &lt;span class="m">322&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Relay_Master_Log_File: mysql-bin.000001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Slave_IO_Running: Yes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Slave_SQL_Running: Yes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Do_DB:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Ignore_DB:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Do_Table:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Ignore_Table:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Wild_Do_Table:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Wild_Ignore_Table:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_Errno: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_Error:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Skip_Counter: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Exec_Master_Log_Pos: &lt;span class="m">887&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Relay_Log_Space: &lt;span class="m">530&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Until_Condition: None
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Until_Log_File:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Until_Log_Pos: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_Allowed: No
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_CA_File:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_CA_Path:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_Cert:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_Cipher:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_Key:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Seconds_Behind_Master: 0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Master_SSL_Verify_Server_Cert: No
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_IO_Errno: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_IO_Error:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_SQL_Errno: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_SQL_Error:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Ignore_Server_Ids:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_Server_Id: &lt;span class="m">226&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Master_UUID: e1148574-bdd0-11e9-8873-0800273acbfd&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_Info_File: mysql.slave_master_info
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SQL_Delay: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SQL_Remaining_Delay: NULL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Slave_SQL_Running_State: Slave has &lt;span class="nb">read&lt;/span> all relay log&lt;span class="p">;&lt;/span> waiting &lt;span class="k">for&lt;/span> more updates
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_Retry_Count: &lt;span class="m">86400&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_Bind:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_IO_Error_Timestamp:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Last_SQL_Error_Timestamp:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_Crl:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_SSL_Crlpath:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Retrieved_Gtid_Set:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Executed_Gtid_Set:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Auto_Position: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Replicate_Rewrite_DB:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Channel_Name:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_TLS_Version:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Master_public_key_path:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Get_master_public_key: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Network_Namespace:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">1&lt;/span> row in &lt;span class="nb">set&lt;/span> &lt;span class="o">(&lt;/span>0.00 sec&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="23-优缺点">2.3 优缺点&lt;/h3>
&lt;p>基于二进制日志的复制是 MySQL 最早使用的复制技术，因此 MySQL 对其的支持比较完善，对执行修改的 SQL 语句几乎没有任何限制。其主要的缺点是在一主多从的高可用复制架构中，如果主库发生宕机，此时想要自动通过从库的日志和偏移量来确定新的主库比较困难。&lt;/p>
&lt;h2 id="三基于-gtid-的复制">三、基于 GTID 的复制&lt;/h2>
&lt;h3 id="21-gtid-简介">2.1 GTID 简介&lt;/h3>
&lt;p>MySQL 5.6 版本之后提供了一个新的复制模式：基于 GTID 的复制。GTID 全称为 Global Transaction ID，即全局事务 ID。它由每个服务节点的唯一标识和其上的事务 ID 共同组成，格式为： &lt;em>server_uuid : transaction_id&lt;/em> 。通过 GTID ，可以保证在主库上的每一个事务都能在备库上得到执行，不会存在任何疏漏。&lt;/p>
&lt;h3 id="22-配置步骤-1">2.2 配置步骤&lt;/h3>
&lt;p>主从服务器均增加以下 GTID 的配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="na">gtid-mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">ON&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 防止执行不受支持的语句，下文会有说明&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">enforce-gtid-consistency&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">ON&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果配置过上面的基于二进制日志的复制，还需要在从服务器上执行以下命令，关闭原有复制链路：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">STOP SLAVE IO_THREAD FOR CHANNEL &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>建立新的基于 GTID 复制链路，指定 &lt;code>MASTER_AUTO_POSITION = 1&lt;/code> 表示由程序来自动确认开始同步的 GTID 的位置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">CHANGE MASTER TO &lt;span class="nv">MASTER_HOST&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;192.168.0.226&amp;#39;&lt;/span>,&lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">MASTER_USER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;repl&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">MASTER_PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;123456&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">MASTER_AUTO_POSITION&lt;/span>&lt;span class="o">=&lt;/span>1&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>开始复制：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">START SLAVE&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在主节点上执行任意修改操作，并查看从节点状态，关键的输出如下：Retrieved_Gtid_Set 代表从主节点上接收到的两个事务，Executed_Gtid_Set 表示这两个事务已经在从库上得到执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SLAVE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">....&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Master_UUID&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e1148574&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">bdd0&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="n">e9&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8873&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0800273&lt;/span>&lt;span class="n">acbfd&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Retrieved_Gtid_Set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e1148574&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">bdd0&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="n">e9&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8873&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0800273&lt;/span>&lt;span class="n">acbfd&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Executed_Gtid_Set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e1148574&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">bdd0&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="n">e9&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8873&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0800273&lt;/span>&lt;span class="n">acbfd&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">.....&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="23-优缺点-1">2.3 优缺点&lt;/h3>
&lt;p>GTID 复制的优点在于程序可以自动确认开始复制的 GTID 点。但其仍然存在以下限制：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不支持 CREATE TABLE &amp;hellip; SELECT 语句。 因为在 ROW 格式下，该语句将会被记录为具有不同 GTID 的两个事务，此时从服务器将无法正确处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>事务，过程，函数和触发器内部的 CREATE TEMPORARY TABLE 和 DROP TEMPORARY TABLE 语句均不受支持。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>为防止执行不受支持的语句，建议配置和上文配置一样，开启 enforce-gtid-consistency 属性， 开启后在主库上执行以上不受支持的语句都将抛出异常并提示。&lt;/p>
&lt;h2 id="四半同步复制">四、半同步复制&lt;/h2>
&lt;p>在上面我们介绍过，不论是基于二进制日志的复制还是基于 GTID 的复制，其本质上都是异步复制，假设从节点还没有获取到二进制日志信息时主节点就宕机了，那么就会存在数据不一致的问题。想要解决这个问题可以通过配置半同步复制来实现：进行半同步复制时，主节点会等待至少一个从节点获取到二进制日志后才将事务的执行结果返回给客户端。具体配置步骤如下：&lt;/p>
&lt;h4 id="1-安装插件">1. 安装插件&lt;/h4>
&lt;p>MySQL 从 5.5 之后开始以插件的形式支持半同步复制，所以先需要先进行插件的安装，命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 主节点上执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INSTALL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PLUGIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rpl_semi_sync_master&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SONAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;semisync_master.so&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- 从节点上执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">INSTALL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PLUGIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rpl_semi_sync_slave&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SONAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;semisync_slave.so&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你的复制是基于高可用架构的，即从节点可能会在主节点宕机后成为新的主节点，而原主节点可能在失败恢复后成为从节点，那么为了保证半同步复制仍然有效，此时可以在主从节点上都安装主从插件。安装后使用以下命令查看是否安装成功：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysql&amp;gt; SELECT PLUGIN_NAME, PLUGIN_STATUS FROM INFORMATION_SCHEMA.PLUGINS WHERE PLUGIN_NAME LIKE &lt;span class="s1">&amp;#39;%semi%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+----------------------+---------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> PLUGIN_NAME &lt;span class="p">|&lt;/span> PLUGIN_STATUS &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+----------------------+---------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> rpl_semi_sync_master &lt;span class="p">|&lt;/span> ACTIVE &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> rpl_semi_sync_slave &lt;span class="p">|&lt;/span> ACTIVE &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+----------------------+---------------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-配置半同步复制">2. 配置半同步复制&lt;/h4>
&lt;p>半同步复制可以基于日志复制或 GTID 复制开启，只需要在其原有配置上增加以下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 主节点上增加如下配置：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">plugin-load&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">rpl_semi_sync_master=semisync_master.so&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">rpl_semi_sync_master_enabled&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 从节点上增加如下配置：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">plugin-load&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">rpl_semi_sync_slave=semisync_slave.so&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">rpl_semi_sync_slave_enabled&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 和上面提到的一样，如果是高可用架构下，则主从节点都可以增加主从配置：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">plugin-load&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">rpl-semi-sync-master-enabled&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">rpl-semi-sync-slave-enabled&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-启动复制">3. 启动复制&lt;/h4>
&lt;p>按照二进制日志或 GTID 的方式正常启动复制即可，此时可以使用如下命令查看半同步日志是否正在执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 主节点&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysql&amp;gt; SHOW STATUS LIKE &lt;span class="s1">&amp;#39;Rpl_semi_sync_master_status&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+-----------------------------+-------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> Variable_name &lt;span class="p">|&lt;/span> Value &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+-----------------------------+-------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> Rpl_semi_sync_master_status &lt;span class="p">|&lt;/span> ON &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+-----------------------------+-------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 从节点&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysql&amp;gt; SHOW STATUS LIKE &lt;span class="s1">&amp;#39;Rpl_semi_sync_slave_status&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+----------------------------+-------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> Variable_name &lt;span class="p">|&lt;/span> Value &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+----------------------------+-------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> Rpl_semi_sync_slave_status &lt;span class="p">|&lt;/span> ON &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+----------------------------+-------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>值为 ON 代表半同步复制配置成功。&lt;/p>
&lt;h4 id="4-可选配置">4. 可选配置&lt;/h4>
&lt;p>半同步日志还有以下两个可选配置：一个是 &lt;code>rpl_semi_sync_master_wait_for_slave_count&lt;/code>，它表示主节点需要至少等待几个从节点复制完成，默认值为 1，因为等待过多从节点可能会导致长时间的延迟，所以通常使用默认值即可。另一个常用参数是 &lt;code>rpl_semi_sync_master_wait_point&lt;/code> ，它主要是用于控制等待的时间点，它有以下两个可选值：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>AFTER_SYNC&lt;/strong>（默认值）：主服务器将每个事务写入其二进制日志，并将二进制日志同步到磁盘后开始进行等待。在收到从节点的确认后，才将事务提交给存储引擎并将结果返回给客户端。&lt;/li>
&lt;li>&lt;strong>AFTER_COMMIT&lt;/strong>：主服务器将每个事务写入其二进制日志并同步到磁盘，然后将事务提交到存储引擎，提交后再进行等待。在收到从节点的确认后，才将结果返回给客户端。&lt;/li>
&lt;/ul>
&lt;p>第二种方式是 MySQL 5.7.2 之前默认方式，但这种方式会导致数据的丢失，所以在 5.7.2 版本后就引入了第一种方式作为默认方式，它可以实现无损复制 (lossless replication)，数据基本无丢失，因此 &lt;code>rpl_semi_sync_master_wait_point&lt;/code> 参数通常也不用进行修改，采用默认值即可。想要查看当前版本该参数的值，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysql&amp;gt; SHOW VARIABLES LIKE &lt;span class="s1">&amp;#39;rpl_semi_sync_master_wait_point&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+---------------------------------+------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> Variable_name &lt;span class="p">|&lt;/span> Value &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+---------------------------------+------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">|&lt;/span> rpl_semi_sync_master_wait_point &lt;span class="p">|&lt;/span> AFTER_SYNC &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+---------------------------------+------------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然半同步复制能够最大程度的避免数据的丢失，但是因为网络通讯会导致额外的等待时间的开销，所以尽量在低延迟的网络环境下使用，如处于同一机房的主机之间。&lt;/p>
&lt;h2 id="五高可用架构">五、高可用架构&lt;/h2>
&lt;p>不论是主主复制结构，还是一主多从复制结构，单存依靠复制只能解决数据可靠性的问题，并不能解决系统高可用的问题，想要保证高可用，系统必须能够自动进行故障转移，即在主库宕机时，主动将其它备库升级为主库。常用的有以下两种解决方案：&lt;/p>
&lt;h3 id="51-mmm">5.1 MMM&lt;/h3>
&lt;p>MMM (Master-Master replication manager for MySQL) 是由 Perl 语言开发的一套支持双主故障切换以及双主日常管理的第三方软件。它包含两类角色：&lt;code>writer&lt;/code> 和 &lt;code>reader&lt;/code>，分别对应读写节点和只读节点。使用 MMM 管理的双主节点在同一时间上只允许一个进行写入操作，当 &lt;code>writer&lt;/code> 节点出现宕机（假设是 Master1），程序会自动移除该节点上的读写 VIP，然后切换到 Master2 ，并设置 Master2 的 read_only = 0，即关闭只读限制，同时将所有 Slave 节点重新指向 Master2。&lt;/p>
&lt;p>除了管理双主节点，MMM 也负责管理所有 Slave 节点，在出现宕机、复制延迟或复制错误，MMM 会移除该节点的 VIP，直至节点恢复正常。MMM 高可用的架构示例图如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/mysql-MMM架构.png"/> &lt;/div>
MMM 架构的缺点在于虽然其能实现自动切换，但却不会主动补齐丢失的数据，所以会存在数据不一致性的风险。另外 MMM 的发布时间比较早，所以其也不支持 MySQL 最新的基于 GTID 的复制，如果你使用的是基于 GTID 的复制，则只能采用 MHA。
&lt;h3 id="52-mha">5.2 MHA&lt;/h3>
&lt;p>MHA (Master High Availability) 是由 Perl 实现的一款高可用程序，相对于 MMM ，它能尽量避免数据不一致的问题。它监控的是一主多从的复制架构，架构如下图所示：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/mysql-MHA架构.png"/> &lt;/div>
在 Master 节点宕机后，其处理流程如下：
&lt;ol>
&lt;li>尝试从宕机 Master 中保存二进制日志；&lt;/li>
&lt;li>找到含有最新中继日志的 Slave；&lt;/li>
&lt;li>把最新中继日志应用到其他实例，保证各实例数据一致；&lt;/li>
&lt;li>应用从 Master 保存的二进制日志事件；&lt;/li>
&lt;li>提升一个 Slave 为 Master ；&lt;/li>
&lt;li>其他 Slave 向该新 Master 同步。&lt;/li>
&lt;/ol>
&lt;p>按照以上的处理流程，MHA 能够最大程序的避免数据不一致的问题。但如果 Master 所在的服务器也宕机了，那么过程的第一步就会失败。在 MySQL 5.5 后，可以开启半同步复制后来避免这个问题，从而可以保证数据的一致性和几乎无丢失。当然 MHA 集群也存在一下一些缺点：&lt;/p>
&lt;ul>
&lt;li>集群中所有节点之间需要开启 SSH 服务，所以会存在一定的安全影响。&lt;/li>
&lt;li>没有实现 Slave 的高可用。&lt;/li>
&lt;li>自带的脚本不足，例如虚拟 IP 的配置需要自己通过命令或者其他第三方软件来实现。&lt;/li>
&lt;li>需要手动清理中继日志。&lt;/li>
&lt;/ul>
&lt;p>以上就是 MMM 和 MHA 架构的简单介绍，关于其具体搭建步骤，可以参考以下两篇博客： &lt;a href="https://segmentfault.com/a/1190000017286307" target="_blank" rel="noopener">MySQL 集群搭建(3)-MMM 高可用架构&lt;/a> 和 &lt;a href="https://segmentfault.com/a/1190000017486693" target="_blank" rel="noopener">MySQL 集群搭建(5)-MHA 高可用架构&lt;/a>。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/replication.html" target="_blank" rel="noopener">Chapter 17 Replication&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/replication-gtids-concepts.html" target="_blank" rel="noopener">GTID Format and Storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/ivictor/p/5735580.html" target="_blank" rel="noopener">MySQL 半同步复制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000017286307" target="_blank" rel="noopener">MySQL 集群搭建(3)-MMM 高可用架构&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000017486693" target="_blank" rel="noopener">MySQL 集群搭建(5)-MHA 高可用架构&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>2020-heibaiying-数据备份与恢复</title><link>https://ng-tech.icu/books/mysql-series/4.%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%87%E4%BB%BD/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/mysql-series/4.%E9%9B%86%E7%BE%A4%E4%B8%8E%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%A4%87%E4%BB%BD/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid><description>&lt;h1 id="数据备份与恢复">数据备份与恢复&lt;/h1>
&lt;h2 id="一备份简介">一、备份简介&lt;/h2>
&lt;h3 id="21-备份分类">2.1 备份分类&lt;/h3>
&lt;p>按照不同的维度，通常将数据库的备份分为以下几类：&lt;/p>
&lt;p>&lt;strong>物理备份 与 逻辑备份&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>物理备份：备份的是完整的数据库目录和数据文件。采用该模式会进行大量的 IO 操作，但不含任何逻辑转换，因此备份和恢复速度通常都比较快。&lt;/li>
&lt;li>逻辑备份：通过数据库结构和内容信息来进行备份。因为要执行逻辑转换，因此其速度较慢，并且在以文本格式保存时，其输出文件的大小大于物理备份。逻辑备份的还原的粒度可以从服务器级别（所有数据库）精确到具体表，但备份不会包括日志文件、配置文件等与数据库无关的内容。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>全量备份 与 增量备份&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>全量备份：备份服务器在给定时间点上的所有数据。&lt;/li>
&lt;li>增量备份：备份在给定时间跨度内（从一个时间点到另一个时间点）对数据所做的更改。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在线备份 与 离线备份&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在线备份：数据库服务在运行状态下进行备份。此时其他客户端依旧可以连接到数据库，但为了保证数据的一致性，在备份期间可能会对数据进行加锁，此时客户端的访问依然会受限。&lt;/li>
&lt;li>离线备份：在数据库服务停机状态下进行备份。此备份过程简单，但由于无法提供对外服务，通常会对业务造成比较大的影响。&lt;/li>
&lt;/ul>
&lt;h3 id="22-备份工具">2.2 备份工具&lt;/h3>
&lt;p>MySQL 支持的备份工具有很多种，这里列出常用的三种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>mysqldump&lt;/strong>：这是 MySQL 自带的备份工具，其采用的备份方式是逻辑备份，支持全库备份、单库备份、单表备份。由于其采用的是逻辑备份，所以生成的备份文件比物理备份的大，且所需恢复时间也比较长。&lt;/li>
&lt;li>&lt;strong>mysqlpump&lt;/strong>：这是 MySQL 5.7 之后新增的备份工具，在 mysqldump 的基础上进行了功能的扩展，支持多线程备份，支持对备份文件进行压缩，能够提高备份的速度和降低备份文件所需的储存空间。&lt;/li>
&lt;li>&lt;strong>Xtrabackup&lt;/strong>：这是 Percona 公司开发的实时热备工具，能够在不停机的情况下进行快速可靠的热备份，并且备份期间不会间断数据库事务的处理。它支持数据的全备和增备，并且由于其采用的是物理备份的方式，所以恢复速度比较快。&lt;/li>
&lt;/ul>
&lt;h2 id="二mysqldump">二、mysqldump&lt;/h2>
&lt;h3 id="21-常用参数">2.1 常用参数&lt;/h3>
&lt;p>mysqldump 的基本语法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 备份数据库或数据库中的指定表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqldump &lt;span class="o">[&lt;/span>options&lt;span class="o">]&lt;/span> db_name &lt;span class="o">[&lt;/span>tbl_name ...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 备份多个指定的数据库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqldump &lt;span class="o">[&lt;/span>options&lt;span class="o">]&lt;/span> --databases db_name ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 备份当前数据库实例中的所有表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqldump &lt;span class="o">[&lt;/span>options&lt;span class="o">]&lt;/span> --all-databases
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>options 代表可选操作，常用的可选参数如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;host=host_name， -h host_name&lt;/strong>&lt;/p>
&lt;p>指定服务器地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;user=user_name， -u user_name&lt;/strong>&lt;/p>
&lt;p>指定用户名。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;password[=password]， -p[password]&lt;/strong>&lt;/p>
&lt;p>指定密码。通常无需在命令行中明文指定，按照提示输入即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;default-character-set=charset_name&lt;/strong>&lt;/p>
&lt;p>导出文本使用的字符集，默认为 utf8。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;events， -E&lt;/strong>&lt;/p>
&lt;p>备份包含数据库中的事件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;ignore-table=db_name.tbl_name&lt;/strong>&lt;/p>
&lt;p>不需要进行备份的表，必须使用数据库和表名来共同指定。也可以作用于视图。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;routines， -R&lt;/strong>&lt;/p>
&lt;p>备份包含数据库中的存储过程和自定义函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;triggers&lt;/strong>&lt;/p>
&lt;p>备份包含数据库中的触发器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;where=&amp;lsquo;where_condition&amp;rsquo;， -w &amp;lsquo;where_condition&amp;rsquo;&lt;/strong>&lt;/p>
&lt;p>在对单表进行导出时候，可以指定过滤条件，例如指定用户名 &lt;code>--where=&amp;quot;user='jimf'&amp;quot;&lt;/code> 或用户范围 &lt;code>-w&amp;quot;userid&amp;gt;1&amp;quot;&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;lock-all-tables， -x&lt;/strong>&lt;/p>
&lt;p>锁定所有数据库中的所有表，从而保证备份数据的一致性。此选项自动关闭 &lt;code>--single-transaction&lt;/code> 和 &lt;code>--lock-tables&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;lock-tables， -l&lt;/strong>&lt;/p>
&lt;p>锁定当前数据库中所有表，能够保证当前数据库中表的一致性，但不能保证全局的一致性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;single-transaction&lt;/strong>&lt;/p>
&lt;p>此选项会将事务隔离模式设置为 REPEATABLE READ 并开启一个事务，从而保证备份数据的一致性。主要用于事务表，如 InnoDB 表。 但是此时仍然不能在备份表上执行 ALTER TABLE， CREATE TABLE， DROP TABLE， RENAME TABLE， TRUNCATE TABLE 等操作，因为 REPEATABLE READ 并不能隔离这些操作。&lt;/p>
&lt;p>另外需要注意的是 &lt;code>--single-transaction&lt;/code> 选项与 &lt;code>--lock-tables&lt;/code> 选项是互斥的，因为 LOCK TABLES 会导致任何正在挂起的事务被隐式提交。转储大表时，可以将 &lt;code>--single-transaction&lt;/code> 选项与 &lt;code>--quick&lt;/code> 选项组合使用 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;quick， -q&lt;/strong>&lt;/p>
&lt;p>主要用于备份大表。它强制 mysqldump 一次只从服务器检索一行数据，避免一次检索所有行而导致缓存溢出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;flush-logs, -F&lt;/strong>&lt;/p>
&lt;p>在开始备份前刷新 MySQL 的日志文件。此选项需要 RELOAD 权限。如果此选项与 &lt;code>--all-databases&lt;/code> 配合使用，则会在每个数据库开始备份前都刷新一次日志。如果配合 &lt;code>--lock-all-tables&lt;/code>，&lt;code>--master-data&lt;/code> 或 &lt;code>--single-transaction&lt;/code> 使用，则只会在锁定所有表或者开启事务时刷新一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;master-data[=&lt;em>value&lt;/em>]&lt;/strong>&lt;/p>
&lt;p>可以通过配置此参数来控制生成的备份文件是否包含 CHANGE MASTER 语句，该语句中包含了当前时间点二进制日志的信息。该选项有两个可选值：1 和 2 ，设置为 1 时 CHANGE MASTER 语句正常生成，设置为 2 时以注释的方式生成。&lt;code>--master-data&lt;/code> 选项还会自动关闭 &lt;code>--lock-tables&lt;/code> 选项，而且如果你没有指定 &lt;code>--single-transaction&lt;/code> 选项，那么它还会启用 &lt;code>--lock-all-tables&lt;/code> 选项，在这种情况下，会在备份开始时短暂内获取全局读锁。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="22-全量备份">2.2 全量备份&lt;/h3>
&lt;p>mysqldump 的全量备份与恢复的操作比较简单，示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 备份雇员库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqldump -uroot -p --databases employees &amp;gt; employees_bak.sql
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 恢复雇员库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysql -uroot -p &amp;lt; employees_bak.sql
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>单表备份：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 备份雇员库中的职位表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqldump -uroot -p --single-transaction employees titles &amp;gt; titles_bak.sql
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 恢复雇员库中的职位表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysql&amp;gt; use employees&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysql&amp;gt; &lt;span class="nb">source&lt;/span> /root/mysqldata/titles_bak.sql&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="23-增量备份">2.3 增量备份&lt;/h3>
&lt;p>mysqldump 本身并不能直接进行增量备份，需要通过分析二进制日志的方式来完成。具体示例如下：&lt;/p>
&lt;h4 id="1-基础全备">1. 基础全备&lt;/h4>
&lt;p>1.先执行一次全备作为基础，这里以单表备份为例，需要用到上文提到的 &lt;code>--master-data&lt;/code> 参数，语句如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysqldump -uroot -p --master-data&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span> --flush-logs employees titles &amp;gt; titles_bak.sql
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 more 命令查看备份文件，此时可以在文件开头看到 CHANGE MASTER 语句，语句中包含了二进制日志的名称和偏移量信息，具体如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- CHANGE MASTER TO MASTER_LOG_FILE=&amp;#39;mysql-bin.000004&amp;#39;, MASTER_LOG_POS=155;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-增量恢复">2. 增量恢复&lt;/h4>
&lt;p>对表内容进行任意修改，然后通过分析二进制日志文件来生成增量备份的脚本文件，示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysqlbinlog --start-position&lt;span class="o">=&lt;/span>&lt;span class="m">155&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--database&lt;span class="o">=&lt;/span>employees &lt;span class="si">${&lt;/span>&lt;span class="nv">MYSQL_HOME&lt;/span>&lt;span class="si">}&lt;/span>/data/mysql-bin.000004 &amp;gt; titles_inr_bak_01.sql
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要注意的是，在实际生产环境中，可能在全量备份后与增量备份前的时间间隔里生成了多份二进制文件，此时需要对每一个二进制文件都执行相同的命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysqlbinlog --database&lt;span class="o">=&lt;/span>employees &lt;span class="si">${&lt;/span>&lt;span class="nv">MYSQL_HOME&lt;/span>&lt;span class="si">}&lt;/span>/data/mysql-bin.000005 &amp;gt; titles_inr_bak_02.sql
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqlbinlog --database&lt;span class="o">=&lt;/span>employees &lt;span class="si">${&lt;/span>&lt;span class="nv">MYSQL_HOME&lt;/span>&lt;span class="si">}&lt;/span>/data/mysql-bin.000006 &amp;gt; titles_inr_bak_03.sql
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后将全备脚本 ( titles_bak.sql )，以及所有的增备脚本 ( inr_01.sql，inr_02.sql &amp;hellip;. ) 通过 source 命令导入即可，这样就完成了全量 + 增量的恢复。&lt;/p>
&lt;h2 id="三mysqlpump">三、mysqlpump&lt;/h2>
&lt;h3 id="31-功能优势">3.1 功能优势&lt;/h3>
&lt;p>mysqlpump 在 mysqldump 的基础上进行了扩展增强，其主要的优点如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>能够并行处理数据库及其中的对象，从而可以加快备份进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能够更好地控制数据库及数据库对象（表，存储过程，用户帐户等）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能够直接对备份文件进行压缩；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>备份时能够显示进度指标（估计值）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>备份用户时生成的是 CREATE USER 与 GRANT 语句，而不是像 mysqldump 一样备份成数据，可以方便用户按需恢复。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="32-常用参数">3.2 常用参数&lt;/h3>
&lt;p>mysqlpump 的使用和 mysqldump 基本一致，这里不再进行赘述。以下主要介绍部分新增的可选项，具体如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;default-parallelism=N&lt;/strong>&lt;/p>
&lt;p>每个并行处理队列的默认线程数。默认值为 2。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;parallel-schemas=[N:]db_list&lt;/strong>&lt;/p>
&lt;p>用于并行备份多个数据库：db_list 是一个或多个以逗号分隔的数据库名称列表；N 为使用的线程数，如果没有设置，则使用 &lt;code>--default-parallelism&lt;/code> 参数的值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;users&lt;/strong>&lt;/p>
&lt;p>将用户信息备份为 CREATE USER 语句和 GRANT 语句 。如果想要只备份用户信息，则可以使用下面的命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysqlpump --exclude-databases&lt;span class="o">=&lt;/span>% --users
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ndash;compress-output=algorithm&lt;/strong>&lt;/p>
&lt;p>默认情况下，mysqlpump 不对备份文件进行压缩。可以使用该选项指定压缩格式，当前支持 LZ4 和 ZLIB 两种格式。需要注意的是压缩后的文件可以占用更少的存储空间，但是却不能直接用于备份恢复，需要先进行解压，具体如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 采用lz4算法进行压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqlpump --compress-output&lt;span class="o">=&lt;/span>LZ4 &amp;gt; dump.lz4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 恢复前需要先进行解压&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lz4_decompress input_file output_file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 采用ZLIB算法进行压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysqlpump --compress-output&lt;span class="o">=&lt;/span>ZLIB &amp;gt; dump.zlib
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">zlib_decompress input_file output_file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MySQL 发行版自带了上面两个压缩工具，不需要进行额外安装。以上就是 mysqlpump 新增的部分常用参数，完整参数可以参考官方文档：&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlpump.html#option_mysqlpump_compress-output" target="_blank" rel="noopener">mysqlpump — A Database Backup Program&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="四xtrabackup">四、Xtrabackup&lt;/h2>
&lt;h3 id="41-在线安装">4.1 在线安装&lt;/h3>
&lt;p>Xtrabackup 可以直接使用 yum 命令进行安装，这里我的 MySQL 为 8.0 ，对应安装的 Xtrabackup 也为 8.0，命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装Percona yum 源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install https://repo.percona.com/yum/percona-release-latest.noarch.rpm
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install percona-xtrabackup-80
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="42-全量备份">4.2 全量备份&lt;/h3>
&lt;p>全量备份的具体步骤如下：&lt;/p>
&lt;h4 id="1-创建备份">1. 创建备份&lt;/h4>
&lt;p>Xtrabackup 全量备份的基本语句如下，可以使用 target-dir 指明备份文件的存储位置，parallel 则是指明操作的并行度：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --backup --user&lt;span class="o">=&lt;/span>root --password --parallel&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span> --target-dir&lt;span class="o">=&lt;/span>/data/backups/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上进行的是整个数据库实例的备份，如果需要备份指定数据库，则可以使用 &amp;ndash;databases 进行指定。&lt;/p>
&lt;p>另外一个容易出现的异常是：Xtrabackup 在进行备份时，默认会去 &lt;code>/var/lib/mysql/mysql.sock&lt;/code> 文件里获取数据库的 socket 信息，如果你修改了数据库的 socket 配置，则需要使用 &amp;ndash;socket 参数进行重新指定，否则会抛出找不到连接的异常。备份完整后需要立即执行的另外一个操作是 prepare （准备备份）。&lt;/p>
&lt;h4 id="2-准备备份">2. 准备备份&lt;/h4>
&lt;p>由于备份是将所有物理库表等文件复制到备份目录，而整个过程需要持续一段时间，此时备份的数据中就可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务，最终导致备份结果处于不一致状态。此时需要进行 prepare 操作来回滚未提交的事务及同步已经提交的事务至数据文件，从而使得整体达到一致性状态。命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --prepare --target-dir&lt;span class="o">=&lt;/span>/data/backups/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要特别注意的在该阶段不要随意中断 xtrabackup 进程，因为这可能会导致数据文件损坏，备份将无法使用。&lt;/p>
&lt;h4 id="3-恢复备份">3. 恢复备份&lt;/h4>
&lt;p>由于 xtrabackup 执行的是物理备份，所以想要进行恢复，必须先要停止 MySQL 服务。同时这里我们可以删除 MySQL 的数据目录来模拟数据丢失的情况，之后使用以下命令将备份文件拷贝到 MySQL 的数据目录下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 模拟数据异常丢失&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rm -rf /usr/app/mysql-8.0.17/data/*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将备份文件拷贝到 data 目录下&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">xtrabackup --copy-back --target-dir&lt;span class="o">=&lt;/span>/data/backups/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>copy-back 命令只需要指定备份文件的位置，不需要指定 MySQL 数据目录的位置，因为 Xtrabackup 会自动从 &lt;code>/etc/my.cnf&lt;/code> 上获取 MySQL 的相关信息，包括数据目录的位置。如果不需要保留备份文件，可以直接使用 &lt;code>--move-back&lt;/code> 命令，代表直接将备份文件移动到数据目录下。此时数据目录的所有者通常为执行命令的用户，需要更改为 mysql 用户，命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">chown -R mysql:mysql /usr/app/mysql-8.0.17/data
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次启动即可完成备份恢复。&lt;/p>
&lt;h3 id="43-增量备份">4.3 增量备份&lt;/h3>
&lt;p>使用 Xtrabackup 进行增量备份时，每一次增量备份都需要以上一次的备份为基础，之后再将增量备份运用到第一次全备之上，从而完成备份。具体操作如下：&lt;/p>
&lt;h4 id="1-创建备份-1">1. 创建备份&lt;/h4>
&lt;p>这里首先创建一个全备作为基础：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --user&lt;span class="o">=&lt;/span>root --password --backup --target-dir&lt;span class="o">=&lt;/span>/data/backups/base/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后修改库中任意数据，然后进行第一次增量备份，此时需要使用 &lt;code>incremental-basedir&lt;/code> 指定基础目录为全备目录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --user&lt;span class="o">=&lt;/span>root --password --backup --target-dir&lt;span class="o">=&lt;/span>/data/backups/inc1 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--incremental-basedir&lt;span class="o">=&lt;/span>/data/backups/base
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再修改库中任意数据，然后进行第二次增量备份，此时需要使用 &lt;code>incremental-basedir&lt;/code> 指定基础目录为上一次增备目录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --user&lt;span class="o">=&lt;/span>root --password --backup --target-dir&lt;span class="o">=&lt;/span>/data/backups/inc2 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--incremental-basedir&lt;span class="o">=&lt;/span>/data/backups/inc1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-准备备份-1">2. 准备备份&lt;/h4>
&lt;p>准备基础备份：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --prepare --apply-log-only --target-dir&lt;span class="o">=&lt;/span>/data/backups/base
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将第一次备份作用于全备数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --prepare --apply-log-only --target-dir&lt;span class="o">=&lt;/span>/data/backups/base &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--incremental-dir&lt;span class="o">=&lt;/span>/data/backups/inc1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将第二次备份作用于全备数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --prepare --target-dir&lt;span class="o">=&lt;/span>/data/backups/base &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--incremental-dir&lt;span class="o">=&lt;/span>/data/backups/inc2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在准备备份时候，除了最后一次增备外，其余的准备命令都需要加上 &lt;code>--apply-log-only&lt;/code> 选项来阻止事务的回滚，因为备份时未提交的事务可能正在进行，并可能在下一次增量备份中提交，如果不进行阻止，那么增量备份将没有任何意义。&lt;/p>
&lt;h4 id="3-恢复备份-1">3. 恢复备份&lt;/h4>
&lt;p>恢复备份和全量备份时相同，只需要最终准备好的全备数据复制到 MySQL 的数据目录下即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">xtrabackup --copy-back --target-dir&lt;span class="o">=&lt;/span>/data/backups/base
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 必须修改文件权限，否则无法启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chown -R mysql:mysql /usr/app/mysql-8.0.17/data
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时增量备份就已经完成。需要说明的是：按照上面的情况，如果第二次备份之后发生了宕机，那么第二次备份后到宕机前的数据依然没法通过 Xtrabackup 进行恢复，此时就只能采用上面介绍的分析二进制日志的恢复方法。由此可以看出，无论是采用何种备份方式，二进制日志都是非常重要的，因此最好对其进行实时备份。&lt;/p>
&lt;h2 id="五二进制日志的备份">五、二进制日志的备份&lt;/h2>
&lt;p>想要备份二进制日志文件，可以通过定时执行 cp 或 scp 等命令来实现，也可以通过 mysqlbinlog 自带的功能来实现远程备份，将远程服务器上的二进制日志文件复制到本机，命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mysqlbinlog --read-from-remote-server --raw --stop-never &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--host&lt;span class="o">=&lt;/span>主机名 --port&lt;span class="o">=&lt;/span>&lt;span class="m">3306&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--user&lt;span class="o">=&lt;/span>用户名 --password&lt;span class="o">=&lt;/span>密码 初始复制时的日志文件名
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要注意的是这里的用户必须具有 replication slave 权限，因为上述命令本质上是模拟主从复制架构下，从节点通过 IO 线程不断去获取主节点的二进制日志，从而达到备份的目的。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/backup-and-recovery.html" target="_blank" rel="noopener">Chapter 7 Backup and Recovery&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html" target="_blank" rel="noopener">mysqldump — A Database Backup Program&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlpump.html" target="_blank" rel="noopener">mysqlpump — A Database Backup Program&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.percona.com/doc/percona-xtrabackup/LATEST/index.html" target="_blank" rel="noopener">Percona XtraBackup - Documentation&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>