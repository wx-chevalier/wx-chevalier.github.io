<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cn | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/</link><atom:link href="https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/index.xml" rel="self" type="application/rss+xml"/><description>cn</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>cn</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/</link></image><item><title>api-rate-limiting</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/api-rate-limiting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/api-rate-limiting/</guid><description>&lt;p>给定一个公共API，限制每个用户每秒只能调用1000次，如何实现？&lt;/p>
&lt;p>这个一个经典的API限速问题(API rate limiting)。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.careercup.com/question?id=5147519440912384" target="_blank" rel="noopener">Google Interview API rate limiting - CareerCup&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>crawler</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/crawler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/crawler/</guid><description>&lt;p>请设计一个网络爬虫。&lt;/p>
&lt;p>并发下载，网址去重，IP被禁等等&lt;/p></description></item><item><title>distributed-id-generator</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/distributed-id-generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/distributed-id-generator/</guid><description>&lt;p>如何设计一个分布式ID生成器(Distributed ID Generator)，并保证ID按时间粗略有序？&lt;/p>
&lt;h3 id="应用场景scenario">应用场景(Scenario)&lt;/h3>
&lt;p>现实中很多业务都有&lt;strong>生成唯一ID&lt;/strong>的需求，例如：&lt;/p>
&lt;ul>
&lt;li>用户ID&lt;/li>
&lt;li>微博ID&lt;/li>
&lt;li>聊天消息ID&lt;/li>
&lt;li>帖子ID&lt;/li>
&lt;li>订单ID&lt;/li>
&lt;/ul>
&lt;h3 id="需求needs">需求(Needs)&lt;/h3>
&lt;p>这个ID往往会作为数据库主键，所以需要保证&lt;strong>全局唯一&lt;/strong>。数据库会在这个字段上建立聚集索引(Clustered Index，参考 MySQL InnoDB)，即该字段会影响各条数据再物理存储上的顺序。&lt;/p>
&lt;p>ID还要尽可能&lt;strong>短&lt;/strong>，节省内存，让数据库索引效率更高。基本上64位整数能够满足绝大多数的场景，但是如果能做到比64位更短那就更好了。需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。&lt;/p>
&lt;p>查询的时候，往往有分页或者&lt;strong>排序&lt;/strong>的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID&lt;strong>按照时间粗略有序&lt;/strong>，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。&lt;/p>
&lt;p>这就引出了ID生成的三大核心需求：&lt;/p>
&lt;ul>
&lt;li>全局唯一(unique)&lt;/li>
&lt;li>按照时间粗略有序(sortable by time)&lt;/li>
&lt;li>尽可能短&lt;/li>
&lt;/ul>
&lt;p>下面介绍一些常用的生成ID的方法。&lt;/p>
&lt;h3 id="uuid">UUID&lt;/h3>
&lt;p>用过MongoDB的人会知道，MongoDB会自动给每一条数据赋予一个唯一的&lt;a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank" rel="noopener">ObjectId&lt;/a>,保证不会重复，这是怎么做到的呢？实际上它用的是一种UUID算法，生成的ObjectId占12个字节，由以下几个部分组成，&lt;/p>
&lt;ul>
&lt;li>4个字节表示的Unix timestamp,&lt;/li>
&lt;li>3个字节表示的机器的ID&lt;/li>
&lt;li>2个字节表示的进程ID&lt;/li>
&lt;li>3个字节表示的计数器&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">UUID&lt;/a>是一类算法的统称，具体有不同的实现。UUID的有点是每台机器可以独立产生ID，理论上保证不会重复，所以天然是分布式的，缺点是生成的ID太长，不仅占用内存，而且索引查询效率低。&lt;/p>
&lt;h3 id="多台mysql服务器">多台MySQL服务器&lt;/h3>
&lt;p>既然MySQL可以产生自增ID，那么用多台MySQL服务器，能否组成一个高性能的分布式发号器呢？ 显然可以。&lt;/p>
&lt;p>假设用8台MySQL服务器协同工作，第一台MySQL初始值是1，每次自增8，第二台MySQL初始值是2，每次自增8，依次类推。前面用一个 round-robin load balancer 挡着，每来一个请求，由 round-robin balancer 随机地将请求发给8台MySQL中的任意一个，然后返回一个ID。&lt;/p>
&lt;p>&lt;a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Flickr就是这么做的&lt;/a>，仅仅使用了两台MySQL服务器。可见这个方法虽然简单无脑，但是性能足够好。不过要注意，在MySQL中，不需要把所有ID都存下来，每台机器只需要存一个MAX_ID就可以了。这需要用到MySQL的一个&lt;a href="http://dev.mysql.com/doc/refman/5.0/en/replace.html" target="_blank" rel="noopener">REPLACE INTO&lt;/a>特性。&lt;/p>
&lt;p>这个方法跟单台数据库比，缺点是&lt;strong>ID是不是严格递增的&lt;/strong>，只是粗略递增的。不过这个问题不大，我们的目标是粗略有序，不需要严格递增。&lt;/p>
&lt;h3 id="twitter-snowflake">Twitter Snowflake&lt;/h3>
&lt;p>比如 Twitter 有个成熟的开源项目，就是专门生成ID的，&lt;a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Twitter Snowflake&lt;/a> 。Snowflake的核心算法如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://121.40.136.3/wp-content/uploads/2015/04/snowflake-64bit.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最高位不用，永远为0，其余三组bit占位均可浮动，看具体的业务需求而定。默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。&lt;/p>
&lt;p>&lt;a href="https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c" target="_blank" rel="noopener">Instagram用了类似的方案&lt;/a>，41位表示时间戳，13位表示shard Id(一个shard Id对应一台PostgreSQL机器),最低10位表示自增ID，怎么样，跟Snowflake的设计非常类似吧。这个方案用一个PostgreSQL集群代替了Twitter Snowflake 集群，优点是利用了现成的PostgreSQL，容易懂，维护方便。&lt;/p>
&lt;p>有的面试官会问，如何让ID可以粗略的按照时间排序？上面的这种格式的ID，含有时间戳，且在高位，恰好满足要求。如果面试官又问，如何保证ID严格有序呢？在分布式这个场景下，是做不到的，要想高性能，只能做到粗略有序，无法保证严格有序。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c" target="_blank" rel="noopener">Sharding &amp;amp; IDs at Instagram&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Twitter Snowflake&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=403837240&amp;amp;idx=1&amp;amp;sn=ae9f2bf0cc5b0f68f9a2213485313127&amp;amp;scene=21" target="_blank" rel="noopener">细聊分布式ID生成方法 - 沈剑&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://calvin1978.blogcn.com/articles/uuid.html" target="_blank" rel="noopener">服务化框架－分布式Unique ID的生成方法一览 - 江南白衣&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&amp;amp;mid=2247489561&amp;amp;idx=1&amp;amp;sn=7396f373af4efa62ba4dbecc6d7f83b3&amp;amp;source=41" target="_blank" rel="noopener">生成全局唯一ID的3个思路，来自一个资深架构师的总结&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>filesystem-cache</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/filesystem-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/filesystem-cache/</guid><description>&lt;p>如何设计一个文件系统缓存？&lt;/p>
&lt;p>在 Linux 操作系统中，当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从磁盘读入到这些内存中，然后再将数据传给应用程序；当需要往文件中写数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。文件 Cache 管理指的就是对这些由操作系统分配，并用来存储文件数据的内存的管理。&lt;/p>
&lt;h2 id="短网址的长度">短网址的长度&lt;/h2>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-cache/" target="_blank" rel="noopener">Linux 内核的文件 Cache 管理机制介绍-IBM&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Twitter Snowflake&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/29270034" target="_blank" rel="noopener">短 URL 系统是怎么设计的？&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>hashmap</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/hashmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/hashmap/</guid><description>&lt;p>请设计一个线程安全的HashMap。&lt;/p>
&lt;p>先回顾一下普通的哈希表(HashMap)是怎么写出来的，再讨论如何做到线程安全。HashMap的核心在于如何解决哈希冲突，主流思路有两种，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>开地址法(Open addressing). 即所有元素在一个一维数组里，遇到冲突则按照一定规则向后跳，假设元素x原本在位置&lt;code>hash(x)%m&lt;/code>（m表示数组长度），那么第i次冲突时位置变为&lt;code>Hi = [hash(x) + di] % m&lt;/code>，其中&lt;code>di&lt;/code>表示第i次冲突时人为加上去的偏移量。偏移量&lt;code>di&lt;/code>一般有如下3种计算方法，&lt;/p>
&lt;ol>
&lt;li>
&lt;p>线性探测法(Linear Probing)。非常简单，发现位子已经被占了，则向后移动1位，即$$d_i = i$$, i=1,2,3,&amp;hellip;&lt;/p>
&lt;p>该算法最大的优点在于计算速度快，对CPU高速缓存友好；其缺点也非常明显，假设3个元素x1，x2，x3的哈希值都相同，记为p, x1先来，查看位置p，是空，则x1被映射到位置p，x2后到达，查看位置p，发生第一次冲突，向后探测一下，即p+1，该位置为空，于是x2映射到p+1, 同理，计算x3的位置需要探测位置p, p+1, p+2，也就是说对于发生冲突的所有元素，在探测过程中会扎堆，导致效率低下，这种现象被称为clustering。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>二次探测法(Quadratic Probing)。$$d_i=ai^2+bi+c$$, 其中a,b,c为系数，$$d_i$$是i的二次函数，所以称为二次探测法。该算法的性能介于线性探测和双哈希之间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>双哈希法(Double Hashing)。偏移量di由另一个哈希函数计算而来，设为&lt;code>hash2(x)&lt;/code>，则&lt;code>di=(hash2(x) % (m-1) + 1) * i&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>拉链法(Chaining)。开一个定长数组，每个格子指向一个桶(Bucket, 可以用单链表或双向链表表示)，对每个元素计算出哈希并取模，找到对应的桶，并插入该桶。发生冲突的元素会处于同一个桶中。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>JDK7和JDK8里&lt;code>java.util.HashMap&lt;/code>采取了拉链法。&lt;/p>
&lt;p>如何将基于拉链法的HashMap改造为线程安全的呢？有以下几个思路，&lt;/p>
&lt;ul>
&lt;li>将所有public方法都加上synchronized. 相当于设置了一把全局锁，所有操作都需要先获取锁，&lt;code>java.util.HashTable&lt;/code>就是这么做的，性能很低&lt;/li>
&lt;li>由于每个桶在逻辑上是相互独立的，将每个桶都加一把锁，如果两个线程各自访问不同的桶，就不需要争抢同一把锁了。这个方案的并发性比单个全局锁的性能要好，不过锁的个数太多，也有很大的开销。&lt;/li>
&lt;li>锁分离(Lock Stripping)技术。第2个方法把锁的压力分散到了多个桶，理论上是可行的的，但是假设有1万个桶，就要新建1万个&lt;code>ReentrantLock&lt;/code>实例，开销很大。可以将所有的桶均匀的划分为16个部分，每一部分成为一个段(Segment)，每个段上有一把锁，这样锁的数量就降低到了16个。JDK 7里的&lt;code>java.util.concurrent.ConcurrentHashMap&lt;/code>就是这个思路。&lt;/li>
&lt;li>在JDK8里，ConcurrentHashMap的实现又有了很大变化，它在锁分离的基础上，大量利用了了CAS指令。并且底层存储有一个小优化，当链表长度太长（默认超过8）时，链表就转换为红黑树。链表太长时，增删查改的效率比较低，改为红黑树可以提高性能。JDK8里的ConcurrentHashMap有6000多行代码，JDK7才1500多行。&lt;/li>
&lt;/ul>
&lt;h3 id="方案1-jdk7版本锁分离">方案1: JDK7版本，锁分离&lt;/h3>
&lt;p>TODO&lt;/p>
&lt;h3 id="方案2-jdk8版本锁分离cas红黑树">方案2: JDK8版本，锁分离+CAS+红黑树&lt;/h3>
&lt;p>TODO&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/concurrent/ConcurrentHashMap.java" target="_blank" rel="noopener">ConcurrentHashMap.java - JDK8&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/tip/src/share/classes/java/util/concurrent/ConcurrentHashMap.java" target="_blank" rel="noopener">ConcurrentHashMap.java - JDK7&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap - 美团点评技术团队&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cnblogs.com/leesf456/p/5242233.html" target="_blank" rel="noopener">JDK1.8源码分析之HashMap（一） - 博客园&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cnblogs.com/yydcdut/p/3959815.html" target="_blank" rel="noopener">ConcurrentHashMap - 博客园&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cnblogs.com/huaizuo/p/5413069.html" target="_blank" rel="noopener">探索jdk8之ConcurrentHashMap 的实现机制 - 博客园&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://blog.csdn.net/u010412719/article/details/52145145" target="_blank" rel="noopener">《Java源码分析》：ConcurrentHashMap JDK1.8 - CSDN&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bentang.me/tech/2016/12/01/jdk8-concurrenthashmap-1/" target="_blank" rel="noopener">ConcurrentHashMap源码解读(put/transfer/get)-jdk8&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://blog.csdn.net/u010723709/article/details/48007881" target="_blank" rel="noopener">ConcurrentHashMap源码分析（JDK8版本）&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://note.youdao.com/share/?id=dde7a10b98aee57676408bc475ab0680&amp;amp;type=note/" target="_blank" rel="noopener">ConcurrentHashMap源码分析&amp;ndash;Java8&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/ConcurrentHashMap" target="_blank" rel="noopener">聊聊并发（四）——深入分析ConcurrentHashMap - InfoQ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制 - IBM&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/BingLau7/blog/issues/14" target="_blank" rel="noopener">ConcurrentHashMap源码解析 - Github&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/33515481/answer/105348019" target="_blank" rel="noopener">并发与并行的区别？ - 知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="noopener">深入理解Java内存模型（一） - 基础&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/java-memory-model-2" target="_blank" rel="noopener">深入理解Java内存模型（二） - 重排序&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/java-memory-model-3" target="_blank" rel="noopener">深入理解Java内存模型（三） - 顺序一致性&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/java-memory-model-4" target="_blank" rel="noopener">深入理解Java内存模型（四） - volatile&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/java-memory-model-5" target="_blank" rel="noopener">深入理解Java内存模型（五） - 锁&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/java-memory-model-6" target="_blank" rel="noopener">深入理解Java内存模型（六） - final&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.infoq.com/cn/articles/java-memory-model-7" target="_blank" rel="noopener">深入理解Java内存模型（七） - 总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/348414580" target="_blank" rel="noopener">一种简单又高效的True Lock-free HashMap c++实现&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>key-value-store</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/key-value-store/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/key-value-store/</guid><description>&lt;p>请设计一个 Key-Value 存储引擎(Design a key-value store)。&lt;/p>
&lt;p>这是一道频繁出现的题目，个人认为也是一道很好的题目，这题纵深非常深，内行的人可以讲的非常深。&lt;/p>
&lt;p>首先讲两个术语，&lt;strong>数据库&lt;/strong>和&lt;strong>存储引擎&lt;/strong>。数据库往往是一个比较丰富完整的系统, 提供了 SQL 查询语言，事务和水平扩展等支持。然而存储引擎则是小而精, 纯粹专注于单机的读/写/存储。一般来说, 数据库底层往往会使用某种存储引擎。&lt;/p>
&lt;p>目前开源的 KV 存储引擎中，RocksDB 是流行的一个，MongoDB 和 MySQL 底层可以切换成 RocksDB， TiDB 底层直接使用了 RocksDB。大多数分布式数据库的底层不约而同的都选择了 RocksDB。&lt;/p>
&lt;p>RocksDB 最初是从 LevelDB 进化而来的，我们先从简单一点的 LevelDB 入手，借鉴它的设计思路。&lt;/p>
&lt;h2 id="leveldb-整体结构">LevelDB 整体结构&lt;/h2>
&lt;p>有一个反直觉的事情是，&lt;strong>内存随机写甚至比硬盘的顺序读还要慢&lt;/strong>，磁盘随机写就更慢了，说明我们要避免随机写，最好设计成顺序写。因此好的 KV 存储引擎，都在尽量避免更新操作，把更新和删除操作转化为顺序写操作。LevelDB 采用了一种 SSTable 的数据结构来达到这个目的。&lt;/p>
&lt;p>SSTable(Sorted String Table)就是一组按照 key 排序好的 key-value 对, key 和 value 都是字节数组。SSTable 既可以在内存中，也可以在硬盘中。SSTable 底层使用 LSM Tree(Log-Structured Merge Tree)来存放有序的 key-value 对。&lt;/p>
&lt;p>LevelDB 整体由如下几个组成部分，&lt;/p>
&lt;ol>
&lt;li>MemTable。即内存中的 SSTable，新数据会写入到这里，然后批量写入磁盘，以此提高写的吞吐量。&lt;/li>
&lt;li>Log 文件。写 MemTable 前会写 Log 文件，即用 WAL(Write Ahead Log)方式记录日志，如果机器突然掉电，内存中的 MemTable 丢失了，还可以通过日志恢复数据。WAL 日志是很多传统数据库例如 MySQL 采用的技术，详细解释可以参考&lt;a href="https://zhuanlan.zhihu.com/p/24900322" target="_blank" rel="noopener">数据库如何用 WAL 保证事务一致性？ - 知乎专栏&lt;/a>。&lt;/li>
&lt;li>Immutable MemTable。内存中的 MemTable 达到指定的大小后，将不再接收新数据，同时会有新的 MemTable 产生，新数据写入到这个新的 MemTable 里，Immutable MemTable 随后会写入硬盘，变成一个 SST 文件。&lt;/li>
&lt;li>&lt;code>SSTable&lt;/code>文件。即硬盘上的 SSTable，文件尾部追加了一块索引，记录 key-&amp;gt;offset，提高随机读的效率。SST 文件为 Level 0 到 Level N 多层，每一层包含多个 SST 文件；单个 SST 文件容量随层次增加成倍增长；Level0 的 SST 文件由 Immutable MemTable 直接 Dump 产生，其他 Level 的 SST 文件由其上一层的文件和本层文件归并产生。&lt;/li>
&lt;li>Manifest 文件。Manifest 文件中记录 SST 文件在不同 Level 的分布，单个 SST 文件的最大最小 key，以及其他一些 LevelDB 需要的元信息。&lt;/li>
&lt;li>Current 文件。从上面的介绍可以看出，LevelDB 启动时的首要任务就是找到当前的 Manifest，而 Manifest 可能有多个。Current 文件简单的记录了当前 Manifest 的文件名。&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/Andrew-Ng-DeepLearning-AI/leveldb/architecture.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>LevelDB 的一些核心逻辑如下，&lt;/p>
&lt;ol>
&lt;li>首先 SST 文件尾部的索引要放在内存中，这样读索引就不需要一次磁盘 IO 了&lt;/li>
&lt;li>所有读要先查看&lt;code>MemTable&lt;/code>，如果没有再查看内存中的索引&lt;/li>
&lt;li>所有写操作只能写到&lt;code>MemTable&lt;/code>, 因为 SST 文件不可修改&lt;/li>
&lt;li>定期把&lt;code>Immutable MemTable&lt;/code>写入硬盘，成为&lt;code>SSTable&lt;/code>文件，同时新建一个&lt;code>MemTable&lt;/code>会继续接收新来的写操作&lt;/li>
&lt;li>定期对&lt;code>SSTable&lt;/code>文件进行合并&lt;/li>
&lt;li>由于硬盘上的&lt;code>SSTable&lt;/code>文件是不可修改的，那怎么更新和删除数据呢？对于更新操作，追加一个新的 key-value 对到文件尾部，由于读&lt;code>SSTable&lt;/code>文件是从前向后读的，所以新数据会最先被读到；对于删除操作，追加“墓碑”值(tombstone)，表示删除该 key，在定期合并&lt;code>SSTable&lt;/code>文件时丢弃这些 key, 即可删除这些 key。&lt;/li>
&lt;/ol>
&lt;h2 id="manifest-文件">Manifest 文件&lt;/h2>
&lt;p>Manifest 文件记录各个 SSTable 各个文件的管理信息，比如该 SST 文件处于哪个 Level，文件名称叫啥，最小 key 和最大 key 各自是多少，如下图所示，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/Andrew-Ng-DeepLearning-AI/leveldb/manifest.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="log-文件">Log 文件&lt;/h2>
&lt;p>Log 文件主要作用是系统发生故障时，能够保证不会丢失数据。因为在数据写入内存中的 MemTable 之前，会先写入 Log 文件，这样即使系统发生故障，MemTable 中的数据没有来得及 Dump 到磁盘，LevelDB 也可以根据 log 文件恢复内存中的 MemTable，不会造成系统丢失数据。这个方式就叫做 WAL(Write Ahead Log)，很多传统数据库例如 MySQL 也使用了 WAL 技术来记录日志。&lt;/p>
&lt;p>每个 Log 文件由多个 block 组成，每个 block 大小为 32K，读取和写入以 block 为基本单位。下图所示的 Log 文件包含 3 个 Block，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/Andrew-Ng-DeepLearning-AI/leveldb/log.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="sstable">SSTable&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/Andrew-Ng-DeepLearning-AI/leveldb/sstable.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="memtable">MemTable&lt;/h2>
&lt;p>MemTable 是内存中的数据结构，存储的内容跟硬盘上的 SSTable 一样，只是格式不一样。Immutable MemTable 的内存结构和 Memtable 是完全一样的，区别仅仅在于它是只读的，而 MemTable 则是允许写入和读取的。当 MemTable 写入的数据占用内存到达指定大小，则自动转换为 Immutable Memtable，等待 Dump 到磁盘中，系统会自动生成一个新的 MemTable 供写操作写入新数据，理解了 MemTable，那么 Immutable MemTable 自然不在话下。&lt;/p>
&lt;p>MemTable 里的数据是按照 key 有序的，因此当插入新数据时，需要把这个 key-value 对插入到合适的位置上，以保持 key 有序性。MemTable 底层的核心数据结构是一个跳表(Skip List)。跳表是红黑树的一种替代数据结构，具有更高的写入速度，而且实现起来更加简单，请参考&lt;a href="appendix/skip-list.md">跳表(Skip List)&lt;/a>。&lt;/p>
&lt;p>前面我们介绍了 LevelDB 的一些内存数据结构和文件，这里开始介绍一些动态操作，例如读取，写入，更新和删除数据，分层合并，错误恢复等操作。&lt;/p>
&lt;h2 id="添加更新和删除数据">添加、更新和删除数据&lt;/h2>
&lt;p>LevelDB 写入新数据时，具体分为两个步骤：&lt;/p>
&lt;ol>
&lt;li>将这个操作顺序追加到 log 文件末尾。尽管这是一个磁盘操作，但是文件的顺序写入效率还是跟高的，所以不会降低写入的速度&lt;/li>
&lt;li>如果 log 文件写入成功，那么将这条 key-value 记录插入到内存中 MemTable。&lt;/li>
&lt;/ol>
&lt;p>LevelDB 更新一条记录时，并不会本地修改 SST 文件，而是会作为一条新数据写入 MemTable，随后会写入 SST 文件，在 SST 文件合并过程中，新数据会处于文件尾部，而读取操作是从文件尾部倒着开始读的，所以新值一定会最先被读到。&lt;/p>
&lt;p>LevelDB 删除一条记录时，也不会修改 SST 文件，而是用一个特殊值(墓碑值，tombstone)作为 value，将这个 key-value 对追加到 SST 文件尾部，在 SST 文件合并过程中，这种值的 key 都会被忽略掉。&lt;/p>
&lt;p>核心思想就是把写操作转换为顺序追加，从而提高了写的效率。&lt;/p>
&lt;h2 id="读取数据">读取数据&lt;/h2>
&lt;p>读操作使用了如下几个手段进行优化：&lt;/p>
&lt;ul>
&lt;li>MemTable + SkipList&lt;/li>
&lt;li>Binary Search(通过 manifest 文件)&lt;/li>
&lt;li>页缓存&lt;/li>
&lt;li>bloom filter&lt;/li>
&lt;li>周期性分层合并&lt;/li>
&lt;/ul>
&lt;h2 id="分层合并leveled-compaction">分层合并(Leveled Compaction)&lt;/h2>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/" target="_blank" rel="noopener">SSTable and Log Structured Storage: LevelDB - igvita.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html" target="_blank" rel="noopener">数据分析与处理之二（Leveldb 实现原理） - Haippy - 博客园&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.open-open.com/lib/view/open1424916275249.html" target="_blank" rel="noopener">Log Structured Merge Trees(LSM) 原理 - OPEN 开发经验库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ggaaooppeenngg.github.io/zh-CN/2017/03/31/%E4%BB%8E%E6%9C%B4%E7%B4%A0%E8%A7%A3%E9%87%8A%E5%87%BA%E5%8F%91%E8%A7%A3%E9%87%8Aleveldb%E7%9A%84%E8%AE%BE%E8%AE%A1/index.html" target="_blank" rel="noopener">从朴素解释出发解释 leveldb 的设计 | ggaaooppeenngg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/19887265" target="_blank" rel="noopener">LSM 算法的原理是什么？ - 知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/24900322" target="_blank" rel="noopener">数据库如何用 WAL 保证事务一致性？ - 知乎专栏&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://chuansong.me/n/1509342851514" target="_blank" rel="noopener">LevelDB 系列概述 - 360 基础架构组&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/abbshr/abbshr.github.io/issues/58" target="_blank" rel="noopener">存储引擎技术架构与内幕 (leveldb-1) - GitHub&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://bean-li.github.io/leveldb-sstable-bloom-filter/" target="_blank" rel="noopener">leveldb 中的 SSTable (3)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>load-balancer</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/load-balancer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/load-balancer/</guid><description>&lt;p>请设计一个load balancer。&lt;/p></description></item><item><title>method</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/method/</guid><description>&lt;h2 id="系统设计考察的是什么">系统设计考察的是什么？&lt;/h2>
&lt;p>系统设计这个面试环节，首先当然是考察候选人的对**系统(System)&lt;strong>底层的了解，然后考察的是候选人的&lt;/strong>架构(Architect)&lt;strong>能力，在各种工具和方案中组合出最合适的。最后，大部分系统设计题是开放型的题目，这时候&lt;/strong>沟通(Communication)**很重要，要多问面试官，理解题意，给出一个能自圆其说的结论。&lt;/p>
&lt;h2 id="设计容量">设计容量&lt;/h2>
&lt;p>搭建一个服务，跟建造一个房子一样，是有开发成本的。不同容量的系统，需要的人月数完全不一样，成本差别巨大。拿到一个题目，首先要问面试者，希望抗住多少流量，多大的QPS或者多少在线用户等。&lt;/p>
&lt;p>这个题目我一直在考虑要不要写，因为有一天也许我们彼此会坐在一方小桌的两端，聊聊系统设计，而我这么做有泄题兜底之嫌。不过，考虑到不是所有的读者都会来 TubiTV 这座小庙面试，而这个方面的确是很多朋友的弱项，我就略说几句。&lt;/p>
&lt;p>请听题：一个使用 rail（或者 django，或者 express，&amp;hellip;）和 MySQL 做的 API 系统，最近流量从 6,000 RPM 激增至 20,000 RPM，整个系统的压力骤升，现在需要在应用层设计一套缓存方案来降低整个系统的负荷。要求是：缓存方案不能在 web 层（包括 proxy）做，也不能使用 framework 自带的，或者第三方的缓存模块。&lt;/p>
&lt;p>大部分的面试者一看，这问题简单啊，使用 redis（或者 memcached），加在应用服务器和数据库服务器之间，读取数据的时候如果没有命中缓存，则读取数据库并写入缓存，下次再读相同的数据时就能命中缓存，大大减轻数据库的压力了。&lt;/p>
&lt;p>这回答对么？不好说。也许对，也许不对。但你要这么快抢答的话基本上就会被面试官毙了。&lt;/p>
&lt;p>系统设计的面试重在讨论和交流，厘清一切限制条件，然后在这些限制条件下面找到一个比较合理的解决方案。它不是编程题或者算法题，弄清楚题目的要求就可以写开始答案的。&lt;/p>
&lt;p>好的面试者应该主动发问，来尽量找全限制条件，而不是直接假设。拿上述回答来说，面试者还没开始认真分析问题所在，就想当然认为压力在数据库一侧（是的，流量激增之后 90% 的可能性都是数据库先扛不住压力，但这是假设，不能化作前提），从可能错误的前提出发，必然会得出一个很可能错误的解决方案。&lt;/p>
&lt;p>所以比较对路的思考过程是：&lt;/p>
&lt;p>现有系统的架构是什么样子？&lt;/p>
&lt;p>作为一个已有系统的优化项目，不了解现有系统的架构，历史（演变的过程和演变的原因，当然，在面试中这个可以省去）而立刻上手设计都是在耍流氓。&lt;/p>
&lt;p>web 服务器，应用服务器，数据库服务器等之间的关系以及数量？&lt;/p>
&lt;p>现在有没有使用类似于 redis / memcached 的缓存服务器？如果有，它们用来处理什么任务？（如果有人问道这个，会有大大的加分）&lt;/p>
&lt;p>目前哪个部分在系统中压力最大？&lt;/p>
&lt;p>这个问题非常重要，你得需要先知道问题在哪再考虑优化。如果问题出在应用服务器，那么，可能需要做页面级的缓存；如果问题出在数据库服务器上，可以做数据级或者页面级的缓存。&lt;/p>
&lt;p>我们希望达到一个什么样的 capacity？&lt;/p>
&lt;p>很多有多年一线工作经验的面试者在这样一个系统设计中竟然不去考虑究竟需要一个什么样的 capacity，就进入到具体的解决方案，这样是不妥的。capacity 因问题而异，在这例子中，起码要考虑 1) 缓存系统每秒的处理能力 2) 缓存系统的容量。对于一个 20k PRM 的请求数量，缓存系统应该能承受 50k，100k，甚至 200k PRM 的请求。至于容量，应该考虑假设所有不同的请求都被缓存（worst case），需要多大的容量，在限定的软硬件条件下，是否能达到这个容量，达不到的话，什么样的上限比较合理。&lt;/p>
&lt;p>有了这样一个目标后，你还需要对你要使用的工具有个谱。有一个面试者说用 redis 做缓存，因为 redis 很快。「很快」是个很虚的概念，我于是问这个面试者你觉得 redis 对于 1k 大小的value，在 commodity hardware 上做 GET 操作每秒钟的 QPS 是多少？对此，面试者一点概念也没有，我让他猜，他竟然给了个 3-5k QPS 的估值。我自己印象中 redis benchmark GET 操作大概是 100k 这个数量级，当然，每次返回 1k 大小的数据会拖累这个结果，但绝不会差出来两个数量级。&lt;/p>
&lt;p>有了设计容量的概念后，我们需要知道要缓存数据的大小，这其中，median size，average size，max size 都需要了解一下，起码知道是什么量级。返回 2k 大小的数据和 200k 大小的数据的处理方式可能是完全不同的，假设你的缓存系统的容量是 1M，2k 数据大小的缓存直接占用的内存是 2G，而 200k 则是 200G，后者显然不能使用内存来做缓存，只能用文件系统缓存。&lt;/p>
&lt;p>讲到文件系统，多说两句。用文件系统做缓存则需要注意 unix 的目录实际上是一个记录文件名和 inode 对应关系的 map（你可以 ls -ai1 . 查看）。单个目录下的文件越多，这个 map 越大，需要的读取次数就越多（一般系统调用会每次读 32k 或者类似的量级），所以当一个目录下的文件特别多时，访问效率会急剧下降。这是为什么常见的文件缓存系统都是用两级甚至多级目录，1M 个文件，一级目录使用两个字母或数字，可以有 (26 + 10) 平方个二级目录，也就是 1296 个目录，每个目录名两个字节，加上 inode 和其他一些消耗， 10-20 字节完全够用，一次读取就能获得所有二级目录，而二级目录平均是 772 个文件，一次读取也能完成，总共两次读取，找到缓存文件，而如果把 1M 个文件放在一个目录下，如果每个记录 32 字节，需要 1000 次读取。这种分级缓存的思路在很多系统中都能见到，比如 TLB（不过多级 TLB 主要是为了节省内存）。&lt;/p>
&lt;p>设计是否有优化的地方？&lt;/p>
&lt;p>如今，内存，硬盘已经非常便宜，很多时候我们做系统设计，已经不需要一个比特或者一个字节地去扣细节，但这并不意味着更好的，更省内存，更快运行的方案就没有价值。我曾在一个面试中和面试者讨论一个系统设计的优化，那个面试者对我「逼」着他优化算法很不理解，他认为 computation 这么便宜，钱不是问题，多加几台机器并行运算就可以了。这是一种错误的做事态度。&lt;/p>
&lt;p>永远不要忘了设计应该是面向未来的，如果通过更换更好的算法，能节省数十倍的内存（bitmap vs hashmap），或者数十倍的运算（bloom filter pre-filter vs raw computation），那么你省下的不仅仅是当下的资源（或者金钱），还有未来的时间 —— 因为，当你的应用有10倍的流量时，你还能够应对自如。&lt;/p>
&lt;p>此外，优化可能会从量变转化为质变。一个 analytics 应用如果每五分钟才能完成一次分析，一小时仅能进行 12 次分析；如果将其优化成 30 秒完成，一个小时就可能完成 120 次，用户可以更快地掌握趋势。&lt;/p>
&lt;p>一个认为资源不是问题，钱不是问题的设计者，只能是一个平庸的设计者。&lt;/p>
&lt;p>每个认真的程序员应该这样看待自己：In me the tiger sniffs the rose.&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/20578447" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20578447&lt;/a>&lt;/p></description></item><item><title>news-feed</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/news-feed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/news-feed/</guid><description>&lt;p>请设计一个信息流(news feed)。例如Facebook用户首页的信息流，微博用户的信息流，等等。&lt;/p></description></item><item><title>pagerank</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/pagerank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/pagerank/</guid><description>&lt;p>请实现PageRank算法(Implement PageRank)。&lt;/p>
&lt;p>注意要分布式。&lt;/p></description></item><item><title>search-engine</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/search-engine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/search-engine/</guid><description>&lt;p>请实现一个搜索引擎(Design a search engine)。&lt;/p>
&lt;p>下载系统， 索引系统，分析系统，查询系统。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.glassdoor.com/Interview/-How-to-design-a-search-engine-If-each-document-contains-a-set-of-keywords-and-is-associated-with-a-numeric-attribute-ho-QTN_9026.htm" target="_blank" rel="noopener">Google Interview Question: How to design a search engin&amp;hellip; | Glassdoor&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>SUMMARY</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/summary/</guid><description>&lt;h1 id="内容目录">内容目录&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="distributed-id-generator.md">分布式ID生成器&lt;/a>&lt;/li>
&lt;li>&lt;a href="tinyurl.md">短网址系统(TinyURL)&lt;/a>&lt;/li>
&lt;li>&lt;a href="news-feed.md">信息流(News Feed)&lt;/a>&lt;/li>
&lt;li>&lt;a href="task-scheduler.md">定时任务调度器&lt;/a>&lt;/li>
&lt;li>&lt;a href="api-rate-limiting.md">API限速&lt;/a>&lt;/li>
&lt;li>&lt;a href="hashmap.md">线程安全的HashMap&lt;/a>&lt;/li>
&lt;li>&lt;a href="top-k-frequent-ip-in-one-hour.md">最近一个小时内访问频率最高的10个IP&lt;/a>&lt;/li>
&lt;li>&lt;a href="load-balancer.md">负载均衡&lt;/a>&lt;/li>
&lt;li>&lt;a href="key-value-store.md">Key-Value存储引擎&lt;/a>&lt;/li>
&lt;li>&lt;a href="crawler.md">网络爬虫&lt;/a>&lt;/li>
&lt;li>&lt;a href="pagerank.md">PageRank&lt;/a>&lt;/li>
&lt;li>&lt;a href="search-engine.md">搜索引擎&lt;/a>&lt;/li>
&lt;li>&lt;a href="bigdata/README.md">大数据&lt;/a>
&lt;ul>
&lt;li>&lt;a href="bigdata/data-stream-sampling.md">数据流采样&lt;/a>&lt;/li>
&lt;li>&lt;a href="bigdata/cardinality-estimation.md">基数估计&lt;/a>&lt;/li>
&lt;li>&lt;a href="bigdata/frequency-estimation.md">频率估计&lt;/a>&lt;/li>
&lt;li>&lt;a href="bigdata/heavy-hitters.md">Top K 频繁项&lt;/a>&lt;/li>
&lt;li>&lt;a href="bigdata/range-query.md">范围查询&lt;/a>&lt;/li>
&lt;li>&lt;a href="bigdata/membership-query.md">成员查询&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>附录
&lt;ul>
&lt;li>&lt;a href="appendix/skip-list.md">跳表(Skip List)&lt;/a>&lt;/li>
&lt;li>&lt;a href="appendix/raft.md">Raft&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>task-scheduler</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/task-scheduler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/task-scheduler/</guid><description>&lt;p>请实现一个定时任务调度器，有很多任务，每个任务都有一个时间戳，任务会在该时间点开始执行。&lt;/p>
&lt;p>定时执行任务是一个很常见的需求，例如Uber打车48小时后自动好评，淘宝购物15天后默认好评，等等。&lt;/p>
&lt;h3 id="方案1-priorityblockingqueue--polling">方案1: PriorityBlockingQueue + Polling&lt;/h3>
&lt;p>我们很快可以想到第一个办法：&lt;/p>
&lt;ul>
&lt;li>用一个&lt;code>java.util.concurrent.PriorityBlockingQueue&lt;/code>来作为优先队列。因为我们需要一个优先队列，又需要线程安全，用&lt;code>PriorityBlockingQueue&lt;/code>再合适不过了。你也可以手工实现一个自己的&lt;code>PriorityBlockingQueue&lt;/code>，用&lt;code>java.util.PriorityQueue&lt;/code> + &lt;code>ReentrantLock&lt;/code>，用一把锁把这个队列保护起来，就是线程安全的啦&lt;/li>
&lt;li>对于生产者，可以用一个&lt;code>while(true)&lt;/code>，造一些随机任务塞进去&lt;/li>
&lt;li>对于消费者，起一个线程，在 &lt;code>while(true)&lt;/code>里每隔几秒检查一下队列，如果有任务，则取出来执行。&lt;/li>
&lt;/ul>
&lt;p>这个方案的确可行，总结起来就是&lt;strong>轮询(polling)&lt;/strong>。轮询通常有个很大的缺点，就是时间间隔不好设置，间隔太长，任务无法及时处理，间隔太短，会很耗CPU。&lt;/p>
&lt;h3 id="方案2-priorityblockingqueue--时间差">方案2: PriorityBlockingQueue + 时间差&lt;/h3>
&lt;p>可以把方案1改进一下，&lt;code>while(true)&lt;/code>里的逻辑变成：&lt;/p>
&lt;ul>
&lt;li>偷看一下堆顶的元素，但并不取出来，如果该任务过期了，则取出来&lt;/li>
&lt;li>如果没过期，则计算一下时间差，然后 sleep()该时间差&lt;/li>
&lt;/ul>
&lt;p>不再是 sleep() 一个固定间隔了，消除了轮询的缺点。&lt;/p>
&lt;p>&lt;strong>稍等！这个方案其实有个致命的缺陷&lt;/strong>，导致它比 &lt;code>PiorityBlockingQueue + Polling&lt;/code> 更加不可用，这个缺点是什么呢？。。。假设当前堆顶的任务在100秒后执行，消费者线程peek()偷看到了后，开始sleep 100秒，这时候一个新的任务插了进来，该任务在10秒后应该执行，但是由于消费者线程要睡眠100秒，这个新任务无法及时处理。&lt;/p>
&lt;h3 id="方案3-delayqueue">方案3: DelayQueue&lt;/h3>
&lt;p>方案2虽然已经不错了，但是还可以优化一下，Java里有一个&lt;a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/concurrent/DelayQueue.java" target="_blank" rel="noopener">DelayQueue&lt;/a>，完全符合题目的要求。DelayQueue 设计得非常巧妙，可以看做是一个特化版的&lt;code>PriorityBlockingQueue&lt;/code>，它把&lt;strong>计算时间差并让消费者等待该时间差&lt;/strong>的功能集成进了队列，消费者不需要关心时间差的事情了，直接在&lt;code>while(true)&lt;/code>里不断&lt;code>take()&lt;/code>就行了。&lt;/p>
&lt;p>DelayQueue的实现原理见下面的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.PriorityQueue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.concurrent.Delayed&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.concurrent.locks.Condition&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.concurrent.locks.ReentrantLock&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import static&lt;/span> &lt;span class="nn">java.util.concurrent.TimeUnit.NANOSECONDS&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DelayQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">E&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Delayed&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">transient&lt;/span> &lt;span class="n">ReentrantLock&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ReentrantLock&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">PriorityQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">PriorityQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Condition&lt;/span> &lt;span class="n">available&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">newCondition&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">Thread&lt;/span> &lt;span class="n">leader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">DelayQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Inserts the specified element into this delay queue.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @param e the element to add
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @return {@code true}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @throws NullPointerException if the specified element is null
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">E&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">final&lt;/span> &lt;span class="n">ReentrantLock&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lock&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lock&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">leader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">signal&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">unlock&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Retrieves and removes the head of this queue, waiting if necessary
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * until an element with an expired delay is available on this queue.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @return the head of this queue
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @throws InterruptedException {@inheritDoc}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">E&lt;/span> &lt;span class="nf">take&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">final&lt;/span> &lt;span class="n">ReentrantLock&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lock&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lockInterruptibly&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="o">(;;)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">E&lt;/span> &lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">await&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getDelay&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">NANOSECONDS&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">delay&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">poll&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// don&amp;#39;t retain ref while waiting
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">leader&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">await&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thisThread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">leader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">thisThread&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">awaitNanos&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">delay&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">leader&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">thisThread&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">leader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">leader&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">signal&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">unlock&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个代码中有几个要点要注意一下。&lt;/p>
&lt;p>&lt;strong>1. put()方法&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">leader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">signal&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果第一个元素等于刚刚插入进去的元素，说明刚才队列是空的。现在队列里有了一个任务，那么就&lt;strong>应该唤醒所有在等待的消费者线程，避免了方案2的缺点&lt;/strong>。将&lt;code>leader&lt;/code>重置为null，这些消费者之间互相竞争，自然有一个会被选为leader。&lt;/p>
&lt;p>&lt;strong>2. 线程leader的作用&lt;/strong>&lt;/p>
&lt;p>&lt;code>leader&lt;/code>这个成员有啥作用？DelayQueue的设计其实是一个Leader/Follower模式，&lt;code>leader&lt;/code>就是指向Leader线程的。该模式可以减少不必要的等待时间，当一个线程是Leader时，它只需要一个时间差；其他Follower线程则无限等待。比如头节点任务还有5秒就要开始了，那么Leader线程会sleep 5秒，不需要傻傻地等待固定时间间隔。&lt;/p>
&lt;p>想象一下有个多个消费者线程用take方法去取任务,内部先加锁,然后每个线程都去peek头节点。如果leader不为空说明已经有线程在取了，让当前消费者无限等待。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">leader&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">await&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果为空说明没有其他消费者去取任务,设置leader为当前消费者，并让改消费者等待指定的时间，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Thread&lt;/span> &lt;span class="n">thisThread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">leader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">thisThread&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">awaitNanos&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">delay&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">leader&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">thisThread&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">leader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下次循环会走如下分支，取到任务结束，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">delay&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">poll&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>3. take()方法中为什么释放first&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// don&amp;#39;t retain ref while waiting
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到 Doug Lea 后面写的注释，那么这行代码有什么用呢？&lt;/p>
&lt;p>如果删除这行代码，会发生什么呢？假设现在有3个消费者线程，&lt;/p>
&lt;ul>
&lt;li>线程A进来获取first,然后进入 else 的 else ,设置了leader为当前线程A，并让A等待一段时间&lt;/li>
&lt;li>线程B进来获取first, 进入else的阻塞操作,然后无限期等待，这时线程B是持有first引用的&lt;/li>
&lt;li>线程A等待指定时间后被唤醒，获取对象成功，出队，这个对象理应被GC回收，但是它还被线程B持有着，GC链可达，所以不能回收这个first&lt;/li>
&lt;li>只要线程B无限期的睡眠，那么这个本该被回收的对象就不能被GC销毁掉，那么就会造成内存泄露&lt;/li>
&lt;/ul>
&lt;h4 id="task对象">Task对象&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.concurrent.Delayed&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.concurrent.TimeUnit&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Task&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Delayed&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// milliseconds
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Task&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">delay&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">startTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">delay&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="nf">getDelay&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TimeUnit&lt;/span> &lt;span class="n">unit&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="n">diff&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">startTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">unit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">convert&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">diff&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Delayed&lt;/span> &lt;span class="n">o&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">)(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">startTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">Task&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">o&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">startTime&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;task &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; at &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JDK中有一个接口&lt;code>java.util.concurrent.Delayed&lt;/code>，可以用于表示具有过期时间的元素，刚好可以拿来表示任务这个概念。&lt;/p>
&lt;h4 id="生产者">生产者&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.Random&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.UUID&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TaskProducer&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Runnable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Random&lt;/span> &lt;span class="n">random&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Random&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">DelayQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Task&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">TaskProducer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">DelayQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Task&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">q&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">delay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nextInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">10000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Task&lt;/span> &lt;span class="n">task&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Task&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">UUID&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">randomUUID&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">delay&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Put &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">task&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">task&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">3000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>生产者很简单，就是一个死循环，不断地产生一些是时间随机的任务。&lt;/p>
&lt;h4 id="消费者">消费者&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TaskConsumer&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Runnable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">DelayQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Task&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">TaskConsumer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">DelayQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Task&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">q&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Task&lt;/span> &lt;span class="n">task&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">take&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Take &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">task&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当 DelayQueue 里没有任务时，&lt;code>TaskConsumer&lt;/code>会无限等待，直到被唤醒，因此它不会消耗CPU。&lt;/p>
&lt;h4 id="定时任务调度器">定时任务调度器&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">TaskScheduler&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">DelayQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Task&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">queue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DelayQueue&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">TaskProducer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="s">&amp;#34;Producer Thread&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">TaskConsumer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="s">&amp;#34;Consumer Thread&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DelayQueue这个方案，每个消费者线程只需要等待所需要的时间差，因此响应速度更快。它内部用了一个优先队列，所以插入和删除的时间复杂度都是$$\log n$$。&lt;/p>
&lt;p>JDK里还有一个&lt;a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/concurrent/ScheduledThreadPoolExecutor.java" target="_blank" rel="noopener">ScheduledThreadPoolExecutor&lt;/a>，原理跟DelayQueue类似，封装的更完善，平时工作中可以用它，不过面试中，还是拿DelayQueue来讲吧，它封装得比较薄，容易讲清楚原理。&lt;/p>
&lt;h3 id="方案4-时间轮hashedwheeltimer">方案4: 时间轮(HashedWheelTimer)&lt;/h3>
&lt;p>时间轮(HashedWheelTimer)其实很简单，就是一个循环队列，如下图所示，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://upload-images.jianshu.io/upload_images/584578-044ce81079679c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>上图是一个长度为8的循环队列，假设该时间轮精度为秒，即每秒走一格，像手表那样，走完一圈就是8秒。每个格子指向一个任务集合，时间轮无限循环，每转到一个格子，就扫描该格子下面的所有任务，把时间到期的任务取出来执行。&lt;/p>
&lt;p>举个例子，假设指针当前正指向格子0，来了一个任务需要4秒后执行，那么这个任务就会放在格子4下面，如果来了一个任务需要20秒后执行怎么？由于这个循环队列转一圈只需要8秒，这个任务需要多转2圈，所以这个任务的位置虽然依旧在格子4(20%8+0=4)下面，不过需要多转2圈后才执行。因此每个任务需要有一个字段记录需圈数，每转一圈就减1，减到0则立刻取出来执行。&lt;/p>
&lt;p>怎么实现时间轮呢？Netty中已经有了一个时间轮的实现, &lt;a href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java" target="_blank" rel="noopener">HashedWheelTimer.java&lt;/a>，可以参考它的源代码。&lt;/p>
&lt;p>时间轮的优点是性能高，插入和删除的时间复杂度都是O(1)。Linux 内核中的定时器采用的就是这个方案。&lt;/p>
&lt;p>&lt;strong>Follow up: 如何设计一个分布式的定时任务调度器呢？&lt;/strong>
答: Redis ZSet, RabbitMQ等&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/concurrent/DelayQueue.java" target="_blank" rel="noopener">java.util.concurrent.DelayQueue&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java" target="_blank" rel="noopener">HashedWheelTimer.java - Github&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.jianshu.com/p/e0bcc9eae0ae" target="_blank" rel="noopener">delayQueue原理理解之源码解析 - 简书&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.jianshu.com/p/7beebbc61229" target="_blank" rel="noopener">细说延时任务的处理 - 简书&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cnblogs.com/haoxinyue/p/6663720.html" target="_blank" rel="noopener">延迟任务的实现总结 - nick hao - 博客园&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://novoland.github.io/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html" target="_blank" rel="noopener">定时器（Timer）的实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://examples.javacodegeeks.com/core-java/util/concurrent/delayqueue/java-util-concurrent-delayqueue-example/" target="_blank" rel="noopener">java.util.concurrent.DelayQueue Example&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cnblogs.com/zemliu/p/3928285.html" target="_blank" rel="noopener">HashedWheelTimer 原理 - ZimZz - 博客园&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://blog.csdn.net/yq76034150/article/details/6783398" target="_blank" rel="noopener">Hash算法系列-具体算法（HashedWheelTimer） - CSDN&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/23235063" target="_blank" rel="noopener">java Disruptor工作原理，谁能用一个比喻形容下? - 知乎&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://chuansong.me/n/1673795846413" target="_blank" rel="noopener">1分钟实现“延迟消息”功能 - 58沈剑&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-cn-timers/" target="_blank" rel="noopener">Linux 下定时器的实现方式分析 - IBM&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://chuansong.me/n/1591963946624" target="_blank" rel="noopener">1分钟了解Leader-Follower线程模型 - 58沈剑&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>tinyurl</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/tinyurl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/tinyurl/</guid><description>&lt;p>如何设计一个短网址服务(TinyURL)？&lt;/p>
&lt;h3 id="使用场景scenario">使用场景(Scenario)&lt;/h3>
&lt;p>微博和Twitter都有140字数的限制，如果分享一个长网址，很容易就超出限制，发布出去。短网址服务可以把一个长网址变成短网址，方便在社交网络上传播。&lt;/p>
&lt;h3 id="需求needs">需求(Needs)&lt;/h3>
&lt;p>很显然，要尽可能的&lt;strong>短&lt;/strong>。长度设计为多少才合适呢？&lt;/p>
&lt;h3 id="短网址的长度">短网址的长度&lt;/h3>
&lt;p>当前互联网上的网页总数大概是 45亿(参考 &lt;a href="http://www.worldwidewebsize.com" target="_blank" rel="noopener">http://www.worldwidewebsize.com&lt;/a>)，45亿超过了 $$2^{32}=4294967296$$，但远远小于64位整数的上限值，那么用一个64位整数足够了。&lt;/p>
&lt;p>微博的短网址服务用的是长度为7的字符串，这个字符串可以看做是62进制的数，那么最大能表示$${62}^7=3521614606208$$个网址，远远大于45亿。所以&lt;strong>长度为7就足够了&lt;/strong>。&lt;/p>
&lt;p>一个64位整数如何转化为字符串呢？，假设我们只是用大小写字母加数字，那么可以看做是62进制数，$$log_{62} {(2^{64}-1)}=10.7$$，即字符串最长11就足够了。&lt;/p>
&lt;p>实际生产中，还可以再短一点，比如新浪微博采用的长度就是7，因为 $$62^7=3521614606208$$，这个量级远远超过互联网上的URL总数了，绝对够用了。&lt;/p>
&lt;p>现代的web服务器（例如Apache, Nginx）大部分都区分URL里的大小写了，所以用大小写字母来区分不同的URL是没问题的。&lt;/p>
&lt;p>因此，&lt;strong>正确答案：长度不超过7的字符串，由大小写字母加数字共62个字母组成&lt;/strong>&lt;/p>
&lt;h3 id="一对一还是一对多映射">一对一还是一对多映射？&lt;/h3>
&lt;p>一个长网址，对应一个短网址，还是可以对应多个短网址？ 这也是个重大选择问题&lt;/p>
&lt;!-- more -->
&lt;p>一般而言，一个长网址，在不同的地点，不同的用户等情况下，生成的短网址应该不一样，这样，在后端数据库中，可以更好的进行数据分析。如果一个长网址与一个短网址一一对应，那么在数据库中，仅有一行数据，无法区分不同的来源，就无法做数据分析了。&lt;/p>
&lt;p>以这个7位长度的短网址作为唯一ID，这个ID下可以挂各种信息，比如生成该网址的用户名，所在网站，HTTP头部的 User Agent等信息，收集了这些信息，才有可能在后面做大数据分析，挖掘数据的价值。短网址服务商的一大盈利来源就是这些数据。&lt;/p>
&lt;p>&lt;strong>正确答案：一对多&lt;/strong>&lt;/p>
&lt;h3 id="如何计算短网址">如何计算短网址&lt;/h3>
&lt;p>现在我们设定了短网址是一个长度为7的字符串，如何计算得到这个短网址呢？&lt;/p>
&lt;p>最容易想到的办法是哈希，先hash得到一个64位整数，将它转化为62进制整，截取低7位即可。但是哈希算法会有冲突，如何处理冲突呢，又是一个麻烦。这个方法只是转移了矛盾，没有解决矛盾，抛弃。&lt;/p>
&lt;p>&lt;strong>正确答案：&lt;a href="distributed-id-generator.md">分布式发号器(Distributed ID Generator)&lt;/a>&lt;/strong>&lt;/p>
&lt;h3 id="如何存储">如何存储&lt;/h3>
&lt;p>如果存储短网址和长网址的对应关系？以短网址为 primary key, 长网址为value, 可以用传统的关系数据库存起来，例如MySQL, PostgreSQL，也可以用任意一个分布式KV数据库，例如Redis, LevelDB。&lt;/p>
&lt;p>如果你手痒想要手工设计这个存储，那就是另一个话题了，你需要完整地造一个KV存储引擎轮子。当前流行的KV存储引擎有LevelDB何RockDB，去读它们的源码吧 :D&lt;/p>
&lt;h3 id="301还是302重定向">301还是302重定向&lt;/h3>
&lt;p>这也是一个有意思的问题。这个问题主要是考察你对301和302的理解，以及浏览器缓存机制的理解。&lt;/p>
&lt;p>301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。但是如果用了301， Google，百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的Cookie, User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。&lt;/p>
&lt;p>所以，&lt;strong>正确答案是302重定向&lt;/strong>。&lt;/p>
&lt;p>可以抓包看看新浪微博的短网址是怎么做的，使用 Chrome 浏览器，访问这个URL &lt;a href="http://t.cn/RX2VxjI" target="_blank" rel="noopener">http://t.cn/RX2VxjI&lt;/a>，是我事先发微博自动生成的短网址。来抓包看看返回的结果是啥，&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://cn.soulmachine.me/images/tinyurl-302.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可见新浪微博用的就是302临时重定向。&lt;/p>
&lt;h3 id="预防攻击">预防攻击&lt;/h3>
&lt;p>如果一些别有用心的黑客，短时间内向TinyURL服务器发送大量的请求，会迅速耗光ID，怎么办呢？&lt;/p>
&lt;p>首先，限制IP的单日请求总数，超过阈值则直接拒绝服务。&lt;/p>
&lt;p>光限制IP的请求数还不够，因为黑客一般手里有上百万台肉鸡的，IP地址大大的有，所以光限制IP作用不大。&lt;/p>
&lt;p>可以用一台Redis作为缓存服务器，存储的不是 ID-&amp;gt;长网址，而是 长网址-&amp;gt;ID，仅存储一天以内的数据，用LRU机制进行淘汰。这样，如果黑客大量发同一个长网址过来，直接从缓存服务器里返回短网址即可，他就无法耗光我们的ID了。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://engineering.instagram.com/sharding-ids-at-instagram-1cf5a71e5a5c" target="_blank" rel="noopener">Sharding &amp;amp; IDs at Instagram&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Twitter Snowflake&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/29270034" target="_blank" rel="noopener">短 URL 系统是怎么设计的？&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>top-k-frequent-ip-in-one-hour</title><link>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/top-k-frequent-ip-in-one-hour/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-interviews/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/cn/top-k-frequent-ip-in-one-hour/</guid><description>&lt;p>实时输出最近一个小时内访问频率最高的10个IP，要求：&lt;/p>
&lt;ul>
&lt;li>实时输出&lt;/li>
&lt;li>从当前时间向前数的1个小时&lt;/li>
&lt;li>QPS可能会达到10W/s&lt;/li>
&lt;/ul>
&lt;p>这道题乍一看很像&lt;a href="bigdata/heavy-hitters.md">Top K 频繁项&lt;/a>，是不是需要 Lossy Count 或 Count-Min Sketch 之类的算法呢？&lt;/p>
&lt;p>其实杀鸡焉用牛刀，这道题用不着上述算法，请听我仔细分析。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>QPS是 10万/秒，即一秒内最高有 10万个请求，那么一个小时内就有 100000*3600=360000000≈$$2^{28.4}$$，向上取整，大概是 $$2^{29}$$个请求，也不是很大。我们在内存中建立3600个&lt;code>HashMap&amp;lt;Int,Int&amp;gt;&lt;/code>，放在一个数组里，每秒对应一个HashMap，IP地址为key, 出现次数作为value。这样，一个小时内最多有$$2^{29}$$个pair，每个pair占8字节，总内存大概是 $$2^{29} \times 8=2^{32}$$字节，即4GB，单机完全可以存下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时还要新建一个固定大小为10的小根堆，用于存放当前出现次数最大的10个IP。堆顶是10个IP里频率最小的IP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每次来一个请求，就把该秒对应的HashMap里对应的IP计数器增1，并查询该IP是否已经在堆中存在，&lt;/p>
&lt;ul>
&lt;li>如果不存在，则把该IP在3600个HashMap的计数器加起来，与堆顶IP的出现次数进行比较，如果大于堆顶元素，则替换掉堆顶元素，如果小于，则什么也不做&lt;/li>
&lt;li>如果已经存在，则把堆中该IP的计数器也增1，并调整堆&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>需要有一个后台常驻线程，每过一秒，把最旧的那个HashMap销毁，并为当前这一秒新建一个HashMap，这样维持一个一小时的窗口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每次查询top 10的IP地址时，把堆里10个IP地址返回来即可。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>以上就是该方案的全部内容。&lt;/p>
&lt;p>有的人问，可不可以用&amp;quot;IP + 时间&amp;quot;作为key, 把所有pair放在单个HashMap里？如果把所有数据放在一个HashMap里，有两个巨大的缺点，&lt;/p>
&lt;ul>
&lt;li>第4步里，怎么淘汰掉一个小时前的pair呢？这时候后台线程只能每隔一秒，全量扫描这个HashMap里的所有pair,把过期数据删除，这是线性时间复杂度，很慢。&lt;/li>
&lt;li>这时候HashMap里的key存放的是&amp;quot;IP + 时间&amp;quot;组合成的字符串，占用内存远远大于一个int。而前面的方案，不用存真正的时间，只需要开一个3600长度的数组来表示一个小时时间窗口。&lt;/li>
&lt;/ul></description></item></channel></rss>