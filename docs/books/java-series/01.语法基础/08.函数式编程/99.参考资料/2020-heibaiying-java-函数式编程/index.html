<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="Java 函数式编程 一、Lambda 1.1 格式 JDK 从 1.8 版本开始支持 Lambda 表达式，通过 Lambda 表达式我们可以将一个函数作为参数传入方法中。在 JDK 1.8 之前，我们只能通过匿名表达式来完成类似的功能，但是匿名表达式比较繁琐，存在大量的模"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><meta property="og:title" content="2020-heibaiying-Java 函数式编程 | Next-gen Tech Edu"><meta property="og:description" content="Java 函数式编程 一、Lambda 1.1 格式 JDK 从 1.8 版本开始支持 Lambda 表达式，通过 Lambda 表达式我们可以将一个函数作为参数传入方法中。在 JDK 1.8 之前，我们只能通过匿名表达式来完成类似的功能，但是匿名表达式比较繁琐，存在大量的模"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>2020-heibaiying-Java 函数式编程 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=ec4d59df25f542114eec1e1a70ab6325><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">99.参考资料</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id73dfc8b12b05dc36994304ca081b5cb7")' href=#id73dfc8b12b05dc36994304ca081b5cb7 aria-expanded=false aria-controls=id73dfc8b12b05dc36994304ca081b5cb7 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/>08.函数式编程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id73dfc8b12b05dc36994304ca081b5cb7 aria-expanded=false aria-controls=id73dfc8b12b05dc36994304ca081b5cb7><i class="fa-solid fa-angle-down" id=caret-id73dfc8b12b05dc36994304ca081b5cb7></i></a></div><ul class="nav docs-sidenav collapse show" id=id73dfc8b12b05dc36994304ca081b5cb7><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide93a062c06a24c5fcf1a409ee5cff717")' href=#ide93a062c06a24c5fcf1a409ee5cff717 aria-expanded=false aria-controls=ide93a062c06a24c5fcf1a409ee5cff717 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>99.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide93a062c06a24c5fcf1a409ee5cff717 aria-expanded=false aria-controls=ide93a062c06a24c5fcf1a409ee5cff717><i class="fa-solid fa-angle-down" id=caret-ide93a062c06a24c5fcf1a409ee5cff717></i></a></div><ul class="nav docs-sidenav collapse show" id=ide93a062c06a24c5fcf1a409ee5cff717><li class="child level active"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/>2020-heibaiying-Java 函数式编程</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idc21c0681c6711e5e536431c67862778f")' href=#idc21c0681c6711e5e536431c67862778f aria-expanded=false aria-controls=idc21c0681c6711e5e536431c67862778f aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/lambda/>Lambda</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idc21c0681c6711e5e536431c67862778f aria-expanded=false aria-controls=idc21c0681c6711e5e536431c67862778f><i class="fa-solid fa-angle-right" id=caret-idc21c0681c6711e5e536431c67862778f></i></a></div><ul class="nav docs-sidenav collapse" id=idc21c0681c6711e5e536431c67862778f><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/lambda/lambda-%E8%AF%AD%E6%B3%95/>Lambda 语法</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/lambda/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/>函数式接口</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/lambda/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/>上下文与作用域</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ida2d26a782fd38ce1737f0d97f0fb20c5")' href=#ida2d26a782fd38ce1737f0d97f0fb20c5 aria-expanded=false aria-controls=ida2d26a782fd38ce1737f0d97f0fb20c5 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/stream-api/>Stream API</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ida2d26a782fd38ce1737f0d97f0fb20c5 aria-expanded=false aria-controls=ida2d26a782fd38ce1737f0d97f0fb20c5><i class="fa-solid fa-angle-right" id=caret-ida2d26a782fd38ce1737f0d97f0fb20c5></i></a></div><ul class="nav docs-sidenav collapse" id=ida2d26a782fd38ce1737f0d97f0fb20c5><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/stream-api/%E5%B9%B6%E5%8F%91%E6%B5%81/>并发流</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/stream-api/%E6%93%8D%E4%BD%9C%E7%AC%A6/>操作符</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/stream-api/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>异常处理</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id355215f0a980ce20e44b2161881ae74f")' href=#id355215f0a980ce20e44b2161881ae74f aria-expanded=false aria-controls=id355215f0a980ce20e44b2161881ae74f aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/>Vavr</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id355215f0a980ce20e44b2161881ae74f aria-expanded=false aria-controls=id355215f0a980ce20e44b2161881ae74f><i class="fa-solid fa-angle-right" id=caret-id355215f0a980ce20e44b2161881ae74f></i></a></div><ul class="nav docs-sidenav collapse" id=id355215f0a980ce20e44b2161881ae74f><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idd42cec451ef0a1d9afd4c4589ad7012e")' href=#idd42cec451ef0a1d9afd4c4589ad7012e aria-expanded=false aria-controls=idd42cec451ef0a1d9afd4c4589ad7012e aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/collections/>Collections</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idd42cec451ef0a1d9afd4c4589ad7012e aria-expanded=false aria-controls=idd42cec451ef0a1d9afd4c4589ad7012e><i class="fa-solid fa-angle-right" id=caret-idd42cec451ef0a1d9afd4c4589ad7012e></i></a></div><ul class="nav docs-sidenav collapse" id=idd42cec451ef0a1d9afd4c4589ad7012e><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/collections/collections/>Collections</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id431a448e6396fe9efbd373bdcc97bc67")' href=#id431a448e6396fe9efbd373bdcc97bc67 aria-expanded=false aria-controls=id431a448e6396fe9efbd373bdcc97bc67 aria-hidden=false data-toggle=collapse></div></div><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/functions/>Functions</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/pattern-matching/>Pattern Matching</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/tuples/>Tuples</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/validation/>Validation</a></li><li class="child level"><a href=/books/java-series/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/08.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/vavr/values/>Values</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#一lambda>一、Lambda</a><ul><li><a href=#11-格式>1.1 格式</a></li><li><a href=#12-行为参数化>1.2 行为参数化</a></li><li><a href=#13-方法引用和构造器引用>1.3 方法引用和构造器引用</a></li></ul></li><li><a href=#二函数式接口>二、函数式接口</a></li><li><a href=#三创建流>三、创建流</a></li><li><a href=#四操作流>四、操作流</a><ul><li><a href=#41-基本操作>4.1 基本操作</a></li><li><a href=#42-数值流>4.2 数值流</a></li></ul></li><li><a href=#五收集器>五、收集器</a><ul><li><a href=#52-分组>5.2 分组</a></li><li><a href=#53-分区>5.3 分区</a></li></ul></li><li><a href=#六并行流>六、并行流</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>2020-heibaiying-Java 函数式编程</h1><div class=article-style><h1 id=java-函数式编程>Java 函数式编程</h1><h2 id=一lambda>一、Lambda</h2><h3 id=11-格式>1.1 格式</h3><p>JDK 从 1.8 版本开始支持 Lambda 表达式，通过 Lambda 表达式我们可以将一个函数作为参数传入方法中。在 JDK 1.8 之前，我们只能通过匿名表达式来完成类似的功能，但是匿名表达式比较繁琐，存在大量的模板代码，不利于将行为参数化，而采用 Lamdba 则能很好的解决这个问题。Lambda 表达式的基本语法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>(</span><span class=n>parameters</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>expression</span>
</span></span></code></pre></div><p>或采用花括号的形式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>(</span><span class=n>parameters</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span> <span class=n>statements</span><span class=o>;</span> <span class=o>}</span>
</span></span></code></pre></div><p>Lambda 表达式具有如下特点：</p><ul><li><strong>可选的参数</strong>：不需要声明参数类型，编译器会依靠上下文进行自动推断；</li><li><strong>可选的参数圆括号</strong>：当且仅当只有一个参数时，包裹参数的圆括号可以省略；</li><li><strong>可选的花括号</strong>：如果主体只有一个表达式，则无需使用花括号；</li><li><strong>可选的返回关键字</strong>：如果主体只有一个表达式，则该表达式的值就是整个 Lambda 表达式的返回值，此时不需要使用 return 关键字进行显式的返回。</li></ul><h3 id=12-行为参数化>1.2 行为参数化</h3><p>上面我们说过，Lambda 表达式主要解决的是行为参数化的问题，而什么是行为参数化？下面给出一个具体的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 定义函数式接口
</span></span></span><span class=line><span class=cl><span class=cm> * @param &lt;T&gt; 参数类型
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>CustomPredicate</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>test</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 集合过滤
</span></span></span><span class=line><span class=cl><span class=cm> * @param list 待过滤的集合
</span></span></span><span class=line><span class=cl><span class=cm> * @param predicate 函数式接口
</span></span></span><span class=line><span class=cl><span class=cm> * @param &lt;T&gt; 集合中元素的类型
</span></span></span><span class=line><span class=cl><span class=cm> * @return 满足条件的元素的集合
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>filter</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>,</span> <span class=n>CustomPredicate</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>predicate</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>result</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=n>T</span> <span class=n>t</span> <span class=o>:</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 将满足条件的元素添加到返回集合中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>predicate</span><span class=o>.</span><span class=na>test</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=n>result</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>针对不同类型的集合，我们可以通过传入不同的 Lambda 表达式作为参数来表达不同的过滤行为，这就是行为参数化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integers</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>,</span> <span class=mi>3</span><span class=o>,</span> <span class=mi>4</span><span class=o>,</span> <span class=mi>5</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>filter</span><span class=o>(</span><span class=n>integers</span><span class=o>,</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=o>);</span>  <span class=c1>// 过滤出所有偶数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>employees</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;张某&#34;</span><span class=o>,</span> <span class=mi>21</span><span class=o>,</span> <span class=kc>true</span><span class=o>),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;李某&#34;</span><span class=o>,</span> <span class=mi>30</span><span class=o>,</span> <span class=kc>true</span><span class=o>),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;王某&#34;</span><span class=o>,</span> <span class=mi>45</span><span class=o>,</span> <span class=kc>false</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=n>filter</span><span class=o>(</span><span class=n>employees</span><span class=o>,</span> <span class=n>employee</span> <span class=o>-&gt;</span> <span class=n>employee</span><span class=o>.</span><span class=na>getAge</span><span class=o>()</span> <span class=o>&gt;</span> <span class=mi>25</span><span class=o>);</span> <span class=c1>// 过滤出所有年龄大于25的员工
</span></span></span></code></pre></div><p>需要注意的是上面我们声明接口时，使用了 <code>@FunctionalInterface</code> 注解，它表示当前的接口是一个函数式接口。函数式接口就是只含有一个抽象方法的接口；即一个接口不论含有多少个默认方法和静态方法，只要它只有一个抽象方法，它就是一个函数式接口。使用 <code>@FunctionalInterface</code> 修饰后，当该接口有一个以上的抽象方法时，编译器就会进行提醒。</p><p>任何使用到函数式接口的地方，都可以使用 Lambda 表达式进行简写。例如 Runnable 接口就是一个函数式接口，我们可以使用 Lambda 表达式对其进行简写：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>new</span> <span class=n>Thread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;hello&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>});</span>
</span></span></code></pre></div><h3 id=13-方法引用和构造器引用>1.3 方法引用和构造器引用</h3><p>紧接上面的例子，如果我们需要过滤出所有的正式员工，除了可以写成下面的形式外：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>filter</span><span class=o>(</span><span class=n>employees</span><span class=o>,</span> <span class=n>employee</span> <span class=o>-&gt;</span> <span class=n>employee</span><span class=o>.</span><span class=na>isOfficial</span><span class=o>());</span>
</span></span></code></pre></div><p>还可以使用方法引用的形式进行简写：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>filter</span><span class=o>(</span><span class=n>employees</span><span class=o>,</span> <span class=n>Employee</span><span class=o>::</span><span class=n>isOfficial</span><span class=o>);</span>
</span></span></code></pre></div><p>除了方法引用外，还可以对构造器进行引用，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=mi>3</span><span class=o>,</span> <span class=mi>5</span><span class=o>,</span> <span class=mi>2</span><span class=o>,</span> <span class=mi>4</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toCollection</span><span class=o>(</span><span class=n>ArrayList</span><span class=o>::</span><span class=k>new</span><span class=o>));</span>  <span class=c1>//等价于 toCollection(()-&gt;new ArrayList&lt;&gt;())
</span></span></span></code></pre></div><p>方法引用和构造器引用的目的都是为了让代码更加的简洁。</p><h2 id=二函数式接口>二、函数式接口</h2><p>通常我们不需要自定义函数式接口，JDK 中内置了大量函数式接口，基本可以满足大多数场景下的使用需求，最基本的四种如下：</p><p><strong>1. Consumer&lt;T></strong>：消费型接口，消费输入的变量，没有返回值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Consumer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>accept</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>2. Consumer&lt;T></strong>：供给型接口，供给变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Supplier</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>3. Function&lt;T, R></strong>：对输入类型为 T 的变量执行特定的转换操作，并返回类型为 R 的返回值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>R</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>apply</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>4. Predicate&lt;T></strong>：判断类型为 T 的变量是否满足特定的条件，如果满足则返回 true，否则返回 false：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Predicate</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>test</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>其他函数式接口都是这四种基本类型的扩展和延伸。以 BiFunction 和 BinaryOperator 接口为例：</p><ul><li><strong>BiFunction&lt;T, U, R></strong>：是函数型接口 Function&lt;T, R> 的扩展，Function 只能接收一个入参；而 BiFunction 可以用于接收两个不同类型的入参；</li><li><strong>BinaryOperator&lt;T></strong>：是 BiFunction 的一种特殊化情况，即两个入参和返回值的类型均相同，通常用于二元运算。定义如下：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>BiFunction</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>U</span><span class=o>,</span> <span class=n>R</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>apply</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>,</span> <span class=n>U</span> <span class=n>u</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>BinaryOperator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>BiFunction</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span><span class=n>T</span><span class=o>,</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=o>....</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>下面演示一下 BinaryOperator 的用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 执行归约操作
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=nf>reduce</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>,</span> <span class=n>T</span> <span class=n>initValue</span><span class=o>,</span> <span class=n>BinaryOperator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>binaryOperator</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=n>T</span> <span class=n>t</span> <span class=o>:</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>initValue</span> <span class=o>=</span> <span class=n>binaryOperator</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>initValue</span><span class=o>,</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>initValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integers</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>,</span> <span class=mi>3</span><span class=o>,</span> <span class=mi>4</span><span class=o>,</span> <span class=mi>5</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>reduce</span><span class=o>(</span><span class=n>integers</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=o>);</span> <span class=c1>// 求和  输出：15
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>reduce</span><span class=o>(</span><span class=n>integers</span><span class=o>,</span> <span class=mi>1</span><span class=o>,</span> <span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=o>);</span> <span class=c1>// 求积  输出：120
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div><h2 id=三创建流>三、创建流</h2><p>JDK 1.8 中另一个大的改进是引入了流，通过流、Lamda 表达式以及函数式接口，可以高效地完成数据的处理。创建流通常有以下四种方法：</p><p><strong>1. 由值创建</strong></p><p>使用静态方法 <code>Stream.of()</code> 由指定的值进行创建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>,</span> <span class=s>&#34;d&#34;</span><span class=o>);</span>
</span></span></code></pre></div><p><strong>2. 由集合或数组创建</strong></p><p>使用静态方法 <code>Arrays.stream()</code> 由指定的数组进行创建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span><span class=o>[]</span> <span class=n>strings</span><span class=o>={</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>,</span> <span class=s>&#34;d&#34;</span><span class=o>};</span>
</span></span><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>strings</span><span class=o>);</span>
</span></span></code></pre></div><p>调用集合类的 <code>stream()</code> 方法进行创建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>List&lt;String&gt; <span class=nv>strings</span> <span class=o>=</span> Arrays.asList<span class=o>(</span><span class=s2>&#34;a&#34;</span>, <span class=s2>&#34;b&#34;</span>, <span class=s2>&#34;c&#34;</span>, <span class=s2>&#34;d&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>Stream&lt;String&gt; <span class=nv>stream</span> <span class=o>=</span> strings.stream<span class=o>()</span><span class=p>;</span>
</span></span></code></pre></div><p><code>stream()</code> 方法定义在 <code>Collection</code> 接口中，它是一个默认方法，因此大多数的集合都可以通过该方法来创建流：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Collection</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span> <span class=n>Stream</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>stream</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>StreamSupport</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>spliterator</span><span class=o>(),</span> <span class=kc>false</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>3. 由文件创建</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>try</span> <span class=o>(</span><span class=n>Stream</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>lines</span> <span class=o>=</span> <span class=n>Files</span><span class=o>.</span><span class=na>lines</span><span class=o>(</span><span class=n>Paths</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=s>&#34;pom.xml&#34;</span><span class=o>),</span> <span class=n>StandardCharsets</span><span class=o>.</span><span class=na>UTF_8</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lines</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>IOException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>4. 由函数创建</strong></p><p>除了以上方法外，还可以通过 <code>Stream.iterate()</code> 和 <code>Stream.generate()</code> 方法来来创建无限流：</p><ul><li><p><code>Stream.iterate()</code> 接受两个参数：第一个是初始值；第二个参数是一个输入值和输出值相同的函数型接口，主要用于迭代式地产生新的元素，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 依次输出0到9
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Stream</span><span class=o>.</span><span class=na>iterate</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=o>).</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>).</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>print</span><span class=o>);</span>
</span></span></code></pre></div></li><li><p><code>Stream.generate()</code> 接收一个供应型函数作为参数，用于按照该函数产生新的元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 依次输出随机数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Stream</span><span class=o>.</span><span class=na>generate</span><span class=o>(</span><span class=n>Math</span><span class=o>::</span><span class=n>random</span><span class=o>).</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>).</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>print</span><span class=o>);</span>
</span></span></code></pre></div></li></ul><h2 id=四操作流>四、操作流</h2><h3 id=41-基本操作>4.1 基本操作</h3><p>当流创建后，便可以利用 Stream 类上的各种方法对流中的数据进行处理，常用的方法如下：</p><table><thead><tr><th>操作</th><th>作用</th><th>返回类型</th><th>使用的类型/函数式接口</th></tr></thead><tbody><tr><td>filter</td><td>过滤符合条件的元素</td><td>Stream&lt;T></td><td>Predicate&lt;T></td></tr><tr><td>distinct</td><td>过滤重复元素</td><td>Stream&lt;T></td><td></td></tr><tr><td>skip</td><td>跳过指定数量的元素</td><td>Stream&lt;T></td><td>long</td></tr><tr><td>limit</td><td>限制元素的数量</td><td>Stream&lt;T></td><td>long</td></tr><tr><td>map</td><td>对元素执行特定转换操作</td><td>Stream&lt;T></td><td>Function&lt;T,R></td></tr><tr><td>flatMap</td><td>将元素扁平化后执行特定转换操作</td><td>Stream&lt;T></td><td>Function&lt;T,Stream&lt;R&#187;</td></tr><tr><td>sorted</td><td>对元素进行排序</td><td>Stream&lt;T></td><td>Comparator&lt;T></td></tr><tr><td>anyMatch</td><td>是否存在任意一个元素能满足指定条件</td><td>boolean</td><td>Predicate&lt;T></td></tr><tr><td>noneMatch</td><td>是否所有元素都不满足指定条件</td><td>boolean</td><td>Predicate&lt;T></td></tr><tr><td>allMatch</td><td>是否所有元素都满足指定条件</td><td>boolean</td><td>Predicate&lt;T></td></tr><tr><td>findAny</td><td>返回任意一个满足指定条件的元素</td><td>Optional&lt;T></td><td></td></tr><tr><td>findFirst</td><td>返回第一个满足指定条件的元素</td><td>Optional&lt;T></td><td></td></tr><tr><td>forEach</td><td>对所有元素执行特定的操作</td><td>void</td><td>Cosumer&lt;T></td></tr><tr><td>collect</td><td>使用收集器</td><td>R</td><td>Collector&lt;T, A, R></td></tr><tr><td>reduce</td><td>执行归约操作</td><td>Optional&lt;T></td><td>BinaryOperator&lt;T></td></tr><tr><td>count</td><td>计算流中元素的数量</td><td>long</td><td></td></tr></tbody></table><blockquote><p>注：上表中返回类型为 Stream&lt;T> 的操作都是中间操作，代表还可以继续调用其它方法对流进行处理。返回类型为其它的操作都是终止操作，代表处理过程到此为止。</p></blockquote><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>.</span><span class=na>iterate</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span>       <span class=c1>// 构建流
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=mi>20</span><span class=o>)</span>                        <span class=c1>// 限制元素的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>.</span><span class=na>skip</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>                        <span class=c1>// 跳过前10个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>         <span class=c1>// 过滤出所有偶数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=s>&#34;偶数:&#34;</span> <span class=o>+</span> <span class=n>x</span><span class=o>)</span>            <span class=c1>// 对元素执行转换操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>    <span class=c1>// 打印出所有元素
</span></span></span></code></pre></div><p>输出结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>偶数:10
</span></span><span class=line><span class=cl>偶数:12
</span></span><span class=line><span class=cl>偶数:14
</span></span><span class=line><span class=cl>偶数:16
</span></span><span class=line><span class=cl>偶数:18
</span></span></code></pre></div><p>上表的 <code>flatMap()</code> 方法接收一个参数，该参数是一个函数型接口 <code>Function&lt;? super T, ? extends Stream&lt;? extends R>> mapper</code>，主要用于将流中的元素转换为 <code>Stream</code> ，从而可以将原有的元素进行扁平化，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span><span class=o>[]</span> <span class=n>strings</span> <span class=o>=</span> <span class=o>{</span><span class=s>&#34;hello&#34;</span><span class=o>,</span> <span class=s>&#34;world&#34;</span><span class=o>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>strings</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span><span class=o>.</span><span class=na>split</span><span class=o>(</span><span class=s>&#34;&#34;</span><span class=o>))</span>              <span class=c1>// 拆分得到: [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;],[&#39;w&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>.</span><span class=na>flatMap</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>x</span><span class=o>))</span>  <span class=c1>// 将每个数组进行扁平化处理得到：&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;w&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>
</span></span></code></pre></div><p>而上表的 <code>reduce()</code> 方法则接收两个参数：第一个参数表示执行归约操作的初始值；第二个参数是上文我们介绍过的函数式接口 <code>BinaryOperator&lt;T></code> ，使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>.</span><span class=na>iterate</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=o>).</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>reduce</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=o>);</span> <span class=c1>//进行求和操作
</span></span></span></code></pre></div><h3 id=42-数值流>4.2 数值流</h3><p>上面的代码等效于对 Stream 中的所有元素执行了求和操作，因此我们还可以调用简便方法 <code>sum()</code> 来进行实现，但是需要注意的是 <code>Stream.iterate()</code> 生成流中的元素类型都是包装类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>iterate</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span> <span class=c1>//包装类型Integer
</span></span></span></code></pre></div><p>而 <code>sum()</code> 方法则是定义在 IntStream 上，此时需要将流转换为具体的数值流，对应的方法是 <code>mapToInt()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>.</span><span class=na>iterate</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=o>).</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>).</span><span class=na>mapToInt</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span><span class=o>).</span><span class=na>sum</span><span class=o>();</span>
</span></span></code></pre></div><p>类似的方法还有 <code>mapToLong()</code> 和 <code>mapToDouble()</code> 。如果你想要将数值流转换为原有的流，相当于对其中的元素进行装箱操作，此时可以调用 <code>boxed()</code> 方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>IntStream</span> <span class=n>intStream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>iterate</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=o>).</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>).</span><span class=na>mapToInt</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>boxed</span> <span class=o>=</span> <span class=n>intStream</span><span class=o>.</span><span class=na>boxed</span><span class=o>();</span>
</span></span></code></pre></div><h2 id=五收集器>五、收集器</h2><p>Stream 中最强大一个终止操作是 <code>collect()</code> ，它接收一个收集器 Collector 作为参数，可以将流中的元素收集到集合中，或进行分组、分区等操作。Java 中内置了多种收集器的实现，可以通过 Collectors 类的静态方法进行调用，常用的收集器如下：</p><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>用于</th></tr></thead><tbody><tr><td>toList</td><td>List&lt;T></td><td>把流中所有元素收集到 List 中</td></tr><tr><td>toSet</td><td>Set&lt;T></td><td>把流中所有元素收集到 Set 中</td></tr><tr><td>toCollection</td><td>Collection&lt;T></td><td>把流中所有元素收集到指定的集合中</td></tr><tr><td>counting</td><td>Long</td><td>计算流中所有元素的个数</td></tr><tr><td>summingInt</td><td>Integer</td><td>将流中所有元素转换为整数，并计算其总和</td></tr><tr><td>averagingInt</td><td>Double</td><td>将流中所有元素转换为整数，并计算其平均值</td></tr><tr><td>summarizingInt</td><td>IntSummaryStatistics</td><td>将流中所有元素转换为整数，并返回统计结果，包含最大值、最小值、<br>总和与平均值等信息</td></tr><tr><td>joining</td><td>String</td><td>将流中所有元素转换为字符串，并使用给定连接符进行连接</td></tr><tr><td>maxBy</td><td>Optional&lt;T></td><td>查找流中最大元素的 Optional</td></tr><tr><td>minBy</td><td>Optional&lt;T></td><td>查找流中最小元素的 Optional</td></tr><tr><td>reducing</td><td>规约操作产生的类型</td><td>对流中所有元素执行归约操作</td></tr><tr><td>collectingAndThen</td><td>转换返回的类型</td><td>先把流中所有元素收集到指定的集合中，再对集合执行特定的操作</td></tr><tr><td>groupingBy</td><td>Map&lt;K,List&lt;T&#187;</td><td>对流中所有元素执行分组操作</td></tr><tr><td>partitionBy</td><td>Map&lt;Boolean,List&lt;T&#187;</td><td>对流中所有元素执行分区操作</td></tr></tbody></table><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>,</span> <span class=mi>3</span><span class=o>,</span> <span class=mi>4</span><span class=o>,</span> <span class=mi>4</span><span class=o>,</span> <span class=mi>5</span><span class=o>,</span> <span class=mi>6</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toSet</span><span class=o>());</span>  <span class=c1>// [1, 2, 3, 4, 5, 6]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span> <span class=c1>// [1, 2, 3, 4, 4, 5, 6]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toCollection</span><span class=o>(</span><span class=n>ArrayList</span><span class=o>::</span><span class=k>new</span><span class=o>));</span> <span class=c1>// [1, 2, 3, 4, 4, 5, 6]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>counting</span><span class=o>());</span> <span class=c1>// 7 等效于 stream.count();
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>summarizingInt</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span><span class=o>));</span> <span class=c1>// IntSummaryStatistics{count=7, sum=25, min=1, average=3.571429, max=6}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>maxBy</span><span class=o>((</span><span class=n>Integer</span><span class=o>::</span><span class=n>compareTo</span><span class=o>)));</span> <span class=c1>// Optional[6]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>reducing</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=o>));</span> <span class=c1>// 等效于 stream.reduce(1, (a, b) -&gt; a * b);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>collectingAndThen</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toSet</span><span class=o>(),</span> <span class=n>Set</span><span class=o>::</span><span class=n>size</span><span class=o>));</span> <span class=c1>// 先把所有元素收集到Set中，再计算Set的大小
</span></span></span></code></pre></div><blockquote><p>注意：以上每个终止操作只能单独演示，因为对一个流只能执行一次终止操作。并且执行完终止操作后，就不能再对这个流进行任何操作，否则将抛出 <code>java.lang.IllegalStateException: stream has already been operated upon or closed</code> 的异常。</p></blockquote><h3 id=52-分组>5.2 分组</h3><p>分组收集器可以实现类似数据库 groupBy 子句的功能。假设存在如下员工信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>stream</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;张某&#34;</span><span class=o>,</span> <span class=s>&#34;男&#34;</span><span class=o>,</span> <span class=s>&#34;A公司&#34;</span><span class=o>,</span> <span class=mi>20</span><span class=o>),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;李某&#34;</span><span class=o>,</span> <span class=s>&#34;女&#34;</span><span class=o>,</span> <span class=s>&#34;A公司&#34;</span><span class=o>,</span> <span class=mi>30</span><span class=o>),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;王某&#34;</span><span class=o>,</span> <span class=s>&#34;男&#34;</span><span class=o>,</span> <span class=s>&#34;B公司&#34;</span><span class=o>,</span> <span class=mi>40</span><span class=o>),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;田某&#34;</span><span class=o>,</span> <span class=s>&#34;女&#34;</span><span class=o>,</span> <span class=s>&#34;B公司&#34;</span><span class=o>,</span> <span class=mi>50</span><span class=o>));</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Employee</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>gender</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>company</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>age</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span><span class=k>return</span> <span class=s>&#34;Employee{&#34;</span> <span class=o>+</span> <span class=s>&#34;name=&#39;&#34;</span> <span class=o>+</span> <span class=n>name</span> <span class=o>+</span> <span class=sc>&#39;\&#39;&#39;</span> <span class=o>+</span> <span class=sc>&#39;}&#39;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>此时如果需要按照公司进行分组，则可以使用 <code>groupingBy()</code> 收集器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>groupingBy</span><span class=o>(</span><span class=n>Employee</span><span class=o>::</span><span class=n>getCompany</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>对应的分组结果如下：</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>   <span class=n>B</span><span class=err>公司</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;王某&#39;</span><span class=o>},</span> <span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;田某&#39;</span><span class=o>}],</span>
</span></span><span class=line><span class=cl>   <span class=n>A</span><span class=err>公司</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;张某&#39;</span><span class=o>},</span> <span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;李某&#39;</span><span class=o>}]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>如果想要计算分组后每家公司的人数，还可以为 <code>groupingBy()</code> 传递一个收集器 Collector 作为其第二个参数，调用其重载方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>groupingBy</span><span class=o>(</span><span class=n>Employee</span><span class=o>::</span><span class=n>getCompany</span><span class=o>,</span> <span class=n>Collectors</span><span class=o>.</span><span class=na>counting</span><span class=o>()));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>对应的结果如下：</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>B</span><span class=err>公司</span><span class=o>=</span><span class=mi>2</span><span class=o>,</span>
</span></span><span class=line><span class=cl>  <span class=n>A</span><span class=err>公司</span><span class=o>=</span><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>因为第二个参数是一个 Collector，这意味着你可以再传入一个分组收集器来完成多级分组，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>groupingBy</span><span class=o>(</span><span class=n>Employee</span><span class=o>::</span><span class=n>getCompany</span><span class=o>,</span> <span class=n>Collectors</span><span class=o>.</span><span class=na>groupingBy</span><span class=o>(</span><span class=n>Employee</span><span class=o>::</span><span class=n>getGender</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>先按照公司分组，再按照性别分组，结果如下：</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>   <span class=n>B</span><span class=err>公司</span><span class=o>={</span><span class=err>女</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;田某&#39;</span><span class=o>}],</span> <span class=err>男</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;王某&#39;</span><span class=o>}]},</span>
</span></span><span class=line><span class=cl>   <span class=n>A</span><span class=err>公司</span><span class=o>={</span><span class=err>女</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;李某&#39;</span><span class=o>}],</span> <span class=err>男</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;张某&#39;</span><span class=o>}]}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>除此之外，也可以通过代码块来自定义分组条件，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;&gt;</span> <span class=n>collect</span> <span class=o>=</span> <span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>groupingBy</span><span class=o>(</span><span class=n>employee</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>employee</span><span class=o>.</span><span class=na>getAge</span><span class=o>()</span> <span class=o>&lt;=</span> <span class=mi>30</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;青年员工&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>employee</span><span class=o>.</span><span class=na>getAge</span><span class=o>()</span> <span class=o>&lt;</span> <span class=mi>50</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;中年员工&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;老年员工&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>对应的分组结果如下：</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=err>中年员工</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;王某&#39;</span><span class=o>}],</span>
</span></span><span class=line><span class=cl>  <span class=err>青年员工</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;张某&#39;</span><span class=o>},</span> <span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;李某&#39;</span><span class=o>}],</span>
</span></span><span class=line><span class=cl>  <span class=err>老年员工</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;田某&#39;</span><span class=o>}]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=53-分区>5.3 分区</h3><p>分区是分组的一种特殊情况，即将满足指定条件的元素分为一组，将不满足指定条件的元素分为另一组，两者在使用上基本类似，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>partitioningBy</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=s>&#34;A公司&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>getCompany</span><span class=o>())));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>对应的分区结果如下：</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kc>false</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;王某&#39;</span><span class=o>},</span> <span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;田某&#39;</span><span class=o>}],</span>
</span></span><span class=line><span class=cl>  <span class=kc>true</span><span class=o>=[</span><span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;张某&#39;</span><span class=o>},</span> <span class=n>Employee</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=err>&#39;李某&#39;</span><span class=o>}]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=六并行流>六、并行流</h2><p>想要将普通流转换为并行流非常简单，只需要调用 Stream 的 <code>parallel()</code> 方法即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>stream</span><span class=o>.</span><span class=na>parallel</span><span class=o>();</span>
</span></span></code></pre></div><p>此时流中的所有元素会被均匀的分配到多个线程上进行处理。并行流内部使用的是 ForkJoinPool 线程池，它默认的线程数量就是处理器数量，可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 来查看该值，通常不需要更改。</p><p>当前也没有办法为某个具体的流指定线程数量，只能通过修改系统属性 <code>java.util.concurrent.ForkJoinPool.common.parallelism</code> 的值来改变所有并行流使用的线程数量，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>System</span><span class=o>.</span><span class=na>setProperty</span><span class=o>(</span><span class=s>&#34;java.util.concurrent.ForkJoinPool.common.parallelism&#34;</span><span class=o>,</span><span class=s>&#34;12&#34;</span><span class=o>);</span>
</span></span></code></pre></div><p>如果想将并行流改回普通的串行流，则只需要调用 Stream 的 <code>sequential()</code> 方法即可：</p><pre tabindex=0><code class=language-she data-lang=she>stream.sequential();
</code></pre><h2 id=参考资料>参考资料</h2><p>厄马(Raoul-Gabriel Urma) / 弗斯科(Mario Fusco) / 米克罗夫特(Alan Mycroft) .<strong>《Java 8 实战》</strong>. 人民邮电出版社 . 2016-04-01</p></div><div class=article-widget><div class="container-xl row post-nav"></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>