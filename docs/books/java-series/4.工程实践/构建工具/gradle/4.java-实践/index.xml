<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>4.Java 实践 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/</link><atom:link href="https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/index.xml" rel="self" type="application/rss+xml"/><description>4.Java 实践</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>4.Java 实践</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/</link></image><item><title>多项目结构</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="多项目结构">多项目结构&lt;/h1>
&lt;p>每一个活跃的项目会随着时间慢慢增长的，一开始可能只是个很小的项目到后面可能包含很多包和类。为了提高可维护性和解藕的目的，你可能想把项目根据逻辑和功能来划分成一个个模块。模块通常按照等级来组织，相互之间可以定义依赖。Gradle 给项目模块化提供了强大的支持，在 Gradle 中每个模块都是一个项目，我们称之为多项目构建。&lt;/p>
&lt;h1 id="子项目定义">子项目定义&lt;/h1>
&lt;p>在 Gradle 中，使用文件 settings.gradle 定义当前项目的子项目，格式如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">include&lt;/span> &lt;span class="s1">&amp;#39;sub-project1&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s1">&amp;#39;sub-project2&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s1">&amp;#39;sub-project3&amp;#39;&lt;/span>&lt;span class="err">，&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它表示在当前的项目下建立三个子项目，分别为&amp;rsquo;sub-project1&amp;rsquo;, &amp;lsquo;sub-project2&amp;rsquo;, &amp;lsquo;sub-project3&amp;rsquo;。默认情况下，每个子项目的名称对应着当前操作系统目录下的一个子目录。当 Gradle 运行时，会根据 settings.gradle 的配置情况，构建一个单根节点的项目树。其中的每个子节点代表一个项目(Project)，每个项目都有一个唯一的路径表示它在当前树中的位置，路径的定义方式类似:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">Root:&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Level1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="err">子节点&lt;/span>&lt;span class="o">&amp;gt;:&amp;lt;&lt;/span>&lt;span class="n">Level2&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="err">子节点&lt;/span>&lt;span class="o">&amp;gt;:&amp;lt;&lt;/span>&lt;span class="n">Level3&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="err">子节点&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以简写成 &lt;code>:&amp;lt;Level1-子节点&amp;gt;:&amp;lt;Level2-子节点&amp;gt;:&amp;lt;Level3-子节点&amp;gt;&lt;/code>。借助这种路径的定义方式，我们可以在 build.gradle 去访问不同的子项目。另外，对于单项目，实际上是一种特殊的、只存在根节点，没有子节点的项目树。&lt;/p>
&lt;p>例如，我们有个产品 A，包括以下几个组件 core，web，mobile。分别代表&amp;quot;核心逻辑&amp;quot;、&amp;ldquo;网站&amp;rdquo;、“手机客户端”。因为每个组件是独立的部分，这个时候最好我们能定义多个子项目，让每个子项目分别管理自己的构建。于是我们可以这样定义 A/settings.gradle&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">include&lt;/span> &lt;span class="s1">&amp;#39;core&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s1">&amp;#39;web&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s1">&amp;#39;mobile&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按照之前描述的，core 组件对应 A/core 目录，web 组件对应 A/web 目录，mobile 组件对应 A/mobile 目录。接下来，我们就可以在每个组件内部，定义 build.gradle 负责管理当前组件的构建。&lt;/p>
&lt;p>Gradle 提供了一个内建的 task &amp;lsquo;gradle projects&amp;rsquo;，可以 帮助我们查看当前项目所包含的子项目，下面让我们看看 gradle projects 的输出结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ gradle projects
:projects
------------------------------------------------------------
Root project
------------------------------------------------------------
Root project &amp;#39;A&amp;#39;
+--- Project &amp;#39;:core&amp;#39;
+--- Project &amp;#39;:mobile&amp;#39;
\--- Project &amp;#39;:web
&lt;/code>&lt;/pre>&lt;p>结果一目了然，首先是 Root 级别的项目 A，然后是 A 下面的子项目&amp;rsquo;core&amp;rsquo;, &amp;lsquo;mobile&amp;rsquo;, &amp;lsquo;mobile&amp;rsquo;，最终的文件以及目录结构如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">A
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --settings.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --web
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --mobile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你不喜欢这种默认的结构，也可以按照如下方式定义子项目的名称和物理目录结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">include&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;:core)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">project(&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">core&lt;/span>&lt;span class="s1">&amp;#39;).projectDir = new File(settingsDir, &amp;#39;&lt;/span>&lt;span class="n">core&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">xxx&lt;/span>&lt;span class="s1">&amp;#39;)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">include(&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">web&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">project&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;:web&amp;#39;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">projectDir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">File&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">settingsDir&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s1">&amp;#39;web-xxx&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">include&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;:mobile)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">project(&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">mobile&lt;/span>&lt;span class="s1">&amp;#39;).projectDir = new File(settingsDir, &amp;#39;&lt;/span>&lt;span class="n">mobile&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">xxx&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中，子项目 core 实际上对应的物理目录为 A/core-xxx，web 实际上对应的是 A/web-xxx，mobile 也类似。虽然我们更改了子项目的物理目录结构，不过由于我们在 build.gradle 中使用的是类似 “ :&lt;SubProject>”的方式访问对应的子项目，所以目录结构的改变，对我们 Gradle 的构建脚本并不会产生影响。&lt;/p>
&lt;p>接下来，考虑一个更复杂的情况，随着产品的发展，mobile 这个组件慢慢的划分成了 Android 和 IOS 两个部分，这时我们只需要在目录 A/mobile 下定义新的 settings.gradle，并加入如下部分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">include&lt;/span> &lt;span class="s1">&amp;#39;android&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s1">&amp;#39;ios&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，mobile 组件下将存在两个新的子项目 &amp;ldquo;android&amp;rdquo; 和 &amp;ldquo;ios&amp;rdquo;；于是，这时候&amp;rsquo;gradle projects&amp;rsquo;的目录结构就变成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">A
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --settings.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --web
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --mobile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --settings.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --ios
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --android
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --build.gradle
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="子项目任务继承">子项目任务继承&lt;/h1>
&lt;p>在 Gradle 中，当在当前项目上执行 &lt;code>gradle &amp;lt;Task&amp;gt;&lt;/code> 时，gradle 会遍历当前项目以及其所有的子项目，依次执行所有的同名 Task，注意：子项目的遍历顺序并不是按照 setting.gradle 中的定义顺序，而是按照子项目的首字母排列顺序。基于刚才的例子，如果我们在根目录下，执行 gradle hello，那么所有子项目的“hello” Task 都会被执行。如果我们在 mobile 目录下执行 gradle hello,那么 mobile、android 以及 IOS 的“hello” Task 都会被执行。&lt;/p>
&lt;p>对于大多数构建工具，对于子项目的配置，都是基于继承的方式。Gradle 除了提供继承的方式来设置子项目，还提供了另外一种集中的配置方式，方便我们统一管理子项目的信息。下面看一个例子，打开 A/build.gradle，输入如下部分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">allprojects&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task&lt;/span> &lt;span class="n">hello&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="n">task&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span> &lt;span class="s2">&amp;#34;I&amp;#39;m $task.project.name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">subprojects&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">allprojects&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task&lt;/span> &lt;span class="n">hello&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="n">task&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span> &lt;span class="s2">&amp;#34;I&amp;#39;m $task.project.name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">allprojects&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task&lt;/span> &lt;span class="n">hello&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="n">task&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span> &lt;span class="s2">&amp;#34;I&amp;#39;m $task.project.name&amp;#34;&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">subprojects&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hello&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="n">println&lt;/span> &lt;span class="s2">&amp;#34;- I am the sub project of A&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">project&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;:core&amp;#39;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">hello&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span> &lt;span class="s2">&amp;#34;- I&amp;#39;m the core component and provide service for other parts.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于上面所示的代码，已经很表意了：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>allprojects{xxx}&lt;/code> 这段代码表示，对于所有的 project，Gradle 都将定义一个名称是 hello 的 Task &lt;code>{ println &amp;quot;I'm $task.[project.name](http://project.name/)&amp;quot;}&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>subprojects{xxxx}&lt;/code> 的这段代码表示，对于所有的子 project，将在名称为 hello 的 Task 上追加 Action &lt;code>{println &amp;quot;- I am the sub project of A&amp;quot;}&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>project(':core')&lt;/code> 的这段代码表示，对于名称为 core 的 project，将在名称为 hello 的 Task 上追加 Action &lt;code>{ println &amp;quot;- I'm the core component and provide service for other parts.&amp;quot; }&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>依赖管理</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="gradle-依赖管理">Gradle 依赖管理&lt;/h1>
&lt;h1 id="依赖仓库">依赖仓库&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mavenCentral&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="c1">// 定义仓库为maven中心仓库
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">jcenter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="c1">// 定义仓库为jcenter仓库
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">maven&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">url&lt;/span> &lt;span class="s2">&amp;#34;http://repo.mycompany.com/maven2&amp;#34;&lt;/span> &lt;span class="c1">// 定义依赖包协议是maven，地址是公司的仓库地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">// 定义本地仓库目录
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">flatDir&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dirs&lt;/span> &lt;span class="s1">&amp;#39;lib&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">// 定义ivy协议类型的仓库
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">ivy&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">url&lt;/span> &lt;span class="s2">&amp;#34;http://repo.mycompany.com/repo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mavenCentral&lt;/span> &lt;span class="nl">artifactUrls:&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;file://C:/maven/.m2/repository/&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是系统的默认配置的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mavenLocal&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="依赖声明">依赖声明&lt;/h1>
&lt;p>在 Gradle 3.0 之后，使用了 implementation 与 api 替代了原来的 compile。compile 声明的依赖，使用该方式依赖的库将会参与编译和打包。而 implementation 该依赖方式所依赖的库不会传递，只会在当前 module 中生效。api 该依赖方式会传递所依赖的库，当其他 module 依赖了该 module 时，可以使用该 module 下使用 api 依赖的库。&lt;/p>
&lt;p>其他常用的依赖声明还包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>provided（compileOnly）: 只在编译时有效，不会参与打包，典型的譬如 lombok 这样的预处理库。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>testCompile（testImplementation）: testCompile 只在单元测试代码的编译以及最终打包测试 apk 时有效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>debugCompile（debugImplementation）: debugCompile 只在 debug 模式的编译和最终的 debug apk 打包时有效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>releaseCompile（releaseImplementation）: Release compile 仅仅针对 Release 模式的编译和最终的 Release apk 打包。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>应用构建</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/4.java-%E5%AE%9E%E8%B7%B5/%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/</guid><description>&lt;h1 id="java--jvm-应用构建">Java &amp;amp; JVM 应用构建&lt;/h1>
&lt;p>一个 Java 项目的最简单的构建脚本应用了 Java 库插件，并可选择设置项目版本和选择要使用的 Java 工具链。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">plugins&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">id&lt;/span> &lt;span class="s1">&amp;#39;java-library&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">java&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">toolchain&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">languageVersion&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">JavaLanguageVersion&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">of&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">version&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;1.2.1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过应用 Java 库插件，你可以得到一大堆的功能。&lt;/p>
&lt;ul>
&lt;li>一个 compileJava 任务，编译&lt;code>src/main/java&lt;/code>下的所有 Java 源文件。&lt;/li>
&lt;li>为 &lt;code>src/test/java&lt;/code> 下的源文件制定的 &lt;code>compileTestJava&lt;/code> 任务&lt;/li>
&lt;li>一个&lt;code>test&lt;/code>任务，运行&lt;code>src/test/java&lt;/code>下的测试。&lt;/li>
&lt;li>一个 jar 任务，将&lt;code>src/main/resources&lt;/code>下的 main 编译的类和资源打包成一个名为&lt;code>&amp;lt;project&amp;gt;-&amp;lt;version&amp;gt;.jar&lt;/code>的 JAR。&lt;/li>
&lt;li>一个&lt;code>javadoc&lt;/code>任务，为&lt;code>main&lt;/code>类生成 Javadoc。&lt;/li>
&lt;/ul>
&lt;p>这并不足以构建任何非复杂的 Java 项目，至少，你可能会有一些文件的依赖性。但这意味着你的构建脚本只需要你的项目所特有的信息。&lt;/p>
&lt;h1 id="source-sets">Source sets&lt;/h1>
&lt;p>Gradle 的 Java 支持是第一个为构建基于源的项目引入新概念的：Source sets。其主要思想是，源文件和资源通常按类型进行逻辑分组，如应用程序代码、单元测试和集成测试。每个逻辑组通常都有自己的文件依赖性、classpaths 等的集合。值得注意的是，构成源文件集的文件不一定要位于同一个目录中，这一点很重要。&lt;/p>
&lt;p>Source sets 是一个强大的概念，它把编译的几个方面联系在一起。&lt;/p>
&lt;ul>
&lt;li>源文件和它们的位置&lt;/li>
&lt;li>编译的 classpath，包括任何必要的依赖关系&lt;/li>
&lt;li>编译后的类文件的位置&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/superbed/2021/07/17/60f27a4d5132923bf87800e7.png" alt="Source sets and Java compilation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>阴影框代表 Source sets 本身的属性。在此基础上，Java 库插件为你或插件定义的每个 Source sets 自动创建一个编译任务，名为 compileSourceSetJava 和几个依赖配置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Replaces conventional source code directory with list of different directories
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">sourceSets&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">main&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">java&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">srcDirs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;src&amp;#39;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Replaces conventional test source code directory with list of different directories
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">test&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">java&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">srcDirs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s1">&amp;#39;test&amp;#39;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Changes project output property to directory out
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">buildDir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;out&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在 Gradle 只会直接在 src 和 test 中搜索相应的源代码。如果你不想覆盖这个惯例，而只是想增加一个额外的源码目录，也许是包含一些你想保持独立的第三方源码的目录呢？语法是类似的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">sourceSets&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">main&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">java&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">srcDir&lt;/span> &lt;span class="s1">&amp;#39;thirdParty/src/main/java&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以指定直接在项目根目录下存放源代码文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">sourceSets&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">main&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">java&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">srcDirs&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;$projectDir&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">srcDirs&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;$projectDir/cadex&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java 项目通常包括源文件以外的资源，如属性文件，这些资源可能需要处理，例如替换文件中的令牌并打包到最终的 JAR 中。Java 库插件通过为每个定义的 Source sets 自动创建一个专门的任务来处理这个问题，这个任务叫做 processSourceSetResources（或者主 Source sets 的 processResources）。下图显示了 Source sets 是如何与这个任务配合的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/superbed/2021/07/17/60f27a955132923bf87aa4e6.png" alt="Processing non-source files for a source set" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>像以前一样，阴影框代表 Source sets 的属性，在这种情况下，它包括资源文件的位置和它们被复制到哪里。除了主 Source sets，Java 库插件还定义了一个测试 Source sets，代表项目的测试。这个 Source sets 被测试任务所使用，它运行测试。你可以在 Java 测试章节中了解更多关于这个任务和相关主题。&lt;/p>
&lt;p>项目通常将这个 Source sets 用于单元测试，但如果你愿意，你也可以将它用于集成、验收和其他类型的测试。另一种方法是为你的每个其他测试类型定义一个新的 Source sets，这通常是出于以下一个或两个原因。为了美观和可管理性，你想保持测试彼此分离，不同的测试类型需要不同的编译或运行时 classpaths 或其他一些设置上的差异&lt;/p>
&lt;h1 id="依赖管理">依赖管理&lt;/h1>
&lt;p>绝大多数的 Java 项目都依赖于库，所以管理项目的依赖关系是建立 Java 项目的一个重要部分。依赖关系管理是一个很大的话题，所以我们在这里将重点介绍 Java 项目的基础知识。为你的 Java 项目指定依赖关系只需要三条信息。&lt;/p>
&lt;ul>
&lt;li>你需要哪个依赖，例如名称和版本&lt;/li>
&lt;li>需要它做什么，比如说编译或运行&lt;/li>
&lt;li>在哪里可以找到它&lt;/li>
&lt;/ul>
&lt;p>前两个在依赖关系 {} 块中指定，第三个在资源库 {} 块中指定。例如，要告诉 Gradle 你的项目需要 3.6.7 版的 Hibernate Core 来编译和运行生产代码，并且要从 Maven Central 仓库下载该库，你可以使用下面的片段。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mavenCentral&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">dependencies&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">implementation&lt;/span> &lt;span class="s1">&amp;#39;org.hibernate:hibernate-core:3.6.7.Final&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这三个要素的 Gradle 术语如下。&lt;/p>
&lt;ul>
&lt;li>仓库&amp;quot;（例如：&amp;ldquo;mavenCentral()&amp;quot;）&amp;ndash;在那里可以找到你声明为依赖的模块&lt;/li>
&lt;li>配置&amp;rdquo;（ex: &lt;code>implementation&lt;/code>）&amp;ndash;命名的依赖关系集合，为特定目标（如编译或运行模块）而分组&amp;ndash;是 Maven 作用域的更灵活形式&lt;/li>
&lt;li>模块坐标&amp;quot;（例如：&lt;code>org.hibernate:hibernate-core-3.6.7.Final&lt;/code>）&amp;ndash;依赖关系的 ID，通常采用&amp;quot;&lt;code>&amp;lt;组&amp;gt;&lt;/code>:&lt;code>&amp;lt;模块&amp;gt;&lt;/code>:&lt;code>&amp;lt;版本&amp;gt;&lt;/code>&amp;ldquo;的形式（或 Maven 术语中的&amp;rdquo;&lt;code>&amp;lt;组ID&amp;gt;&lt;/code>:&lt;code>&amp;lt;工件ID&amp;gt;&lt;/code>:&lt;code>&amp;lt;版本&amp;gt;&lt;/code>&amp;quot;）。&lt;/li>
&lt;/ul>
&lt;p>你可以找到一份更全面的依赖性管理术语表&lt;a href="https://docs.gradle.org/current/userguide/dependency_management_terminology.html#dependency_management_terminology" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;p>就配置而言，主要有以下几种。&lt;/p>
&lt;ul>
&lt;li>&lt;code>compileOnly&lt;/code>&amp;ndash;用于编译生产代码所需的依赖项，但不应该成为运行时 classpath 的一部分。&lt;/li>
&lt;li>&lt;code>implementation&lt;/code> (取代&lt;code>compile&lt;/code>) - 用于编译和运行时。&lt;/li>
&lt;li>&lt;code>runtimeOnly&lt;/code> (取代&lt;code>runtime&lt;/code>) - 只在运行时使用，不用于编译&lt;/li>
&lt;li>&lt;code>testCompileOnly&lt;/code> - 与&lt;code>compileOnly&lt;/code>相同，只是用于测试。&lt;/li>
&lt;li>&lt;code>testImplementation&lt;/code> - 测试相当于&lt;code>implementation&lt;/code>。&lt;/li>
&lt;li>&lt;code>testRuntimeOnly&lt;/code>&amp;ndash;相当于&lt;code>runtimeOnly&lt;/code>的测试。&lt;/li>
&lt;/ul>
&lt;h1 id="编译">编译&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://lippiouyang.gitbooks.io/gradle-in-action-cn/content/images/dag12.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>现在你可以构建你的项目了，java 插件添加了一个 build 任务到你项目中，build 任务编译你的代码、运行测试然后打包成 jar 文件，所有都是按序执行的。运行 gradle build 之后你的输出应该是类似这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ gradle build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:compileJava
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:processResources UP-TO-DATE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:classes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:jar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:assemble
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:compileTestJava UP-TO-DATE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:processTestResources UP-TO-DATE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:testClasses UP-TO-DATE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:check
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出的每一行都表示一个可执行的任务，你可能注意到有一些任务标记为 UP_TO-DATE,这意味着这些任务被跳过了，gradle 能够自动检查哪些部分没有发生改变，就把这部分标记下来，省的重复执行。在大型的企业项目中可以节省不少时间。执行完 gradle build 之后项目结构应该是类似这样的：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://lippiouyang.gitbooks.io/gradle-in-action-cn/content/images/dag13.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://lippiouyang.gitbooks.io/gradle-in-action-cn/content/images/dag14.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在项目的根目录你可以找到一个 build 目录，这里包含了所有的输出，包含 class 文件，测试报告，打包的 jar 文件，以及一些用来归档的临时文件。如果你之前使用过 maven，它的标准输出是 target，这两个结构应该很类似。jar 文件目录 build/libs 下可以直接运行，jar 文件的名称直接由项目名称得来的。&lt;/p>
&lt;h2 id="自定义属性">自定义属性&lt;/h2>
&lt;p>Java 插件是一个非常固执的框架，对于项目很多的方面它都假定有默认值，比如项目布局，如果你看待世界的方法是不一样的，Gradle 给你提供了一个自定义约定的选项。想知道哪些东西是可以配置的？可以参考这个手册：http://www.gradle.org/docs/current/dsl/，之前提到过，运行命令行 gradle properties 可以列出可配置的标准和插件属性以及他们的默认值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Identifies project’sversion through a number scheme
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">version&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Sets Java version compilation compatibility to 1.6
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">sourceCompatibility&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1.6&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Adds Main-Class header to JAR file’s manifest
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">jar&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">manifest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">attributes&lt;/span> &lt;span class="s1">&amp;#39;Main-Class&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;com.manning.gia.todo.ToDoApp&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>打包成 JAR 之后，你会发现 JAR 文件的名称变成了 todo-app-0.1.jar，这个 jar 包含了 main-class 首部，你就可以通过命令 java -jar build/libs/todo-app-0.1.jar 运行了。&lt;/p>
&lt;h1 id="打包与发布">打包与发布&lt;/h1>
&lt;p>你如何打包并可能发布你的 Java 项目，取决于它是什么类型的项目：库、应用程序、Web 应用程序和企业应用程序都有不同的要求。默认情况下，Java Library Plugin 提供了 jar 任务，将所有编译好的生产类和资源打包成一个 JAR。这个 JAR 也是由 assemble 任务自动构建的。此外，如果需要的话，该插件可以被配置为提供 javadocJar 和 sourcesJar 任务来打包 Javadoc 和源代码。如果使用了一个发布插件，这些任务将在发布过程中自动运行，或者可以直接调用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">java&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">withJavadocJar&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">withSourcesJar&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你想创建一个 &amp;ldquo;超级&amp;rdquo;（又称 Fat）JAR，那么你可以使用这样的任务定义。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">plugins&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">id&lt;/span> &lt;span class="s1">&amp;#39;java&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">version&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;1.0.0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">repositories&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mavenCentral&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">dependencies&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">implementation&lt;/span> &lt;span class="s1">&amp;#39;commons-io:commons-io:2.6&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">tasks&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">register&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;uberJar&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Jar&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">archiveClassifier&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;uber&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">from&lt;/span> &lt;span class="n">sourceSets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">main&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">output&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dependsOn&lt;/span> &lt;span class="n">configurations&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">runtimeClasspath&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">from&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">configurations&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">runtimeClasspath&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">findAll&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">endsWith&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;jar&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">}.&lt;/span>&lt;span class="na">collect&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="n">zipTree&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改-jar-包元定义">修改 Jar 包元定义&lt;/h2>
&lt;p>Jar、War 和 Ear 任务的每个实例都有一个清单属性，允许您自定义进入相应存档的 MANIFEST.MF 文件。下面的例子演示了如何在 JAR 的清单中设置属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-groovy" data-lang="groovy">&lt;span class="line">&lt;span class="cl">&lt;span class="n">jar&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">manifest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">attributes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;Implementation-Title&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;Gradle&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Implementation-Version&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">archiveVersion&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>您还可以创建 Manifest 的独立实例。这样做的一个原因是为了在 JAR 之间共享清单信息。下面的例子演示了如何在 JAR 之间共享共同属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sharedManifest&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">manifest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">attributes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Implementation-Title&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s">&amp;#34;Gradle&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Implementation-Version&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">version&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">tasks&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">register&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">fooJar&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Jar&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">manifest&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">project&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">manifest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">from&lt;/span> &lt;span class="n">sharedManifest&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另一个可供您使用的选项是将舱单合并到一个舱单对象中。这些源清单的形式可以是文本，也可以是另一个 Manifest 对象。在下面的例子中，源清单都是文本文件，只有 sharedManifest 除外，它是前面例子中的清单对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">tasks&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">register&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">barJar&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Jar&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">manifest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">attributes&lt;/span> &lt;span class="n">key1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">value1&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">from&lt;/span> &lt;span class="n">sharedManifest&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">basemanifest&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">txt&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">from&lt;/span>&lt;span class="o">([&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">javabasemanifest&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">txt&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libbasemanifest&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">txt&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">eachEntry&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="n">details&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">details&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">baseValue&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">details&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">mergeValue&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">details&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">baseValue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">details&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">key&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">details&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">exclude&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>