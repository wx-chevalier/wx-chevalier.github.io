<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>基础配置 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</link><atom:link href="https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/index.xml" rel="self" type="application/rss+xml"/><description>基础配置</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>基础配置</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</link></image><item><title>快速开始</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</guid><description>&lt;h1 id="安装与配置">安装与配置&lt;/h1>
&lt;p>Maven 的安装也非常方便，可从 Apache 官方下载最新的 Maven 压缩包然后解压，也可以使用 &lt;a href="http://sdkman.io/" target="_blank" rel="noopener">SDK Man&lt;/a> 执行安装；如果是手动配置的话我们还需要配置设置下系统的环境变量：&lt;/p>
&lt;ul>
&lt;li>M2HOME: 指向 Maven 安装目录&lt;/li>
&lt;li>Path: 追加 Maven 安装目录下的 bin 目录&lt;/li>
&lt;/ul>
&lt;p>在用户目录下，我们可以发现 .m2 文件夹。默认情况下，该文件夹下放置了 Maven 本地仓库 .m2/repository。所有的 Maven 构件(artifact)都被存储到该仓库中，以方便重用。默认情况下，~/.m2 目录下除了 repository 仓库之外就没有其他目录和文件了，不过大多数 Maven 用户需要复制 M2HOME/conf/settings.xml 文件到 ~/.m2/settings.xml。&lt;/p>
&lt;p>部分常用的 Maven 命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看maven版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mvn -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 编译&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mvn compile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 测试&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mvn &lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 打包&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mvn package
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除 target&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mvn clean
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装jar包到本地仓库中&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mvn install
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建一个新工程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mvn archetype:generate -DgroupId&lt;span class="o">=&lt;/span>com.mycompany.app -DartifactId&lt;span class="o">=&lt;/span>my-app -DarchetypeArtifactId&lt;span class="o">=&lt;/span>maven-archetype-quickstart -DarchetypeVersion&lt;span class="o">=&lt;/span>1.4 -DinteractiveMode&lt;span class="o">=&lt;/span>&lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="网络代理">网络代理&lt;/h1>
&lt;p>众所周知的原因，国内有时候并不能够很顺畅的访问 Maven 的中央仓库，往往我们需要访问国内的镜像地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;mirror&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;id&amp;gt;&lt;/span>CN&lt;span class="nt">&amp;lt;/id&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>OSChina Central&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;url&amp;gt;&lt;/span>http://maven.oschina.net/content/groups/public/&lt;span class="nt">&amp;lt;/url&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;mirrorOf&amp;gt;&lt;/span>central&lt;span class="nt">&amp;lt;/mirrorOf&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/mirror&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者编辑 ~/.m2/settings.xml 文件(如果没有该文件，则复制 $M2HOME/conf/settings.xml)，添加代理配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;settings&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;proxies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;proxy&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;id&amp;gt;&lt;/span>my-proxy&lt;span class="nt">&amp;lt;/id&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;active&amp;gt;&lt;/span>true&lt;span class="nt">&amp;lt;/active&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;protocol&amp;gt;&lt;/span>http&lt;span class="nt">&amp;lt;/protocol&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;host&amp;gt;&lt;/span>代理服务器主机名&lt;span class="nt">&amp;lt;/host&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;port&amp;gt;&lt;/span>端口号&lt;span class="nt">&amp;lt;/port&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c">&amp;lt;!--
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"> &amp;lt;username&amp;gt;***&amp;lt;/username&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"> &amp;lt;password&amp;gt;***&amp;lt;/password&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"> &amp;lt;nonProxyHosts&amp;gt;repository.mycom.com|*.google.com&amp;lt;/nonProxyHosts&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/proxy&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/proxies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/settings&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果不行试试重启机器或者 eclipse 等 ide 还不行试试下面这种方式：windows&amp;ndash;&amp;gt;preferences&amp;ndash;&amp;gt;maven&amp;ndash;&amp;gt;installations add&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://outofmemory.cn/ugc/upload/00/20/20130620/maven-config.png" alt="maven config" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这样配置后将使用指定目录下的 maven，而非 eclipse 的 maven 内置插件。&lt;/p></description></item><item><title>生命周期</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>&lt;h1 id="生命周期">生命周期&lt;/h1>
&lt;p>Maven 对构建(build)的过程进行了抽象和定义，这个过程被称为构建的生命周期(lifecycle)。生命周期(lifecycle)由多个阶段(phase)组成,每个阶段(phase)会挂接一到多个 goal。goal 是 maven 里定义任务的最小单元，相当于 ant 里的 target。&lt;/p>
&lt;p>Maven 的生命周期就是对所有的构建过程进行抽象和统一。包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有的构建步骤。Maven 的生命周期是抽象的，即生命周期不做任何实际的工作，实际任务由插件完成，类似于设计模式中的模板方法。&lt;/p>
&lt;h2 id="核心概念">核心概念&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>lifecycle：生命周期，这是 maven 最高级别的的控制单元，它是一系列的 phase 组成，也就是说，一个生命周期，就是一个大任务的总称，不管它里面分成多少个子任务，反正就是运行一个 lifecycle，就是交待了一个任务，运行完后，就得到了一个结果，中间的过程，是 phase 完成的，自己可以定义自己的 lifecycle，包含自己想要的 phase。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>phase：可以理解为任务单元，lifecycle 是总任务，phase 就是总任务分出来的一个个子任务，但是这些子任务是被规格化的，它可以同时被多个 lifecycle 所包含，一个 lifecycle 可以包含任意个 phase，phase 的执行是按顺序的，一个 phase 可以绑定很多个 goal，至少为一个，没有 goal 的 phase 是没有意义的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>goal: 这是执行任务的最小单元，它可以绑定到任意个 phase 中，一个 phase 有一个或多个 goal，goal 也是按顺序执行的，一个 phase 被执行时，绑定到 phase 里的 goal 会按绑定的时间被顺序执行，不管 phase 己经绑定了多少个 goal，你自己定义的 goal 都可以继续绑到 phase 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mojo: lifecycle 与 phase 与 goal 都是概念上的东西，mojo 才是做具体事情的，可以简单理解 mojo 为 goal 的实现类，它继承于 AbstractMojo，有一个 execute 方法，goal 等的定义都是通过在 mojo 里定义一些注释的 anotation 来实现的，maven 会在打包时，自动根据这些 anotation 生成一些 xml 文件，放在 plugin 的 jar 包里。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>抛开 mojo 不讲，lifecycle 与 phase 与 goal 就是级别的大小问题，引用必须是从高级引用下级（goal 绑定到 phase，也可理间为 phase 引用 goal，只是在具体绑定时，不会 phase 定义引用哪些 goal，但是执行是，却是 phase 调用绑定到它那的 goal），也不能跨级引用，如 lifecycle 可以引用任意的 phase，不同 lifecycle 可以同时引用相同的 phase，lifecycle 不能跨级引用 goal。goal 会绑定到任意的 phase 中，也就是说不同的 phase 可以同时引用相同的 goal，所以 goal 可以在一个 lifecycle 里被重复执行哦，goal 自然也不能说绑定到 lifecycle 中，它们三者的关系可以用公司里的 总领导，组领导，与职员的关系来解释。&lt;/p>
&lt;p>lifecycle 的 phase 执行会指向之前所有的 phase，然后执行当前指定的 phase，一个 phase 会引用至少一个 goal。plugin 中的 goal 只是单单执行当前指定的 goal。执行 install:install 只会执行 installplugin 中的 goal:install，但是项目创建后还没有进行之前必要的步骤，比如 complie。这样直接执行 install:install 是肯定会出错的。&lt;/p>
&lt;h2 id="三套生命周期">三套生命周期&lt;/h2>
&lt;p>Maven 有三套相互独立的生命周期，分别是 clean、default 和 site。每个生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。&lt;/p>
&lt;ul>
&lt;li>clean 生命周期：清理项目，包含三个 phase：&lt;/li>
&lt;/ul>
&lt;p>1）pre-clean：执行清理前需要完成的工作
2）clean：清理上一次构建生成的文件
3）post-clean：执行清理后需要完成的工作&lt;/p>
&lt;ul>
&lt;li>default 生命周期：构建项目，重要的 phase 如下：&lt;/li>
&lt;/ul>
&lt;p>1）validate：验证工程是否正确，所有需要的资源是否可用。
2）compile：编译项目的源代码。
3）test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。
4）package：把已编译的代码打包成可发布的格式，比如 jar。
5）integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。
6）verify：运行所有检查，验证包是否有效且达到质量标准。
7）install：把包安装到 maven 本地仓库，可以被其他工程作为依赖来使用。
8）deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的 repository，使得其他的开发者或者工程可以共享。&lt;/p>
&lt;ul>
&lt;li>site 生命周期：建立和发布项目站点，phase 如下：&lt;/li>
&lt;/ul>
&lt;p>1）pre-site：生成项目站点之前需要完成的工作
2）site：生成项目站点文档
3）post-site：生成项目站点之后需要完成的工作
4）site-deploy：将项目站点发布到服务器&lt;/p>
&lt;p>各个生命周期相互独立，一个生命周期的阶段前后依赖。举例如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>mvn clean：调用 clean 生命周期的 clean 阶段，实际执行 pre-clean 和 clean 阶段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mvn test：调用 default 生命周期的 test 阶段，实际执行 test 以及之前所有阶段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mvn clean install：调用 clean 生命周期的 clean 阶段和 default 的 install 阶段，实际执行 pre-clean 和 clean，install 以及之前所有阶段&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="mojo">Mojo&lt;/h2>
&lt;h3 id="以-phase-为目标构建">以 phase 为目标构建&lt;/h3>
&lt;p>以 phase 为目标进行构建是最常见的，如我们平时经常执行的 mvn compile,mvn test,mvn package&amp;hellip; 等等,compile,test,package 都是 maven 生命周期(lifecycle)里的 phase,通过 mvn 命令，你可以指定一次构建执行到那一个阶段，在执行过程中，所有经历的执行阶段(phase)上绑定的 goal 都将得到执行。例如，对于一个 jar 包应用，当执行 mvn package 命令时，maven 从 validate 阶段一个阶段一个阶段的执行，在执行到 compile 阶段时，compiler 插件的 compile goal 会被执行，因为这个 goal 是绑定在 compile 阶段(phase)上的。这一点可从其对应的 mojo 类上得知：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/12/17/QouCDS.png" alt="CompilerMojo" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>再比如经常使用的打包插件 shade，它的 goal 是绑定到 package 阶段的，这样，使用 mvn package 进行打包时都会执行 shade 的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/12/17/QoulE4.png" alt="ShareMojo" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="以-goal-为目标构建">以 goal 为目标构建&lt;/h3>
&lt;p>虽然以 phase 为目标的构建最常见，但是有时候我们会发现，一些插件的 goal 并不适合绑定到任何阶段(phase)上，或者是，这些 goal 往往是单独执行，不需要同某个阶段(phase)绑定在一起，比如 hibernate 插件的导入\导出 goal 多数情况下是根据需要要手动执行的(当然，也可以绑定到某个阶段上，比如进行单元测试时，可考虑将其绑定到 test 阶段上)。再比如 jetty(6.1.26)插件，它的 goal 都是将打包或未打包的工程部署到 jetty 里然后启动 jetty 容器的，多数情况下，人们都是独立运行这些 goal 的，比如：人们希望当键入 mvn jetty:run 后，工程就能完成编译后启动 jetty,而 jetty 插件也确实是这样做的，它的 run goal 的 mojo 是这样声明的：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/12/17/QouJ81.png" alt="Jetty6RunMojo" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其中@execute phase=&amp;ldquo;test-compile&amp;quot;指明 jetty:run 这一 goal 会促使 maven 先 build 到 test-compile 阶段，再执行这个 goal.同样，对于 jetty:run-war 这个 goal 则要求先 build 到 package 阶段再执行该 goal。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/12/17/QouD5d.png" alt="Jetty6RunWar" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而另外一个例子是 exec 插件的 exec:java：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/12/17/Qou62t.png" alt="ExecJavaMojo" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个 goal 也声明了 execute 的 phase,但却是 validate，这样，如果代码没有编译，执行这个 goal 就会出错，所以多数情况下，人们总是使用下面的方式执行的：&lt;code>mvn clean compile exec:java&lt;/code>。&lt;/p></description></item><item><title>项目结构</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="maven-项目结构">Maven 项目结构&lt;/h1>
&lt;p>就像 Make 的 Makefile，Ant 的 build.xml 一样，Maven 项目的核心是 pom.xml。首先创建一个名为 hello-world 的文件夹，打开该文件夹，新建一个名为 pom.xml 的文件，输入其内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;project&lt;/span> &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">xmlns:xsi=&lt;/span>&lt;span class="s">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">xsi:schemaLocation=&lt;/span>&lt;span class="s">&amp;#34;http://maven.apache.org/POM/4.0.0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">http://maven.apache.org/maven-v4_0_0.xsd&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span class="nt">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>com.wx.mvn&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>hello-world&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.0-SNAPSHOT&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;name&amp;gt;&lt;/span>Maven Hello World Project&lt;span class="nt">&amp;lt;/name&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="文件结构">文件结构&lt;/h1>
&lt;ul>
&lt;li>代码的第一行是 XML 头，指定了该 xml 文档的版本和编码方式。紧接着是 project 元素，project 是所有 pom.xml 的根元素，它还声明了一些 POM 相关的命名空间及 xsd 元素，虽然这些属性不是必须的，但使用这些属性能够让第三方工具(如 IDE 中的 XML 编辑器)帮助我们快速编辑 POM。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>根元素下的第一个子元素 modelVersion 指定了当前 POM 模型的版本，对于 Maven 2 及 Maven 3 来说，它只能是 4.0.0。这段代码中最重要的是 groupId，artifactId 和 version 三行。这三个元素定义了一个项目基本的坐标，在 Maven 的世界，任何的 jar、pom 或者 war 都是以基于这些基本的坐标进行区分的。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>groupId 定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联，譬如你在 googlecode 上建立了一个名为 myapp 的项目，那么 groupId 就应该是 com.googlecode.myapp，如果你的公司是 mycom，有一个项目为 myapp，那么 groupId 就应该是 com.mycom.myapp。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>artifactId 定义了当前 Maven 项目在组中唯一的 ID，我们为这个 Hello World 项目定义 artifactId 为 hello-world，本书其他章节代码会被分配其他的 artifactId。而在前面的 groupId 为 com.googlecode.myapp 的例子中，你可能会为不同的子项目(模块)分配 artifactId，如：myapp-util、myapp-domain、myapp-web 等等。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>version 指定了 Hello World 项目当前的版本——1.0-SNAPSHOT。SNAPSHOT 意为快照，说明该项目还处于开发中，是不稳定的版本。随着项目的发展，version 会不断更新，如升级为 1.0、1.1-SNAPSHOT、1.1、2.0 等等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后一个 name 元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但我还是推荐为每个 POM 声明 name，以方便信息交流。没有任何实际的 Java 代码，我们就能够定义一个 Maven 项目的 POM，这体现了 Maven 的一大优点，它能让项目对象模型最大程度地与实际代码相独立，我们可以称之为解耦，或者正交性，这在很大程度上避免了 Java 代码和 POM 代码的相互影响。比如当项目需要升级版本时，只需要修改 POM，而不需要更改 Java 代码；而在 POM 稳定之后，日常的 Java 代码开发工作基本不涉及 POM 的修改。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="变量替换">变量替换&lt;/h2>
&lt;p>在 pom.xml 定义 properties 标签&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;properties&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;project.build.sourceEncoding&amp;gt;&lt;/span>UTF-8&lt;span class="nt">&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;spring.version&amp;gt;&lt;/span>1.2.6&lt;span class="nt">&amp;lt;/spring.version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;developer.organization&amp;gt;&lt;/span>&lt;span class="cp">&amp;lt;![CDATA[xy公司]]&amp;gt;&lt;/span>&lt;span class="nt">&amp;lt;/developer.organization&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上内容就改成了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>spring-core&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>${spring.version}&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>spring-aop&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>${spring.version}&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用 &lt;a href="http://www.mojohaus.org/properties-maven-plugin/plugin-info.html" target="_blank" rel="noopener">maven-properties&lt;/a> 插件来支持外部变量&lt;/p>
&lt;h1 id="目录结构">目录结构&lt;/h1>
&lt;p>项目主代码和测试代码不同，项目的主代码会被打包到最终的构件中(比如 jar)，而测试代码只在运行测试时用到，不会被打包。默认情况下，Maven 假设项目主代码位于 &lt;code>src/main/java&lt;/code> 目录，我们遵循 Maven 的约定，创建该目录，然后在该目录下创建文件 &lt;code>com/wx/mvn/helloworld/HelloWorld.java&lt;/code>，其内容如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nn">com.wx.mvn.helloworld&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">HelloWorld&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Hello Maven&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">HelloWorld&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于该 Java 代码有两点需要注意。首先，大部分情况下我们应该把项目主代码放到 src/main/java/ 目录下(遵循 Maven 的约定)，而无须额外的配置，Maven 会自动搜寻该目录找到项目主代码。其次，该 Java 类的包名是 com.wx.mvn.helloworld，这与我们之前在 POM 中定义的 groupId 和 artifactId 相吻合。一般来说，项目中 Java 类的包都应该基于项目的 groupId 和 artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或者 Java 类。代码编写完毕后，我们使用 Maven 进行编译，在项目根目录下运行命令 &lt;code>mvn clean compile&lt;/code> 即可。Maven 首先执行了 clean:clean 任务，删除 target/ 目录，默认情况下 Maven 构建的所有输出都在 target/ 目录中；接着执行 resources:resources 任务(未定义项目资源，暂且略过)；最后执行 compiler:compile 任务，将项目主代码编译至 target/classes 目录(编译好的类为 com/wx/mvn/helloworld/HelloWorld.Class)。&lt;/p>
&lt;h2 id="仓库配置">仓库配置&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://hengyunabc.github.io/img/maven-repositories.png" alt="Maven Repos" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>下面介绍一些 Maven 仓库工作的原理。典型的一个 Maven 依赖下会有这三个文件：&lt;/p>
&lt;pre tabindex="0">&lt;code>maven-metadata.xml
maven-metadata.xml.md5
maven-metadata.xml.sha1
&lt;/code>&lt;/pre>&lt;p>maven-metadata.xml 里面记录了最后 deploy 的版本和时间。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;metadata&lt;/span> &lt;span class="na">modelVersion=&lt;/span>&lt;span class="s">&amp;#34;1.1.0&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.github.hengyunabc&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>mybatis-ehcache-spring&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>0.0.1-SNAPSHOT&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;versioning&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;snapshot&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;timestamp&amp;gt;&lt;/span>20150804.095005&lt;span class="nt">&amp;lt;/timestamp&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;buildNumber&amp;gt;&lt;/span>1&lt;span class="nt">&amp;lt;/buildNumber&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/snapshot&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;lastUpdated&amp;gt;&lt;/span>20150804095005&lt;span class="nt">&amp;lt;/lastUpdated&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/versioning&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/metadata&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 md5, sha1 校验文件是用来保证这个 meta 文件的完整性。Maven 在编绎项目时，会先尝试请求 maven-metadata.xml，如果没有找到，则会直接尝试请求到 jar 文件，在下载 jar 文件时也会尝试下载 jar 的 md5, sha1 文件。Maven 的 repository 并没有优先级的配置，也不能单独为某些依赖配置 repository。所以如果项目配置了多个 repository，在首次编绎时，会依次尝试下载依赖。如果没有找到，尝试下一个，整个流程会很长。所以尽量多个依赖放同一个仓库，不要每个项目都有一个自己的仓库。如果想要使用本地 file 仓库里，在项目的 pom.xml 里配置，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;repositories&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;repository&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;id&amp;gt;&lt;/span>hengyunabc-maven-repo&lt;span class="nt">&amp;lt;/id&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;url&amp;gt;&lt;/span>file:/home/hengyunabc/code/maven-repo/repository/&lt;span class="nt">&amp;lt;/url&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/repository&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/repositories&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>依赖调停</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E4%BE%9D%E8%B5%96%E8%B0%83%E5%81%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E4%BE%9D%E8%B5%96%E8%B0%83%E5%81%9C/</guid><description>&lt;h1 id="dependency-mediation--依赖调停">Dependency Mediation | 依赖调停&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://www.yiibai.com/uploads/allimg/131228/212042K00-0.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>传递性依赖是在 Maven 中添加的新特征，这个特征的作用就是你不需要考虑你依赖的库文件所需要依赖的库文件，能够将依赖模块的依赖自动的引入。例如我们依赖于 Spring 的库文件，但是 Spring 本身也有依赖，如果没有传递性依赖那就需要我们了解 Spring 项目依赖，然后也要添加到我们的项目中。&lt;/p>
&lt;p>由于没有限制依赖的数量，如果出现循环依赖的时候会出现问题，这个时候有两种方式处理，一种是通过 build-helper-maven-plugin 插件来规避，另一种就是重构两个相互依赖的项目。通过传递性依赖，项目的依赖结构能够很快生成。但是因为这个新的特性会有一些其他的特性被添加进来来限制由于传递性依赖所引入的包。&lt;/p>
&lt;p>依赖调节：如果在一个项目里面出现不同的模块，依赖了一个项目的不同版本的时候判断依赖的版本。Maven 的时候仅仅支持最近原则也就是在依赖树中的最靠近项目的版本作为依赖版本。到了 Maven 的时候又提出了一个最先声明原则，也就是在项目中被最早声明的被判断为依赖的版本。&lt;/p>
&lt;p>同一个 jar 包，又会有不同的版本，当你所依赖的 jar 有不同的版本的时候，比如你的 A 项目: &lt;code>A -&amp;gt; B -&amp;gt; C -&amp;gt; D 2.0 and A -&amp;gt; E -&amp;gt; D 1.0&lt;/code>。这就出现了冲突，你当然也可以再 A 里面配置指定依赖 D2.0。如果你没在 A 的 pom 里面配置指定用哪一个。maven 会替你找一个近的，即 D1.0。&lt;/p>
&lt;h2 id="excluded--optional-dependencies--排除依赖于可选依赖">Excluded &amp;amp; Optional Dependencies | 排除依赖于可选依赖&lt;/h2>
&lt;p>可选依赖使用的情况是对于某个依赖来说系统只有在某个特定的情况下使用到它。例如数据库驱动，有 mysql 的，oracle 的。只有在我们使用到 mysql 的时候才会被使用。&lt;/p>
&lt;h1 id="排包">排包&lt;/h1>
&lt;p>再次回顾下 Maven 中的包依赖规则如下：&lt;/p>
&lt;ul>
&lt;li>compile（默认使用）：编译依赖范围，编译、测试、运行都生效；&lt;/li>
&lt;li>test：测试依赖范围，只在测试的 classpath 有效，比如我们常用的 JUnit；&lt;/li>
&lt;li>provided：只对编译和测试有效，对运行无效，常用于容器提供了的运行环境；&lt;/li>
&lt;li>runtime：运行时依赖范围，比如 JDBC 驱动，编译和测试时不需要，只需要使用 JDK 提供的 JDBC 接口；&lt;/li>
&lt;li>system：系统依赖范围，依赖 Maven 仓库以外的依赖。&lt;/li>
&lt;/ul>
&lt;h2 id="仲裁规则">仲裁规则&lt;/h2>
&lt;ul>
&lt;li>第一原则：路径最短优先选中，将 pom 文件默认为一个树形结构，路径节点从根出发。&lt;/li>
&lt;/ul>
&lt;p>假设：路径 1 是：A-&amp;gt;B-&amp;gt;C-&amp;gt;D(version1.0)，路径 2 是：A-&amp;gt;B-&amp;gt;D(version2.0)。由于路径 2 的长度小于路径 1，所以结果就是 A 会传递性依赖 D(version2.0)，当路径长度相等的时候，使用第二原则&lt;/p>
&lt;ul>
&lt;li>第二原则：先声明者优先原则&lt;/li>
&lt;/ul>
&lt;p>当路径长度相同时候，就要使用第二原则。假设：路径 1 不变依然是：A-&amp;gt;B-&amp;gt;C-&amp;gt;D(version1.0)，路径 2 是：A-&amp;gt;B-&amp;gt;E-&amp;gt;D(version2.0)，由于路径 1 在路径 2 前面声明，所以结果就是 A 会传递性依赖 D(version1.0)。&lt;/p>
&lt;ul>
&lt;li>第三原则：冲突 jar 句柄顺序随机原则&lt;/li>
&lt;/ul>
&lt;p>如果系统自己已经在 target 目录中加载了有冲突的 jar 包，并且机器有一定概率可以启动成功，主要是当打包的时候包会打印到 target 目录中，编译机器和目标机器执行了打包上传解压，在这个过程中就会引起互相冲突的 jar 在目标机器上排序，系统启动的时候，加载包的顺序就是随机的。&lt;/p>
&lt;h2 id="项目排包">项目排包&lt;/h2>
&lt;p>&lt;code>mvn dependency:tree&amp;gt;tree.log&lt;/code> 直接执行这个命令，基本上只能先优先看一下总体的依赖状况，做整体评估，然后根据系统日志报错信息反查。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动时直接报错，java.lang.ClassNotFoundException ,或者方法不存在：这种比较简单，直接查找该类在哪个包中，相互冲突的基本上在两个 jar 包内就可以确定，基本手段：排除低版本，选择和自己 Java 代码一致使用的，排除和业务代码无关的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类路径长度统计，版本就高不就低。这点需要找到有疑似冲突的，做一个简单的统计，常常新版本的会解决之前的问题，但是也有一个潜在的风险，高版本的可能引入了更多有可能的冲突，因此，高版本的尽量遵循业务无关的类库，如果和业务有关，尽量把两个版本的依赖树都保存以做比对，或者和具体业务负责人确认改动点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>隐含错误加上调试参数：&lt;code>mvn +X dependency:tree&amp;gt;tree.log&lt;/code>，这样根据报错信息可以更精确的定位到错误或者冲突。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>依赖管理</title><link>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/4.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="maven-中的依赖管理">Maven 中的依赖管理&lt;/h1>
&lt;p>依赖管理是 Maven 的一大特征，对于一个简单的项目，对依赖的管理并不是什么困难的事，但是如果这个项目依赖的库文件达到几十个甚至于上百个的时候就不是一个简单的问题了。在这个时候 Maven 对于依赖管理的作用就显露出来了。下面主要讨论几个方面的内容：传递性依赖，依赖范围，依赖管理，系统依赖，可选依赖&lt;/p>
&lt;p>Maven 使用 dependencyManagement 元素来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父 POM 中看到 dependencyManagement 元素。使用 pom.xml 中的 dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。Maven 会沿着父子层次向上走，直到找到一个拥有 dependencyManagement 元素的项目，然后它就会使用在这个 dependencyManagement 元素中指定的版本号。&lt;/p>
&lt;p>例如在父项目里：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependencyManagement&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>5.1.2&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependencyManagement&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在子项目里就可以添加 mysql-connector 时可以不指定版本号，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时在 dependenceManagement 种，也可以从外部导入 POM 文件中的依赖项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependencyManagement&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c">&amp;lt;!-- Import dependency management from Spring Boot --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-dependencies&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.3.0.RC1&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;type&amp;gt;&lt;/span>pom&lt;span class="nt">&amp;lt;/type&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>import&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependencyManagement&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="dependency-scope">Dependency Scope&lt;/h1>
&lt;p>Maven 有三套 classpath(编译 classpath，运行 classpath，测试 classpath)分别对应构建的三个阶段。依赖范围就是控制依赖与这三套 classpath 的关系。依赖范围有六种。在 POM 4 中，&lt;code>&amp;lt;dependency&amp;gt;&lt;/code> 中还引入了 &lt;code>&amp;lt;scope&amp;gt;&lt;/code>，它主要管理依赖的部署。目前 &lt;code>&amp;lt;scope&amp;gt;&lt;/code> 可以使用 5 个值:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>compile，缺省值，适用于所有阶段，会随着项目一起发布。compile 是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的 classpath 中可用，同时它们也会被打包。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>provided，provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用。例如，如果你开发了一个 web 应用，你可能在编译 classpath 中需要可用的 ServletAPI 来编译一个 servlet，但是你不会想要在打包好的 WAR 中包含这个 ServletAPI；这个 Servlet API JAR 由你的应用服务器或者 servlet 容器提供。已提供范围的依赖在编译 classpath(不是运行时)可用。它们不是传递性的，也不会被打包。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>runtime，runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要 JDBC API JAR，而只有在运行的时候才需要 JDBC 驱动实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>system，system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的(你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>javax.sql&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>jdbc-stdext&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>2.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>system&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;systemPath&amp;gt;&lt;/span>${java.home}/lib/rt.jar&lt;span class="nt">&amp;lt;/systemPath&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-system-依赖范围">使用 system 依赖范围&lt;/h2>
&lt;p>在下文中会有对于依赖的 scope 的详细解释，这里只需要知道如果将 scope 设置为了 system 即是自动在本地路径中寻找依赖的 Jar 包即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>dnsns&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>dnsns&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>system&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;systemPath&amp;gt;&lt;/span>${project.basedir}/src/lib/dnsns.jar&lt;span class="nt">&amp;lt;/systemPath&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>localedata&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>localedata&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>system&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;systemPath&amp;gt;&lt;/span>${project.basedir}/src/lib/localedata.jar&lt;span class="nt">&amp;lt;/systemPath&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>sunjce_provider&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>sunjce_provider&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>system&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;systemPath&amp;gt;&lt;/span>${project.basedir}/src/lib/sunjce_provider.jar&lt;span class="nt">&amp;lt;/systemPath&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>sunpkcs11&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>sunpkcs11&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;scope&amp;gt;&lt;/span>system&lt;span class="nt">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;systemPath&amp;gt;&lt;/span>${project.basedir}/src/lib/sunpkcs11.jar&lt;span class="nt">&amp;lt;/systemPath&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="maven-install-plugin">maven-install-plugin&lt;/h1>
&lt;p>maven-install-plugin 默认绑定在 maven 的生命周期 install 阶段。该插件有三个 goals:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>install:install 即默认的 maven install 执行的命令，用来自动地将本项目的主 artifact 以及它的附件如 source，doc 安装到本地的仓库中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>install:install-file 作为 install 的补充，安装你指定的文件到本地仓库。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>install:help 本插件的帮助信息。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.maven.plugins&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>maven-install-plugin&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>**&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>