<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>内置工具 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/06.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7/</link><atom:link href="https://ng-tech.icu/books/java-series/06.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><description>内置工具</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>内置工具</title><link>https://ng-tech.icu/books/java-series/06.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7/</link></image><item><title>jstack</title><link>https://ng-tech.icu/books/java-series/06.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7/jstack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/06.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7/jstack/</guid><description>&lt;h1 id="jstack">jstack&lt;/h1>
&lt;p>jstack 命令主要用于调试 java 程序运行过程中的线程堆栈信息，可以用于检测死锁，进程耗用 cpu 过高报警问题的排查。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ jstack
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Usage:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> jstack &lt;span class="o">[&lt;/span>-l&lt;span class="o">]&lt;/span> &amp;lt;pid&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> jstack -F &lt;span class="o">[&lt;/span>-m&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-l&lt;span class="o">]&lt;/span> &amp;lt;pid&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Options:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> -F 强制dump线程堆栈信息. 用于进程hung住，jstack &amp;lt;pid&amp;gt;命令没有响应的情况
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> -m 同时打印java和本地&lt;span class="o">(&lt;/span>native&lt;span class="o">)&lt;/span>线程栈信息，m是mixed mode的简写
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> -l 打印锁的额外信息
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="典型用法">典型用法&lt;/h1>
&lt;p>jstack 的典型用法如下：&lt;/p>
&lt;ul>
&lt;li>qmq 是部署在 tomcat 中的应用名&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ ps -ef &lt;span class="p">|&lt;/span> grep qmq &lt;span class="p">|&lt;/span> grep -v grep
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>拿到进程号，例如上面对应的是 3192&lt;/p>
&lt;ul>
&lt;li>第二步找出该进程内最耗费 CPU 的线程，可以使用 ps -Lfp pid 或者 ps -mp pid -o THREAD, tid, time 或者 top -Hp pid。例如用第三个 top -Hp 3192：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">Tasks: &lt;span class="m">123&lt;/span> total, &lt;span class="m">0&lt;/span> running, &lt;span class="m">123&lt;/span> sleeping, &lt;span class="m">0&lt;/span> stopped, &lt;span class="m">0&lt;/span> zombie
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cpu&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span>: 0.3%us, 0.4%sy, 0.0%ni, 99.3%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Mem: 3922688k total, 3272588k used, 650100k free, 432768k buffers
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Swap: 4194296k total, 0k used, 4194296k free, 596488k cached
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3494&lt;/span> tomcat &lt;span class="m">20&lt;/span> &lt;span class="m">0&lt;/span> 4905m 1.1g 11m S 0.3 28.4 0:51.91 java
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3551&lt;/span> tomcat &lt;span class="m">20&lt;/span> &lt;span class="m">0&lt;/span> 4905m 1.1g 11m S 0.3 28.4 4:46.32 java
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3588&lt;/span> tomcat &lt;span class="m">20&lt;/span> &lt;span class="m">0&lt;/span> 4905m 1.1g 11m S 0.3 28.4 0:07.35 java
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3192&lt;/span> tomcat &lt;span class="m">20&lt;/span> &lt;span class="m">0&lt;/span> 4905m 1.1g 11m S 0.0 28.4 0:00.00 java
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3194&lt;/span> tomcat &lt;span class="m">20&lt;/span> &lt;span class="m">0&lt;/span> 4905m 1.1g 11m S 0.0 28.4 0:00.82 java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>TIME 列就是各个 Java 线程耗费的 CPU 时间，CPU 时间最长的是线程 ID 为 3551 的线程，用 &lt;code>printf &amp;quot;%x\n&amp;quot; 3551&lt;/code> 得到 ddf&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sudo -u tomcat jstack 3192 | grep ddf&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;New I/O worker #30&amp;#34;&lt;/span> daemon &lt;span class="nv">prio&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">10&lt;/span> &lt;span class="nv">tid&lt;/span>&lt;span class="o">=&lt;/span>0x00007f44fd525800 &lt;span class="nv">nid&lt;/span>&lt;span class="o">=&lt;/span>0xde4 runnable &lt;span class="o">[&lt;/span>0x00007f4530ddf000&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;DubboResponseTimeoutScanTimer&amp;#34;&lt;/span> daemon &lt;span class="nv">prio&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">10&lt;/span> &lt;span class="nv">tid&lt;/span>&lt;span class="o">=&lt;/span>0x00007f44fca88000 &lt;span class="nv">nid&lt;/span>&lt;span class="o">=&lt;/span>0xddf waiting on condition &lt;span class="o">[&lt;/span>0x00007f45322e5000&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="线程信息详解">线程信息详解&lt;/h1>
&lt;p>jstack 命令会打印出所有的线程，包括用户自己启动的线程和 jvm 后台线程，我们主要关注的是用户线程，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ jstack &lt;span class="m">15525&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Full thread dump Java HotSpot&lt;span class="o">(&lt;/span>TM&lt;span class="o">)&lt;/span> 64-Bit Server VM &lt;span class="o">(&lt;/span>25.65-b01 mixed mode&lt;span class="o">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;elasticsearch[Native][merge][T#1]&amp;#34;&lt;/span> &lt;span class="c1">#98 daemon prio=5 os_prio=0 tid=0x00007f031c009000 nid=0x4129 waiting on condition [0x00007f02f61ee000]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> java.lang.Thread.State: WAITING &lt;span class="o">(&lt;/span>parking&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at sun.misc.Unsafe.park&lt;span class="o">(&lt;/span>Native Method&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - parking to &lt;span class="nb">wait&lt;/span> &lt;span class="k">for&lt;/span> &amp;lt;0x00000000eea589f0&amp;gt; &lt;span class="o">(&lt;/span>a org.elasticsearch.common.util.concurrent.EsExecutors&lt;span class="nv">$ExecutorScalingQueue&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.locks.LockSupport.park&lt;span class="o">(&lt;/span>LockSupport.java:175&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.LinkedTransferQueue.awaitMatch&lt;span class="o">(&lt;/span>LinkedTransferQueue.java:737&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.LinkedTransferQueue.xfer&lt;span class="o">(&lt;/span>LinkedTransferQueue.java:647&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.LinkedTransferQueue.take&lt;span class="o">(&lt;/span>LinkedTransferQueue.java:1269&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor.getTask&lt;span class="o">(&lt;/span>ThreadPoolExecutor.java:1067&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor.runWorker&lt;span class="o">(&lt;/span>ThreadPoolExecutor.java:1127&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor&lt;span class="nv">$Worker&lt;/span>.run&lt;span class="o">(&lt;/span>ThreadPoolExecutor.java:617&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.lang.Thread.run&lt;span class="o">(&lt;/span>Thread.java:745&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>线程 dump 信息说明：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>elasticsearch[Native][merge][T#1] 是我们为线程起的名字&lt;/p>
&lt;/li>
&lt;li>
&lt;p>daemon 表示线程是否是守护线程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>prio 表示我们为线程设置的优先级&lt;/p>
&lt;/li>
&lt;li>
&lt;p>os_prio 表示的对应的操作系统线程的优先级，由于并不是所有的操作系统都支持线程优先级，所以可能会出现都置为 0 的情况&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tid 是 java 中为这个线程的 id&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nid 是这个线程对应的操作系统本地线程 id，每一个 java 线程都有一个对应的操作系统线程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wait on condition 表示当前线程处于等待状态，但是并没列出具体原因&lt;/p>
&lt;/li>
&lt;li>
&lt;p>java.lang.Thread.State: WAITING (parking) 也是表示的处于等待状态，括号中的内容说明了导致等待的原因，例如这里的 parking 说明是因为调用了 LockSupport.park 方法导致等待&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="javalangthreadstate">java.lang.Thread.State&lt;/h2>
&lt;p>一个 Thread 对象可以有多个状态，在 java.lang.Thread.State 中，总共定义六种状态。&lt;/p>
&lt;ul>
&lt;li>New&lt;/li>
&lt;/ul>
&lt;p>线程刚刚被创建，也就是已经 new 过了，但是还没有调用 start()方法，jstack 命令不会列出处于此状态的线程信息。&lt;/p>
&lt;ul>
&lt;li>RUNNABLE&lt;/li>
&lt;/ul>
&lt;p>RUNNABLE 这个名字很具有欺骗性，很容易让人误以为处于这个状态的线程正在运行。事实上，这个状态只是表示，线程是可运行的。我们已经无数次提到过，一个单核 CPU 在同一时刻，只能运行一个线程。&lt;/p>
&lt;ul>
&lt;li>BLOCKED&lt;/li>
&lt;/ul>
&lt;p>线程处于阻塞状态，正在等待一个 monitor lock。通常情况下，是因为本线程与其他线程公用了一个锁。其他在线程正在使用这个锁进入某个 synchronized 同步方法块或者方法，而本线程进入这个同步代码块也需要这个锁，最终导致本线程处于阻塞状态。&lt;/p>
&lt;ul>
&lt;li>WAITING&lt;/li>
&lt;/ul>
&lt;p>等待状态，调用以下方法可能会导致一个线程处于等待状态：Object.wait 不指定超时时间、Thread.join with no timeout、LockSupport.park #java.lang.Thread.State: WAITING (parking)。&lt;/p>
&lt;p>例如：对于 wait()方法，一个线程处于等待状态，通常是在等待其他线程完成某个操作。本线程调用某个对象的 wait()方法，其他线程处于完成之后，调用同一个对象的 notify 或者 notifyAll()方法。Object.wait()方法只能够在同步代码块中调用。调用了 wait()方法后，会释放锁。&lt;/p>
&lt;ul>
&lt;li>TIMED_WAITING&lt;/li>
&lt;/ul>
&lt;p>线程等待指定的时间，对于以下方法的调用，可能会导致线程处于这个状态：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Thread.sleep #java.lang.Thread.State: TIMED_WAITING (sleeping)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Object.wait 指定超时时间 #java.lang.Thread.State: TIMED_WAITING (on object monitor)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thread.join with timeout&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LockSupport.parkNanos #java.lang.Thread.State: TIMED_WAITING (parking)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LockSupport.parkUntil #java.lang.Thread.State: TIMED_WAITING (parking)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>TERMINATED&lt;/li>
&lt;/ul>
&lt;p>线程终止。说明，对于 java.lang.Thread.State: WAITING (on object monitor)和 java.lang.Thread.State: TIMED_WAITING (on object monitor)，对于这两个状态，是因为调用了 Object 的 wait 方法(前者没有指定超时，后者指定了超时)，由于 wait 方法肯定要在 syncronized 代码中编写，因此肯定是如类似以下代码导致：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">synchronized&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// .........
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">wait&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// .........
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="死锁">死锁&lt;/h2>
&lt;p>在 Java 5 中加强了对死锁的检测。线程 Dump 中可以直接报告出 Java 级别的死锁，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Found&lt;/span> &lt;span class="n">one&lt;/span> &lt;span class="n">Java&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">level&lt;/span> &lt;span class="n">deadlock&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">=============================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">&amp;#34;Thread-1&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">waiting&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">monitor&lt;/span> &lt;span class="mh">0x0003f334&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">object&lt;/span> &lt;span class="mh">0x22c19f18&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">java&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Object&lt;/span>&lt;span class="o">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">which&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">held&lt;/span> &lt;span class="n">by&lt;/span> &lt;span class="s">&amp;#34;Thread-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">&amp;#34;Thread-0&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">waiting&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="n">monitor&lt;/span> &lt;span class="mh">0x0003f314&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">object&lt;/span> &lt;span class="mh">0x22c19f20&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">java&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Object&lt;/span>&lt;span class="o">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">which&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">held&lt;/span> &lt;span class="n">by&lt;/span> &lt;span class="s">&amp;#34;Thread-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nid">nid&lt;/h2>
&lt;p>每个线程都有一个 tid 和 nid，tid 是 java 中这个线程的编号，而 nid(native id)是对应操作系统线程 id。有的时候，我们会收到报警，说服务器，某个进程占用 CPU 过高，肯定是因为某个 java 线程有耗 CPU 资源的方法。&lt;/p></description></item><item><title>jstat</title><link>https://ng-tech.icu/books/java-series/06.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7/jstat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/06.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7/jstat/</guid><description>&lt;h1 id="jstat">jstat&lt;/h1>
&lt;p>如下所示为 jstat 的命令格式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ jstat -&amp;lt;option&amp;gt; &lt;span class="o">[&lt;/span>-t&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-h&amp;lt;lines&amp;gt;&lt;span class="o">]&lt;/span> &amp;lt;vmid&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;interval&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;count&amp;gt;&lt;span class="o">]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ jstat -gc -h3 &lt;span class="m">31736&lt;/span> &lt;span class="m">1000&lt;/span> &lt;span class="m">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="jstat--gc">jstat -gc&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ jstat -gc xxxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其对应的指标含义如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>S0C&lt;/td>
&lt;td>年轻代中第一个 survivor（幸存区）的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S1C&lt;/td>
&lt;td>年轻代中第二个 survivor（幸存区）的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S0U&lt;/td>
&lt;td>年轻代中第一个 survivor（幸存区）目前已使用空间 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S1U&lt;/td>
&lt;td>年轻代中第二个 survivor（幸存区）目前已使用空间 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EC&lt;/td>
&lt;td>年轻代中 Eden（伊甸园）的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EU&lt;/td>
&lt;td>年轻代中 Eden（伊甸园）目前已使用空间 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OC&lt;/td>
&lt;td>Old 代的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OU&lt;/td>
&lt;td>Old 代目前已使用空间 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PC&lt;/td>
&lt;td>Perm(持久代)的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PU&lt;/td>
&lt;td>Perm(持久代)目前已使用空间 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>YGC&lt;/td>
&lt;td>从应用程序启动到采样时年轻代中 gc 次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>YGCT&lt;/td>
&lt;td>从应用程序启动到采样时年轻代中 gc 所用时间(s)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FGC&lt;/td>
&lt;td>从应用程序启动到采样时 old 代(全 gc)gc 次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FGCT&lt;/td>
&lt;td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GCT&lt;/td>
&lt;td>从应用程序启动到采样时 gc 用的总时间(s)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="jstat--gcutil">jstat -gcutil&lt;/h1>
&lt;p>查看 gc 的统计信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ jstat -gcutil xxxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其对应的指标含义如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>S0&lt;/td>
&lt;td>年轻代中第一个 survivor（幸存区）已使用的占当前容量百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S1&lt;/td>
&lt;td>年轻代中第二个 survivor（幸存区）已使用的占当前容量百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>E&lt;/td>
&lt;td>年轻代中 Eden（伊甸园）已使用的占当前容量百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>O&lt;/td>
&lt;td>old 代已使用的占当前容量百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>P&lt;/td>
&lt;td>perm 代已使用的占当前容量百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>YGC&lt;/td>
&lt;td>从应用程序启动到采样时年轻代中 gc 次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>YGCT&lt;/td>
&lt;td>从应用程序启动到采样时年轻代中 gc 所用时间(s)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FGC&lt;/td>
&lt;td>从应用程序启动到采样时 old 代(全 gc)gc 次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FGCT&lt;/td>
&lt;td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GCT&lt;/td>
&lt;td>从应用程序启动到采样时 gc 用的总时间(s)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="jstat--gccapacity">jstat -gccapacity&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ jstat -gccapacity xxxx1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其对应的指标含义如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>NGCMN&lt;/td>
&lt;td>年轻代(young)中初始化(最小)的大小 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NGCMX&lt;/td>
&lt;td>年轻代(young)的最大容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NGC&lt;/td>
&lt;td>年轻代(young)中当前的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S0C&lt;/td>
&lt;td>年轻代中第一个 survivor（幸存区）的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S1C&lt;/td>
&lt;td>年轻代中第二个 survivor（幸存区）的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EC&lt;/td>
&lt;td>年轻代中 Eden（伊甸园）的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OGCMN&lt;/td>
&lt;td>old 代中初始化(最小)的大小 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OGCMX&lt;/td>
&lt;td>old 代的最大容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OGC&lt;/td>
&lt;td>old 代当前新生成的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OC&lt;/td>
&lt;td>Old 代的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PGCMN&lt;/td>
&lt;td>perm 代中初始化(最小)的大小 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PGCMX&lt;/td>
&lt;td>perm 代的最大容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PGC&lt;/td>
&lt;td>perm 代当前新生成的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PC&lt;/td>
&lt;td>Perm(持久代)的容量 (字节)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>YGC&lt;/td>
&lt;td>从应用程序启动到采样时年轻代中 gc 次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FGC&lt;/td>
&lt;td>从应用程序启动到采样时 old 代(全 gc)gc 次数&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="其他命令">其他命令&lt;/h1>
&lt;ol>
&lt;li>查看年轻代对象的信息及其占用量。&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>jstat -gcnewcapacity xxxx1
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>查看老年代对象的信息及其占用量。&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>jstat -gcoldcapacity xxxx1
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>查看年轻代对象的信息&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>jstat -gcnew xxxx1
&lt;/code>&lt;/pre>&lt;ol start="4">
&lt;li>查看老年代对象的信息&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>jstat -gcold xxxx
&lt;/code>&lt;/pre>&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://club.perfma.com/article/316783?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io" target="_blank" rel="noopener">https://club.perfma.com/article/316783?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>