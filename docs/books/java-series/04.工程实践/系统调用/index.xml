<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>系统调用 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link><atom:link href="https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/index.xml" rel="self" type="application/rss+xml"/><description>系统调用</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>系统调用</title><link>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link></image><item><title>RMI</title><link>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/rmi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/rmi/</guid><description>&lt;h1 id="rmi">RMI&lt;/h1>
&lt;p>RMI:远程方法调用(Remote Method Invocation)。能够让在某个 java 虚拟机上的对象像调用本地对象一样调用另一个 java 虚拟机中的对象上的方法。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://img.blog.csdn.net/20130813104359359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>RMI 远程调用步骤：&lt;/p>
&lt;p>1，客户对象调用客户端辅助对象上的方法&lt;/p>
&lt;p>2，客户端辅助对象打包调用信息(变量，方法名)，通过网络发送给服务端辅助对象&lt;/p>
&lt;p>3，服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象&lt;/p>
&lt;p>4，调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象&lt;/p>
&lt;p>5，服务端辅助对象将结果打包，发送给客户端辅助对象&lt;/p>
&lt;p>6，客户端辅助对象将返回值解包，返回给客户对象&lt;/p>
&lt;p>7，客户对象获得返回值&lt;/p>
&lt;p>对于客户对象来说，步骤 2-6 是完全透明的&lt;/p>
&lt;p>搭建一个 RMI 服务的过程分为以下 7 步;&lt;/p>
&lt;p>1，创建远程方法接口，该接口必须继承自 Remote 接口&lt;/p>
&lt;p>Remote 接口是一个标识接口，用于标识所包含的方法可以从非本地虚拟机上调用的接口，Remote 接口本身不包含任何方法&lt;/p>
&lt;p>搭建一个 RMI 服务的过程分为以下 7 步;
1，创建远程方法接口，该接口必须继承自 Remote 接口
Remote 接口是一个标识接口，用于标识所包含的方法可以从非本地虚拟机上调用的接口，Remote 接口本身不包含任何方法&lt;/p>
&lt;pre tabindex="0">&lt;code> package server;
import java.rmi.Remote;
import java.rmi.RemoteException;
public interface Hello extends Remote {
public String sayHello(String name) throws RemoteException;
}
&lt;/code>&lt;/pre>&lt;p>由于远程方法调用的本质依然是网络通信，只不过隐藏了底层实现，网络通信是经常会出现异常的，所以接口的所有方法都必须抛出 RemoteException 以说明该方法是有风险的
2，创建远程方法接口实现类：
UnicastRemoteObject 类的构造函数抛出了 RemoteException，故其继承类不能使用默认构造函数，继承类的构造函数必须也抛出 RemoteException
由于方法参数与返回值最终都将在网络上传输，故必须是可序列化的&lt;/p>
&lt;pre tabindex="0">&lt;code> package server;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
public class HelloImpl extends UnicastRemoteObject implements Hello {
private static final long serialVersionUID = -271947229644133464L;
public HelloImpl() throws RemoteException{
super();
}
public String sayHello(String name) throws RemoteException {
return &amp;#34;Hello,&amp;#34;+name;
}
}
&lt;/code>&lt;/pre>&lt;p>3，利用 java 自带 rmic 工具生成 sutb 存根类(jdk1.5.0_15/bin/rmic)
jdk1.2 以后的 RMI 可以通过反射 API 可以直接将请求发送给真实类，所以不需要 skeleton 类了
sutb 存根为远程方法类在本地的代理，是在服务端代码的基础上生成的，需要 HelloImpl.class 文件，由于 HelloImpl 继承了 Hello 接口，故 Hello.class 文件也是不可少的
Test&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>server&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>Hello.class&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>HelloImpl.class
方式一：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>[name@name Test]$ cd /home/name/Test/
[name@name Test]$ rmic server.HelloImpl
&lt;/code>&lt;/pre>&lt;p>方式二：&lt;/p>
&lt;pre tabindex="0">&lt;code>[name@name Test]$ rmic -classpath /home/name/Test server.HelloImpl
&lt;/code>&lt;/pre>&lt;p>运行成功后将会生成 HelloImpl_Stub.class 文件
4，启动 RMI 注册服务(jdk1.5.0_15/bin/rmiregistry)
方式一：后台启动 rmiregistry 服务&lt;/p>
&lt;pre tabindex="0">&lt;code> [name@name jdk]$ jdk1.5.0_15/bin/rmiregistry 12312 &amp;amp;
[1] 22720
[name@name jdk]$ ps -ef|grep rmiregistry
name 22720 13763 0 16:43 pts/3 00:00:00 jdk1.5.0_15/bin/rmiregistry 12312
name 22737 13763 0 16:43 pts/3 00:00:00 grep rmiregistry
&lt;/code>&lt;/pre>&lt;p>如果不带具体端口号，则默认为 1099
方式二：人工创建 rmiregistry 服务，需要在代码中添加：&lt;/p>
&lt;pre tabindex="0">&lt;code> LocateRegistry.createRegistry(12312);
&lt;/code>&lt;/pre>&lt;p>5，编写服务端代码&lt;/p>
&lt;pre tabindex="0">&lt;code> package server;
import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;
public class HelloServer {
public static void main(String[] args) {
try{
Hello h = new HelloImpl();
//创建并导出接受指定port请求的本地主机上的Registry实例。
//LocateRegistry.createRegistry(12312);
/** Naming 类提供在对象注册表中存储和获得远程对远程对象引用的方法
* Naming 类的每个方法都可将某个名称作为其一个参数，
* 该名称是使用以下形式的 URL 格式(没有 scheme 组件)的 java.lang.String:
* //host:port/name
* host：注册表所在的主机(远程或本地)，省略则默认为本地主机
* port：是注册表接受调用的端口号，省略则默认为1099，RMI注册表registry使用的著名端口
* name：是未经注册表解释的简单字符串
*/
//Naming.bind(&amp;#34;//host:port/name&amp;#34;, h);
Naming.bind(&amp;#34;rmi://192.168.58.164:12312/Hello&amp;#34;, h);
System.out.println(&amp;#34;HelloServer启动成功&amp;#34;);
}catch(Exception e){
e.printStackTrace();
}
}
}
&lt;/code>&lt;/pre>&lt;p>先创建注册表，然后才能在注册表中存储远程对象信息
6，运行服务端(58.164)：
Test&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>server&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>Hello.class&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>HelloImpl.class&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>HelloServer.class&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code> [name@name ~]$ java server.HelloServer
HelloServer启动成功
&lt;/code>&lt;/pre>&lt;p>当然/home/name/Test 一定要在系统 CLASSPATH 中，否则会报找不到相应的.class 文件
7，编写客户端代码&lt;/p>
&lt;pre tabindex="0">&lt;code> package client;
import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import server.Hello;
public class HelloClient {
public static void main(String[] args) {
try {
Hello h = (Hello)Naming.lookup(&amp;#34;rmi://192.168.58.164:12312/Hello&amp;#34;);
System.out.println(h.sayHello(&amp;#34;zx&amp;#34;));
} catch (MalformedURLException e) {
System.out.println(&amp;#34;url格式异常&amp;#34;);
} catch (RemoteException e) {
System.out.println(&amp;#34;创建对象异常&amp;#34;);
e.printStackTrace();
} catch (NotBoundException e) {
System.out.println(&amp;#34;对象未绑定&amp;#34;);
}
}
}
&lt;/code>&lt;/pre>&lt;p>8，运行客户端(58.163)：
Test&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>client&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>HelloClient.class&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>server&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>Hello.class&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>HelloImpl_Stub.class//服务端生成的存根文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code> [name@name client]$ java client.HelloClient
Hello,zx
&lt;/code>&lt;/pre>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://img.blog.csdn.net/20130816094554390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>跨语言调用</title><link>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8/</guid><description>&lt;h1 id="java-跨语言调用">Java 跨语言调用&lt;/h1>
&lt;p>JNA provides Java programs easy access to native shared libraries without writing anything but Java code - no JNI or native code is required. This functionality is comparable to Windows&amp;rsquo; Platform/Invoke and Python&amp;rsquo;s ctypes.&lt;/p>
&lt;h1 id="c作为中转">C++作为中转&lt;/h1>
&lt;p>&lt;a href="http://www.iteye.com/topic/1133867" target="_blank" rel="noopener">Java 调用 C# DLL&lt;/a>&lt;/p>
&lt;h1 id="jni4netbridge-between-java-and-net-intraprocess-fast-object-oriented-open-source">jni4net:bridge between Java and .NET (intraprocess, fast, object oriented, open-source)&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://jni4net.com/pics/jni4net-overview.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="quick-start">Quick Start&lt;/h2>
&lt;h3 id="installation">Installation&lt;/h3>
&lt;p>Microsoft Windows (XP / 7 / 8 / 8.1) x86 or x64
This guide is currently using Microsoft Windows 7 Professional x64 and is confirmed working. You may try other versions of Windows. Jni4Net binaries and dependencies do not support Mac/Linux.&lt;/p>
&lt;p>Microsoft Visual Studio
Microsoft Visual Studio 2010 Ultimate will work.&lt;/p>
&lt;p>Microsoft .NET Framework 4
Version 4.0.30319 will work. Minimum version is 2.0.50727. Can try later versions.&lt;/p>
&lt;p>Java SE Development Kit
You may follow the download links and install the 32-bit version, and the rest of this process should go smoothly.&lt;/p>
&lt;p>Set up your JAVA_HOME environment variable.
Simply follow the instructions found on the net.&lt;/p>
&lt;p>Add JAVA_HOME to your system Path
by creating a new entry for JAVA_HOME, ;%JAVA_HOME%\bin;.&lt;/p>
&lt;p>Java commands can now be run from Windows Command Prompt. Remember to separate entries with semicolons (;) in between, then restart your computer.&lt;/p>
&lt;p>&lt;a href="http://sourceforge.net/projects/jni4net/files/" target="_blank" rel="noopener">Download Jni4Net&lt;/a>
Currently this guide uses &lt;a href="http://sourceforge.net/projects/jni4net/files/0.8.8/jni4net-0.8.8.0-bin.zip/download" target="_blank" rel="noopener">jni4net-0.8.8.0-bin.zip&lt;/a>.&lt;/p>
&lt;h3 id="proxygen">ProxyGen&lt;/h3>
&lt;p>Open and extract these files to your favorite location, (the Desktop for example):
bin/proxygen.exe
bin/proxygen.exe.config
lib/jni4net.j-0.8.8.0.jar
lib/jni4net.n.w32.v40-0.8.8.0.dll
lib/jni4net.n-0.8.8.0.dll
Because proxygen.exe is causing confusion between 32-bit and 64-bit versions of Java and CLR virtual machines, the following steps are required to modify the file for easier use.
Open the Visual Studio Command Prompt. You can find it in the Start Menu via All Programs &amp;gt; Microsoft Visual Studio (*) &amp;gt; Visual Studio Tools
or simply type Visual Studio Command Prompt.
Once opened, enter:
corflags c:\users\you\desktop\proxygen.exe /32BIT+ /Force, (command and arguments are case-sensitive).
If the Command Prompt gives warning CF011, you may ignore it. The tool is ready for use in development.&lt;/p>
&lt;p>&lt;a href="https://github.com/jni4net/jni4net/wiki/ProxyGen-Setup" target="_blank" rel="noopener">Check the ProxyGen Setup guide&lt;/a> if you haven&amp;rsquo;t.&lt;/p>
&lt;p>We will also refer to &lt;a href="http://sourceforge.net/projects/jni4net/files/0.8.8/jni4net-0.8.8.0-bin.zip/download" target="_blank" rel="noopener">Jni4Net version 0.8.8.0&lt;/a> for the time being.&lt;/p>
&lt;p>&lt;em>[The assembly of your choice]&lt;/em>. For this guide, we will refer to a sample .NET-assembled library called &lt;code>testlib.dll&lt;/code>. It looks like this:&lt;/p>
&lt;pre tabindex="0">&lt;code> // Simple method that just prints a hard-coded string.
public void Hello()
{
Console.WriteLine(&amp;#34;Hello Java, from .NET!&amp;#34;);
}
// Parameterized method that accepts a string
public void Repeat(string line)
{
Console.WriteLine(line);
}
&lt;/code>&lt;/pre>&lt;p>Open the Windows Command Prompt.&lt;/p>
&lt;p>Enter a command to &lt;code>proxygen.exe&lt;/code> as follows:&lt;/p>
&lt;p>Enter a command to &lt;code>proxygen.exe&lt;/code> as follows:
&lt;code>c:\users\you\desktop\proxygen.exe c:\users\you\desktop\testlib.dll -wd c:\users\you\desktop&lt;/code>&lt;/p>
&lt;p>Four files and folders in total will be created:&lt;/p>
&lt;blockquote>
&lt;p>clr\&lt;/p>
&lt;p>clr&lt;br>
jvm\&lt;/p>
&lt;p>clr&lt;br>
jvm&lt;br>
testlib.proxygen.xml&lt;/p>
&lt;p>clr&lt;br>
jvm&lt;br>
testlib.proxygen.xml
build.cmd&lt;/p>
&lt;/blockquote>
&lt;p>Click and run the newly generated &lt;code>build.cmd&lt;/code> file. Your .NET and Java proxies are created:&lt;/p>
&lt;blockquote>
&lt;p>testlib.j4n.dll&lt;/p>
&lt;p>testlib.j4n.dll
testlib.j4n.jar&lt;/p>
&lt;p>testlib.j4n.dll
testlib.j4n.jar
target\ included&lt;/p>
&lt;/blockquote>
&lt;p>Ready the following resources to be imported into your project:&lt;/p>
&lt;blockquote>
&lt;p>jni4net.j-0.8.8.0.jar&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testlib.dll&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testlib.dll
testlib.j4n.jar&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testlib.dll
testlib.j4n.jar
testlib.j4n.dll&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testlib.dll
testlib.j4n.jar
testlib.j4n.dll
jni4net.n.w32.v40-0.8.8.0.dll&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testlib.dll
testlib.j4n.jar
testlib.j4n.dll
jni4net.n.w32.v40-0.8.8.0.dll
target\ (optional)&lt;/p>
&lt;/blockquote>
&lt;p>*&lt;em>Try not to include the rest of the generated files and folders as that would just increase the size of your project explorer/pipeline.&lt;/em>&lt;/p>
&lt;hr>
&lt;p>&lt;strong>JARs - Quick Example with testjar.jar&lt;/strong>&lt;/p>
&lt;p>Running &lt;code>proxygen.exe&lt;/code> with the command,&lt;/p>
&lt;p>Running &lt;code>proxygen.exe&lt;/code> with the command,
&lt;code>c:\users\you\desktop\proxygen.exe c:\users\you\desktop\testjar.jar -wd c:\users\you\desktop&lt;/code>&lt;/p>
&lt;p>generates these to your desktop:&lt;/p>
&lt;blockquote>
&lt;p>clr\&lt;/p>
&lt;p>clr&lt;br>
jvm\&lt;/p>
&lt;p>clr&lt;br>
jvm&lt;br>
testjar.proxygen.xml&lt;/p>
&lt;p>clr&lt;br>
jvm&lt;br>
testjar.proxygen.xml
build.cmd&lt;/p>
&lt;/blockquote>
&lt;p>Run &lt;code>build.cmd&lt;/code> and receive,&lt;/p>
&lt;blockquote>
&lt;p>testjar.j4n.dll&lt;/p>
&lt;p>testjar.j4n.dll
testjar.j4n.jar&lt;/p>
&lt;p>testjar.j4n.dll
testjar.j4n.jar
target\&lt;/p>
&lt;/blockquote>
&lt;p>then import these into your project:&lt;/p>
&lt;blockquote>
&lt;p>jni4net.j-0.8.8.0.jar&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testjar.jar&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testjar.jar
testjar.j4n.jar&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testjar.jar
testjar.j4n.jar
testjar.j4n.dll&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testjar.jar
testjar.j4n.jar
testjar.j4n.dll
jni4net.n.w32.v40-0.8.8.0.dll&lt;/p>
&lt;p>jni4net.j-0.8.8.0.jar
jni4net.n-0.8.8.0.dll
testjar.jar
testjar.j4n.jar
testjar.j4n.dll
jni4net.n.w32.v40-0.8.8.0.dll
target\&lt;/p>
&lt;/blockquote></description></item><item><title>命令执行</title><link>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/04.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</guid><description>&lt;h1 id="java-中命令执行">Java 中命令执行&lt;/h1>
&lt;p>在 Java 中执行系统命令，主要是使用 ProcessBuilder 和 Runtime.getRuntime().exec()。而在这里主要是介绍两种方法的使用。&lt;/p>
&lt;h1 id="runtime">Runtime&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 上传之后的视频文件名为test.tmpmedia
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">command&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;mencoder test.tmpmedia -o test.flv -ofps 25 -of lavf -oac mp3lame -srate 22050 -ovc lavc -lavcopts &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;vcodec=flv:keyint=59:vbitrate=6000:mbd=2:trell:v4mv:o=mpv_flagg=cbp_rd:last_pred=3 -vf harddup,scale=480:256&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Process&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Runtime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRuntime&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">exec&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">command&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 读取命令的输出信息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">InputStream&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getInputStream&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">BufferedReader&lt;/span> &lt;span class="n">reader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">BufferedReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">InputStreamReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">is&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">waitFor&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">exitValue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//说明命令执行失败
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//可以进入到错误处理步骤中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 打印输出信息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">reader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">readLine&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 waitFor()方法会阻塞当前进程，直到命令执行结束。而 exitValue 不会阻塞进程，但是调用 exitValue 的时候，如果命令没有执行完成就会报错。&lt;/p>
&lt;h1 id="processbuilder">ProcessBuilder&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 将命令分解为List存储
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">commandSplit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">command&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">split&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lcommand&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">commandSplit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lcommand&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">commandSplit&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ProcessBuilder&lt;/span> &lt;span class="n">processBuilder&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ProcessBuilder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">lcommand&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">processBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">redirectErrorStream&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Process&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">processBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">InputStream&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getInputStream&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">BufferedReader&lt;/span> &lt;span class="n">bs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">BufferedReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">InputStreamReader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">is&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">waitFor&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">exitValue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//说明命令执行失败
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//可以进入到错误处理步骤中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">String&lt;/span> &lt;span class="n">line&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">line&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">readLine&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">line&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resultLog&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">line&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ProcessBuilder 可以使用 redirectErrorStream 将标准输出和标准错误流合并，然后使用 getInputStream 获取到流，放入 BufferedReader 中打印出来，便可解决缓存区满的问题。&lt;/p></description></item></channel></rss>