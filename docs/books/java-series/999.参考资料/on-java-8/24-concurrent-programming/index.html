<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="第二十四章 并发编程 爱丽丝：“我可不想到疯子中间去” 猫咪：“啊，那没辙了，我们这都是疯子。我疯了，你也疯了” 爱丽丝：“你怎么知道我疯了”。 猫咪：“你一定是疯了，否则你就不会来这儿” ——爱丽丝梦游仙境 第 6"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/24-concurrent-programming/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/24-concurrent-programming/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/24-concurrent-programming/"><meta property="og:title" content="24-Concurrent-Programming | Next-gen Tech Edu"><meta property="og:description" content="第二十四章 并发编程 爱丽丝：“我可不想到疯子中间去” 猫咪：“啊，那没辙了，我们这都是疯子。我疯了，你也疯了” 爱丽丝：“你怎么知道我疯了”。 猫咪：“你一定是疯了，否则你就不会来这儿” ——爱丽丝梦游仙境 第 6"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>24-Concurrent-Programming | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=f6747442c149a98697b0fb38cbbe9a65><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">On Java 8</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idb2e20681920018e3a6e20318a9804534")' href=#idb2e20681920018e3a6e20318a9804534 aria-expanded=false aria-controls=idb2e20681920018e3a6e20318a9804534 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>999.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idb2e20681920018e3a6e20318a9804534 aria-expanded=false aria-controls=idb2e20681920018e3a6e20318a9804534><i class="fa-solid fa-angle-down" id=caret-idb2e20681920018e3a6e20318a9804534></i></a></div><ul class="nav docs-sidenav collapse show" id=idb2e20681920018e3a6e20318a9804534><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id4d84ffe3754d5f34aa3c13b4d1952b31")' href=#id4d84ffe3754d5f34aa3c13b4d1952b31 aria-expanded=false aria-controls=id4d84ffe3754d5f34aa3c13b4d1952b31 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/>On Java 8</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id4d84ffe3754d5f34aa3c13b4d1952b31 aria-expanded=false aria-controls=id4d84ffe3754d5f34aa3c13b4d1952b31><i class="fa-solid fa-angle-down" id=caret-id4d84ffe3754d5f34aa3c13b4d1952b31></i></a></div><ul class="nav docs-sidenav collapse show" id=id4d84ffe3754d5f34aa3c13b4d1952b31><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/00-introduction/>00-Introduction</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/01-what-is-an-object/>01-What-is-an-Object</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/02-installing-java-and-the-book-examples/>02-Installing-Java-and-the-Book-Examples</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/03-objects-everywhere/>03-Objects-Everywhere</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/04-operators/>04-Operators</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/05-control-flow/>05-Control-Flow</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/06-housekeeping/>06-Housekeeping</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/07-implementation-hiding/>07-Implementation-Hiding</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/08-reuse/>08-Reuse</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/09-polymorphism/>09-Polymorphism</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/10-interfaces/>10-Interfaces</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/11-inner-classes/>11-Inner-Classes</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/12-collections/>12-Collections</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/13-functional-programming/>13-Functional-Programming</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/14-streams/>14-Streams</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/15-exceptions/>15-Exceptions</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/16-validating-your-code/>16-Validating-Your-Code</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/17-files/>17-Files</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/18-strings/>18-Strings</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/19-type-information/>19-Type-Information</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/20-generics/>20-Generics</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/21-arrays/>21-Arrays</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/22-enumerations/>22-Enumerations</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/23-annotations/>23-Annotations</a></li><li class="child level active"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/24-concurrent-programming/>24-Concurrent-Programming</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/25-patterns/>25-Patterns</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-becoming-a-programmer/>Appendix-Becoming-a-Programmer</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-benefits-and-costs-of-static-type-checking/>Appendix-Benefits-and-Costs-of-Static-Type-Checking</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-collection-topics/>Appendix-Collection-Topics</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-data-compression/>Appendix-Data-Compression</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-io-streams/>Appendix-IO-Streams</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-javadoc/>Appendix-Javadoc</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-low-level-concurrency/>Appendix-Low-Level-Concurrency</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-new-io/>Appendix-New-IO</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-object-serialization/>Appendix-Object-Serialization</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-passing-and-returning-objects/>Appendix-Passing-and-Returning-Objects</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-programming-guidelines/>Appendix-Programming-Guidelines</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-standard-io/>Appendix-Standard-IO</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-supplements/>Appendix-Supplements</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-the-positive-legacy-of-c-plus-plus-and-java/>Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/appendix-understanding-equals-and-hashcode/>Appendix-Understanding-equals-and-hashCode</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/glossary/>GLOSSARY</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id214ecc87c188b2007b2d478ce6167fb1")' href=#id214ecc87c188b2007b2d478ce6167fb1 aria-expanded=false aria-controls=id214ecc87c188b2007b2d478ce6167fb1 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/>Think in Java</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id214ecc87c188b2007b2d478ce6167fb1 aria-expanded=false aria-controls=id214ecc87c188b2007b2d478ce6167fb1><i class="fa-solid fa-angle-right" id=caret-id214ecc87c188b2007b2d478ce6167fb1></i></a></div><ul class="nav docs-sidenav collapse" id=id214ecc87c188b2007b2d478ce6167fb1><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idca73ee751e8224db415e54c000dd27fb")' href=#idca73ee751e8224db415e54c000dd27fb aria-expanded=false aria-controls=idca73ee751e8224db415e54c000dd27fb aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/>1.对象入门</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idca73ee751e8224db415e54c000dd27fb aria-expanded=false aria-controls=idca73ee751e8224db415e54c000dd27fb><i class="fa-solid fa-angle-right" id=caret-idca73ee751e8224db415e54c000dd27fb></i></a></div><ul class="nav docs-sidenav collapse" id=idca73ee751e8224db415e54c000dd27fb><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.1-%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%BF%9B%E6%AD%A5/>1.1 抽象的进步</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.10-%E6%B0%B8%E4%B9%85%E6%80%A7/>1.10 永久性</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.11-java%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/>1.11 Java和因特网</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.12-%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1/>1.12 分析和设计</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.13-java%E8%BF%98%E6%98%AFc++/>1.13 Java还是C++</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%A5%E5%8F%A3/>1.2 对象的接口</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E7%9A%84%E9%9A%90%E8%97%8F/>1.3 实现方案的隐藏</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.4-%E6%96%B9%E6%A1%88%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8/>1.4 方案的重复使用</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.5-%E7%BB%A7%E6%89%BF%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3/>1.5 继承：重新使用接口</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.6-%E5%A4%9A%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E6%8D%A2%E4%BD%BF%E7%94%A8/>1.6 多态对象的互换使用</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.7-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%AD%98%E5%9C%A8%E6%97%B6%E9%97%B4/>1.7 对象的创建和存在时间</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/1.%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/1.9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/>1.9 多线程</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide41bfd2e5eef4f5cc967d0bf0d3beae5")' href=#ide41bfd2e5eef4f5cc967d0bf0d3beae5 aria-expanded=false aria-controls=ide41bfd2e5eef4f5cc967d0bf0d3beae5 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/>10.Java IO 系统</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide41bfd2e5eef4f5cc967d0bf0d3beae5 aria-expanded=false aria-controls=ide41bfd2e5eef4f5cc967d0bf0d3beae5><i class="fa-solid fa-angle-right" id=caret-ide41bfd2e5eef4f5cc967d0bf0d3beae5></i></a></div><ul class="nav docs-sidenav collapse" id=ide41bfd2e5eef4f5cc967d0bf0d3beae5><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.1-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/>10.1 输入和输出</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.10-%E6%80%BB%E7%BB%93/>10.10 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.11-%E7%BB%83%E4%B9%A0/>10.11 练习</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.2-%E5%A2%9E%E6%B7%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/>10.2 增添属性和有用的接口</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.3-%E6%9C%AC%E8%BA%AB%E7%9A%84%E7%BC%BA%E9%99%B7randomaccessfile/>10.3 本身的缺陷：RandomAccessFile</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.4-file%E7%B1%BB/>10.4 File类</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.5-io%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8/>10.5 IO流的典型应用</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.6-streamtokenizer/>10.6 StreamTokenizer</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.7-java-1.1%E7%9A%84io%E6%B5%81/>10.7 Java 1.1的IO流</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.8-%E5%8E%8B%E7%BC%A9/>10.8 压缩</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/10.java-io-%E7%B3%BB%E7%BB%9F/10.9-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/>10.9 对象序列化</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idb836ac598092c15afaccbaa2c465c59e")' href=#idb836ac598092c15afaccbaa2c465c59e aria-expanded=false aria-controls=idb836ac598092c15afaccbaa2c465c59e aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/11.%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/>11.运行期类型鉴定</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idb836ac598092c15afaccbaa2c465c59e aria-expanded=false aria-controls=idb836ac598092c15afaccbaa2c465c59e><i class="fa-solid fa-angle-right" id=caret-idb836ac598092c15afaccbaa2c465c59e></i></a></div><ul class="nav docs-sidenav collapse" id=idb836ac598092c15afaccbaa2c465c59e><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/11.%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/11.1-%E5%AF%B9rtti%E7%9A%84%E9%9C%80%E8%A6%81/>11.1 对RTTI的需要</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/11.%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/11.2-rtti-%E8%AF%AD%E6%B3%95/>11.2 RTTI 语法</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/11.%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/11.3-%E5%8F%8D%E5%B0%84%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E4%BF%A1%E6%81%AF/>11.3 反射：运行期类信息</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/11.%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/11.4-%E6%80%BB%E7%BB%93/>11.4 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/11.%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/11.5-%E7%BB%83%E4%B9%A0/>11.5 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide320911890134774be5931d1a0a20cc9")' href=#ide320911890134774be5931d1a0a20cc9 aria-expanded=false aria-controls=ide320911890134774be5931d1a0a20cc9 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/12.%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/>12.传递和返回对象</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide320911890134774be5931d1a0a20cc9 aria-expanded=false aria-controls=ide320911890134774be5931d1a0a20cc9><i class="fa-solid fa-angle-right" id=caret-ide320911890134774be5931d1a0a20cc9></i></a></div><ul class="nav docs-sidenav collapse" id=ide320911890134774be5931d1a0a20cc9><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/12.%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/12.1-%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88/>12.1 传递指针</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/12.%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/12.2-%E5%88%B6%E4%BD%9C%E6%9C%AC%E5%9C%B0%E5%89%AF%E6%9C%AC/>12.2 制作本地副本</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/12.%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/12.3-%E5%85%8B%E9%9A%86%E7%9A%84%E6%8E%A7%E5%88%B6/>12.3 克隆的控制</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/12.%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/12.4-%E5%8F%AA%E8%AF%BB%E7%B1%BB/>12.4 只读类</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/12.%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/12.5-%E6%80%BB%E7%BB%93/>12.5 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/12.%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/12.6-%E7%BB%83%E4%B9%A0/>12.6 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-iddba1dfa22d26f49d68205d3c67fa5695")' href=#iddba1dfa22d26f49d68205d3c67fa5695 aria-expanded=false aria-controls=iddba1dfa22d26f49d68205d3c67fa5695 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idbb7b9ed9f3766574125ce978e02ab9b3")' href=#idbb7b9ed9f3766574125ce978e02ab9b3 aria-expanded=false aria-controls=idbb7b9ed9f3766574125ce978e02ab9b3 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/>14.多线程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idbb7b9ed9f3766574125ce978e02ab9b3 aria-expanded=false aria-controls=idbb7b9ed9f3766574125ce978e02ab9b3><i class="fa-solid fa-angle-right" id=caret-idbb7b9ed9f3766574125ce978e02ab9b3></i></a></div><ul class="nav docs-sidenav collapse" id=idbb7b9ed9f3766574125ce978e02ab9b3><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.1-%E5%8F%8D%E5%BA%94%E7%81%B5%E6%95%8F%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/>14.1 反应灵敏的用户界面</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.2-%E5%85%B1%E4%BA%AB%E6%9C%89%E9%99%90%E7%9A%84%E8%B5%84%E6%BA%90/>14.2 共享有限的资源</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.3-%E5%A0%B5%E5%A1%9E/>14.3 堵塞</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.4-%E4%BC%98%E5%85%88%E7%BA%A7/>14.4 优先级</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.5-%E5%9B%9E%E9%A1%BErunnable/>14.5 回顾runnable</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.6-%E6%80%BB%E7%BB%93/>14.6 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/14.%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.7-%E7%BB%83%E4%B9%A0/>14.7 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id0717cbd205b42e749ff12487fe013a48")' href=#id0717cbd205b42e749ff12487fe013a48 aria-expanded=false aria-controls=id0717cbd205b42e749ff12487fe013a48 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>15.网络编程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id0717cbd205b42e749ff12487fe013a48 aria-expanded=false aria-controls=id0717cbd205b42e749ff12487fe013a48><i class="fa-solid fa-angle-right" id=caret-id0717cbd205b42e749ff12487fe013a48></i></a></div><ul class="nav docs-sidenav collapse" id=id0717cbd205b42e749ff12487fe013a48><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.1-%E6%9C%BA%E5%99%A8%E7%9A%84%E6%A0%87%E8%AF%86/>15.1 机器的标识</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.10-%E7%BB%83%E4%B9%A0/>15.10 练习</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.2-%E5%A5%97%E6%8E%A5%E5%AD%97/>15.2 套接字</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.3-%E6%9C%8D%E5%8A%A1%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7/>15.3 服务多个客户</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.4-%E6%95%B0%E6%8D%AE%E6%8A%A5/>15.4 数据报</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.5-%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8/>15.5 一个Web应用</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.6-java%E4%B8%8Ecgi%E7%9A%84%E6%B2%9F%E9%80%9A/>15.6 Java与CGI的沟通</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.7-%E7%94%A8jdbc%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/>15.7 用JDBC连接数据库</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.8-%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95/>15.8 远程方法</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/15.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.9-%E6%80%BB%E7%BB%93/>15.9 总结</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idb45833a961ce68d05972119f0bd5689d")' href=#idb45833a961ce68d05972119f0bd5689d aria-expanded=false aria-controls=idb45833a961ce68d05972119f0bd5689d aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/>16.设计范式</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idb45833a961ce68d05972119f0bd5689d aria-expanded=false aria-controls=idb45833a961ce68d05972119f0bd5689d><i class="fa-solid fa-angle-right" id=caret-idb45833a961ce68d05972119f0bd5689d></i></a></div><ul class="nav docs-sidenav collapse" id=idb45833a961ce68d05972119f0bd5689d><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.1-%E8%8C%83%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5/>16.1 范式的概念</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.10-%E7%BB%83%E4%B9%A0/>16.10 练习</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.2-%E8%A7%82%E5%AF%9F%E5%99%A8%E8%8C%83%E5%BC%8F/>16.2 观察器范式</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.3-%E6%A8%A1%E6%8B%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AB%99/>16.3 模拟垃圾回收站</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.4-%E6%94%B9%E8%BF%9B%E8%AE%BE%E8%AE%A1/>16.4 改进设计</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.5-%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/>16.5 抽象的应用</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.6-%E5%A4%9A%E9%87%8D%E6%B4%BE%E9%81%A3/>16.6 多重派遣</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.7-%E8%AE%BF%E9%97%AE%E5%99%A8%E8%8C%83%E5%BC%8F/>16.7 访问器范式</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.8-rtti%E7%9C%9F%E7%9A%84%E6%9C%89%E5%AE%B3%E5%90%97/>16.8 RTTI真的有害吗</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/16.%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/16.9-%E6%80%BB%E7%BB%93/>16.9 总结</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id9dcdb57b589db03f63de5260a0331b23")' href=#id9dcdb57b589db03f63de5260a0331b23 aria-expanded=false aria-controls=id9dcdb57b589db03f63de5260a0331b23 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/17.%E9%A1%B9%E7%9B%AE/>17.项目</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id9dcdb57b589db03f63de5260a0331b23 aria-expanded=false aria-controls=id9dcdb57b589db03f63de5260a0331b23><i class="fa-solid fa-angle-right" id=caret-id9dcdb57b589db03f63de5260a0331b23></i></a></div><ul class="nav docs-sidenav collapse" id=id9dcdb57b589db03f63de5260a0331b23><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/17.%E9%A1%B9%E7%9B%AE/17.1-%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86/>17.1 文字处理</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/17.%E9%A1%B9%E7%9B%AE/17.2-%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/>17.2 方法查找工具</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/17.%E9%A1%B9%E7%9B%AE/17.3-%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/>17.3 复杂性理论</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/17.%E9%A1%B9%E7%9B%AE/17.4-%E6%80%BB%E7%BB%93/>17.4 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/17.%E9%A1%B9%E7%9B%AE/17.5-%E7%BB%83%E4%B9%A0/>17.5 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idf0960bbb6faeb4cccffb1ac69252ea28")' href=#idf0960bbb6faeb4cccffb1ac69252ea28 aria-expanded=false aria-controls=idf0960bbb6faeb4cccffb1ac69252ea28 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/>2.一切都是对象</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idf0960bbb6faeb4cccffb1ac69252ea28 aria-expanded=false aria-controls=idf0960bbb6faeb4cccffb1ac69252ea28><i class="fa-solid fa-angle-right" id=caret-idf0960bbb6faeb4cccffb1ac69252ea28></i></a></div><ul class="nav docs-sidenav collapse" id=idf0960bbb6faeb4cccffb1ac69252ea28><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.1-%E7%94%A8%E6%8C%87%E9%92%88%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/>2.1 用指针操纵对象</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.10-%E6%80%BB%E7%BB%93/>2.10 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.11-%E7%BB%83%E4%B9%A0/>2.11 练习</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.2-%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%BF%85%E9%A1%BB%E5%88%9B%E5%BB%BA/>2.2 所有对象都必须创建</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.3-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E8%A6%81%E6%B8%85%E9%99%A4%E5%AF%B9%E8%B1%A1/>2.3 绝对不要清除对象</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.4-%E6%96%B0%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B1%BB/>2.4 新建数据类型：类</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.5-%E6%96%B9%E6%B3%95%E8%87%AA%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC/>2.5 方法、自变量和返回值</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.6-%E6%9E%84%E5%BB%BAjava%E7%A8%8B%E5%BA%8F/>2.6 构建Java程序</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.7-%E6%88%91%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F/>2.7 我们的第一个Java程序</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.8-%E6%B3%A8%E9%87%8A%E5%92%8C%E5%B5%8C%E5%85%A5%E6%96%87%E6%A1%A3/>2.8 注释和嵌入文档</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2.9-%E7%BC%96%E7%A0%81%E6%A0%B7%E5%BC%8F/>2.9 编码样式</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id742622a5c8a24c8f9f9a1ecc037a0f62")' href=#id742622a5c8a24c8f9f9a1ecc037a0f62 aria-expanded=false aria-controls=id742622a5c8a24c8f9f9a1ecc037a0f62 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/3.%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/>3.控制程序流程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id742622a5c8a24c8f9f9a1ecc037a0f62 aria-expanded=false aria-controls=id742622a5c8a24c8f9f9a1ecc037a0f62><i class="fa-solid fa-angle-right" id=caret-id742622a5c8a24c8f9f9a1ecc037a0f62></i></a></div><ul class="nav docs-sidenav collapse" id=id742622a5c8a24c8f9f9a1ecc037a0f62><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/3.%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/3.1-%E4%BD%BF%E7%94%A8java%E8%BF%90%E7%AE%97%E7%AC%A6/>3.1 使用Java运算符</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/3.%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/3.2-%E6%89%A7%E8%A1%8C%E6%8E%A7%E5%88%B6/>3.2 执行控制</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/3.%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/3.3-%E6%80%BB%E7%BB%93/>3.3 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/3.%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/3.4-%E7%BB%83%E4%B9%A0/>3.4 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idada88f416ec1dfab89f033bf872d6408")' href=#idada88f416ec1dfab89f033bf872d6408 aria-expanded=false aria-controls=idada88f416ec1dfab89f033bf872d6408 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/>4.初始化和清除</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idada88f416ec1dfab89f033bf872d6408 aria-expanded=false aria-controls=idada88f416ec1dfab89f033bf872d6408><i class="fa-solid fa-angle-right" id=caret-idada88f416ec1dfab89f033bf872d6408></i></a></div><ul class="nav docs-sidenav collapse" id=idada88f416ec1dfab89f033bf872d6408><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/4.1-%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/>4.1 用构造器自动初始化</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/4.2-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/>4.2 方法重载</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/4.3-%E6%B8%85%E9%99%A4%E6%94%B6%E5%B0%BE%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/>4.3 清除：收尾和垃圾收集</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/4.4-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/>4.4 成员初始化</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/4.5-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/>4.5 数组初始化</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/4.6-%E6%80%BB%E7%BB%93/>4.6 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/4.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/4.7-%E7%BB%83%E4%B9%A0/>4.7 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idadcf0cac1c984df3c4fe242a8cf5b932")' href=#idadcf0cac1c984df3c4fe242a8cf5b932 aria-expanded=false aria-controls=idadcf0cac1c984df3c4fe242a8cf5b932 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/5.%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/>5.隐藏实施过程</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idadcf0cac1c984df3c4fe242a8cf5b932 aria-expanded=false aria-controls=idadcf0cac1c984df3c4fe242a8cf5b932><i class="fa-solid fa-angle-right" id=caret-idadcf0cac1c984df3c4fe242a8cf5b932></i></a></div><ul class="nav docs-sidenav collapse" id=idadcf0cac1c984df3c4fe242a8cf5b932><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/5.%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/5.1-%E5%8C%85%E5%BA%93%E5%8D%95%E5%85%83/>5.1 包：库单元</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/5.%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/5.2-java%E8%AE%BF%E9%97%AE%E6%8C%87%E7%A4%BA%E7%AC%A6/>5.2 Java访问指示符</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/5.%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/5.3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/>5.3 接口与实现</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/5.%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/5.4-%E7%B1%BB%E8%AE%BF%E9%97%AE/>5.4 类访问</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/5.%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/5.5-%E6%80%BB%E7%BB%93/>5.5 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/5.%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/5.6-%E7%BB%83%E4%B9%A0/>5.6 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id867e4ec83e2a44d87f6aed649979a0c1")' href=#id867e4ec83e2a44d87f6aed649979a0c1 aria-expanded=false aria-controls=id867e4ec83e2a44d87f6aed649979a0c1 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/>6.类再生</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id867e4ec83e2a44d87f6aed649979a0c1 aria-expanded=false aria-controls=id867e4ec83e2a44d87f6aed649979a0c1><i class="fa-solid fa-angle-right" id=caret-id867e4ec83e2a44d87f6aed649979a0c1></i></a></div><ul class="nav docs-sidenav collapse" id=id867e4ec83e2a44d87f6aed649979a0c1><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.1-%E5%90%88%E6%88%90%E7%9A%84%E8%AF%AD%E6%B3%95/>6.1 合成的语法</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.10-%E6%80%BB%E7%BB%93/>6.10 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.11-%E7%BB%83%E4%B9%A0/>6.11 练习</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.2-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95/>6.2 继承的语法</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.3-%E5%90%88%E6%88%90%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%93%E5%90%88/>6.3 合成与继承的结合</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.4-%E5%88%B0%E5%BA%95%E9%80%89%E6%8B%A9%E5%90%88%E6%88%90%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF/>6.4 到底选择合成还是继承</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.5-protected/>6.5 protected</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.6-%E7%B4%AF%E7%A7%AF%E5%BC%80%E5%8F%91/>6.6 累积开发</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.7-%E4%B8%8A%E6%BA%AF%E9%80%A0%E5%9E%8B/>6.7 上溯造型</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.8-final%E5%85%B3%E9%94%AE%E5%AD%97/>6.8 final关键字</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/6.%E7%B1%BB%E5%86%8D%E7%94%9F/6.9-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%B1%BB%E8%A3%85%E8%BD%BD/>6.9 初始化和类装载</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idf3d9d72d599cb56e323c67f4c3e5106c")' href=#idf3d9d72d599cb56e323c67f4c3e5106c aria-expanded=false aria-controls=idf3d9d72d599cb56e323c67f4c3e5106c aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/>7.多态性</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idf3d9d72d599cb56e323c67f4c3e5106c aria-expanded=false aria-controls=idf3d9d72d599cb56e323c67f4c3e5106c><i class="fa-solid fa-angle-right" id=caret-idf3d9d72d599cb56e323c67f4c3e5106c></i></a></div><ul class="nav docs-sidenav collapse" id=idf3d9d72d599cb56e323c67f4c3e5106c><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.1-%E4%B8%8A%E6%BA%AF%E9%80%A0%E5%9E%8B/>7.1 上溯造型</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.10-%E7%BB%83%E4%B9%A0/>7.10 练习</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.2-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/>7.2 深入理解</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.3-%E8%A6%86%E7%9B%96%E4%B8%8E%E9%87%8D%E8%BD%BD/>7.3 覆盖与重载</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95/>7.4 抽象类和方法</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.5-%E6%8E%A5%E5%8F%A3/>7.5 接口</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.6-%E5%86%85%E9%83%A8%E7%B1%BB/>7.6 内部类</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.7-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81%E6%80%A7/>7.7 构造器和多态性</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.8-%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1/>7.8 通过继承进行设计</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/7.%E5%A4%9A%E6%80%81%E6%80%A7/7.9-%E6%80%BB%E7%BB%93/>7.9 总结</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide8fec1c6956e847a0af483b3edf921cd")' href=#ide8fec1c6956e847a0af483b3edf921cd aria-expanded=false aria-controls=ide8fec1c6956e847a0af483b3edf921cd aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/>8.对象的容纳</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide8fec1c6956e847a0af483b3edf921cd aria-expanded=false aria-controls=ide8fec1c6956e847a0af483b3edf921cd><i class="fa-solid fa-angle-right" id=caret-ide8fec1c6956e847a0af483b3edf921cd></i></a></div><ul class="nav docs-sidenav collapse" id=ide8fec1c6956e847a0af483b3edf921cd><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.1-%E6%95%B0%E7%BB%84/>8.1 数组</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.2-%E9%9B%86%E5%90%88/>8.2 集合</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.3-%E8%BF%AD%E4%BB%A3%E5%99%A8/>8.3 迭代器</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.4-%E9%9B%86%E5%90%88%E7%9A%84%E7%B1%BB%E5%9E%8B/>8.4 集合的类型</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.5-%E6%8E%92%E5%BA%8F/>8.5 排序</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.6-%E9%80%9A%E7%94%A8%E9%9B%86%E5%90%88%E5%BA%93/>8.6 通用集合库</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.7-%E6%96%B0%E9%9B%86%E5%90%88/>8.7 新集合</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.8-%E6%80%BB%E7%BB%93/>8.8 总结</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/8.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/8.9-%E7%BB%83%E4%B9%A0/>8.9 练习</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id24b0f4bf6b1849b1d34cc1cf59d9a598")' href=#id24b0f4bf6b1849b1d34cc1cf59d9a598 aria-expanded=false aria-controls=id24b0f4bf6b1849b1d34cc1cf59d9a598 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/9.%E5%BC%82%E5%B8%B8%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/>9.异常差错控制</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id24b0f4bf6b1849b1d34cc1cf59d9a598 aria-expanded=false aria-controls=id24b0f4bf6b1849b1d34cc1cf59d9a598><i class="fa-solid fa-angle-right" id=caret-id24b0f4bf6b1849b1d34cc1cf59d9a598></i></a></div><ul class="nav docs-sidenav collapse" id=id24b0f4bf6b1849b1d34cc1cf59d9a598><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/9.%E5%BC%82%E5%B8%B8%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/9.10-%E7%BB%83%E4%B9%A0/>9.10 练习</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/9.%E5%BC%82%E5%B8%B8%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/9.6-%E7%94%A8finally%E6%B8%85%E9%99%A4/>9.6 用finally清除</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/9.%E5%BC%82%E5%B8%B8%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/9.7-%E6%9E%84%E9%80%A0%E5%99%A8/>9.7 构造器</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/9.%E5%BC%82%E5%B8%B8%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/9.9-%E6%80%BB%E7%BB%93/>9.9 总结</a></li></ul></div><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E9%99%84%E5%BD%95a-%E4%BD%BF%E7%94%A8%E9%9D%9Ejava%E4%BB%A3%E7%A0%81/>附录A 使用非JAVA代码</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E9%99%84%E5%BD%95b-%E5%AF%B9%E6%AF%94c++%E5%92%8Cjava/>附录B 对比C++和Java</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E9%99%84%E5%BD%95c-java%E7%BC%96%E7%A8%8B%E8%A7%84%E5%88%99/>附录C Java编程规则</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E9%99%84%E5%BD%95d-%E6%80%A7%E8%83%BD/>附录D 性能</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E9%99%84%E5%BD%95e-%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%9D/>附录E 关于垃圾收集的一些话</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E9%99%84%E5%BD%95f-%E6%8E%A8%E8%8D%90%E8%AF%BB%E7%89%A9/>附录F 推荐读物</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/>写在前面的话</a></li><li class="child level"><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/think-in-java/%E5%BC%95%E8%A8%80/>引言</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#术语问题>术语问题</a></li><li><a href=#并发的新定义>并发的新定义</a></li><li><a href=#并发的超能力>并发的超能力</a></li><li><a href=#并发为速度而生>并发为速度而生</a></li><li><a href=#java-并发的四句格言>Java 并发的四句格言</a><ul><li><a href=#1不要用它>1.不要用它</a></li><li><a href=#2没有什么是真的一切可能都有问题>2.没有什么是真的，一切可能都有问题</a></li><li><a href=#3仅仅是它能运行并不意味着它没有问题>3.仅仅是它能运行，并不意味着它没有问题</a></li><li><a href=#4你必须理解它>4.你必须理解它</a></li></ul></li><li><a href=#残酷的真相>残酷的真相</a></li><li><a href=#本章其余部分>本章其余部分</a></li><li><a href=#并行流>并行流</a></li><li><a href=#创建和运行任务>创建和运行任务</a></li><li><a href=#终止耗时任务>终止耗时任务</a></li><li><a href=#completablefuture-类>CompletableFuture 类</a><ul><li><a href=#基本用法>基本用法</a></li><li><a href=#结合-completablefuture>结合 CompletableFuture</a></li><li><a href=#模拟>模拟</a></li><li><a href=#异常>异常</a></li><li><a href=#流异常stream-exception>流异常（Stream Exception）</a></li><li><a href=#检查性异常>检查性异常</a></li></ul></li><li><a href=#死锁>死锁</a></li><li><a href=#构造方法非线程安全>构造方法非线程安全</a></li><li><a href=#复杂性和代价>复杂性和代价</a></li><li><a href=#本章小结>本章小结</a><ul><li><a href=#缺点>缺点</a></li><li><a href=#共享内存陷阱>共享内存陷阱</a></li><li><a href=#this-albatross-is-big>This Albatross is Big</a></li><li><a href=#其他类库>其他类库</a></li><li><a href=#考虑为并发设计的语言>考虑为并发设计的语言</a></li><li><a href=#拓展阅读>拓展阅读</a></li></ul></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>24-Concurrent-Programming</h1><div class=article-style><h1 id=第二十四章-并发编程>第二十四章 并发编程</h1><blockquote><p>爱丽丝：“我可不想到疯子中间去”</p><p>猫咪：“啊，那没辙了，我们这都是疯子。我疯了，你也疯了”</p><p>爱丽丝：“你怎么知道我疯了”。</p><p>猫咪：“你一定是疯了，否则你就不会来这儿” ——爱丽丝梦游仙境 第 6 章。</p></blockquote><p>在本章之前，我们惯用一种简单顺序的叙事方式来编程，有点类似文学中的意识流：第一件事发生了，然后是第二件，第三件……总之，我们完全掌握着事情发生的进展和顺序。如果我们将一个值设置为 5，再看时它已变成 47 的话，这就令人匪夷所思了。</p><p>现在，我们来到了陌生的并发世界，在这里这样的结果一点都不奇怪。你原来相信的一切都不再可靠。原有的规则可能生效也可能失效。更可能的是原有的规则只会在某些情况下生效。我们只有完全了解这些情况，才能决定我们处理事情的方式。</p><p>比如，我们正常的生活的世界是遵循经典牛顿力学的。物体具有质量：会坠落并且转移动能。电线有电阻，光沿直线传播。假如我们进入到极小、极大、极冷或者极热（那些我们无法生存的世界），这些现象就会发生改变。我们无法判断某物体是粒子还是波，光是否受到重力影响，一些物质还会变为超导体。</p><p>假设我们处在多条故事线并行的间谍小说里，非单一意识流地叙事：第一个间谍在岩石底留下了微缩胶片。当第二个间谍来取时，胶片可能已被第三个间谍拿走。小说并没有交代此处的细节。所以直到故事结尾，我们都没搞清楚到底发生了什么。</p><p>构建并发程序好比玩<a href=https://en.wikipedia.org/wiki/Jenga target=_blank rel=noopener>搭积木</a>游戏。每拉出一块放在塔顶时都有崩塌的可能。每个积木塔和应用程序都是独一无二的，有着自己的作用。你在某个系统构建中学到的知识并不一定适用于下一个系统。</p><p>本章是对并发概念最基本的介绍。虽然我们用到了现代的 Java 8 工具来演示原理，但还远未及全面论述并发。我的目标是为你提供足够的基础知识，使你能够把握问题的复杂性和危险性，从而安全地渡过这片鲨鱼肆虐的困难水域。</p><p>更多繁琐和底层的细节，请参阅附录：<a href=https://github.com/LingCoder/OnJava8/blob/master/docs/book/Appendix-Low-Level-Concurrency.md target=_blank rel=noopener>并发底层原理</a>。要进一步深入这个领域，你还必须阅读 <em>Brian Goetz</em> 等人的 《Java Concurrency in Practice》。在撰写本文时，该书已有十多年的历史了，但它仍包含我们必须要了解和明白的知识要点。理想情况下，本章和上述附录是阅读该书的良好前提。另外，<em>Bill Venner</em> 的 《Inside the Java Virtual Machine》也很值得一看。它详细描述了包括线程在内的 JVM 的内部工作方式。</p><h2 id=术语问题>术语问题</h2><p>术语“并发”，“并行”，“多任务”，“多处理”，“多线程”，分布式系统（可能还有其他）在整个编程文献中都以多种相互冲突的方式使用，并且经常被混为一谈。 <em>Brian Goetz</em> 在他 2016 年《从并发到并行》的演讲中指出了这一点，之后提出了合理的区分：</p><ul><li>并发是关于正确有效地控制对共享资源的访问。</li><li>并行是使用额外的资源来更快地产生结果。</li></ul><p>这些定义很好，但是我们已有几十年混乱使用和抗拒解决此问题的历史了。一般来说，当人们使用“并发”这个词时，他们的意思是“所有的一切”。事实上，我自己也经常陷入这样的想法。在大多数书籍中，包括 <em>Brian Goetz</em> 的 《Java Concurrency in Practice》，都在标题中使用这个词。</p><p>“并发”通常表示：”不止一个任务正在执行“。而“并行”几乎总是代表：”不止一个任务同时执行“。现在我们能立即看出这些定义中的问题所在：“并行”也有不止一个任务正在执行的语义在里面。区别就在于细节：究竟是怎么“执行”的。此外还有一些重叠：为并行编写的程序依旧可以在单处理器上运行，而并发编写的系统也可以利用多个处理器。</p><p>还有另一种方式，围绕”缓慢“出现的情况写下定义：</p><p><strong>并发</strong></p><p>同时完成多任务。无需等待当前任务完成即可执行其他任务。“并发”解决了程序因外部控制而无法进一步执行的阻塞问题。最常见的例子就是 I/O 操作，任务必须等待数据输入（在一些例子中也称阻塞）。这个问题常见于 I/O 密集型任务。</p><p><strong>并行</strong></p><p>同时在多个位置完成多任务。这解决了所谓的 CPU 密集型问题：将程序分为多部分，在多个处理器上同时处理不同部分来加快程序执行效率。</p><p>上面的定义说明了这两个术语令人困惑的原因：两者的核心都是“同时完成多个任务”，不过并行增加了跨多个处理器的分布。更重要的是，它们可以解决不同类型的问题：并行可能对解决 I / O 密集型问题没有任何好处，因为问题不在于程序的整体执行速度，而在于 I/O 阻塞。而尝试在单个处理器上使用并发来解决计算密集型问题也可能是浪费时间。两种方法都试图在更短的时间内完成更多工作，但是它们实现加速的方式有所不同，这取决于问题施加的约束。</p><p>这两个概念混合在一起的一个主要原因是包括 Java 在内的许多编程语言使用相同的机制 - <strong>线程</strong>来实现并发和并行。</p><p>我们甚至可以尝试以更细的粒度去进行定义（然而这并不是标准化的术语）：</p><ul><li><p><strong>纯并发</strong>：仍然在单个 CPU 上运行任务。纯并发系统比时序系统更快地产生结果，但是它的运行速度不会因为处理器的增加而变得更快。</p></li><li><p><strong>并发-并行</strong>：使用并发技术，结果程序可以利用多处理器更快地产生结果。</p></li><li><p><strong>并行-并发</strong>：使用并行编程技术编写，即使只有一个处理器，结果程序仍然可以运行（Java 8 <strong>Streams</strong> 就是一个很好的例子）。</p></li><li><p><strong>纯并行</strong>：只有多个处理器的情况下才能运行。</p></li></ul><p>在某些情况下，这是一个有效的分类法。</p><p>支持并发性的语言和库似乎是<a href=https://en.wikipedia.org/wiki/Leaky_abstraction target=_blank rel=noopener>抽象泄露（Leaky Abstraction</a>一词的完美候选。抽象的目标是“抽象”掉那些对手头的想法不重要的部分，以屏蔽不必要的细节所带来的影响。如果抽象发生泄露，那么即使费很大功夫去隐藏它们，这些细枝末节也总会不断凸显出自己是重要的。</p><p>于是我开始怀疑是否真的有高度地抽象。因为当编写这类程序时，底层的系统、工具，甚至是关于 CPU 缓存如何工作的细节，都永远不会被屏蔽。最后，即使你已非常谨慎，你开发的程序也不一定在所有情况下运行正常。有时是因为两台机器的配置不同，有时是程序的预计负载不同。这不是 Java 特有的 - 这是并发和并行编程的本质。</p><p>你可能会认为<a href=https://en.wikipedia.org/wiki/Purely_functional target=_blank rel=noopener>纯函数式</a>语言没有这些限制。实际上，纯函数式语言的确解决了大量并发问题。如果你正在解决一个困难的并发问题，可以考虑用纯函数语言编写这个部分。但是，如果你编写一个使用队列的系统，例如，如果该系统没有被合理地调优，并且输入速率也没有被正确地估计或限制（在不同的情况下，限制意味着具有不同的影响的不同东西），该队列要么被填满并阻塞，要么溢出。最后，你必须了解所有可能会破坏你的系统的细节和问题。这是一种非常不同的编程方式。</p><h2 id=并发的新定义>并发的新定义</h2><p>几十年来，我一直在努力解决各种形式的并发问题，其中一个最大的挑战是简洁的定义它。在撰写本章的过程中，我终于有了这样的洞察力，我将其定义为：</p><blockquote><p>并发性是一系列专注于减少等待的性能技术</p></blockquote><p>这实际上是一个相当复杂的表述，所以我将其分解：</p><ul><li>这是一个集合：包含许多不同的方法来解决这个问题。因为技术差异很大，这是使定义并发性如此具有挑战性的问题之一。</li><li>这些是性能技术：就是这样。并发的关键点在于让你的程序运行得更快。在 Java 中，并发是非常棘手和困难的，所以绝对不要使用它，除非你有一个重大的性能问题 - 即使这样，使用最简单的方法产生你需要的性能，因为并发很快变得难以管理。</li><li>“减少等待”部分很重要而且微妙。无论（例如）你的程序运行在多少个处理器上，你只能在等待发生时产生效益。如果你发起 I/O 请求并立即获得结果，没有延迟，因此无需改进。如果你在多个处理器上运行多个任务，并且每个处理器都以满容量运行，并且没有任务需要等待其他任务，那么尝试提高吞吐量是没有意义的。并发的唯一机会是程序的某些部分被迫等待。等待会以多种形式出现 - 这解释了为什么存在多种不同的并发方法。</li></ul><p>值得强调的是，这个定义的有效性取决于“等待”这个词。如果没有什么可以等待，那就没有机会去加速。如果有什么东西在等待，那么就会有很多方法可以加快速度，这取决于多种因素，包括系统运行的配置，你要解决的问题类型以及其他许多问题。</p><h2 id=并发的超能力>并发的超能力</h2><p>想象一下，你置身于一部科幻电影。你必须在一栋大楼中找到一个东西，它被小心而巧妙地隐藏在大楼千万个房间中的一间。你进入大楼，沿着走廊走下去。走廊是分开的。</p><p>一个人完成这项任务要花上一百辈子的时间。</p><p>现在假设你有一个奇怪的超能力。你可以将自己一分为二，然后在继续前进的同时将另一半送到另一个走廊。每当你在走廊或楼梯上遇到分隔到下一层时，你都会重复这个分裂的技巧。最终，整个建筑中的每个走廊的终点都有一个你。</p><p>每个走廊都有一千个房间。此时你的超能力变得弱了一点，你只能克隆 50 个自己来并发搜索走廊里面的房间。</p><p>一旦克隆体进入房间，它必须搜索房间的每个角落。这时它切换到了第二种超能力。它分裂成了一百万个纳米机器人，每个机器人都会飞到或爬到房间里一些看不见的地方。你不需要了解这种功能 - 一旦你开启它就会自动工作。在他们自己的控制下，纳米机器人开始行动，搜索房间然后回来重新组装成你，突然间，不知怎么的，你就知道这间房间里有没有那个东西。</p><p>我很想说，“并发就是刚才描述的置身于科幻电影中的超能力“。就像你自己可以一分为二然后解决更多的问题一样简单。但是问题在于，我们来描述这种现象的任何模型最终都是抽象泄露的（leaky abstraction)。</p><p>以下是其中一个泄露：在理想的世界中，每次克隆自己时，也会复制一个物理处理器来运行克隆搜索者。这当然是不现实的——实际上，你的机器上一般只有 4 个或 8 个处理器核心（编写本文时的典型情况）。或许你拥有更多的处理器，但仍有很多情况下只有一个单核处理器。在关于抽象的讨论中，分配物理处理器核心这本身就是抽象的泄露，甚至也可以支配你的决策。</p><p>让我们在科幻电影中改变一些东西。现在当每个克隆搜索者最终到达一扇门时，他们必须敲门并等到有人开门。如果每个搜索者都有一个处理器核心，这没有问题——只是空闲等待直到有人开门。但是如果我们只有 8 个处理器核心却有几千个搜索者，我们不希望处理器仅仅因为某个搜索者恰好在等待回答中被锁住而闲置下来。相反，我们希望将处理器应用于可以真正执行工作的搜索者身上，因此需要将处理器从一个任务切换到另一个任务的机制。</p><p>许多模型能够有效地隐藏处理器的数量，允许你假装有很多个处理器。但在某些情况下，当你必须明确知道处理器数量以便于工作的时候，这些模型就会失效。</p><p>最大的影响之一取决于是使用单核处理器还是多核处理器。如果你只有单核处理器，那么任务切换的成本也由该核心承担，将并发技术应用于你的系统会使它运行得更慢。</p><p>这可能会让你以为，在单核处理器的情况下，编写并发代码是没有意义的。然而，有些情况下，并发模型会产生更简单的代码，光是为了这个目的就值得舍弃一些性能。</p><p>在克隆体敲门等待的情况下，即使单核处理器系统也能从并发中受益，因为它可以从等待（阻塞）的任务切换到准备运行的任务。但是如果所有任务都可以一直运行那么切换的成本反而会使任务变慢，在这种情况下，并发只在如果你有多个处理器的情况下有意义。</p><p>假设你正在尝试破解某种密码，在同一时间内参与破解的线程越多，你越快得到答案的可能性就越大。每个线程都能持续使用你所分配的处理器时间，在这种情况下（CPU 密集型问题），你代码中的线程数应该和你拥有的处理器的核心数保持一致。</p><p>在接听电话的客户服务部门，你只有一定数量的员工，但是你的部门可能会收到很多电话。这些员工（处理器）一次只能接听一个电话直到打完，此时其它打来的电话必须排队等待。</p><p>在“鞋匠和精灵”的童话故事中，鞋匠有很多工作要做，当他睡着时，出现了一群精灵来为他制作鞋子。这里的工作是分布式的，但即使使用大量的物理处理器，在制造鞋子的某些部件时也会产生限制——例如，如果鞋底的制作时间最长，这就限制了鞋子的制作速度，这也会改变你设计解决方案的方式。</p><p>因此，你要解决的问题驱动了方案的设计。将一个问题分解成“独立运行”的子任务，这是一种美好的抽象，然后就是实际发生的现实：物理现实不断干扰和动摇这个抽象。</p><p>这只是问题的一部分：考虑一个制作蛋糕的工厂。我们以某种方式把制作蛋糕的任务分给了工人们，现在是时候让工人把蛋糕放在盒子里了。那里有一个准备存放蛋糕的盒子。但是在一个工人把蛋糕放进盒子之前，另一个工人就冲过去，把蛋糕放进盒子里，砰！这两个蛋糕撞到一起砸坏了。这是常见的“共享内存”问题，会产生所谓的竞态条件（race condition），其结果取决于哪个工人能先把蛋糕放进盒子里（通常使用锁机制来解决问题，因此一个工作人员可以先抓住一个盒子并防止蛋糕被砸烂）。</p><p>当“同时”执行的任务相互干扰时，就会出现问题。这可能以一种微妙而偶然的方式发生，因此可以说并发是“可以论证的确定性，但实际上是不确定性的”。也就是说，假设你很小心地编写并发程序，而且通过了代码检查可以正确运行。然而实际上，我们编写的并发程序大部分情况下都能正常运行，但是在一些特定情况下会失败。这些情况可能永远不会发生，或者在你在测试期间几乎很难发现它们。实际上，编写测试代码通常无法为并发程序生成故障条件。由此产生的失败只会偶尔发生，因此它们以客户投诉的形式出现。这是学习并发中最强有力的论点之一：如果你忽略它，你可能会受伤。</p><p>因此，并发似乎充满了危险，如果这让你有点害怕，这可能是一件好事。尽管 Java 8 在并发性方面做出了很大改进，但仍然没有像编译时验证 (compile-time verification) 或受检查的异常 (checked exceptions) 那样的安全网来告诉你何时出现错误。关于并发，你只能依靠自己，只有知识渊博、保持怀疑和积极进取的人，才能用 Java 编写可靠的并发代码。</p><h2 id=并发为速度而生>并发为速度而生</h2><p>在听说并发编程的问题之后，你可能会想知道它是否值得这么麻烦。答案是“不，除非你的程序运行速度不够快。”并且在决定用它之前你会想要仔细思考。不要随便跳进并发编程的悲痛之中。如果有一种方法可以在更快的机器上运行你的程序，或者如果你可以对其进行分析并发现瓶颈并在该位置替换更快的算法，那么请执行此操作。只有在显然没有其他选择时才开始使用并发，然后仅在必要的地方去使用它。</p><p>速度问题一开始听起来很简单：如果你想要一个程序运行得更快，将其分解为多个部分，并在单独的处理器上运行每个部分。随着我们提高时钟速度的能力耗尽（至少对传统芯片而言），速度的提高是出现在多核处理器的形式而不是更快的芯片。为了使程序运行得更快，你必须学会利用那些额外的处理器（译者注：处理器一般代表 CPU 的一个逻辑核心），这是并发所带来的好处之一。</p><p>对于多处理器机器，可以在这些处理器之间分配多个任务，这可以显著提高吞吐量。强大的多处理器 Web 服务器通常就是这种情况，它可以在程序中为 CPU 分配大量用户请求，每个请求分配一个线程。</p><p>但是，并发通常可以提高在单处理器上运行的程序的性能。这听起来有点违反直觉。如果你仔细想想，由于上下文切换的成本增加（从一个任务切换到另一个任务），在单个处理器上运行的并发程序实际上应该比程序的所有部分顺序运行具有更多的开销。从表面上看，将程序的所有部分作为单个任务运行，并且节省上下文切换的成本，这样看似乎更划算。</p><p>使这个问题变得有些不同的是阻塞。如果程序中的某个任务由于程序控制之外的某种情况而无法继续（通常是 I/O），我们就称该任务或线程已阻塞（在我们的科幻故事中，就是克隆人已经敲门并等待它打开）。如果没有并发，整个程序就会停下来，直到外部条件发生变化。但是，如果使用并发编写程序，则当一个任务被阻塞时，程序中的其他任务可以继续执行，因此整个程序得以继续运行。事实上，从性能的角度来看，如果没有任务会阻塞，那么在单处理器机器上使用并发是没有意义的。</p><p>单处理器系统中性能改进的一个常见例子是事件驱动编程，特别是用户界面编程。考虑一个程序执行一些耗时操作，最终忽略用户输入导致无响应。如果你有一个“退出”按钮，你不想在你编写的每段代码中都检查它的状态（轮询）。这会产生笨拙的代码，也无法保证程序员不会忘了检查。没有并发，生成可响应用户界面的唯一方法是让所有任务都定期检查用户输入。通过创建单独的线程以执行用户输入的响应，能够让程序保证一定程度的响应能力。</p><p>实现并发的一种简单方式是使用操作系统级别的进程。与线程不同，进程是在其自己的地址空间中运行的独立程序。进程的优势在于，因为操作系统通常将一个进程与另一个进程隔离，因此它们不会相互干扰，这使得进程编程相对容易。相比之下，线程之间会共享内存和 I/O 等资源，因此编写多线程程序最基本的困难，在于协调不同线程驱动的任务之间对这些资源的使用，以免这些资源同时被多个任务访问。</p><p>有些人甚至提倡将进程作为唯一合理的并发实现方式<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，但遗憾的是，通常存在数量和开销方面的限制，从而阻止了进程在并发范围内的适用性（最终你会习惯标准的并发限制，“这种方法适用于一些情况但不适用于其他情况”）</p><p>一些编程语言旨在将并发任务彼此隔离。这些通常被称为<em>函数式语言</em>，其中每个函数调用不产生副作用（不会干扰到其它函数），所以可以作为独立的任务来驱动。Erlang 就是这样一种语言，它包括一个任务与另一个任务进行通信的安全机制。如果发现程序的某一部分必须大量使用并发，并且在尝试构建该部分时遇到了过多的问题，那么可以考虑使用这些专用的并发语言创建程序的这个部分。</p><p>Java 采用了更传统的方法<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，即在顺序语言之上添加对线程的支持而不是在多任务操作系统中分叉外部进程，线程是在表示执行程序的单个进程内创建任务。</p><p>并发会带来各种成本，包括复杂性成本，但可以被程序设计、资源平衡和用户便利性方面的改进所抵消。通常，并发性使你能够创建更低耦合的设计；另一方面，你必须特别关注那些使用了并发操作的代码。</p><h2 id=java-并发的四句格言>Java 并发的四句格言</h2><p>在经历了多年 Java 并发的实践之后，我总结了以下四个格言：</p><blockquote><p>1.不要用它（避免使用并发）</p><p>2.没有什么是真的，一切可能都有问题</p><p>3.仅仅是它能运行，并不意味着它没有问题</p><p>4.你必须理解它（逃不掉并发）</p></blockquote><p>这些格言专门针对 Java 的并发设计问题，尽管它们也可以适用于其他一些语言。但是，确实存在旨在防止这些问题的语言。</p><h3 id=1不要用它>1.不要用它</h3><p>（而且不要自己去实现它）</p><p>避免陷入并发所带来的玄奥问题的最简单方法就是不要用它。尽管尝试一些简单的东西可能很诱人，也似乎足够安全，但是陷阱却是无穷且微妙的。如果你能避免使用它，你的生活将会轻松得多。</p><p>使用并发唯一的正当理由是速度。如果你的程序运行速度不够快——这里要小心，因为仅仅想让它运行得更快不是正当理由——应该首先用一个分析器（参见代码校验章中分析和优化）来发现你是否可以执行其他一些优化。</p><p>如果你被迫使用并发，请采取最简单，最安全的方法来解决问题。使用知名的库并尽可能少地自己编写代码。对于并发，就没有“太简单了”——自作聪明是你的敌人。</p><h3 id=2没有什么是真的一切可能都有问题>2.没有什么是真的，一切可能都有问题</h3><p>不使用并发编程，你已经预料到你的世界具有确定的顺序和一致性。对于变量赋值这样简单的操作，很明显它应该总是能够正常工作。</p><p>在并发领域，有些事情可能是真的而有些事情却不是，以至于你必须假设没有什么是真的。你必须质疑一切。即使将变量设置为某个值也可能不会按预期的方式工作，事情从这里开始迅速恶化。我已经熟悉了这样一种感觉：我认为应该明显奏效的东西，实际上却行不通。</p><p>在非并发编程中你可以忽略的各种事情，在并发下突然变得很重要。例如，你必须了解处理器缓存以及保持本地缓存与主内存一致的问题，你必须理解对象构造的深层复杂性，这样你的构造函数就不会意外地暴露数据，以致于被其它线程更改。这样的例子不胜枚举。</p><p>虽然这些主题过于复杂，无法在本章中给你提供专业知识（同样，请参见 Java Concurrency in Practice），但你必须了解它们。</p><h3 id=3仅仅是它能运行并不意味着它没有问题>3.仅仅是它能运行，并不意味着它没有问题</h3><p>我们很容易编写出一个看似正常实则有问题的并发程序，而且问题只有在极少的情况下才会显现出来——在程序部署后不可避免地会成为用户问题（投诉）。</p><ul><li>你不能验证出并发程序是正确的，你只能（有时）验证出它是不正确的。</li><li>大多数情况下你甚至没办法验证：如果它出问题了，你可能无法检测到它。</li><li>你通常无法编写有用的测试，因此你必须依靠代码检查和对并发的深入了解来发现错误。</li><li>即使是有效的程序也只能在其设计参数下工作。当超出这些设计参数时，大多数并发程序会以某种方式失败。</li></ul><p>在其他 Java 主题中，我们养成了决定论的观念。一切都按照语言的承诺的（或暗示的）发生，这是令人欣慰的也是人们所期待的——毕竟，编程语言的意义就是让机器做我们想要它做的事情。从确定性编程的世界进入并发编程领域，我们遇到了一种称为 <a href=https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect target=_blank rel=noopener>邓宁-克鲁格效应</a> 的认知偏差，可以概括为“无知者无畏”，意思是：“相对不熟练的人拥有着虚幻的优越感，错误地评估他们的能力远高于实际。</p><p>我自己的经验是，无论你是多么确定你的代码是<em>线程安全</em>的，它都可能是有问题的。你可以很容易地了解所有的问题，然后几个月或几年后你会发现一些概念，让你意识到你编写的大多数代码实际上都容易受到并发 bug 的影响。当某些代码不正确时，编译器不会告诉你。为了使它正确，在研究代码时，必须将并发性的所有问题都放在前脑中。</p><p>在 Java 的所有非并发领域，“没有明显的 bug 而且没有编译报错“似乎意味着一切都好。但对于并发，它没有任何意义。在这种情况你最糟糕的表现就是“自信”。</p><h3 id=4你必须理解它>4.你必须理解它</h3><p>在格言 1-3 之后，你可能会对并发性感到害怕，并且认为，“到目前为止，我已经避免了它，也许我可以继续避免它。</p><p>这是一种理性的反应。你可能知道其他更好地被设计用于构建并发程序的编程语言——甚至是在 JVM 上运行的语言（从而提供与 Java 的轻松通信），例如 Clojure 或 Scala。为什么不用这些语言来编写并发部分，然后用 Java 来做其他的事情呢?</p><p>唉，你不能轻易逃脱：</p><ul><li>即使你从未显示地创建一个线程，你使用的框架也可能——例如，Swing 图形用户界面（GUI）库，或者像 <strong>Timer</strong> 类（计时器）那样简单的东西。</li><li>最糟糕的是：当你创建组件时，必须假设这些组件可能会在多线程环境中重用。即使你的解决方案是放弃并声明你的组件是“非线程安全的”，你仍然必须充分了解这样一个语句的重要性及其含义。</li></ul><p>人们有时会认为并发对于介绍语言的书来说太高级了，因此不适合放在其中。他们认为并发是一个独立的主题，并且对于少数出现在日常的程序设计中的情况（例如图形用户界面），可以用特殊的惯用法来处理。如果你可以回避，为什么还要介绍这么复杂的主题呢？</p><p>唉，如果是这样就好了。遗憾的是，对于线程何时出现在 Java 程序中，这不是你能决定的。仅仅是你自己没有启动线程，并不代表你就可以回避编写使用线程的代码。例如，Web 系统是最常见的 Java 应用之一，本质上是多线程的 Web 服务器，通常包含多个处理器，而并行是利用这些处理器的理想方式。尽管这样的系统看起来很简单，但你必须理解并发才能正确地编写它。</p><p>Java 是一种多线程语言，不管你有没有意识到并发问题，它就在那里。因此，有很多使用并发的 Java 程序，要么只是偶然运行，要么大部分时间都在运行，并且会因为未被发现的并发缺陷而时不时地神秘崩溃。有时这种崩溃是相对温和的，但有时它意味着丢失有价值的数据，如果你没有意识到并发问题，你最终可能会把问题归咎于其他地方而不是你的代码中。如果将程序移动到多处理器系统中，这些类型的问题还会被暴露或放大。基本上，了解并发可以使你意识到明显正确的程序也可能会表现出错误的行为。</p><h2 id=残酷的真相>残酷的真相</h2><p>当人类开始烹饪他们的食物时，他们大大减少了他们的身体分解和消化食物所需的能量。烹饪创造了一个“外化的胃”，从而释放出能量去发展其他的能力。火的使用促成了文明。</p><p>我们现在通过计算机和网络技术创造了一个“外化大脑”，开始了第二次基本转变。虽然我们只是触及表面，但已经引发了其他转变，例如设计生物机制的能力，并且已经看到文化演变的显著加速（过去，人们通过旅游进行文化交流，但现在他们开始在互联网上做这件事）。这些转变的影响和好处已经超出了科幻作家预测它们的能力（他们在预测文化和个人变化，甚至技术转变的次要影响方面都特别困难）。</p><p>有了这种根本性的人类变化，看到许多破坏和失败的实验并不令人惊讶。实际上，进化依赖于无数的实验，其中大多数都失败了。这些实验是向前发展的必要条件。</p><p>Java 是在充满自信，热情和睿智的氛围中创建的。在发明一种编程语言时，很容易感觉语言的初始可塑性会持续存在一样，你可以把某些东西拿出来，如果不能解决问题，那么就修复它。编程语言以这种方式是独一无二的 - 它们经历了类似水的改变：气态，液态和最终的固态。在气态阶段，灵活性似乎是无限的，并且很容易认为它总是那样。一旦人们开始使用你的语言，变化就会变得更加严重，环境变得更加粘稠。语言设计的过程本身就是一门艺术。</p><p>紧迫感来自互联网的最初兴起。它似乎是一场比赛，第一个通过起跑线的人将“获胜”（事实上，Java，JavaScript 和 PHP 等语言的流行程度可以证明这一点）。唉，通过匆忙设计语言而产生的认知负荷和技术债务最终会赶上我们。</p><p><a href=https://en.wikipedia.org/wiki/Turing_completeness target=_blank rel=noopener>Turing completeness</a> 是不足够的;语言需要更多的东西：它们必须能够创造性地表达，而不是用不必要的东西来衡量我们。解放我们的心理能力只是为了扭转并再次陷入困境，这是毫无意义的。我承认，尽管存在这些问题，我们已经完成了令人惊奇的事情，但我也知道如果没有这些问题我们能做得更多。</p><p>热情使原始 Java 设计师加入了一些似乎有必要的特性。信心（以及气态的初始语言）让他们认为任何问题随后都可以解决。在时间轴的某个地方，有人认为任何加入 Java 的东西是固定的和永久性的 -他们非常有信心，并相信第一个决定永远是正确的，因此我们看到 Java 的体系中充斥着糟糕的决策。其中一些决定最终没有什么后果;例如，你可以告诉人们不要使用 Vector，但只能在语言中继续保留它以便对之前版本的支持。</p><p>线程包含在 Java 1.0 中。当然，对 java 来说支持并发是一个很基本的设计决定，该特性影响了这个语言的各个角落，我们很难想象以后在以后的版本添加它。公平地说，当时并不清楚基本的并发性是多少。像 C 这样的其他语言能够将线程视为一个附加功能，因此 Java 设计师也纷纷效仿，包括一个 Thread 类和必要的 JVM 支持（这比你想象的要复杂得多）。</p><p>C 语言是面向过程语言，这限制了它的野心。这些限制使附加线程库合理。当采用原始模型并将其粘贴到复杂语言中时，Java 的大规模扩展迅速暴露了基本问题。在 Thread 类中的许多方法的弃用以及后续的高级库浪潮中，这种情况变得明显，这些库试图提供更好的并发抽象。</p><p>不幸的是，为了在更高级别的语言中获得并发性，所有语言功能都会受到影响，包括最基本的功能，例如标识符代表可变值。在简化并发编程中，所有函数和方法中为了保持事物不变和防止副作用都要做出巨大的改变（这些是纯函数式编程语言的基础），但当时对于主流语言的创建者来说似乎是奇怪的想法。最初的 Java 设计师要么没有意识到这些选择，要么认为它们太不同了，并且会劝退许多潜在的语言使用者。我们可以慷慨地说，语言设计社区当时根本没有足够的经验来理解调整在线程库中的影响。</p><p>Java 实验告诉我们，结果是悄然灾难性的。程序员很容易陷入认为 Java 线程并不那么困难的陷阱。表面上看起来正常工作的程序实际上充满了微妙的并发 bug。</p><p>为了获得正确的并发性，语言功能必须从头开始设计并考虑并发性。木已成舟；Java 将不再是为并发而设计的语言，而只是一种允许并发的语言。</p><p>尽管有这些基本的不可修复的缺陷，但令人印象深刻的是它已经走了这么远。Java 的后续版本添加了库，以便在使用并发时提升抽象级别。事实上，我根本不会想到有可能在 Java 8 中进行改进：并行流和 <strong>CompletableFutures</strong> - 这是惊人的史诗般的变化，我会惊奇地重复的查看它<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。</p><p>这些改进非常有用，我们将在本章重点介绍并行流和 <strong>CompletableFutures</strong> 。虽然它们可以大大简化你对并发和后续代码的思考方式，但基本问题仍然存在：由于 Java 的原始设计，代码的所有部分仍然很脆弱，你仍然必须理解这些复杂和微妙的问题。Java 中的线程绝不是简单或安全的;那种经历必须降级为另一种更新的语言。</p><h2 id=本章其余部分>本章其余部分</h2><p>这是我们将在本章的其余部分介绍的内容。请记住，本章的重点是使用最新的高级 Java 并发结构。相比于旧的替代品，使用这些会使你的生活更加轻松。但是，你仍会在遗留代码中遇到一些低级工具。有时，你可能会被迫自己使用其中的一些。附录：<a href=./Appendix-Low-Level-Concurrency.md>并发底层原理</a> 包含一些更原始的 Java 并发元素的介绍。</p><ul><li>Parallel Streams（并行流）
到目前为止，我已经强调了 Java 8 Streams 提供的改进语法。现在该语法（作为一个粉丝，我希望）会使你感到舒适，你可以获得额外的好处：你可以通过简单地将 parallel() 添加到表达式来并行化流。这是一种简单，强大，坦率地说是利用多处理器的惊人方式</li></ul><p>添加 parallel() 来提高速度似乎是微不足道的，但是，唉，它就像你刚刚在<a href=#The-Brutal-Truth>残酷的真相</a> 中学到的那样简单。我将演示并解释一些盲目添加 parallel() 到 Stream 表达式的缺陷。</p><ul><li>创建和运行任务
任务是一段可以独立运行的代码。为了解释创建和运行任务的一些基础知识，本节介绍了一种比并行流或 CompletableFutures 更简单的机制：Executor。执行者管理一些低级 Thread 对象（Java 中最原始的并发形式）。你创建一个任务，然后将其交给 Executor 去运行。</li></ul><p>有多种类型的 Executor 用于不同的目的。在这里，我们将展示规范形式，代表创建和运行任务的最简单和最佳方法。</p><ul><li>终止长时间运行的任务
任务独立运行，因此需要一种机制来关闭它们。典型的方法使用了一个标志，这引入了共享内存的问题，我们将使用 Java 的“Atomic”库来回避它。</li><li>Completable Futures
当你将衣服带到干洗店时，他们会给你一张收据。你继续完成其他任务，当你的衣服洗干净时你可以把它取走。收据是你与干洗店在后台执行的任务的连接。这是 Java 5 中引入的 Future 的方法。</li></ul><p>Future 比以前的方法更方便，但你仍然必须出现并用收据取出干洗，如果任务没有完成你还需要等待。对于一系列操作，Futures 并没有真正帮助那么多。</p><p>Java 8 CompletableFuture 是一个更好的解决方案：它允许你将操作链接在一起，因此你不必将代码写入接口排序操作。有了 CompletableFuture 完美的结合，就可以更容易地做出“采购原料，组合成分，烹饪食物，提供食物，收拾餐具，储存餐具”等一系列链式操作。</p><ul><li>死锁
某些任务必须去<strong>等待 - 阻塞</strong>来获得其他任务的结果。被阻止的任务有可能等待另一个被阻止的任务，另一个被阻止的任务也在等待其他任务，等等。如果被阻止的任务链循环到第一个，没有人可以取得任何进展，你就会陷入死锁。</li></ul><p>如果在运行程序时没有立即出现死锁，则会出现最大的问题。你的系统可能容易出现死锁，并且只会在某些条件下死锁。程序可能在某个平台上（例如在你的开发机器）运行正常，但是当你将其部署到不同的硬件时会开始死锁。</p><p>死锁通常源于细微的编程错误;一系列无辜的决定，最终意外地创建了一个依赖循环。本节包含一个经典示例，演示了死锁的特性。</p><ul><li>努力，复杂，成本</li></ul><p>我们将通过模拟创建披萨的过程完成本章，首先使用并行流实现它，然后是 CompletableFutures。这不仅仅是两种方法的比较，更重要的是探索你应该投入多少工作来使你的程序变得更快。</p><h2 id=并行流>并行流</h2><p>Java 8 流的一个显著优点是，在某些情况下，它们可以很容易地并行化。这来自库的仔细设计，特别是流使用内部迭代的方式 - 也就是说，它们控制着自己的迭代器。特别是，他们使用一种特殊的迭代器，称为 Spliterator，它被限制为易于自动分割。我们只需要念 <code>.parallel()</code> 就会产生魔法般的结果，流中的所有内容都作为一组并行任务运行。如果你的代码是使用 Streams 编写的，那么并行化以提高速度似乎是一种琐事</p><p>例如，考虑来自 Streams 的 Prime.java。查找质数可能是一个耗时的过程，我们可以看到该程序的计时：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/ParallelPrime.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import static</span> <span class=nn>java.util.stream.LongStream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.io.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.nio.file.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ParallelPrime</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>COUNT</span> <span class=o>=</span> <span class=mi>100_000</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>boolean</span> <span class=nf>isPrime</span><span class=o>(</span><span class=kt>long</span> <span class=n>n</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>rangeClosed</span><span class=o>(</span><span class=mi>2</span><span class=o>,</span> <span class=o>(</span><span class=kt>long</span><span class=o>)</span><span class=n>Math</span><span class=o>.</span><span class=na>sqrt</span><span class=o>(</span><span class=n>n</span><span class=o>)).</span><span class=na>noneMatch</span><span class=o>(</span><span class=n>i</span> <span class=o>-&gt;</span> <span class=n>n</span> <span class=o>%</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>throws</span> <span class=n>IOException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Timer</span> <span class=n>timer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Timer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>primes</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>iterate</span><span class=o>(</span><span class=mi>2</span><span class=o>,</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>parallel</span><span class=o>()</span>              <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>ParallelPrime</span><span class=o>::</span><span class=n>isPrime</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=n>COUNT</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>Long</span><span class=o>::</span><span class=n>toString</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>Files</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=n>Paths</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=s>&#34;primes.txt&#34;</span><span class=o>),</span> <span class=n>primes</span><span class=o>,</span> <span class=n>StandardOpenOption</span><span class=o>.</span><span class=na>CREATE</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>    Output:
    1224
</code></pre><p>请注意，这不是微基准测试，因为我们计时整个程序。我们将数据保存在磁盘上以防止编译器过激的优化;如果我们没有对结果做任何事情，那么一个高级的编译器可能会观察到程序没有意义并且终止了计算（这不太可能，但并非不可能）。请注意使用 nio2 库编写文件的简单性（在<a href=./17-Files.md>文件</a> 一章中有描述）。</p><p>当我注释掉[1] parallel() 行时，我的结果用时大约是 parallel() 的三倍。</p><p>并行流似乎是一个甜蜜的交易。你所需要做的就是将编程问题转换为流，然后插入 parallel() 以加快速度。实际上，有时候这很容易。但遗憾的是，有许多陷阱。</p><ul><li>parallel() 不是灵丹妙药</li></ul><p>作为对流和并行流的不确定性的探索，让我们看一个看似简单的问题：对增长的数字序列进行求和。事实证明有大量的方式去实现它，并且我将冒险用计时器将它们进行比较 - 我会尽量小心，但我承认我可能会在计时代码执行时遇到许多基本陷阱之一。结果可能有一些缺陷（例如 JVM 没有“热身”），但我认为它仍然提供了一些有用的指示。</p><p>我将从一个计时方法 <strong>timeTest()</strong> 开始，它采用 <strong>LongSupplier</strong> ，测量 <strong>getAsLong()</strong> 调用的长度，将结果与 <strong>checkValue</strong> 进行比较并显示结果。</p><p>请注意，一切都必须严格使用 <strong>long</strong> ；我花了一些时间发现隐蔽的溢出，然后才意识到在重要的地方错过了 <strong>long</strong> 。</p><p>所有关于时间和内存的数字和讨论都是指“我的机器”。你的经历可能会有所不同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Summing.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.function.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Summing</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>timeTest</span><span class=o>(</span><span class=n>String</span> <span class=n>id</span><span class=o>,</span> <span class=kt>long</span> <span class=n>checkValue</span><span class=o>,</span>    <span class=n>LongSupplier</span> <span class=n>operation</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>id</span> <span class=o>+</span> <span class=s>&#34;: &#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Timer</span> <span class=n>timer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Timer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>result</span> <span class=o>=</span> <span class=n>operation</span><span class=o>.</span><span class=na>getAsLong</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>result</span> <span class=o>==</span> <span class=n>checkValue</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;ms&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>format</span><span class=o>(</span><span class=s>&#34;result: %d%ncheckValue: %d%n&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>checkValue</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SZ</span> <span class=o>=</span> <span class=mi>100_000_000</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This even works:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// public static final int SZ = 1_000_000_000;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>CHECK</span> <span class=o>=</span> <span class=o>(</span><span class=kt>long</span><span class=o>)</span><span class=n>SZ</span> <span class=o>*</span> <span class=o>((</span><span class=kt>long</span><span class=o>)</span><span class=n>SZ</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)/</span><span class=mi>2</span><span class=o>;</span> <span class=c1>// Gauss&#39;s formula
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>CHECK</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>timeTest</span><span class=o>(</span><span class=s>&#34;Sum Stream&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>LongStream</span><span class=o>.</span><span class=na>rangeClosed</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>SZ</span><span class=o>).</span><span class=na>sum</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>timeTest</span><span class=o>(</span><span class=s>&#34;Sum Stream Parallel&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>LongStream</span><span class=o>.</span><span class=na>rangeClosed</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>SZ</span><span class=o>).</span><span class=na>parallel</span><span class=o>().</span><span class=na>sum</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>timeTest</span><span class=o>(</span><span class=s>&#34;Sum Iterated&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>LongStream</span><span class=o>.</span><span class=na>iterate</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=n>SZ</span><span class=o>+</span><span class=mi>1</span><span class=o>).</span><span class=na>sum</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Slower &amp; runs out of memory above 1_000_000:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// timeTest(&#34;Sum Iterated Parallel&#34;, CHECK, () -&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//   LongStream.iterate(0, i -&gt; i + 1)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//     .parallel()
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//     .limit(SZ+1).sum());
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>5000000050000000
Sum Stream: 167ms
Sum Stream Parallel: 46ms
Sum Iterated: 284ms
</code></pre><p><strong>CHECK</strong> 值是使用 Carl Friedrich Gauss（高斯）在 1700 年代后期还在上小学的时候创建的公式计算出来的.</p><p><strong>main()</strong> 的第一个版本使用直接生成 <strong>Stream</strong> 并调用 <strong>sum()</strong> 的方法。我们看到流的好处在于即使 SZ 为十亿（1_000_000_000）程序也可以很好地处理而没有溢出（为了让程序运行得快一点，我使用了较小的数字）。使用 <strong>parallel()</strong> 的基本范围操作明显更快。</p><p>如果使用 <strong>iterate()</strong> 来生成序列，则减速是相当明显的，可能是因为每次生成数字时都必须调用 lambda。但是如果我们尝试并行化，当 <strong>SZ</strong> 超过一百万时，结果不仅比非并行版本花费的时间更长，而且也会耗尽内存（在某些机器上）。当然，当你可以使用 <strong>range()</strong> 时，你不会使用 <strong>iterate()</strong> ，但如果你生成的东西不是简单的序列，你必须使用 <strong>iterate()</strong> 。应用 <strong>parallel()</strong> 是一个合理的尝试，但会产生令人惊讶的结果。我们将在后面的部分中探讨内存限制的原因，但我们可以对流并行算法进行初步观察：</p><ul><li>流并行性将输入数据分成多个部分，因此算法可以应用于那些单独的部分。</li><li>数组分割成本低，分割均匀且对分割的大小有着完美的掌控。</li><li>链表没有这些属性;“拆分”一个链表仅仅意味着把它分成“第一元素”和“其余元素”，这相对无用。</li><li>无状态生成器的行为类似于数组;上面使用的 <strong>range()</strong> 就是无状态的。</li><li>迭代生成器的行为类似于链表; <strong>iterate()</strong> 是一个迭代生成器。</li></ul><p>现在让我们尝试通过在数组中填充值并对数组求和来解决问题。因为数组只分配了一次，所以我们不太可能遇到垃圾收集时序问题。</p><p>首先我们将尝试一个充满原始 <strong>long</strong> 的数组：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Summing2.java
</span></span></span><span class=line><span class=cl><span class=c1>// {ExcludeFromTravisCI}import java.util.*;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Summing2</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>long</span> <span class=nf>basicSum</span><span class=o>(</span><span class=kt>long</span><span class=o>[]</span> <span class=n>ia</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>ia</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>            <span class=n>sum</span> <span class=o>+=</span> <span class=n>ia</span><span class=o>[</span><span class=n>i</span><span class=o>];</span><span class=k>return</span> <span class=n>sum</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Approximate largest value of SZ before
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// running out of memory on mymachine:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SZ</span> <span class=o>=</span> <span class=mi>20_000_000</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>CHECK</span> <span class=o>=</span> <span class=o>(</span><span class=kt>long</span><span class=o>)</span><span class=n>SZ</span> <span class=o>*</span> <span class=o>((</span><span class=kt>long</span><span class=o>)</span><span class=n>SZ</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)/</span><span class=mi>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>CHECK</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span><span class=o>[]</span> <span class=n>la</span> <span class=o>=</span> <span class=n>newlong</span><span class=o>[</span><span class=n>SZ</span><span class=o>+</span><span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>parallelSetAll</span><span class=o>(</span><span class=n>la</span><span class=o>,</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;Array Stream Sum&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>la</span><span class=o>).</span><span class=na>sum</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;Parallel&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>la</span><span class=o>).</span><span class=na>parallel</span><span class=o>().</span><span class=na>sum</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;Basic Sum&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>basicSum</span><span class=o>(</span><span class=n>la</span><span class=o>));</span><span class=c1>// Destructive summation:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;parallelPrefix&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Arrays</span><span class=o>.</span><span class=na>parallelPrefix</span><span class=o>(</span><span class=n>la</span><span class=o>,</span> <span class=n>Long</span><span class=o>::</span><span class=n>sum</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>la</span><span class=o>[</span><span class=n>la</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>200000010000000
Array Stream
Sum: 104ms
Parallel: 81ms
Basic Sum: 106ms
parallelPrefix: 265ms
</code></pre><p>第一个限制是内存大小；因为数组是预先分配的，所以我们不能创建几乎与以前版本一样大的任何东西。并行化可以加快速度，甚至比使用 <strong>basicSum()</strong> 循环更快。有趣的是， <strong>Arrays.parallelPrefix()</strong> 似乎实际上减慢了速度。但是，这些技术中的任何一种在其他条件下都可能更有用 - 这就是为什么你不能做出任何确定性的声明，除了“你必须尝试一下”。</p><p>最后，考虑使用包装类 <strong>Long</strong> 的效果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Summing3.java
</span></span></span><span class=line><span class=cl><span class=c1>// {ExcludeFromTravisCI}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Summing3</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>long</span> <span class=nf>basicSum</span><span class=o>(</span><span class=n>Long</span><span class=o>[]</span> <span class=n>ia</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>ia</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>            <span class=n>sum</span> <span class=o>+=</span> <span class=n>ia</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>sum</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Approximate largest value of SZ before
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// running out of memory on my machine:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SZ</span> <span class=o>=</span> <span class=mi>10_000_000</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>CHECK</span> <span class=o>=</span> <span class=o>(</span><span class=kt>long</span><span class=o>)</span><span class=n>SZ</span> <span class=o>*</span> <span class=o>((</span><span class=kt>long</span><span class=o>)</span><span class=n>SZ</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)/</span><span class=mi>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>CHECK</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Long</span><span class=o>[]</span> <span class=n>aL</span> <span class=o>=</span> <span class=n>newLong</span><span class=o>[</span><span class=n>SZ</span><span class=o>+</span><span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>parallelSetAll</span><span class=o>(</span><span class=n>aL</span><span class=o>,</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=kt>long</span><span class=o>)</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;Long Array Stream Reduce&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>aL</span><span class=o>).</span><span class=na>reduce</span><span class=o>(</span><span class=mi>0</span><span class=n>L</span><span class=o>,</span> <span class=n>Long</span><span class=o>::</span><span class=n>sum</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;Long Basic Sum&#34;</span><span class=o>,</span> <span class=n>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>basicSum</span><span class=o>(</span><span class=n>aL</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Destructive summation:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;Long parallelPrefix&#34;</span><span class=o>,</span><span class=n>CHECK</span><span class=o>,</span> <span class=o>()-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Arrays</span><span class=o>.</span><span class=na>parallelPrefix</span><span class=o>(</span><span class=n>aL</span><span class=o>,</span> <span class=n>Long</span><span class=o>::</span><span class=n>sum</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>aL</span><span class=o>[</span><span class=n>aL</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>            <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>50000005000000
Long Array
Stream Reduce: 1038ms
Long Basic
Sum: 21ms
Long parallelPrefix: 3616ms
</code></pre><p>现在可用的内存量大约减半，并且所有情况下所需的时间都会很长，除了 <strong>basicSum()</strong> ，它只是循环遍历数组。令人惊讶的是， <strong>Arrays.parallelPrefix()</strong> 比任何其他方法都要花费更长的时间。</p><p>我将 <strong>parallel()</strong> 版本分开了，因为在上面的程序中运行它导致了一个冗长的垃圾收集，扭曲了结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Summing4.java
</span></span></span><span class=line><span class=cl><span class=c1>// {ExcludeFromTravisCI}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Summing4</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Summing3</span><span class=o>.</span><span class=na>CHECK</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Long</span><span class=o>[]</span> <span class=n>aL</span> <span class=o>=</span> <span class=n>newLong</span><span class=o>[</span><span class=n>Summing3</span><span class=o>.</span><span class=na>SZ</span><span class=o>+</span><span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>parallelSetAll</span><span class=o>(</span><span class=n>aL</span><span class=o>,</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=kt>long</span><span class=o>)</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Summing</span><span class=o>.</span><span class=na>timeTest</span><span class=o>(</span><span class=s>&#34;Long Parallel&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>        <span class=n>Summing3</span><span class=o>.</span><span class=na>CHECK</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>aL</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>parallel</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>reduce</span><span class=o>(</span><span class=mi>0</span><span class=n>L</span><span class=o>,</span><span class=n>Long</span><span class=o>::</span><span class=n>sum</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>50000005000000
Long Parallel: 1014ms
</code></pre><p>它比非 parallel() 版本略快，但并不显着。</p><p>导致时间增加的一个重要原因是处理器内存缓存。使用 <strong>Summing2.java</strong> 中的原始 <strong>long</strong> ，数组 <strong>la</strong> 是连续的内存。处理器可以更容易地预测该阵列的使用，并使缓存充满下一个需要的阵列元素。访问缓存比访问主内存快得多。似乎 <strong>Long parallelPrefix</strong> 计算受到影响，因为它为每个计算读取两个数组元素，并将结果写回到数组中，并且每个都为 <strong>Long</strong> 生成一个超出缓存的引用。</p><p>使用 <strong>Summing3.java</strong> 和 <strong>Summing4.java</strong> ，<strong>aL</strong> 是一个 <strong>Long</strong> 数组，它不是一个连续的数据数组，而是一个连续的 <strong>Long</strong> 对象引用数组。尽管该数组可能会在缓存中出现，但指向的对象几乎总是不在缓存中。</p><p>这些示例使用不同的 SZ 值来显示内存限制。</p><p>为了进行时间比较，以下是 SZ 设置为最小值 1000 万的结果：</p><p><strong>Sum Stream: 69msSum
Stream Parallel: 18msSum
Iterated: 277ms
Array Stream Sum: 57ms
Parallel: 14ms
Basic Sum: 16ms
parallelPrefix: 28ms
Long Array Stream Reduce: 1046ms
Long Basic Sum: 21ms
Long parallelPrefix: 3287ms
Long Parallel: 1008ms</strong></p><p>虽然 Java 8 的各种内置“并行”工具非常棒，但我认为它们被视为神奇的灵丹妙药：“只需添加 parallel() 并且它会更快！” 我希望我已经开始表明情况并非所有都是如此，并且盲目地应用内置的“并行”操作有时甚至会使运行速度明显变慢。</p><ul><li>parallel()/limit() 交点</li></ul><p>使用 <strong>parallel()</strong> 时会有更复杂的问题。从其他语言中吸取的流机制被设计为大约是一个无限的流模型。如果你拥有有限数量的元素，则可以使用集合以及为有限大小的集合设计的关联算法。如果你使用无限流，则使用针对流优化的算法。</p><p>Java 8 将两者合并起来。例如，<strong>Collections</strong> 没有内置的 <strong>map()</strong> 操作。在 <strong>Collection</strong> 和 <strong>Map</strong> 中唯一类似流的批处理操作是 <strong>forEach()</strong> 。如果要执行 <strong>map()</strong> 和 <strong>reduce()</strong> 等操作，必须首先将 <strong>Collection</strong> 转换为存在这些操作的 <strong>Stream</strong> :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CollectionIntoStream.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>onjava.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CollectionIntoStream</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>strings</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>generate</span><span class=o>(</span><span class=k>new</span> <span class=n>Rand</span><span class=o>.</span><span class=na>String</span><span class=o>(</span><span class=mi>5</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=n>strings</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Convert to a Stream for many more options:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>String</span> <span class=n>result</span> <span class=o>=</span> <span class=n>strings</span><span class=o>.</span><span class=na>stream</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>String</span><span class=o>::</span><span class=n>toUpperCase</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>s</span><span class=o>.</span><span class=na>substring</span><span class=o>(</span><span class=mi>2</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>reduce</span><span class=o>(</span><span class=s>&#34;:&#34;</span><span class=o>,</span> <span class=o>(</span><span class=n>s1</span><span class=o>,</span> <span class=n>s2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>s1</span> <span class=o>+</span> <span class=n>s2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>result</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>btpen
pccux
szgvg
meinn
eeloz
tdvew
cippc
ygpoa
lkljl
bynxt
:PENCUXGVGINNLOZVEWPPCPOALJLNXT
</code></pre><p><strong>Collection</strong> 确实有一些批处理操作，如 <strong>removeAll()</strong> ，<strong>removeIf()</strong> 和 <strong>retainAll()</strong> ，但这些都是破坏性的操作。<strong>ConcurrentHashMap</strong> 对 <strong>forEach</strong> 和 <strong>reduce</strong> 操作有特别广泛的支持。</p><p>在许多情况下，只在集合上调用 <strong>stream()</strong> 或者 <strong>parallelStream()</strong> 没有问题。但是，有时将 <strong>Stream</strong> 与 <strong>Collection</strong> 混合会产生意想不到的结果。这是一个有趣的难题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/ParallelStreamPuzzle.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.function.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ParallelStreamPuzzle</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>IntGenerator</span>
</span></span><span class=line><span class=cl>    <span class=kd>implements</span> <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kt>int</span> <span class=n>current</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>get</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>current</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>generate</span><span class=o>(</span><span class=k>new</span> <span class=n>IntGenerator</span><span class=o>())</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>parallel</span><span class=o>()</span>  <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* Output:
</span></span></span><span class=line><span class=cl><span class=cm>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>如果[1] 注释运行它，它会产生预期的：
<strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</strong>
每次。但是包含了 parallel()，它看起来像一个随机数生成器，带有输出（从一次运行到下一次运行不同），如：
<strong>[0, 3, 6, 8, 11, 14, 17, 20, 23, 26]</strong>
这样一个简单的程序怎么会如此糟糕呢？让我们考虑一下我们在这里要实现的目标：“并行生成。”那意味着什么？一堆线程都在从一个生成器取值，然后以某种方式选择有限的结果集？代码看起来很简单，但它变成了一个特别棘手的问题。</p><p>为了看到它，我们将添加一些仪器。由于我们正在处理线程，因此我们必须将任何跟踪信息捕获到并发数据结构中。在这里我使用 <strong>ConcurrentLinkedDeque</strong> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/ParallelStreamPuzzle2.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.function.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.nio.file.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ParallelStreamPuzzle2</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>TRACE</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>ConcurrentLinkedDeque</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span>
</span></span><span class=line><span class=cl>    <span class=nc>IntGenerator</span> <span class=kd>implements</span> <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=n>AtomicInteger</span> <span class=n>current</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>AtomicInteger</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>get</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>TRACE</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>current</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;: &#34;</span> <span class=o>+</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>current</span><span class=o>.</span><span class=na>getAndIncrement</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>Stream</span><span class=o>.</span><span class=na>generate</span><span class=o>(</span><span class=n>newIntGenerator</span><span class=o>())</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>parallel</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Files</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=n>Paths</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=s>&#34;PSP2.txt&#34;</span><span class=o>),</span> <span class=n>TRACE</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p>current 是使用线程安全的 <strong>AtomicInteger</strong> 类定义的，可以防止竞争条件；<strong>parallel()</strong> 允许多个线程调用 <strong>get()</strong> 。</p><p>在查看 <strong>PSP2.txt</strong> .<strong>IntGenerator.get()</strong> 被调用 1024 次时，你可能会感到惊讶。</p><pre tabindex=0><code>0: main
1: ForkJoinPool.commonPool-worker-1
2: ForkJoinPool.commonPool-worker-2
3: ForkJoinPool.commonPool-worker-2
4: ForkJoinPool.commonPool-worker-1
5: ForkJoinPool.commonPool-worker-1
6: ForkJoinPool.commonPool-worker-1
7: ForkJoinPool.commonPool-worker-1
8: ForkJoinPool.commonPool-worker-4
9: ForkJoinPool.commonPool-worker-4
10: ForkJoinPool.commonPool-worker-4
11: main
12: main
13: main
14: main
15: main...10
17: ForkJoinPool.commonPool-worker-110
18: ForkJoinPool.commonPool-worker-610
19: ForkJoinPool.commonPool-worker-610
20: ForkJoinPool.commonPool-worker-110
21: ForkJoinPool.commonPool-worker-110
22: ForkJoinPool.commonPool-worker-110
23: ForkJoinPool.commonPool-worker-1
</code></pre><p>这个块大小似乎是内部实现的一部分（尝试使用<code>limit()</code> 的不同参数来查看不同的块大小）。将<code>parallel()</code>与<code>limit()</code>结合使用可以预取一串值，作为流输出。</p><p>试着想象一下这里发生了什么：一个流抽象出无限序列，按需生成。当你要求它并行产生流时，你要求所有这些线程尽可能地调用<code>get()</code>。添加<code>limit()</code>，你说“只需要这些。”基本上，当你为了随机输出而选择将<code>parallel()</code>与<code>limit()</code>结合使用时，这种方法可能对你正在解决的问题有效。但是当你这样做时，你必须明白。这是一个仅限专家的功能，而不是要争辩说“Java 弄错了”。</p><p>什么是更合理的方法来解决问题？好吧，如果你想生成一个 int 流，你可以使用 IntStream.range()，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/ParallelStreamPuzzle3.java
</span></span></span><span class=line><span class=cl><span class=c1>// {VisuallyInspectOutput}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ParallelStreamPuzzle3</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>30</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>peek</span><span class=o>(</span><span class=n>e</span> <span class=o>-&gt;</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span> <span class=o>+</span> <span class=s>&#34;: &#34;</span> <span class=o>+</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>getName</span><span class=o>()))</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>parallel</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>boxed</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>8: main
6: ForkJoinPool.commonPool-worker-5
3: ForkJoinPool.commonPool-worker-7
5: ForkJoinPool.commonPool-worker-5
1: ForkJoinPool.commonPool-worker-3
2: ForkJoinPool.commonPool-worker-6
4: ForkJoinPool.commonPool-worker-1
0: ForkJoinPool.commonPool-worker-4
7: ForkJoinPool.commonPool-worker-1
9: ForkJoinPool.commonPool-worker-2
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p>为了表明 <strong>parallel()</strong> 确实有效，我添加了一个对 <strong>peek()</strong> 的调用，这是一个主要用于调试的流函数：它从流中提取一个值并执行某些操作但不影响从流向下传递的元素。注意这会干扰线程行为，但我只是尝试在这里做一些事情，而不是实际调试任何东西。</p><p>你还可以看到 <strong>boxed()</strong> 的添加，它接受 <strong>int</strong> 流并将其转换为 <strong>Integer</strong> 流。</p><p>现在我们得到多个线程产生不同的值，但它只产生 10 个请求的值，而不是 1024 个产生 10 个值。</p><p>它更快吗？一个更好的问题是：什么时候开始有意义？当然不是这么小的一套；上下文切换的代价远远超过并行性的任何加速。很难想象什么时候用并行生成一个简单的数字序列会有意义。如果你要生成的东西需要很高的成本，它可能有意义 - 但这都是猜测。只有通过测试我们才能知道用并行是否有效。记住这句格言：“首先使它工作，然后使它更快地工作 - 只有当你必须这样做时。”将 <strong>parallel()</strong> 和 <strong>limit()</strong> 结合使用仅供专家操作（把话说在前面，我不认为自己是这里的专家）。</p><ul><li>并行流只看起来很容易</li></ul><p>实际上，在许多情况下，并行流确实可以毫不费力地更快地产生结果。但正如你所见，仅仅将 <strong>parallel()</strong> 加到你的 Stream 操作上并不一定是安全的事情。在使用 <strong>parallel()</strong> 之前，你必须了解并行性如何帮助或损害你的操作。一个基本认知错误就是认为使用并行性总是一个好主意。事实上并不是。Stream 意味着你不需要重写所有代码便可以并行运行它。但是流的出现并不意味着你可以不用理解并行的原理以及不用考虑并行是否真的有助于实现你的目标。</p><h2 id=创建和运行任务>创建和运行任务</h2><p>如果无法通过并行流实现并发，则必须创建并运行自己的任务。稍后你将看到运行任务的理想 Java 8 方法是 CompletableFuture，但我们将使用更基本的工具介绍概念。</p><p>Java 并发的历史始于非常原始和有问题的机制，并且充满了各种尝试的改进。这些主要归入附录：<a href=./Appendix-Low-Level-Concurrency.md>低级并发 (Appendix: Low-Level Concurrency)</a>。在这里，我们将展示一个规范形式，表示创建和运行任务的最简单，最好的方法。与并发中的所有内容一样，存在各种变体，但这些变体要么降级到该附录，要么超出本书的范围。</p><ul><li>Tasks and Executors</li></ul><p>在 Java 的早期版本中，你通过直接创建自己的 Thread 对象来使用线程，甚至将它们子类化以创建你自己的特定“任务线程”对象。你手动调用了构造函数并自己启动了线程。</p><p>创建所有这些线程的开销变得非常重要，现在不鼓励采用手动操作方法。在 Java 5 中，添加了类来为你处理线程池。你可以将任务创建为单独的类型，然后将其交给 ExecutorService 以运行该任务，而不是为每种不同类型的任务创建新的 Thread 子类型。ExecutorService 为你管理线程，并且在运行任务后重新循环线程而不是丢弃线程。</p><p>首先，我们将创建一个几乎不执行任务的任务。它“sleep”（暂停执行）100 毫秒，显示其标识符和正在执行任务的线程的名称，然后完成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/NapTask.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>NapTask</span> <span class=kd>implements</span> <span class=n>Runnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>NapTask</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span><span class=c1>// Seconds
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=k>this</span> <span class=o>+</span> <span class=s>&#34; &#34;</span><span class=o>+</span>
</span></span><span class=line><span class=cl>            <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=s>&#34;NapTask[&#34;</span> <span class=o>+</span> <span class=n>id</span> <span class=o>+</span> <span class=s>&#34;]&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>这只是一个 <strong>Runnable</strong> ：一个包含 <strong>run()</strong> 方法的类。它没有包含实际运行任务的机制。我们使用 <strong>Nap</strong> 类中的“sleep”：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// onjava/Nap.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nn>onjava</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Nap</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Nap</span><span class=o>(</span><span class=kt>double</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// Seconds
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>TimeUnit</span><span class=o>.</span><span class=na>MILLISECONDS</span><span class=o>.</span><span class=na>sleep</span><span class=o>((</span><span class=kt>int</span><span class=o>)(</span><span class=mi>1000</span> <span class=o>*</span> <span class=n>t</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>catch</span><span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Nap</span><span class=o>(</span><span class=kt>double</span> <span class=n>t</span><span class=o>,</span> <span class=n>String</span> <span class=n>msg</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>msg</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>为了消除异常处理的视觉干扰，这被定义为实用程序。第二个构造函数在超时时显示一条消息</p><p>对 <strong>TimeUnit.MILLISECONDS.sleep()</strong> 的调用获取“当前线程”并在参数中将其置于休眠状态，这意味着该线程被挂起。这并不意味着底层处理器停止。操作系统将其切换到其他任务，例如在你的计算机上运行另一个窗口。OS 任务管理器定期检查 <strong>sleep()</strong> 是否超时。当它执行时，线程被“唤醒”并给予更多处理时间。</p><p>你可以看到 <strong>sleep()</strong> 抛出一个受检的 <strong>InterruptedException</strong> ;这是原始 Java 设计中的一个工件，它通过突然断开它们来终止任务。因为它往往会产生不稳定的状态，所以后来不鼓励终止。但是，我们必须在需要或仍然发生终止的情况下捕获异常。</p><p>要执行任务，我们将从最简单的方法&ndash;SingleThreadExecutor 开始:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//concurrent/SingleThreadExecutor.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SingleThreadExecutor</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ExecutorService</span> <span class=n>exec</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>Executors</span><span class=o>.</span><span class=na>newSingleThreadExecutor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>NapTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>exec</span><span class=o>::</span><span class=n>execute</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;All tasks submitted&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=o>(!</span><span class=n>exec</span><span class=o>.</span><span class=na>isTerminated</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span>
</span></span><span class=line><span class=cl>            <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()+</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34; awaiting termination&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>All tasks submitted
main awaiting termination
main awaiting termination
NapTask[0] pool-1-thread-1
main awaiting termination
NapTask[1] pool-1-thread-1
main awaiting termination
NapTask[2] pool-1-thread-1
main awaiting termination
NapTask[3] pool-1-thread-1
main awaiting termination
NapTask[4] pool-1-thread-1
main awaiting termination
NapTask[5] pool-1-thread-1
main awaiting termination
NapTask[6] pool-1-thread-1
main awaiting termination
NapTask[7] pool-1-thread-1
main awaiting termination
NapTask[8] pool-1-thread-1
main awaiting termination
NapTask[9] pool-1-thread-1
</code></pre><p>首先请注意，没有 <strong>SingleThreadExecutor</strong> 类。<strong>newSingleThreadExecutor()</strong> 是 <strong>Executors</strong> 中的一个工厂方法，它创建特定类型的 <strong>ExecutorService</strong> <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><p>我创建了十个 NapTasks 并将它们提交给 ExecutorService，这意味着它们开始自己运行。然而，在此期间，main() 继续做事。当我运行 callexec.shutdown() 时，它告诉 ExecutorService 完成已经提交的任务，但不接受任何新任务。此时，这些任务仍然在运行，因此我们必须等到它们在退出 main() 之前完成。这是通过检查 exec.isTerminated() 来实现的，这在所有任务完成后变为 true。</p><p>请注意，main() 中线程的名称是 main，并且只有一个其他线程 pool-1-thread-1。此外，交错输出显示两个线程确实同时运行。</p><p>如果你只是调用 exec.shutdown()，程序将完成所有任务。也就是说，不需要 <strong>while(!exec.isTerminated())</strong> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/SingleThreadExecutor2.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SingleThreadExecutor2</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span><span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ExecutorService</span> <span class=n>exec</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span><span class=n>Executors</span><span class=o>.</span><span class=na>newSingleThreadExecutor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>NapTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>exec</span><span class=o>::</span><span class=n>execute</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>NapTask[0] pool-1-thread-1
NapTask[1] pool-1-thread-1
NapTask[2] pool-1-thread-1
NapTask[3] pool-1-thread-1
NapTask[4] pool-1-thread-1
NapTask[5] pool-1-thread-1
NapTask[6] pool-1-thread-1
NapTask[7] pool-1-thread-1
NapTask[8] pool-1-thread-1
NapTask[9] pool-1-thread-1
</code></pre><p>一旦你调用了 exec.shutdown()，尝试提交新任务将抛出 RejectedExecutionException。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/MoreTasksAfterShutdown.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MoreTasksAfterShutdown</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ExecutorService</span> <span class=n>exec</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span><span class=n>Executors</span><span class=o>.</span><span class=na>newSingleThreadExecutor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=n>newNapTask</span><span class=o>(</span><span class=mi>1</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>exec</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=n>newNapTask</span><span class=o>(</span><span class=mi>99</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>catch</span><span class=o>(</span><span class=n>RejectedExecutionException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>java.util.concurrent.RejectedExecutionException: TaskNapTask[99] rejected from java.util.concurrent.ThreadPoolExecutor@4e25154f[Shutting down, pool size = 1,active threads = 1, queued tasks = 0, completed tasks =0]NapTask[1] pool-1-thread-1
</code></pre><p><strong>exec.shutdown()</strong> 的替代方法是 <strong>exec.shutdownNow()</strong> ，它除了不接受新任务外，还会尝试通过中断任务来停止任何当前正在运行的任务。同样，中断是错误的，容易出错并且不鼓励。</p><ul><li>使用更多线程</li></ul><p>使用线程的重点是（几乎总是）更快地完成任务，那么我们为什么要限制自己使用 SingleThreadExecutor 呢？查看执行 <strong>Executors</strong> 的 Javadoc，你将看到更多选项。例如 CachedThreadPool：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CachedThreadPool.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CachedThreadPool</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ExecutorService</span> <span class=n>exec</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span><span class=n>Executors</span><span class=o>.</span><span class=na>newCachedThreadPool</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>NapTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>exec</span><span class=o>::</span><span class=n>execute</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>NapTask[7] pool-1-thread-8
NapTask[4] pool-1-thread-5
NapTask[1] pool-1-thread-2
NapTask[3] pool-1-thread-4
NapTask[0] pool-1-thread-1
NapTask[8] pool-1-thread-9
NapTask[2] pool-1-thread-3
NapTask[9] pool-1-thread-10
NapTask[6] pool-1-thread-7
NapTask[5] pool-1-thread-6
</code></pre><p>当你运行这个程序时，你会发现它完成得更快。这是有道理的，每个任务都有自己的线程，所以它们都并行运行，而不是使用相同的线程来顺序运行每个任务。这似乎没毛病，很难理解为什么有人会使用 SingleThreadExecutor。</p><p>要理解这个问题，我们需要一个更复杂的任务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/InterferingTask.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>InterferingTask</span> <span class=kd>implements</span> <span class=n>Runnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Integer</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>InterferingTask</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>id</span> <span class=o>+</span> <span class=s>&#34; &#34;</span><span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>每个任务增加 val 一百次。这似乎很简单。让我们用 CachedThreadPool 尝试一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CachedThreadPool2.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CachedThreadPool2</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ExecutorService</span> <span class=n>exec</span>
</span></span><span class=line><span class=cl>    <span class=o>=</span><span class=n>Executors</span><span class=o>.</span><span class=na>newCachedThreadPool</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>InterferingTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>exec</span><span class=o>::</span><span class=n>execute</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>0 pool-1-thread-1 200
1 pool-1-thread-2 200
4 pool-1-thread-5 300
5 pool-1-thread-6 400
8 pool-1-thread-9 500
9 pool-1-thread-10 600
2 pool-1-thread-3 700
7 pool-1-thread-8 800
3 pool-1-thread-4 900
6 pool-1-thread-7 1000
</code></pre><p>输出不是我们所期望的，并且从一次运行到下一次运行会有所不同。问题是所有的任务都试图写入 val 的单个实例，并且他们正在踩着彼此的脚趾。我们称这样的类是线程不安全的。让我们看看 SingleThreadExecutor 会发生什么：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/SingleThreadExecutor3.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SingleThreadExecutor3</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span><span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ExecutorService</span> <span class=n>exec</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span><span class=n>Executors</span><span class=o>.</span><span class=na>newSingleThreadExecutor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>InterferingTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>exec</span><span class=o>::</span><span class=n>execute</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>0 pool-1-thread-1 100
1 pool-1-thread-1 200
2 pool-1-thread-1 300
3 pool-1-thread-1 400
4 pool-1-thread-1 500
5 pool-1-thread-1 600
6 pool-1-thread-1 700
7 pool-1-thread-1 800
8 pool-1-thread-1 900
9 pool-1-thread-1 1000
</code></pre><p>现在我们每次都得到一致的结果，尽管 <strong>InterferingTask</strong> 缺乏线程安全性。这是 SingleThreadExecutor 的主要好处 - 因为它一次运行一个任务，这些任务不会相互干扰，因此强加了线程安全性。这种现象称为线程封闭，因为在单线程上运行任务限制了它们的影响。线程封闭限制了加速，但可以节省很多困难的调试和重写。</p><ul><li>产生结果</li></ul><p>因为 <strong>InterferingTask</strong> 是一个 <strong>Runnable</strong> ，它没有返回值，因此只能使用副作用产生结果 - 操纵缓冲值而不是返回结果。副作用是并发编程中的主要问题之一，因为我们看到了 <strong>CachedThreadPool2.java</strong> 。<strong>InterferingTask</strong> 中的 <strong>val</strong> 被称为可变共享状态，这就是问题所在：多个任务同时修改同一个变量会产生竞争。结果取决于首先在终点线上执行哪个任务，并修改变量（以及其他可能性的各种变化）。</p><p>避免竞争条件的最好方法是避免可变的共享状态。我们可以称之为自私的孩子原则：什么都不分享。</p><p>使用 <strong>InterferingTask</strong> ，最好删除副作用并返回任务结果。为此，我们创建 <strong>Callable</strong> 而不是 <strong>Runnable</strong> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CountingTask.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CountingTask</span> <span class=kd>implements</span> <span class=n>Callable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>CountingTask</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>)</span> <span class=o>{</span> <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>call</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Integer</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>id</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>val</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>call() 完全独立于所有其他 CountingTasks 生成其结果</strong>，这意味着没有可变的共享状态</p><p><strong>ExecutorService</strong> 允许你使用 <strong>invokeAll()</strong> 启动集合中的每个 Callable：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CachedThreadPool3.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CachedThreadPool3</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Integer</span> <span class=nf>extractResult</span><span class=o>(</span><span class=n>Future</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>f</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>f</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>catch</span><span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span><span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ExecutorService</span> <span class=n>exec</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>Executors</span><span class=o>.</span><span class=na>newCachedThreadPool</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>CountingTask</span><span class=o>&gt;</span> <span class=n>tasks</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>CountingTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Future</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>futures</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>exec</span><span class=o>.</span><span class=na>invokeAll</span><span class=o>(</span><span class=n>tasks</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Integer</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>futures</span><span class=o>.</span><span class=na>stream</span><span class=o>()</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>CachedThreadPool3</span><span class=o>::</span><span class=n>extractResult</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>reduce</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>Integer</span><span class=o>::</span><span class=n>sum</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;sum = &#34;</span> <span class=o>+</span> <span class=n>sum</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>1 pool-1-thread-2 100
0 pool-1-thread-1 100
4 pool-1-thread-5 100
5 pool-1-thread-6 100
8 pool-1-thread-9 100
9 pool-1-thread-10 100
2 pool-1-thread-3 100
3 pool-1-thread-4 100
6 pool-1-thread-7 100
7 pool-1-thread-8 100
sum = 1000
</code></pre><p>只有在所有任务完成后，<strong>invokeAll()</strong> 才会返回一个 <strong>Future</strong> 列表，每个任务一个 <strong>Future</strong> 。<strong>Future</strong> 是 Java 5 中引入的机制，允许你提交任务而无需等待它完成。在这里，我们使用 <strong>ExecutorService.submit()</strong> :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Futures.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Futures</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span><span class=kd>throws</span> <span class=n>InterruptedException</span><span class=o>,</span> <span class=n>ExecutionException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ExecutorService</span> <span class=n>exec</span>
</span></span><span class=line><span class=cl>        <span class=o>=</span><span class=n>Executors</span><span class=o>.</span><span class=na>newSingleThreadExecutor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Future</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=o>.</span><span class=na>submit</span><span class=o>(</span><span class=n>newCountingTask</span><span class=o>(</span><span class=mi>99</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>f</span><span class=o>.</span><span class=na>get</span><span class=o>());</span> <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>99 pool-1-thread-1 100
100
</code></pre><ul><li>[1] 当你的任务在尚未完成的 <strong>Future</strong> 上调用 <strong>get()</strong> 时，调用会阻塞（等待）直到结果可用。</li></ul><p>但这意味着，在 <strong>CachedThreadPool3.java</strong> 中，<strong>Future</strong> 似乎是多余的，因为 <strong>invokeAll()</strong> 甚至在所有任务完成之前都不会返回。但是，这里的 Future 并不用于延迟结果，而是用于捕获任何可能发生的异常。</p><p>还要注意在 <strong>CachedThreadPool3.java.get()</strong> 中抛出异常，因此 <strong>extractResult()</strong> 在 Stream 中执行此提取。</p><p>因为当你调用 <strong>get()</strong> 时，<strong>Future</strong> 会阻塞，所以它只能解决等待任务完成才暴露问题。最终，<strong>Futures</strong> 被认为是一种无效的解决方案，现在不鼓励，我们推荐 Java 8 的 <strong>CompletableFuture</strong> ，这将在本章后面探讨。当然，你仍会在遗留库中遇到 Futures。</p><p>我们可以使用并行 Stream 以更简单，更优雅的方式解决这个问题:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CountingStream.java
</span></span></span><span class=line><span class=cl><span class=c1>// {VisuallyInspectOutput}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CountingStream</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span>
</span></span><span class=line><span class=cl>            <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>10</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>parallel</span><span class=o>()</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>CountingTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>ct</span> <span class=o>-&gt;</span> <span class=n>ct</span><span class=o>.</span><span class=na>call</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>reduce</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>Integer</span><span class=o>::</span><span class=n>sum</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>1 ForkJoinPool.commonPool-worker-3 100
8 ForkJoinPool.commonPool-worker-2 100
0 ForkJoinPool.commonPool-worker-6 100
2 ForkJoinPool.commonPool-worker-1 100
4 ForkJoinPool.commonPool-worker-5 100
9 ForkJoinPool.commonPool-worker-7 100
6 main 100
7 ForkJoinPool.commonPool-worker-4 100
5 ForkJoinPool.commonPool-worker-2 100
3 ForkJoinPool.commonPool-worker-3 100
1000
</code></pre><p>这不仅更容易理解，而且我们需要做的就是将 <code>parallel()</code> 插入到其他顺序操作中，然后一切都在同时运行。</p><ul><li>Lambda 和方法引用作为任务</li></ul><p>在 <strong>java8</strong> 有了 <strong>lambdas</strong> 和方法引用，你不需要受限于只能使用 <strong>Runnable</strong> 和 <strong>Callable</strong> 。因为 java8 的 <strong>lambdas</strong> 和方法引用可以通过匹配方法签名来使用（即，它支持结构一致性），所以我们可以将非 <strong>Runnable</strong> 或 <strong>Callable</strong> 的参数传递给 <code>ExecutorService</code> :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/LambdasAndMethodReferences.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>NotRunnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>go</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;NotRunnable&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>NotCallable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>get</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;NotCallable&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>LambdasAndMethodReferences</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span><span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ExecutorService</span> <span class=n>exec</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>Executors</span><span class=o>.</span><span class=na>newCachedThreadPool</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>submit</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Lambda1&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>submit</span><span class=o>(</span><span class=k>new</span> <span class=n>NotRunnable</span><span class=o>()::</span><span class=n>go</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>submit</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Lambda2&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>submit</span><span class=o>(</span><span class=k>new</span> <span class=n>NotCallable</span><span class=o>()::</span><span class=n>get</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>Lambda1
NotCallable
NotRunnable
Lambda2
</code></pre><p>这里，前两个 <strong>submit()</strong> 调用可以改为调用 <strong>execute()</strong> 。所有 <strong>submit()</strong> 调用都返回 <strong>Futures</strong> ，你可以在后两次调用的情况下提取结果。</p><h2 id=终止耗时任务>终止耗时任务</h2><p>并发程序通常使用长时间运行的任务。可调用任务在完成时返回值;虽然这给它一个有限的寿命，但仍然可能很长。可运行的任务有时被设置为永远运行的后台进程。你经常需要一种方法在正常完成之前停止 <strong>Runnable</strong> 和 <strong>Callable</strong> 任务，例如当你关闭程序时。</p><p>最初的 Java 设计提供了中断运行任务的机制（为了向后兼容，仍然存在）;中断机制包括阻塞问题。中断任务既乱又复杂，因为你必须了解可能发生中断的所有可能状态，以及可能导致的数据丢失。使用中断被视为反对模式，但我们仍然被迫接受。</p><p>InterruptedException，因为设计的向后兼容性残留。</p><p>任务终止的最佳方法是设置任务周期性检查的标志。然后任务可以通过自己的 shutdown 进程并正常终止。不是在任务中随机关闭线程，而是要求任务在到达了一个较好时自行终止。这总是产生比中断更好的结果，以及更容易理解的更合理的代码。</p><p>以这种方式终止任务听起来很简单：设置任务可以看到的 <strong>boolean</strong> flag。编写任务，以便定期检查标志并执行正常终止。这实际上就是你所做的，但是有一个复杂的问题：我们的旧克星，共同的可变状态。如果该标志可以被另一个任务操纵，则存在碰撞可能性。</p><p>在研究 Java 文献时，你会发现很多解决这个问题的方法，经常使用 <strong>volatile</strong> 关键字。我们将使用更简单的技术并避免所有易变的参数，这些都在<a href=./Appendix-Low-Level-Concurrency.md>附录：低级并发</a> 中有所涉及。</p><p>Java 5 引入了 <strong>Atomic</strong> 类，它提供了一组可以使用的类型，而不必担心并发问题。我们将添加 <strong>AtomicBoolean</strong> 标志，告诉任务清理自己并退出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/QuittableTask.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.AtomicBoolean</span><span class=o>;</span><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>QuittableTask</span> <span class=kd>implements</span> <span class=n>Runnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>QuittableTask</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>AtomicBoolean</span> <span class=n>running</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>AtomicBoolean</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>quit</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>running</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=kc>false</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=o>(</span><span class=n>running</span><span class=o>.</span><span class=na>get</span><span class=o>())</span>         <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>id</span> <span class=o>+</span> <span class=s>&#34; &#34;</span><span class=o>);</span>  <span class=c1>// [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>虽然多个任务可以在同一个实例上成功调用 <strong>quit()</strong> ，但是 <strong>AtomicBoolean</strong> 可以防止多个任务同时实际修改 <strong>running</strong> ，从而使 <strong>quit()</strong> 方法成为线程安全的。</p><ul><li>[1]:只要运行标志为 true，此任务的 run() 方法将继续。</li><li></li></ul><p>需要 <strong>running AtomicBoolean</strong> 证明编写 Java program 并发时最基本的困难之一是，如果 <strong>running</strong> 是一个普通的布尔值，你可能无法在执行程序中看到问题。实际上，在这个例子中，你可能永远不会有任何问题 - 但是代码仍然是不安全的。编写表明该问题的测试可能很困难或不可能。因此，你没有任何反馈来告诉你已经做错了。通常，你编写线程安全代码的唯一方法就是通过了解事情可能出错的所有细微之处。</p><p>作为测试，我们将启动很多 QuittableTasks 然后关闭它们。尝试使用较大的 COUNT 值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/QuittingTasks.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>QuittingTasks</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>COUNT</span> <span class=o>=</span> <span class=mi>150</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ExecutorService</span> <span class=n>es</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>Executors</span><span class=o>.</span><span class=na>newCachedThreadPool</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>QuittableTask</span><span class=o>&gt;</span> <span class=n>tasks</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=n>COUNT</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>QuittableTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>peek</span><span class=o>(</span><span class=n>qt</span> <span class=o>-&gt;</span> <span class=n>es</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=n>qt</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>tasks</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>QuittableTask</span><span class=o>::</span><span class=n>quit</span><span class=o>);</span>    <span class=n>es</span><span class=o>.</span><span class=na>shutdown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>24 27 31 8 11 7 19 12 16 4 23 3 28 32 15 20 63 60 68 6764 39 47 52 51 55 40 43 48 59 44 56 36 35 71 72 83 10396 92 88 99 100 87 91 79 75 84 76 115 108 112 104 107111 95 80 147 120 127 119 123 144 143 116 132 124 128
136 131 135 139 148 140 2 126 6 5 1 18 129 17 14 13 2122 9 10 30 33 58 37 125 26 34 133 145 78 137 141 138 6274 142 86 65 73 146 70 42 149 121 110 134 105 82 117106 113 122 45 114 118 38 50 29 90 101 89 57 53 94 4161 66 130 69 77 81 85 93 25 102 54 109 98 49 46 97
</code></pre><p>我使用 <strong>peek()</strong> 将 <strong>QuittableTasks</strong> 传递给 <strong>ExecutorService</strong> ，然后将这些任务收集到 <strong>List.main()</strong> 中，只要任何任务仍在运行，就会阻止程序退出。即使为每个任务按顺序调用 quit() 方法，任务也不会按照它们创建的顺序关闭。独立运行的任务不会确定性地响应信号。</p><h2 id=completablefuture-类>CompletableFuture 类</h2><p>作为介绍，这里是使用 CompletableFutures 在 QuittingTasks.java 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/QuittingCompletable.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>QuittingCompletable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>QuittableTask</span><span class=o>&gt;</span> <span class=n>tasks</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>1</span><span class=o>,</span> <span class=n>QuittingTasks</span><span class=o>.</span><span class=na>COUNT</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>QuittableTask</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Void</span><span class=o>&gt;&gt;</span> <span class=n>cfutures</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>tasks</span><span class=o>.</span><span class=na>stream</span><span class=o>()</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>::</span><span class=n>runAsync</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>tasks</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>QuittableTask</span><span class=o>::</span><span class=n>quit</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cfutures</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>::</span><span class=n>join</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 2526 27 28 29 30 31 32 33 34 6 35 4 38 39 40 41 42 43 4445 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 6263 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 8081 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 9899 100 101 102 103 104 105 106 107 108 109 110 111 1121 113 114 116 117 118 119 120 121 122 123 124 125 126127 128 129 130 131 132 133 134 135 136 137 138 139 140141 142 143 144 145 146 147 148 149 5 115 37 36 2 3
</code></pre><p>任务是一个 <code>List&lt;QuittableTask></code>，就像在 <code>QuittingTasks.java</code> 中一样，但是在这个例子中，没有 <code>peek()</code> 将每个 <code>QuittableTask</code> 提交给 <code>ExecutorService</code>。相反，在创建 <code>cfutures</code> 期间，每个任务都交给 <code>CompletableFuture::runAsync</code>。这执行 <code>VerifyTask.run()</code> 并返回 <code>CompletableFuture&lt;Void></code> 。因为 <code>run()</code> 不返回任何内容，所以在这种情况下我只使用 <code>CompletableFuture</code> 调用 <code>join()</code> 来等待它完成。</p><p>在本例中需要注意的重要一点是，运行任务不需要使用 <code>ExecutorService</code>。而是直接交给 <code>CompletableFuture</code> 管理 (不过你可以向它提供自己定义的 <code>ExectorService</code>)。您也不需要调用 <code>shutdown()</code>;事实上，除非你像我在这里所做的那样显式地调用 <code>join()</code>，否则程序将尽快退出，而不必等待任务完成。</p><p>这个例子只是一个起点。你很快就会看到 <code>ComplempleFuture</code> 能够做得更多。</p><h3 id=基本用法>基本用法</h3><p>这是一个带有静态方法 <strong>work()</strong> 的类，它对该类的对象执行某些工作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Machina.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Machina</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>enum</span> <span class=n>State</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>START</span><span class=o>,</span> <span class=n>ONE</span><span class=o>,</span> <span class=n>TWO</span><span class=o>,</span> <span class=n>THREE</span><span class=o>,</span> <span class=n>END</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>State</span> <span class=nf>step</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=o>(</span><span class=n>equals</span><span class=o>(</span><span class=n>END</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>END</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=n>values</span><span class=o>()[</span><span class=n>ordinal</span><span class=o>()</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>State</span> <span class=n>state</span> <span class=o>=</span> <span class=n>State</span><span class=o>.</span><span class=na>START</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Machina</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Machina</span> <span class=nf>work</span><span class=o>(</span><span class=n>Machina</span> <span class=n>m</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(!</span><span class=n>m</span><span class=o>.</span><span class=na>state</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>State</span><span class=o>.</span><span class=na>END</span><span class=o>)){</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>m</span><span class=o>.</span><span class=na>state</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=na>state</span><span class=o>.</span><span class=na>step</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>m</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=s>&#34;Machina&#34;</span> <span class=o>+</span> <span class=n>id</span> <span class=o>+</span> <span class=s>&#34;: &#34;</span> <span class=o>+</span> <span class=o>(</span><span class=n>state</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>State</span><span class=o>.</span><span class=na>END</span><span class=o>)?</span> <span class=s>&#34;complete&#34;</span> <span class=o>:</span> <span class=n>state</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>这是一个有限状态机，一个微不足道的机器，因为它没有分支&mldr;&mldr;它只是从头到尾遍历一条路径。<strong>work()</strong> 方法将机器从一个状态移动到下一个状态，并且需要 100 毫秒才能完成“工作”。</p><p><strong>CompletableFuture</strong> 可以被用来做的一件事是, 使用 <strong>completedFuture()</strong> 将它感兴趣的对象进行包装。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CompletedMachina.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletedMachina</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>Machina</span><span class=o>(</span><span class=mi>0</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Machina</span> <span class=n>m</span> <span class=o>=</span> <span class=n>cf</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>  <span class=c1>// Doesn&#39;t block
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>}</span> <span class=k>catch</span><span class=o>(</span><span class=n>InterruptedException</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>            <span class=n>ExecutionException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>completedFuture()</strong> 创建一个“已经完成”的 <strong>CompletableFuture</strong> 。对这样一个未来做的唯一有用的事情是 <strong>get()</strong> 里面的对象，所以这看起来似乎没有用。注意 <strong>CompletableFuture</strong> 被输入到它包含的对象。这个很重要。</p><p>通常，<strong>get()</strong> 在等待结果时阻塞调用线程。此块可以通过 <strong>InterruptedException</strong> 或 <strong>ExecutionException</strong> 中断。在这种情况下，阻止永远不会发生，因为 <strong>CompletableFuture</strong> 已经完成，所以结果立即可用。</p><p>当我们将 <strong>handle()</strong> 包装在 <strong>CompletableFuture</strong> 中时，发现我们可以在 <strong>CompletableFuture</strong> 上添加操作来处理所包含的对象，使得事情变得更加有趣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CompletableApply.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletableApply</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>Machina</span><span class=o>(</span><span class=mi>0</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf2</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>cf</span><span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf3</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>cf2</span><span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf4</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>cf3</span><span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf5</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>cf4</span><span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>输出结果</strong>：</p><pre tabindex=0><code>Machina0: ONE
Machina0: TWO
Machina0: THREE
Machina0: complete
</code></pre><p><code>thenApply()</code> 应用一个接收输入并产生输出的函数。在本例中，<code>work()</code> 函数产生的类型与它所接收的类型相同 （<code>Machina</code>），因此每个 <code>CompletableFuture</code>添加的操作的返回类型都为 <code>Machina</code>，但是 (类似于流中的 <code>map()</code> ) 函数也可以返回不同的类型，这将体现在返回类型上。</p><p>你可以在此处看到有关 <strong>CompletableFutures</strong> 的重要信息：它们会在你执行操作时自动解包并重新包装它们所携带的对象。这使得编写和理解代码变得更加简单， 而不会在陷入在麻烦的细节中。</p><p>我们可以消除中间变量并将操作链接在一起，就像我们使用 Streams 一样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CompletableApplyChained.javaimport java.util.concurrent.*;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>onjava.Timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletableApplyChained</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Timer</span> <span class=n>timer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Timer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>Machina</span><span class=o>(</span><span class=mi>0</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                  <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                  <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                  <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                  <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>Machina0: ONE
Machina0: TWO
Machina0: THREE
Machina0: complete
514
</code></pre><p>这里我们还添加了一个 <code>Timer</code>，它的功能在每一步都显性地增加 100ms 等待时间之外，还将 <code>CompletableFuture</code> 内部 <code>thenApply</code> 带来的额外开销给体现出来了。
<strong>CompletableFutures</strong> 的一个重要好处是它们鼓励使用私有子类原则（不共享任何东西）。默认情况下，使用 <strong>thenApply()</strong> 来应用一个不对外通信的函数 - 它只需要一个参数并返回一个结果。这是函数式编程的基础，并且它在并发特性方面非常有效<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。并行流和 <code>ComplempleFutures</code> 旨在支持这些原则。只要你不决定共享数据（共享非常容易导致意外发生）你就可以编写出相对安全的并发程序。</p><p>回调 <code>thenApply()</code> 一旦开始一个操作，在完成所有任务之前，不会完成 <strong>CompletableFuture</strong> 的构建。虽然这有时很有用，但是开始所有任务通常更有价值，这样就可以运行继续前进并执行其他操作。我们可通过<code>thenApplyAsync()</code> 来实现此目的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CompletableApplyAsync.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletableApplyAsync</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Timer</span> <span class=n>timer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Timer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Machina</span><span class=o>&gt;</span> <span class=n>cf</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>Machina</span><span class=o>(</span><span class=mi>0</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Machina</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>cf</span><span class=o>.</span><span class=na>join</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>116
Machina0: ONE
Machina0: TWO
Machina0:THREE
Machina0: complete
Machina0: complete
552
</code></pre><p>同步调用 (我们通常使用的那种) 意味着：“当你完成工作时，才返回”，而异步调用以意味着： “立刻返回并继续后续工作”。 正如你所看到的，<code>cf</code> 的创建现在发生的更快。每次调用 <code>thenApplyAsync()</code> 都会立刻返回，因此可以进行下一次调用，整个调用链路完成速度比以前快得多。</p><p>事实上，如果没有回调 <code>cf.join()</code> 方法，程序会在完成其工作之前退出。而 <code>cf.join()</code> 直到 cf 操作完成之前，阻止 <code>main()</code> 进程结束。我们还可以看出本示例大部分时间消耗在 <code>cf.join()</code> 这。</p><p>这种“立即返回”的异步能力需要 <code>CompletableFuture</code> 库进行一些秘密（<code>client</code> 无感）工作。特别是，它将你需要的操作链存储为一组回调。当操作的第一个链路（后台操作）完成并返回时，第二个链路（后台操作）必须获取生成的 <code>Machina</code> 并开始工作，以此类推！ 但这种异步机制没有我们可以通过程序调用栈控制的普通函数调用序列，它的调用链路顺序会丢失，因此它使用一个函数地址来存储的回调来解决这个问题。</p><p>幸运的是，这就是你需要了解的有关回调的全部信息。程序员将这种人为制造的混乱称为 callback hell（回调地狱）。通过异步调用，<code>CompletableFuture</code> 帮你管理所有回调。 除非你知道你系统中的一些特定逻辑会导致某些改变，或许你更想使用异步调用来实现程序。</p><ul><li>其他操作</li></ul><p>当你查看<code>CompletableFuture</code>的 <code>Javadoc</code> 时，你会看到它有很多方法，但这个方法的大部分来自不同操作的变体。例如，有 <code>thenApply()</code>，<code>thenApplyAsync()</code> 和第二种形式的 <code>thenApplyAsync()</code>，它们使用 <code>Executor</code> 来运行任务 (在本书中，我们忽略了 <code>Executor</code> 选项)。</p><p>下面的示例展示了所有"基本"操作，这些操作既不涉及组合两个 <code>CompletableFuture</code>，也不涉及异常 (我们将在后面介绍)。首先，为了提供简洁性和方便性，我们应该重用以下两个实用程序:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span> <span class=nn>onjava</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletableUtilities</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Get and show value stored in a CF:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>showr</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>&lt;?&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>c</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>catch</span><span class=o>(</span><span class=n>InterruptedException</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>ExecutionException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// For CF operations that have no value:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>voidr</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Void</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>c</span><span class=o>.</span><span class=na>get</span><span class=o>();</span> <span class=c1>// Returns void
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span> <span class=k>catch</span><span class=o>(</span><span class=n>InterruptedException</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>ExecutionException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><code>showr()</code> 在 <code>CompletableFuture&lt;Integer></code> 上调用 <code>get()</code>，并显示结果，<code>try/catch</code> 两个可能会出现的异常。</p><p><code>voidr()</code> 是 <code>CompletableFuture&lt;Void></code> 的 <code>showr()</code> 版本，也就是说，<code>CompletableFutures</code> 只为任务完成或失败时显示信息。</p><p>为简单起见，下面的 <code>CompletableFutures</code> 只包装整数。<code>cfi()</code> 是一个便利的方法，它把一个整数包装在一个完整的 <code>CompletableFuture&lt;Integer></code> :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CompletableOperations.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import static</span> <span class=nn>onjava.CompletableUtilities.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletableOperations</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>cfi</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>                <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                        <span class=n>Integer</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>i</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>cfi</span><span class=o>(</span><span class=mi>1</span><span class=o>));</span> <span class=c1>// Basic test
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>voidr</span><span class=o>(</span><span class=n>cfi</span><span class=o>(</span><span class=mi>2</span><span class=o>).</span><span class=na>runAsync</span><span class=o>(()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;runAsync&#34;</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>voidr</span><span class=o>(</span><span class=n>cfi</span><span class=o>(</span><span class=mi>3</span><span class=o>).</span><span class=na>thenRunAsync</span><span class=o>(()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;thenRunAsync&#34;</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>voidr</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>.</span><span class=na>runAsync</span><span class=o>(()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;runAsync is static&#34;</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=mi>99</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>voidr</span><span class=o>(</span><span class=n>cfi</span><span class=o>(</span><span class=mi>4</span><span class=o>).</span><span class=na>thenAcceptAsync</span><span class=o>(</span><span class=n>i</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;thenAcceptAsync: &#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>cfi</span><span class=o>(</span><span class=mi>5</span><span class=o>).</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>42</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>cfi</span><span class=o>(</span><span class=mi>6</span><span class=o>).</span><span class=na>thenComposeAsync</span><span class=o>(</span><span class=n>i</span> <span class=o>-&gt;</span> <span class=n>cfi</span><span class=o>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>99</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>c</span> <span class=o>=</span> <span class=n>cfi</span><span class=o>(</span><span class=mi>7</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=o>.</span><span class=na>obtrudeValue</span><span class=o>(</span><span class=mi>111</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>cfi</span><span class=o>(</span><span class=mi>8</span><span class=o>).</span><span class=na>toCompletableFuture</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=o>.</span><span class=na>complete</span><span class=o>(</span><span class=mi>9</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=o>.</span><span class=na>cancel</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;cancelled: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>.</span><span class=na>isCancelled</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;completed exceptionally: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>.</span><span class=na>isCompletedExceptionally</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;done: &#34;</span> <span class=o>+</span> <span class=n>c</span><span class=o>.</span><span class=na>isDone</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>c</span><span class=o>.</span><span class=na>getNow</span><span class=o>(</span><span class=mi>777</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>42</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>12</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;dependents: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>.</span><span class=na>getNumberOfDependents</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span> <span class=o>/</span> <span class=mi>2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;dependents: &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>.</span><span class=na>getNumberOfDependents</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>输出结果</strong> ：</p><pre tabindex=0><code>1
runAsync
thenRunAsync
runAsync is static
99
thenAcceptAsync: 4
47
105
111
8
9
cancelled: true
completed exceptionally: true
done: true
java.util.concurrent.CompletableFuture@6d311334[Complet ed exceptionally]
777
dependents: 1
dependents: 2
</code></pre><ul><li><code>main()</code> 包含一系列可由其 <code>int</code> 值引用的测试。<ul><li><code>cfi(1)</code> 演示了 <code>showr()</code> 正常工作。</li><li><code>cfi(2)</code> 是调用 <code>runAsync()</code> 的示例。由于 <code>Runnable</code> 不产生返回值，因此使用了返回 <code>CompletableFuture &lt;Void></code> 的<code>voidr()</code> 方法。</li><li>注意使用 <code>cfi(3)</code>,<code>thenRunAsync()</code> 效果似乎与 上例 <code>cfi(2)</code> 使用的 <code>runAsync()</code>相同，差异在后续的测试中体现：<ul><li><code>runAsync()</code> 是一个 <code>static</code> 方法，所以你通常不会像<code>cfi(2)</code>一样调用它。相反你可以在 <code>QuittingCompletable.java</code> 中使用它。</li><li>后续测试中表明 <code>supplyAsync()</code> 也是静态方法，区别在于它需要一个 <code>Supplier</code> 而不是<code>Runnable</code>, 并产生一个<code>CompletableFuture&lt;Integer></code> 而不是 <code>CompletableFuture&lt;Void></code>。</li></ul></li><li><code>then</code> 系列方法将对现有的 <code>CompletableFuture&lt;Integer></code> 进一步操作。<ul><li>与 <code>thenRunAsync()</code> 不同，<code>cfi(4)</code>，<code>cfi(5)</code> 和<code>cfi(6)</code> &ldquo;then&rdquo; 方法的参数是未包装的 <code>Integer</code>。</li><li>通过使用 <code>voidr()</code>方法可以看到:<ul><li><code>AcceptAsync()</code>接收了一个 <code>Consumer</code>，因此不会产生结果。</li><li><code>thenApplyAsync()</code> 接收一个<code>Function</code>, 并生成一个结果（该结果的类型可以不同于其输入类型）。</li><li><code>thenComposeAsync()</code> 与 <code>thenApplyAsync()</code>非常相似，唯一区别在于其 <code>Function</code> 必须产生已经包装在<code>CompletableFuture</code>中的结果。</li></ul></li></ul></li><li><code>cfi(7)</code> 示例演示了 <code>obtrudeValue()</code>，它强制将值作为结果。</li><li><code>cfi(8)</code> 使用 <code>toCompletableFuture()</code> 从 <code>CompletionStage</code> 生成一个<code>CompletableFuture</code>。</li><li><code>c.complete(9)</code> 显示了如何通过给它一个结果来完成一个<code>task</code>（<code>future</code>）（与 <code>obtrudeValue()</code> 相对，后者可能会迫使其结果替换该结果）。</li><li>如果你调用 <code>CompletableFuture</code>中的 <code>cancel()</code>方法，如果已经完成此任务，则正常结束。 如果尚未完成，则使用 <code>CancellationException</code> 完成此 <code>CompletableFuture</code>。</li><li>如果任务（<code>future</code>）完成，则 <strong>getNow()</strong> 方法返回<code>CompletableFuture</code>的完成值，否则返回<code>getNow()</code>的替换参数。</li><li>最后，我们看一下依赖 (<code>dependents</code>) 的概念。如果我们将两个<code>thenApplyAsync()</code>调用链路到<code>CompletableFuture</code>上，则依赖项的数量不会增加，保持为 1。但是，如果我们另外将另一个<code>thenApplyAsync()</code>直接附加到<code>c</code>，则现在有两个依赖项：两个一起的链路和另一个单独附加的链路。<ul><li>这表明你可以使用一个<code>CompletionStage</code>，当它完成时，可以根据其结果派生多个新任务。</li></ul></li></ul></li></ul><h3 id=结合-completablefuture>结合 CompletableFuture</h3><p>第二种类型的 <code>CompletableFuture</code> 方法采用两种 <code>CompletableFuture</code> 并以各异方式将它们组合在一起。就像两个人在比赛一样, 一个<code>CompletableFuture</code>通常比另一个更早地到达终点。这些方法允许你以不同的方式处理结果。
为了测试这一点，我们将创建一个任务，它有一个我们可以控制的定义了完成任务所需要的时间量的参数。
CompletableFuture 先完成:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Workable.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Workable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=kt>double</span> <span class=n>duration</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Workable</span><span class=o>(</span><span class=n>String</span> <span class=n>id</span><span class=o>,</span> <span class=kt>double</span> <span class=n>duration</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>duration</span> <span class=o>=</span> <span class=n>duration</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;Workable[&#34;</span> <span class=o>+</span> <span class=n>id</span> <span class=o>+</span> <span class=s>&#34;]&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Workable</span> <span class=nf>work</span><span class=o>(</span><span class=n>Workable</span> <span class=n>tt</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=n>tt</span><span class=o>.</span><span class=na>duration</span><span class=o>);</span> <span class=c1>// Seconds
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>tt</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>tt</span><span class=o>.</span><span class=na>id</span> <span class=o>+</span> <span class=s>&#34;W&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>tt</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tt</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Workable</span><span class=o>&gt;</span> <span class=nf>make</span><span class=o>(</span><span class=n>String</span> <span class=n>id</span><span class=o>,</span> <span class=kt>double</span> <span class=n>duration</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>CompletableFuture</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                        <span class=k>new</span> <span class=n>Workable</span><span class=o>(</span><span class=n>id</span><span class=o>,</span> <span class=n>duration</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Workable</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>在 <code>make()</code>中，<code>work()</code>方法应用于<code>CompletableFuture</code>。<code>work()</code>需要一定的时间才能完成，然后它将字母 W 附加到 id 上，表示工作已经完成。</p><p>现在我们可以创建多个竞争的 <code>CompletableFuture</code>，并使用 <code>CompletableFuture</code> 库中的各种方法来进行操作:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/DualCompletableOperations.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import static</span> <span class=nn>onjava.CompletableUtilities.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>DualCompletableOperations</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Workable</span><span class=o>&gt;</span> <span class=n>cfA</span><span class=o>,</span> <span class=n>cfB</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>init</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cfA</span> <span class=o>=</span> <span class=n>Workable</span><span class=o>.</span><span class=na>make</span><span class=o>(</span><span class=s>&#34;A&#34;</span><span class=o>,</span> <span class=mf>0.15</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cfB</span> <span class=o>=</span> <span class=n>Workable</span><span class=o>.</span><span class=na>make</span><span class=o>(</span><span class=s>&#34;B&#34;</span><span class=o>,</span> <span class=mf>0.10</span><span class=o>);</span> <span class=c1>// Always wins
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>join</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cfA</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>cfB</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;*****************&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>voidr</span><span class=o>(</span><span class=n>cfA</span><span class=o>.</span><span class=na>runAfterEitherAsync</span><span class=o>(</span><span class=n>cfB</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;runAfterEither&#34;</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>voidr</span><span class=o>(</span><span class=n>cfA</span><span class=o>.</span><span class=na>runAfterBothAsync</span><span class=o>(</span><span class=n>cfB</span><span class=o>,</span> <span class=o>()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;runAfterBoth&#34;</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>cfA</span><span class=o>.</span><span class=na>applyToEitherAsync</span><span class=o>(</span><span class=n>cfB</span><span class=o>,</span> <span class=n>w</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;applyToEither: &#34;</span> <span class=o>+</span> <span class=n>w</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>w</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>voidr</span><span class=o>(</span><span class=n>cfA</span><span class=o>.</span><span class=na>acceptEitherAsync</span><span class=o>(</span><span class=n>cfB</span><span class=o>,</span> <span class=n>w</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;acceptEither: &#34;</span> <span class=o>+</span> <span class=n>w</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>voidr</span><span class=o>(</span><span class=n>cfA</span><span class=o>.</span><span class=na>thenAcceptBothAsync</span><span class=o>(</span><span class=n>cfB</span><span class=o>,</span> <span class=o>(</span><span class=n>w1</span><span class=o>,</span> <span class=n>w2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;thenAcceptBoth: &#34;</span>
</span></span><span class=line><span class=cl>                    <span class=o>+</span> <span class=n>w1</span> <span class=o>+</span> <span class=s>&#34;, &#34;</span> <span class=o>+</span> <span class=n>w2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>showr</span><span class=o>(</span><span class=n>cfA</span><span class=o>.</span><span class=na>thenCombineAsync</span><span class=o>(</span><span class=n>cfB</span><span class=o>,</span> <span class=o>(</span><span class=n>w1</span><span class=o>,</span> <span class=n>w2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;thenCombine: &#34;</span>
</span></span><span class=line><span class=cl>                    <span class=o>+</span> <span class=n>w1</span> <span class=o>+</span> <span class=s>&#34;, &#34;</span> <span class=o>+</span> <span class=n>w2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>w1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Workable</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>cfC</span> <span class=o>=</span> <span class=n>Workable</span><span class=o>.</span><span class=na>make</span><span class=o>(</span><span class=s>&#34;C&#34;</span><span class=o>,</span> <span class=mf>0.08</span><span class=o>),</span>
</span></span><span class=line><span class=cl>                <span class=n>cfD</span> <span class=o>=</span> <span class=n>Workable</span><span class=o>.</span><span class=na>make</span><span class=o>(</span><span class=s>&#34;D&#34;</span><span class=o>,</span> <span class=mf>0.09</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>anyOf</span><span class=o>(</span><span class=n>cfA</span><span class=o>,</span> <span class=n>cfB</span><span class=o>,</span> <span class=n>cfC</span><span class=o>,</span> <span class=n>cfD</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenRunAsync</span><span class=o>(()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;anyOf&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>cfC</span> <span class=o>=</span> <span class=n>Workable</span><span class=o>.</span><span class=na>make</span><span class=o>(</span><span class=s>&#34;C&#34;</span><span class=o>,</span> <span class=mf>0.08</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cfD</span> <span class=o>=</span> <span class=n>Workable</span><span class=o>.</span><span class=na>make</span><span class=o>(</span><span class=s>&#34;D&#34;</span><span class=o>,</span> <span class=mf>0.09</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>allOf</span><span class=o>(</span><span class=n>cfA</span><span class=o>,</span> <span class=n>cfB</span><span class=o>,</span> <span class=n>cfC</span><span class=o>,</span> <span class=n>cfD</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenRunAsync</span><span class=o>(()</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;allOf&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>输出结果</strong>：</p><pre tabindex=0><code>Workable[BW]
runAfterEither
Workable[AW]
*****************
Workable[BW]
Workable[AW]
runAfterBoth
*****************
Workable[BW]
applyToEither: Workable[BW]
Workable[BW]
Workable[AW]
*****************
Workable[BW]
acceptEither: Workable[BW]
Workable[AW]
*****************
Workable[BW]
Workable[AW]
thenAcceptBoth: Workable[AW], Workable[BW]
****************
 Workable[BW]
 Workable[AW]
 thenCombine: Workable[AW], Workable[BW]
 Workable[AW]
 *****************
 Workable[CW]
 anyOf
 Workable[DW]
 Workable[BW]
 Workable[AW]
 *****************
 Workable[CW]
 Workable[DW]
 Workable[BW]
 Workable[AW]
 *****************
 allOf
</code></pre><ul><li>为了方便访问， 将 <code>cfA</code> 和 <code>cfB</code> 定义为 <code>static</code>的。<ul><li><code>init()</code>方法用于 <code>A</code>, <code>B</code> 初始化这两个变量，因为 <code>B</code> 总是给出比<code>A</code>较短的延迟，所以总是 <code>win</code> 的一方。</li><li><code>join()</code> 是在两个方法上调用 <code>join()</code> 并显示边框的另一个便利方法。</li></ul></li><li>所有这些 “<code>dual</code>” 方法都以一个 <code>CompletableFuture</code> 作为调用该方法的对象，第二个 <code>CompletableFuture</code> 作为第一个参数，然后是要执行的操作。</li><li>通过使用 <code>showr()</code> 和 <code>voidr()</code> 可以看到，“<code>run</code>”和“<code>accept</code>”是终端操作，而“<code>apply</code>”和“<code>combine</code>”则生成新的 <code>payload-bearing</code> (承载负载) 的 <code>CompletableFuture</code>。</li><li>方法的名称不言自明，你可以通过查看输出来验证这一点。一个特别有趣的方法是 <code>combineAsync()</code>，它等待两个 <code>CompletableFuture</code> 完成，然后将它们都交给一个 <code>BiFunction</code>，这个 <code>BiFunction</code> 可以将结果加入到最终的 <code>CompletableFuture</code> 的有效负载中。</li></ul><h3 id=模拟>模拟</h3><p>作为使用 <code>CompletableFuture</code> 将一系列操作组合的示例，让我们模拟一下制作蛋糕的过程。在第一阶段，我们准备并将原料混合成面糊:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Batter.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Batter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Eggs</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Milk</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Sugar</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Flour</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=nf>prepare</span><span class=o>(</span><span class=n>T</span> <span class=n>ingredient</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ingredient</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=nf>prep</span><span class=o>(</span><span class=n>T</span> <span class=n>ingredient</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>CompletableFuture</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span><span class=n>ingredient</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Batter</span><span class=o>::</span><span class=n>prepare</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Batter</span><span class=o>&gt;</span> <span class=nf>mix</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Eggs</span><span class=o>&gt;</span> <span class=n>eggs</span> <span class=o>=</span> <span class=n>prep</span><span class=o>(</span><span class=k>new</span> <span class=n>Eggs</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Milk</span><span class=o>&gt;</span> <span class=n>milk</span> <span class=o>=</span> <span class=n>prep</span><span class=o>(</span><span class=k>new</span> <span class=n>Milk</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Sugar</span><span class=o>&gt;</span> <span class=n>sugar</span> <span class=o>=</span> <span class=n>prep</span><span class=o>(</span><span class=k>new</span> <span class=n>Sugar</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Flour</span><span class=o>&gt;</span> <span class=n>flour</span> <span class=o>=</span> <span class=n>prep</span><span class=o>(</span><span class=k>new</span> <span class=n>Flour</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>allOf</span><span class=o>(</span><span class=n>eggs</span><span class=o>,</span> <span class=n>milk</span><span class=o>,</span> <span class=n>sugar</span><span class=o>,</span> <span class=n>flour</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span> <span class=c1>// Mixing time
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span><span class=k>new</span> <span class=n>Batter</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>每种原料都需要一些时间来准备。<code>allOf()</code> 等待所有的配料都准备好，然后使用更多些的时间将其混合成面糊。接下来，我们把单批面糊放入四个平底锅中烘烤。产品作为 <code>CompletableFutures</code> 流返回：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Baked.java
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Baked</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Pan</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>Pan</span> <span class=nf>pan</span><span class=o>(</span><span class=n>Batter</span> <span class=n>b</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>Pan</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>Baked</span> <span class=nf>heat</span><span class=o>(</span><span class=n>Pan</span> <span class=n>p</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>Baked</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Baked</span><span class=o>&gt;</span> <span class=nf>bake</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Batter</span><span class=o>&gt;</span> <span class=n>cfb</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cfb</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Baked</span><span class=o>::</span><span class=n>pan</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Baked</span><span class=o>::</span><span class=n>heat</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Stream</span><span class=o>&lt;</span><span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Baked</span><span class=o>&gt;&gt;</span> <span class=nf>batch</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Batter</span><span class=o>&gt;</span> <span class=n>batter</span> <span class=o>=</span> <span class=n>Batter</span><span class=o>.</span><span class=na>mix</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=n>bake</span><span class=o>(</span><span class=n>batter</span><span class=o>),</span>
</span></span><span class=line><span class=cl>                <span class=n>bake</span><span class=o>(</span><span class=n>batter</span><span class=o>),</span>
</span></span><span class=line><span class=cl>                <span class=n>bake</span><span class=o>(</span><span class=n>batter</span><span class=o>),</span>
</span></span><span class=line><span class=cl>                <span class=n>bake</span><span class=o>(</span><span class=n>batter</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>最后，我们制作了一批糖，并用它对蛋糕进行糖化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/FrostedCake.java
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=kd>class</span> <span class=nc>Frosting</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Frosting</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Frosting</span><span class=o>&gt;</span> <span class=nf>make</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>CompletableFuture</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span><span class=k>new</span> <span class=n>Frosting</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>FrostedCake</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>FrostedCake</span><span class=o>(</span><span class=n>Baked</span> <span class=n>baked</span><span class=o>,</span> <span class=n>Frosting</span> <span class=n>frosting</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;FrostedCake&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Baked</span><span class=o>.</span><span class=na>batch</span><span class=o>().</span><span class=na>forEach</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=n>baked</span> <span class=o>-&gt;</span> <span class=n>baked</span>
</span></span><span class=line><span class=cl>                        <span class=o>.</span><span class=na>thenCombineAsync</span><span class=o>(</span><span class=n>Frosting</span><span class=o>.</span><span class=na>make</span><span class=o>(),</span>
</span></span><span class=line><span class=cl>                                <span class=o>(</span><span class=n>cake</span><span class=o>,</span> <span class=n>frosting</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                                        <span class=k>new</span> <span class=n>FrostedCake</span><span class=o>(</span><span class=n>cake</span><span class=o>,</span> <span class=n>frosting</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                        <span class=o>.</span><span class=na>thenAcceptAsync</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                        <span class=o>.</span><span class=na>join</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>一旦你习惯了这种背后的想法, <code>CompletableFuture</code> 它们相对易于使用。</p><h3 id=异常>异常</h3><p>与 <code>CompletableFuture</code> 在处理链中包装对象的方式相同，它也会缓冲异常。这些在处理时调用者是无感的，但仅当你尝试提取结果时才会被告知。为了说明它们是如何工作的，我们首先创建一个类，它在特定的条件下抛出一个异常:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Breakable.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Breakable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>failcount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Breakable</span><span class=o>(</span><span class=n>String</span> <span class=n>id</span><span class=o>,</span> <span class=kt>int</span> <span class=n>failcount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>failcount</span> <span class=o>=</span> <span class=n>failcount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;Breakable_&#34;</span> <span class=o>+</span> <span class=n>id</span> <span class=o>+</span> <span class=s>&#34; [&#34;</span> <span class=o>+</span> <span class=n>failcount</span> <span class=o>+</span> <span class=s>&#34;]&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Breakable</span> <span class=nf>work</span><span class=o>(</span><span class=n>Breakable</span> <span class=n>b</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(--</span><span class=n>b</span><span class=o>.</span><span class=na>failcount</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;Throwing Exception for &#34;</span> <span class=o>+</span> <span class=n>b</span><span class=o>.</span><span class=na>id</span> <span class=o>+</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>            <span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;Breakable_&#34;</span> <span class=o>+</span> <span class=n>b</span><span class=o>.</span><span class=na>id</span> <span class=o>+</span> <span class=s>&#34; failed&#34;</span>
</span></span><span class=line><span class=cl>            <span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>当<code>failcount</code> > 0，且每次将对象传递给 <code>work()</code> 方法时， <code>failcount - 1</code> 。当<code>failcount - 1 = 0</code> 时，<code>work()</code> 将抛出一个异常。如果传给 <code>work()</code> 的 <code>failcount = 0</code> ，<code>work()</code> 永远不会抛出异常。</p><p>注意，异常信息此示例中被抛出（ <code>RuntimeException</code> )</p><p>在下面示例 <code>test()</code> 方法中，<code>work()</code> 多次应用于 <code>Breakable</code>，因此如果 <code>failcount</code> 在范围内，就会抛出异常。然而，在测试<code>A</code>到<code>E</code>中，你可以从输出中看到抛出了异常，但它们从未出现:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CompletableExceptions.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletableExceptions</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Breakable</span><span class=o>&gt;</span> <span class=nf>test</span><span class=o>(</span><span class=n>String</span> <span class=n>id</span><span class=o>,</span> <span class=kt>int</span> <span class=n>failcount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>Breakable</span><span class=o>(</span><span class=n>id</span><span class=o>,</span> <span class=n>failcount</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Exceptions don&#39;t appear ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;A&#34;</span><span class=o>,</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;B&#34;</span><span class=o>,</span> <span class=mi>2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;C&#34;</span><span class=o>,</span> <span class=mi>3</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;D&#34;</span><span class=o>,</span> <span class=mi>4</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;E&#34;</span><span class=o>,</span> <span class=mi>5</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... until you try to fetch the value:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>test</span><span class=o>(</span><span class=s>&#34;F&#34;</span><span class=o>,</span> <span class=mi>2</span><span class=o>).</span><span class=na>get</span><span class=o>();</span> <span class=c1>// or join()
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>getMessage</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Test for exceptions:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=n>test</span><span class=o>(</span><span class=s>&#34;G&#34;</span><span class=o>,</span> <span class=mi>2</span><span class=o>).</span><span class=na>isCompletedExceptionally</span><span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Counts as &#34;done&#34;:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>test</span><span class=o>(</span><span class=s>&#34;H&#34;</span><span class=o>,</span> <span class=mi>2</span><span class=o>).</span><span class=na>isDone</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Force an exception:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>cfi</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>CompletableFuture</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;done? &#34;</span> <span class=o>+</span> <span class=n>cfi</span><span class=o>.</span><span class=na>isDone</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>cfi</span><span class=o>.</span><span class=na>completeExceptionally</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=s>&#34;forced&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cfi</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>getMessage</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>Throwing Exception for A
Breakable_B [1]
Throwing Exception for B
Breakable_C [2]
Breakable_C [1]
Throwing Exception for C
Breakable_D [3]
Breakable_D [2]
Breakable_D [1]
Throwing Exception for D
Breakable_E [4]
Breakable_E [3]
Breakable_E [2]
Breakable_E [1]
Breakable_F [1]
Throwing Exception for F
java.lang.RuntimeException: Breakable_F failed
Breakable_G [1]
Throwing Exception for G
true
Breakable_H [1]
Throwing Exception for H
true
done? false
java.lang.RuntimeException: forced
</code></pre><p>测试 <code>A</code> 到 <code>E</code> 运行到抛出异常，然后…并没有将抛出的异常暴露给调用方。只有在测试 F 中调用 <code>get()</code> 时，我们才会看到抛出的异常。
测试 <code>G</code> 表明，你可以首先检查在处理期间是否抛出异常，而不抛出该异常。然而，test <code>H</code> 告诉我们，不管异常是否成功，它仍然被视为已“完成”。
代码的最后一部分展示了如何将异常插入到 <code>CompletableFuture</code> 中，而不管是否存在任何失败。
在连接或获取结果时，我们使用 <code>CompletableFuture</code> 提供的更复杂的机制来自动响应异常，而不是使用粗糙的 <code>try-catch</code>。
你可以使用与我们看到的所有 <code>CompletableFuture</code> 相同的表单来完成此操作:在链中插入一个 <code>CompletableFuture</code> 调用。有三个选项 <code>exceptionally()</code>，<code>handle()</code>， <code>whenComplete()</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CatchCompletableExceptions.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CatchCompletableExceptions</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>handleException</span><span class=o>(</span><span class=kt>int</span> <span class=n>failcount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Call the Function only if there&#39;s an
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// exception, must produce same type as came in:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CompletableExceptions</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>test</span><span class=o>(</span><span class=s>&#34;exceptionally&#34;</span><span class=o>,</span> <span class=n>failcount</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>exceptionally</span><span class=o>((</span><span class=n>ex</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span> <span class=c1>// Function
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>ex</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;I don&#39;t get it yet&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=k>new</span> <span class=n>Breakable</span><span class=o>(</span><span class=n>ex</span><span class=o>.</span><span class=na>getMessage</span><span class=o>(),</span> <span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>})</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>str</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;result: &#34;</span> <span class=o>+</span> <span class=n>str</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Create a new result (recover):
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CompletableExceptions</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>test</span><span class=o>(</span><span class=s>&#34;handle&#34;</span><span class=o>,</span> <span class=n>failcount</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>handle</span><span class=o>((</span><span class=n>result</span><span class=o>,</span> <span class=n>fail</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span> <span class=c1>// BiFunction
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>fail</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>return</span> <span class=s>&#34;Failure recovery object&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>else</span>
</span></span><span class=line><span class=cl>                        <span class=k>return</span> <span class=n>result</span> <span class=o>+</span> <span class=s>&#34; is good&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>})</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>str</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;result: &#34;</span> <span class=o>+</span> <span class=n>str</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Do something but pass the same result through:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CompletableExceptions</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>test</span><span class=o>(</span><span class=s>&#34;whenComplete&#34;</span><span class=o>,</span> <span class=n>failcount</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>whenComplete</span><span class=o>((</span><span class=n>result</span><span class=o>,</span> <span class=n>fail</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span> <span class=c1>// BiConsumer
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>fail</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;It failed&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>else</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>result</span> <span class=o>+</span> <span class=s>&#34; OK&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>})</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenAccept</span><span class=o>(</span><span class=n>r</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;result: &#34;</span> <span class=o>+</span> <span class=n>r</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;**** Failure Mode ****&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>handleException</span><span class=o>(</span><span class=mi>2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;**** Success Mode ****&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>handleException</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>**** Failure Mode ****
Breakable_exceptionally [1]
Throwing Exception for exceptionally
result: Breakable_java.lang.RuntimeException:
Breakable_exceptionally failed [0]
Breakable_handle [1]
Throwing Exception for handle
result: Failure recovery object
Breakable_whenComplete [1]
Throwing Exception for whenComplete
It failed
**** Success Mode ****
Breakable_exceptionally [-1]
Breakable_exceptionally [-2]
Breakable_exceptionally [-3]
Breakable_exceptionally [-4]
result: Breakable_exceptionally [-4]
Breakable_handle [-1]
Breakable_handle [-2]
Breakable_handle [-3]
Breakable_handle [-4]
result: Breakable_handle [-4] is good
Breakable_whenComplete [-1]
Breakable_whenComplete [-2]
Breakable_whenComplete [-3]
Breakable_whenComplete [-4]
Breakable_whenComplete [-4] OK
result: Breakable_whenComplete [-4]
</code></pre><ul><li><p><code>exceptionally()</code> 参数仅在出现异常时才运行。<code>exceptionally()</code> 局限性在于，该函数只能返回输入类型相同的值。</p></li><li><p><code>exceptionally()</code> 通过将一个好的对象插入到流中来恢复到一个可行的状态。</p></li><li><p><code>handle()</code> 一致被调用来查看是否发生异常（必须检查 fail 是否为 true）。</p><ul><li><p>但是 <code>handle()</code> 可以生成任何新类型，所以它允许执行处理，而不是像使用 <code>exceptionally()</code>那样简单地恢复。</p></li><li><p><code>whenComplete()</code> 类似于 handle()，同样必须测试它是否失败，但是参数是一个消费者，并且不修改传递给它的结果对象。</p></li></ul></li></ul><h3 id=流异常stream-exception>流异常（Stream Exception）</h3><p>通过修改 <strong>CompletableExceptions.java</strong> ，看看 <strong>CompletableFuture</strong> 异常与流异常有何不同：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/StreamExceptions.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>StreamExceptions</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>Stream</span><span class=o>&lt;</span><span class=n>Breakable</span><span class=o>&gt;</span> <span class=nf>test</span><span class=o>(</span><span class=n>String</span> <span class=n>id</span><span class=o>,</span> <span class=kt>int</span> <span class=n>failcount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>Breakable</span><span class=o>(</span><span class=n>id</span><span class=o>,</span> <span class=n>failcount</span><span class=o>))</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Breakable</span><span class=o>::</span><span class=n>work</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// No operations are even applied ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;A&#34;</span><span class=o>,</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;B&#34;</span><span class=o>,</span> <span class=mi>2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Stream</span><span class=o>&lt;</span><span class=n>Breakable</span><span class=o>&gt;</span> <span class=n>c</span> <span class=o>=</span> <span class=n>test</span><span class=o>(</span><span class=s>&#34;C&#34;</span><span class=o>,</span> <span class=mi>3</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;D&#34;</span><span class=o>,</span> <span class=mi>4</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>test</span><span class=o>(</span><span class=s>&#34;E&#34;</span><span class=o>,</span> <span class=mi>5</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... until there&#39;s a terminal operation:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Entering try&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>   <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>getMessage</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>Entering try
Breakable_C [2]
Breakable_C [1]
Throwing Exception for C
Breakable_C failed
</code></pre><p>使用 <code>CompletableFuture</code>，我们可以看到测试 A 到 E 的进展，但是使用流，在你应用一个终端操作之前（e.g. <code>forEach()</code>），什么都不会暴露给 Client</p><p><code>CompletableFuture</code> 执行工作并捕获任何异常供以后检索。比较这两者并不容易，因为 <code>Stream</code> 在没有终端操作的情况下根本不做任何事情——但是流绝对不会存储它的异常。</p><h3 id=检查性异常>检查性异常</h3><p><code>CompletableFuture</code> 和 <code>parallel Stream</code> 都不支持包含检查性异常的操作。相反，你必须在调用操作时处理检查到的异常，这会产生不太优雅的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/ThrowsChecked.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThrowsChecked</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>class</span> <span class=nc>Checked</span> <span class=kd>extends</span> <span class=n>Exception</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>ThrowsChecked</span> <span class=nf>nochecked</span><span class=o>(</span><span class=n>ThrowsChecked</span> <span class=n>tc</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tc</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=n>ThrowsChecked</span> <span class=nf>withchecked</span><span class=o>(</span><span class=n>ThrowsChecked</span> <span class=n>tc</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Checked</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tc</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>testStream</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=k>new</span> <span class=n>ThrowsChecked</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>ThrowsChecked</span><span class=o>::</span><span class=n>nochecked</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=c1>// .map(ThrowsChecked::withchecked); // [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=o>.</span><span class=na>map</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                        <span class=n>tc</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                            <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>return</span> <span class=n>withchecked</span><span class=o>(</span><span class=n>tc</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                            <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Checked</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                            <span class=o>}</span>
</span></span><span class=line><span class=cl>                        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>testCompletableFuture</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span><span class=k>new</span> <span class=n>ThrowsChecked</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span><span class=n>ThrowsChecked</span><span class=o>::</span><span class=n>nochecked</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=c1>// .thenApply(ThrowsChecked::withchecked); // [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=o>.</span><span class=na>thenApply</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                        <span class=n>tc</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                            <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>return</span> <span class=n>withchecked</span><span class=o>(</span><span class=n>tc</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                            <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Checked</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                            <span class=o>}</span>
</span></span><span class=line><span class=cl>                        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>如果你试图像使用 <code>nochecked()</code> 那样使用<code> withchecked()</code> 的方法引用，编译器会在 <code>[1]</code> 和 <code>[2]</code> 中报错。相反，你必须写出 lambda 表达式 (或者编写一个不会抛出异常的包装器方法)。</p><h2 id=死锁>死锁</h2><p>由于任务可以被阻塞，因此一个任务有可能卡在等待另一个任务上，而后者又在等待别的任务，这样一直下去，知道这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间相互等待的连续循环， 没有哪个线程能继续， 这称之为死锁<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>
如果你运行一个程序，而它马上就死锁了， 你可以立即跟踪下去。真正的问题在于，程序看起来工作良好， 但是具有潜在的死锁危险。这时， 死锁可能发生，而事先却没有任何征兆， 所以 <code>bug</code> 会潜伏在你的程序例，直到客户发现它出乎意料的发生（以一种几乎肯定是很难重现的方式发生）。因此在编写并发程序的时候，进行仔细的程序设计以防止死锁是关键部分。
埃德斯·迪克斯特拉（<code>Essger Dijkstra</code>）发明的“哲学家进餐"问题是经典的死锁例证。基本描述指定了五位哲学家（此处显示的示例允许任何数目）。这些哲学家将花部分时间思考，花部分时间就餐。他们在思考的时候并不需要任何共享资源；但是他们使用的餐具数量有限。在最初的问题描述中，餐具是叉子，需要两个叉子才能从桌子中间的碗里取出意大利面。常见的版本是使用筷子， 显然，每个哲学家都需要两根筷子才能吃饭。
引入了一个困难：作为哲学家，他们的钱很少，所以他们只能买五根筷子（更一般地讲，筷子的数量与哲学家相同）。他们围在桌子周围，每人之间放一根筷子。 当一个哲学家要就餐时，该哲学家必须同时持有左边和右边的筷子。如果任一侧的哲学家都在使用所需的筷子，则我们的哲学家必须等待，直到可得到必须的筷子。</p><p><strong>StickHolder</strong> 类通过将单根筷子保持在大小为 1 的 <strong>BlockingQueue</strong> 中来管理它。<strong>BlockingQueue</strong> 是一个设计用于在并发程序中安全使用的集合，如果你调用 take() 并且队列为空，则它将阻塞（等待）。将新元素放入队列后，将释放该块并返回该值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/StickHolder.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>StickHolder</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Chopstick</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Chopstick</span> <span class=n>stick</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Chopstick</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>BlockingQueue</span><span class=o>&lt;</span><span class=n>Chopstick</span><span class=o>&gt;</span> <span class=n>holder</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>ArrayBlockingQueue</span><span class=o>&lt;&gt;(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>StickHolder</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>putDown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>pickUp</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>holder</span><span class=o>.</span><span class=na>take</span><span class=o>();</span> <span class=c1>// Blocks if unavailable
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>putDown</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>holder</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>stick</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>为简单起见，<code>Chopstick</code>(<code>static</code>) 实际上不是由 <code>StickHolder</code> 生产的，而是在其类中保持私有的。</p><p>如果您调用了<code>pickUp()</code>，而 <code>stick</code> 不可用，那么<code>pickUp()</code>将阻塞该 <code>stick</code>，直到另一个哲学家调用<code>putDown()</code> 将 <code>stick</code> 返回。</p><p>注意，该类中的所有线程安全都是通过 <code>BlockingQueue</code> 实现的。</p><p>每个哲学家都是一项任务，他们试图把筷子分别 <code>pickUp()</code> 在左手和右手上，这样筷子才能吃东西，然后通过 <code>putDown()</code> 放下 <code>stick</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Philosopher.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Philosopher</span> <span class=kd>implements</span> <span class=n>Runnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>seat</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>StickHolder</span> <span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Philosopher</span><span class=o>(</span><span class=kt>int</span> <span class=n>seat</span><span class=o>,</span> <span class=n>StickHolder</span> <span class=n>left</span><span class=o>,</span> <span class=n>StickHolder</span> <span class=n>right</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>seat</span> <span class=o>=</span> <span class=n>seat</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>left</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;P&#34;</span> <span class=o>+</span> <span class=n>seat</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// System.out.println(&#34;Thinking&#34;);   // [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>right</span><span class=o>.</span><span class=na>pickUp</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span><span class=o>.</span><span class=na>pickUp</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=k>this</span> <span class=o>+</span> <span class=s>&#34; eating&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span><span class=o>.</span><span class=na>putDown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span><span class=o>.</span><span class=na>putDown</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>没有两个哲学家可以同时成功调用 take() 同一只筷子。另外，如果一个哲学家已经拿过筷子，那么下一个试图拿起同一根筷子的哲学家将阻塞，等待其被释放。</p><p>结果是一个看似无辜的程序陷入了死锁。我在这里使用数组而不是集合，只是因为这种语法更简洁：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/DiningPhilosophers.java
</span></span></span><span class=line><span class=cl><span class=c1>// Hidden deadlock
</span></span></span><span class=line><span class=cl><span class=c1>// {ExcludeFromGradle} Gradle has trouble
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>DiningPhilosophers</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>StickHolder</span><span class=o>[]</span> <span class=n>sticks</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Philosopher</span><span class=o>[]</span> <span class=n>philosophers</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>DiningPhilosophers</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sticks</span> <span class=o>=</span> <span class=k>new</span> <span class=n>StickHolder</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>setAll</span><span class=o>(</span><span class=n>sticks</span><span class=o>,</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>StickHolder</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>philosophers</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Philosopher</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Arrays</span><span class=o>.</span><span class=na>setAll</span><span class=o>(</span><span class=n>philosophers</span><span class=o>,</span> <span class=n>i</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=k>new</span> <span class=n>Philosopher</span><span class=o>(</span><span class=n>i</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>sticks</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>sticks</span><span class=o>[(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>n</span><span class=o>]));</span>    <span class=c1>// [1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Fix by reversing stick order for this one:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// philosophers[1] =                     // [2]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//   new Philosopher(0, sticks[0], sticks[1]);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>philosophers</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>::</span><span class=n>runAsync</span><span class=o>);</span> <span class=c1>// [3]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Returns right away:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>new</span> <span class=n>DiningPhilosophers</span><span class=o>(</span><span class=mi>5</span><span class=o>);</span>               <span class=c1>// [4]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Keeps main() from exiting:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=mi>3</span><span class=o>,</span> <span class=s>&#34;Shutdown&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li>当你停止查看输出时，该程序将死锁。但是，根据你的计算机配置，你可能不会看到死锁。看来这取决于计算机上的内核数<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>。两个核心不会产生死锁，但两核以上却很容易产生死锁。</li><li>此行为使该示例更好地说明了死锁，因为你可能正在具有 2 核的计算机上编写程序（如果确实是导致问题的原因），并且确信该程序可以正常工作，只能启动它将其安装在另一台计算机上时出现死锁。请注意，不能因为你没或不容易看到死锁，这并不意味着此程序不会在 2 核机器上发生死锁。 该程序仍然有死锁倾向，只是很少发生——可以说是最糟糕的情况，因为问题不容易出现。</li><li>在 <code>DiningPhilosophers</code> 的构造方法中，每个哲学家都获得一个左右筷子的引用。除最后一个哲学家外，都是通过把哲学家放在下一双空闲筷子之间来初始化：<ul><li>最后一位哲学家得到了第 0 根筷子作为他的右筷子，所以圆桌就完成。</li><li>那是因为最后一位哲学家正坐在第一个哲学家的旁边，而且他们俩都共用零筷子。[1] 显示了以 n 为模数选择的右筷子，将最后一个哲学家绕到第一个哲学家的旁边。</li></ul></li><li>现在，所有哲学家都可以尝试吃饭，每个哲学家都在旁边等待哲学家放下筷子。<ul><li>为了让每个哲学家在[3] 上运行，调用 <code>runAsync()</code>，这意味着 DiningPhilosophers 的构造函数立即返回到[4]。</li><li>如果没有任何东西阻止 <code>main()</code> 完成，程序就会退出，不会做太多事情。</li><li><code>Nap</code> 对象阻止 <code>main()</code> 退出，然后在三秒后强制退出 (假设/可能是) 死锁程序。</li><li>在给定的配置中，哲学家几乎不花时间思考。因此，他们在吃东西的时候都争着用筷子，而且往往很快就会陷入僵局。你可以改变这个:</li></ul></li></ul><ol><li><p>通过增加[4] 的值来添加更多哲学家。</p></li><li><p>在 Philosopher.java 中取消注释行[1]。</p></li></ol><p>任一种方法都会减少死锁的可能性，这表明编写并发程序并认为它是安全的危险，因为它似乎“在我的机器上运行正常”。你可以轻松地说服自己该程序没有死锁，即使它不是。这个示例相当有趣，因为它演示了看起来可以正确运行，但实际上会可能发生死锁的程序。</p><p>要修正死锁问题，你必须明白，当以下四个条件同时满足时，就会发生死锁：</p><ol><li>互斥条件。任务使用的资源中至少有一个不能共享的。 这里，一根筷子一次就只能被一个哲学家使用。</li><li>至少有一个任务它必须持有一个资源且正在等待获取一个被当前别的任务持有的资源。也就是说，要发生死锁，哲学家必须拿着一根筷子并且等待另一根。</li><li>资源不能被任务抢占， 任务必须把资源释放当作普通事件。哲学家很有礼貌，他们不会从其它哲学家那里抢筷子。</li><li>必须有循环等待， 这时，一个任务等待其它任务所持有的资源， 后者又在等待另一个任务所持有的资源， 这样一直下去，知道有一个任务在等待第一个任务所持有的资源， 使得大家都被锁住。 在 <code>DiningPhilosophers.java</code> 中， 因为每个哲学家都试图先得到右边的 筷子, 然后得到左边的 筷子, 所以发生了循环等待。</li></ol><p>因为必须满足所有条件才能导致死锁，所以要阻止死锁的话，只需要破坏其中一个即可。在此程序中，防止死锁的一种简单方法是打破第四个条件。之所以会发生这种情况，是因为每个哲学家都尝试按照特定的顺序拾起自己的筷子：先右后左。因此，每个哲学家都有可能在等待左手的同时握住右手的筷子，从而导致循环等待状态。但是，如果其中一位哲学家尝试首先拿起左筷子，则该哲学家决不会阻止紧邻右方的哲学家拿起筷子，从而排除了循环等待。</p><p>在 <strong>DiningPhilosophers.java</strong> 中，取消注释[1] 和其后的一行。这将原来的哲学家[1] 替换为筷子颠倒的哲学家。通过确保第二位哲学家拾起并在右手之前放下左筷子，我们消除了死锁的可能性。
这只是解决问题的一种方法。你也可以通过防止其他情况之一来解决它。
没有语言支持可以帮助防止死锁；你有责任通过精心设计来避免这种情况。对于试图调试死锁程序的人来说，这些都不是安慰。当然，避免并发问题的最简单，最好的方法是永远不要共享资源-不幸的是，这并不总是可能的。</p><h2 id=构造方法非线程安全>构造方法非线程安全</h2><p>当你在脑子里想象一个对象构造的过程，你会很容易认为这个过程是线程安全的。毕竟，在对象初始化完成前对外不可见，所以又怎会对此产生争议呢？确实，<a href=https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3 target=_blank rel=noopener>Java 语言规范</a> (JLS) 自信满满地陈述道：“<em>没必要使构造器的线程同步，因为它会锁定正在构造的对象，直到构造器完成初始化后才对其他线程可见。</em>”</p><p>不幸的是，对象的构造过程如其他操作一样，也会受到共享内存并发问题的影响，只是作用机制可能更微妙罢了。</p><p>设想下使用一个 <strong>static</strong> 字段为每个对象自动创建唯一标识符的过程。为了测试其不同的实现过程，我们从一个接口开始。代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//concurrent/HasID.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>HasID</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>getID</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>然后 <strong>StaticIDField</strong> 类显式地实现该接口。代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/StaticIDField.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>StaticIDField</span> <span class=kd>implements</span> <span class=n>HasID</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=n>counter</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getID</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=n>id</span><span class=o>;</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>如你所想，该类是个简单无害的类，它甚至都没一个显式的构造器来引发问题。当我们运行多个用于创建此类对象的线程时，究竟会发生什么？为了搞清楚这点，我们做了以下测试。代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/IDChecker.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.function.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>com.google.common.collect.Sets</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>IDChecker</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>SIZE</span> <span class=o>=</span> <span class=mi>100_000</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>MakeObjects</span> <span class=kd>implements</span>
</span></span><span class=line><span class=cl>        <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>HasID</span><span class=o>&gt;</span> <span class=n>gen</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>MakeObjects</span><span class=o>(</span><span class=n>Supplier</span><span class=o>&lt;</span><span class=n>HasID</span><span class=o>&gt;</span> <span class=n>gen</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>gen</span> <span class=o>=</span> <span class=n>gen</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span> <span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>get</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Stream</span><span class=o>.</span><span class=na>generate</span><span class=o>(</span><span class=n>gen</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=n>SIZE</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>HasID</span><span class=o>::</span><span class=n>getID</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(</span><span class=n>Supplier</span><span class=o>&lt;</span><span class=n>HasID</span><span class=o>&gt;</span> <span class=n>gen</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>groupA</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(</span><span class=k>new</span>
</span></span><span class=line><span class=cl>            <span class=n>MakeObjects</span><span class=o>(</span><span class=n>gen</span><span class=o>)),</span>
</span></span><span class=line><span class=cl>        <span class=n>groupB</span> <span class=o>=</span> <span class=n>CompletableFuture</span><span class=o>.</span><span class=na>supplyAsync</span><span class=o>(</span><span class=k>new</span>
</span></span><span class=line><span class=cl>            <span class=n>MakeObjects</span><span class=o>(</span><span class=n>gen</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>groupA</span><span class=o>.</span><span class=na>thenAcceptBoth</span><span class=o>(</span><span class=n>groupB</span><span class=o>,</span> <span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=n>Sets</span><span class=o>.</span><span class=na>intersection</span><span class=o>(</span>
</span></span><span class=line><span class=cl>                <span class=n>Sets</span><span class=o>.</span><span class=na>newHashSet</span><span class=o>(</span><span class=n>a</span><span class=o>),</span>
</span></span><span class=line><span class=cl>                <span class=n>Sets</span><span class=o>.</span><span class=na>newHashSet</span><span class=o>(</span><span class=n>b</span><span class=o>)).</span><span class=na>size</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=o>}).</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>MakeObjects</strong> 类是一个生产者类，包含一个能够产生 List&lt;Integer> 类型的列表对象的 <code>get()</code> 方法。通过从每个 <code>HasID</code> 对象提取 <code>ID</code> 并放入列表中来生成这个列表对象，而 <code>test()</code> 方法则创建了两个并行的 <strong>CompletableFuture</strong> 对象，用于运行 <strong>MakeObjects</strong> 生产者类，然后获取运行结果。</p><p>使用 Guava 库中的 **Sets.<code>intersection()</code> 方法，计算出这两个返回的 List&lt;Integer> 对象中有多少相同的 <code>ID</code>（使用谷歌 Guava 库里的方法比使用官方的 <code>retainAll()</code> 方法速度快得多）。</p><p>现在我们可以测试上面的 <strong>StaticIDField</strong> 类了。代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/TestStaticIDField.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>TestStaticIDField</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>IDChecker</span><span class=o>.</span><span class=na>test</span><span class=o>(</span><span class=n>StaticIDField</span><span class=o>::</span><span class=k>new</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>    13287
</code></pre><p>结果中出现了很多重复项。很显然，纯静态 <code>int</code> 用于构造过程并不是线程安全的。让我们使用 <strong>AtomicInteger</strong> 来使其变为线程安全的。代码示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/GuardedIDField.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>GuardedIDField</span> <span class=kd>implements</span> <span class=n>HasID</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>AtomicInteger</span> <span class=n>counter</span> <span class=o>=</span> <span class=k>new</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicInteger</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=n>counter</span><span class=o>.</span><span class=na>getAndIncrement</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getID</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=n>id</span><span class=o>;</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>                <span class=n>IDChecker</span><span class=o>.</span><span class=na>test</span><span class=o>(</span><span class=n>GuardedIDField</span><span class=o>::</span><span class=k>new</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>    0
</code></pre><p>构造器有一种更微妙的状态共享方式：通过构造器参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/SharedConstructorArgument.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>SharedArg</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Unsafe</span> <span class=kd>implements</span> <span class=n>SharedArg</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>get</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>i</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Safe</span> <span class=kd>implements</span> <span class=n>SharedArg</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>AtomicInteger</span> <span class=n>counter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicInteger</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>get</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>counter</span><span class=o>.</span><span class=na>getAndIncrement</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>SharedUser</span> <span class=kd>implements</span> <span class=n>HasID</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SharedUser</span><span class=o>(</span><span class=n>SharedArg</span> <span class=n>sa</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>id</span> <span class=o>=</span> <span class=n>sa</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getID</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SharedConstructorArgument</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Unsafe</span> <span class=n>unsafe</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Unsafe</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IDChecker</span><span class=o>.</span><span class=na>test</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>SharedUser</span><span class=o>(</span><span class=n>unsafe</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Safe</span> <span class=n>safe</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Safe</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IDChecker</span><span class=o>.</span><span class=na>test</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>SharedUser</span><span class=o>(</span><span class=n>safe</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>    24838
    0
</code></pre><p>在这里，<strong>SharedUser</strong> 构造器实际上共享了相同的参数。即使 <strong>SharedUser</strong> 以完全无害且合理的方式使用其自己的参数，其构造器的调用方式也会引起冲突。<strong>SharedUser</strong> 甚至不知道它是以这种方式调用的，更不必说控制它了。</p><p>同步构造器并不被 java 语言所支持，但是通过使用同步语块来创建你自己的同步构造器是可能的（请参阅附录：<a href=./Appendix-Low-Level-Concurrency.md>并发底层原理 </a>，来进一步了解同步关键字—— <code>synchronized</code>）。尽管 JLS（java 语言规范）这样陈述道：“……它会锁定正在构造的对象”，但这并不是真的——构造器实际上只是一个静态方法，因此同步构造器实际上会锁定该类的 Class 对象。我们可以通过创建自己的静态对象并锁定它，来达到与同步构造器相同的效果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/SynchronizedConstructor.java
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>SyncConstructor</span> <span class=kd>implements</span> <span class=n>HasID</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Object</span> <span class=n>constructorLock</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>Object</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SyncConstructor</span><span class=o>(</span><span class=n>SharedArg</span> <span class=n>sa</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=n>constructorLock</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>id</span> <span class=o>=</span> <span class=n>sa</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getID</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SynchronizedConstructor</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Unsafe</span> <span class=n>unsafe</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Unsafe</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IDChecker</span><span class=o>.</span><span class=na>test</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>SyncConstructor</span><span class=o>(</span><span class=n>unsafe</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>    0
</code></pre><p><strong>Unsafe</strong> 类的共享使用现在就变得安全了。另一种方法是将构造器设为私有（因此可以防止继承），并提供一个静态 Factory 方法来生成新对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/SynchronizedFactory.java
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>import</span> <span class=nn>java.util.concurrent.atomic.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=kd>class</span> <span class=nc>SyncFactory</span> <span class=kd>implements</span> <span class=n>HasID</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>SyncFactory</span><span class=o>(</span><span class=n>SharedArg</span> <span class=n>sa</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>id</span> <span class=o>=</span> <span class=n>sa</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getID</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kd>synchronized</span> <span class=n>SyncFactory</span> <span class=nf>factory</span><span class=o>(</span><span class=n>SharedArg</span> <span class=n>sa</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>SyncFactory</span><span class=o>(</span><span class=n>sa</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SynchronizedFactory</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Unsafe</span> <span class=n>unsafe</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Unsafe</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IDChecker</span><span class=o>.</span><span class=na>test</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>SyncFactory</span><span class=o>.</span><span class=na>factory</span><span class=o>(</span><span class=n>unsafe</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>    0
</code></pre><p>通过同步静态工厂方法，可以在构造过程中锁定 <strong>Class</strong> 对象。</p><p>这些示例充分表明了在并发 Java 程序中检测和管理共享状态有多困难。即使你采取“不共享任何内容”的策略，也很容易产生意外的共享事件。</p><h2 id=复杂性和代价>复杂性和代价</h2><p>假设你正在做披萨，我们把从整个流程的当前步骤到下一个步骤所需的工作量，在这里一一表示为枚举变量的一部分：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/Pizza.java import java.util.function.*;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Nap</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Pizza</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>enum</span> <span class=n>Step</span><span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DOUGH</span><span class=o>(</span><span class=mi>4</span><span class=o>),</span> <span class=n>ROLLED</span><span class=o>(</span><span class=mi>1</span><span class=o>),</span> <span class=n>SAUCED</span><span class=o>(</span><span class=mi>1</span><span class=o>),</span> <span class=n>CHEESED</span><span class=o>(</span><span class=mi>2</span><span class=o>),</span>
</span></span><span class=line><span class=cl>        <span class=n>TOPPED</span><span class=o>(</span><span class=mi>5</span><span class=o>),</span> <span class=n>BAKED</span><span class=o>(</span><span class=mi>2</span><span class=o>),</span> <span class=n>SLICED</span><span class=o>(</span><span class=mi>1</span><span class=o>),</span> <span class=n>BOXED</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>effort</span><span class=o>;</span><span class=c1>// Needed to get to the next step
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>Step</span><span class=o>(</span><span class=kt>int</span> <span class=n>effort</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>effort</span> <span class=o>=</span> <span class=n>effort</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Step</span> <span class=nf>forward</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>equals</span><span class=o>(</span><span class=n>BOXED</span><span class=o>))</span> <span class=k>return</span> <span class=n>BOXED</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>Nap</span><span class=o>(</span><span class=n>effort</span> <span class=o>*</span> <span class=mf>0.1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>values</span><span class=o>()[</span><span class=n>ordinal</span><span class=o>()</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Step</span> <span class=n>step</span> <span class=o>=</span> <span class=n>Step</span><span class=o>.</span><span class=na>DOUGH</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Pizza</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>id</span> <span class=o>=</span> <span class=n>id</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>next</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=n>step</span> <span class=o>=</span> <span class=n>step</span><span class=o>.</span><span class=na>forward</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Pizza &#34;</span> <span class=o>+</span> <span class=n>id</span> <span class=o>+</span> <span class=s>&#34;: &#34;</span> <span class=o>+</span> <span class=n>step</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>next</span><span class=o>(</span><span class=n>Step</span> <span class=n>previousStep</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(!</span><span class=n>step</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>previousStep</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalStateException</span><span class=o>(</span><span class=s>&#34;Expected &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                      <span class=n>previousStep</span> <span class=o>+</span> <span class=s>&#34; but found &#34;</span> <span class=o>+</span> <span class=n>step</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>roll</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>DOUGH</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>sauce</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>ROLLED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>cheese</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>SAUCED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>toppings</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>CHEESED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>bake</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>TOPPED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>slice</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>BAKED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Pizza</span> <span class=nf>box</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>next</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>SLICED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>complete</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>step</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>BOXED</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>toString</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;Pizza&#34;</span> <span class=o>+</span> <span class=n>id</span> <span class=o>+</span> <span class=s>&#34;: &#34;</span> <span class=o>+</span> <span class=o>(</span><span class=n>step</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>Step</span><span class=o>.</span><span class=na>BOXED</span><span class=o>)</span> <span class=o>?</span> <span class=s>&#34;complete&#34;</span> <span class=o>:</span> <span class=n>step</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>这只算得上是一个平凡的状态机，就像 <strong>Machina</strong> 类一样。</p><p>制作一个披萨，当披萨饼最终被放在盒子中时，就算完成最终任务了。 如果一个人在做一个披萨饼，那么所有步骤都是线性进行的，即一个接一个地进行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/OnePizza.java
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>OnePizza</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Pizza</span> <span class=n>za</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Pizza</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Timer</span><span class=o>.</span><span class=na>duration</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=o>(!</span><span class=n>za</span><span class=o>.</span><span class=na>complete</span><span class=o>())</span> <span class=n>za</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>Pizza 0: ROLLED
Pizza 0: SAUCED
Pizza 0: CHEESED
Pizza 0: TOPPED
Pizza 0: BAKED
Pizza 0: SLICED
Pizza 0: BOXED
	1622
</code></pre><p>时间以毫秒为单位，加总所有步骤的工作量，会得出与我们的期望值相符的数字。 如果你以这种方式制作了五个披萨，那么你会认为它花费的时间是原来的五倍。 但是，如果这还不够快怎么办？ 我们可以从尝试并行流方法开始：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/PizzaStreams.java
</span></span></span><span class=line><span class=cl><span class=c1>// import java.util.*; import java.util.stream.*;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>PizzaStreams</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>QUANTITY</span> <span class=o>=</span> <span class=mi>5</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Timer</span> <span class=n>timer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Timer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>QUANTITY</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>parallel</span><span class=o>()</span><span class=c1>//[1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        	<span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>za</span> <span class=o>-&gt;</span> <span class=o>{</span> <span class=k>while</span><span class=o>(!</span><span class=n>za</span><span class=o>.</span><span class=na>complete</span><span class=o>())</span> <span class=n>za</span><span class=o>.</span><span class=na>next</span><span class=o>();</span> <span class=o>});</span> 			<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>Pizza 2: ROLLED
Pizza 0: ROLLED
Pizza 1: ROLLED
Pizza 4: ROLLED
Pizza 3:ROLLED
Pizza 2:SAUCED
Pizza 1:SAUCED
Pizza 0:SAUCED
Pizza 4:SAUCED
Pizza 3:SAUCED
Pizza 2:CHEESED
Pizza 1:CHEESED
Pizza 0:CHEESED
Pizza 4:CHEESED
Pizza 3:CHEESED
Pizza 2:TOPPED
Pizza 1:TOPPED
Pizza 0:TOPPED
Pizza 4:TOPPED
Pizza 3:TOPPED
Pizza 2:BAKED
Pizza 1:BAKED
Pizza 0:BAKED
Pizza 4:BAKED
Pizza 3:BAKED
Pizza 2:SLICED
Pizza 1:SLICED
Pizza 0:SLICED
Pizza 4:SLICED
Pizza 3:SLICED
Pizza 2:BOXED
Pizza 1:BOXED
Pizza 0:BOXED
Pizza 4:BOXED
Pizza 3:BOXED
1739
</code></pre><p>现在，我们制作五个披萨的时间与制作单个披萨的时间就差不多了。 尝试删除标记为[1] 的行后，你会发现它花费的时间是原来的五倍。 你还可以尝试将 <strong>QUANTITY</strong> 更改为 4、8、10、16 和 17，看看会有什么不同，并猜猜看为什么会这样。</p><p><strong>PizzaStreams</strong> 类产生的每个并行流在它的<code>forEach()</code>内完成所有工作，如果我们将其各个步骤用映射的方式一步一步处理，情况会有所不同吗？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/PizzaParallelSteps.java
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>PizzaParallelSteps</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>QUANTITY</span> <span class=o>=</span> <span class=mi>5</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Timer</span> <span class=n>timer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Timer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>QUANTITY</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>parallel</span><span class=o>()</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>roll</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>sauce</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>cheese</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>toppings</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>bake</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>slice</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>box</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>za</span> <span class=o>-&gt;</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>za</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>Pizza 2: ROLLED
Pizza 0: ROLLED
Pizza 1: ROLLED
Pizza 4: ROLLED
Pizza 3: ROLLED
Pizza 1: SAUCED
Pizza 0: SAUCED
Pizza 2: SAUCED
Pizza 3: SAUCED
Pizza 4: SAUCED
Pizza 1: CHEESED
Pizza 0: CHEESED
Pizza 2: CHEESED
Pizza 3: CHEESED
Pizza 4: CHEESED
Pizza 0: TOPPED
Pizza 2: TOPPED
Pizza 1: TOPPED
Pizza 3: TOPPED
Pizza 4: TOPPED
Pizza 1: BAKED
Pizza 2: BAKED
Pizza 0: BAKED
Pizza 4: BAKED
Pizza 3: BAKED
Pizza 0: SLICED
Pizza 2: SLICED
Pizza 1: SLICED
Pizza 3: SLICED
Pizza 4: SLICED
Pizza 1: BOXED
Pizza1: complete
Pizza 2: BOXED
Pizza 0: BOXED
Pizza2: complete
Pizza0: complete
Pizza 3: BOXED
Pizza 4: BOXED
Pizza4: complete
Pizza3: complete
1738
</code></pre><p>答案是“否”，事后看来这并不奇怪，因为每个披萨都需要按顺序执行步骤。因此，没法通过分步执行操作来进一步提高速度，就像上文的 <code>PizzaParallelSteps.java</code> 里面展示的一样。</p><p>我们可以使用 <strong>CompletableFutures</strong> 重写这个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// concurrent/CompletablePizza.java
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.concurrent.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.stream.*</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>onjava.Timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CompletablePizza</span><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>QUANTITY</span> <span class=o>=</span> <span class=mi>5</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Pizza</span><span class=o>&gt;</span> <span class=nf>makeCF</span><span class=o>(</span><span class=n>Pizza</span> <span class=n>za</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>CompletableFuture</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>completedFuture</span><span class=o>(</span><span class=n>za</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>roll</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>sauce</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>cheese</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>toppings</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>bake</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>slice</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>thenApplyAsync</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=n>box</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>show</span><span class=o>(</span><span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Pizza</span><span class=o>&gt;</span> <span class=n>cf</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>cf</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>RuntimeException</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>Timer</span> <span class=n>timer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Timer</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Pizza</span><span class=o>&gt;&gt;</span> <span class=n>pizzas</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>QUANTITY</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>Pizza</span><span class=o>::</span><span class=k>new</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>CompletablePizza</span><span class=o>::</span><span class=n>makeCF</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>pizzas</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>CompletablePizza</span><span class=o>::</span><span class=n>show</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>timer</span><span class=o>.</span><span class=na>duration</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>169
Pizza 0: ROLLED
Pizza 1: ROLLED
Pizza 2: ROLLED
Pizza 4: ROLLED
Pizza 3: ROLLED
Pizza 1: SAUCED
Pizza 0: SAUCED
Pizza 2: SAUCED
Pizza 4: SAUCED
Pizza 3: SAUCED
Pizza 0: CHEESED
Pizza 4: CHEESED
Pizza 1: CHEESED
Pizza 2: CHEESED
Pizza 3: CHEESED
Pizza 0: TOPPED
Pizza 4: TOPPED
Pizza 1: TOPPED
Pizza 2: TOPPED
Pizza 3: TOPPED
Pizza 0: BAKED
Pizza 4: BAKED
Pizza 1: BAKED
Pizza 3: BAKED
Pizza 2: BAKED
Pizza 0: SLICED
Pizza 4: SLICED
Pizza 1: SLICED
Pizza 3: SLICED
Pizza 2: SLICED
Pizza 4: BOXED
Pizza 0: BOXED
Pizza0: complete
Pizza 1: BOXED
Pizza1: complete
Pizza 3: BOXED
Pizza 2: BOXED
Pizza2: complete
Pizza3: complete
Pizza4: complete
1797
</code></pre><p>并行流和 <strong>CompletableFutures</strong> 是 Java 并发工具箱中最先进发达的技术。 你应该始终首先选择其中之一。 当一个问题很容易并行处理时，或者说，很容易把数据分解成相同的、易于处理的各个部分时，使用并行流方法处理最为合适（而如果你决定不借助它而由自己完成，你就必须撸起袖子，深入研究 <strong>Spliterator</strong> 的文档）。</p><p>而当工作的各个部分内容各不相同时，使用 <strong>CompletableFutures</strong> 是最好的选择。比起面向数据，<strong>CompletableFutures</strong> 更像是面向任务的。</p><p>对于披萨问题，结果似乎也没有什么不同。实际上，并行流方法看起来更简洁，仅出于这个原因，我认为并行流作为解决问题的首次尝试方法更具吸引力。</p><p>由于制作披萨总需要一定的时间，无论你使用哪种并发方法，你能做到的最好情况，是在制作一个披萨的相同时间内制作 n 个披萨。 在这里当然很容易看出来，但是当你处理更复杂的问题时，你就可能忘记这一点。 通常，在项目开始时进行粗略的计算，就能很快弄清楚最大可能的并行吞吐量，这可以防止你因为采取无用的加快运行速度的举措而忙得团团转。</p><p>使用 <strong>CompletableFutures</strong> 或许可以轻易地带来重大收益，但是在尝试更进一步时需要倍加小心，因为额外增加的成本和工作量会非常容易远远超出你之前拼命挤出的那一点点收益。</p><h2 id=本章小结>本章小结</h2><p>需要并发的唯一理由是“等待太多”。这也可以包括用户界面的响应速度，但是由于 Java 用于构建用户界面时并不高效，因此<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> 这仅仅意味着“你的程序运行速度还不够快”。</p><p>如果并发很容易，则没有理由拒绝并发。 正因为并发实际上很难，所以你应该仔细考虑是否值得为此付出努力，并考虑你能否以其他方式提升速度。</p><p>例如，迁移到更快的硬件（这可能比消耗程序员的时间要便宜得多）或者将程序分解成多个部分，然后在不同的机器上运行这些部分。</p><p>奥卡姆剃刀是一个经常被误解的原则。 我看过至少一部电影，他们将其定义为”最简单的解决方案是正确的解决方案“，就好像这是某种毋庸置疑的法律。实际上，这是一个准则：面对多种方法时，请先尝试需要最少假设的方法。 在编程世界中，这已演变为“尝试可能可行的最简单的方法”。当你了解了特定工具的知识时——就像你现在了解了有关并发性的知识一样，你可能会很想使用它，或者提前规定你的解决方案必须能够“速度飞快”，从而来证明从一开始就进行并发设计是合理的。但是，我们的奥卡姆剃刀编程版本表示你应该首先尝试最简单的方法（这种方法开发起来也更便宜），然后看看它是否足够好。</p><p>由于我出身于底层学术背景（物理学和计算机工程），所以我很容易想到所有小轮子转动的成本。我确定使用最简单的方法不够快的场景出现的次数已经数不过来了，但是尝试后却发现它实际上绰绰有余。</p><h3 id=缺点>缺点</h3><p>并发编程的主要缺点是：</p><ol><li><p>在线程等待共享资源时会降低速度。</p></li><li><p>线程管理产生额外 CPU 开销。</p></li><li><p>糟糕的设计决策带来无法弥补的复杂性。</p></li><li><p>诸如饥饿，竞速，死锁和活锁（多线程各自处理单个任务而整体却无法完成）之类的问题。</p></li><li><p>跨平台的不一致。 通过一些示例，我发现了某些计算机上很快出现的竞争状况，而在其他计算机上却没有。 如果你在后者上开发程序，则在分发程序时可能会感到非常惊讶。</p></li></ol><p>另外，并发的应用是一门艺术。 Java 旨在允许你创建尽可能多的所需要的对象来解决问题——至少在理论上是这样。<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> 但是，线程不是典型的对象：每个线程都有其自己的执行环境，包括堆栈和其他必要的元素，使其比普通对象大得多。 在大多数环境中，只能在内存用光之前创建数千个 <strong>Thread</strong> 对象。通常，你只需要几个线程即可解决问题，因此一般来说创建线程没有什么限制，但是对于某些设计而言，它会成为一种约束，可能迫使你使用完全不同的方案。</p><h3 id=共享内存陷阱>共享内存陷阱</h3><p>并发性的主要困难之一是因为可能有多个任务共享一个资源（例如对象中的内存），并且你必须确保多个任务不会同时读取和更改该资源。</p><p>我花了多年的时间研究并发。 我了解到你永远无法相信使用共享内存并发的程序可以正常工作。 你可以轻易发现它是错误的，但永远无法证明它是正确的。 这是众所周知的并发原则之一。<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup></p><p>我遇到了许多人，他们对编写正确的线程程序的能力充满信心。 我偶尔开始认为我也可以做好。 对于一个特定的程序，我最初是在只有单个 CPU 的机器上编写的。 那时我能够说服自己该程序是正确的，因为我以为我对 Java 工具很了解。 而且在我的单 CPU 计算机上也没有失败。而到了具有多个 CPU 的计算机，程序出现问题不能运行后，我感到很惊讶，但这还只是众多问题中的一个而已。 这不是 Java 的错； “写一次，到处运行”，在单核与多核计算机间无法扩展到并发编程领域。这是并发编程的基本问题。 实际上你可以在单 CPU 机器上发现一些并发问题，但是在多线程实际上真的在并行运行的多 CPU 机器上，就会出现一些其他问题。</p><p>再举一个例子，哲学家就餐的问题可以很容易地进行调整，因此几乎不会产生死锁，这会给你一种一切都棒极了的印象。当涉及到共享内存并发编程时，你永远不应该对自己的编程能力变得过于自信。</p><h3 id=this-albatross-is-big>This Albatross is Big</h3><p>如果你对 Java 并发感到不知所措，那说明你身处在一家出色的公司里。你可以访问 <strong>Thread</strong> 类的<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html target=_blank rel=noopener>Javadoc</a> 页面， 看一下哪些方法现在是 <strong>Deprecated</strong> （废弃的）。这些是 Java 语言设计者犯过错的地方，因为他们在设计语言时对并发性了解不足。</p><p>事实证明，在 Java 的后续版本中添加的许多库解决方案都是无效的，甚至是无用的。 幸运的是，Java 8 中的并行 <strong>Streams</strong> 和 <strong>CompletableFutures</strong> 都非常有价值。但是当你使用旧代码时，仍然会遇到旧的解决方案。</p><p>在本书的其他地方，我谈到了 Java 的一个基本问题：每个失败的实验都永远嵌入在语言或库中。 Java 并发强调了这个问题。尽管有不少错误，但错误并不是那么多，因为有很多不同的尝试方法来解决问题。 好的方面是，这些尝试产生了更好，更简单的设计。 不利之处在于，在找到好的方法之前，你很容易迷失于旧的设计中。</p><h3 id=其他类库>其他类库</h3><p>本章重点介绍了相对安全易用的并行工具流和 <strong>CompletableFutures</strong> ，并且仅涉及 Java 标准库中一些更细粒度的工具。 为避免你不知所措，我没有介绍你可能实际在实践中使用的某些库。我们使用了几个 <strong>Atomic</strong> （原子）类，<strong>ConcurrentLinkedDeque</strong> ，<strong>ExecutorService</strong> 和 <strong>ArrayBlockingQueue</strong> 。附录：<a href=./Appendix-Low-Level-Concurrency.md>并发底层原理</a> 涵盖了其他一些内容，但是你还想探索 <strong>java.util.concurrent</strong> 的 Javadocs。 但是要小心，因为某些库组件已被新的更好的组件所取代。</p><h3 id=考虑为并发设计的语言>考虑为并发设计的语言</h3><p>通常，请谨慎地使用并发。 如果需要使用它，请尝试使用最现代的方法：并行流或 <strong>CompletableFutures</strong> 。 这些功能旨在（假设你不尝试共享内存）使你摆脱麻烦（在 Java 的世界范围内）。</p><p>如果你的并发问题变得比高级 Java 构造所支持的问题更大且更复杂，请考虑使用专为并发设计的语言，仅在需要并发的程序部分中使用这种语言是有可能的。 在撰写本文时，JVM 上最纯粹的功能语言是 Clojure（Lisp 的一种版本）和 Frege（Haskell 的一种实现）。这些使你可以在其中编写应用程序的并发部分语言，并通过 JVM 轻松地与你的主要 Java 代码进行交互。 或者，你可以选择更复杂的方法，即通过外部功能接口（FFI）将 JVM 之外的语言与另一种为并发设计的语言进行通信。<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup></p><p>你很容易被一种语言绑定，迫使自己尝试使用该语言来做所有事情。 一个常见的示例是构建 HTML / JavaScript 用户界面。 这些工具确实很难使用，令人讨厌，并且有许多库允许你通过使用自己喜欢的语言编写代码来生成这些工具（例如，<strong>Scala.js</strong> 允许你在 Scala 中完成代码）。</p><p>心理上的便利是一个合理的考虑因素。 但是，我希望我在本章（以及附录：<a href=./Appendix-Low-Level-Concurrency.md>并发底层原理 </a>）中已经表明 Java 并发是一个你可能无法逃离很深的洞。 与 Java 语言的任何其他部分相比，在视觉上检查代码同时记住所有陷阱所需要的的知识要困难得多。</p><p>无论使用特定的语言、库使得并发看起来多么简单，都要将其视为一种妖术，因为总是有东西会在你最不期望出现的时候咬你。</p><h3 id=拓展阅读>拓展阅读</h3><p>《Java Concurrency in Practice》，出自 Brian Goetz，Tim Peierls， Joshua Bloch，Joseph Bowbeer，David Holmes 和 Doug Lea (Addison Wesley，2006 年)——这些基本上就是 Java 并发世界中的名人名单了《Java Concurrency in Practice》第二版，出自 Doug Lea (Addison-Wesley，2000 年)。尽管这本书出版时间远远早于 Java 5 发布，但 Doug 的大部分工作都写入了 <strong>java.util.concurrent</strong> 库。因此，这本书对于全面理解并发问题至关重要。 它超越了 Java，讨论了跨语言和技术的并发编程。 尽管它在某些地方可能很钝，但值得多次重读（最好是在两个月之间进行消化）。 道格（Doug）是世界上为数不多的真正了解并发编程的人之一，因此这是值得的。</p><div style=page-break-after:always></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>例如,Eric-Raymond 在“Unix 编程艺术”（Addison-Wesley，2004）中提出了一个很好的案例。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>可以说，试图将并发性用于后续语言是一种注定要失败的方法，但你必须得出自己的结论&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>有人谈论在 Java——10 中围绕泛型做一些类似的基本改进，这将是非常令人难以置信的。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>这是一种有趣的，虽然不一致的方法。通常，我们期望在公共接口上使用显式类表示不同的行为&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>不，永远不会有纯粹的功能性 Java。我们所能期望的最好的是一种在 JVM 上运行的全新语言。&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>当两个任务能够更改其状态以使它们不会被阻止但它们从未取得任何有用的进展时，你也可以使用活动锁。&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>而不是超线程；通常每个内核有两个超线程，并且在询问内核数量时，本书所使用的 Java 版本会报告超线程的数量。超线程产生了更快的上下文切换，但是只有实际的内核才真的工作，而不是超线程。 ↩&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>库就在那里用于调用，而语言本身就被设计用于此目的，但实际上它很少发生，以至于可以说”没有“。↩&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>举例来说，如果没有 Flyweight 设计模式，在工程中创建数百万个对象用于有限元分析可能在 Java 中不可行。↩&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>在科学中，虽然从来没有一种理论被证实过，但是一种理论必须是可证伪的才有意义。而对于并发性，我们大部分时间甚至都无法得到这种可证伪性。↩&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>尽管 <strong>Go</strong> 语言显示了 FFI 的前景，但在撰写本文时，它并未提供跨所有平台的解决方案。&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>上一页</div><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/23-annotations/ rel=next>23-Annotations</a></div><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/java-series/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/on-java-8/25-patterns/ rel=prev>25-Patterns</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>