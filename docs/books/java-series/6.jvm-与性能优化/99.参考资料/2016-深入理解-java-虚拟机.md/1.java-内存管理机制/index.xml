<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>1.Java 内存管理机制 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</link><atom:link href="https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/index.xml" rel="self" type="application/rss+xml"/><description>1.Java 内存管理机制</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>1.Java 内存管理机制</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</link></image><item><title>00-Java 内存区域详解</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/00-java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/00-java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</guid><description>&lt;h1 id="java-内存区域详解">Java 内存区域详解&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#java-%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%e8%af%a6%e8%a7%a3">Java 内存区域详解&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#jvm-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%9a%84%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f">JVM 运行时的数据区域&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8">程序计数器&lt;/a>&lt;/li>
&lt;li>&lt;a href="#java-%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88">Java 虚拟机栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88">本地方法栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="#java-%e5%a0%86">Java 堆&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%96%b9%e6%b3%95%e5%8c%ba">方法区&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98">直接内存&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#hotspot-%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%a0%86%e4%b8%ad%e7%9a%84%e5%af%b9%e8%b1%a1">HotSpot 虚拟机堆中的对象&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%88%9b%e5%bb%ba%e9%81%87%e5%88%b0%e4%b8%80%e6%9d%a1-new-%e6%8c%87%e4%bb%a4%e6%97%b6">对象的创建（遇到一条 new 指令时）&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80">对象的内存布局&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e8%ae%bf%e9%97%ae">对象的访问&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%8f%a5%e6%9f%84%e8%ae%bf%e9%97%ae">句柄访问&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e7%9b%b4%e6%8e%a5%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae">直接指针访问&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="jvm-运行时的数据区域">JVM 运行时的数据区域&lt;/h2>
&lt;p>首先获取一个直观的认识：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/JVM%e8%bf%90%e8%a1%8c%e6%97%b6%e7%9a%84%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f.png" alt="JVM运行时的数据区域.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>总共也就这么 5 个区（直接内存不属于 JVM 运行时数据区的一部分），除了程序计数器其他的地方都有可能出现 OOM (OutOfMemoryError)，其中像是程序计数器和两个栈（Java 虚拟机栈 &amp;amp; 本地方法栈）都是每个线程要有一个的，所以肯定是线程隔离的。而其他 2 个区就是线程共享的了，也就是说，如果有多个线程要同时访问这两个区的数据，是会出现线程安全问题的。接下来，我们将对这些区域进行详细的介绍。&lt;/p>
&lt;h3 id="程序计数器">程序计数器&lt;/h3>
&lt;ul>
&lt;li>当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来确定下一条要执行的字节码指令的位置&lt;/li>
&lt;li>执行 Java 方法和 native 方法时的区别：
&lt;ul>
&lt;li>执行 Java 方法时：记录虚拟机正在执行的字节码指令地址；&lt;/li>
&lt;li>执行 native 方法时：无定义；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>是 5 个区域中唯一不会出现 OOM 的区域。&lt;/li>
&lt;/ul>
&lt;h3 id="java-虚拟机栈">Java 虚拟机栈&lt;/h3>
&lt;ul>
&lt;li>Java 方法执行的内存模型，每个方法执行的过程，就是它所对应的栈帧在虚拟机栈中入栈到出栈的过程；&lt;/li>
&lt;li>服务于 Java 方法；&lt;/li>
&lt;li>可能抛出的异常：
&lt;ul>
&lt;li>OutOfMemoryError（在虚拟机栈可以动态扩展的情况下，扩展时无法申请到足够的内存）；&lt;/li>
&lt;li>StackOverflowError（线程请求的栈深度 &amp;gt; 虚拟机所允许的深度）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>虚拟机参数设置：&lt;code>-Xss&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h3 id="本地方法栈">本地方法栈&lt;/h3>
&lt;ul>
&lt;li>服务于 native 方法；&lt;/li>
&lt;li>可能抛出的异常：与 Java 虚拟机栈一样。&lt;/li>
&lt;/ul>
&lt;h3 id="java-堆">Java 堆&lt;/h3>
&lt;ul>
&lt;li>唯一的目的：存放对象实例；&lt;/li>
&lt;li>垃圾收集器管理的主要区域；&lt;/li>
&lt;li>可以处于物理上不连续的内存空间中；&lt;/li>
&lt;li>可能抛出的异常：
&lt;ul>
&lt;li>OutOfMemoryError（堆中没有内存可以分配给新创建的实例，并且堆也无法再继续扩展了）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>虚拟机参数设置：
&lt;ul>
&lt;li>最大值：&lt;code>-Xmx&lt;/code>&lt;/li>
&lt;li>最小值：&lt;code>-Xms&lt;/code>&lt;/li>
&lt;li>两个参数设置成相同的值可避免堆自动扩展。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="方法区">方法区&lt;/h3>
&lt;ul>
&lt;li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
&lt;ul>
&lt;li>类信息：即 Class 类，如类名、访问修饰符、常量池、字段描述、方法描述等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>垃圾收集行为在此区域很少发生；
&lt;ul>
&lt;li>不过也不能不清理，对于经常动态生成大量 Class 的应用，如 Spring 等，需要特别注意类的回收状况。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行时常量池也是方法区的一部分；
&lt;ul>
&lt;li>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量（就是代码中定义的 static final 常量）和符号引用，这部分信息就存储在运行时常量池中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可能抛出的异常：
&lt;ul>
&lt;li>OutOfMemoryError（方法区无法满足内存分配需求时）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="直接内存">直接内存&lt;/h3>
&lt;ul>
&lt;li>JDK 1.4 的 NIO 类可以使用 native 函数库直接分配堆外内存，这是一种基于通道与缓冲区的 I/O 方式，它在 Java 堆中存储一个 DirectByteBuffer 对象作为堆外内存的引用，这样就可以对堆外内存进行操作了。因为可以避免 Java 堆和 Native 堆之间来回复制数据，在一些场景可以带来显著的性能提高。&lt;/li>
&lt;li>虚拟机参数设置：&lt;code>-XX:MaxDirectMemorySize&lt;/code>
&lt;ul>
&lt;li>默认等于 Java 堆最大值，即 &lt;code>-Xmx&lt;/code> 指定的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将直接内存放在这里讲解的原因是它也可能会出现 OutOfMemoryError；
&lt;ul>
&lt;li>服务器管理员在配置 JVM 参数时，会根据机器的实际内存设置 &lt;code>-Xmx&lt;/code> 等信息，但经常会忽略直接内存（默认等于 &lt;code>-Xmx&lt;/code> 设置值），这可能会使得各个内存区域的总和大于物理内存限制，从而导致动态扩展时出现 OOM。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="hotspot-虚拟机堆中的对象">HotSpot 虚拟机堆中的对象&lt;/h2>
&lt;p>这一小节将对 JVM 对 Java 堆中的对象的创建、布局和访问的全过程进行讲解。&lt;/p>
&lt;h3 id="对象的创建遇到一条-new-指令时">对象的创建（遇到一条 new 指令时）&lt;/h3>
&lt;ol>
&lt;li>检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先把这个类加载进内存；&lt;/li>
&lt;li>类加载检查通过后，虚拟机将为新对象分配内存，此时已经可以确定存储这个对象所需的内存大小；&lt;/li>
&lt;li>在堆中为新对象分配可用内存；&lt;/li>
&lt;li>将分配到的内存初始化；&lt;/li>
&lt;li>设置对象头中的数据；&lt;/li>
&lt;li>此时，从虚拟机的角度看，对象已经创建好了，但从 Java 程序的角度看，对象创建才刚刚开始，构造函数还没有执行。&lt;/li>
&lt;/ol>
&lt;p>第 3 步，在堆中为新对象分配可用内存时，会涉及到以下两个问题：&lt;/p>
&lt;p>&lt;strong>如何在堆中为新对象划分可用的内存？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>指针碰撞（内存分配规整）
&lt;ul>
&lt;li>用过的内存放一边，没用过的内存放一边，中间用一个指针分隔；&lt;/li>
&lt;li>分配内存的过程就是将指针向没用过的内存那边移动所需的长度；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>空闲列表（内存分配不规整）
&lt;ul>
&lt;li>维护一个列表，记录哪些内存块是可用的；&lt;/li>
&lt;li>分配内存时，从列表上选取一块足够大的空间分给对象，并更新列表上的记录；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>如何处理多线程创建对象时，划分内存的指针的同步问题？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对分配内存空间的动作进行同步处理（CAS）；&lt;/li>
&lt;li>把内存分配动作按照线程划分在不同的空间之中进行；
&lt;ul>
&lt;li>每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）；&lt;/li>
&lt;li>哪个线程要分配内存就在哪个线程的 TLAB 上分配，TLAB 用完需要分配新的 TLAB 时，才需要同步锁定；&lt;/li>
&lt;li>通过 &lt;code>-XX:+/-UseTLAB&lt;/code> 参数设定是否使用 TLAB。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="对象的内存布局">对象的内存布局&lt;/h3>
&lt;ul>
&lt;li>对象头：
&lt;ul>
&lt;li>第一部分：存储对象自身运行时的数据，HashCode、GC 分代年龄等（Mark Word）；&lt;/li>
&lt;li>第二部分：类型指针，指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例（HotSpot 采用的是直接指针的方式访问对象的）；&lt;/li>
&lt;li>如果是个数组对象，对象头中还有一块用于记录数组长度的数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实例数据：
&lt;ul>
&lt;li>默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，相同宽度的字段会被分配在一起，除了 oops，其他的长度由长到短；&lt;/li>
&lt;li>默认分配顺序下，父类字段会被分配在子类字段前面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>注：HotSpot VM 要求对象的起始地址必须是 8 字节的整数倍，所以不够要补齐。&lt;/em>&lt;/p>
&lt;h3 id="对象的访问">对象的访问&lt;/h3>
&lt;p>Java 程序需要通过虚拟机栈上的 reference 数据来操作堆上的具体对象，reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：句柄访问和直接指针访问。&lt;/p>
&lt;h4 id="句柄访问">句柄访问&lt;/h4>
&lt;p>句柄访问会在 Java 堆中划分一块内存作为句柄池，每一个句柄存放着到对象实例数据和对象类型数据的指针。&lt;/p>
&lt;p>优势：对象移动的时候（这在垃圾回收时十分常见）只需改变句柄池中对象实例数据的指针，不需要修改 reference 本身。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%af%b9%e8%b1%a1%e7%9a%84%e8%ae%bf%e9%97%ae%e5%ae%9a%e4%bd%8d_%e5%8f%a5%e6%9f%84%e8%ae%bf%e9%97%ae.png" alt="对象的访问定位_句柄访问.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h4 id="直接指针访问">直接指针访问&lt;/h4>
&lt;p>直接指针访问方式在 Java 堆对象的实例数据中存放了一个指向对象类型数据的指针，在 HotSpot 中，这个指针会被存放在对象头中。&lt;/p>
&lt;p>优势：减少了一次指针定位对象实例数据的开销，速度更快。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%af%b9%e8%b1%a1%e7%9a%84%e8%ae%bf%e9%97%ae%e5%ae%9a%e4%bd%8d_%e7%9b%b4%e6%8e%a5%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae.png" alt="对象的访问定位_直接指针访问.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>01-OOM 异常</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/01-oom-%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/01-oom-%E5%BC%82%E5%B8%B8/</guid><description>&lt;h1 id="oom-异常-outofmemoryerror">OOM 异常 (OutOfMemoryError)&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#oom-%E5%BC%82%E5%B8%B8-outofmemoryerror">OOM 异常 (OutOfMemoryError)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#java-%E5%A0%86%E6%BA%A2%E5%87%BA">Java 堆溢出&lt;/a>&lt;/li>
&lt;li>&lt;a href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA">Java 虚拟机栈和本地方法栈溢出&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA">方法区和运行时常量池溢出&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">直接内存溢出&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="java-堆溢出">Java 堆溢出&lt;/h2>
&lt;ul>
&lt;li>出现标志：&lt;code>java.lang.OutOfMemoryError: Java heap space&lt;/code>&lt;/li>
&lt;li>解决方法：
&lt;ul>
&lt;li>先通过内存映像分析工具分析 Dump 出来的堆转储快照，确认内存中的对象是否是必要的，即分清楚是出现了内存泄漏还是内存溢出；&lt;/li>
&lt;li>如果是内存泄漏，通过工具查看泄漏对象到 GC Root 的引用链，定位出泄漏的位置；&lt;/li>
&lt;li>如果不存在泄漏，检查虚拟机堆参数（-Xmx 和 -Xms）是否可以调大，检查代码中是否有哪些对象的生命周期过长，尝试减少程序运行期的内存消耗。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>虚拟机参数：
&lt;ul>
&lt;li>&lt;code>-XX:HeapDumpOnOutOfMemoryError&lt;/code>：让虚拟机在出现内存泄漏异常时 Dump 出当前的内存堆转储快照用于事后分析。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="java-虚拟机栈和本地方法栈溢出">Java 虚拟机栈和本地方法栈溢出&lt;/h2>
&lt;ul>
&lt;li>单线程下，栈帧过大、虚拟机容量过小都不会导致 OutOfMemoryError，只会导致 StackOverflowError（栈会比内存先爆掉），一般多线程才会出现 OutOfMemoryError，因为线程本身要占用内存；&lt;/li>
&lt;li>如果是多线程导致的 OutOfMemoryError，在不能减少线程数或更换 64 位虚拟机的情况，只能通过减少最大堆和减少栈容量来换取更多的线程；
&lt;ul>
&lt;li>这个调节思路和 Java 堆出现 OOM 正好相反，Java 堆出现 OOM 要调大堆内存的设置值，而栈出现 OOM 反而要调小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出&lt;/h2>
&lt;ul>
&lt;li>测试思路：产生大量的类去填满方法区，直到溢出；&lt;/li>
&lt;li>在经常动态生成大量 Class 的应用中，如 Spring 框架（使用 CGLib 字节码技术），方法区溢出是一种常见的内存溢出，要特别注意类的回收状况。&lt;/li>
&lt;/ul>
&lt;h2 id="直接内存溢出">直接内存溢出&lt;/h2>
&lt;ul>
&lt;li>出现特征：Heap Dump 文件中看不见明显异常，程序中直接或间接用了 NIO；&lt;/li>
&lt;li>虚拟机参数：&lt;code>-XX:MaxDirectMemorySize&lt;/code>，如果不指定，则和 &lt;code>-Xmx&lt;/code> 一样。&lt;/li>
&lt;/ul></description></item><item><title>02-垃圾收集(GC)</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86gc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86gc/</guid><description>&lt;h1 id="垃圾收集-gc">垃圾收集 (GC)&lt;/h1>
&lt;p>垃圾收集（Garbage Collection，GC），它的任务是解决以下 3 件问题：&lt;/p>
&lt;ul>
&lt;li>哪些内存需要回收？&lt;/li>
&lt;li>什么时候回收？&lt;/li>
&lt;li>如何回收？&lt;/li>
&lt;/ul>
&lt;p>其中第一个问题很好回答，在 Java 中，GC 主要发生在 Java 堆和方法区中，对于后两个问题，我们将在之后的内容中进行讨论，并介绍 HotSpot 的 7 个垃圾收集器。&lt;/p>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86-gc">垃圾收集 (GC)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%88%a4%e6%96%ad%e5%af%b9%e8%b1%a1%e7%9a%84%e7%94%9f%e6%ad%bb">判断对象的生死&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%88%a4%e6%96%ad%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e5%8f%af%e7%94%a8%e7%9a%84%e7%ae%97%e6%b3%95">判断对象是否可用的算法&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e7%ae%97%e6%b3%95">引用计数算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95%e4%b8%bb%e6%b5%81">可达性分析算法（主流）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e5%9b%9b%e7%a7%8d%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b">四种引用类型&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%ae%a3%e5%91%8a%e5%af%b9%e8%b1%a1%e6%ad%bb%e4%ba%a1%e7%9a%84%e4%b8%a4%e6%ac%a1%e6%a0%87%e8%ae%b0%e8%bf%87%e7%a8%8b">宣告对象死亡的两次标记过程&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%96%b9%e6%b3%95%e5%8c%ba%e7%9a%84%e5%9b%9e%e6%94%b6">方法区的回收&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95">垃圾收集算法&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%9f%ba%e7%a1%80%e6%a0%87%e8%ae%b0---%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95">基础：标记 - 清除算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e8%a7%a3%e5%86%b3%e6%95%88%e7%8e%87%e9%97%ae%e9%a2%98%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95">解决效率问题：复制算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e8%a7%a3%e5%86%b3%e7%a9%ba%e9%97%b4%e7%a2%8e%e7%89%87%e9%97%ae%e9%a2%98%e6%a0%87%e8%ae%b0---%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95">解决空间碎片问题：标记 - 整理算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e8%bf%9b%e5%8c%96%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95">进化：分代收集算法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#hotspot-%e4%b8%ad-gc-%e7%ae%97%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0">HotSpot 中 GC 算法的实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="#7-%e4%b8%aa%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8">7 个垃圾收集器&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#serial--parnew-%e6%90%ad%e9%85%8d-serial-old-%e6%94%b6%e9%9b%86%e5%99%a8">Serial / ParNew 搭配 Serial Old 收集器&lt;/a>&lt;/li>
&lt;li>&lt;a href="#parallel-%e6%90%ad%e9%85%8d-parallel-scavenge-%e6%94%b6%e9%9b%86%e5%99%a8">Parallel 搭配 Parallel Scavenge 收集器&lt;/a>&lt;/li>
&lt;li>&lt;a href="#cms-%e6%94%b6%e9%9b%86%e5%99%a8">CMS 收集器&lt;/a>&lt;/li>
&lt;li>&lt;a href="#g1-%e6%94%b6%e9%9b%86%e5%99%a8">G1 收集器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#gc-%e6%97%a5%e5%bf%97%e8%a7%a3%e8%af%bb">GC 日志解读&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="判断对象的生死">判断对象的生死&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%88%a4%e6%96%ad%e5%af%b9%e8%b1%a1%e7%9a%84%e7%94%9f%e6%ad%bb.png" alt="判断对象的生死.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>什么时候回收对象？当然是这个对象再也不会被用到的时候回收。所以要想解决 “什么时候回收？” 这个问题，我们要先能判断一个对象什么时候什么时候真正的 “死” 掉了，判断对象是否可用主要有以下两种方法。&lt;/p>
&lt;h3 id="判断对象是否可用的算法">判断对象是否可用的算法&lt;/h3>
&lt;h4 id="引用计数算法">引用计数算法&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>算法描述：&lt;/strong>
&lt;ul>
&lt;li>给对象添加一个引用计数器；&lt;/li>
&lt;li>每有一个地方引用它，计数器加 1；&lt;/li>
&lt;li>引用失效时，计数器减 1；&lt;/li>
&lt;li>计数器值为 0 的对象不再可用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>缺点：&lt;/strong>
&lt;ul>
&lt;li>很难解决循环引用的问题。即 &lt;code>objA.instance = objB; objB.instance = objA;&lt;/code>，objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="可达性分析算法主流">可达性分析算法（主流）&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>算法描述：&lt;/strong>
&lt;ul>
&lt;li>从 &amp;ldquo;GC Root&amp;rdquo; 对象作为起点开始向下搜索，走过的路径称为引用链（Reference Chain）；&lt;/li>
&lt;li>从 &amp;ldquo;GC Root&amp;rdquo; 开始，不可达的对象被判为不可用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Java 中可作为 “GC Root” 的对象：&lt;/strong>
&lt;ul>
&lt;li>栈中（本地变量表中的 reference）
&lt;ul>
&lt;li>虚拟机栈中，栈帧中的本地变量表引用的对象；&lt;/li>
&lt;li>本地方法栈中，JNI 引用的对象（native 方法）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>方法区中
&lt;ul>
&lt;li>类的静态属性引用的对象；&lt;/li>
&lt;li>常量引用的对象；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。&lt;/p>
&lt;h3 id="四种引用类型">四种引用类型&lt;/h3>
&lt;p>JDK 1.2 后，Java 中才有了后 3 种引用的实现。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>强引用：&lt;/strong> 像 &lt;code>Object obj = new Object()&lt;/code> 这种，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。&lt;/li>
&lt;li>&lt;strong>软引用：&lt;/strong> 用来引用还存在但非必须的对象。对于软引用对象，在 OOM 前，虚拟机会把这些对象列入回收范围中进行第二次回收，如果这次回收后，内存还是不够用，就 OOM。实现类：&lt;code>SoftReference&lt;/code>。&lt;/li>
&lt;li>&lt;strong>弱引用：&lt;/strong> 被弱引用引用的对象只能生存到下一次垃圾收集前，一旦发生垃圾收集，被弱引用所引用的对象就会被清掉。实现类：&lt;code>WeakReference&lt;/code>。&lt;/li>
&lt;li>&lt;strong>虚引用：&lt;/strong> 幽灵引用，对对象没有半毛钱影响，甚至不能用来取得一个对象的实例。它唯一的用途就是：当被一个虚引用引用的对象被回收时，系统会收到这个对象被回收了的通知。实现类：&lt;code>PhantomReference&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h3 id="宣告对象死亡的两次标记过程">宣告对象死亡的两次标记过程&lt;/h3>
&lt;ul>
&lt;li>当发现对象不可达后，该对象被第一次标记，并进行是否有必要执行 &lt;code>finalize()&lt;/code> 方法的判断；
&lt;ul>
&lt;li>不需要执行：对象没有覆盖 &lt;code>finalize()&lt;/code> 方法，或者 &lt;code>finalize()&lt;/code> 方法已被执行过（&lt;code>finalize()&lt;/code> 只被执行一次）；&lt;/li>
&lt;li>需要执行：将该对象放置在一个队列中，稍后由一个虚拟机自动创建的低优先级线程执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>finalize()&lt;/code> 方法是对象逃脱死亡的最后一次机会，不过虚拟机不保证等待 &lt;code>finalize()&lt;/code> 方法执行结束，也就是说，虚拟机只触发 &lt;code>finalize()&lt;/code> 方法的执行，如果这个方法要执行超久，那么虚拟机并不等待它执行结束，所以最好不要用这个方法。&lt;/li>
&lt;li>&lt;code>finalize()&lt;/code> 方法能做的，try-finally 都能做，所以忘了这个方法吧！&lt;/li>
&lt;/ul>
&lt;h3 id="方法区的回收">方法区的回收&lt;/h3>
&lt;p>永久代的 GC 主要回收：&lt;strong>废弃常量&lt;/strong> 和 &lt;strong>无用的类&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>废弃常量：例如一个字符串 &amp;ldquo;abc&amp;rdquo;，当没有任何引用指向 &amp;ldquo;abc&amp;rdquo; 时，它就是废弃常量了。&lt;/li>
&lt;li>无用的类：同时满足以下 3 个条件的类。
&lt;ul>
&lt;li>该类的所有实例已被回收，Java 堆中不存在该类的任何实例；&lt;/li>
&lt;li>加载该类的 Classloader 已被回收；&lt;/li>
&lt;li>该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="垃圾收集算法">垃圾收集算法&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95.png" alt="垃圾收集算法.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="基础标记---清除算法">基础：标记 - 清除算法&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>算法描述：&lt;/strong>
&lt;ul>
&lt;li>先标记出所有需要回收的对象（图中深色区域）；&lt;/li>
&lt;li>标记完后，统一回收所有被标记对象（留下狗啃似的可用内存区域……）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>不足：&lt;/strong>
&lt;ul>
&lt;li>效率问题：标记和清理两个过程的效率都不高。&lt;/li>
&lt;li>空间碎片问题：标记清除后会产生大量不连续的内存碎片，导致以后为较大的对象分配内存时找不到足够的连续内存，会提前触发另一次 GC。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4GC%e7%ae%97%e6%b3%95.png" alt="标记清除GC算法.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="解决效率问题复制算法">解决效率问题：复制算法&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>算法描述：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>将可用内存分为大小相等的两块，每次只使用其中一块；&lt;/li>
&lt;li>当一块内存用完时，将这块内存上还存活的对象复制到另一块内存上去，将这一块内存全部清理掉。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不足：&lt;/strong> 可用内存缩小为原来的一半，适合 GC 过后只有少量对象存活的新生代。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>节省内存的方法：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>新生代中的对象 98% 都是朝生夕死的，所以不需要按照 1:1 的比例对内存进行划分；&lt;/li>
&lt;li>把内存划分为：
&lt;ul>
&lt;li>1 块比较大的 Eden 区；&lt;/li>
&lt;li>2 块较小的 Survivor 区；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每次使用 Eden 区和 1 块 Survivor 区；&lt;/li>
&lt;li>回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空；&lt;/li>
&lt;li>JVM 参数设置：&lt;code>-XX:SurvivorRatio=8&lt;/code> 表示 &lt;code>Eden 区大小 / 1 块 Survivor 区大小 = 8&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%a4%8d%e5%88%b6GC%e7%ae%97%e6%b3%95.png" alt="复制GC算法.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="解决空间碎片问题标记---整理算法">解决空间碎片问题：标记 - 整理算法&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>算法描述：&lt;/strong>
&lt;ul>
&lt;li>标记方法与 “标记 - 清除算法” 一样；&lt;/li>
&lt;li>标记完后，将所有存活对象向一端移动，然后直接清理掉边界以外的内存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>不足：&lt;/strong> 存在效率问题，适合老年代。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86GC%e7%ae%97%e6%b3%95.png" alt="标记整理GC算法.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="进化分代收集算法">进化：分代收集算法&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>新生代：&lt;/strong> GC 过后只有少量对象存活 —— &lt;strong>复制算法&lt;/strong>&lt;/li>
&lt;li>&lt;strong>老年代：&lt;/strong> GC 过后对象存活率高 —— &lt;strong>标记 - 整理算法&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="hotspot-中-gc-算法的实现">HotSpot 中 GC 算法的实现&lt;/h2>
&lt;p>通过前两小节对于判断对象生死和垃圾收集算法的介绍，我们已经对虚拟机是进行 GC 的流程有了一个大致的了解。但是，在 HotSpot 虚拟机中，高效的实现这些算法也是一个需要考虑的问题。所以，接下来，我们将研究一下 HotSpot 虚拟机到底是如何高效的实现这些算法的，以及在实现中有哪些需要注意的问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/GC%e7%9a%84%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0.png" alt="GC的算法实现.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通过之前的分析，GC 算法的实现流程简单的来说分为以下两步：&lt;/p>
&lt;ol>
&lt;li>找到死掉的对象；&lt;/li>
&lt;li>把它清了。&lt;/li>
&lt;/ol>
&lt;p>想要找到死掉的对象，我们就要进行可达性分析，也就是从 GC Root 找到引用链的这个操作。&lt;/p>
&lt;p>也就是说，进行可达性分析的第一步，就是要枚举 GC Roots，这就需要虚拟机知道哪些地方存放着对象应用。如果每一次枚举 GC Roots 都需要把整个栈上位置都遍历一遍，那可就费时间了，毕竟并不是所有位置都存放在引用呀。所以为了提高 GC 的效率，HotSpot 使用了一种 OopMap 的数据结构，&lt;strong>OopMap 记录了栈上本地变量到堆上对象的引用关系&lt;/strong>，也就是说，GC 的时候就不用遍历整个栈只遍历每个栈的 OopMap 就行了。&lt;/p>
&lt;p>在 OopMap 的帮助下，HotSpot 可以快速准确的完成 GC 枚举了，不过，OopMap 也不是万年不变的，它也是需要被更新的，当内存中的对象间的引用关系发生变化时，就需要改变 OopMap 中的相应内容。可是能导致引用关系发生变化的指令非常之多，如果我们执行完一条指令就改下 OopMap，这 GC 成本实在太高了。&lt;/p>
&lt;p>因此，HotSpot 采用了一种在 “安全点” 更新 OopMap 的方法，安全点的选取既不能让 GC 等待的时间过长，也不能过于频繁增加运行负担，也就是说，我们既要让程序运行一段时间，又不能让这个时间太长。我们知道，JVM 中每条指令执行的是很快的，所以一个超级长的指令流也可能很快就执行完了，所以 &lt;strong>真正会出现 “长时间执行” 的一般是指令的复用，例如：方法调用、循环跳转、异常跳转等&lt;/strong>，虚拟机一般会将这些地方设置为安全点更新 OopMap 并判断是否需要进行 GC 操作。&lt;/p>
&lt;p>此外，在进行枚举根节点的这个操作时，为了保证准确性，我们需要在一段时间内 “冻结” 整个应用，即 Stop The World（传说中的 GC 停顿），因为如果在我们分析可达性的过程中，对象的引用关系还在变来变去，那是不可能得到正确的分析结果的。即便是在号称几乎不会发生停顿的 CMS 垃圾收集器中，枚举根节点时也是必须要停顿的。这里就涉及到了一个问题：&lt;/p>
&lt;p>&lt;strong>我们让所有线程跑到最近的安全点再停顿下来进行 GC 操作呢？&lt;/strong>&lt;/p>
&lt;p>主要有以下两种方式：&lt;/p>
&lt;ul>
&lt;li>抢先式中断：
&lt;ul>
&lt;li>先中断所有线程；&lt;/li>
&lt;li>发现有线程没中断在安全点，恢复它，让它跑到安全点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>主动式中断：&lt;/strong> (主要使用)
&lt;ul>
&lt;li>设置一个中断标记；&lt;/li>
&lt;li>每个线程到达安全点时，检查这个中断标记，选择是否中断自己。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>除此安全点之外，还有一个叫做 “安全区域” 的东西，一个一直在执行的线程可以自己 “走” 到安全点去，可是一个处于 Sleep 或者 Blocked 状态的线程是没办法自己到达安全点中断自己的，我们总不能让 GC 操作一直等着这些个 ”不执行“ 的线程重新被分配资源吧。对于这种情况，我们要依靠安全区域来解决。&lt;/p>
&lt;p>&lt;strong>安全区域是指在一段代码片段之中，引用关系不会发生变化，因此在这个区域中的任意位置开始 GC 都是安全的。&lt;/strong>&lt;/p>
&lt;p>当线程执行到安全区域时，它会把自己标识为 Safe Region，这样 JVM 发起 GC 时是不会理会这个线程的。当这个线程要离开安全区域时，它会检查系统是否在 GC 中，如果不在，它就继续执行，如果在，它就等 GC 结束再继续执行。&lt;/p>
&lt;p>本小节我们主要讲述 HotSpot 虚拟机是如何发起内存回收的，也就是如何找到死掉的对象，至于如何清掉这些个对象，HotSpot 将其交给了一堆叫做 ”GC 收集器“ 的东西，这东西又有好多种，不同的 GC 收集器的处理方式不同，适用的场景也不同，我们将在下一小节进行详细讲述。&lt;/p>
&lt;h2 id="7-个垃圾收集器">7 个垃圾收集器&lt;/h2>
&lt;p>垃圾收集器就是内存回收操作的具体实现，HotSpot 里足足有 7 种，为啥要弄这么多，因为它们各有各的适用场景。有的属于新生代收集器，有的属于老年代收集器，所以一般是搭配使用的（除了万能的 G1）。关于它们的简单介绍以及分类请见下图。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e4%bb%ac.png" alt="垃圾收集器们.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="serial--parnew-搭配-serial-old-收集器">Serial / ParNew 搭配 Serial Old 收集器&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/Serial_ParNew%e6%94%b6%e9%9b%86%e5%99%a8.jpg" alt="Serial_ParNew收集器.jpg" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Serial 收集器是虚拟机在 Client 模式下的默认新生代收集器，它的优势是简单高效，在单 CPU 模式下很牛。&lt;/p>
&lt;p>ParNew 收集器就是 Serial 收集器的多线程版本，虽然除此之外没什么创新之处，但它却是许多运行在 Server 模式下的虚拟机中的首选新生代收集器，因为除了 Serial 收集器外，只有它能和 CMS 收集器搭配使用。&lt;/p>
&lt;h3 id="parallel-搭配-parallel-scavenge-收集器">Parallel 搭配 Parallel Scavenge 收集器&lt;/h3>
&lt;p>首先，这俩货肯定是要搭配使用的，不仅仅如此，它俩还贼特别，它们的关注点与其他收集器不同，其他收集器关注于尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目的是达到一个可控的吞吐量。&lt;/p>
&lt;blockquote>
&lt;p>吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )&lt;/p>
&lt;/blockquote>
&lt;p>因此，Parallel Scavenge 收集器不管是新生代还是老年代都是多个线程同时进行垃圾收集，十分适合于应用在注重吞吐量以及 CPU 资源敏感的场合。&lt;/p>
&lt;p>可调节的虚拟机参数：&lt;/p>
&lt;ul>
&lt;li>&lt;code>-XX:MaxGCPauseMillis&lt;/code>：最大 GC 停顿的秒数；&lt;/li>
&lt;li>&lt;code>-XX:GCTimeRatio&lt;/code>：吞吐量大小，一个 0 ~ 100 的数，&lt;code>最大 GC 时间占总时间的比率 = 1 / (GCTimeRatio + 1)&lt;/code>；&lt;/li>
&lt;li>&lt;code>-XX:+UseAdaptiveSizePolicy&lt;/code>：一个开关参数，打开后就无需手工指定 &lt;code>-Xmn&lt;/code>，&lt;code>-XX:SurvivorRatio&lt;/code> 等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，自行调整。&lt;/li>
&lt;/ul>
&lt;h3 id="cms-收集器">CMS 收集器&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/CMS%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8.png" alt="CMS垃圾收集器.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/CMS%e6%94%b6%e9%9b%86%e5%99%a8%e8%bf%90%e8%a1%8c%e7%a4%ba%e6%84%8f%e5%9b%be.jpg" alt="CMS收集器运行示意图.jpg" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>参数设置：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>-XX:+UseCMSCompactAtFullCollection&lt;/code>：在 CMS 要进行 Full GC 时进行内存碎片整理（默认开启）&lt;/li>
&lt;li>&lt;code>-XX:CMSFullGCsBeforeCompaction&lt;/code>：在多少次 Full GC 后进行一次空间整理（默认是 0，即每一次 Full GC 后都进行一次空间整理）&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>关于 CMS 使用 标记 - 清除 算法的一点思考：&lt;/strong>&lt;/p>
&lt;p>之前对于 CMS 为什么要采用 标记 - 清除 算法十分的不理解，既然已经有了看起来更高级的 标记 - 整理 算法，那 CMS 为什么不用呢？最近想了想，感觉可能是这个原因，不过也不是很确定，只是个人的一种猜测。&lt;/p>
&lt;p>标记 - 整理 会将所有存活对象向一端移动，然后直接清理掉边界以外的内存。这就意味着需要一个指针来维护这个分隔存活对象和无用空间的点，而我们知道 CMS 是并发清理的，虽然我们启动了多个线程进行垃圾回收，不过如果使用 标记 - 整理 算法，为了保证线程安全，在整理时要对那个分隔指针加锁，保证同一时刻只有一个线程能修改它，&lt;strong>加锁的这一过程相当于将并行的清理过程变成了串行的，也就失去了并行清理的意义了。&lt;/strong>&lt;/p>
&lt;p>所以，CMS 采用了 标记 - 清除 算法。&lt;/p>
&lt;/blockquote>
&lt;h3 id="g1-收集器">G1 收集器&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/G1%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8.png" alt="G1垃圾收集器.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/G1%e6%94%b6%e9%9b%86%e5%99%a8%e8%bf%90%e8%a1%8c%e7%a4%ba%e6%84%8f%e5%9b%be.jpg" alt="G1收集器运行示意图.jpg" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="gc-日志解读">GC 日志解读&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/GC%e6%97%a5%e5%bf%97%e8%a7%a3%e8%af%bb.png" alt="GC日志解读.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>03-Java 内存分配策略</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/03-java-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/1.java-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/03-java-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid><description>&lt;h1 id="java-内存分配策略">Java 内存分配策略&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6%e7%ad%96%e7%95%a5.png" alt="内存分配与回收策略.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#java-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5">Java 内存分配策略&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e4%bc%98%e5%85%88%e5%9c%a8-eden-%e5%8c%ba%e5%88%86%e9%85%8d">优先在 Eden 区分配&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%a4%a7%e5%af%b9%e8%b1%a1%e7%9b%b4%e6%8e%a5%e8%bf%9b%e5%85%a5%e8%80%81%e5%b9%b4%e4%bb%a3">大对象直接进入老年代&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e9%95%bf%e6%9c%9f%e5%ad%98%e6%b4%bb%e7%9a%84%e5%af%b9%e8%b1%a1%e5%b0%86%e8%bf%9b%e5%85%a5%e8%80%81%e5%b9%b4%e4%bb%a3">长期存活的对象将进入老年代&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e6%8b%85%e4%bf%9d">空间分配担保&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;blockquote>
&lt;p>&lt;strong>新生代和老年代的 GC 操作&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>新生代 GC 操作：Minor GC
&lt;ul>
&lt;li>发生的非常频繁，速度较块。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>老年代 GC 操作：Full GC / Major GC
&lt;ul>
&lt;li>经常伴随着至少一次的 Minor GC；&lt;/li>
&lt;li>速度一般比 Minor GC 慢上 10 倍以上。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="优先在-eden-区分配">优先在 Eden 区分配&lt;/h2>
&lt;ul>
&lt;li>Eden 空间不够将会触发一次 Minor GC；&lt;/li>
&lt;li>虚拟机参数：
&lt;ul>
&lt;li>&lt;code>-Xmx&lt;/code>：Java 堆的最大值；&lt;/li>
&lt;li>&lt;code>-Xms&lt;/code>：Java 堆的最小值；&lt;/li>
&lt;li>&lt;code>-Xmn&lt;/code>：新生代大小；&lt;/li>
&lt;li>&lt;code>-XX:SurvivorRatio=8&lt;/code>：Eden 区 / Survivor 区 = 8 : 1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="大对象直接进入老年代">大对象直接进入老年代&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>大对象定义：&lt;/strong> 需要大量连续内存空间的 Java 对象。例如那种很长的字符串或者数组。&lt;/li>
&lt;li>&lt;strong>设置对象直接进入老年代大小限制：&lt;/strong>
&lt;ul>
&lt;li>&lt;code>-XX:PretenureSizeThreshold&lt;/code>：单位是字节；
&lt;ul>
&lt;li>只对 Serial 和 ParNew 两款收集器有效。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>目的：&lt;/strong> 因为新生代采用的是复制算法收集垃圾，大对象直接进入老年代可以避免在 Eden 区和 Survivor 区发生大量的内存复制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>固定对象年龄判定：&lt;/strong> 虚拟机给每个对象定义一个年龄计数器，对象每在 Survivor 中熬过一次 Minor GC，年龄 +1，达到 &lt;code>-XX:MaxTenuringThreshold&lt;/code> 设定值后，会被晋升到老年代，&lt;code>-XX:MaxTenuringThreshold&lt;/code> 默认为 15；&lt;/li>
&lt;li>&lt;strong>动态对象年龄判定：&lt;/strong> Survivor 中有相同年龄的对象的空间总和大于 Survivor 空间的一半，那么，年龄大于或等于该年龄的对象直接晋升到老年代。&lt;/li>
&lt;/ul>
&lt;h2 id="空间分配担保">空间分配担保&lt;/h2>
&lt;p>我们知道，新生代采用的是复制算法清理内存，每一次 Minor GC，虚拟机会将 Eden 区和其中一块 Survivor 区的存活对象复制到另一块 Survivor 区，但 &lt;strong>当出现大量对象在一次 Minor GC 后仍然存活的情况时，Survivor 区可能容纳不下这么多对象，此时，就需要老年代进行分配担保，即将 Survivor 无法容纳的对象直接进入老年代。&lt;/strong>&lt;/p>
&lt;p>这么做有一个前提，就是老年代得装得下这么多对象。可是在一次 GC 操作前，虚拟机并不知道到底会有多少对象存活，所以空间分配担保有这样一个判断流程：&lt;/p>
&lt;ul>
&lt;li>发生 Minor GC 前，虚拟机先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间；
&lt;ul>
&lt;li>如果大于，Minor GC 一定是安全的；&lt;/li>
&lt;li>如果小于，虚拟机会查看 HandlePromotionFailure 参数，看看是否允许担保失败；
&lt;ul>
&lt;li>允许失败：尝试着进行一次 Minor GC；&lt;/li>
&lt;li>不允许失败：进行一次 Full GC；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不过 JDK 6 Update 24 后，HandlePromotionFailure 参数就没有用了，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC。&lt;/li>
&lt;/ul>
&lt;h2 id="metaspace-元空间与-permgen-永久代">Metaspace 元空间与 PermGen 永久代&lt;/h2>
&lt;p>Java 8 彻底将永久代 (PermGen) 移除出了 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Metaspace。&lt;/p>
&lt;p>&lt;strong>移除 PermGen 的原因：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM；&lt;/li>
&lt;li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>移除 PermGen 后，方法区和字符串常量的位置：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>方法区：移至 Metaspace；&lt;/li>
&lt;li>字符串常量：移至 Java Heap。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Metaspace 的位置：&lt;/strong> 本地堆内存(native heap)。&lt;/p>
&lt;p>&lt;strong>Metaspace 的优点：&lt;/strong> 永久代 OOM 问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上 Metaspace 就可以有多大；&lt;/p>
&lt;p>&lt;strong>JVM 参数：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>-XX:MetaspaceSize&lt;/code>：分配给类元数据空间（以字节计）的初始大小，为估计值。MetaspaceSize 的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。&lt;/li>
&lt;li>&lt;code>-XX:MaxMetaspaceSize&lt;/code>：分配给类元数据空间的最大值，超过此值就会触发 Full GC，取决于系统内存的大小。JVM 会动态地改变此值。&lt;/li>
&lt;li>&lt;code>-XX:MinMetaspaceFreeRatio&lt;/code>：一次 GC 以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。&lt;/li>
&lt;li>&lt;code>-XX:MaxMetaspaceFreeRatio&lt;/code>：一次 GC 以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。&lt;/li>
&lt;/ul></description></item></channel></rss>