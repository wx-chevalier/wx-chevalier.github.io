<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2.Java 虚拟机程序执行 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</link><atom:link href="https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/index.xml" rel="self" type="application/rss+xml"/><description>2.Java 虚拟机程序执行</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>2.Java 虚拟机程序执行</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</link></image><item><title>00-Class文件的组成结构</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/00-class%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/00-class%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="class-文件的组成结构">Class 文件的组成结构&lt;/h1>
&lt;p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有任何分隔符。Java 虚拟机规范规定 Class 文件采用一种类似 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，我们之后也主要对这两种类型的数据类型进行解析。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无符号数：&lt;/strong> 无符号数属于基本数据类型，以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用它来描述数字、索引引用、数量值或 utf-8 编码的字符串值。&lt;/li>
&lt;li>&lt;strong>表：&lt;/strong> 表是由多个无符号数或其他表为数据项构成的复合数据类型，名称上都以 &lt;code>_info&lt;/code> 结尾。&lt;/li>
&lt;/ul>
&lt;h2 id="class-文件的头-8-个字节">Class 文件的头 8 个字节&lt;/h2>
&lt;p>Class 文件的头 8 个字节是魔数和版本号，其中头 4 个字节是魔数，也就是 &lt;code>0xCAFEBABE&lt;/code>，它可以用来确定这个文件是否为一个能被虚拟机接受的 Class 文件（这通过扩展名来识别文件类型要安全，毕竟扩展名是可以随便修改的）。&lt;/p>
&lt;p>后 4 个字节则是当前 Class 文件的版本号，其中第 5、6 个字节是次版本号，第 7、8 个字节是主版本号。&lt;/p>
&lt;h2 id="常量池">常量池&lt;/h2>
&lt;p>从第 9 个字节开始，就是常量池的入口，常量池是 Class 文件中：&lt;/p>
&lt;ul>
&lt;li>与其他项目关联最多的的数据类型；&lt;/li>
&lt;li>占用 Class 文件空间最大的数据项目；&lt;/li>
&lt;li>Class 文件中第一个出现的表类型数据项目。&lt;/li>
&lt;/ul>
&lt;p>常量池的开始的两个字节，也就是第 9、10 个字节，放置一个 u2 类型的数据，标识常量池中常量的数量 cpc (constant_pool_count)，这个计数值有一个十分特殊的地方，就是它是从 1 开始而不是从 0 开始的，也就是说如果 cpc = 22，那么代表常量池中有 21 项常量，索引值为 1 ~ 21，第 0 项常量被空出来，为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”时，将让这个索引值指向 0 即可。&lt;/p>
&lt;p>常量池中记录的是代码出现过的所有 token（类名，成员变量名等，也是我们接下来要修改的地方）以及符号引用（方法引用，成员变量引用等），主要包括以下两大类常量：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>字面量：&lt;/strong> 接近于 Java 语言层面的常量概念，包括
&lt;ul>
&lt;li>文本字符串&lt;/li>
&lt;li>声明为 final 的常量值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>符号引用：&lt;/strong> 以一组符号来描述所引用的目标，包括
&lt;ul>
&lt;li>类和接口的全限定名&lt;/li>
&lt;li>字段的名称和描述符&lt;/li>
&lt;li>方法的名称和描述符&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>常量池中的每一项常量都通过一个表来存储。目前一共有 14 种常量，不过麻烦的地方就在于，这 14 种常量类型每一种都有自己的结构，我们在这里只详细介绍两种：CONSTANT_Class_info 和 CONSTANT_Utf8_info。&lt;/p>
&lt;p>CONSTANT_Class_info 的存储结构为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="o">...&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">7&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="n">name_index&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">...&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="err">位&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="err">位&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，tag 是标志位，用来区分常量类型的，tag = 7 就表示接下来的这个表是一个 CONSTANT_Class_info，name_index 是一个索引值，指向常量池中的一个 CONSTANT_Utf8_info 类型的常量所在的索引值，CONSTANT_Utf8_info 类型常量一般被用来描述类的全限定名、方法名和字段名。它的存储结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="o">...&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="err">当前常量的长度&lt;/span> &lt;span class="n">len&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="err">常量的符号引用的字符串值&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">...&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="err">位&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="err">位&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="err">位&lt;/span> &lt;span class="o">]&lt;/span> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>后面还没看，先简单介绍到这里……&lt;/p></description></item><item><title>01-虚拟机的类加载机制</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/01-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/01-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>&lt;h1 id="虚拟机的类加载机制">虚拟机的类加载机制&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6">虚拟机的类加载机制&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e7%9a%84%e6%97%b6%e6%9c%ba">类加载的时机&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e7%b1%bb%e7%9a%84%e6%98%be%e5%bc%8f%e5%8a%a0%e8%bd%bd%e5%92%8c%e9%9a%90%e5%bc%8f%e5%8a%a0%e8%bd%bd">类的显式加载和隐式加载&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e7%9a%84%e8%bf%87%e7%a8%8b">类加载的过程&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e7%b1%bb%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">类的生命周期&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%8a%a0%e8%bd%bd">加载&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%8a%a0%e8%bd%bd%e7%9a%84-3-%e4%b8%aa%e9%98%b6%e6%ae%b5">加载的 3 个阶段&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%88%86%e7%b1%bb">分类&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e9%aa%8c%e8%af%81">验证&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%87%86%e5%a4%87">准备&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e8%a7%a3%e6%9e%90">解析&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%88%9d%e5%a7%8b%e5%8c%96">初始化&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8">类加载器&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e4%b8%a4%e4%b8%aa%e7%b1%bb-%e7%9b%b8%e7%ad%89">如何判断两个类 “相等”&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e7%9a%84%e5%88%86%e7%b1%bb">类加载器的分类&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%a8%a1%e5%9e%8b">双亲委派模型&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="类加载的时机">类加载的时机&lt;/h2>
&lt;p>JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主动引用&lt;/strong>
&lt;ul>
&lt;li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：
&lt;ul>
&lt;li>使用 new 实例化对象；&lt;/li>
&lt;li>读取或设置一个类的 static 字段（被 final 修饰的除外）；&lt;/li>
&lt;li>调用类的静态方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对类进行反射调用；&lt;/li>
&lt;li>初始化一个类时，其父类还没初始化（需先初始化父类）；
&lt;ul>
&lt;li>这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>虚拟机启动，先初始化包含 main() 函数的主类；&lt;/li>
&lt;li>JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>被动引用&lt;/strong>
&lt;ul>
&lt;li>通过子类引用父类静态字段，不会导致子类初始化；&lt;/li>
&lt;li>&lt;code>Array[] arr = new Array[10];&lt;/code> 不会触发 Array 类初始化；&lt;/li>
&lt;li>&lt;code>static final VAR&lt;/code> 在编译阶段会存入调用类的常量池，通过 &lt;code>ClassName.VAR&lt;/code> 引用不会触发 ClassName 初始化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。&lt;/p>
&lt;h2 id="类的显式加载和隐式加载">类的显式加载和隐式加载&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>显示加载：&lt;/strong>
&lt;ul>
&lt;li>调用 &lt;code>ClassLoader#loadClass(className)&lt;/code> 或 &lt;code>Class.forName(className)&lt;/code>。&lt;/li>
&lt;li>两种显示加载 .class 文件的区别：
&lt;ul>
&lt;li>&lt;code>Class.forName(className)&lt;/code> 加载 class 的同时会初始化静态域，&lt;code>ClassLoader#loadClass(className)&lt;/code> 不会初始化静态域；&lt;/li>
&lt;li>Class.forName 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>隐式加载：&lt;/strong>
&lt;ul>
&lt;li>new 类对象；&lt;/li>
&lt;li>使用类的静态域；&lt;/li>
&lt;li>创建子类对象；&lt;/li>
&lt;li>使用子类的静态域；&lt;/li>
&lt;li>其他的隐式加载，在 JVM 启动时：
&lt;ul>
&lt;li>BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；&lt;/li>
&lt;li>ExtClassLoader 会加载指定目录下一些特殊的 Class；&lt;/li>
&lt;li>AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="类加载的过程">类加载的过程&lt;/h2>
&lt;h3 id="类的生命周期">类的生命周期&lt;/h3>
&lt;pre tabindex="0">&lt;code>加载 --&amp;gt; 验证 --&amp;gt; 准备 --&amp;gt; 解析 --&amp;gt; 初始化 --&amp;gt; 使用 --&amp;gt; 卸载
|&amp;lt;------- 连接 -------&amp;gt;|
|&amp;lt;------------- 类加载 ----------------&amp;gt;|
&lt;/code>&lt;/pre>&lt;p>类的生命周期一共有 7 个阶段，其中前五个阶段较为重要，统称为类加载，第 2 ~ 4 阶段统称为连接，加载和连接中的三个过程开始的顺序是固定的，但是执行过程中是可以交叉执行的。接下来，我们将对类加载的 5 个阶段进行一一讲解。&lt;/p>
&lt;h3 id="加载">加载&lt;/h3>
&lt;h4 id="加载的-3-个阶段">加载的 3 个阶段&lt;/h4>
&lt;ul>
&lt;li>通过类的全限定名获取二进制字节流（将 .class 文件读进内存）；&lt;/li>
&lt;li>将字节流的静态存储结构转化为运行时的数据结构；&lt;/li>
&lt;li>在内存中生成该类的 Class 对象；
&lt;ul>
&lt;li>HotSpot 虚拟机把这个对象放在方法区，非 Java 堆。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="分类">分类&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>非数组类&lt;/strong>
&lt;ul>
&lt;li>系统提供的引导类加载器&lt;/li>
&lt;li>用户自定义的类加载器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>数组类&lt;/strong>
&lt;ul>
&lt;li>不通过类加载器，由 Java 虚拟机直接创建&lt;/li>
&lt;li>创建动作由 newarray 指令触发，new 实际上触发了 &lt;code>[L全类名&lt;/code> 对象的初始化&lt;/li>
&lt;li>规则
&lt;ul>
&lt;li>数组元素是引用类型
&lt;ul>
&lt;li>加载：递归加载其组件&lt;/li>
&lt;li>可见性：与引用类型一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数组元素是非引用类型
&lt;ul>
&lt;li>加载：与引导类加载器关联&lt;/li>
&lt;li>可见性：public&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="验证">验证&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>目的：&lt;/strong> 确保 .class 文件中的字节流信息符合虚拟机的要求。&lt;/li>
&lt;li>&lt;strong>4 个验证过程：&lt;/strong>
&lt;ul>
&lt;li>文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” &lt;code>0xCAFEBABE&lt;/code>&lt;/li>
&lt;li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析）&lt;/li>
&lt;li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）&lt;/li>
&lt;li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>这个操作虽然重要，但不是必要的，可以通过 &lt;code>-Xverify:none&lt;/code> 关掉。&lt;/li>
&lt;/ul>
&lt;h3 id="准备">准备&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>描述：&lt;/strong> 为 static 变量在方法区分配内存。&lt;/li>
&lt;li>static 变量准备后的初始值：
&lt;ul>
&lt;li>&lt;code>public static int value = 123;&lt;/code>
&lt;ul>
&lt;li>准备后为 0，value 的赋值指令 putstatic 会被放在 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法中，&lt;code>&amp;lt;clinit&amp;gt;()&lt;/code>方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>public static final int value = 123;&lt;/code>
&lt;ul>
&lt;li>准备后为 123，因为被 &lt;code>static final&lt;/code> 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="解析">解析&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>描述：&lt;/strong> 将常量池中的 “符号引用” 替换为 “直接引用”。
&lt;ul>
&lt;li>在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。&lt;/li>
&lt;li>什么是 “符号引用” 和 “直接引用” ？
&lt;ul>
&lt;li>符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。&lt;/li>
&lt;li>直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>描述：&lt;/strong> 执行类构造器 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法的过程。&lt;/li>
&lt;li>&lt;strong>&lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法&lt;/strong>
&lt;ul>
&lt;li>包含的内容：
&lt;ul>
&lt;li>所有 static 的赋值操作；&lt;/li>
&lt;li>static 块中的语句；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法中的语句顺序：
&lt;ul>
&lt;li>基本按照语句在源文件中出现的顺序排列；&lt;/li>
&lt;li>静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>与 &lt;code>&amp;lt;init&amp;gt;()&lt;/code> 的不同：
&lt;ul>
&lt;li>不需要显示调用父类的 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法；&lt;/li>
&lt;li>虚拟机保证在子类的 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法执行前，父类的 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法一定执行完毕。
&lt;ul>
&lt;li>也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>接口与类的不同：
&lt;ul>
&lt;li>执行子接口的 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法前不需要先执行父接口的 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法（除非用到了父接口中定义的 public static final 变量）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>执行过程中加锁：
&lt;ul>
&lt;li>同一时刻只能有一个线程在执行 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非必要性：
&lt;ul>
&lt;li>一个类如果没有任何 static 的内容就不需要执行 &lt;code>&amp;lt;clinit&amp;gt;()&lt;/code> 方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;em>注：初始化时，才真正开始执行类中定义的 Java 代码。&lt;/em>&lt;/p>
&lt;h2 id="类加载器">类加载器&lt;/h2>
&lt;h3 id="如何判断两个类-相等">如何判断两个类 “相等”&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>“相等” 的要求&lt;/strong>
&lt;ul>
&lt;li>同一个 .class 文件&lt;/li>
&lt;li>被同一个虚拟机加载&lt;/li>
&lt;li>被同一个类加载器加载&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>判断 “相等” 的方法&lt;/strong>
&lt;ul>
&lt;li>&lt;code>instanceof&lt;/code> 关键字&lt;/li>
&lt;li>Class 对象中的方法：
&lt;ul>
&lt;li>&lt;code>equals()&lt;/code>&lt;/li>
&lt;li>&lt;code>isInstance()&lt;/code>&lt;/li>
&lt;li>&lt;code>isAssignableFrom()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="类加载器的分类">类加载器的分类&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>启动类加载器（Bootstrap）&lt;/strong>
&lt;ul>
&lt;li>&amp;lt;JAVA_HOME&amp;gt;/lib&lt;/li>
&lt;li>-Xbootclasspath 参数指定的路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>扩展类加载器（Extension）&lt;/strong>
&lt;ul>
&lt;li>&amp;lt;JAVA_HOME&amp;gt;/lib/ext&lt;/li>
&lt;li>java.ext.dirs 系统变量指定的路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>应用程序类加载器（Application）&lt;/strong>
&lt;ul>
&lt;li>-classpath 参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="双亲委派模型">双亲委派模型&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>工作过程&lt;/strong>
&lt;ul>
&lt;li>当前类加载器收到类加载的请求后，先不自己尝试加载类，而是先将请求委派给父类加载器
&lt;ul>
&lt;li>因此，所有的类加载请求，都会先被传送到启动类加载器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>只有当父类加载器加载失败时，当前类加载器才会尝试自己去自己负责的区域加载&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>实现&lt;/strong>
&lt;ul>
&lt;li>检查该类是否已经被加载&lt;/li>
&lt;li>将类加载请求委派给父类
&lt;ul>
&lt;li>如果父类加载器为 null，默认使用启动类加载器&lt;/li>
&lt;li>&lt;code>parent.loadClass(name, false)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当父类加载器加载失败时
&lt;ul>
&lt;li>catch ClassNotFoundException 但不做任何处理&lt;/li>
&lt;li>调用自己的 findClass() 去加载
&lt;ul>
&lt;li>我们在实现自己的类加载器时只需要 &lt;code>extends ClassLoader&lt;/code>，然后重写 &lt;code>findClass()&lt;/code> 方法而不是 &lt;code>loadClass()&lt;/code> 方法，这样就不用重写 &lt;code>loadClass()&lt;/code> 中的双亲委派机制了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>
&lt;ul>
&lt;li>自己写的类库同名类不会覆盖类库的类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>02-虚拟机字节码执行引擎_00-虚拟机栈栈帧结构</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_00-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_00-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="虚拟机栈栈帧结构">虚拟机栈栈帧结构&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e6%a0%88%e5%b8%a7%e7%bb%93%e6%9e%84.png" alt="虚拟机栈栈帧结构.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e6%a0%88%e5%b8%a7%e7%bb%93%e6%9e%84">虚拟机栈栈帧结构&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8">局部变量表&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8%e7%9a%84%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d">局部变量表的空间分配&lt;/a>&lt;/li>
&lt;li>&lt;a href="#slot-%e7%9a%84%e5%a4%8d%e7%94%a8">Slot 的复用&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e6%93%8d%e4%bd%9c%e6%95%b0%e6%a0%88">操作数栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%8a%a8%e6%80%81%e8%bf%9e%e6%8e%a5">动态连接&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%96%b9%e6%b3%95%e8%bf%94%e5%9b%9e%e5%9c%b0%e5%9d%80">方法返回地址&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="局部变量表">局部变量表&lt;/h2>
&lt;ul>
&lt;li>存放方法参数和方法内部定义的局部变量；
&lt;ul>
&lt;li>Java 程序编译为 class 文件时，就确定了每个方法需要分配的局部变量表的最大容量。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最小单位：Slot；
&lt;ul>
&lt;li>一个 Slot 中可以存放：boolean，byte，char，short，int，float，reference，returnAddress (少见)；&lt;/li>
&lt;li>虚拟机可通过局部变量表中的 reference 做到：
&lt;ul>
&lt;li>查找 Java 堆中的实例对象的起始地址；&lt;/li>
&lt;li>查找方法区中的 Class 对象。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="局部变量表的空间分配">局部变量表的空间分配&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/book/understanding-the-jvm/%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8%e7%9a%84%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d.png" alt="局部变量表的空间分配.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="slot-的复用">Slot 的复用&lt;/h3>
&lt;p>&lt;strong>定义：&lt;/strong> 如果当前位置已经超过某个变量的作用域时，例如出了定义这个变量的代码块，这个变量对应的 Slot 就可以给其他变量使用了。但同时也说明，只要其他变量没有使用这部分 Slot 区域，这个变量就还保存在那里，这会对 GC 操作产生影响。&lt;/p>
&lt;p>&lt;strong>对 GC 操作的影响：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">placeholder&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1024&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">gc&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>-verbose:gc&lt;/code> 输出：&lt;/p>
&lt;pre tabindex="0">&lt;code>[GC (System.gc()) 68813K-&amp;gt;66304K(123904K), 0.0034797 secs]
[Full GC (System.gc()) 66304K-&amp;gt;66204K(123904K), 0.0086225 secs] // 没有被回收
&lt;/code>&lt;/pre>&lt;p>进行如下修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">placeholder&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1024&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 新加一个赋值操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">gc&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>-verbose:gc&lt;/code> 输出：&lt;/p>
&lt;pre tabindex="0">&lt;code>[GC (System.gc()) 68813K-&amp;gt;66320K(123904K), 0.0017394 secs]
[Full GC (System.gc()) 66320K-&amp;gt;668K(123904K), 0.0084337 secs] // 被回收了
&lt;/code>&lt;/pre>&lt;p>&lt;strong>第二次修改后，placeholder 能被回收的原因？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>placeholder 能否被回收的关键：局部变量表中的 Slot 是否还存在关于 placeholder 的引用；&lt;/li>
&lt;li>出了 placeholder 所在的代码块后，还没有进行其他操作，所以 placeholder 所在的 Slot 还没有被其他变量复用，也就是说，局部变量表的 Slot 中依然存在着 placeholder 的引用；&lt;/li>
&lt;li>第二次修改后，int a 占用了原来 placeholder 所在的 Slot，所以可以被 GC 掉了。&lt;/li>
&lt;/ul>
&lt;h2 id="操作数栈">操作数栈&lt;/h2>
&lt;ul>
&lt;li>元素可以是任意 Java 类型，32 位数据占 1 个栈容量，64 位数据占 2 个栈容量；&lt;/li>
&lt;li>Java 虚拟机的解释执行称为：基于栈的执行引擎，其中 “栈” 指的就是操作数栈；&lt;/li>
&lt;/ul>
&lt;h2 id="动态连接">动态连接&lt;/h2>
&lt;ul>
&lt;li>指向运行时常量池中该栈帧所属方法的引用；&lt;/li>
&lt;li>为了支持方法调用过程中的动态连接，什么是动态连接会在下一篇文章进行讲解，先知道有这么个东西就行。&lt;/li>
&lt;/ul>
&lt;h2 id="方法返回地址">方法返回地址&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>两种退出方法的方式：&lt;/strong>
&lt;ul>
&lt;li>遇到 return；&lt;/li>
&lt;li>遇到异常。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>退出方法时可能执行的操作：&lt;/strong>
&lt;ul>
&lt;li>恢复上层方法的局部变量表和操作数栈；&lt;/li>
&lt;li>把返回值压入调用者栈帧的操作数栈；&lt;/li>
&lt;li>调整 PC 计数器指向方法调用后面的指令。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>02-虚拟机字节码执行引擎_01-方法调用</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</guid><description>&lt;h1 id="方法调用">方法调用&lt;/h1>
&lt;p>Java 的方法的执行分为两个部分：&lt;/p>
&lt;ul>
&lt;li>方法调用：确定被调用的方法是哪一个；&lt;/li>
&lt;li>基于栈的解释执行：真正的执行方法的字节码。&lt;/li>
&lt;/ul>
&lt;p>在本节中我们将对方法调用进行详细的讲解，我们知道，一切方法的调用在 Class 文件中存储的都是常量池中的符号引用，而不是方法实际运行时的入口地址（直接引用），直到类加载的时候，甚至是实际运行的时候才回去会去确定要被运行的方法的直接引用，而确定要被运行的方法的直接引用的过程就叫做方法调用。&lt;/p>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8">方法调用&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8%e5%ad%97%e8%8a%82%e7%a0%81%e6%8c%87%e4%bb%a4">方法调用字节码指令&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e8%a7%a3%e6%9e%90%e8%b0%83%e7%94%a8">解析调用&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%88%86%e6%b4%be%e8%b0%83%e7%94%a8">分派调用&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e9%9d%99%e6%80%81%e5%88%86%e6%b4%be%e6%96%b9%e6%b3%95%e9%87%8d%e8%bd%bd">静态分派（方法重载）&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%8f%98%e9%87%8f%e7%9a%84%e9%9d%99%e6%80%81%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%ae%9e%e9%99%85%e7%b1%bb%e5%9e%8b">变量的静态类型和实际类型&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e9%87%8d%e8%bd%bd%e6%96%b9%e6%b3%95%e5%8c%b9%e9%85%8d%e4%bc%98%e5%85%88%e7%ba%a7%e4%be%8b%e5%a6%82%e4%b8%80%e4%b8%aa%e5%ad%97%e7%ac%a6-a-%e4%bd%9c%e4%b8%ba%e5%85%a5%e5%8f%82">重载方法匹配优先级，例如一个字符 &amp;lsquo;a&amp;rsquo; 作为入参&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e5%8a%a8%e6%80%81%e5%88%86%e6%b4%be%e6%96%b9%e6%b3%95%e9%87%8d%e5%86%99">动态分派（方法重写）&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%8a%a8%e6%80%81%e5%88%86%e6%b4%be%e7%9a%84%e8%bf%87%e7%a8%8b">动态分派的过程&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%8a%a8%e6%80%81%e5%88%86%e6%b4%be%e7%9a%84%e5%ae%9e%e7%8e%b0">动态分派的实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e5%8d%95%e5%88%86%e6%b4%be%e4%b8%8e%e5%a4%9a%e5%88%86%e6%b4%be">单分派与多分派&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b%e8%af%ad%e8%a8%80%e6%94%af%e6%8c%81">动态类型语言支持&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#javalanginvoke-%e5%8c%85">java.lang.invoke 包&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#methodhandle-%e7%9a%84%e4%bd%bf%e7%94%a8">MethodHandle 的使用&lt;/a>&lt;/li>
&lt;li>&lt;a href="#methodhandle-%e5%92%8c-reflection-%e7%9a%84%e5%8c%ba%e5%88%ab">MethodHandle 和 Reflection 的区别&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#invokedynamic-%e6%8c%87%e4%bb%a4">&lt;code>invokedynamic&lt;/code> 指令&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="方法调用字节码指令">方法调用字节码指令&lt;/h2>
&lt;p>Java 虚拟机提供了 5 个职责不同的方法调用字节码指令：&lt;/p>
&lt;ul>
&lt;li>&lt;code>invokestatic&lt;/code>：调用静态方法；&lt;/li>
&lt;li>&lt;code>invokespecial&lt;/code>：调用构造器方法、私有方法、父类方法；&lt;/li>
&lt;li>&lt;code>invokevirtual&lt;/code>：调用所有虚方法，除了静态方法、构造器方法、私有方法、父类方法、final 方法的其他方法叫虚方法；&lt;/li>
&lt;li>&lt;code>invokeinterface&lt;/code>：调用接口方法，会在运行时确定一个该接口的实现对象；&lt;/li>
&lt;li>&lt;code>invokedynamic&lt;/code>：在运行时动态解析出调用点限定符引用的方法，再执行该方法。&lt;/li>
&lt;/ul>
&lt;p>除了 &lt;code>invokedynamic&lt;/code>，其他 4 种方法的第一个参数都是被调用的方法的符号引用，是在编译时确定的，所以它们缺乏动态类型语言支持，因为动态类型语言只有在运行期才能确定接收者的类型，即变量的类型检查的主体过程在运行期，而非编译期。&lt;/p>
&lt;blockquote>
&lt;p>final 方法虽然是通过 &lt;code>invokevirtual&lt;/code> 调用的，但是其无法被覆盖，没有其他版本，无需对接收者进行多态选择，或者说多态选择的结果是唯一的，所以属于非虚方法。&lt;/p>
&lt;/blockquote>
&lt;h2 id="解析调用">解析调用&lt;/h2>
&lt;p>解析调用，正如其名，就是 &lt;strong>在类加载的解析阶段，就确定了方法的调用版本&lt;/strong> 。我们知道类加载的解析阶段会将一部分符号引用转化为直接引用，这一过程就叫做解析调用。因为是在程序真正运行前就确定了要调用哪一个方法，所以 &lt;strong>解析调用能成立的前提就是：方法在程序真正运行前就有一个明确的调用版本了，并且这个调用版本不会在运行期发生改变。&lt;/strong>&lt;/p>
&lt;p>符合这两个要求的只有以下两类方法：&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>invokestatic&lt;/code> 调用的方法：静态方法；&lt;/li>
&lt;li>通过 &lt;code>invokespecial&lt;/code> 调用的方法：私有方法、构造器方法、父类方法；&lt;/li>
&lt;/ul>
&lt;p>这两类方法根本不可能通过继承或者别的方式重写出来其他版本，也就是说，在运行前就可以确定调用版本了，十分适合在类加载阶段就解析好。它们会在类加载的解析阶被解析为直接引用，即确定调用版本。&lt;/p>
&lt;h2 id="分派调用">分派调用&lt;/h2>
&lt;p>在介绍分派调用前，我们先来介绍一下 Java 所具备的面向对象的 3 个基本特征：封装，继承，多态。&lt;/p>
&lt;p>其中多态最基本的体现就是重载和重写了，重载和重写的一个重要特征就是方法名相同，其他各种不同：&lt;/p>
&lt;ul>
&lt;li>重载：发生在同一个类中，入参必须不同，返回类型、访问修饰符、抛出的异常都可以不同；&lt;/li>
&lt;li>重写：发生在子父类中，入参和返回类型必须相同，访问修饰符大于等于被重写的方法，不能抛出新的异常。&lt;/li>
&lt;/ul>
&lt;p>相同的方法名实际上给虚拟机的调用带来了困惑，因为虚拟机需要判断，它到底应该调用哪个方法，而这个过程会在分派调用中体现出来。其中：&lt;/p>
&lt;ul>
&lt;li>方法重载 —— 静态分派&lt;/li>
&lt;li>方法重写 —— 动态分派&lt;/li>
&lt;/ul>
&lt;h3 id="静态分派方法重载">静态分派（方法重载）&lt;/h3>
&lt;p>在介绍静态分派前，我们先来介绍一下什么是变量的静态类型和实际类型。&lt;/p>
&lt;h4 id="变量的静态类型和实际类型">变量的静态类型和实际类型&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">StaticDispatch&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Human&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Man&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Human&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Woman&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Human&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Human&lt;/span> &lt;span class="n">guy&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello guy!&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Man&lt;/span> &lt;span class="n">man&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello man!&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Woman&lt;/span> &lt;span class="n">woman&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello woman!&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Human&lt;/span> &lt;span class="n">man&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Man&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Human&lt;/span> &lt;span class="n">woman&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Woman&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">StaticDispatch&lt;/span> &lt;span class="n">sr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">StaticDispatch&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">man&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">woman&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* 输出：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Hello guy!
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Hello guy!
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 因为是根据变量的静态类型，也就是左面的类型：Human 来判断调用哪个方法，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 所以调用的都是 public void sayHello(Human guy)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* 简单讲解 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 使用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Human&lt;/span> &lt;span class="n">man&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Man&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 实际类型发生变化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Human&lt;/span> &lt;span class="n">man&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Man&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">man&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Woman&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 静态类型发生变化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">sr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="n">Man&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">man&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 输出：Hello man!
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">sr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="n">Woman&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">man&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 输出：Hello woman!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>Human&lt;/code> 称为变量的静态类型，&lt;code>Man&lt;/code> 称为变量的实际类型。&lt;/p>
&lt;p>在重载时，编译器是通过方法参数的静态类型，而不是实际类型，来判断应该调用哪个方法的。&lt;/p>
&lt;p>&lt;strong>通俗的讲，静态分派就是通过方法的参数（类型 &amp;amp; 个数 &amp;amp; 顺序）这种静态的东西来判断到底调用哪个方法的过程。&lt;/strong>&lt;/p>
&lt;h4 id="重载方法匹配优先级例如一个字符-a-作为入参">重载方法匹配优先级，例如一个字符 &amp;lsquo;a&amp;rsquo; 作为入参&lt;/h4>
&lt;ul>
&lt;li>基本类型
&lt;ul>
&lt;li>char&lt;/li>
&lt;li>int&lt;/li>
&lt;li>long&lt;/li>
&lt;li>float&lt;/li>
&lt;li>double&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Character&lt;/li>
&lt;li>Serializable（Character 实现的接口）
&lt;ul>
&lt;li>同时出现两个优先级相同的接口，如 Serializable 和 Comparable，会提示类型模糊，拒绝编译。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Object&lt;/li>
&lt;li>char&amp;hellip;（变长参数优先级最低）&lt;/li>
&lt;/ul>
&lt;h3 id="动态分派方法重写">动态分派（方法重写）&lt;/h3>
&lt;p>动态分派就是在运行时，根据实际类型确定方法执行版本的分派过程。&lt;/p>
&lt;h4 id="动态分派的过程">动态分派的过程&lt;/h4>
&lt;p>我们先来看一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DynamicDispatch&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Human&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">protected&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Man&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Human&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello man&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Woman&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Human&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">protected&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello woman&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Human&lt;/span> &lt;span class="n">man&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Man&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Human&lt;/span> &lt;span class="n">woman&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Woman&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">man&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">woman&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">man&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">woman&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">man&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* 输出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Hello man
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Hello woman
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Hello woman
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>字节码分析：&lt;/p>
&lt;pre tabindex="0">&lt;code>public static void main(java.lang.String[]);
descriptor: ([Ljava/lang/String;)V
flags: ACC_PUBLIC, ACC_STATIC
Code:
stack=2, locals=3, args_size=1
0: new #2 // class com/jvm/ch8/DynamicDispatch$Man
3: dup
4: invokespecial #3 // Method com/jvm/ch8/DynamicDispatch$Man.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
7: astore_1
8: new #4 // class com/jvm/ch8/DynamicDispatch$Woman
11: dup
12: invokespecial #5 // Method com/jvm/ch8/DynamicDispatch$Woman.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
15: astore_2
16: aload_1 // 把刚创建的对象的引用压到操作数栈顶，
// 供之后执行sayHello时确定是执行哪个对象的sayHello
17: invokevirtual #6 // 方法调用
20: aload_2 // 把刚创建的对象的引用压到操作数栈顶，
// 供之后执行sayHello时确定是执行哪个对象的sayHello
21: invokevirtual #6 // 方法调用
24: aload_2
25: astore_1
26: aload_1
27: invokevirtual #6 // Method com/jvm/ch8/DynamicDispatch$Human.sayHello:()V
30: return
&lt;/code>&lt;/pre>&lt;p>通过字节码分析可以看出，&lt;code>invokevirtual&lt;/code> 指令的运行过程大致为：&lt;/p>
&lt;ul>
&lt;li>去操作数栈顶取出将要执行的方法的所有者，记作 C；&lt;/li>
&lt;li>查找此方法：
&lt;ul>
&lt;li>在 C 中查找此方法；&lt;/li>
&lt;li>在 C 的各个父类中查找；&lt;/li>
&lt;li>查找过程：
&lt;ul>
&lt;li>查找与常量的描述符和简单名称都相同的方法；&lt;/li>
&lt;li>进行访问权限验证，不通过抛出：IllegalAccessError 异常；&lt;/li>
&lt;li>通过访问权限验证则返回直接引用；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>没找到则抛出：AbstractMethodError 异常，即该方法没被实现。&lt;/li>
&lt;/ul>
&lt;h4 id="动态分派的实现">动态分派的实现&lt;/h4>
&lt;p>动态分派在虚拟机种执行的非常频繁，而且方法查找的过程要在类的方法元数据中搜索合适的目标，从性能上考虑，不太可能进行如此频繁的搜索，需要进行性能上的优化。&lt;/p>
&lt;p>&lt;strong>常用优化手段：&lt;/strong> 在类的方法区中建立一个虚方法表。&lt;/p>
&lt;ul>
&lt;li>虚方法表中存放着各个方法的实际入口地址，如果某个方法没有被子类方法重写，那子类方法表中该方法的入口地址 = 父类方法表中该方法的入口地址；&lt;/li>
&lt;li>使用这个方法表索引代替在元数据中查找；&lt;/li>
&lt;li>该方法表会在类加载的连接阶段初始化好。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>通俗的讲，动态分派就是通过方法的接收者这种动态的东西来判断到底调用哪个方法的过程。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>总结一下：静态分派看左面，动态分派看右面。&lt;/p>
&lt;/blockquote>
&lt;h3 id="单分派与多分派">单分派与多分派&lt;/h3>
&lt;p>除了静态分派和动态分派这种分派分类方式，还有一种根据宗量分类的方式，可以将方法分派分为单分派和多分派。&lt;/p>
&lt;blockquote>
&lt;p>宗量：方法的接收者 &amp;amp; 方法的参数。&lt;/p>
&lt;/blockquote>
&lt;p>Java 语言的静态分派属于多分派，根据 &lt;strong>方法接收者的静态类型&lt;/strong> 和 &lt;strong>方法参数类型&lt;/strong> 两个宗量进行选择。&lt;/p>
&lt;p>Java 语言的动态分派属于单分派，只根据 &lt;strong>方法接收者的实际类型&lt;/strong> 一个宗量进行选择。&lt;/p>
&lt;h2 id="动态类型语言支持">动态类型语言支持&lt;/h2>
&lt;p>&lt;strong>什么是动态类型语言？&lt;/strong>&lt;/p>
&lt;p>就是类型检查的主体过程在运行期，而非编译期的编程语言。&lt;/p>
&lt;p>&lt;strong>动/静态类型语言各自的优点？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>动态类型语言：灵活性高，开发效率高。&lt;/li>
&lt;li>静态类型语言：编译器提供了严谨的类型检查，类型相关的问题能在编码的时候就发现。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Java虚拟机层面提供的动态类型支持：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>invokedynamic&lt;/code> 指令&lt;/li>
&lt;li>java.lang.invoke 包&lt;/li>
&lt;/ul>
&lt;h3 id="javalanginvoke-包">java.lang.invoke 包&lt;/h3>
&lt;p>&lt;strong>目的：&lt;/strong> 在之前的依靠符号引用确定调用的目标方法的方式之外，提供了 MethodHandle 这种动态确定目标方法的调用机制。&lt;/p>
&lt;h4 id="methodhandle-的使用">MethodHandle 的使用&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>获得方法的参数描述，第一个参数是方法返回值的类型，之后的参数是方法的入参：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MethodType&lt;/span> &lt;span class="n">mt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MethodType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">methodType&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>获取一个普通方法的调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 需要的参数：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 1. 被调用方法所属类的类对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 2. 方法名
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 3. MethodType 对象 mt
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 4. 调用该方法的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">MethodHandle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lookup&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">findVirtual&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">receiver&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="s">&amp;#34;方法名&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mt&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">bindTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">receiver&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>获取一个父类方法的调用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 需要的参数：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 1. 被调用方法所属类的类对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 2. 方法名
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 3. MethodType 对象 mt
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 4. 调用这个方法的类的类对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">MethodHandle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lookup&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">findSpecial&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">GrandFather&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;方法名&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mt&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">getClass&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>通过 &lt;code>MethodHandle mh&lt;/code> 执行方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">invoke() 和 invokeExact() 的区别：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">- invokeExact() 要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">- invoke() 允许更加松散的调用方式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mh&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello world&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mh&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">invokeExact&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello world&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>使用示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MethodHandleTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ClassA&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">Throwable&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> obj的静态类型是Object，是没有println方法的，所以尽管obj的实际类型都包含println方法，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 它还是不能调用println方法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Object&lt;/span> &lt;span class="n">obj&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ClassA&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> invoke()和invokeExact()的区别：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> - invokeExact()要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> - invoke()允许更加松散的调用方式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">getPrintlnMH&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello world&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">getPrintlnMH&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">invokeExact&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello world&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">MethodHandle&lt;/span> &lt;span class="nf">getPrintlnMH&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">receiver&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">throws&lt;/span> &lt;span class="n">NoSuchMethodException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IllegalAccessException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* MethodType代表方法类型，第一个参数是方法返回值的类型，之后的参数是方法的入参 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MethodType&lt;/span> &lt;span class="n">mt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MethodType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">methodType&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> lookup()方法来自于MethodHandles.lookup，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">MethodHandles&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lookup&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">findVirtual&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">receiver&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="s">&amp;#34;println&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mt&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">bindTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">receiver&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>MethodHandles.lookup 中 3 个方法对应的字节码指令：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>findStatic()&lt;/code>：对应 invokestatic&lt;/li>
&lt;li>&lt;code>findVirtual()&lt;/code>：对应 invokevirtual &amp;amp; invokeinterface&lt;/li>
&lt;li>&lt;code>findSpecial()&lt;/code>：对应 invokespecial&lt;/li>
&lt;/ul>
&lt;h4 id="methodhandle-和-reflection-的区别">MethodHandle 和 Reflection 的区别&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>本质区别：&lt;/strong> 它们都在模拟方法调用，但是
&lt;ul>
&lt;li>Reflection 模拟的是 Java 代码层次的调用；&lt;/li>
&lt;li>MethodHandle 模拟的是字节码层次的调用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>包含信息的区别：&lt;/strong>
&lt;ul>
&lt;li>Reflection 的 Method 对象包含的信息多，包括：方法签名、方法描述符、方法的各种属性的Java端表达方式、方法执行权限等；&lt;/li>
&lt;li>MethodHandle 对象包含的信息比较少，既包含与执行该方法相关的信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="invokedynamic-指令">&lt;code>invokedynamic&lt;/code> 指令&lt;/h3>
&lt;p>Lambda 表达式就是通过 &lt;code>invokedynamic&lt;/code> 指令实现的。&lt;/p></description></item><item><title>02-虚拟机字节码执行引擎_02-基于栈的字节码解释执行引擎</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_02-%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_02-%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</guid><description>&lt;h1 id="基于栈的字节码解释执行引擎">基于栈的字节码解释执行引擎&lt;/h1>
&lt;p>这个栈，就是栈帧中的操作数栈。&lt;/p>
&lt;h2 id="解释执行">解释执行&lt;/h2>
&lt;p>先通过 javac 将代码编译成字节码，虚拟机再通过加载字节码文件，解释执行字节码文件生成机器码，解释执行的流程如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>词法分析 -&amp;gt; 语法分析 -&amp;gt; 形成抽象语法树 -&amp;gt; 遍历语法树生成线性字节码指令流
&lt;/code>&lt;/pre>&lt;h2 id="指令集分类">指令集分类&lt;/h2>
&lt;h3 id="基于栈的指令集">基于栈的指令集&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>可移植：寄存器由硬件直接提供，程序如果直接依赖这些硬件寄存器，会不可避免的受到硬件的约束；&lt;/li>
&lt;li>代码更紧凑：字节码中每个字节对应一条指令，多地址指令集中还需要存放参数；&lt;/li>
&lt;li>编译器实现更简单：不需要考虑空间分配问题，所需的空间都在栈上操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点：&lt;/strong> 执行速度稍慢&lt;/p>
&lt;ul>
&lt;li>完成相同的功能，需要更多的指令，因为出入栈本身就产生相当多的指令；&lt;/li>
&lt;li>频繁的栈访问导致频繁的内存访问，对于处理器而言，内存是执行速度的瓶颈。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>示例：&lt;/strong> 两数相加&lt;/p>
&lt;pre tabindex="0">&lt;code>iconst_1 // 把常量1入栈
iconst_1
iadd // 把栈顶两元素出栈相加，结果入栈
istore_0 // 把栈顶值存入第0个Slot中
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h3 id="基于寄存器的指令集">基于寄存器的指令集&lt;/h3>
&lt;p>&lt;strong>示例：&lt;/strong> 两数相加&lt;/p>
&lt;pre tabindex="0">&lt;code>mov eax, 1
add eax, 1
&lt;/code>&lt;/pre>&lt;h2 id="执行过程分析">执行过程分析&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Architecture&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> calc函数的字节码分析：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> public int calc();
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> descriptor: ()I
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> flags: ACC_PUBLIC
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Code:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> stack=2, locals=4, args_size=1 // stack=2，说明需要深度为2的操作数栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> // locals=4，说明需要4个Slot的局部变量表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 0: bipush 100 // 将单字节的整型常数值push到操作数栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 2: istore_1 // 将操作数栈顶的整型值出栈并存放到第一个局部变量Slot中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 3: sipush 200
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 6: istore_2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 7: sipush 300
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 10: istore_3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 11: iload_1 // 将局部变量表第一个Slot中的整型值复制到操作数栈顶
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 12: iload_2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 13: iadd // 将操作数栈中头两个元素出栈并相加，将结果重新入栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 14: iload_3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 15: imul // 将操作数栈中头两个元素出栈并相乘，将结果重新入栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 16: ireturn // 返回指令，结束方法执行，将操作数栈顶的整型值返回给此方法的调用者
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">calc&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">300&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Architecture&lt;/span> &lt;span class="n">architecture&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Architecture&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">architecture&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">calc&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>附录0-实现Java类的热替换</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E9%99%84%E5%BD%950-%E5%AE%9E%E7%8E%B0java%E7%B1%BB%E7%9A%84%E7%83%AD%E6%9B%BF%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/2.java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E9%99%84%E5%BD%950-%E5%AE%9E%E7%8E%B0java%E7%B1%BB%E7%9A%84%E7%83%AD%E6%9B%BF%E6%8D%A2/</guid><description>&lt;h1 id="实现-java-类的热替换">实现 Java 类的热替换&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#%e5%ae%9e%e7%8e%b0-java-%e7%b1%bb%e7%9a%84%e7%83%ad%e6%9b%bf%e6%8d%a2">实现 Java 类的热替换&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%83%ad%e6%9b%bf%e6%8d%a2%e5%8f%8a%e5%85%b6%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">什么是热替换及其实现原理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84-java-%e7%b1%bb%e7%83%ad%e6%9b%bf%e6%8d%a2">实现简单的 Java 类热替换&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e9%9c%80%e6%b1%82%e5%88%86%e6%9e%90">需求分析&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%ae%9e%e7%8e%b0%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8">实现类加载器&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="什么是热替换及其实现原理">什么是热替换及其实现原理&lt;/h2>
&lt;ul>
&lt;li>热替换是在不停止正在运行的系统的情况下进行类（对象）的升级替换；&lt;/li>
&lt;li>这要求虚拟机中要存在同一个类的两个不同版本。可我们知道，我们是无法将同一个类加载两遍的，想要实现这点，我们需要让虚拟机认为这是两个不同的类，即用两个不同的类加载器去加载这个类不同版本的 class 文件；&lt;/li>
&lt;li>因此，这个工作就不能由系统提供给我们的启动类加载器，扩展类加载器或者应用程序类加载器来完成，因为这三个类加载器在同一个虚拟机中只有一份，不仅如此，我们还要跳过这些类加载器；&lt;/li>
&lt;li>想要跳过这些类加载器可不是只要不用这些类加载器就行了，还需要我们跳过双亲委派模型，否则类的加载还会被委派到这些个类加载器，如果恰好某个类之前是由这三个类加载器中的一个加载的，虚拟机就不会再次加载新版本的类了，就无法实现类的热替换了。&lt;/li>
&lt;/ul>
&lt;h2 id="实现简单的-java-类热替换">实现简单的 Java 类热替换&lt;/h2>
&lt;h3 id="需求分析">需求分析&lt;/h3>
&lt;p>现有一 Foo 类，可以在控制台持续打印：Hello world! version one，我们将在该类运行时，将其 .class 文件替换为修改后的 Foo 类的 .class 文件，修改后的 Foo 会在控制台持续打印：Hello world! version two。也就是说，替换之后，控制台打印的内容发生变化，就说明类的热替换实现成功。&lt;/p>
&lt;p>Foo 类的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Foo&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Hello world! version one&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// System.out.println(&amp;#34;Hello world! version two&amp;#34;); // 之后替换成这个
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们通过如下程序运行 Foo 类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Task&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">TimerTask&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">basePath&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;C:\\Users\\Bean\\IdeaProjects\\USTJ\\target\\classes&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每执行一次任务都 new 一个新的类加载器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">HotswapClassLoader&lt;/span> &lt;span class="n">cl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HotswapClassLoader&lt;/span>&lt;span class="o">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">basePath&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">[]{&lt;/span>&lt;span class="s">&amp;#34;com.jvm.ch7.hotswap.Foo&amp;#34;&lt;/span>&lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通过我们自己实现的类加载器加载 Foo 类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cl&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">loadClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;com.jvm.ch7.hotswap.Foo&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Object&lt;/span> &lt;span class="n">foo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">newInstance&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Method&lt;/span> &lt;span class="n">method&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getMethod&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;sayHello&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Class&lt;/span>&lt;span class="o">[]{});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">method&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">[]{});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Exception&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Timer&lt;/span> &lt;span class="n">timer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Timer&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">timer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">schedule&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Task&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="实现类加载器">实现类加载器&lt;/h3>
&lt;p>&lt;code>HotswapClassLoader&lt;/code> 的实现如下，具体的讲解已被写入注释中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">HotswapClassLoader&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">ClassLoader&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">basePath&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">HashSet&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">loadedClass&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 用来记录被这个类加载器所加载的类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">HotswapClassLoader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">basePath&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">classList&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 跳过父类加载器，把它设为null
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">basePath&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">basePath&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">loadedClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HashSet&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 该类加载器在初始化的时候会直接把应该它负责加载的类加载好，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这样之后 loadClass 时，会在第一步检验该类是否已经被加载时发现该类已经被加载过了，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 就无需执行 loadClass 之后的流程，直接返回虚拟机中被加载好的类即可，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这样虽然初始化的时间长了点，但是之后 loadClass 时会比较省时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">loadClassByMe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">classList&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 加载给定的的 classList 中的类到虚拟机
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">loadClassByMe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">classList&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">classList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Class&lt;/span> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">loadClassDirectly&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">classList&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">cls&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">loadedClass&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">classList&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 通过文件名直接加载类，得到Class对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="nf">loadClassDirectly&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">className&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Class&lt;/span> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">StringBuilder&lt;/span> &lt;span class="n">sb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">StringBuilder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">basePath&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">String&lt;/span> &lt;span class="n">classPath&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">className&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">separator&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;.class&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sb&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">separator&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">classPath&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">File&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">File&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">InputStream&lt;/span> &lt;span class="n">fin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">FileInputStream&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将字节流转化成内存中的Class对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">instantiateClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">className&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">fin&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">file&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">cls&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">IOException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">fin&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">close&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">IOException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 将字节流转化成内存中的Class对象啊，使用defineClass方法！
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="nf">instantiateClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">InputStream&lt;/span> &lt;span class="n">fin&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">buffer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">defineClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">IOException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">fin&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">close&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">IOException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 覆盖原有的loadClass规则，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="nf">loadClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">resolve&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">ClassNotFoundException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Class&lt;/span> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 应该由 HotswapClassLoader 负责加载的类会通过下面这一行得到类的 Class 对象，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 因为早在 HotswapClassLoader 类加载器执行构造函数时，它们就被加载好了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findLoadedClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 只有在这个类没有被加载，且！这个类不是当前这个类加载器负责加载的时候，才去使用启动类加载器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">cls&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">loadedClass&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findSystemClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">cls&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// resolveClass是进行连接操作的，即&amp;#34;验证+准备+解析&amp;#34;，之后就可以进行初始化了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">resolve&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resolveClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cls&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">cls&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>