<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>3.虚拟机性能监控及故障处理 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link><atom:link href="https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><description>3.虚拟机性能监控及故障处理</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>3.虚拟机性能监控及故障处理</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link></image><item><title>00-常用虚拟机性能监控工具</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/00-%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/00-%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</guid><description>&lt;h1 id="常用虚拟机性能监控工具">常用虚拟机性能监控工具&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7">常用虚拟机性能监控工具&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#jdk-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">JDK 命令行工具&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E8%A1%A5%E5%85%85ps-%E5%91%BD%E4%BB%A4-linux">补充：&lt;code>ps&lt;/code> 命令 (Linux)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="jdk-命令行工具">JDK 命令行工具&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/understanding-the-jvm/JDK%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%b7%a5%e5%85%b7.png" alt="JDK命令行工具.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其中的重中之重是 jstat 命令！而它最常用的参数就是 -gcutil，使用格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">jstat -gcutil &lt;span class="o">[&lt;/span>pid&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>intervel&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>count&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>S0&lt;/code>：堆上 Survivor space 0 区已使用空间的百分比&lt;/li>
&lt;li>&lt;code>S1&lt;/code>：堆上 Survivor space 1 区已使用空间的百分比&lt;/li>
&lt;li>&lt;code>E&lt;/code>：堆上 Eden 区已使用空间的百分比&lt;/li>
&lt;li>&lt;code>O&lt;/code>：堆上 Old space 区已使用空间的百分比&lt;/li>
&lt;li>&lt;code>P&lt;/code>：堆上 Perm space 区已使用空间的百分比&lt;/li>
&lt;li>&lt;code>YGC&lt;/code>：从程序启动到采样时发生的 Minor GC 次数&lt;/li>
&lt;li>&lt;code>YGCT&lt;/code>：从程序启动到采样时 Minor GC 所用的时间&lt;/li>
&lt;li>&lt;code>FGC&lt;/code>：从程序启动到采样时发生的 Full GC 次数&lt;/li>
&lt;li>&lt;code>FGCT&lt;/code>：从程序启动到采样时 Full GC 所用的时间&lt;/li>
&lt;li>&lt;code>GCT&lt;/code>：从程序启动到采样时 GC 的总时间&lt;/li>
&lt;/ul>
&lt;h2 id="补充ps-命令-linux">补充：&lt;code>ps&lt;/code> 命令 (Linux)&lt;/h2>
&lt;p>对于 &lt;code>jps&lt;/code> 命令，其实没必要使用，一般使用 Linux 里的 &lt;code>ps&lt;/code> 就够了，&lt;code>ps&lt;/code> 为我们提供了当前进程状态的一次性的查看，它所提供的查看结果并不动态连续的，如果想对进程时间监控，应该用 &lt;code>top&lt;/code> 工具。&lt;/p>
&lt;p>&lt;strong>Linux 上进程的 5 种状态&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>运行 [R, Runnable]：正在运行或者在运行队列中等待；&lt;/li>
&lt;li>中断 [S, Sleep]：休眠中, 受阻, 在等待某个条件的形成或接受到信号；&lt;/li>
&lt;li>不可中断 [D]：收到信号不唤醒和不可运行, 进程必须等待直到有中断发生；&lt;/li>
&lt;li>僵死 [Z, zombie]：进程已终止, 但进程描述符存在, 直到父进程调用 wait4() 系统调用后释放；&lt;/li>
&lt;li>停止 [T, Traced or stop]：进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">ps -A &lt;span class="c1"># 列出所有进程信息（非详细信息）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ps aux &lt;span class="c1"># 列出所有进程的信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ps aux &lt;span class="p">|&lt;/span> grep zsh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ps -ef &lt;span class="c1"># 显示所有进程信息，连同命令行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ps -ef &lt;span class="p">|&lt;/span> grep zsh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ps -u root &lt;span class="c1"># 显示指定用户信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ps -l &lt;span class="c1"># 列出这次登录bash相关信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ps axjf &lt;span class="c1"># 同时列出进程树状信息&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>01-JVM常见参数设置</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/01-jvm%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/01-jvm%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</guid><description>&lt;h1 id="jvm-常见参数设置">JVM 常见参数设置&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#jvm-%e5%b8%b8%e8%a7%81%e5%8f%82%e6%95%b0%e8%ae%be%e7%bd%ae">JVM 常见参数设置&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%86%85%e5%ad%98%e8%ae%be%e7%bd%ae">内存设置&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%8f%82%e6%95%b0">参数&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e8%ae%be%e7%bd%ae%e7%bb%8f%e9%aa%8c">设置经验&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%e6%94%b6%e9%9b%86%e5%99%a8%e8%ae%be%e7%bd%ae">收集器设置&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e5%8f%82%e6%95%b0-1">参数&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="内存设置">内存设置&lt;/h2>
&lt;h3 id="参数">参数&lt;/h3>
&lt;ul>
&lt;li>&lt;code>-Xms&lt;/code>：初始堆大小，JVM 启动的时候，给定堆空间大小。&lt;/li>
&lt;li>&lt;code>-Xmx&lt;/code>：最大堆大小，如果初始堆空间不足的时候，最大可以扩展到多少。&lt;/li>
&lt;li>&lt;code>-Xmn&lt;/code>：设置年轻代大小。&lt;code>整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小&lt;/code>。持久代一般固定大小为 64M，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8。&lt;/li>
&lt;li>&lt;code>-Xss&lt;/code>： 设置每个线程的 Java 栈大小。JDK 5 后每个线程 Java 栈大小为 1M。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。&lt;/li>
&lt;li>&lt;code>-XX:NewRatio=n&lt;/code>：设置年轻代和年老代的比值。如为 3，表示年轻代与年老代比值为 1:3。&lt;/li>
&lt;li>&lt;code>-XX:MaxTenuringThreshold&lt;/code>：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用（即 Minor GC 过后有大量对象存活的应用），可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。&lt;/li>
&lt;/ul>
&lt;h3 id="设置经验">设置经验&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>开发过程的测试应用，要求物理内存大于 4G&lt;/p>
&lt;pre tabindex="0">&lt;code>-Xmx3550m
-Xms3550m
-Xmn2g
-Xss128k
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>高并发本地测试使用，大对象相对较多（如 IO 流）&lt;/p>
&lt;pre tabindex="0">&lt;code>Xmx3550m
-Xms3550m
-Xss128k
-XX:NewRatio=4
-XX:SurvivorRatio=4
-XX:MaxPermSize=160m
-XX:MaxTenuringThreshold=0
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>环境： 16G 物理内存，高并发服务，重量级对象中等（线程池，连接池等），常用对象比例为 40%（即运行过程中产生的对象 40% 是生命周期较长的）&lt;/p>
&lt;pre tabindex="0">&lt;code>-Xmx10G
-Xms10G
-Xss1M
-XX:NewRatio=3
-XX:SurvivorRatio=4
-XX:MaxPermSize=2048m
-XX:MaxTenuringThreshold=5
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="收集器设置">收集器设置&lt;/h2>
&lt;h3 id="参数-1">参数&lt;/h3>
&lt;ul>
&lt;li>收集器设置
&lt;ul>
&lt;li>&lt;code>-XX:+UseSerialGC&lt;/code>：设置串行收集器，年轻带收集器。&lt;/li>
&lt;li>&lt;code>-XX:+UseParallelGC&lt;/code>：设置并行收集器。&lt;/li>
&lt;li>&lt;code>-XX:+UseParNewGC&lt;/code>：设置年轻代为并行收集。可与 CMS 收集同时使用。JDK 5.0 以上，JVM 会根据系统配置自行设置，所以无需再设置此值。&lt;/li>
&lt;li>&lt;code>-XX:+UseParallelOldGC&lt;/code>：设置并行年老代收集器，JDK6.0 支持对年老代并行收集。&lt;/li>
&lt;li>&lt;code>-XX:+UseConcMarkSweepGC&lt;/code>：设置年老代并发收集器，测试中配置这个以后，&lt;code>-XX:NewRatio&lt;/code> 的配置失效，原因不明。所以，此时年轻代大小最好用 &lt;code>-Xmn&lt;/code> 设置。&lt;/li>
&lt;li>&lt;code>-XX:+UseG1GC&lt;/code>：设置 G1 收集器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>并行收集器参数设置
&lt;ul>
&lt;li>&lt;code>-XX:ParallelGCThreads=n&lt;/code>：设置并行收集器收集时最大线程数使用的 CPU 数。并行收集线程数。&lt;/li>
&lt;li>&lt;code>-XX:MaxGCPauseMillis=n&lt;/code>：设置并行收集最大暂停时间，单位毫秒。&lt;/li>
&lt;li>&lt;code>-XX:GCTimeRatio=n&lt;/code>：设置垃圾回收时间占程序运行时间的百分比。&lt;/li>
&lt;li>&lt;code>-XX:+UseAdaptiveSizePolicy&lt;/code>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的 Survivor 区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。&lt;/li>
&lt;li>&lt;code>-XX:CMSFullGCsBeforeCompaction=n&lt;/code>：由于 CMS 不对内存空间进行压缩、整理，所以运行一段时间以后会产生&amp;quot;碎片&amp;quot;，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。&lt;/li>
&lt;li>&lt;code>-XX:+UseCMSCompactAtFullCollection&lt;/code>：打开对年老代的压缩。可能会影响性能，但是可以消除碎片。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>02-虚拟机调优案例分析</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/999.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2016-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA.md/3.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</guid><description>&lt;h1 id="虚拟机调优案例分析">虚拟机调优案例分析&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%b0%83%e4%bc%98%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90">虚拟机调优案例分析&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%e9%ab%98%e6%80%a7%e8%83%bd%e7%a1%ac%e4%bb%b6%e4%b8%8a%e7%9a%84%e7%a8%8b%e5%ba%8f%e9%83%a8%e7%bd%b2%e7%ad%96%e7%95%a5">高性能硬件上的程序部署策略&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%9c%8d%e5%8a%a1%e7%b3%bb%e7%bb%9f%e7%bb%8f%e5%b8%b8%e5%87%ba%e7%8e%b0%e5%8d%a1%e9%a1%bffull-gc-%e6%97%b6%e9%97%b4%e5%a4%aa%e9%95%bf">服务系统经常出现卡顿（Full GC 时间太长）&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e9%99%a4%e4%ba%86-java-%e5%a0%86%e5%92%8c%e6%b0%b8%e4%b9%85%e4%bb%a3%e4%b9%8b%e5%a4%96%e4%bc%9a%e5%8d%a0%e7%94%a8%e8%be%83%e5%a4%9a%e5%86%85%e5%ad%98%e7%9a%84%e5%8c%ba%e5%9f%9f">除了 Java 堆和永久代之外，会占用较多内存的区域&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e4%bb%8e-gc-%e8%b0%83%e4%bc%98%e8%a7%92%e5%ba%a6%e8%a7%a3%e5%86%b3%e6%96%b0%e7%94%9f%e4%bb%a3%e5%ad%98%e6%b4%bb%e5%a4%a7%e9%87%8f%e5%af%b9%e8%b1%a1%e9%97%ae%e9%a2%98minor-gc-%e6%97%b6%e9%97%b4%e5%a4%aa%e9%95%bf">从 GC 调优角度解决新生代存活大量对象问题（Minor GC 时间太长）&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="高性能硬件上的程序部署策略">高性能硬件上的程序部署策略&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://ngte-superbed.oss-cn-beijing.aliyuncs.com/book/understanding-the-jvm/%e9%ab%98%e6%80%a7%e8%83%bd%e7%a1%ac%e4%bb%b6%e4%b8%8a%e7%9a%84%e7%a8%8b%e5%ba%8f%e9%83%a8%e7%bd%b2%e7%ad%96%e7%95%a5.png" alt="高性能硬件上的程序部署策略.png" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>补充：64 位虚拟机&lt;/strong>&lt;/p>
&lt;p>在 Java EE 方面，企业级应用经常需要使用超过 4GB 的内存，此时，32 位虚拟机将无法满足需求，可是 64 位虚拟机虽然可以设置更大的内存，却存在以下缺点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内存问题：&lt;/strong> 由于指针膨胀和各种数据类型对齐补白的原因，运行于 64 位系统上的 Java 应用程序需要消耗更多的内存，通常要比 32 位系统额外增加 10% ~ 30% 的内存消耗。&lt;/li>
&lt;li>&lt;strong>性能问题：&lt;/strong> 64 位虚拟机的运行速度在各个测试项中几乎全面落后于 32 位虚拟机，两者大概有 15% 左右的性能差距。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="服务系统经常出现卡顿full-gc-时间太长">服务系统经常出现卡顿（Full GC 时间太长）&lt;/h2>
&lt;p>首先 &lt;code>jstat -gcutil&lt;/code> 观察 GC 的耗时，&lt;code>jstat -gccapacity&lt;/code> 检查内存用量（也可以加上 &lt;code>-verbose:gc&lt;/code> 参数获取 GC 的详细日志），发现卡顿是由于 Full GC 时间太长导致的，然后 &lt;code>jinfo -v pid&lt;/code>，查看虚拟机参数设置，发现 &lt;code>-XX:NewRatio=9&lt;/code>，这就是原因：&lt;/p>
&lt;ul>
&lt;li>新生代太小，对象提前进入老年代，触发 Full GC&lt;/li>
&lt;li>老年代较大，一次 Full GC 时间较长&lt;/li>
&lt;/ul>
&lt;p>可以调小 NewRatio 的值，尽肯能让比较少的对象进入老年代。&lt;/p>
&lt;h2 id="除了-java-堆和永久代之外会占用较多内存的区域">除了 Java 堆和永久代之外，会占用较多内存的区域&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>区域&lt;/th>
&lt;th>大小调整 / 说明&lt;/th>
&lt;th>内存不足时抛出的异常&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>直接内存&lt;/td>
&lt;td>&lt;code>-XX:MaxDirectMemorySize&lt;/code>&lt;/td>
&lt;td>OutOfMemoryError: Direct buffer memory&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>线程堆栈&lt;/td>
&lt;td>&lt;code>-Xss&lt;/code>&lt;/td>
&lt;td>StackOverflowError 或 OutOfMemoryError: unable to create new native thread&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Socket 缓存区&lt;/td>
&lt;td>每个 Socket 连接都有 Receive(37KB) 和 Send(25KB) 两个缓存区&lt;/td>
&lt;td>IOException: Too many open files&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>JNI 代码&lt;/td>
&lt;td>如果代码中使用 JNI 调用本地库，那本地库使用的内存也不在堆中&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>虚拟机和 GC&lt;/td>
&lt;td>虚拟机、GC 代码执行要消耗一定内存&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="从-gc-调优角度解决新生代存活大量对象问题minor-gc-时间太长">从 GC 调优角度解决新生代存活大量对象问题（Minor GC 时间太长）&lt;/h2>
&lt;ul>
&lt;li>将 Survivor 空间去除，让新生代中存活的对象在第一次 Minor GC 后立刻进入老年代，等到 Full GC 时再清理。&lt;/li>
&lt;li>参数调整方法：
&lt;ul>
&lt;li>&lt;code>-XX:SurvivorRatio=65536&lt;/code>&lt;/li>
&lt;li>&lt;code>-XX:MaxTenuringThreshold=0&lt;/code>&lt;/li>
&lt;li>&lt;code>-XX:AlwaysTenure&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>