<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>埋点与插桩 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%8F%92%E6%A1%A9/</link><atom:link href="https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%8F%92%E6%A1%A9/index.xml" rel="self" type="application/rss+xml"/><description>埋点与插桩</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>埋点与插桩</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%8F%92%E6%A1%A9/</link></image><item><title>埋点与插桩</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%8F%92%E6%A1%A9/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%8F%92%E6%A1%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%8F%92%E6%A1%A9/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%8F%92%E6%A1%A9/</guid><description>&lt;h1 id="埋点与插桩">埋点与插桩&lt;/h1>
&lt;h1 id="非侵入式埋点">非侵入式埋点&lt;/h1>
&lt;p>运行时代码诊断，首先需要考虑的就是如何将埋点代码嵌入至业务代码中；常见做法主要有四种：侵入式埋点、运行时增强、编译时增强、中间件增强，后三种都属于非侵入式埋点，埋点性能逐步提升。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>侵入式埋点：每个业务方都需要主动感知或唤起埋点代码，仅适用于小范围内部产品，不宜大范围推广。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运行时增强：程序运行时动态拦截，如 Spring AOP、jvm-sandbox。优点是动态可插拔，控制灵活；缺点是有运行时额外开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>编译时增强：程序编译时进行增强，如 AspectJ、ASM。优点是几乎没有运行时额外开销；缺点是需要额外的构建步骤，启动比较慢。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>中间件增强：在各个中间件服务中嵌入埋点代码。优点是原生代码，没有任何额外开销；缺点是需使用统一的中间件服务。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="调用拦截">调用拦截&lt;/h1>
&lt;p>调用拦截的目的是为了明确&lt;strong>线程监听的对象与生命周期&lt;/strong>。传统的线程诊断，由于没有明确的监听对象与生命周期，只能进行全局线程的随机监听，不但浪费了大量的系统资源，还经常遗漏关键调用的线程信息。&lt;/p>
&lt;h1 id="性能诊断">性能诊断&lt;/h1>
&lt;p>性能诊断主要有插桩（Instrumentation）和采样（Sampling）两种实现方式，前者开销较高，后者结果有一定误差。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>插桩法（Instrumentation），需要在每个方法前后添加埋点，计算耗时，优点是结果准确，缺点是开销较高，需要明确目标函数，代码结构也会发生一定变化，很多在线诊断工具，如 Arthas 都是采用的这种方法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>采样法（Sampling），则是周期性获取 JVM 运行栈快照，然后通过比对方法在快照集（Snapshot Set）中出现的次数来粗略估计其运行时间。每次快照生成均需等待 JVM 运行到安全点（Safe Point），因此，运行结果有一定误差，不过，性能开销要远低于插桩法，而且能够获取完整线程栈，无需事先指定目标函数。主流的 Java Profiler 都是采用的 Sampling 方式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50535503-b95dd100-0b85-11e9-86d9-0147f3229bad.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item></channel></rss>