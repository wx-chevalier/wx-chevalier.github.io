<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>99.参考资料 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/mat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link><atom:link href="https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/mat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml"/><description>99.参考资料</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>99.参考资料</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/mat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link></image><item><title>2020-hprof 文件分析工具：JVM 内存分析工具 MAT</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/mat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-hprof-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7jvm-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-mat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/mat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-hprof-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7jvm-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-mat/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_39850150/article/details/111250003" target="_blank" rel="noopener">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="hprof-文件分析工具jvm-内存分析工具-mat">hprof 文件分析工具：JVM 内存分析工具 MAT&lt;/h1>
&lt;p>MAT(Memory Analyzer Tools)是一个快速且功能丰富的 Java 堆分析器，可帮助您查找内存泄漏并减少内存消耗。使用 MAT 分析具有数亿个对象的高效堆转储，快速计算对象的保留大小，查看谁阻止垃圾收集器收集对象，运行报告以自动提取泄漏嫌疑者。&lt;/p>
&lt;h1 id="1-简介">1 简介&lt;/h1>
&lt;p>MAT 是一款非常强大的内存分析工具，在 Eclipse 中有相应的插件，同时也有单独的安装包。在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件，通过 MAT 打开就可以直观地看到当前的内存信息。&lt;/p>
&lt;h1 id="2-使用">2 使用&lt;/h1>
&lt;h2 id="21-准备-mat">2.1 准备 MAT&lt;/h2>
&lt;p>下载独立版本的 MAT，下载地址：https://www.eclipse.org/mat/downloads.php，下载后解压。找到 MemoryAnalyzer.ini 文件，该文件里面有个 Xmx 参数，该参数表示最大内存占用量，默认为 1024m，根据堆转储文件大小修改该参数即可。&lt;/p>
&lt;h2 id="22-准备堆转储文件heap-dump">2.2 准备堆转储文件(Heap Dump)&lt;/h2>
&lt;p>堆转储文件(Heap Dump)是 Java 进程在某个时间内的快照(.hprof 格式)。它在触发快照的时候保存了很多信息，如：Java 对象和类信息(通常在写堆转储文件前会触发一次 Full GC)。堆转储文件信息：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154117.png" alt="堆转储文件信息" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。&lt;/li>
&lt;li>所有的类信息，包括 classloader、类名称、父类、静态变量等。&lt;/li>
&lt;li>GC Root 到所有的这些对象的引用路径。&lt;/li>
&lt;li>线程信息，包括线程的调用栈及此线程的线程局部变量(TLS)。&lt;/li>
&lt;/ul>
&lt;p>多种方式获取堆转储文件：&lt;/p>
&lt;ul>
&lt;li>通过 jmap 命令可以在 cmd 里执行：jmap -dump:format=b,file= 。&lt;/li>
&lt;li>如果想在发生内存溢出的时候自动 dump，需要添加下面 JVM 参数：-XX:+HeapDumpOnOutOfMemoryError。&lt;/li>
&lt;li>使用 Ctrl+Break 组合键主动获取获取，需要添加下面 JVM 参数：-XX:+HeapDumpOnCtrlBreak。&lt;/li>
&lt;li>使用 HPROF Agent 可以在程序执行结束时或受到 SIGOUT 信号时生成 Dump 文件，配置在虚拟机的参数如下：-agentlib:hprof=heap=dump,format=b。&lt;/li>
&lt;li>使用 JConsole 获取。&lt;/li>
&lt;li>使用 Memory Analyzer Tools 的 File -&amp;gt; Acquire Heap Dump 功能获取。&lt;/li>
&lt;/ul>
&lt;h2 id="23-分析堆转储文件">2.3 分析堆转储文件&lt;/h2>
&lt;p>打开 MAT 之后，加载 dump 文件，差不多就下面这样的界面：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154413.png" alt="MAT 界面" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>常用的两个功能：Histogram、 Leak Suspects。&lt;/p>
&lt;h3 id="231-histogram">2.3.1 Histogram&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154450.png" alt="Histogram 示意" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Histogram 可以列出内存中的对象，对象的个数及其内存大小，可以用来定位哪些对象在 Full GC 之后还活着，哪些对象占大部分内存。&lt;/p>
&lt;ul>
&lt;li>Class Name：类名称，Java 类名。&lt;/li>
&lt;li>Objects：类的对象的数量，这个对象被创建了多少个。&lt;/li>
&lt;li>Shallow Heap：对象本身占用内存的大小，不包含其引用的对象内存，实际分析中作用不大。常规对象(非数组)的 Shallow Size 由其成员变量的数量和类型决定。数组的 Shallow Size 由数组元素的类型(对象类型、基本类型)和数组长度决定。对象成员都是些引用，真正的内存都在堆上，看起来是一堆原生的 byte[], char[], int[]，对象本身的内存都很小。&lt;/li>
&lt;li>Retained Heap：计算方式是将 Retained Set(当该对象被回收时那些将被 GC 回收的对象集合)中的所有对象大小叠加。或者说，因为 X 被释放，导致其它所有被释放对象(包括被递归释放的)所占的 heap 大小。Retained Heap 可以更精确的反映一个对象实际占用的大小。&lt;/li>
&lt;/ul>
&lt;p>Retained Heap 例子：一个 ArrayList 对象持有 100 个对象，每一个占用 16 bytes，如果这个 list 对象被回收，那么其中 100 个对象也可以被回收，可以回收 &lt;code>16*100 + X&lt;/code> 的内存，X 代表 ArrayList 的 shallow 大小。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154537.png" alt="Histogram 下钻示意" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在上述列表中选择一个 Class，右键选择 List objects &amp;gt; with incoming references，在新页面会显示通过这个 class 创建的对象信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154604.png" alt="Path to GCRoots" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>继续选择一个对象，右键选择 Path to GC Roots &amp;gt; &lt;code>****&lt;/code> ，通常在排查**内存泄漏(一般是因为存在无效的引用)**的时候，我们会选择 exclude all phantom/weak/soft etc.references，意思是查看排除虚引用/弱引用/软引用等的引用链，因为被虚引用/弱引用/软引用的对象可以直接被 GC 给回收，我们要看的就是某个对象否还存在 Strong 引用链(在导出 Heap Dump 之前要手动触发 GC 来保证)，如果有，则说明存在内存泄漏，然后再去排查具体引用。&lt;/p>
&lt;p>这时会拿到 GC Roots 到该对象的路径，通过对象之间的引用，可以清楚的看出这个对象没有被回收的原因，然后再去定位问题。如果上面对象此时本来应该是被 GC 掉的，简单的办法就是将其中的某处置为 null 或者 remove 掉，使其到 GC Root 无路径可达，处于不可触及状态，垃圾回收器就可以回收了。反之，一个存在 GC Root 的对象是不会被垃圾回收器回收掉的。&lt;/p>
&lt;h3 id="232-leak-suspects">2.3.2 Leak Suspects&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154849.png" alt="Leak Suspects" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Leak Suspects 可以自动分析并提示可能存在的内存泄漏，可以直接定位到 Class 及对应的行数。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154913.png" alt="java.lang.Class" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>比如：这里问题一的描述，列出了一些比较大的实例。点击 Details 可以看到细节信息，另外还可点击 See stacktrace 查看具体的线程栈信息(可直接定位到具体某个类中的方法)。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406154944.png" alt="详情" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在 Details 详情页面 Shortest Paths To the Accumulation Point 表示 GC root 到内存消耗聚集点的最短路径，如果某个内存消耗聚集点有路径到达 GC root，则该内存消耗聚集点不会被当做垃圾被回收。&lt;/p>
&lt;blockquote>
&lt;p>实战：在某项目中，其中几个 Tomcat 响应特别慢，打开 Java VisualVM 观察 Tomcat(pid xxx)-Visual GC 发现 Spaces-Old 升高，Graphs-GC Time 比较频繁且持续时间长、有尖峰(重启后过段时间又出现了)，最后通过 Leak Suspects 中的 See stacktrace 定位到某个查询接口，仔细排查代码后发现有个 BUG：在特定查询条件下会一次性查询几万的数据出来(因为脏数据)，处理过后恢复正常。&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406155029.png" alt="Visual VM" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="233-内存快照对比">2.3.3 内存快照对比&lt;/h3>
&lt;p>为了更有效率的找出内存泄露的对象，一般会获取两个堆转储文件(先 dump 一个，隔段时间再 dump 一个)，通过对比后的结果可以很方便定位。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230406155106.png" alt="内存快照对比" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item></channel></rss>