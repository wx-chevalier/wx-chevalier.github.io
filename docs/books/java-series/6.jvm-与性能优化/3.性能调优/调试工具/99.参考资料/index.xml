<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>99.参考资料 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link><atom:link href="https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml"/><description>99.参考资料</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>99.参考资料</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link></image><item><title>2020-heibaiying-JVM 性能监控之可视化工具</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-jvm-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B9%8B%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-jvm-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B9%8B%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</guid><description>&lt;h1 id="jvm-性能监控之可视化工具">JVM 性能监控之可视化工具&lt;/h1>
&lt;h2 id="一简介">一、简介&lt;/h2>
&lt;p>在 JDK 安装目录的 &lt;code>bin&lt;/code> 文件夹下，除了提供有命令行监控工具外，还提供了几种可视化的监控工具，以方便用户直观地了解虚拟机的运行状态。常用的可视化监控工具如下：&lt;/p>
&lt;h2 id="二jconsole">二、JConsole&lt;/h2>
&lt;h3 id="21-简介">2.1 简介&lt;/h3>
&lt;p>JConsole（Java Monitoring and Management Console）是一款基于 JMX（Java Manage-ment Extensions）的可视化监视工具。它的主要功能是通过 JMX 的 MBean（Managed Bean）对系统信息进行收集和动态调整系统参数。JMX（Java Management Extensions）是一个为应用程序、设备、系统等植入管理功能的框架，通常用于监控系统的运行状态或管理系统的部分功能。&lt;/p>
&lt;h3 id="22-使用">2.2 使用&lt;/h3>
&lt;p>打开位于 bin 目录下的 &lt;code>jconsole&lt;/code> 程序后，它会自动扫描当前主机上的所有 JVM 进程：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jconsole-start.png"/> &lt;/div>
&lt;p>选中需要监控的进程后，点击连接，即可进入监控界面。监控界面包含了 &lt;em>概览&lt;/em>、&lt;em>内存&lt;/em>、&lt;em>线程&lt;/em>、&lt;em>类&lt;/em>、&lt;em>VM 概要&lt;/em>、&lt;em>MBean&lt;/em> 六个选项卡。其中概览界面显示的是 &lt;em>内存&lt;/em>、&lt;em>线程&lt;/em>、&lt;em>类&lt;/em> 等三个选项卡界面的概览信息，如下所示：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jconsole-概览.png"/> &lt;/div>
&lt;p>而内存界面主要用于显示堆和非堆上各个区域的使用量：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jconsole-内存.png"/> &lt;/div>
&lt;p>线程界面内主要显示各个线程的堆栈信息，最下角有一个 &lt;strong>检测死锁&lt;/strong> 按钮，点击后如果检测到死锁存在，则在下部的线程选项卡旁边会出现死锁选项卡：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jconsole-检测死锁.png"/> &lt;/div>
&lt;p>点击死锁选项卡则可以看到造成死锁的线程：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jconsole-死锁.png"/> &lt;/div>
&lt;p>最后的 &lt;strong>类&lt;/strong> 选项卡主要用于显示当前已加载和已卸载的类的数量。而 &lt;strong>VM 概要&lt;/strong> 选项卡则主要用于显示虚拟机的相关参数，如下所示：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jconsole-概要.png"/> &lt;/div>
&lt;h2 id="三visualvm">三、VisualVM&lt;/h2>
&lt;h3 id="31-简介">3.1 简介&lt;/h3>
&lt;p>VisualVM（All-in-One Java Troubleshooting Tool）是 Oracle 提供的功能最强大的运行监视和故障处理程序之一， 它除了支持常规的运行监视、故障处理等功能外，还能用于性能分析（Profiling）。同时因为 VisualVM 是基于 NetBeans 平台的开发工具，所以它还支持通过插件来进行功能的拓展。VisualVM 的主要功能如下：&lt;/p>
&lt;ul>
&lt;li>显示虚拟机进程及其配置信息、环境信息（与 jps、jinfo 功能类似）；&lt;/li>
&lt;li>监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息（与 jstat、jstack 功能类似）；&lt;/li>
&lt;li>dump 以及分析堆转储快照（与 jmap、jhat 功能类似）；&lt;/li>
&lt;li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法；&lt;/li>
&lt;li>离线程序快照：可以收集程序的运行时配置、线程 dump、内存 dump 等信息来建立快照。&lt;/li>
&lt;/ul>
&lt;h3 id="32-使用">3.2 使用&lt;/h3>
&lt;p>打开位于 bin 目录下的 &lt;code>jvisualvm&lt;/code> 程序， 它会自动扫描当前主机上的所有 JVM 进程：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual.png"/> &lt;/div>
&lt;p>点击需要监控的进程后，右侧即会显示相关的监控信息：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-监视.png"/> &lt;/div>
&lt;p>&lt;strong>1. 堆 Dump&lt;/strong>&lt;/p>
&lt;p>在监控界面点击按钮可以 &lt;strong>执行垃圾回收&lt;/strong> 或者 &lt;strong>堆 Dump&lt;/strong> 。进行堆 Dump 后，还会显示其分析结果：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-堆dump.png"/> &lt;/div>
&lt;p>&lt;strong>2. 线程 Dump&lt;/strong>&lt;/p>
&lt;p>在线程界面可以查看所有线程的状态，如果出现死锁，该界面还会进行提示：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-线程.png"/> &lt;/div>
&lt;p>此时可以进行 &lt;strong>线程 Dump&lt;/strong> 来获取具体的线程信息，效果和 jstack 命令类似：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-dump.png"/> &lt;/div>
&lt;p>&lt;strong>3. 性能分析&lt;/strong>&lt;/p>
&lt;p>在 Profiler 界面，可以进行 CPU 和 内存的性能分析。要开始性能分析，需要先选择 &lt;strong>CPU&lt;/strong> 或 &lt;strong>内存&lt;/strong> 按钮中的一个，VisualVM 将会开始记录应用程序执行过的所有方法：如果是进行的是 CPU 执行时间分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析，则会统计每个方法关联的对象数以及这些对象所占的空间。想要结束性能分析，点击停止按钮即可：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-性能分析.png"/> &lt;/div>
&lt;p>&lt;strong>4. Visual GC&lt;/strong>&lt;/p>
&lt;p>Visual GC 面板默认是不显示的，需要通过插件进行扩展。它会实时监控虚拟机的状态，在功能上类似于 jstat 命令：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-gc.png"/> &lt;/div>
&lt;h3 id="33-安装插件">3.3 安装插件&lt;/h3>
&lt;p>在主界面，点击 &lt;strong>工具 =&amp;gt; 插件&lt;/strong> ，可以打开插件面板。右击插件选项或者点击安装按钮即可完成对应插件的安装：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-插件安装.png"/> &lt;/div>
&lt;p>需要注意的是，安装插件前需要按照自己 JVM 的版本来配置插件中心，否则会抛出 ”无法连接到插件中心“ 的异常。每个版本对应的插件中心可以在该网址上查看：https://visualvm.github.io/pluginscenters.html，界面如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-插件中心.png"/> &lt;/div>
&lt;p>之后需要将正确的插件中心的地址配置到程序中：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-配置插件中心.png"/> &lt;/div>
&lt;h2 id="四连接远程进程">四、连接远程进程&lt;/h2>
&lt;p>以上演示 JConsole 和 VisualVM 时，我们都是用的本地进程，但在实际开发中，我们更多需要监控的是服务器上的远程进程。想要监控远程主机上的进程，需要进行 JMX 的相关配置，根据连接时是否需要用户名和密码，可以分为以下两种配置方式：&lt;/p>
&lt;h3 id="41-不使用安全凭证">4.1 不使用安全凭证&lt;/h3>
&lt;p>启动服务器上的 Java 进程时增加以下参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl"> java -Dcom.sun.management.jmxremote.port&lt;span class="o">=&lt;/span>&lt;span class="m">12345&lt;/span> &lt;span class="c1">#jmx远程连接的端口号&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> -Dcom.sun.management.jmxremote.ssl&lt;span class="o">=&lt;/span>&lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> -Dcom.sun.management.jmxremote.authenticate&lt;span class="o">=&lt;/span>&lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> -jar springboot.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时只需要知道主机地址和端口号就可以连接，不需要使用用户名和密码，所以安全性比较低。&lt;/p>
&lt;h3 id="42-使用安全凭证">4.2 使用安全凭证&lt;/h3>
&lt;p>启动服务器上的 Java 进程时增加以下参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">java -Dcom.sun.management.jmxremote.port&lt;span class="o">=&lt;/span>&lt;span class="m">12345&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-Dcom.sun.management.jmxremote.ssl&lt;span class="o">=&lt;/span>&lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-Dcom.sun.management.jmxremote.authenticate&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-Dcom.sun.management.jmxremote.access.file&lt;span class="o">=&lt;/span>/usr/local/jmxremote.access
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-Dcom.sun.management.jmxremote.password.file&lt;span class="o">=&lt;/span>/usr/local/jmxremote.password
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-jar springboot.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>jmxremote.access &lt;/code> 的内容如下，其中 admin 为用户名，readwrite 表示可读可写，也可以设置为 readonly（只读）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">admin readwrite
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>jmxremote.password&lt;/code> 的内容如下，其中 admin 为用户名，123456 为密码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">admin &lt;span class="m">123456&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>两个文件创建好后，还需要赋予其执行权限：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">chmod &lt;span class="m">600&lt;/span> /usr/local/jmxremote.access
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chmod &lt;span class="m">600&lt;/span> /usr/local/jmxremote.password
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chown root:root /usr/local/jmxremote.access
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chown root:root /usr/local/jmxremote.password
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后在使用 VisualVM 进行远程连接时，配置如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jvisual-连接远程主机.png"/> &lt;/div>
&lt;p>需要注意的是这里的端口号是配置的 &lt;code>Dcom.sun.management.jmxremote.port&lt;/code> 的值，而不是 Java 程序的端口号。连接完成后，即可查看到对应进程的监控状态。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ol>
&lt;li>主要参考自：周志明 . 深入理解 Java 虚拟机（第 3 版）. 机械工业出版社 , 2019-12 ，想要深入了解虚拟机的话，推荐阅读原书。&lt;/li>
&lt;li>visualvm 官方文档：https://visualvm.github.io/documentation.html&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/gossip/p/6141941.html" target="_blank" rel="noopener">Java_jvisualvm 使用 JMX 连接远程机器（实践）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://my.oschina.net/mye/blog/64879" target="_blank" rel="noopener">使用 JMX 透过防火墙远程监控 tomcat 服务&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>2020-heibaiying-JVM 性能监控之命令行工具</title><link>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-jvm-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/6.jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-jvm-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>&lt;h1 id="jvm-性能监控之命令行工具">JVM 性能监控之命令行工具&lt;/h1>
&lt;h2 id="一简介">一、简介&lt;/h2>
&lt;p>在 JDK 安装目录的 &lt;code>bin&lt;/code> 文件夹下，除了提供有 &lt;code>javac&lt;/code> 、&lt;code>java&lt;/code> 这两个常用的编译和运行工具外，还提供了一系列命令行工具用于 JVM 的性能监控和故障诊断，常用的命令如下：&lt;/p>
&lt;h2 id="二jps">二、jps&lt;/h2>
&lt;p>jps（JVM Process Status Tool）用于列出正在运行的虚拟机进程的主类名称和 LVMID（Local Virtual Machine Identifier，本地虚拟机唯一标识），这里得到的 LVMID 是进行后续其它查询的基础。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">C:/Users&amp;gt;jps
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">10848&lt;/span> Main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">14560&lt;/span> Jps
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">7040&lt;/span> Launcher
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">11572&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">9492&lt;/span> DeadLockTest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">7868&lt;/span> JConsole
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可选参数有 &lt;code>-v&lt;/code> ，用于输出虚拟机进程启动时的 JVM 参数。&lt;/p>
&lt;h2 id="三jstat">三、jstat&lt;/h2>
&lt;p>jstat（JVM Statistics Monitoring Tool）用于监视虚拟机的运行状态。使用格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">jstat -&amp;lt;option&amp;gt; &lt;span class="o">[&lt;/span>-t&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-h&amp;lt;lines&amp;gt;&lt;span class="o">]&lt;/span> &amp;lt;vmid&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;interval&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;count&amp;gt;&lt;span class="o">]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>option&lt;/code> 的所有可选值如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>选项&lt;/th>
&lt;th>作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-class&lt;/td>
&lt;td>监视类加载、卸载数量、总空间以及类装载所耗费的时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gc&lt;/td>
&lt;td>监视 Java 堆状况，包括 Eden 区、2 个 Survivor 区、老年代的容量、已用空间、垃圾收集时间等信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gccapacity&lt;/td>
&lt;td>与 -gc 基本相同，但主要关注的是 Java 堆各个区域使用到的最大、最小空间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gcutil&lt;/td>
&lt;td>与 -gc 基本相同，但主要关注的是已使用空间占总空间的百分比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gccause&lt;/td>
&lt;td>与 -gcutil 基本相同，但是会额外输出上一次垃圾回收的原因&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gcnew&lt;/td>
&lt;td>监视新生代垃圾回收的状况&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gcnewcapacity&lt;/td>
&lt;td>与 -gcnew 基本相同，但主要关注的是使用到的最大、最小空间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gcold&lt;/td>
&lt;td>监视老年代垃圾回收的状况&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-gcoldcapacity&lt;/td>
&lt;td>与 -gcold 基本相同，但主要关注的是使用到的最大、最小空间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-compiler&lt;/td>
&lt;td>输出即时编译器编译过的方法、耗时等信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-printcompilation&lt;/td>
&lt;td>输出已经被即时编译的方法&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>命令行中的 &lt;code>interval&lt;/code> 表示监控的时间间隔，&lt;code>count&lt;/code> 表示监控次数。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">jstat -gc &lt;span class="m">9492&lt;/span> 3s &lt;span class="m">5&lt;/span> &lt;span class="c1"># 每3s输出一次，一共输出5次&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jstat_gc.png"/> &lt;/div>
&lt;p>输出信息中各个参数含义分别如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>S0C&lt;/strong>：survivor 0 的容量大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>S1C&lt;/strong>：survivor 1 的容量大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>S0U&lt;/strong>：survivor 0 已使用的空间大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>S1U&lt;/strong>：survivor 1 已使用的空间大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>EC&lt;/strong>：Eden 区的容量大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>EU&lt;/strong>：Eden 区已使用的空间大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>OC&lt;/strong>：老年代的容量大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>OU&lt;/strong>：老年代已使用的空间大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>MC&lt;/strong>：Metaspace 容量大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>MU&lt;/strong>：Metaspace 已使用的空间大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>CCSC&lt;/strong>：压缩类的空间大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>CCSU&lt;/strong>：压缩类已使用的空间大小，单位 kB；&lt;/li>
&lt;li>&lt;strong>YGC&lt;/strong>：年轻代垃圾回收的次数；&lt;/li>
&lt;li>&lt;strong>YGCT&lt;/strong>： 年轻代垃圾回收所消耗的时间；&lt;/li>
&lt;li>&lt;strong>FGC&lt;/strong>：老年代垃圾回收的次数；&lt;/li>
&lt;li>&lt;strong>FGCT&lt;/strong>：老年代垃圾回收所消耗的时间；&lt;/li>
&lt;li>&lt;strong>GCT&lt;/strong>：垃圾回收所消耗的总时间。&lt;/li>
&lt;/ul>
&lt;p>以上是 option 为 &lt;code>-gc&lt;/code> 时的输出结果，不同 option 的输出结果是不同的，所有输出结果及其参数解释可以参考官方文章： &lt;a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html&lt;/a>&lt;/p>
&lt;h2 id="四jinfo">四、jinfo&lt;/h2>
&lt;p>jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机的各项参数。使用格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">jinfo &lt;span class="o">[&lt;/span>option&lt;span class="o">]&lt;/span> &amp;lt;pid&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>option &lt;/code> 支持以下可选项：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>-flag name&lt;/strong> ：输出指定的虚拟机参数的值；&lt;/li>
&lt;li>&lt;strong>-flag [+|-]name&lt;/strong> ：启用或禁用指定名称的虚拟机参数；&lt;/li>
&lt;li>&lt;strong>-flag name=value&lt;/strong> ：设置虚拟机参数的值；&lt;/li>
&lt;li>&lt;strong>-flags&lt;/strong> ：以键值对的方式输出 JVM 的相关属性；&lt;/li>
&lt;li>&lt;strong>-sysprops&lt;/strong>：以键值对的方式输出 Java 相关的系统属性。&lt;/li>
&lt;/ul>
&lt;p>示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">jinfo&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">flags&lt;/span> &lt;span class="mi">13604&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">jinfo&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">flag&lt;/span> &lt;span class="n">CMSInitiatingOccupancyFraction&lt;/span> &lt;span class="mi">13604&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jinfo.png"/> &lt;/div>
&lt;h2 id="五jmap">五、jmap&lt;/h2>
&lt;p>jmap（Memory Map for Java）命令主要用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。除此之外，它还可以用来查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率、当前使用的收集器等。 使用格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">jmap &lt;span class="o">[&lt;/span>option&lt;span class="o">]&lt;/span> &amp;lt;pid&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>option&lt;/code> 支持以下可选项：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>选项&lt;/th>
&lt;th>作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-dump:[live,]format=b,file=&lt;/td>
&lt;td>生成 Java 堆转储快照，其中 live 用于指明是否只 dump 出存活的对象&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-finalizerinfo&lt;/td>
&lt;td>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 平台下有效&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-heap&lt;/td>
&lt;td>显示 Java 堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在 Linux/Solaris 平台下有效&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-histo[:live]&lt;/td>
&lt;td>显示堆中对象的统计信息，包括类、实例数量、合计容量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-permstat&lt;/td>
&lt;td>以 ClassLoader 为统计口径显示永久代内存状态。只在 Linux/Solaris 平台下有效&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-F&lt;/td>
&lt;td>当虚拟机进程堆 -dump 选项没有响应时，可使用这个选项强制生成 dump 快照。&lt;br/>只在 Linux/Solaris 平台下有效&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">jmap -dump:format&lt;span class="o">=&lt;/span>b,file&lt;span class="o">=&lt;/span>test.bin &lt;span class="m">3260&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jmap.png"/> &lt;/div>
&lt;h2 id="六jhat">六、jhat&lt;/h2>
&lt;p>jhat（JVM Heap Analysis Tool）命令主要用来分析 jmap 生成的堆转储快照。 假设我们有如下一段程序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">StackOverFlowTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">StackOverFlowTest&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">InterruptedException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">StackOverFlowTest&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">//因为只是演示，所以休眠一下，避免生成的堆转储文件过大，导致分析时间过长
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其最终会抛出 &lt;code>java.lang.OutOfMemoryError: Java heap space&lt;/code> 异常，意味着在 JVM 堆上发生了内存溢出。在程序运行期间，我们可以使用上面的 jmap 命令生成堆转储快照，并使用 jhat 命令进行分析：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jhat.png"/> &lt;/div>
&lt;p>jhat 命令最终的分析结果会以网页的方式进行提供，端口为 7000，界面如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jhat_web.png"/> &lt;/div>
&lt;p>jhat 分析的结果并不够直观，因此我们还可以借助第三方工具来分析堆转储快照，这里以 JProfiler 为例，该软件可以直接从&lt;a href="https://www.ej-technologies.com/products/jprofiler/overview.htm" target="_blank" rel="noopener">官网&lt;/a>下载并安装，安装完成后，点击 &lt;code>session&lt;/code> 选项卡，并使用 &lt;code>Open Snapshot&lt;/code> 打开 jmap 命令生成的堆转储快照：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jprofiler-1.png"/> &lt;/div>
&lt;p>之后程序会自动进行分析，分析结果如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jprofiler-2.png"/> &lt;/div>
&lt;p>通过以上可视化的统计结果，我们就可以很快定位到导致内存溢出的原因。&lt;/p>
&lt;h2 id="七jstack">七、jstack&lt;/h2>
&lt;p>jstack（Stack Trace for Java）命令用于生成虚拟机的线程快照（一般称为 threaddump 或者 javacore 文件）。线程快照就是每一条线程正在执行的方法堆栈的集合，线程快照可以用于定位线程长时间停顿的原因，如死锁、死循环和长时间挂起等。其使用格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl"> jstack -F &lt;span class="o">[&lt;/span>-m&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-l&lt;span class="o">]&lt;/span> &amp;lt;pid&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>各选项的作用如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>选项&lt;/th>
&lt;th>作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-F&lt;/td>
&lt;td>当正常输出的请求不被响应时，强制输出线程堆栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-m&lt;/td>
&lt;td>除堆栈外，显示关于锁的附加信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-l&lt;/td>
&lt;td>如果有调用本地方法的话，则可以显示 C/C++ 的堆栈&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>假设我们的程序中存在如下死锁：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">DeadLockTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;a&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;b&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">new&lt;/span> &lt;span class="n">DeadLockTest&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">deadlock&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">deadlock&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}).&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}).&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时使用 jstack 分析就能很快的定位到问题所在，示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">jstack &lt;span class="m">8112&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/jstack.png"/> &lt;/div>
&lt;p>从输出中结果中可以看出，出现了一个死锁，该死锁由线程 Thread-0 和 Thread-1 导致，原因是 Thread-0 锁住了对象 &lt;code>&amp;lt;0x00000000d6d8d610&amp;gt;&lt;/code> ，并尝试获取 &lt;code>&amp;lt;0x00000000d6d8d640&amp;gt;&lt;/code> 对象的锁；但是 Thread-0 却恰恰相反，锁住了对象 &lt;code>&amp;lt;0x00000000d6d8d640&amp;gt;&lt;/code> ，并尝试获取 &lt;code>&amp;lt;0x00000000d6d8d610&amp;gt;&lt;/code> 对象的锁，由此导致死锁。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>主要参考自：周志明 . 深入理解 Java 虚拟机（第 3 版）. 机械工业出版社 , 2019-12 ，想要深入了解虚拟机的话，推荐阅读原书。&lt;/li>
&lt;li>官方文档：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/s11-troubleshooting_tools.html#sthref327&lt;/li>
&lt;/ul></description></item></channel></rss>