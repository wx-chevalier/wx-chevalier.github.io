<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>架构机制 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/</link><atom:link href="https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/index.xml" rel="self" type="application/rss+xml"/><description>架构机制</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>架构机制</title><link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/</link></image><item><title>原理浅析</title><link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</guid><description>&lt;h1 id="rxjava-原理与机制浅析">RxJava 原理与机制浅析&lt;/h1>
&lt;p>&lt;a href="http://blog.kifile.com/reactivex/2015/12/07/rx_introduce.html" target="_blank" rel="noopener">ReactiveX 框架(基于 RxJava)实现原理浅析&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://blog.csdn.net/lzyzsd/article/details/50110355" target="_blank" rel="noopener">RxJava 基本流程和 lift 源码分析 &lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.jianshu.com/p/53b79866f58a" target="_blank" rel="noopener">RxJava 原理解析&lt;/a>&lt;/p>
&lt;h1 id="subscribe">Subscribe&lt;/h1>
&lt;p>&lt;code>Observable.subscribe(Subscriber)&lt;/code> 的内部实现是这样的(仅核心代码)：&lt;/p>
&lt;pre tabindex="0">&lt;code>// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public Subscription subscribe(Subscriber subscriber) {
subscriber.onStart();
onSubscribe.call(subscriber);
return subscriber;
}
&lt;/code>&lt;/pre>&lt;p>可以看到，&lt;code>subscriber()&lt;/code> 做了 3 件事：&lt;/p>
&lt;ol>
&lt;li>调用 &lt;code>Subscriber.onStart()&lt;/code>。这个方法在前面已经介绍过，是一个可选的准备方法。&lt;/li>
&lt;li>调用 &lt;code>Observable&lt;/code> 中的 &lt;code>OnSubscribe.call(Subscriber)&lt;/code>。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中，&lt;code>Observable&lt;/code> 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 &lt;code>subscribe()&lt;/code> 方法执行的时候。&lt;/li>
&lt;li>将传入的 &lt;code>Subscriber&lt;/code> 作为 &lt;code>Subscription&lt;/code> 返回。这是为了方便 &lt;code>unsubscribe()&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>整个过程中对象间的关系如下图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg" alt="关系静图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>或者可以看动图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif" alt="关系静图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>除了 &lt;code>subscribe(Observer)&lt;/code> 和 &lt;code>subscribe(Subscriber)&lt;/code>，&lt;code>subscribe()&lt;/code> 还支持不完整定义的回调，RxJava 会自动根据定义创建出 &lt;code>Subscriber&lt;/code>。形式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>Action1&amp;lt;String&amp;gt; onNextAction = new Action1&amp;lt;String&amp;gt;() {
// onNext()
@Override
public void call(String s) {
Log.d(tag, s);
}
};
Action1&amp;lt;Throwable&amp;gt; onErrorAction = new Action1&amp;lt;Throwable&amp;gt;() {
// onError()
@Override
public void call(Throwable throwable) {
// Error handling
}
};
Action0 onCompletedAction = new Action0() {
// onCompleted()
@Override
public void call() {
Log.d(tag, &amp;#34;completed&amp;#34;);
}
};
// 自动创建 Subscriber，并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);
// 自动创建 Subscriber，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);
// 自动创建 Subscriber，并使用 onNextAction、onErrorAction 和 onCompletedAction 来定义 onNext()、onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
&lt;/code>&lt;/pre>&lt;p>简单解释一下这段代码中出现的 &lt;code>Action1&lt;/code> 和 &lt;code>Action0&lt;/code>。&lt;code>Action0&lt;/code> 是 RxJava 的一个接口，它只有一个方法 &lt;code>call()&lt;/code>，这个方法是无参无返回值的；由于 &lt;code>onCompleted()&lt;/code> 方法也是无参无返回值的，因此 &lt;code>Action0&lt;/code> 可以被当成一个包装对象，将 &lt;code>onCompleted()&lt;/code> 的内容打包起来将自己作为一个参数传入 &lt;code>subscribe()&lt;/code> 以实现不完整定义的回调。这样其实也可以看做将 &lt;code>onCompleted()&lt;/code> 方法作为参数传进了 &lt;code>subscribe()&lt;/code>，相当于其他某些语言中的闭包。&lt;code>Action1&lt;/code> 也是一个接口，它同样只有一个方法 &lt;code>call(T param)&lt;/code>，这个方法也无返回值，但有一个参数；与 &lt;code>Action0&lt;/code> 同理，由于 &lt;code>onNext(T obj)&lt;/code> 和 &lt;code>onError(Throwable error)&lt;/code> 也是单参数无返回值的，因此 &lt;code>Action1&lt;/code> 可以将 &lt;code>onNext(obj)&lt;/code> 和 &lt;code>onError(error)&lt;/code> 打包起来传入 &lt;code>subscribe()&lt;/code> 以实现不完整定义的回调。事实上，虽然 &lt;code>Action0&lt;/code> 和 &lt;code>Action1&lt;/code> 在 API 中使用最广泛，但 RxJava 是提供了多个 &lt;code>ActionX&lt;/code> 形式的接口 (例如 &lt;code>Action2&lt;/code>, &lt;code>Action3&lt;/code>) 的，它们可以被用以包装不同的无返回值的方法。&lt;/p>
&lt;blockquote>
&lt;p>注：正如前面所提到的，&lt;code>Observer&lt;/code> 和 &lt;code>Subscriber&lt;/code> 具有相同的角色，而且 &lt;code>Observer&lt;/code> 在 &lt;code>subscribe()&lt;/code> 过程中最终会被转换成 &lt;code>Subscriber&lt;/code> 对象，因此，从这里开始，后面的描述我将用 &lt;code>Subscriber&lt;/code> 来代替 &lt;code>Observer&lt;/code>，这样更加严谨。&lt;/p>
&lt;/blockquote>
&lt;h1 id="transform">Transform&lt;/h1>
&lt;p>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法: lift(Operator)。首先看一下 lift() 的内部实现(仅核心代码)：&lt;/p>
&lt;pre tabindex="0">&lt;code>// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public &amp;lt;R&amp;gt; Observable&amp;lt;R&amp;gt; lift(Operator&amp;lt;? extends R, ? super T&amp;gt; operator) {
return Observable.create(new OnSubscribe&amp;lt;R&amp;gt;() {
@Override
public void call(Subscriber subscriber) {
Subscriber newSubscriber = operator.call(subscriber);
newSubscriber.onStart();
onSubscribe.call(newSubscriber);
}
});
}
&lt;/code>&lt;/pre>&lt;p>这段代码很有意思：它生成了一个新的 &lt;code>Observable&lt;/code> 并返回，而且创建新 &lt;code>Observable&lt;/code> 所用的参数 &lt;code>OnSubscribe&lt;/code> 的回调方法 &lt;code>call()&lt;/code> 中的实现竟然看起来和前面讲过的 &lt;code>Observable.subscribe()&lt;/code> 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 &lt;code>onSubscribe.call(subscriber)&lt;/code> 中的 &lt;strong>onSubscribe 所指代的对象不同&lt;/strong>(高能预警：接下来的几句话可能会导致身体的严重不适)——&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>subscribe()&lt;/code> 中这句话的 &lt;code>onSubscribe&lt;/code> 指的是 &lt;code>Observable&lt;/code> 中的 &lt;code>onSubscribe&lt;/code> 对象，这个没有问题，但是 &lt;code>lift()&lt;/code> 之后的情况就复杂了点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当含有 &lt;code>lift()&lt;/code> 时:&lt;/p>
&lt;p>当含有 &lt;code>lift()&lt;/code> 时: 1.&lt;code>lift()&lt;/code> 创建了一个 &lt;code>Observable&lt;/code> 后，加上之前的原始 &lt;code>Observable&lt;/code>，已经有两个 &lt;code>Observable&lt;/code> 了；&lt;/p>
&lt;p>当含有 &lt;code>lift()&lt;/code> 时: 1.&lt;code>lift()&lt;/code> 创建了一个 &lt;code>Observable&lt;/code> 后，加上之前的原始 &lt;code>Observable&lt;/code>，已经有两个 &lt;code>Observable&lt;/code> 了；2.而同样地，新 &lt;code>Observable&lt;/code> 里的新 &lt;code>OnSubscribe&lt;/code> 加上之前的原始 &lt;code>Observable&lt;/code> 中的原始 &lt;code>OnSubscribe&lt;/code>，也就有了两个 &lt;code>OnSubscribe&lt;/code>；&lt;/p>
&lt;p>当含有 &lt;code>lift()&lt;/code> 时: 1.&lt;code>lift()&lt;/code> 创建了一个 &lt;code>Observable&lt;/code> 后，加上之前的原始 &lt;code>Observable&lt;/code>，已经有两个 &lt;code>Observable&lt;/code> 了；2.而同样地，新 &lt;code>Observable&lt;/code> 里的新 &lt;code>OnSubscribe&lt;/code> 加上之前的原始 &lt;code>Observable&lt;/code> 中的原始 &lt;code>OnSubscribe&lt;/code>，也就有了两个 &lt;code>OnSubscribe&lt;/code>；3.当用户调用经过 &lt;code>lift()&lt;/code> 后的 &lt;code>Observable&lt;/code> 的 &lt;code>subscribe()&lt;/code> 的时候，使用的是 &lt;code>lift()&lt;/code> 所返回的新的 &lt;code>Observable&lt;/code>，于是它所触发的 &lt;code>onSubscribe.call(subscriber)&lt;/code>，也是用的新 &lt;code>Observable&lt;/code> 中的新 &lt;code>OnSubscribe&lt;/code>，即在 &lt;code>lift()&lt;/code> 中生成的那个 &lt;code>OnSubscribe&lt;/code>；&lt;/p>
&lt;p>当含有 &lt;code>lift()&lt;/code> 时: 1.&lt;code>lift()&lt;/code> 创建了一个 &lt;code>Observable&lt;/code> 后，加上之前的原始 &lt;code>Observable&lt;/code>，已经有两个 &lt;code>Observable&lt;/code> 了；2.而同样地，新 &lt;code>Observable&lt;/code> 里的新 &lt;code>OnSubscribe&lt;/code> 加上之前的原始 &lt;code>Observable&lt;/code> 中的原始 &lt;code>OnSubscribe&lt;/code>，也就有了两个 &lt;code>OnSubscribe&lt;/code>；3.当用户调用经过 &lt;code>lift()&lt;/code> 后的 &lt;code>Observable&lt;/code> 的 &lt;code>subscribe()&lt;/code> 的时候，使用的是 &lt;code>lift()&lt;/code> 所返回的新的 &lt;code>Observable&lt;/code>，于是它所触发的 &lt;code>onSubscribe.call(subscriber)&lt;/code>，也是用的新 &lt;code>Observable&lt;/code> 中的新 &lt;code>OnSubscribe&lt;/code>，即在 &lt;code>lift()&lt;/code> 中生成的那个 &lt;code>OnSubscribe&lt;/code>；4.而这个新 &lt;code>OnSubscribe&lt;/code> 的 &lt;code>call()&lt;/code> 方法中的 &lt;code>onSubscribe&lt;/code>，就是指的原始 &lt;code>Observable&lt;/code> 中的原始 &lt;code>OnSubscribe&lt;/code>，在这个 &lt;code>call()&lt;/code> 方法里，新 &lt;code>OnSubscribe&lt;/code> 利用 &lt;code>operator.call(subscriber)&lt;/code> 生成了一个新的 &lt;code>Subscriber&lt;/code>(&lt;code>Operator&lt;/code> 就是在这里，通过自己的 &lt;code>call()&lt;/code> 方法将新 &lt;code>Subscriber&lt;/code> 和原始 &lt;code>Subscriber&lt;/code> 进行关联，并插入自己的变换代码以实现变换)，然后利用这个新 &lt;code>Subscriber&lt;/code> 向原始 &lt;code>Observable&lt;/code> 进行订阅。&lt;/p>
&lt;p>当含有 &lt;code>lift()&lt;/code> 时: 1.&lt;code>lift()&lt;/code> 创建了一个 &lt;code>Observable&lt;/code> 后，加上之前的原始 &lt;code>Observable&lt;/code>，已经有两个 &lt;code>Observable&lt;/code> 了；2.而同样地，新 &lt;code>Observable&lt;/code> 里的新 &lt;code>OnSubscribe&lt;/code> 加上之前的原始 &lt;code>Observable&lt;/code> 中的原始 &lt;code>OnSubscribe&lt;/code>，也就有了两个 &lt;code>OnSubscribe&lt;/code>；3.当用户调用经过 &lt;code>lift()&lt;/code> 后的 &lt;code>Observable&lt;/code> 的 &lt;code>subscribe()&lt;/code> 的时候，使用的是 &lt;code>lift()&lt;/code> 所返回的新的 &lt;code>Observable&lt;/code>，于是它所触发的 &lt;code>onSubscribe.call(subscriber)&lt;/code>，也是用的新 &lt;code>Observable&lt;/code> 中的新 &lt;code>OnSubscribe&lt;/code>，即在 &lt;code>lift()&lt;/code> 中生成的那个 &lt;code>OnSubscribe&lt;/code>；4.而这个新 &lt;code>OnSubscribe&lt;/code> 的 &lt;code>call()&lt;/code> 方法中的 &lt;code>onSubscribe&lt;/code>，就是指的原始 &lt;code>Observable&lt;/code> 中的原始 &lt;code>OnSubscribe&lt;/code>，在这个 &lt;code>call()&lt;/code> 方法里，新 &lt;code>OnSubscribe&lt;/code> 利用 &lt;code>operator.call(subscriber)&lt;/code> 生成了一个新的 &lt;code>Subscriber&lt;/code>(&lt;code>Operator&lt;/code> 就是在这里，通过自己的 &lt;code>call()&lt;/code> 方法将新 &lt;code>Subscriber&lt;/code> 和原始 &lt;code>Subscriber&lt;/code> 进行关联，并插入自己的变换代码以实现变换)，然后利用这个新 &lt;code>Subscriber&lt;/code> 向原始 &lt;code>Observable&lt;/code> 进行订阅。
这样就实现了 &lt;code>lift()&lt;/code> 过程，有点&lt;strong>像一种代理机制，通过事件拦截和处理实现事件序列的变换。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>精简掉细节的话，也可以这么说：在 &lt;code>Observable&lt;/code> 执行了 &lt;code>lift(Operator)&lt;/code> 方法之后，会返回一个新的 &lt;code>Observable&lt;/code>，这个新的 &lt;code>Observable&lt;/code> 会像一个代理一样，负责接收原始的 &lt;code>Observable&lt;/code> 发出的事件，并在处理后发送给 &lt;code>Subscriber&lt;/code>。&lt;/p>
&lt;p>如果你更喜欢具象思维，可以看图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcrna27j20h40d1q4f.jpg" alt="lift() 原理图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>或者可以看动图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxcu9f46g20go0cz4qp.gif" alt="lift 原理动图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>两次和多次的 &lt;code>lift()&lt;/code> 同理，如下图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcvophmj20h30hl0v3.jpg" alt="两次 lift" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>举一个具体的 &lt;code>Operator&lt;/code> 的实现。下面这是一个将事件中的 &lt;code>Integer&lt;/code> 对象转换成 &lt;code>String&lt;/code> 的例子，仅供参考：&lt;/p>
&lt;pre tabindex="0">&lt;code>observable.lift(new Observable.Operator&amp;lt;String, Integer&amp;gt;() {
@Override
public Subscriber&amp;lt;? super Integer&amp;gt; call(final Subscriber&amp;lt;? super String&amp;gt; subscriber) {
// 将事件序列中的 Integer 对象转换为 String 对象
return new Subscriber&amp;lt;Integer&amp;gt;() {
@Override
public void onNext(Integer integer) {
subscriber.onNext(&amp;#34;&amp;#34; + integer);
}
@Override
public void onCompleted() {
subscriber.onCompleted();
}
@Override
public void onError(Throwable e) {
subscriber.onError(e);
}
};
}
});
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>讲述 &lt;code>lift()&lt;/code> 的原理只是为了让你更好地了解 RxJava，从而可以更好地使用它。然而不管你是否理解了 &lt;code>lift()&lt;/code> 的原理，RxJava 都不建议开发者自定义 &lt;code>Operator&lt;/code> 来直接使用 &lt;code>lift()&lt;/code>，而是建议尽量使用已有的 &lt;code>lift()&lt;/code> 包装方法(如 &lt;code>map()&lt;/code> &lt;code>flatMap()&lt;/code> 等)进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。&lt;/p>
&lt;/blockquote></description></item></channel></rss>