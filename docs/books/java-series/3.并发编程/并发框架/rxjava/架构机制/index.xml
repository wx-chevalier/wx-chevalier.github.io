<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>架构机制 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/</link>
      <atom:link href="https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/index.xml" rel="self" type="application/rss+xml" />
    <description>架构机制</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>架构机制</title>
      <link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/</link>
    </image>
    
    <item>
      <title>原理浅析</title>
      <link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;rxjava-原理与机制浅析&#34;&gt;RxJava 原理与机制浅析&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.kifile.com/reactivex/2015/12/07/rx_introduce.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ReactiveX 框架(基于 RxJava)实现原理浅析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/lzyzsd/article/details/50110355&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RxJava 基本流程和 lift 源码分析 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/53b79866f58a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RxJava 原理解析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;subscribe&#34;&gt;Subscribe&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Observable.subscribe(Subscriber)&lt;/code&gt; 的内部实现是这样的(仅核心代码)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public Subscription subscribe(Subscriber subscriber) {
    subscriber.onStart();
    onSubscribe.call(subscriber);
    return subscriber;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，&lt;code&gt;subscriber()&lt;/code&gt; 做了 3 件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用 &lt;code&gt;Subscriber.onStart()&lt;/code&gt;。这个方法在前面已经介绍过，是一个可选的准备方法。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;Observable&lt;/code&gt; 中的 &lt;code&gt;OnSubscribe.call(Subscriber)&lt;/code&gt;。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中，&lt;code&gt;Observable&lt;/code&gt; 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 &lt;code&gt;subscribe()&lt;/code&gt; 方法执行的时候。&lt;/li&gt;
&lt;li&gt;将传入的 &lt;code&gt;Subscriber&lt;/code&gt; 作为 &lt;code&gt;Subscription&lt;/code&gt; 返回。这是为了方便 &lt;code&gt;unsubscribe()&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个过程中对象间的关系如下图：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg&#34; alt=&#34;关系静图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者可以看动图：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif&#34; alt=&#34;关系静图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;subscribe(Observer)&lt;/code&gt; 和 &lt;code&gt;subscribe(Subscriber)&lt;/code&gt;，&lt;code&gt;subscribe()&lt;/code&gt; 还支持不完整定义的回调，RxJava 会自动根据定义创建出 &lt;code&gt;Subscriber&lt;/code&gt;。形式如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Action1&amp;lt;String&amp;gt; onNextAction = new Action1&amp;lt;String&amp;gt;() {
    // onNext()
    @Override
    public void call(String s) {
        Log.d(tag, s);
    }
};
Action1&amp;lt;Throwable&amp;gt; onErrorAction = new Action1&amp;lt;Throwable&amp;gt;() {
    // onError()
    @Override
    public void call(Throwable throwable) {
        // Error handling
    }
};
Action0 onCompletedAction = new Action0() {
    // onCompleted()
    @Override
    public void call() {
        Log.d(tag, &amp;#34;completed&amp;#34;);
    }
};

// 自动创建 Subscriber，并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);
// 自动创建 Subscriber，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);
// 自动创建 Subscriber，并使用 onNextAction、onErrorAction 和 onCompletedAction 来定义 onNext()、onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单解释一下这段代码中出现的 &lt;code&gt;Action1&lt;/code&gt; 和 &lt;code&gt;Action0&lt;/code&gt;。&lt;code&gt;Action0&lt;/code&gt; 是 RxJava 的一个接口，它只有一个方法 &lt;code&gt;call()&lt;/code&gt;，这个方法是无参无返回值的；由于 &lt;code&gt;onCompleted()&lt;/code&gt; 方法也是无参无返回值的，因此 &lt;code&gt;Action0&lt;/code&gt; 可以被当成一个包装对象，将 &lt;code&gt;onCompleted()&lt;/code&gt; 的内容打包起来将自己作为一个参数传入 &lt;code&gt;subscribe()&lt;/code&gt; 以实现不完整定义的回调。这样其实也可以看做将 &lt;code&gt;onCompleted()&lt;/code&gt; 方法作为参数传进了 &lt;code&gt;subscribe()&lt;/code&gt;，相当于其他某些语言中的闭包。&lt;code&gt;Action1&lt;/code&gt; 也是一个接口，它同样只有一个方法 &lt;code&gt;call(T param)&lt;/code&gt;，这个方法也无返回值，但有一个参数；与 &lt;code&gt;Action0&lt;/code&gt; 同理，由于 &lt;code&gt;onNext(T obj)&lt;/code&gt; 和 &lt;code&gt;onError(Throwable error)&lt;/code&gt; 也是单参数无返回值的，因此 &lt;code&gt;Action1&lt;/code&gt; 可以将 &lt;code&gt;onNext(obj)&lt;/code&gt; 和 &lt;code&gt;onError(error)&lt;/code&gt; 打包起来传入 &lt;code&gt;subscribe()&lt;/code&gt; 以实现不完整定义的回调。事实上，虽然 &lt;code&gt;Action0&lt;/code&gt; 和 &lt;code&gt;Action1&lt;/code&gt; 在 API 中使用最广泛，但 RxJava 是提供了多个 &lt;code&gt;ActionX&lt;/code&gt; 形式的接口 (例如 &lt;code&gt;Action2&lt;/code&gt;, &lt;code&gt;Action3&lt;/code&gt;) 的，它们可以被用以包装不同的无返回值的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：正如前面所提到的，&lt;code&gt;Observer&lt;/code&gt; 和 &lt;code&gt;Subscriber&lt;/code&gt; 具有相同的角色，而且 &lt;code&gt;Observer&lt;/code&gt; 在 &lt;code&gt;subscribe()&lt;/code&gt; 过程中最终会被转换成 &lt;code&gt;Subscriber&lt;/code&gt; 对象，因此，从这里开始，后面的描述我将用 &lt;code&gt;Subscriber&lt;/code&gt; 来代替 &lt;code&gt;Observer&lt;/code&gt;，这样更加严谨。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;transform&#34;&gt;Transform&lt;/h1&gt;
&lt;p&gt;这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法: lift(Operator)。首先看一下 lift() 的内部实现(仅核心代码)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public &amp;lt;R&amp;gt; Observable&amp;lt;R&amp;gt; lift(Operator&amp;lt;? extends R, ? super T&amp;gt; operator) {
    return Observable.create(new OnSubscribe&amp;lt;R&amp;gt;() {
        @Override
        public void call(Subscriber subscriber) {
            Subscriber newSubscriber = operator.call(subscriber);
            newSubscriber.onStart();
            onSubscribe.call(newSubscriber);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码很有意思：它生成了一个新的 &lt;code&gt;Observable&lt;/code&gt; 并返回，而且创建新 &lt;code&gt;Observable&lt;/code&gt; 所用的参数 &lt;code&gt;OnSubscribe&lt;/code&gt; 的回调方法 &lt;code&gt;call()&lt;/code&gt; 中的实现竟然看起来和前面讲过的 &lt;code&gt;Observable.subscribe()&lt;/code&gt; 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 &lt;code&gt;onSubscribe.call(subscriber)&lt;/code&gt; 中的 &lt;strong&gt;onSubscribe 所指代的对象不同&lt;/strong&gt;(高能预警：接下来的几句话可能会导致身体的严重不适)——&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;subscribe()&lt;/code&gt; 中这句话的 &lt;code&gt;onSubscribe&lt;/code&gt; 指的是 &lt;code&gt;Observable&lt;/code&gt; 中的 &lt;code&gt;onSubscribe&lt;/code&gt; 对象，这个没有问题，但是 &lt;code&gt;lift()&lt;/code&gt; 之后的情况就复杂了点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当含有 &lt;code&gt;lift()&lt;/code&gt; 时:&lt;/p&gt;
&lt;p&gt;当含有 &lt;code&gt;lift()&lt;/code&gt; 时: 1.&lt;code&gt;lift()&lt;/code&gt; 创建了一个 &lt;code&gt;Observable&lt;/code&gt; 后，加上之前的原始 &lt;code&gt;Observable&lt;/code&gt;，已经有两个 &lt;code&gt;Observable&lt;/code&gt; 了；&lt;/p&gt;
&lt;p&gt;当含有 &lt;code&gt;lift()&lt;/code&gt; 时: 1.&lt;code&gt;lift()&lt;/code&gt; 创建了一个 &lt;code&gt;Observable&lt;/code&gt; 后，加上之前的原始 &lt;code&gt;Observable&lt;/code&gt;，已经有两个 &lt;code&gt;Observable&lt;/code&gt; 了；2.而同样地，新 &lt;code&gt;Observable&lt;/code&gt; 里的新 &lt;code&gt;OnSubscribe&lt;/code&gt; 加上之前的原始 &lt;code&gt;Observable&lt;/code&gt; 中的原始 &lt;code&gt;OnSubscribe&lt;/code&gt;，也就有了两个 &lt;code&gt;OnSubscribe&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;当含有 &lt;code&gt;lift()&lt;/code&gt; 时: 1.&lt;code&gt;lift()&lt;/code&gt; 创建了一个 &lt;code&gt;Observable&lt;/code&gt; 后，加上之前的原始 &lt;code&gt;Observable&lt;/code&gt;，已经有两个 &lt;code&gt;Observable&lt;/code&gt; 了；2.而同样地，新 &lt;code&gt;Observable&lt;/code&gt; 里的新 &lt;code&gt;OnSubscribe&lt;/code&gt; 加上之前的原始 &lt;code&gt;Observable&lt;/code&gt; 中的原始 &lt;code&gt;OnSubscribe&lt;/code&gt;，也就有了两个 &lt;code&gt;OnSubscribe&lt;/code&gt;；3.当用户调用经过 &lt;code&gt;lift()&lt;/code&gt; 后的 &lt;code&gt;Observable&lt;/code&gt; 的 &lt;code&gt;subscribe()&lt;/code&gt; 的时候，使用的是 &lt;code&gt;lift()&lt;/code&gt; 所返回的新的 &lt;code&gt;Observable&lt;/code&gt;，于是它所触发的 &lt;code&gt;onSubscribe.call(subscriber)&lt;/code&gt;，也是用的新 &lt;code&gt;Observable&lt;/code&gt; 中的新 &lt;code&gt;OnSubscribe&lt;/code&gt;，即在 &lt;code&gt;lift()&lt;/code&gt; 中生成的那个 &lt;code&gt;OnSubscribe&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;当含有 &lt;code&gt;lift()&lt;/code&gt; 时: 1.&lt;code&gt;lift()&lt;/code&gt; 创建了一个 &lt;code&gt;Observable&lt;/code&gt; 后，加上之前的原始 &lt;code&gt;Observable&lt;/code&gt;，已经有两个 &lt;code&gt;Observable&lt;/code&gt; 了；2.而同样地，新 &lt;code&gt;Observable&lt;/code&gt; 里的新 &lt;code&gt;OnSubscribe&lt;/code&gt; 加上之前的原始 &lt;code&gt;Observable&lt;/code&gt; 中的原始 &lt;code&gt;OnSubscribe&lt;/code&gt;，也就有了两个 &lt;code&gt;OnSubscribe&lt;/code&gt;；3.当用户调用经过 &lt;code&gt;lift()&lt;/code&gt; 后的 &lt;code&gt;Observable&lt;/code&gt; 的 &lt;code&gt;subscribe()&lt;/code&gt; 的时候，使用的是 &lt;code&gt;lift()&lt;/code&gt; 所返回的新的 &lt;code&gt;Observable&lt;/code&gt;，于是它所触发的 &lt;code&gt;onSubscribe.call(subscriber)&lt;/code&gt;，也是用的新 &lt;code&gt;Observable&lt;/code&gt; 中的新 &lt;code&gt;OnSubscribe&lt;/code&gt;，即在 &lt;code&gt;lift()&lt;/code&gt; 中生成的那个 &lt;code&gt;OnSubscribe&lt;/code&gt;；4.而这个新 &lt;code&gt;OnSubscribe&lt;/code&gt; 的 &lt;code&gt;call()&lt;/code&gt; 方法中的 &lt;code&gt;onSubscribe&lt;/code&gt;，就是指的原始 &lt;code&gt;Observable&lt;/code&gt; 中的原始 &lt;code&gt;OnSubscribe&lt;/code&gt;，在这个 &lt;code&gt;call()&lt;/code&gt; 方法里，新 &lt;code&gt;OnSubscribe&lt;/code&gt; 利用 &lt;code&gt;operator.call(subscriber)&lt;/code&gt; 生成了一个新的 &lt;code&gt;Subscriber&lt;/code&gt;(&lt;code&gt;Operator&lt;/code&gt; 就是在这里，通过自己的 &lt;code&gt;call()&lt;/code&gt; 方法将新 &lt;code&gt;Subscriber&lt;/code&gt; 和原始 &lt;code&gt;Subscriber&lt;/code&gt; 进行关联，并插入自己的变换代码以实现变换)，然后利用这个新 &lt;code&gt;Subscriber&lt;/code&gt; 向原始 &lt;code&gt;Observable&lt;/code&gt; 进行订阅。&lt;/p&gt;
&lt;p&gt;当含有 &lt;code&gt;lift()&lt;/code&gt; 时: 1.&lt;code&gt;lift()&lt;/code&gt; 创建了一个 &lt;code&gt;Observable&lt;/code&gt; 后，加上之前的原始 &lt;code&gt;Observable&lt;/code&gt;，已经有两个 &lt;code&gt;Observable&lt;/code&gt; 了；2.而同样地，新 &lt;code&gt;Observable&lt;/code&gt; 里的新 &lt;code&gt;OnSubscribe&lt;/code&gt; 加上之前的原始 &lt;code&gt;Observable&lt;/code&gt; 中的原始 &lt;code&gt;OnSubscribe&lt;/code&gt;，也就有了两个 &lt;code&gt;OnSubscribe&lt;/code&gt;；3.当用户调用经过 &lt;code&gt;lift()&lt;/code&gt; 后的 &lt;code&gt;Observable&lt;/code&gt; 的 &lt;code&gt;subscribe()&lt;/code&gt; 的时候，使用的是 &lt;code&gt;lift()&lt;/code&gt; 所返回的新的 &lt;code&gt;Observable&lt;/code&gt;，于是它所触发的 &lt;code&gt;onSubscribe.call(subscriber)&lt;/code&gt;，也是用的新 &lt;code&gt;Observable&lt;/code&gt; 中的新 &lt;code&gt;OnSubscribe&lt;/code&gt;，即在 &lt;code&gt;lift()&lt;/code&gt; 中生成的那个 &lt;code&gt;OnSubscribe&lt;/code&gt;；4.而这个新 &lt;code&gt;OnSubscribe&lt;/code&gt; 的 &lt;code&gt;call()&lt;/code&gt; 方法中的 &lt;code&gt;onSubscribe&lt;/code&gt;，就是指的原始 &lt;code&gt;Observable&lt;/code&gt; 中的原始 &lt;code&gt;OnSubscribe&lt;/code&gt;，在这个 &lt;code&gt;call()&lt;/code&gt; 方法里，新 &lt;code&gt;OnSubscribe&lt;/code&gt; 利用 &lt;code&gt;operator.call(subscriber)&lt;/code&gt; 生成了一个新的 &lt;code&gt;Subscriber&lt;/code&gt;(&lt;code&gt;Operator&lt;/code&gt; 就是在这里，通过自己的 &lt;code&gt;call()&lt;/code&gt; 方法将新 &lt;code&gt;Subscriber&lt;/code&gt; 和原始 &lt;code&gt;Subscriber&lt;/code&gt; 进行关联，并插入自己的变换代码以实现变换)，然后利用这个新 &lt;code&gt;Subscriber&lt;/code&gt; 向原始 &lt;code&gt;Observable&lt;/code&gt; 进行订阅。
这样就实现了 &lt;code&gt;lift()&lt;/code&gt; 过程，有点&lt;strong&gt;像一种代理机制，通过事件拦截和处理实现事件序列的变换。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精简掉细节的话，也可以这么说：在 &lt;code&gt;Observable&lt;/code&gt; 执行了 &lt;code&gt;lift(Operator)&lt;/code&gt; 方法之后，会返回一个新的 &lt;code&gt;Observable&lt;/code&gt;，这个新的 &lt;code&gt;Observable&lt;/code&gt; 会像一个代理一样，负责接收原始的 &lt;code&gt;Observable&lt;/code&gt; 发出的事件，并在处理后发送给 &lt;code&gt;Subscriber&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你更喜欢具象思维，可以看图：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcrna27j20h40d1q4f.jpg&#34; alt=&#34;lift() 原理图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者可以看动图：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxcu9f46g20go0cz4qp.gif&#34; alt=&#34;lift 原理动图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;两次和多次的 &lt;code&gt;lift()&lt;/code&gt; 同理，如下图：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcvophmj20h30hl0v3.jpg&#34; alt=&#34;两次 lift&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;举一个具体的 &lt;code&gt;Operator&lt;/code&gt; 的实现。下面这是一个将事件中的 &lt;code&gt;Integer&lt;/code&gt; 对象转换成 &lt;code&gt;String&lt;/code&gt; 的例子，仅供参考：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;observable.lift(new Observable.Operator&amp;lt;String, Integer&amp;gt;() {
    @Override
    public Subscriber&amp;lt;? super Integer&amp;gt; call(final Subscriber&amp;lt;? super String&amp;gt; subscriber) {
        // 将事件序列中的 Integer 对象转换为 String 对象
        return new Subscriber&amp;lt;Integer&amp;gt;() {
            @Override
            public void onNext(Integer integer) {
                subscriber.onNext(&amp;#34;&amp;#34; + integer);
            }

            @Override
            public void onCompleted() {
                subscriber.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }
        };
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;讲述 &lt;code&gt;lift()&lt;/code&gt; 的原理只是为了让你更好地了解 RxJava，从而可以更好地使用它。然而不管你是否理解了 &lt;code&gt;lift()&lt;/code&gt; 的原理，RxJava 都不建议开发者自定义 &lt;code&gt;Operator&lt;/code&gt; 来直接使用 &lt;code&gt;lift()&lt;/code&gt;，而是建议尽量使用已有的 &lt;code&gt;lift()&lt;/code&gt; 包装方法(如 &lt;code&gt;map()&lt;/code&gt; &lt;code&gt;flatMap()&lt;/code&gt; 等)进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>
