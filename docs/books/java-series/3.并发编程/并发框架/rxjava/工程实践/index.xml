<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>工程实践 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</link><atom:link href="https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/index.xml" rel="self" type="application/rss+xml"/><description>工程实践</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>工程实践</title><link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</link></image><item><title>线程调度</title><link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="rxjava-线程调度">RxJava 线程调度&lt;/h1>
&lt;h1 id="scheduler">Scheduler&lt;/h1>
&lt;p>&lt;code>Scheduler&lt;/code>是&lt;code>RxJava&lt;/code>的线程调度器，可以指定代码执行的线程。RxJava 内置了几种线程：&lt;/p>
&lt;ul>
&lt;li>&lt;code>AndroidSchedulers.mainThread()&lt;/code> 主线程&lt;/li>
&lt;li>&lt;code>Schedulers.immediate()&lt;/code> 当前线程，即默认&lt;code>Scheduler&lt;/code>&lt;/li>
&lt;li>&lt;code>Schedulers.newThread()&lt;/code> 启用新线程&lt;/li>
&lt;li>&lt;code>Schedulers.io()&lt;/code> IO 线程，内部是一个数量无上限的线程池，可以进行文件、数据库和网络操作。&lt;/li>
&lt;li>&lt;code>Schedulers.computation()&lt;/code> CPU 计算用的线程，内部是一个数目固定为 CPU 核数的线程池，适合于 CPU 密集型计算，不能操作文件、数据库和网络。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>subscribeOn()&lt;/code>和&lt;code>observeOn()&lt;/code>可以用来控制代码的执行线程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Observable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">create&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Observable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">OnSubscribe&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">call&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Subscriber&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span> &lt;span class="kd">super&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">subscriber&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">d&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TAG&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;OnSubscribe.call Thread -&amp;gt; &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">subscriber&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">onNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;message&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}).&lt;/span>&lt;span class="na">subscribeOn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Schedulers&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">io&lt;/span>&lt;span class="o">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">observeOn&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AndroidSchedulers&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">mainThread&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="c1">//这一句在J2EE中无法执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">.&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Subscriber&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">onCompleted&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">onError&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Throwable&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">onNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">d&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TAG&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;Subscriber.onNext Thread -&amp;gt; &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据打印出的 Log 可以得出结论：
subscribeOn()指定 OnSubscribe.call()的执行线程，即 Observable 通知 Subscriber 的线程；
observeOn()指定 Subscriber 回调的执行线程，即事件消费的线程。&lt;/p>
&lt;h1 id="links">Links&lt;/h1></description></item><item><title>应用案例</title><link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</guid><description>&lt;h1 id="基于-rxjava-的响应式编程">基于 RxJava 的响应式编程&lt;/h1>
&lt;h1 id="loading-data">Loading Data&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/" target="_blank" rel="noopener">loading-data-from-multiple-sources-with-rxjava&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>假设我需要从网络上获取一些数据。每次需要数据的时候，我都可以简单的访问网络，但是，将数据缓存到磁盘或内存则可以更有效率。&lt;/p>
&lt;p>更明确的说，我希望是这样的：
1、偶尔的从网络上获取新数据。
2、然而可以尽快的恢复数据(通过缓存网络数据的结果)。&lt;/p>
&lt;h2 id="按优先级加载有效数据">按优先级加载有效数据&lt;/h2>
&lt;p>给每一数据源(网络、磁盘和内存)一个&lt;code>Observable&lt;/code>接口，我们可以通过两个操作：&lt;code>concat()&lt;/code>和&lt;code>first()&lt;/code>，来实现一个简单的解决方案。&lt;code>concat()&lt;/code>持有多个&lt;code>Observables&lt;/code>，并且把它们连接在队列里。&lt;code>first()&lt;/code>仅从队列里中获取到第一个条目。因此，如果你使用&lt;code>concat().first()&lt;/code>可以从多个数据源中获取到第一个。&lt;/p>
&lt;pre tabindex="0">&lt;code>// Our sources (left as an exercise for the reader)
Observable&amp;lt;Data&amp;gt; memory = ...;
Observable&amp;lt;Data&amp;gt; disk = ...;
Observable&amp;lt;Data&amp;gt; network = ...;
// Retrieve the first source with data
Observable&amp;lt;Data&amp;gt; source = Observable
.concat(memory, disk, network)
.first();
&lt;/code>&lt;/pre>&lt;p>这种模式的关键是 concat()只在需要资源的时候才会订阅每个子 Observable。如果数据被缓存，就不需要通过速度慢的数据源来获取数据。注意 concat()中 Observables 数据源的顺序问题，因为它们是被一个接一个检索出来的。在实际应用场景中，我们还需要在&lt;code>first&lt;/code>中判断获取到的数据是否有效以及是否过期，只要进行简单的修正即可：&lt;/p>
&lt;pre tabindex="0">&lt;code>Observable&amp;lt;Data&amp;gt; source = Observable.concat(
sources.memory(),
sources.disk(),
sources.network()
)
.first(data -&amp;gt; data != null &amp;amp;&amp;amp; data.isUpToDate());
&lt;/code>&lt;/pre>&lt;h2 id="自动保存数据">自动保存数据&lt;/h2>
&lt;p>很显然，下一步就是保存数据源。如果，你没有将网络请求的结果保存到磁盘，将磁盘的地址保存在内存中，那就再也没法挽救啦！上面所有的代码就是让网咯请求持久化。我的解决方式是在每次发出请求的时候保存或缓存数据源：&lt;/p>
&lt;pre tabindex="0">&lt;code>Observable&amp;lt;Data&amp;gt; networkWithSave = network.doOnNext(data -&amp;gt; {
saveToDisk(data);
cacheInMemory(data);
});
Observable&amp;lt;Data&amp;gt; diskWithCache = disk.doOnNext(data -&amp;gt; {
cacheInMemory(data);
});
&lt;/code>&lt;/pre>&lt;p>现在，如果你使用&lt;code>networkWithSave&lt;/code>和&lt;code>diskWithCache&lt;/code>，数据都将会在你下载的时候自动保存。(这种策略的另外一个好处就是&lt;code>networkWithSave/diskWithCache&lt;/code>可以在任何地方使用，不仅仅在我们的多个数据源模式下。)&lt;/p>
&lt;h2 id="日志记录">日志记录&lt;/h2>
&lt;p>有时候，我们还需要记录下每次请求的命中情况，譬如有时候我们需要去测试下缓存的命中率，可以用 compose 方法来实现：&lt;/p>
&lt;pre tabindex="0">&lt;code>// Save network responses to disk and cache in memory
return observable.doOnNext(data -&amp;gt; {
disk = data;
memory = data;
})
.compose(logSource(&amp;#34;NETWORK&amp;#34;));
...
// Simple logging to let us know what each source is returning
Observable.Transformer&amp;lt;Data, Data&amp;gt; logSource(final String source) {
return dataObservable -&amp;gt; dataObservable.doOnNext(data -&amp;gt; {
if (data == null) {
System.out.println(source + &amp;#34; does not have any data.&amp;#34;);
} else if (!data.isUpToDate()) {
System.out.println(source + &amp;#34; has stale data.&amp;#34;);
} else {
System.out.println(source + &amp;#34; has the data you are looking for!&amp;#34;);
}
});
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>完整的测试代码可以参考&lt;a href="https://github.com/wx-chevalier/WXJavaToolkits/blob/master/src%2Fmain%2Fjava%2Fwx%2Ftoolkits%2Fsysproc%2Fconcurrence%2Frxjava%2Fpractice%2Fdataloading%2FSources.java" target="_blank" rel="noopener">这里&lt;/a>&lt;/p>
&lt;/blockquote></description></item></channel></rss>