<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>工程实践 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</link>
      <atom:link href="https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/index.xml" rel="self" type="application/rss+xml" />
    <description>工程实践</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>工程实践</title>
      <link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</link>
    </image>
    
    <item>
      <title>线程调度</title>
      <link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h1 id=&#34;rxjava-线程调度&#34;&gt;RxJava 线程调度&lt;/h1&gt;
&lt;h1 id=&#34;scheduler&#34;&gt;Scheduler&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Scheduler&lt;/code&gt;是&lt;code&gt;RxJava&lt;/code&gt;的线程调度器，可以指定代码执行的线程。RxJava 内置了几种线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt; 主线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Schedulers.immediate()&lt;/code&gt; 当前线程，即默认&lt;code&gt;Scheduler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Schedulers.newThread()&lt;/code&gt; 启用新线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Schedulers.io()&lt;/code&gt; IO 线程，内部是一个数量无上限的线程池，可以进行文件、数据库和网络操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Schedulers.computation()&lt;/code&gt; CPU 计算用的线程，内部是一个数目固定为 CPU 核数的线程池，适合于 CPU 密集型计算，不能操作文件、数据库和网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;subscribeOn()&lt;/code&gt;和&lt;code&gt;observeOn()&lt;/code&gt;可以用来控制代码的执行线程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Observable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Observable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;OnSubscribe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Log&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TAG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;OnSubscribe.call Thread -&amp;gt; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;currentThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;subscribeOn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Schedulers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;observeOn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AndroidSchedulers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mainThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//这一句在J2EE中无法执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;subscribe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Subscriber&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onCompleted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onError&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;Log&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TAG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Subscriber.onNext Thread -&amp;gt; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;currentThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据打印出的 Log 可以得出结论：
subscribeOn()指定 OnSubscribe.call()的执行线程，即 Observable 通知 Subscriber 的线程；
observeOn()指定 Subscriber 回调的执行线程，即事件消费的线程。&lt;/p&gt;
&lt;h1 id=&#34;links&#34;&gt;Links&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>应用案例</title>
      <link>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/java-series/3.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/rxjava/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>&lt;h1 id=&#34;基于-rxjava-的响应式编程&#34;&gt;基于 RxJava 的响应式编程&lt;/h1&gt;
&lt;h1 id=&#34;loading-data&#34;&gt;Loading Data&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;loading-data-from-multiple-sources-with-rxjava&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设我需要从网络上获取一些数据。每次需要数据的时候，我都可以简单的访问网络，但是，将数据缓存到磁盘或内存则可以更有效率。&lt;/p&gt;
&lt;p&gt;更明确的说，我希望是这样的：
1、偶尔的从网络上获取新数据。
2、然而可以尽快的恢复数据(通过缓存网络数据的结果)。&lt;/p&gt;
&lt;h2 id=&#34;按优先级加载有效数据&#34;&gt;按优先级加载有效数据&lt;/h2&gt;
&lt;p&gt;给每一数据源(网络、磁盘和内存)一个&lt;code&gt;Observable&lt;/code&gt;接口，我们可以通过两个操作：&lt;code&gt;concat()&lt;/code&gt;和&lt;code&gt;first()&lt;/code&gt;，来实现一个简单的解决方案。&lt;code&gt;concat()&lt;/code&gt;持有多个&lt;code&gt;Observables&lt;/code&gt;，并且把它们连接在队列里。&lt;code&gt;first()&lt;/code&gt;仅从队列里中获取到第一个条目。因此，如果你使用&lt;code&gt;concat().first()&lt;/code&gt;可以从多个数据源中获取到第一个。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Our sources (left as an exercise for the reader)
Observable&amp;lt;Data&amp;gt; memory = ...;
Observable&amp;lt;Data&amp;gt; disk = ...;
Observable&amp;lt;Data&amp;gt; network = ...;

// Retrieve the first source with data
Observable&amp;lt;Data&amp;gt; source = Observable
  .concat(memory, disk, network)
  .first();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种模式的关键是 concat()只在需要资源的时候才会订阅每个子 Observable。如果数据被缓存，就不需要通过速度慢的数据源来获取数据。注意 concat()中 Observables 数据源的顺序问题，因为它们是被一个接一个检索出来的。在实际应用场景中，我们还需要在&lt;code&gt;first&lt;/code&gt;中判断获取到的数据是否有效以及是否过期，只要进行简单的修正即可：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Observable&amp;lt;Data&amp;gt; source = Observable.concat(
        sources.memory(),
        sources.disk(),
        sources.network()
)
.first(data -&amp;gt; data != null &amp;amp;&amp;amp; data.isUpToDate());
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;自动保存数据&#34;&gt;自动保存数据&lt;/h2&gt;
&lt;p&gt;很显然，下一步就是保存数据源。如果，你没有将网络请求的结果保存到磁盘，将磁盘的地址保存在内存中，那就再也没法挽救啦！上面所有的代码就是让网咯请求持久化。我的解决方式是在每次发出请求的时候保存或缓存数据源：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Observable&amp;lt;Data&amp;gt; networkWithSave = network.doOnNext(data -&amp;gt; {
  saveToDisk(data);
  cacheInMemory(data);
});

Observable&amp;lt;Data&amp;gt; diskWithCache = disk.doOnNext(data -&amp;gt; {
  cacheInMemory(data);
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，如果你使用&lt;code&gt;networkWithSave&lt;/code&gt;和&lt;code&gt;diskWithCache&lt;/code&gt;，数据都将会在你下载的时候自动保存。(这种策略的另外一个好处就是&lt;code&gt;networkWithSave/diskWithCache&lt;/code&gt;可以在任何地方使用，不仅仅在我们的多个数据源模式下。)&lt;/p&gt;
&lt;h2 id=&#34;日志记录&#34;&gt;日志记录&lt;/h2&gt;
&lt;p&gt;有时候，我们还需要记录下每次请求的命中情况，譬如有时候我们需要去测试下缓存的命中率，可以用 compose 方法来实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Save network responses to disk and cache in memory
return observable.doOnNext(data -&amp;gt; {
    disk = data;
    memory = data;
})
        .compose(logSource(&amp;#34;NETWORK&amp;#34;));
...
// Simple logging to let us know what each source is returning
Observable.Transformer&amp;lt;Data, Data&amp;gt; logSource(final String source) {
    return dataObservable -&amp;gt; dataObservable.doOnNext(data -&amp;gt; {
        if (data == null) {
            System.out.println(source + &amp;#34; does not have any data.&amp;#34;);
        } else if (!data.isUpToDate()) {
            System.out.println(source + &amp;#34; has stale data.&amp;#34;);
        } else {
            System.out.println(source + &amp;#34; has the data you are looking for!&amp;#34;);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;完整的测试代码可以参考&lt;a href=&#34;https://github.com/wx-chevalier/WXJavaToolkits/blob/master/src%2Fmain%2Fjava%2Fwx%2Ftoolkits%2Fsysproc%2Fconcurrence%2Frxjava%2Fpractice%2Fdataloading%2FSources.java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>
