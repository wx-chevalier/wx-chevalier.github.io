<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Json | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/microcn-notes/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81/json/</link><atom:link href="https://ng-tech.icu/books/microcn-notes/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81/json/index.xml" rel="self" type="application/rss+xml"/><description>Json</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Json</title><link>https://ng-tech.icu/books/microcn-notes/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81/json/</link></image><item><title>JSONSchema</title><link>https://ng-tech.icu/books/microcn-notes/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81/json/jsonschema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-notes/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81/json/jsonschema/</guid><description>&lt;h1 id="jsonschema">JSONSchema&lt;/h1>
&lt;p>JSON Schema 用以标注和验证 JSON 文档的元数据的文档，可以类比于 XML Schema。相对于 JSON Schema，一个 JSON 文档就是 JSON Schema 的一个 instance。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/09/02/nP1GSs.png" alt="JSON Schema 概念" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如下是简单的 JSON Schema 的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;$schema&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://json-schema.org/draft-07/schema#&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;$id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://example.com/product.schema.json&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;title&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Product&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;description&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;A product in the catalog&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;object&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://json-schema.org/latest/json-schema-core.html#rfc.section.7" target="_blank" rel="noopener">&lt;code>$schema&lt;/code>&lt;/a> 关键字指出此模式是根据标准的特定草案编写的，出于各种原因（主要是版本控制）使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://json-schema.org/latest/json-schema-core.html#rfc.section.8.2" target="_blank" rel="noopener">&lt;code>$id&lt;/code>&lt;/a> 关键字定义架构的 URI，以及解析架构中其他 URI 引用所依据的基本 URI。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://json-schema.org/latest/json-schema-validation.html#rfc.section.10.1" target="_blank" rel="noopener">&lt;code>title&lt;/code>&lt;/a> and &lt;a href="http://json-schema.org/latest/json-schema-validation.html#rfc.section.10.1" target="_blank" rel="noopener">&lt;code>description&lt;/code>&lt;/a> 关键字仅是描述性的。它们不会对要验证的数据增加约束，用这两个关键字说明了 Schema 的意图。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.1" target="_blank" rel="noopener">&lt;code>type&lt;/code>&lt;/a> 关键字定义了对我们的 JSON 数据的第一个约束，在这种情况下，它必须是 JSON 对象。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="http://json-schema.org/learn/getting-started-step-by-step.html" target="_blank" rel="noopener">http://json-schema.org/learn/getting-started-step-by-step.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>二进制编码</title><link>https://ng-tech.icu/books/microcn-notes/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81/json/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/microcn-notes/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A0%81/json/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/</guid><description>&lt;h1 id="二进制编码">二进制编码&lt;/h1>
&lt;p>对于仅在组织内部使用的数据，使用最小公分母编码格式的压力较小。例如，可以选择更紧凑或更快的解析格式。虽然对小数据集来说，收益可以忽略不计，但一旦达到 TB 级别，数据格式的选择就会产生巨大的影响。&lt;/p>
&lt;p>JSON 比 XML 简洁，但与二进制格式一比，还是太占地方。这一事实导致大量二进制编码版本 JSON &amp;amp; XML 的出现，JSON（MessagePack，BSON，BJSON，UBJSON，BISON 和 Smile 等）（例如 WBXML 和 Fast Infoset）。这些格式已经被各种各样的领域所采用，但是没有一个像 JSON 和 XML 的文本版本那样被广泛采用。&lt;/p>
&lt;p>这些格式中的一些扩展了一组数据类型（例如，区分整数和浮点数，或者增加对二进制字符串的支持），另一方面，它们没有盖面 JSON / XML 的数据模型。特别是由于它们没有规定模式，所以它们需要在编码数据中包含所有的对象字段名称。也就是说，在下例中的 JSON 文档的二进制编码中，需要在某处包含字符串 userName，favoriteNumber 和 interest。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;userName&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Martin&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;favoriteNumber&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1337&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;interests&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;daydreaming&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;hacking&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们来看一个 MessagePack 的例子，它是一个 JSON 的二进制编码。下图显示了如果使用 MessagePack 对上例中的 JSON 文档进行编码，则得到的字节序列。前几个字节如下：&lt;/p>
&lt;ol>
&lt;li>一个字节&lt;code>0x83&lt;/code>表示接下来是&lt;strong>3&lt;/strong>个字段（低四位= &lt;code>0x03&lt;/code>）的&lt;strong>对象 object&lt;/strong>（高四位= &lt;code>0x80&lt;/code>）（如果想知道如果一个对象有 15 个以上的字段会发生什么情况，字段的数量塞不进 4 个 bit 里，那么它会用另一个不同的类型标识符，字段的数量被编码两个或四个字节）。&lt;/li>
&lt;li>第二个字节&lt;code>0xa8&lt;/code>表示接下来是&lt;strong>8&lt;/strong>字节长的字符串（最高四位= 0x08）。&lt;/li>
&lt;li>接下来八个字节是 ASCII 字符串形式的字段名称&lt;code>userName&lt;/code>。由于之前已经指明长度，不需要任何标记来标识字符串的结束位置（或者任何转义）。&lt;/li>
&lt;li>接下来的七个字节对前缀为&lt;code>0xa6&lt;/code>的六个字母的字符串值&lt;code>Martin&lt;/code>进行编码，依此类推。&lt;/li>
&lt;/ol>
&lt;p>二进制编码长度为 66 个字节，仅略小于文本 JSON 编码所取的 81 个字节（删除了空白）。所有的 JSON 的二进制编码在这方面是相似的。空间节省了一丁点（以及解析加速）是否能弥补可读性的损失，谁也说不准。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2020/02/06/1yWWAs.md.png" alt="使用MessagePack编码的记录" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item></channel></rss>