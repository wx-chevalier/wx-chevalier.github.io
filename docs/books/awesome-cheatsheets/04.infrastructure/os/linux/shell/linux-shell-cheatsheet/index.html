<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="Shell CheatSheet 一、脚本基础 1.1 创建脚本 在创建 shell 脚本时，必须在文件第一行指明要使用的 shell 。其格式为： #!/bin/bash 示例如下： #!/bin/bash date who 脚本创建完成后，还需要使用 chmod 命令赋予文件拥有者执行文件的权限： chmod u+x test1 u 表示该文件的拥有者，g 表示同"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/os/linux/shell/linux-shell-cheatsheet/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.fab3cd1900ae35687457073b2d518207.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/os/linux/shell/linux-shell-cheatsheet/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/os/linux/shell/linux-shell-cheatsheet/"><meta property="og:title" content="Linux-Shell-CheatSheet | Next-gen Tech Edu"><meta property="og:description" content="Shell CheatSheet 一、脚本基础 1.1 创建脚本 在创建 shell 脚本时，必须在文件第一行指明要使用的 shell 。其格式为： #!/bin/bash 示例如下： #!/bin/bash date who 脚本创建完成后，还需要使用 chmod 命令赋予文件拥有者执行文件的权限： chmod u+x test1 u 表示该文件的拥有者，g 表示同"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>Linux-Shell-CheatSheet | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=254e21179ce8f836cc753d24ad357a54><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">Shell</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id7468b7e117d7ce935db5ba40b4929324")' href=#id7468b7e117d7ce935db5ba40b4929324 aria-expanded=false aria-controls=id7468b7e117d7ce935db5ba40b4929324 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/04.infrastructure/os/linux/>Linux</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id7468b7e117d7ce935db5ba40b4929324 aria-expanded=false aria-controls=id7468b7e117d7ce935db5ba40b4929324><i class="fa-solid fa-angle-down" id=caret-id7468b7e117d7ce935db5ba40b4929324></i></a></div><ul class="nav docs-sidenav collapse show" id=id7468b7e117d7ce935db5ba40b4929324><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id73a7075ad6deee8dd28b403bd7dcca49")' href=#id73a7075ad6deee8dd28b403bd7dcca49 aria-expanded=false aria-controls=id73a7075ad6deee8dd28b403bd7dcca49 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/04.infrastructure/os/linux/commands/>Commands</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id73a7075ad6deee8dd28b403bd7dcca49 aria-expanded=false aria-controls=id73a7075ad6deee8dd28b403bd7dcca49><i class="fa-solid fa-angle-right" id=caret-id73a7075ad6deee8dd28b403bd7dcca49></i></a></div><ul class="nav docs-sidenav collapse" id=id73a7075ad6deee8dd28b403bd7dcca49><li class="child level"><a href=/books/awesome-cheatsheets/04.infrastructure/os/linux/commands/bash-pitfalls/>Bash Pitfalls</a></li><li class="child level"><a href=/books/awesome-cheatsheets/04.infrastructure/os/linux/commands/heibaiying-linux-commands-cheatsheet/>Heibaiying-Linux-Commands-CheatSheet</a></li><li class="child level"><a href=/books/awesome-cheatsheets/04.infrastructure/os/linux/commands/trinib-linux-commands-cheatsheet/>Trinib-Linux-Commands-CheatSheet</a></li></ul></div><li class="child level"><a href=/books/awesome-cheatsheets/04.infrastructure/os/linux/linux-cheatsheet/>Linux-CheatSheet</a></li><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id2efc8d3974a647ca499ab8d2eac73186")' href=#id2efc8d3974a647ca499ab8d2eac73186 aria-expanded=false aria-controls=id2efc8d3974a647ca499ab8d2eac73186 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/04.infrastructure/os/linux/shell/>Shell</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id2efc8d3974a647ca499ab8d2eac73186 aria-expanded=false aria-controls=id2efc8d3974a647ca499ab8d2eac73186><i class="fa-solid fa-angle-down" id=caret-id2efc8d3974a647ca499ab8d2eac73186></i></a></div><ul class="nav docs-sidenav collapse show" id=id2efc8d3974a647ca499ab8d2eac73186><li class="child level active"><a href=/books/awesome-cheatsheets/04.infrastructure/os/linux/shell/linux-shell-cheatsheet/>Linux-Shell-CheatSheet</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#一脚本基础>一、脚本基础</a><ul><li><a href=#11-创建脚本>1.1 创建脚本</a></li><li><a href=#12-显示消息>1.2 显示消息</a></li><li><a href=#13-使用变量>1.3 使用变量</a></li><li><a href=#14-数学运算>1.4 数学运算</a></li><li><a href=#15-退出脚本>1.5 退出脚本</a></li></ul></li><li><a href=#二分支语句>二、分支语句</a><ul><li><a href=#21-if-then>2.1 if-then</a></li><li><a href=#22-if-then-else>2.2 if-then-else</a></li><li><a href=#23-if-then-elif>2.3 if-then-elif</a></li><li><a href=#24-test-命令>2.4 test 命令</a></li><li><a href=#25-复合条件>2.5 复合条件</a></li><li><a href=#26-if-then-高级特性>2.6 if-then 高级特性</a></li><li><a href=#27-case>2.7 case</a></li></ul></li><li><a href=#三循环语句>三、循环语句</a><ul><li><a href=#31-for>3.1 for</a></li><li><a href=#32-while>3.2 while</a></li><li><a href=#33-until>3.3 until</a></li><li><a href=#34-break--contiune>3.4 break & contiune</a></li><li><a href=#35-处理循环的输出>3.5 处理循环的输出</a></li></ul></li><li><a href=#四处理用户输入>四、处理用户输入</a><ul><li><a href=#41-命令行参数>4.1 命令行参数</a></li><li><a href=#42-移动变量>4.2 移动变量</a></li><li><a href=#43-处理用户输入>4.3 处理用户输入</a></li></ul></li><li><a href=#五处理程序输出>五、处理程序输出</a><ul><li><a href=#51-文件描述符>5.1 文件描述符</a></li><li><a href=#52-输出重定向>5.2 输出重定向</a></li><li><a href=#53-输入重定向>5.3 输入重定向</a></li><li><a href=#54-自定义重定向>5.4 自定义重定向</a></li><li><a href=#55-阻止命令输出>5.5 阻止命令输出</a></li><li><a href=#56-创建临时文件>5.6 创建临时文件</a></li><li><a href=#57-记录输出>5.7 记录输出</a></li></ul></li><li><a href=#六创建函数>六、创建函数</a><ul><li><a href=#61-创建函数>6.1 创建函数</a></li><li><a href=#62-函数参数>6.2 函数参数</a></li><li><a href=#63-退出状态码>6.3 退出状态码</a></li><li><a href=#64-局部变量>6.4 局部变量</a></li><li><a href=#65-函数库>6.5 函数库</a></li></ul></li><li><a href=#七控制脚本>七、控制脚本</a><ul><li><a href=#71-处理信号>7.1 处理信号</a></li><li><a href=#72-后台运行>7.2 后台运行</a></li><li><a href=#73-作业控制>7.3 作业控制</a></li><li><a href=#74-定时作业>7.4 定时作业</a></li></ul></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>Linux-Shell-CheatSheet</h1><div class=article-style><h1 id=shell-cheatsheet>Shell CheatSheet</h1><h2 id=一脚本基础>一、脚本基础</h2><h3 id=11-创建脚本>1.1 创建脚本</h3><p>在创建 shell 脚本时，必须在文件第一行指明要使用的 shell 。其格式为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span></code></pre></div><p>示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>date
</span></span><span class=line><span class=cl>who
</span></span></code></pre></div><p>脚本创建完成后，还需要使用 <code>chmod</code> 命令赋予文件拥有者执行文件的权限：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>chmod</span> <span class=n>u</span><span class=o>+</span><span class=n>x</span> <span class=n>test1</span>
</span></span></code></pre></div><ul><li>u 表示该文件的拥有者，g 表示同组其他用户，o 表示该组外的其他用户，a 表示所有用户；</li><li>+ 表示增加权限、- 表示取消权限、= 表示设定唯一权限；</li><li>x 表示可执行，r 表示可读取，w 表示可写入。</li></ul><h3 id=12-显示消息>1.2 显示消息</h3><p>shell 支持使用 echo 命令来在控制台上显示文本内容，以提示用户进行相应的操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> This is a <span class=nb>test</span>
</span></span></code></pre></div><p>默认情况下，不需要使用引号来圈定所需要输出的字符，但如果待输出字符中含有单引号，则需要使用双引号进行圈定，反之亦然。示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;This is a test to see if you&#39;re paying attention&#34;</span>
</span></span></code></pre></div><p>除此之外，echo 还支持 <code>-n</code> 参数，用于将文本和命令行的输出显示在同一行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> -n <span class=s2>&#34;The time and date are: &#34;</span>
</span></span><span class=line><span class=cl>date
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>输出：the <span class=nb>time</span> and date are: 2020年 02月 18日 星期二 10:29:28 CST
</span></span></code></pre></div><h3 id=13-使用变量>1.3 使用变量</h3><p><strong>1. 用户变量</strong></p><p>用户变量可以是由字母、数字或下划线组成的长度不超过 20 的任意字符串，区分大小，采用等号进行赋值，在变量、等号和值之间不能有空格。定义完成后，可以使用 <code>$</code> 符号进行引用：</p><pre tabindex=0><code>name=heibaiying
echo $name
</code></pre><p>需要注意的是使用一个已经存在的用户变量来对新的用户变量进行赋值，仍然需要使用 <code>$</code> 符号进行引用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>value1</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=nv>value2</span><span class=o>=</span><span class=nv>$value1</span> <span class=c1>#正确</span>
</span></span><span class=line><span class=cl><span class=nv>value2</span><span class=o>=</span>value1  <span class=c1>#错误</span>
</span></span></code></pre></div><p>因为 <code>$</code> 符号已经用作引用变量，所以如果想在普通文本中使用它，则需要使用 <code>\</code> 进行转义。</p><p><strong>2. 环境变量</strong></p><p>在 shell 脚本中，除了可以使用用户自定义变量外，还可以使用系统内置的环境变量，系统内置的环境变量可以使用 <code>set</code> 命令进行查看。和自定义变量一样，引用系统变量时也需要使用 <code>$</code> 符号。</p><p><strong>3. 命令变量</strong></p><p>除了可以将普通文本内容赋值给变量外，还可以将命令的输出赋值给变量，此时可以使用两种方式来进行引用：</p><ul><li>使用反引号将整个命令圈起来；</li><li>使用 <code>$()</code> 格式。</li></ul><p>示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>date1</span><span class=o>=</span><span class=sb>`</span>date<span class=sb>`</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;1.The date and time are: &#34;</span> <span class=nv>$date1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>date2</span><span class=o>=</span><span class=k>$(</span>date<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;2.The date and time are: &#34;</span> <span class=nv>$date2</span>
</span></span></code></pre></div><h3 id=14-数学运算>1.4 数学运算</h3><p><strong>1. 基本运算</strong></p><p>在 shell 脚本中，如果想要将数学运算的结果赋值给变量，一种较为通用的方式是使用方括号表示法（ $[ operation ] ），示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>var1</span><span class=o>=</span>$<span class=o>[</span><span class=m>1</span> + 5<span class=o>]</span>   <span class=c1># 结果：6</span>
</span></span><span class=line><span class=cl><span class=nv>var2</span><span class=o>=</span>$<span class=o>[</span><span class=nv>$var1</span> * 2<span class=o>]</span>  <span class=c1># 结果：12</span>
</span></span><span class=line><span class=cl><span class=nv>var3</span><span class=o>=</span>$<span class=o>[</span><span class=nv>$var1</span> * <span class=o>(</span><span class=nv>$var2</span> - <span class=nv>$var1</span><span class=o>)]</span> <span class=c1># 结果：36</span>
</span></span></code></pre></div><p>需要注意的是 bash shell 默认只支持整数运算，不支持浮点数运算：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>var1</span><span class=o>=</span><span class=m>100</span>
</span></span><span class=line><span class=cl><span class=nv>var2</span><span class=o>=</span><span class=m>45</span>
</span></span><span class=line><span class=cl><span class=nv>var3</span><span class=o>=</span>$<span class=o>[</span><span class=nv>$var1</span> / <span class=nv>$var2</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> The final result is <span class=nv>$var3</span>  <span class=c1># 结果：2</span>
</span></span></code></pre></div><p><strong>2. 浮点数运算</strong></p><p>如果想要支持浮点数运算，可以使用内置的 bc 计算器，在命令行中输入 <code>bc</code> 命令即可打开该计算器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@node01 ~<span class=o>]</span><span class=c1># bc</span>
</span></span><span class=line><span class=cl>bc 1.06.95
</span></span><span class=line><span class=cl>Copyright 1991-1994, 1997, 1998, 2000, 2004, <span class=m>2006</span> Free Software Foundation, Inc.
</span></span><span class=line><span class=cl>This is free software with ABSOLUTELY NO WARRANTY.
</span></span><span class=line><span class=cl>For details <span class=nb>type</span> <span class=sb>`</span>warranty<span class=err>&#39;</span>.
</span></span><span class=line><span class=cl><span class=nv>scale</span> <span class=o>=</span> <span class=m>4</span>
</span></span><span class=line><span class=cl>8/3
</span></span><span class=line><span class=cl>2.6666
</span></span></code></pre></div><p>如果想要在脚本文件中使用 bc 计算器，则需要使用到命令变量，其基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>variable</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=s2>&#34;options; expression&#34;</span> <span class=p>|</span> bc<span class=k>)</span>
</span></span></code></pre></div><p>该方式通过管道运算符将 echo 的输出作为 bc 命令的输入，同时使用 <code>$()</code> 格式来引用 bc 命令的输出，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>var1</span><span class=o>=</span><span class=m>100</span>
</span></span><span class=line><span class=cl><span class=nv>var2</span><span class=o>=</span><span class=m>45</span>
</span></span><span class=line><span class=cl><span class=nv>var3</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=s2>&#34;scale=4; </span><span class=nv>$var1</span><span class=s2> / </span><span class=nv>$var2</span><span class=s2>&#34;</span> <span class=p>|</span> bc<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> The answer <span class=k>for</span> this is <span class=nv>$var3</span>  <span class=c1># 结果：2.2222</span>
</span></span></code></pre></div><p>如果你要进行的运算比较复杂，需要多行书写，此时可以使用内联输入重定向：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>var1</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=nv>var2</span><span class=o>=</span>1.5
</span></span><span class=line><span class=cl><span class=nv>var3</span><span class=o>=</span><span class=m>5</span>
</span></span><span class=line><span class=cl><span class=nv>var4</span><span class=o>=</span>2.5
</span></span><span class=line><span class=cl><span class=nv>var5</span><span class=o>=</span><span class=k>$(</span>bc <span class=s>&lt;&lt; EOF
</span></span></span><span class=line><span class=cl><span class=s>a1 = ( $var1 * $var2)
</span></span></span><span class=line><span class=cl><span class=s>b1 = ($var3 * $var4)
</span></span></span><span class=line><span class=cl><span class=s>a1 + b1
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span><span class=line><span class=cl><span class=k>)</span> <span class=c1># 结果：27.5</span>
</span></span></code></pre></div><p>这里使用 EOF 来标识了内联重定向数据的开始和结束。</p><h3 id=15-退出脚本>1.5 退出脚本</h3><p><strong>1. 退出状态码</strong></p><p>shell 中运行的每个命令在结束时都会传递给 shell 一个退出状态码（exit status），可以使用 <code>$?</code> 来查看上一个命令的退出状态码，使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># date</span>
</span></span><span class=line><span class=cl>2020年 02月 18日 星期二 11:43:42 CST
</span></span><span class=line><span class=cl><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>0</span>
</span></span></code></pre></div><p>0 表示命令成功结束，其他常用状态码如下：</p><table><thead><tr><th><strong>状态码</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>命令成功结束</td></tr><tr><td>1</td><td>一般性未知错误</td></tr><tr><td>2</td><td>不适合的 shell 命令</td></tr><tr><td>126</td><td>命令不可执行</td></tr><tr><td>127</td><td>没找到命令</td></tr><tr><td>128</td><td>无效的退出参数</td></tr><tr><td>128+x</td><td>与 Linux 信号 x 相关的严重错误</td></tr><tr><td>130</td><td>通过 Ctrl+C 终止的命令</td></tr><tr><td>255</td><td>范围之外的退出状态码</td></tr></tbody></table><p><strong>2. exit 命令</strong></p><p>默认情况下，shell 脚本会以最后一个命令的退出状态码来作为最终的退出状态码， 当然你也可以使用 exit 命令来指定最终的退出状态码，示例如下：</p><pre tabindex=0><code>exit 0
</code></pre><p>需要注意的是退出状态码的范围只能是 0~255，如果超过这个数值，则会以对 256 取余的结果来作为退出状态码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>exit</span> <span class=m>300</span> <span class=c1>#实际的退出状态码为：44</span>
</span></span></code></pre></div><h2 id=二分支语句>二、分支语句</h2><h3 id=21-if-then>2.1 if-then</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span>  <span class=nb>command</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>如果 if 后面 commond 命令的退出状态码为 0，则执行 then 部分的命令，then 后面可以是一行或多行命令。</p><h3 id=22-if-then-else>2.2 if-then-else</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span>  <span class=nb>command</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>如果 if 后面的 commond 命令的退出状态码为 0，则执行 then 部分的命令，否则执行 else 部分的命令。</p><h3 id=23-if-then-elif>2.3 if-then-elif</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span>  command1
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>elif</span> command2
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>bash shell 会依次执行 if 语句，只有第一个退出状态码是 0 的语句中的 then 部分会被执行。</p><h3 id=24-test-命令>2.4 test 命令</h3><p><code>test</code> 可以用在 if-then 的测试语句中，如果 <code>test</code> 命令中条件成立，<code>test</code> 命令就会退出并返回退出状态码 0。基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span>  <span class=nb>test</span> condition
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>bash shell 还提供了另一种条件测试方法，其效果与 test 命令相同，只需要使用方括号将测试条件包裹起来，格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> condition <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>需要注意的是第一个方括号后和第二个方括号前必须加上一个空格，否则就会报错。常见的条件测试分为以下三种：</p><p><strong>1. 数值比较</strong></p><table><thead><tr><th>比较</th><th>描述</th></tr></thead><tbody><tr><td>n1 -eq n2</td><td>检查 n1 是否与 n2 相等</td></tr><tr><td>n1 -ge n2</td><td>检查 n1 是否大于或等于 n2</td></tr><tr><td>n1 -gt n2</td><td>检查 n1 是否大于 n2</td></tr><tr><td>n1 -le n2</td><td>检查 n1 是否小于或等于 n2</td></tr><tr><td>n1 -lt n2</td><td>检查 n1 是否小于 n2</td></tr><tr><td>n1 -ne n2</td><td>检查 n1 是否不等于 n2</td></tr></tbody></table><p>示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>value1</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=nv>value2</span><span class=o>=</span><span class=m>11</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=nv>$value1</span> -eq <span class=nv>$value2</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;The values are equal&#34;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;The values are different&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p><strong>2. 字符串比较</strong></p><table><thead><tr><th>比较</th><th>描述</th></tr></thead><tbody><tr><td>str1 = str2</td><td>检查 str1 是否和 str2 相同</td></tr><tr><td>str1 != str2</td><td>检查 str1 是否和 str2 不同</td></tr><tr><td>str1 &lt; str2</td><td>检查 str1 是否比 str2 小</td></tr><tr><td>str1 > str2</td><td>检查 str1 是否比 str2 大</td></tr><tr><td>-n str1</td><td>检查 str1 的长度是否非 0</td></tr><tr><td>-z str1</td><td>检查 str1 的长度是否为 0</td></tr></tbody></table><p>字符串在进行大小比较时使用的是标准的 ASCII 顺序，但需要注意的是 <code>&lt;</code> 和 <code>></code> 符号通常会被解释为输入重定向符号和输出重定向符号，因此需要使用 <code>\</code> 对其进行转义。</p><p><strong>3. 文件比较</strong></p><table><thead><tr><th>比较</th><th>描述</th></tr></thead><tbody><tr><td>-d file</td><td>检查 file 是否存在并且是一个目录</td></tr><tr><td>-e file</td><td>检查 file 是否存在</td></tr><tr><td>-f file</td><td>检查 file 是否存在并且是一个文件</td></tr><tr><td>-r file</td><td>检查 file 是否存在并且可读</td></tr><tr><td>-s file</td><td>检查 file 是否存在并且非空</td></tr><tr><td>-w file</td><td>检查 file 是否存在并且可写</td></tr><tr><td>-x file</td><td>检查 file 是否存在并且可执行</td></tr><tr><td>-O file</td><td>检查 file 是否存在并且属于当前用户所有</td></tr><tr><td>-G file</td><td>检查 file 是否存在并且默认组与当前用户的默认组是否相同</td></tr><tr><td>file1 -nt file2</td><td>检查 file1 是否比 file2 新</td></tr><tr><td>file1 -ot file2</td><td>检查 file1 是否比 file2 旧</td></tr></tbody></table><h3 id=25-复合条件>2.5 复合条件</h3><p>除了上面的单一测试外，还可以使用逻辑运算符来组合测试：</p><ul><li><strong>&&</strong> ：等价于 and ，基本格式如下： [ condition1 ] && [ condition2 ] ；</li><li><strong>||</strong> ：等价于 or，基本格式如下：[ condition1 ] || [ condition2 ] 。</li></ul><h3 id=26-if-then-高级特性>2.6 if-then 高级特性</h3><p>bash shell 提供了两项可在 if-then 语句中使用的高级特性：</p><ul><li>用于数学表达式的双括号；</li><li>用于高级字符串处理功能的双方括号。</li></ul><p><strong>1. 使用双括号</strong></p><p>基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>((</span> expression <span class=o>))</span>
</span></span></code></pre></div><p>expression 可以是任意的数学赋值或比较表达式，除此之外还支持以下运算符：</p><table><thead><tr><th>符 号</th><th>描 述</th></tr></thead><tbody><tr><td>val++</td><td>后增</td></tr><tr><td>val&ndash;</td><td>后减</td></tr><tr><td>++val</td><td>先增</td></tr><tr><td>&ndash;val</td><td>先减</td></tr><tr><td>!</td><td>逻辑求反</td></tr><tr><td>~</td><td>位求反</td></tr><tr><td>**</td><td>幂运算</td></tr><tr><td>&#171;</td><td>左位移</td></tr><tr><td>>></td><td>右位移</td></tr><tr><td>&</td><td>位布尔和</td></tr><tr><td>|</td><td>位布尔或</td></tr><tr><td>&&</td><td>逻辑和</td></tr><tr><td>||</td><td>逻辑或</td></tr></tbody></table><p>示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>val1</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>((</span> <span class=nv>$val1</span> ** <span class=m>2</span> &gt; <span class=m>90</span> <span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=o>((</span> <span class=nv>val2</span> <span class=o>=</span> <span class=nv>$val1</span> ** <span class=m>2</span> <span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;The square of </span><span class=nv>$val1</span><span class=s2> is </span><span class=nv>$val2</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>同时由于使用了双括号，这里的 <code>></code> 符号也不需要转义。</p><p><strong>2. 使用双方括号</strong></p><p>双方括号的基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[[</span> expression <span class=o>]]</span>
</span></span></code></pre></div><p>它最主要的功能是支持字符串的模式匹配，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span> <span class=o>[[</span> <span class=nv>$USER</span> <span class=o>==</span> r* <span class=o>]]</span> <span class=c1>#匹配所有以r开头的用户</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Hello </span><span class=nv>$USER</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Sorry, I do not know you&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><h3 id=27-case>2.7 case</h3><p>case 命令会将指定的变量与不同模式进行比较，如果变量和模式相匹配，那么 shell 会执行该模式指定的命令，基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>case</span> variable in
</span></span><span class=line><span class=cl>pattern1 <span class=p>|</span> pattern2 <span class=o>)</span>  commands1 <span class=p>;;</span>
</span></span><span class=line><span class=cl>pattern3 <span class=o>)</span>  commands2 <span class=p>;;</span>
</span></span><span class=line><span class=cl>*<span class=o>)</span>  default commands <span class=p>;;</span>
</span></span><span class=line><span class=cl><span class=k>esac</span>
</span></span></code></pre></div><p>示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>city</span><span class=o>=</span>上海
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nv>$city</span> in
</span></span><span class=line><span class=cl>北京<span class=p>|</span>天津<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;华北地区&#34;</span><span class=p>;;</span>
</span></span><span class=line><span class=cl>上海<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;华东地区&#34;</span><span class=p>;;</span>
</span></span><span class=line><span class=cl>广州<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;华南地区&#34;</span><span class=p>;;</span>
</span></span><span class=line><span class=cl>*<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;其他地区&#34;</span><span class=p>;;</span>
</span></span><span class=line><span class=cl><span class=k>esac</span>
</span></span></code></pre></div><h2 id=三循环语句>三、循环语句</h2><h3 id=31-for>3.1 for</h3><p>for 命令的基本使用格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>for</span> var in list
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>for</span> letter in a b c d e f g
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> The next letter is <span class=nv>$letter</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输出</span>
</span></span><span class=line><span class=cl>The next letter is a
</span></span><span class=line><span class=cl>The next letter is b
</span></span><span class=line><span class=cl>The next letter is c
</span></span><span class=line><span class=cl>The next letter is d
</span></span><span class=line><span class=cl>The next letter is e
</span></span><span class=line><span class=cl>The next letter is f
</span></span><span class=line><span class=cl>The next letter is g
</span></span></code></pre></div><p>默认情况下，bash shell 会将下列字符当做字段分隔符：</p><ul><li>空格；</li><li>制表符；</li><li>换行符。</li></ul><p>如果你想要的采用自定义的字段分隔符，可以通过修改 IFS（internal field separator，内部字段分隔符）来进行实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>value</span><span class=o>=</span><span class=s2>&#34;a,b,c,d,e,f&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>OLDIFS</span><span class=o>=</span><span class=nv>$IFS</span>  <span class=c1># 保存原有的IFS</span>
</span></span><span class=line><span class=cl><span class=nv>IFS</span><span class=o>=</span>,  <span class=c1># 自定义IFS</span>
</span></span><span class=line><span class=cl><span class=k>for</span> letter in <span class=nv>$value</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> The next letter is <span class=nv>$letter</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl><span class=nv>IFS</span><span class=o>=</span><span class=nv>$OLDIFS</span> <span class=c1># 还原默认的IFS,防止影响其他命令的执行</span>
</span></span></code></pre></div><p>除此之外，for 命令还支持在读取目录时使用通配符，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>for</span> file in /home/rich/test/*
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>[</span> -d <span class=s2>&#34;</span><span class=nv>$file</span><span class=s2>&#34;</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$file</span><span class=s2> 是一个目录&#34;</span>
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=o>[</span> -f <span class=s2>&#34;</span><span class=nv>$file</span><span class=s2>&#34;</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$file</span><span class=s2> 是一个文件&#34;</span>
</span></span><span class=line><span class=cl>  <span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>除了上面介绍的 for 循环外，bash shell 还支持 C 语言风格的 for 循环，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>for</span> <span class=o>((</span> <span class=nv>i</span><span class=o>=</span>1<span class=p>;</span> i &lt;<span class=o>=</span> 10<span class=p>;</span> i++ <span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;The next number is </span><span class=nv>$i</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>该风格的 for 循环还支持在迭代中使用多个变量，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>for</span> <span class=o>((</span> <span class=nv>a</span><span class=o>=</span>1, <span class=nv>b</span><span class=o>=</span>10<span class=p>;</span> a &lt;<span class=o>=</span> 10<span class=p>;</span> a++, b-- <span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$a</span><span class=s2> - </span><span class=nv>$b</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><h3 id=32-while>3.2 while</h3><p>while 命令的基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>while</span> <span class=nb>test</span> commands
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>     other commands
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>var1</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> <span class=nv>$var1</span> -gt <span class=m>0</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$var1</span>
</span></span><span class=line><span class=cl>    <span class=nv>var1</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$var1</span> - <span class=m>1</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>while 命令支持使用多个测试语句，但只有最后一个测试语句的退出状态码会被用来决定循环的结束。</p><h3 id=33-until>3.3 until</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>until</span> <span class=nb>test</span> commands
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    other commands
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>var1</span><span class=o>=</span><span class=m>100</span>
</span></span><span class=line><span class=cl><span class=k>until</span> <span class=o>[</span> <span class=nv>$var1</span> -eq <span class=m>0</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$var1</span>
</span></span><span class=line><span class=cl>    <span class=nv>var1</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$var1</span> - <span class=m>25</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><h3 id=34-break--contiune>3.4 break & contiune</h3><p>和其他大多数编程语言类似，shell 支持使用 break 和 contiune 来控制循环：</p><ul><li>break 用于退出循环，默认只能跳出当前循环，如果想要跳出多层循环，可以使用 <code>break n</code> 进行指定；</li><li>contiune 用于提前结束本次循环。</li></ul><p>基本使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>for</span> var1 in <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span> <span class=m>5</span> <span class=m>6</span> <span class=m>7</span> <span class=m>8</span> <span class=m>9</span> <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>[</span> <span class=nv>$var1</span> -eq <span class=m>5</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>break</span>
</span></span><span class=line><span class=cl>  <span class=k>fi</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> <span class=s2>&#34;Iteration number: </span><span class=nv>$var1</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;循环结束&#34;</span>
</span></span></code></pre></div><h3 id=35-处理循环的输出>3.5 处理循环的输出</h3><p>想要对循环的输出进行处理，可以通过在 done 之后添加一个处理命令来实现，例如将循环的输出重定向到指定文件中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>for</span> letter in a b c d e f g
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> The next letter is <span class=nv>$letter</span>
</span></span><span class=line><span class=cl><span class=k>done</span> &gt; output.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># cat output.txt</span>
</span></span><span class=line><span class=cl>The next letter is a
</span></span><span class=line><span class=cl>The next letter is b
</span></span><span class=line><span class=cl>The next letter is c
</span></span><span class=line><span class=cl>The next letter is d
</span></span><span class=line><span class=cl>The next letter is e
</span></span><span class=line><span class=cl>The next letter is f
</span></span><span class=line><span class=cl>The next letter is g
</span></span></code></pre></div><h2 id=四处理用户输入>四、处理用户输入</h2><h3 id=41-命令行参数>4.1 命令行参数</h3><p>命令行参数允许在运行脚本时向脚本传递额外参数，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>./test <span class=m>10</span> <span class=m>20</span>
</span></span></code></pre></div><p>这些位置参数可以在程序中直接引用：<code>$0</code> 是脚本名，<code>$1</code> 是第一个参数，<code>$2</code> 是第二个参数，依次类推，直到第九个参数 <code>$9</code> ；如果命令行参数不止 9 个，则之后的变量名需要加上花括号，例如 <code>${10}</code> 。另外还需要注意以下事项：</p><ul><li>每个参数默认使用空格进行分割，如果参数值包含空格，则需要用单引号或者双引号进行包裹；</li><li>如果你在启动脚本时使用的是完整的路径，则<code>$0</code> 也会包含路径信息，此时可以使用 <code>basename $0</code> 来获取脚本名称；</li><li>命令行参数的总个数可以使用 <code>$#</code> 来获取；</li><li>如果想要访问所有参数，可以使用 <code>$*</code> 和 <code>$@</code> ，两者的区别在于：<code>$*</code> 会将命令行上的所有参数当做一个整体的单词来保存，而 <code>$@</code> 会将命令行上的所有参数当做同一个字符串中的多个独立单词来保存，示例如下：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span>
</span></span><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=k>for</span> param in <span class=s2>&#34;</span><span class=nv>$*</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;\$* Parameter #</span><span class=nv>$count</span><span class=s2> = </span><span class=nv>$param</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>count</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$count</span> + <span class=m>1</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span>
</span></span><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=k>for</span> param in <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;\$@ Parameter #</span><span class=nv>$count</span><span class=s2> = </span><span class=nv>$param</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>count</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$count</span> + <span class=m>1</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ./test.sh a b c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$*</span> Parameter <span class=c1>#1 = a b c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$@</span> Parameter <span class=c1>#1 = a</span>
</span></span><span class=line><span class=cl><span class=nv>$@</span> Parameter <span class=c1>#2 = b</span>
</span></span><span class=line><span class=cl><span class=nv>$@</span> Parameter <span class=c1>#3 = c</span>
</span></span></code></pre></div><h3 id=42-移动变量>4.2 移动变量</h3><p>bash shell 支持使用 shift 命令来移动参数。默认情况下，它会将每个参数向左移动一个位置：即变量 <code>$3</code> 的值会移到 <code>$2</code> 中，变量 <code>$2</code> 的值会移到 <code>$1</code> 中，而变量 <code>$1</code> 的值则会被删除（变量 <code>$0</code> 的值，也就是程序名，不会改变）。使用 shift 参数，可以很方便的完成参数的遍历，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> -n <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Parameter #</span><span class=nv>$count</span><span class=s2> = </span><span class=nv>$1</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>count</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$count</span> + <span class=m>1</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=nb>shift</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>输出结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ./test.sh a b c</span>
</span></span><span class=line><span class=cl>Parameter <span class=c1>#1 = a</span>
</span></span><span class=line><span class=cl>Parameter <span class=c1>#2 = b</span>
</span></span><span class=line><span class=cl>Parameter <span class=c1>#3 = c</span>
</span></span></code></pre></div><p>如果想要一次移动多个参数，可以使用 <code>shift n</code> 来实现。另外，通过 shift 还可以很方便的处理带值的选项，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> -n <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> in
</span></span><span class=line><span class=cl>    -a<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;Found the -a option&#34;</span><span class=p>;;</span>
</span></span><span class=line><span class=cl>    -b<span class=o>)</span> <span class=nv>param</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$2</span><span class=s2>&#34;</span>  <span class=c1>#当找到选项b时，则后面一个参数就是其对应的值</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> <span class=s2>&#34;Found the -b option, with parameter value </span><span class=nv>$param</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=nb>shift</span> <span class=p>;;</span>
</span></span><span class=line><span class=cl>    -c<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;Found the -c option&#34;</span><span class=p>;;</span>
</span></span><span class=line><span class=cl>    --<span class=o>)</span> <span class=nb>shift</span>
</span></span><span class=line><span class=cl>        <span class=nb>break</span> <span class=p>;;</span>
</span></span><span class=line><span class=cl>     *<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2> is not an option&#34;</span><span class=p>;;</span>
</span></span><span class=line><span class=cl>  <span class=k>esac</span>
</span></span><span class=line><span class=cl>  <span class=nb>shift</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>输出结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># ./test.sh -a -b heibaiying -d</span>
</span></span><span class=line><span class=cl>Found the -a option
</span></span><span class=line><span class=cl>Found the -b option, with parameter value heibaiying
</span></span><span class=line><span class=cl>-d is not an option
</span></span></code></pre></div><h3 id=43-处理用户输入>4.3 处理用户输入</h3><p>命令行参数主要用于初始化脚本运行，但在程序运行的过程中，你可能还需要与用户进行交互，并根据用户的输入来决定程序的走向，此时可以使用 read 命令来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>read</span> -p <span class=s2>&#34;Please enter your age: &#34;</span> age  <span class=c1># -p用于显示提示文本，用户的输入会被保存到age变量中</span>
</span></span><span class=line><span class=cl><span class=nv>days</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$age</span> * <span class=m>365</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;That makes you over </span><span class=nv>$days</span><span class=s2> days old! &#34;</span>
</span></span></code></pre></div><p>除此之外还支持使用以下参数：</p><ul><li><strong>-s</strong>：用于隐藏用户输入，即用户的输入不会显示在终端页面上，通常用在输入密码等敏感信息时；</li><li><strong>-t</strong>：用于指定等待的秒数，如果在指定时间内用户没有输入，则 read 命令会以非 0 状态码退出，示例如下：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>if</span> <span class=nb>read</span> -t <span class=m>5</span> -p <span class=s2>&#34;Please enter your name: &#34;</span> name
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Hello </span><span class=nv>$name</span><span class=s2>, welcome to my script&#34;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Sorry, too slow! &#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>read 命令除了可以用于读取终端的输入外，还可以用于读取文件的内容，通常配合 cat 命令来使用，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>cat <span class=nb>test</span> <span class=p>|</span> <span class=k>while</span> <span class=nb>read</span> line
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> <span class=s2>&#34;Line </span><span class=nv>$count</span><span class=s2>: </span><span class=nv>$line</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>  <span class=nv>count</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$count</span> + 1<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><h2 id=五处理程序输出>五、处理程序输出</h2><h3 id=51-文件描述符>5.1 文件描述符</h3><p>Linux 系统将每个对象都当作文件处理，并用文件描述符（ filedescriptor ）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程一次最多可以有九个文件描述符。bash shell 保留了前三个文件描述符（ 0 、1 和 2 ）用于特定的表述：</p><table><thead><tr><th>文件描述符</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>STDIN</td><td>标准输入</td></tr><tr><td>1</td><td>STDOUT</td><td>标准输出</td></tr><tr><td>2</td><td>STDERR</td><td>标准错误</td></tr></tbody></table><ul><li><strong>STDIN</strong>：代表 shell 的标准输入，它可以是终端界面的键盘，也可以是使用重定向符号（&lt;）读取的文件。</li><li><strong>STDOUT</strong>：代表 shell 的标准输出，它通常是终端界面的显示器，也可以是使用重定向符号（>）创建的文件。</li><li><strong>STDERR</strong>：代表 shell 的标准错误输出，默认情况下，STDERR 文件描述符和 STDOUT 文件描述符指向相同的地方。也就是说，在默认情况下，错误消息会被输出到显示器上。当然你也可以重定向错误的输出位置：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ls -al badfile 2&gt; test1 <span class=c1>#将错误输出重定向到test1文件，正常的输出默认显示到屏幕上</span>
</span></span><span class=line><span class=cl>ls -al badfile 2&gt; test2 1&gt; test3 <span class=c1>#将错误的输出重定向到test2，正常输出重定向到test1</span>
</span></span></code></pre></div><p>如果你想要将正常输出和错误输出重定向到同一个文件，可以使用 <code>&></code> 符号进行简写：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ls -al badfile <span class=p>&amp;</span>&gt; test4
</span></span></code></pre></div><h3 id=52-输出重定向>5.2 输出重定向</h3><p><strong>1. 临时重定向</strong></p><p>如果你想要在脚本中输出特定的错误信息，此时可以在文件描述符数字之前加一个 & ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;捕获到未知异常&#34;</span> &gt;<span class=p>&amp;</span><span class=m>2</span>
</span></span></code></pre></div><p>此时异常信息就会被添加到标准错误输出中。但上面提到过，标准错误输出默认是显示在界面上，如果想要将捕获到的错误信息输出到指定文件中，则还需要对标准错误输出进行重定向：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ./test 2&gt; error.txt
</span></span></code></pre></div><p><strong>2. 永久重定向</strong></p><p>如果需要对每条语句都进行临时重定向，此时可以使用 <code>exec</code> 进行一次性永久重定向：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>exec</span> 1&gt;testout <span class=c1>#之后的所有正常输出都重定向到testout文件中</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;This is a test of redirecting all output&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;from a script to another file.&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;without having to redirect every individual line&#34;</span>
</span></span></code></pre></div><h3 id=53-输入重定向>5.3 输入重定向</h3><p>exec 命令还允许你将 STDIN 重定向到文件上，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>exec</span> 0&lt; testfile
</span></span></code></pre></div><h3 id=54-自定义重定向>5.4 自定义重定向</h3><p>bash shell 只占用了 3 个文件描述符，其他的 6 个（ 3~8 ）文件描述符均可用作自定义的输入或输出重定向，具体如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>exec</span> 3&gt;test3out <span class=c1>#将文件描述符为3的输出重定向到test3out</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;and this should be stored in the file&#34;</span> &gt;<span class=p>&amp;</span><span class=m>3</span>
</span></span></code></pre></div><p>如果之后想要关闭自定义的文件描述符，需要将它重定向到特殊符号 <code>&-</code> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>exec</span> 3&gt;<span class=p>&amp;</span>-
</span></span></code></pre></div><p>需要注意的是一旦关闭了文件描述符，就不能再向它写入任何数据，否则就会抛出异常。</p><h3 id=55-阻止命令输出>5.5 阻止命令输出</h3><p>如果你不需要任何输出信息，此时可以将输出重定向到一个叫作 null 的特殊文件中，在 Linux 系统上 null 文件的标准位置是 <code>/dev/null</code> ，重定向到该位置的任何数据都会被丢弃，不会显示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ls -al &gt; /dev/null
</span></span><span class=line><span class=cl>$ cat /dev/null
</span></span><span class=line><span class=cl>$
</span></span></code></pre></div><h3 id=56-创建临时文件>5.6 创建临时文件</h3><p>通常你会需要创建某些临时文件用于保存程序输出，此时可以使用 mktemp 命令来实现，它会创建一个唯一的临时文件，并赋予创建者完整的读写权限。默认情况下， mktemp 会在本地目录中创建一个文件，你只要指定文件名，并加上任意个 X ，X 会被替换为其他字符，用于保证唯一性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># mktemp testing.XXXXXX</span>
</span></span><span class=line><span class=cl>testing.UdxhQH
</span></span><span class=line><span class=cl><span class=c1># mktemp testing.XXXXXX</span>
</span></span><span class=line><span class=cl>testing.3pe64N
</span></span><span class=line><span class=cl><span class=c1># mktemp testing.XXX</span>
</span></span><span class=line><span class=cl>testing.SWw
</span></span></code></pre></div><p>除此之外，它还支持以下参数：</p><ul><li><strong>-t</strong> ：该选项会强制 mktemp 在系统的临时目录（如 /tmp）下创建文件， 此时它会返回临时文件的全路径；</li><li><strong>-d</strong>：该选项告诉 mktemp 需要创建的是一个目录而不是文件。</li></ul><h3 id=57-记录输出>5.7 记录输出</h3><p>如果你需要将输出既显示在终端上，又写入到文件中，此时可以使用 tee 命令来实现。它不仅会将结果输出到 STDOUT 中，同时也会将结果写出到指定的文件中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#  date | tee testfile</span>
</span></span><span class=line><span class=cl>2020年 02月 20日 星期四 14:21:40 CST
</span></span><span class=line><span class=cl><span class=c1># cat testfile</span>
</span></span><span class=line><span class=cl>2020年 02月 20日 星期四 14:21:40 CST
</span></span></code></pre></div><h2 id=六创建函数>六、创建函数</h2><h3 id=61-创建函数>6.1 创建函数</h3><p>在 shell 脚本中可以通过以下两种方式来定义函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 方式一：使用function关键字</span>
</span></span><span class=line><span class=cl><span class=k>function</span>  name <span class=o>{</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 方式二</span>
</span></span><span class=line><span class=cl>name <span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    commands
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>调用函数时，只需要在对应行中指定函数名即可，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>function</span> func <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;This is an example of a function&#34;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>func <span class=c1>#调用函数</span>
</span></span></code></pre></div><p>函数的调用必须在函数的定义之后，另外函数名必须是唯一的，如果出现同名函数，则后面的函数定义会覆盖前面的函数定义。</p><h3 id=62-函数参数>6.2 函数参数</h3><p>如果想要为函数传递所需的参数，只需要在函数名后面跟上所需的参数即可。在函数体内可以通过 <code>$1</code> 、 <code>$2</code> 来进行引用的；<code>$0</code> 则表示具体的函数名，<code>$#</code> 表示参数的总数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>function</span> addem <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>[</span> <span class=nv>$#</span> -eq <span class=m>0</span> <span class=o>]</span> <span class=o>||</span> <span class=o>[</span> <span class=nv>$#</span> -gt <span class=m>2</span> <span class=o>]</span> <span class=c1>#如果没有传递参数或者传递两个以上的参数都返回-1</span>
</span></span><span class=line><span class=cl>  <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> -1
</span></span><span class=line><span class=cl>  <span class=k>elif</span> <span class=o>[</span> <span class=nv>$#</span> -eq <span class=m>1</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> $<span class=o>[</span> <span class=nv>$1</span> + <span class=nv>$1</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> $<span class=o>[</span> <span class=nv>$1</span> + <span class=nv>$2</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> -n <span class=s2>&#34;Adding 10 and 15: &#34;</span>
</span></span><span class=line><span class=cl><span class=nv>value</span><span class=o>=</span><span class=k>$(</span>addem <span class=m>10</span> 15<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$value</span>  <span class=c1>#25</span>
</span></span></code></pre></div><p>同时如上面的例子所示，<strong>函数的返回值使用 echo 语句进行输出</strong>。</p><h3 id=63-退出状态码>6.3 退出状态码</h3><p>默认情况下，函数中最后一条命令的退出状态码就是整个函数的退出状态码。在函数执行后，可以使用变量 <code>$?</code> 来获取函数的退出状态码。如果你想要返回自定义的状态码，可以使用 return 命令来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=k>function</span> func <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>read</span> -p <span class=s2>&#34;Enter a value: &#34;</span> value
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;doubling the value&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> $<span class=o>[</span> <span class=nv>$value</span> * <span class=m>2</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>和命令的退出状态码一致，这里的退出状态码的取值范围必须是 0~255 。</p><h3 id=64-局部变量>6.4 局部变量</h3><p>在 shell 脚本中，变量分为全局变量和局部变量。默认情况下，你在脚本中定义的任何变量都是全局变量，为了避免函数体内的变量对全局变量造成污染，你可以在函数体内使用局部变量，此时只需要在变量声明前面加上 local 关键字即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>value1</span><span class=o>=</span><span class=m>100</span>
</span></span><span class=line><span class=cl><span class=nv>value2</span><span class=o>=</span><span class=m>100</span>
</span></span><span class=line><span class=cl><span class=k>function</span> func <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>local</span> <span class=nv>value1</span><span class=o>=</span><span class=m>200</span>
</span></span><span class=line><span class=cl>  <span class=nv>value2</span><span class=o>=</span><span class=m>200</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span>  <span class=s2>&#34;局部变量value1 ：&#34;</span> <span class=nv>$value1</span>     <span class=c1>#200</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span>  <span class=s2>&#34;局部变量value2 ：&#34;</span> <span class=nv>$value2</span>     <span class=c1>#200</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>func
</span></span><span class=line><span class=cl><span class=nb>echo</span>  <span class=s2>&#34;全局变量value1 ：&#34;</span> <span class=nv>$value1</span>     <span class=c1>#100 使用局部变量可以保证同名的全局变量不被污染</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span>  <span class=s2>&#34;全局变量value2 ：&#34;</span> <span class=nv>$value2</span>     <span class=c1>#200  没有使用局部变量，全局变量收到了勿扰</span>
</span></span></code></pre></div><h3 id=65-函数库>6.5 函数库</h3><p>某些时候你可能需要引用第三方的函数库，或者你的通用函数比较多，此时可以将通用函数定义到一个统一的文件中。如下，就是一个简单的自定义函数库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat myfuncs
</span></span><span class=line><span class=cl><span class=c1># 自定义函数库</span>
</span></span><span class=line><span class=cl><span class=k>function</span> addem <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> $<span class=o>[</span> <span class=nv>$1</span> + <span class=nv>$2</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=k>function</span> multem <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> $<span class=o>[</span> <span class=nv>$1</span> * <span class=nv>$2</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=k>function</span> divem <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>[</span> <span class=nv>$2</span> -ne <span class=m>0</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> $<span class=o>[</span> <span class=nv>$1</span> / <span class=nv>$2</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> -1
</span></span><span class=line><span class=cl>  <span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>想要在其他脚本中引用该函数库，可以使用 source 命令。source 命令可以使用点操作符进行简写，假设脚本文件和函数库文件处于同一目录，此时只需要在脚本文件中使用以下命令进行引用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>. ./myfuncs <span class=c1>#引用函数库</span>
</span></span><span class=line><span class=cl><span class=nv>value1</span><span class=o>=</span><span class=m>10</span>
</span></span><span class=line><span class=cl><span class=nv>value2</span><span class=o>=</span><span class=m>5</span>
</span></span><span class=line><span class=cl><span class=nv>result1</span><span class=o>=</span><span class=k>$(</span>addem <span class=nv>$value1</span> <span class=nv>$value2</span><span class=k>)</span> <span class=c1>#直接调用函数库中的函数</span>
</span></span></code></pre></div><h2 id=七控制脚本>七、控制脚本</h2><h3 id=71-处理信号>7.1 处理信号</h3><p>Linux 系统可以使用信号来与运行在系统中的进程通信，从而可以启动、停止、终止进程。我们可以通过对脚本进行编程，使其在收到特定信号时执行特定的操作，常用的 Linux 系统信号如下：</p><table><thead><tr><th>信号</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>挂起进程</td></tr><tr><td>2</td><td>SIGINT</td><td>终止进程（可以通过键盘组合 Ctrl+C 进程触发）</td></tr><tr><td>3</td><td>SIGQUIT</td><td>停止进程</td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程</td></tr><tr><td>15</td><td>SIGTERM</td><td>尽可能终止进程</td></tr><tr><td>17</td><td>SIGSTOP</td><td>无条件停止进程，但不是终止进程</td></tr><tr><td>18</td><td>SIGTSTP</td><td>停止或暂停进程，但不终止进程程（可以通过键盘组合 Ctrl+Z 进程触发）</td></tr><tr><td>19</td><td>SIGCONT</td><td>继续运行处于停止状态的进程</td></tr></tbody></table><p>想要在脚本中捕获这些信号，可以通过 trap 命令来实现，其基本使用格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>trap</span> commonds signals
</span></span></code></pre></div><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>trap</span> <span class=s2>&#34;echo &#39; Sorry! I have trapped Ctrl-C&#39;&#34;</span> SIGINT  <span class=c1>#捕获SIGINT信号并执行echo命令</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> <span class=nv>$count</span> -le <span class=m>10</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Loop #</span><span class=nv>$count</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    sleep <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=nv>count</span><span class=o>=</span>$<span class=o>[</span> <span class=nv>$count</span> + <span class=m>1</span> <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>除了可以在 shell 脚本中捕获到正常信号外，你还可以在 shell 脚本退出时捕获到退出信号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>trap</span> <span class=s2>&#34;echo Goodbye...&#34;</span> EXIT <span class=c1>#捕获脚本退出的EXIT信号</span>
</span></span></code></pre></div><p>要想在脚本中的不同位置进行不同的捕获处理，你只需重新使用 trap 命令即可。如果想要删除已设置好的捕获，则需要在 trap 命令与信号名称之间加上两个破折号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>trap</span> -- SIGINT <span class=c1>#删除对SIGINT命令的捕获</span>
</span></span></code></pre></div><h3 id=72-后台运行>7.2 后台运行</h3><p>如果想要以后台模式运行 shell ，只要在命令后加个 & 符号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ./test.sh <span class=p>&amp;</span>
</span></span></code></pre></div><p>采用该方式运行的后台进程默认是与终端会话关联在一起的，如果终端会话退出了，那么后台进程也会随之退出，如果希望后台进程在登出控制台之后仍能继续运行，则可以使用 nohup 命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ nohup ./test.sh <span class=p>&amp;</span>
</span></span></code></pre></div><p>由于 nohup 命令会解除进程与终端的关联，此时进程也就不再同 STDOUT 和 STDERR 联系在一起。为了保存该命令产生的输出， nohup 命令会自动将 STDOUT 和 STDERR 的消息重定向到一个名为 nohup.out 的文件中。如果该文件已存在，则会将输出以追加的方式写入该文件。</p><h3 id=73-作业控制>7.3 作业控制</h3><p>想要查看 shell 当前正在处理的作业，可以使用 jobs 命令来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># jobs -l</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span>+ <span class=m>14630</span> 停止                  ./test.sh
</span></span><span class=line><span class=cl><span class=o>[</span>2<span class=o>]</span>- <span class=m>14831</span> 运行中               ./test.sh &gt; test.out <span class=p>&amp;</span>
</span></span></code></pre></div><p><code>-l</code> 表示列出作业的 PID 以及作业号，其余的部分可选参数如下：</p><ul><li><strong>-r</strong>：只列运行中的作业；</li><li><strong>-s</strong>：只列出已停止的作业。</li></ul><p>如上输出所示，带加号的作业是默认作业，当默认作业处理完成后，带减号的作业会成为下一个默认作业。不论 shell 中有多少个正在运行的作业，任何时候都只有一个带加号的作业和一个带减号的作业。</p><p>在 bash 的作业控制中，还可以将已停止的作业作为后台进程或前台进程进行重启，命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>bg</span> <span class=m>1</span> <span class=c1>#将作业号为1的作业以后台进程的方式进程重启</span>
</span></span><span class=line><span class=cl><span class=nb>fg</span> <span class=m>1</span> <span class=c1>#将作业号为1的作业以前台进程的方式进程重启</span>
</span></span></code></pre></div><h3 id=74-定时作业>7.4 定时作业</h3><p>Linux 提供了以下两个命令来执行定时作业：</p><ul><li><strong>at</strong>：用于一次性的定时作业；</li><li><strong>corn</strong>：用于需要周期性执行的定时作业。</li></ul><p><strong>1. at 命令</strong></p><p>at 命令的基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>at <span class=o>[</span>-f filename<span class=o>]</span> <span class=nb>time</span>
</span></span></code></pre></div><p><code>-f</code> 用于指定脚本文件，time 用于指定脚本的执行时间，它可以是以下多种格式：</p><ul><li>标准的小时和分钟格式，比如 10:15；</li><li>AM/PM 指示符，比如 10:15 PM；</li><li>特定可命名时间，比如 now、noon、midnight 或者 teatime（4 PM）。</li></ul><p>除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期：</p><ul><li>标准日期格式，比如 MMDDYY、MM/DD/YY 或 DD.MM.YY；</li><li>文本日期，比如 Jul 4 或 Dec 25，加不加年份均可。</li></ul><p>另外还可以指定时间增量：</p><ul><li>now + 25 min；</li><li>10:15 + 7 days。</li></ul><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ at -f test.sh now <span class=c1>#立即执行test.sh脚本</span>
</span></span></code></pre></div><p>使用 at 命令时，该作业会被提交到作业队列中（job queue）。针对不同优先级，存在 26 种不同的作业队列，通常用小写字 <code>a~z</code> 或大写字母 <code>A~Z</code> 来指代，作业队列的字母排序越高，作业运行的优先级就越低。默认情况下， at 的作业会被提交到 a 队列，如果想以更高优先级运行作业，可以用 <code>-q</code> 参数进行指定。</p><p>需要注意的是，显示器并不会关联 at 提交的作业。取而代之的是，Linux 系统会将提交该作业的用户的电子邮件地址作为 STDOUT 和 STDERR，任何发到 STDOUT 或 STDERR 的输出都会通过邮件系统发送给该用户；如果你的系统中没有安装 sendmail ，那就无法获得任何输出。因此在使用 at 命令时，最好在脚本中对 STDOUT 和 STDERR 进行重定向。</p><p>最后 Linux 还提供了 <code>atq</code> 命令用于查看处于等待状态的作业，并且支持使用 <code>atrm</code> 命令来删除处于等待中的作业：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl> $ atrm <span class=m>18</span> <span class=c1>#删除作业号为18的等待作业</span>
</span></span></code></pre></div><p><strong>2. cron 命令</strong></p><p>cron 命令通常用于需要周期性执行的任务，其基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>min hour dayofmonth month dayofweek <span class=nb>command</span>
</span></span></code></pre></div><p>使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=m>15</span> <span class=m>10</span> * * * /root/test.sh <span class=c1>#每天15:10分执行test.sh脚本</span>
</span></span></code></pre></div><p>想要新建基于该 cron 表达式的定时任务，可以使用 <code>crontab -e</code> 命令，然后在打开的文本编辑器（操作类似 Vim）中输入上述表达式，编辑完成后保存即可。最后可以使用 <code>crontab -l</code> 来查看系统中所有的定时任务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># crontab -l</span>
</span></span><span class=line><span class=cl><span class=m>15</span> <span class=m>10</span> * * * /root/test.sh
</span></span></code></pre></div><h1 id=links>Links</h1><ul><li><a href=https://mojotv.cn/2018/12/26/shell-cheat-sheet target=_blank rel=noopener>https://mojotv.cn/2018/12/26/shell-cheat-sheet</a> Shell 语法快速入门</li><li><a href=https://mojotv.cn/2019/07/26/general-shell-resources target=_blank rel=noopener>https://mojotv.cn/2019/07/26/general-shell-resources</a> linux-Bash 命令快速查询</li><li><a href=https://devhints.io/bash target=_blank rel=noopener>https://devhints.io/bash</a> 提取其中的命令语句为 CheatSheet</li><li><a href=https://linuxconfig.org/bash-scripting-cheat-sheet target=_blank rel=noopener>https://linuxconfig.org/bash-scripting-cheat-sheet</a></li></ul></div><div class=article-widget><div class="container-xl row post-nav"></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div><script type=text/javascript id=clstr_globe async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>