<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MessageQueue | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/</link><atom:link href="https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/index.xml" rel="self" type="application/rss+xml"/><description>MessageQueue</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>MessageQueue</title><link>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/</link></image><item><title>Pulsar-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/pulsar-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/pulsar-cheatsheet/</guid><description>&lt;h1 id="pulsar-cheatsheet">Pulsar CheatSheet&lt;/h1>
&lt;p>Apache Pulsar 将高性能的流（Apache Kafka 所追求的）和灵活的传统队列（RabbitMQ 所追求的）结合到一个统一的消息模型和 API 中。Pulsar 使用统一的 API 为用户提供一个支持流和队列的系统，且具有同样的高性能。应用程序可以将此统一的 API 用于高性能队列和流式传输，而无需维护两套系统：RabbitMQ 进行队列处理，Kafka 进行流式处理。&lt;/p>
&lt;p>Pulsar 旨在取代 Apache Kafka 多年的主宰地位。Pulsar 在很多情况下提供了比 Kafka 更快的吞吐量和更低的延迟，并为开发人员提供了一组兼容的 API，让他们可以很轻松地从 Kafka 切换到 Pulsar。Pulsar 的最大优点在于它提供了比 Apache Kafka 更简单明了、更健壮的一系列操作功能，特别在解决可观察性、地域复制和多租户方面的问题。在运行大型 Kafka 集群方面感觉有困难的企业可以考虑转向使用 Pulsar。&lt;/p>
&lt;h1 id="架构概览">架构概览&lt;/h1>
&lt;p>Apache Pulsar 和其他消息系统最根本的不同是采用分层架构。Apache Pulsar 集群由两层组成：无状态服务层，由一组接收和传递消息的 Broker 组成；以及一个有状态持久层，由一组名为 bookies 的 Apache BookKeeper 存储节点组成，可持久化地存储消息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50599299-9ebe8b80-0ee8-11e9-84ed-966979b2d062.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Apache Pulsar 和 Apache Kafka 之间的根本区别在于 Apache Kafka 是以分区为存储中心，而 Apache Pulsar 是以 Segment 为存储中心。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50600008-ba2a9600-0eea-11e9-844a-0b1eb5a429a5.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在 Pulsar 客户端中提供生产者和消费者（Producer &amp;amp; Consumer）接口，应用程序使用 Pulsar 客户端连接到 Broker 来发布和消费消息。Pulsar 客户端不直接与存储层 Apache BookKeeper 交互。客户端也没有直接的 Zookeeper 访问权限。这种隔离，为 Pulsar 实现安全的多租户统一身份验证模型提供了基础。&lt;/p>
&lt;p>Apache Pulsar 为客户端提供多种语言的支持，包括 Java，C++，Python，Go 和 Websockets。Apache Pulsar 还提供了一组兼容 Kafka 的 API，用户可以通过简单地更新依赖关系并将客户端指向 Pulsar 集群来迁移现有的 Kafka 应用程序，这样现有的 Kafka 应用程序可以立即与 Apache Pulsar 一起使用，无需更改任何代码。&lt;/p>
&lt;h2 id="broker-层无状态服务层">Broker 层：无状态服务层&lt;/h2>
&lt;p>Broker 集群在 Apache Pulsar 中形成无状态服务层。服务层是“无状态的”，因为 Broker 实际上并不在本地存储任何消息数据。有关 Pulsar 主题的消息，都被存储在分布式日志存储系统（Apache BookKeeper）中。每个主题分区（Topic Partition）由 Pulsar 分配给某个 Broker，该 Broker 称为该主题分区的所有者。Pulsar 生产者和消费者连接到主题分区的所有者 Broker，以向所有者代理发送消息并消费消息。&lt;/p>
&lt;p>如果一个 Broker 失败，Pulsar 会自动将其拥有的主题分区移动到群集中剩余的某一个可用 Broker 中。这里要说的一件事是：由于 Broker 是无状态的，当发生 Topic 的迁移时，Pulsar 只是将所有权从一个 Broker 转移到另一个 Broker，在这个过程中，不会有任何数据复制发生。&lt;/p>
&lt;p>下图显示了一个拥有 4 个 Broker 的 Pulsar 集群，其中 4 个主题分区分布在 4 个 Broker 中。每个 Broker 拥有并为一个主题分区提供消息服务。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50599374-e0e7cd00-0ee8-11e9-9528-f57c6396c151.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="bookkeeper-层持久化存储层">BookKeeper 层：持久化存储层&lt;/h2>
&lt;p>Apache BookKeeper 是 Apache Pulsar 的持久化存储层。Apache Pulsar 中的每个主题分区本质上都是存储在 Apache BookKeeper 中的分布式日志。每个分布式日志又被分为 Segment 分段。每个 Segment 分段作为 Apache BookKeeper 中的一个 Ledger，均匀分布并存储在 BookKeeper 群集中的多个 Bookie（Apache BookKeeper 的存储节点）中。&lt;/p>
&lt;p>Segment 的创建时机包括以下几种：基于配置的 Segment 大小；基于配置的滚动时间；或者当 Segment 的所有者被切换。通过 Segment 分段的方式，主题分区中的消息可以均匀和平衡地分布在群集中的所有 Bookie 中。这意味着主题分区的大小不仅受一个节点容量的限制；相反，它可以扩展到整个 BookKeeper 集群的总容量。&lt;/p>
&lt;p>下面的图说明了一个分为 x 个 Segment 段的主题分区。每个 Segment 段存储 3 个副本。所有 Segment 都分布并存储在 4 个 Bookie 中。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50599446-1db3c400-0ee9-11e9-8d4d-fa0135dc6297.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="消息模型">消息模型&lt;/h1>
&lt;p>Apache Pulsar 通过“订阅”，抽象出了统一的: producer-topic-subscription-consumer 消费模型。Pulsar 的消息模型既支持队列模型，也支持流模型。在 Pulsar 的消息消费模型中，Topic 是用于发送消息的通道。每一个 Topic 对应着 Apache ZookKeeper 中的一个分布式日志。发布者发布的每条消息只在 Topic 中存储一次；存储的过程中，ZookKeeper 会将消息复制存储在多个存储节点上；Topic 中的每条消息，可以根据消费者的订阅需求，多次被使用，每个订阅对应一个消费者组（Consumer Group）。&lt;/p>
&lt;p>主题（Topic）是消费消息的真实来源。尽管消息仅在主题（Topic）上存储一次，但是用户可以有不同的订阅方式来消费这些消息：&lt;/p>
&lt;ul>
&lt;li>消费者被组合在一起以消费消息，每个消费组是一个订阅。&lt;/li>
&lt;li>每个 Topic 可以有不同的消费组。&lt;/li>
&lt;li>每组消费者都是对主题的一个订阅。&lt;/li>
&lt;li>每组消费者可以拥有自己不同的消费方式：独占（Exclusive），故障切换（Failover）或共享（Share）。&lt;/li>
&lt;/ul>
&lt;p>Pulsar 通过这种模型，将队列模型和流模型这两种模型结合在了一起，提供了统一的 API 接口。这种模型，既不会影响消息系统的性能，也不会带来额外的开销，同时还为用户提供了更多灵活性，方便用户程序以最匹配模式来使用消息系统。&lt;/p>
&lt;p>Pulsar 中的订阅实际上与 Apache Kafka 中的 Consumer Group 的概念类似。创建订阅的操作很轻量化，而且具有高度可扩展性，用户可以根据应用的需要创建任意数量的订阅。对同一主题的不同订阅，也可以采用不同的订阅类型。比如用户可以在同一主题上可以提供一个包含 3 个消费者的故障切换订阅，同时也提供一个包含 20 个消费者的共享订阅，并且可以在不改变分区数量的情况下，向共享订阅添加更多的消费者。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50560024-4e53fc00-0d37-11e9-8b57-9b1636d238ac.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="消息消费模型">消息消费模型&lt;/h2>
&lt;p>独占和故障切换订阅，仅允许一个消费者来使用和消费每个对主题的订阅。这两种模式都按主题分区顺序使用消息。它们最适用于需要严格消息顺序的流（Stream）用例。&lt;/p>
&lt;h3 id="stream-独占订阅">Stream 独占订阅&lt;/h3>
&lt;p>顾名思义，独占订阅中，在任何时间，一个消费者组（订阅）中有且只有一个消费者来消费 Topic 中的消息。下图是独占订阅的示例。在这个示例中有一个有订阅 A 的活跃消费者 A-0，消息 m0 到 m4 按顺序传送并由 A-0 消费。如果另一个消费者 A-1 想要附加到订阅 A，则是不被允许的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50560041-78a5b980-0d37-11e9-9ec2-15d02bcac551.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="stream-故障切换订阅">Stream 故障切换订阅&lt;/h3>
&lt;p>使用故障切换订阅，多个消费者（Consumer）可以附加到同一订阅。但是，一个订阅中的所有消费者，只会有一个消费者被选为该订阅的主消费者。其他消费者将被指定为故障转移消费者。
当主消费者断开连接时，分区将被重新分配给其中一个故障转移消费者，而新分配的消费者将成为新的主消费者。发生这种情况时，所有未确认（ack）的消息都将传递给新的主消费者。这类似于 Apache Kafka 中的 Consumer partition rebalance。
下图是故障切换订阅的示例。消费者 B-0 和 B-1 通过订阅 B 订阅消费消息。B-0 是主消费者并接收所有消息。B-1 是故障转移消费者，如果消费者 B-0 出现故障，它将接管消费。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50560045-80fdf480-0d37-11e9-8965-95094f8f3db0.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="queue-共享订阅模型">Queue 共享订阅模型&lt;/h3>
&lt;p>使用共享订阅，在同一个订阅背后，用户按照应用的需求挂载任意多的消费者。订阅中的所有消息以循环分发形式发送给订阅背后的多个消费者，并且一个消息仅传递给一个消费者。当消费者断开连接时，所有传递给它但是未被确认（ack）的消息将被重新分配和组织，以便发送给该订阅上剩余的剩余消费者。下图是共享订阅的示例。消费者 C-1，C-2 和 C-3 都在同一主题上消费消息。每个消费者接收大约所有消息的 1/3。如果想提高消费的速度，用户不需要不增加分区数量，只需要在同一个订阅中添加更多的消费者。&lt;/p>
&lt;p>共享订阅允许每个主题分区有多个消费者。同一订阅中的每个消费者仅接收主题分区的一部分消息。共享订阅最适用于不需要保证消息顺序的队列（Queue）的使用模式，并且可以按照需要任意扩展消费者的数量。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50560030-60ce3580-0d37-11e9-8064-5a9cecec37c1.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="ack--消息确认">ACK | 消息确认&lt;/h2>
&lt;p>在 Apache Pulsar 中，每个订阅中都使用一个专门的数据结构——游标（Cursor）来跟踪订阅中的每条消息的确认（ACK）状态。每当消费者在主题分区上确认消息时，游标都会更新。更新游标可确保消费者不会再次收到消息。Apache Pulsar 提供两种消息确认方法，单条确认（Individual Ack）和累积确认（Cumulative Ack）。通过累积确认，消费者只需要确认它收到的最后一条消息。主题分区中的所有消息（包括）提供消息 ID 将被标记为已确认，并且不会再次传递给消费者。累积确认与 Apache Kafka 中的 Offset 更新类似。&lt;/p>
&lt;p>Apache Pulsar 可以支持消息的单条确认，也就是选择性确认。消费者可以单独确认一条消息。被确认后的消息将不会被重新传递。下图说明了单条确认和累积确认的差异（灰色框中的消息被确认并且不会被重新传递）。在图的上半部分，它显示了累计确认的一个例子，M12 之前的消息被标记为 acked。在图的下半部分，它显示了单独进行 acking 的示例。仅确认消息 M7 和 M12 - 在消费者失败的情况下，除了 M7 和 M12 之外，其他所有消息将被重新传送。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50560119-7132e000-0d38-11e9-90f3-caf99b8aac0f.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>独占订阅或故障切换订阅的消费者能够对消息进行单条确认和累积确认；共享订阅的消费者只允许对消息进行单条确认。单条确认消息的能力为处理消费者故障提供了更好的体验。对于某些应用来说，处理一条消息可能需要很长时间或者非常昂贵，防止重新传送已经确认的消息非常重要。&lt;/p>
&lt;p>这个管理 Ack 的专门的数据结构——游标（Cursor），由 Broker 来管理，利用 BookKeeper 的 Ledger 提供存储。Apache Pulsar 提供了灵活的消息消费订阅类型和消息确认方法，通过简单的统一的 API，就可以支持各种消息和流的使用场景。&lt;/p>
&lt;h1 id="存储模型">存储模型&lt;/h1>
&lt;p>Pulsar 主题分区实际上是存储在 Apache BookKeeper 中，它还提供了一个读取 API（Reader），类似于消费者 API（但 Reader 没有游标管理），以便用户完全控制如何使用 Topic 中的消息。&lt;/p>
&lt;h2 id="segment-为中心的存储">Segment 为中心的存储&lt;/h2>
&lt;p>存储服务的分层的架构 和 以 Segment 为中心的存储 是 Apache Pulsar（使用 Apache BookKeeper）的两个关键设计理念。这两个基础为 Pulsar 提供了许多重要的好处：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>无限制的主题分区存储&lt;/p>
&lt;/li>
&lt;li>
&lt;p>即时扩展，无需数据迁移&lt;/p>
&lt;ul>
&lt;li>无缝 Broker 故障恢复&lt;/li>
&lt;li>无缝集群扩展&lt;/li>
&lt;li>无缝的存储（Bookie）故障恢复&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>独立的可扩展性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="无限制的主题分区存储">无限制的主题分区存储&lt;/h3>
&lt;p>由于主题分区被分割成 Segment 并在 Apache BookKeeper 中以分布式方式存储，因此主题分区的容量不受任何单一节点容量的限制。相反，主题分区可以扩展到整个 BookKeeper 集群的总容量，只需添加 Bookie 节点即可扩展集群容量。这是 Apache Pulsar 支持存储无限大小的流数据，并能够以高效，分布式方式处理数据的关键。使用 Apache BookKeeper 的分布式日志存储，对于统一消息服务和存储至关重要。&lt;/p>
&lt;h3 id="即时扩展">即时扩展&lt;/h3>
&lt;p>由于消息服务层和持久存储层是分开的，因此 Apache Pulsar 可以独立地扩展存储层和服务层。这种独立的扩展，更具成本效益：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当您需要支持更多的消费者或生产者时，您可以简单地添加更多的 Broker。主题分区将立即在 Brokers 中做平衡迁移，一些主题分区的所有权立即转移到新的 Broker。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当您需要更多存储空间来将消息保存更长时间时，您只需添加更多 Bookie。通过智能资源感知和数据放置，流量将自动切换到新的 Bookie 中。Apache Pulsar 中不会涉及到不必要的数据搬迁，不会将旧数据从现有存储节点重新复制到新存储节点。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>由于消息服务和消息存储分为两层，因此将主题分区从一个 Broker 移动到另一个 Broker 几乎可以瞬时内完成，而无需任何数据重新平衡（将数据从一个节点重新复制到另一个节点）。这一特性对于高可用的许多方面至关重要，例如集群扩展；对 Broker 和 Bookie 失败的快速应对。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50599832-25279d00-0eea-11e9-8ee3-e5eb2142b7c8.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>上图说明了 Pulsar 如何处理集群的容量扩展。当 Broker 2 将消息写入 Topic1-Part2 的 Segment X 时，将 Bookie X 和 Bookie Y 添加到集群中。Broker 2 立即发现新加入的 Bookies X 和 Y。然后 Broker 将尝试将 Segment X + 1 和 X + 2 的消息存储到新添加的 Bookie 中。新增加的 Bookie 立刻被使用起来，流量立即增加，而不会重新复制任何数据。除了机架感知和区域感知策略之外，Apache BookKeeper 还提供资源感知的放置策略，以确保流量在群集中的所有存储节点之间保持平衡。&lt;/p>
&lt;h3 id="故障恢复">故障恢复&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50599704-ce21c800-0ee9-11e9-9946-a1ba576503e9.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>上图说明了 Pulsar 如何处理 Broker 失败的示例。在例子中 Broker 2 因某种原因（例如停电）而断开。Pulsar 检测到 Broker 2 已关闭，并立即将 Topic1-Part2 的所有权从 Broker 2 转移到 Broker 3。在 Pulsar 中数据存储和数据服务分离，所以当代理 3 接管 Topic1-Part2 的所有权时，它不需要复制 Partiton 的数据。如果有新数据到来，它立即附加并存储为 Topic1-Part2 中的 Segment x + 1。Segment x + 1 被分发并存储在 Bookie1, 2 和 4 上。因为它不需要重新复制数据，所以所有权转移立即发生而不会牺牲主题分区的可用性。&lt;/p>
&lt;p>下图说明了 Pulsar（通过 Apache BookKeeper）如何处理 bookie 的磁盘故障。这里有一个磁盘故障导致存储在 bookie 2 上的 Segment 4 被破坏。Apache BookKeeper 后台会检测到这个错误并进行复制修复。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/50599903-530ce180-0eea-11e9-9184-3f90191113d0.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Apache BookKeeper 中的副本修复是 Segment（甚至是 Entry）级别的多对多快速修复，这比重新复制整个主题分区要精细，只会复制必须的数据。这意味着 Apache BookKeeper 可以从 bookie 3 和 bookie 4 读取 Segment 4 中的消息，并在 bookie 1 处修复 Segment 4。所有的副本修复都在后台进行，对 Broker 和应用透明。&lt;/p>
&lt;p>即使有 Bookie 节点出错的情况发生时，通过添加新的可用的 Bookie 来替换失败的 Bookie，所有 Broker 都可以继续接受写入，而不会牺牲主题分区的可用性。&lt;/p>
&lt;h2 id="retention--消息保留">Retention | 消息保留&lt;/h2>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/v4A--nGiDTt58pZyIzepeg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/v4A--nGiDTt58pZyIzepeg&lt;/a> 提取其中的图片&lt;/li>
&lt;/ul></description></item><item><title>RabbitMQ-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/rabbitmq-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/rabbitmq-cheatsheet/</guid><description>&lt;h1 id="rabbitmq-cheatsheet">RabbitMQ CheatSheet&lt;/h1>
&lt;h2 id="一消息队列">一、消息队列&lt;/h2>
&lt;p>消息队列中间件 (Message Queue Middleware，简称 MQ) 是指利用高效可靠的消息传递机制进行与平台无关的数据交流，它可以在分布式环境下扩展进程间的数据通信，并基于数据通信来进行分布式系统的集成。它主要适用于以下场景：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>项目解耦&lt;/strong>：不同的项目或模块可以使用消息中间件进行数据的传递，从而可以保证模块的相对独立，实现解耦。&lt;/li>
&lt;li>&lt;strong>流量削峰&lt;/strong>：可以将突发的流量 (如秒杀数据) 写入消息中间件，然后由多个消费者进行异步处理。&lt;/li>
&lt;li>&lt;strong>弹性伸缩&lt;/strong>：可以通过对消息中间件进行横向扩展来提高系统的处理能力和吞吐量。&lt;/li>
&lt;li>&lt;strong>发布订阅&lt;/strong>：可以用于任意的发布订阅模式中。&lt;/li>
&lt;li>&lt;strong>异步处理&lt;/strong>：当我们不需要对数据进行立即处理，或者不关心数据的处理结果时，可以使用中间件进行异步处理。&lt;/li>
&lt;li>&lt;strong>冗余存储&lt;/strong>：消息中间件可以对数据进行持久化存储，直到你消费完成后再进行删除。&lt;/li>
&lt;/ul>
&lt;h2 id="二amqp-协议">二、AMQP 协议&lt;/h2>
&lt;p>AMQP (Advanced Message Queuing Protocol) 是一个提供统一消息服务的应用层通讯协议，为消息中间件提供统一的开发规范。不同客户端可以将消息投递到中间件上，或从上面获取消息；发送消息和接收消息的客户端可以采用不同的语言开发、不同的技术实现，但必须遵循相同的 AMQP 协议。AMQP 协议本身包括以下三层：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Module Layer&lt;/strong>：位于协议最高层，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。例如：可以使用 Queue.Declare 命令声明一个队列或者使用 Basic.Consume 订阅消费一个队列中的消息。&lt;/li>
&lt;li>&lt;strong>Session Layer&lt;/strong>：位于中间层，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理。&lt;/li>
&lt;li>&lt;strong>Transport Layer&lt;/strong>：位于最底层，主要传输二进制数据流 ，提供帧的处理、信道复用、错误检测和数据表示等。&lt;/li>
&lt;/ul>
&lt;h2 id="三rabbitmq-简介">三、RabbitMQ 简介&lt;/h2>
&lt;p>RabbitMQ 完全实现了 AMQP 协议，并基于相同的模型架构。RabbitMQ 在实现 &lt;code>AMQP 0-9-1&lt;/code> 的基础上还进行了额外拓展，并可以通过插件来支持 &lt;code>AMQP 1.0&lt;/code>。所以在某种程度上而言， RabbitMQ 就是 AMQP 在 Erlang 语言上的实现。RabbitMQ 基于众多优秀的特性成为了目前最为广泛使用的消息中间件，它的主要特性如下：&lt;/p>
&lt;ul>
&lt;li>支持多种消息传递协议，除了 AMQP 外，还可以通过插件支持所有版本的 STOMP 协议和 MQTT 3.1 协议；&lt;/li>
&lt;li>拥有丰富的交换器类型，可以满足绝大部分的使用需求；&lt;/li>
&lt;li>支持多种部署方式，易于部署；&lt;/li>
&lt;li>支持跨语言开发，如：Java，.NET，PHP，Python，JavaScript，Ruby，Go；&lt;/li>
&lt;li>可以通过集群来实现高可用性和高吞吐，还可以通过 Federation 插件来连接跨机房跨区域的不同版本的服务节点；&lt;/li>
&lt;li>插拔式的身份验证和授权，支持 TLS 和 LDAP；&lt;/li>
&lt;li>支持持续集成，能够使用各种插件进行灵活地扩展；&lt;/li>
&lt;li>能够使用多种方式进行监控和管理，如 HTTP API，命令行工具和 UI 界面。&lt;/li>
&lt;/ul>
&lt;h2 id="四模型架构">四、模型架构&lt;/h2>
&lt;p>RabbitMQ 与 AMQP 遵循相同的模型架构，其架构示例图如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/rabbitmq-模型架构.png"/> &lt;/div>
&lt;h3 id="1-publisher发布者">1. Publisher（发布者）&lt;/h3>
&lt;p>发布者 (或称为生产者) 负责生产消息并将其投递到指定的交换器上。&lt;/p>
&lt;h3 id="2-message消息">2. Message（消息）&lt;/h3>
&lt;p>消息由消息头和消息体组成。消息头用于存储与消息相关的元数据：如目标交换器的名字 (exchange_name) 、路由键 (RountingKey) 和其他可选配置 (properties) 信息。消息体为实际需要传递的数据。&lt;/p>
&lt;h3 id="3-exchange交换器">3. Exchange（交换器）&lt;/h3>
&lt;p>交换器负责接收来自生产者的消息，并将将消息路由到一个或者多个队列中，如果路由不到，则返回给生产者或者直接丢弃，这取决于交换器的 mandatory 属性：&lt;/p>
&lt;ul>
&lt;li>当 mandatory 为 true 时：如果交换器无法根据自身类型和路由键找到一个符合条件的队列，则会将该消息返回给生产者；&lt;/li>
&lt;li>当 mandatory 为 false 时：如果交换器无法根据自身类型和路由键找到一个符合条件的队列，则会直接丢弃该消息。&lt;/li>
&lt;/ul>
&lt;h3 id="4-bindingkey-绑定键">4. BindingKey (绑定键）&lt;/h3>
&lt;p>交换器与队列通过 BindingKey 建立绑定关系。&lt;/p>
&lt;h3 id="5-routingkey路由键">5. Routingkey（路由键）&lt;/h3>
&lt;p>生产者将消息发给交换器的时候，一般会指定一个 RountingKey，用来指定这个消息的路由规则。当 RountingKey 与 BindingKey 基于交换器类型的规则相匹配时，消息被路由到对应的队列中。&lt;/p>
&lt;h3 id="6-queue消息队列">6. Queue（消息队列）&lt;/h3>
&lt;p>用于存储路由过来的消息。多个消费者可以订阅同一个消息队列，此时队列会将收到的消息将以轮询 (round-robin) 的方式分发给所有消费者。即每条消息只会发送给一个消费者，不会出现一条消息被多个消费者重复消费的情况。&lt;/p>
&lt;h3 id="7-consumer消费者">7. Consumer（消费者）&lt;/h3>
&lt;p>消费者订阅感兴趣的队列，并负责消费存储在队列中的消息。为了保证消息能够从队列可靠地到达消费者，RabbitMQ 提供了消息确认机制 (message acknowledgement)，并通过 autoAck 参数来进行控制：&lt;/p>
&lt;ul>
&lt;li>当 autoAck 为 true 时：此时消息发送出去 (写入 TCP 套接字) 后就认为消费成功，而不管消费者是否真正消费到这些消息。当 TCP 连接或 channel 因意外而关闭，或者消费者在消费过程之中意外宕机时，对应的消息就丢失。因此这种模式可以提高吞吐量，但会存在数据丢失的风险。&lt;/li>
&lt;li>当 autoAck 为 false 时：需要用户在数据处理完成后进行手动确认，只有用户手动确认完成后，RabbitMQ 才认为这条消息已经被成功处理。这可以保证数据的可靠性投递，但会降低系统的吞吐量。&lt;/li>
&lt;/ul>
&lt;h3 id="8-connection连接">8. Connection（连接）&lt;/h3>
&lt;p>用于传递消息的 TCP 连接。&lt;/p>
&lt;h3 id="9-channel信道">9. Channel（信道）&lt;/h3>
&lt;p>RabbitMQ 采用类似 NIO (非阻塞式 IO ) 的设计，通过 Channel 来复用 TCP 连接，并确保每个 Channel 的隔离性，就像是拥有独立的 Connection 连接。当数据流量不是很大时，采用连接复用技术可以避免创建过多的 TCP 连接而导致昂贵的性能开销。&lt;/p>
&lt;h3 id="10-virtual-host虚拟主机">10. Virtual Host（虚拟主机）&lt;/h3>
&lt;p>RabbitMQ 通过虚拟主机来实现逻辑分组和资源隔离，一个虚拟主机就是一个小型的 RabbitMQ 服务器，拥有独立的队列、交换器和绑定关系。用户可以按照不同业务场景建立不同的虚拟主机，虚拟主机之间是完全独立的，你无法将 vhost1 上的交换器与 vhost2 上的队列进行绑定，这可以极大的保证业务之间的隔离性和数据安全。默认的虚拟主机名为 &lt;code>/&lt;/code> 。&lt;/p>
&lt;h3 id="11-broker">11. Broker&lt;/h3>
&lt;p>一个真实部署运行的 RabbitMQ 服务。&lt;/p>
&lt;h2 id="五交换器类型">五、交换器类型&lt;/h2>
&lt;p>RabbitMQ 支持多种交换器类型，常用的有以下四种：&lt;/p>
&lt;h3 id="51-fanout">5.1 fanout&lt;/h3>
&lt;p>这是最简单的一种交换器模型，此时会把消息路由到与该交换器绑定的所有队列中。如下图，任何发送到 X 交换器上的消息，都会被路由到 Q1 和 Q2 两个队列上。&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/rabbitmq-fanout-exchange.png"/> &lt;/div>
&lt;h3 id="52-direct">5.2 direct&lt;/h3>
&lt;p>把消息路由到 BindingKey 和 RountingKey 完全一样的队列中。如下图，当消息的 RountingKey 为 orange 时，消息会被路由到 Q1 队列；当消息的 RountingKey 为 black 或 green 时，消息会被路由到 Q2 队列。&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/rabbitmq-direct-exchange.png"/> &lt;/div>
&lt;p>需要特别说明的是一个交换器绑定多个队列时，它们的 BindingKey 是可以相同的，如下图。此时当消息的 RountingKey 为 black 时，消息会同时被路由到 Q1 和 Q2 队列。&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/rabbitmq-direct-exchange-2.png"/> &lt;/div>
&lt;h3 id="53-topic">5.3 topic&lt;/h3>
&lt;p>将消息路由到 BindingKey 和 RountingKey 相匹配的队列中，匹配规则如下：&lt;/p>
&lt;ul>
&lt;li>RountingKey 和 BindingKey 由多个单词使用逗号 &lt;code>.&lt;/code> 进行连接；&lt;/li>
&lt;li>BindingKey 支持两个特殊符号：&lt;code>#&lt;/code> 和 &lt;code>*&lt;/code> 。其中 &lt;code>*&lt;/code> 用于匹配一个单词， &lt;code>#&lt;/code> 用于匹配零个或者多个单词。&lt;/li>
&lt;/ul>
&lt;p>以下是官方文档中的示例，交换器与队列的绑定情况如图所示，此时的路由情况如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/rabbitmq-topic-exchange.png"/> &lt;/div>
&lt;ul>
&lt;li>路由键为 &lt;code>lazy.orange.elephant&lt;/code> 的消息会发送给所有队列；&lt;/li>
&lt;li>路由键为 &lt;code>quick.orange.fox&lt;/code> 的消息只会发送给 Q1 队列；&lt;/li>
&lt;li>路由键为 &lt;code>lazy.brown.fox&lt;/code> 的消息只会发送给 Q2 队列；&lt;/li>
&lt;li>路由键为 &lt;code>lazy.pink.rabbit&lt;/code> 的消息只会发送给 Q2 队列；&lt;/li>
&lt;li>路由键为 &lt;code>quick.brown.fox&lt;/code> 的消息与任何绑定都不匹配；&lt;/li>
&lt;li>路由键为 &lt;code>orange&lt;/code> 或 &lt;code>quick.orange.male.rabbit&lt;/code> 的消息也与任何绑定都不匹配。&lt;/li>
&lt;/ul>
&lt;h3 id="54-headers">5.4 headers&lt;/h3>
&lt;p>在交换器与队列进行绑定时可以指定一组键值对作为 BindingKey；在发送消息的 headers 中的可以指定一组键值对属性，当这些属性与 BindingKey 相匹配时，则将消息路由到该队列。同时还可以使用 &lt;code>x-match&lt;/code> 参数指定匹配模式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>x-match = all&lt;/strong> ：所有的键值对都相同才算匹配成功；&lt;/li>
&lt;li>&lt;strong>x-match = any&lt;/strong>：只要有一个键值对相同就算匹配成功。&lt;/li>
&lt;/ul>
&lt;p>headers 类型的交换器性能比较差，因此其在实际开发中使用得比较少。&lt;/p>
&lt;h2 id="六死信队列">六、死信队列&lt;/h2>
&lt;p>RabbitMQ 中另外一个比较常见的概念是死信队列。当消息在一个队列中变成死信 (dead message) 之后，它可以被重新被发送到死信交换器上 (英文为 Dead-Letter-Exchange，简称 DLX )，任何绑定死信交换器的队列都称之为死信队列。需要特别说明的是死信交换器和死信队列与正常的交换器和队列完全一样，采用同样的方式进行创建，它们的名称表达的是其功能，而不是其类型。一个正常的消息变成死信一般是由于以下三个原因：&lt;/p>
&lt;ul>
&lt;li>消息被拒绝 (Basic.Reject/Basic.Nack) ，井且设置重回队列的参数 requeue 为 false；&lt;/li>
&lt;li>消息过期；&lt;/li>
&lt;li>队列达到最大长度。&lt;/li>
&lt;/ul>
&lt;p>我们可以在队列创建的 channel.queueDeclare 方法中设置 x-dead-letter-exchange 参数来为正常队列添加死信交换器，当该队列中存在死信时，死信就会被发送到死信交换器上，进而路由到死信队列上。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 创建死信交换器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">channel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">exchangeDeclare&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;exchange.dlx&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;direct&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 声明死信队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">channel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">queueDeclare&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34; queue.d1x &amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 绑定死信交换器和死信队列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">channel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">queueBind&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;queue.dlx &amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;exchange.dlx &amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;routingkey&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HashMap&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">args&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;x-dead-letter-exchange&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;exchange.dlx&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 为名为 myqueue 的正常队列指定死信交换器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">channel&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">queueDeclare&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;queue.normal&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外，您还可以重新指定死信的路由键，如果没有指定，则默认使用原有的路由键，重新设置的方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">args.put&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;x-dead-letter-routing-key&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;some-routing-key&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ol>
&lt;li>朱忠华 . RabbitMQ 实战指南 . 电子工业出版社 . 2017-11-1&lt;/li>
&lt;li>官方文档：&lt;a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ Tutorials&lt;/a> 、&lt;a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">Documentation: Table of Contents&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>RocketMQ-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/rocketmq-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/04.infrastructure/messagequeue/rocketmq-cheatsheet/</guid><description>&lt;h1 id="rocketmq-cheatsheet">RocketMQ CheatSheet&lt;/h1>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/d06e9bc6c463?from=timeline&amp;amp;isappinstalled=0" target="_blank" rel="noopener">https://www.jianshu.com/p/d06e9bc6c463?from=timeline&amp;isappinstalled=0&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/meilong_whpu/article/details/76922456" target="_blank" rel="noopener">https://blog.csdn.net/meilong_whpu/article/details/76922456&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/gesanghuakaisunshine/article/details/80261628" target="_blank" rel="noopener">https://blog.csdn.net/gesanghuakaisunshine/article/details/80261628&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>