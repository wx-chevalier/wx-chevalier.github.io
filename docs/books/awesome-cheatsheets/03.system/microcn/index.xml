<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MicroCN | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/</link><atom:link href="https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/index.xml" rel="self" type="application/rss+xml"/><description>MicroCN</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>MicroCN</title><link>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/</link></image><item><title>Auth-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/auth-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/auth-cheatsheet/</guid><description>&lt;h1 id="auth-cheatsheet--权限认证机制概述">Auth CheatSheet | 权限认证机制概述&lt;/h1>
&lt;p>可以阅读 &lt;a href="https://parg.co/GWc" target="_blank" rel="noopener">Web 安全实践清单&lt;/a> 了解权限校验、密码规范等安全相关知识。WebAPI 或者 RPC 接口，&lt;a href="">HTTP CheatSheet&lt;/a>，&lt;a href="">DOM CheatSheet/数据存储&lt;/a>。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/63885ca816f2c2beb1ff12ce.jpg" alt="Session, cookie, JWT, token, SSO, and OAuth 2.0" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>WWW-Authenticate 是最基本的方法，浏览器会要求你提供用户名和密码。由于无法控制登录的生命周期，现在已经很少使用了。&lt;/li>
&lt;li>对登录生命周期的更精细的控制是 session-cookie。服务器保持会话存储，而浏览器则保持会话的 ID，一个 cookie 通常只适用于浏览器，对移动应用不友好。&lt;/li>
&lt;li>使用 token 来解决兼容性问题，客户端将令牌发送给服务器，而服务器则验证令牌的有效性。缺点是需要对令牌进行加密和解密，这可能很耗时。&lt;/li>
&lt;li>JWT 是一种代表令牌的标准方式。这种信息可以被验证和信任，因为它是数字签名的。由于 JWT 包含签名，所以不需要在服务器端保存会话信息。&lt;/li>
&lt;li>通过使用 SSO（单点登录），你可以只登录一次，并登录到多个网站。它使用 CAS（中央认证服务）来维护跨网站信息&lt;/li>
&lt;li>通过使用 OAuth 2.0，你可以授权一个网站访问你在另一个网站的信息&lt;/li>
&lt;/ul>
&lt;h1 id="http-basic-认证">HTTP Basic 认证&lt;/h1>
&lt;p>桌面应用程序也通过 HTTP 协议跟 Web 服务器交互，桌面应用程序一般不会使用 cookie, 而是把 &amp;quot; 用户名 + 冒号 + 密码 &amp;quot; 用 BASE64 算法加密后的字符串放在 http request 中的 header Authorization 中发送给服务端，这种方式叫 HTTP 基本认证 (Basic Authentication)&lt;/p>
&lt;p>当浏览器访问使用基本认证的网站的时候，浏览器会提示你输入用户名和密码，如下图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://pic002.cnblogs.com/images/2012/263119/2012092510283354.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>假如用户名密码错误的话，服务器会返回 401 如下图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://pic002.cnblogs.com/images/2012/263119/2012092510293780.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>HTTP 基本认证的过程&lt;/p>
&lt;p>第一步 : 客户端发送 http request 给服务器，&lt;/p>
&lt;p>第二步 : 因为 request 中没有包含 Authorization header, 服务器会返回一个 401 Unauthozied 给客户端，并且在 Response 的 header &amp;ldquo;WWW-Authenticate&amp;rdquo; 中添加信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://pic002.cnblogs.com/images/2012/263119/2012092121494456.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>第三步：客户端把用户名和密码用 BASE64 加密后，放在 Authorization header 中发送给服务器，认证成功。&lt;/p>
&lt;p>第四步：服务器将 Authorization header 中的用户名密码取出，进行验证，如果验证通过，将根据请求，发送资源给客户端&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://pic002.cnblogs.com/images/2012/263119/2012092121495881.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>使用 Fiddler Inspectors 下的 Auth 选项卡，可以很方便的看到用户名和密码&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://pic002.cnblogs.com/images/2012/263119/2012092121505442.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>HTTP 基本认证的优点&lt;/p>
&lt;p>HTTP 基本认证，简单明了。Rest API 就是经常使用基本认证的。&lt;/p>
&lt;p>每次都要进行认证&lt;/p>
&lt;p>http 协议是无状态的，同一个客户端对 服务器的每个请求都要求认证。&lt;/p>
&lt;h1 id="基于-session-的认证">基于 Session 的认证&lt;/h1>
&lt;p>Cookie 与 Session 的存在主要是为了解决 HTTP 这一无状态协议下服务器如何识别用户的问题，其原理就是在用户登录通过验证后，服务端将数据加密后保存到客户端浏览器的 Cookie 中，同时服务器保留相对应的 Session（文件或 DB）。用户之后发起的请求都会携带 Cookie 信息，服务端需要根据 Cookie 寻回对应的 Session，从而完成验证，确认这是之前登陆过的用户。其工作原理如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/43043318-d9211e10-8dc3-11e8-806c-e3074eb4dd39.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="基于-token-的认证">基于 Token 的认证&lt;/h1>
&lt;h2 id="json-web-token">JSON Web Token&lt;/h2>
&lt;h1 id="oauth">OAuth&lt;/h1>
&lt;h1 id="认证策略">认证策略&lt;/h1>
&lt;h2 id="单点登录">单点登录&lt;/h2>
&lt;h2 id="2fa-双因子认证">2FA 双因子认证&lt;/h2></description></item><item><title>GraphQL-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/graphql-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/graphql-cheatsheet/</guid><description>&lt;h1 id="graphql-cheatsheet--graphql-入门指引与实践清单">GraphQL CheatSheet | GraphQL 入门指引与实践清单&lt;/h1>
&lt;p>GraphQL 是由 Facebook 开源的查询语言标准，其并非具体的后端编程框架，而是一个包含了数据格式、数据关联、查询方式定义与实现等等一揽子东西的数据抽象层。GraphQL 并不能消融业务内在的复杂度，而是通过引入灵活的数据抽象层，尽量解耦前后端之间的直接关联或者阻塞；在满足日益增长不断变化的 Web/Mobile 端复杂的数据需求的同时，尽可能避免服务端内部逻辑复杂度的无序增加。GraphQL 能够用于实践 &lt;a href="https://www.thoughtworks.com/radar/techniques/bff-backend-for-frontends" target="_blank" rel="noopener">BFF&lt;/a> 理念，其允许将部分数据组装/聚合地逻辑交于前端完成，即给予了前端灵活变更、快速迭代的空间，也能保证后端的相对中立性，不会疲于应付不同端或者不同界面设计的差异化数据格式要求。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/39741543-ef8d4c50-52cc-11e8-9d16-c3f71329290a.jpg" alt="default" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>经典的 REST 架构模式立足资源，规范了基础的增删改查操作，却未能很好地处理资源之间的关联，及其衍生的一系列接口命名、代码分层等问题。接口名是对于某个逻辑的抽象描述，其往往会关联到某个特定的服务以及特定的多表查询语句，这就导致了接口、服务、SQL 语句与某个逻辑的强耦合性，而无法动态地应对业务逻辑的快速变化。笔者在早年间提出的 &lt;a href="https://parg.co/AvR" target="_blank" rel="noopener">RARF&lt;/a> 架构模式中也探讨过，将请求再资源间响应式地流动与转换，单个资源仅需要关心与其他邻接资源的转换而不需要耦合于某个接口的返回，这也是典型的图模式。&lt;/p>
&lt;p>与 REST 相比，GraphQL 为我们提供了声明式(Declarative)、分层可组合的(Hiearchial)、强类型控制(Static Type)的接口声明与交互方式；即保证了单一的查询端点，也提供了更严格、可扩展、可维护的数据查询方式(详见下文-数据模型层)。单一的查询端点能够让开发者免于考虑大量复杂的接口命名，直接使用图查询语言，也能更好地描述资源之间的关系；同时像 GraphiQL 这样的工具也能够帮我们快速生成交互式地接口文档。GraphQL 本质上是面向消费者的，客户端驱动的开发模式；它允许请求方(即客户端)而非响应方(即服务器端)决定查询的结果格式，从而返回可预测(Predictable)的结果类型，省去了客户端很多的异常情况处理与向后兼容的操作(Backwards Compatible)，提升了产品整体的健壮性。这样确实使得整个请求需要很多额外的数据参数与编码工作，但是它就将消费者与服务端解耦，并且强迫服务端遵守 Postel 法则(对自己严格，对他人宽容)。&lt;/p>
&lt;p>不过 GraphQL 并非银弹，其并未缓解业务逻辑本身的复杂度，反而图查询方式在弱化各模块间的耦合的同时带来多次查询的性能损耗，在代码规范、模块划分不当的情况下可能导致渐进式地微服务切分割离也变得麻烦。于前端，直接用 Apollo Graphql React 这样的框架替代原有的状态管理，将组件直接绑定于接口，就是在破坏前端应用的自治性，与 SOLID 背道而驰，将独立的前端应用强耦合于后端；单一的端点在网络调试时也是不甚方便。Graphql 作为前端编写，维护的数据聚合层是非常好的选择，但是小型项目也可以在前端完成自聚合；将服务端的计算查询压力，传导给分布式的，性能日渐强大的客户端，也不失一个选择。Rest 与 GraphQL 并非取舍关系，而是渐进融合，Rest 项目在自身迭代衍化的过程中也可以不断地借鉴 GraphQL 中的一些思想或者理念，来解决譬如模型分层与界定等问题。&lt;/p>
&lt;p>值得一提的是，&lt;a href="https://developer.github.com/v4/explorer/" target="_blank" rel="noopener">Github Explorer&lt;/a> 是非常不错的在 Github GraphQL API 中实践 GraphQL 的在线练习场，也可以在 &lt;a href="https://github.com/wx-chevalier/Backend-Boilerplate/blob/master/node/graphql" target="_blank" rel="noopener">Backend-Boilerplate/graphql&lt;/a> 中了解笔者的 GraphQL 相关模板。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gql" data-lang="gql">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nc">user&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="py">login&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;wx-chevalier&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nc">starredRepositories&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">totalCount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">followers&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">totalCount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">repositories&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="py">first&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">35&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nc">nodes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">descriptionHTML&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">forkCount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">stargazers&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="py">totalCount&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>HA-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/ha-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/ha-cheatsheet/</guid><description>&lt;h1 id="ha-cheatsheet--一文了解高可用架构关键点性能指标负载均衡缓存降级与限流">HA CheatSheet | 一文了解高可用架构关键点：性能指标、负载均衡、缓存、降级与限流&lt;/h1>
&lt;h1 id="监控告警与测试">监控、告警与测试&lt;/h1>
&lt;h1 id="负载均衡">负载均衡&lt;/h1>
&lt;h1 id="数据库优化">数据库优化&lt;/h1>
&lt;h2 id="缓存">缓存&lt;/h2>
&lt;h2 id="分库分表">分库分表&lt;/h2>
&lt;h2 id="性能优化">性能优化&lt;/h2>
&lt;h1 id="服务容错">服务容错&lt;/h1>
&lt;h2 id="服务降级">服务降级&lt;/h2>
&lt;h2 id="服务隔离">服务隔离&lt;/h2>
&lt;h1 id="秒杀系统">秒杀系统&lt;/h1></description></item><item><title>MicroService-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/microservice-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/microservice-cheatsheet/</guid><description>&lt;h1 id="microservice-cheatsheet--微服务理念架构与实践速览">MicroService CheatSheet | 微服务理念、架构与实践速览&lt;/h1>
&lt;p>微服务是系统或应用程序中的自包含独立组件。每个微服务都应该有明确的作用域和责任，理想情况下，一个微服务只做一件事。它应该是无状态的或有状态的，如果它是有状态的，它应该带有自己的持久层（即数据库），不与其他服务共享。软件开发团队基于微服务架构以更分散的方式开发可重用的独立组件。他们可以为每个微服务使用自定义框架、依赖关系集，甚至是完全不同的编程语言。微服务也有助于实现可扩展性，因为它们本质上是分布式的，并且每个微服务都可以独立增长或复制。&lt;/p>
&lt;p>微服务微前端，都是希望将某个单一的单体应用，转化为多个可以独立运行、独立开发、独立部署、独立维护的服务或者应用的聚合。如康威定律(Conway’s Law)所言，设计系统的组织，其产生的设计和架构等价于组织间的沟通结构；微服务与微前端不仅仅是技术架构的变化，还包含了组织方式、沟通方式的变化。微服务与微前端原理和软件工程，面向对象设计中的原理同样相通，就像高级编程语言一样，微服务以更抽象能力提供了更好地描述问题的方式；并且它们都是遵循单一职责(Single Responsibility)、关注分离(Separation of Concerns)、模块化(Modularity)与分而治之(Divide &amp;amp; Conquer)等基本的原则。&lt;/p>
&lt;p>&lt;a href="">HA CheatSheet | 高可用架构手册&lt;/a>或者 &lt;a href="">Spring Boot CheatSheet&lt;/a>，&lt;a href="">微前端&lt;/a>。&lt;/p>
&lt;p>很多人认为微服务是一种细粒度的 SOA，在去掉了 SOA 中的 ESB 之后，微服务变得更加灵活、性能更强。Martin Fowler 曾经总结过微服务实施的前提包括：&lt;/p>
&lt;p>计算资源的快速分配&lt;/p>
&lt;p>基本的监控&lt;/p>
&lt;p>快速部署&lt;/p>
&lt;p>虽然如 Spring Cloud、Dubbo 微服务框架在各方面已经非常完善，但随着云原生计算基金会的壮大，基于 Kubernetes 的微服务在社区中的热度越来越高，也开始有很多公司开始利用这一套技术栈来构建微服务。&lt;/p>
&lt;h1 id="单体应用与微服务">单体应用与微服务&lt;/h1>
&lt;p>微服务是一个简单而泛化的概念，不同的行业领域、技术背景、业务架构对于微服务的理解与实践也是不一致的。与微服务相对的，即是单体架构的巨石型(Monolithic)应用，典型的即是将所有功能都部署在一个 Web 容器中运行的系统。虽然很多的文章对于巨石型应用颇多诟病，但并不意味着其就真的一无是处，毕竟微服务本身也是有代价的。除了组织的结构之外，微服务往往还要求组织具备快速的环境提供(Rapid Provisioning)与云开发、基本的监控(Basic Monitoring)、快速的应用发布(Rapid Application Deployment)、DevOps 等能力。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/43848094-c9c506c6-9b64-11e8-9658-62066098ce86.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;a href="https://www.processon.com/view/link/5a8b974ae4b059c41ac40e07" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/36406479-25dcddf2-1632-11e8-91a3-2db79aaf7492.png" alt="microservice" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/a>&lt;/p>
&lt;h2 id="架构衍化">架构衍化&lt;/h2>
&lt;p>团队规模不大的时候，单块架构比微服务架构具有更高的生产率(Productivity)，建立微服务架构需要额外的开销来支持和管理微服务，从而降低生产率；但是随着业务复杂性的增加和团队规模的扩大，单块架构比微服务架构的生产率下降更趋明显，当复杂性达到一个点，微服务的松散耦合自治特性减缓了生产率的下降趋势，微服务架构的生产率会优于单块架构。换言之，如果团队能力强，不管用单块还是微服务，都能找到好的管理复杂性的手段，所以说团队的技能才是管理复杂性的关键。&lt;/p>
&lt;p>在系统早期流量较少时，只需一个应用将所有功能都部署在一起，以减少部署节点和成本；此时，用于简化增删改查工作量的数据访问框架 (ORM) 是关键。随着流量逐步增大，我们过渡为了包含多个相互隔离应用的垂直应用架构；如下图 y 轴的衍化，即是将不同职能的模块分成不同的服务，也逐步开始了微服务化的步伐。接下来，随着垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中台；此时我们即需要考虑应用间的协调治理，也需要考虑如下图所示的 x 轴水平扩展以及 z 轴分库分表的数据库扩展等操作。系统继续衍化，服务数目、体量持续增加，小服务资源的浪费等问题逐渐显现，需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率；此时对于资源调度与治理越发的关键。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/43848114-d5dc2cfa-9b64-11e8-8956-b1636019f22a.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="存储分隔与无状态服务">存储分隔与无状态服务&lt;/h2>
&lt;p>在编码中，我们往往倾向于使用纯函数来描述抽象逻辑，以保证代码的可读性与可测性；并且纯函数也可以非常方便地使用并发编程或者结果缓存等方式来进行扩展与优化。而在微服务系统中&lt;/p>
&lt;p>The monolithic approach on the left has a single database and tiers of specific technologies.&lt;/p>
&lt;p>The microservices approach on the right has a graph of interconnected microservices where state is typically scoped to the microservice and various technologies are used.&lt;/p>
&lt;p>In a monolithic approach, typically the application uses a single database. The advantage is that it is a single location, which makes it easy to deploy. Each component can have a single table to store its state. Teams need to strictly separate state, which is a challenge. Inevitably there are temptations to add a new column to an existing customer table, do a join between tables, and create dependencies at the storage layer. After this happens, you can&amp;rsquo;t scale individual components.&lt;/p>
&lt;p>In the microservices approach, each service manages and stores its own state. Each service is responsible for scaling both code and state together to meet the demands of the service. A downside is that when there is a need to create views, or queries, of your application’s data, you need to query across disparate state stores. Typically, this is solved by having a separate microservice that builds a view across a collection of microservices. If you need to perform multiple impromptu queries on the data, each microservice should consider writing its data to a data warehousing service for offline analytics.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://docs.microsoft.com/en-us/azure/service-fabric/media/service-fabric-overview-microservices/statemonolithic-vs-micro.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所谓的“单体”，即把所有服务代码结合一个“项目”打包发布，也就是一个“普通”的项目并且共用一个数据库，但每个服务的表名都有服务的标识（约定），例如商品服务的相关表名以“KW_GOODS_XXX”命名，订单服务的相关表名以“KW_ORDER_XXX”命名，支付服务的相关表名以“KW_PAYMENT_XXX”命名，充值服务的相关表名以“KW_RECHARGE_XXX”命名，对账服务的相关表名以“KW_ACCOUNT_XXX”命名，服务之间决不能跨越服务操作数据库表，必须按照“业务流程设计”调用，所以“单体”只是体现在物理实施层面，逻辑层面始终保持着“微服务”的分布式特性，保留了各种不用修改一行代码即可灵活扩展的可能性。&lt;/p>
&lt;h1 id="微服务的挑战">微服务的挑战&lt;/h1>
&lt;p>微服务应用往往由多个粒度较小，版本独立，有明确边界并可扩展的服务构成，各个服务之间通过定义好的标准协议相互通信。在构建微服务架构时，模块化(Modularity)和分而治之(Divide &amp;amp; Conquer)是基本的思路。然后需要考虑单一职责(Single Responsibility)原则，即一个服务应当承担尽可能单一的职责，服务应基于有界的上下文(Bounded Context)，通常是边界清晰的业务领域构建；服务理想应当只有一个变更的理由，当一个服务承担过多职责，就会产生各种耦合性问题，需要进一步拆分使其尽可能职责单一化。其次我们需要遵循关注分离(Separation of Concerns)，将日志分析、监控、限流、安全等横向功能与具体的业务逻辑相互分离，让开发人员能专注于业务逻辑的开发。&lt;/p>
&lt;p>&lt;a href="https://www.processon.com/view/link/5a8b974ae4b059c41ac40e07" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/36406479-25dcddf2-1632-11e8-91a3-2db79aaf7492.png" alt="microservice" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/a>&lt;/p>
&lt;p>当我们开始构建微服务系统时，首先要考虑的就是服务之间如何通信交互。基于微服务架构构建的应用程序或 API 不仅要把自己完全暴露出来，还需要在内部组件（微服务）之间建立连接。由于每个微服务都可以使用不同的编程语言实现，我们需要依赖标准协议（如 HTTP）来建立微服务之间的连接。这个时候我们就回到了 API 上。
最基本的形式是每个微服务都公开一个 API，让其他服务可以向这个 API 发出请求并获取数据。也可以使用其他不同的方法，比如消息队列。微服务 API 是私有 API，仅限用在单个应用程序中。它通常不提供公共 URL，而是使用组织内部专用网络的私有 IP 或主机名，甚至是单个服务器集群内的 IP 或主机名。不过，这些 API 可以遵循类似公共 API 那样的设计范式或协议。而且，尽管它们的消费者数量有限，也应该遵循开发者体验的基本规则。也就是说，它们应该拥有相关的、一致的、可演化的 API 设计和文档，让其他团队（甚至是你自己）知道如何使用这些微服务。&lt;/p>
&lt;h2 id="服务网关">服务网关&lt;/h2>
&lt;p>网关一词较早出现在网络设备里面，比如两个相互独立的局域网段之间通过路由器或者桥接设备进行通信，这中间的路由或者桥接设备我们称之为网关。&lt;/p>
&lt;p>相应的 API 网关将各系统对外暴露的服务聚合起来，所有要调用这些服务的系统都需要通过 API 网关进行访问，基于这种方式网关可以对 API 进行统一管控，例如：认证、鉴权、流量控制、协议转换、监控等等。API 网关的流行得益于近几年微服务架构的兴起，原本一个庞大的业务系统被拆分成许多粒度更小的系统进行独立部署和维护，这种模式势必会带来更多的跨系统交互，企业 API 的规模也会成倍增加，API 网关(或者微服务网关)就逐渐成为了微服务架构的标配组件。&lt;/p>
&lt;p>Kong, Traefik, Caddy, Linkerd, Fabio, Vulcand, and Netflix Zuul seem to be the most common in microservice proxy/gateway solutions. Kubernetes Ingress is often a simple Ngnix, which is difficult to separate the popularity from other things.&lt;/p>
&lt;p>A Service Mesh is related, but distinct from the concept of API gateways, edge proxies, and the enterprise service bus. The service mesh is a networking model that sits at a layer of abstraction above TCP/IP. A Service Mesh provides three benefits:&lt;/p>
&lt;p>security (TLS for service to service authentication)
intelligent traffic management (proxy, deployed as a sidecar to the relevant service)
visibility (monitoring and tracing for troubleshooting and debugging)
Lyft&amp;rsquo;s Istio or Bouyant&amp;rsquo;s Linkerd or Conduit are examples of a Service Mesh, while Traefik, Envoy, Kong, Zuul, etc. are API Gateway implemented using Reverse Proxy. Before Linkerd/Istio/Conduit, large companies implemented the same functionality using fat client libraries.&lt;/p>
&lt;p>In these systems, a generalized communication layer became suddenly relevant, but typically took the form of a “fat client” library—Twitter’s Finagle, Netflix’s Hysterix, and Google’s Stubby being cases in point.&lt;/p>
&lt;p>1、面向 Web 或者移动 App&lt;/p>
&lt;p>这类场景，在物理形态上类似前后端分离，前端应用通过 API 调用后端服务，需要网关具有认证、鉴权、缓存、服务编排、监控告警等功能。&lt;/p>
&lt;p>2、面向合作伙伴开放 API&lt;/p>
&lt;p>这类场景，主要为了满足业务形态对外开放，与企业外部合作伙伴建立生态圈，此时的 API 网关注重安全认证、权限分级、流量管控、缓存等功能的建设。&lt;/p>
&lt;p>3、企业内部系统互联互通&lt;/p>
&lt;p>对于中大型的企业内部往往有几十、甚至上百个系统，尤其是微服务架构的兴起系统数量更是急剧增加。系统之间相互依赖，逐渐形成网状调用关系不便于管理和维护，需要 API 网关进行统一的认证、鉴权、流量管控、超时熔断、监控告警管理，从而提高系统的稳定性、降低重复建设、运维管理等成本。&lt;/p>
&lt;p>服务发现是大部分分布式系统和面向服务架构的核心组件。最初问题看起来很简单：&lt;em>客户如何决定服务的 IP 地址和端口，这些服务已存在于多个服务器上的。&lt;/em>&lt;/p>
&lt;p>通常，你开始一些静态的配置，这些配置离你需要做的还挺远的。当你开始布署越来越多的服务时，事情会越来越复杂。在一个上线的系统中，由于自动的或人为的规模变化，服务的位置会经常的变化，例如布署新的服务，服务器宕机或者被替换。&lt;/p>
&lt;p>在这些应用场景中为了避免服务冲突，动态的服务注册和发现会越来越重要。&lt;/p>
&lt;p>定位服务的问题划分为两类。服务注册与服务发现。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务注册&lt;/strong> - 服务进程在注册中心注册自己的位置。它通常注册自己的主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的详细资料。&lt;/li>
&lt;li>&lt;strong>服务发现&lt;/strong> - 客户端应用进程向注册中心发起查询，来获取服务的位置。&lt;/li>
&lt;/ul>
&lt;p>任何服务注册、服务发现也有其它开发、操作层面的考虑：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>监控&lt;/strong> - 如果服务注册失败会发生什么？有时会因为超时、或者其它进程而突然处于未注册状态。通常会要求服务实现心跳机制来确保其活跃性，并且通常要求客户端有能力可靠地处理失效的服务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>负载均衡&lt;/strong> -如果多个服务被注册，怎样来处理所有的客户端跨服务的均衡问题？如果有个主服务，它能被客户端正确的判断吗？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>集成风格&lt;/strong> - 注册中心仅仅提供了少量语言的绑定，例如仅仅支持 Java 吗？集成需要嵌入注册与发现的代码到程应用程序中，还是可以选择一个辅助进程？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>运行时依赖&lt;/strong> - 它需要 JVM，Ruby 或者其它与你的运行环境不兼容的软件吗？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可用性考虑&lt;/strong> - 丢失一个节点能继续工作吗？升级时不会中断服务吗？注册处会成为架构的中心部分，会变成单点故障吗？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>请求路由，客户端直接调用 Gateway，Gateway 负责路由转发到注册服务上
服务注册，后端服务将 API 注册，Gateway 负责路由
负载均衡，支持多种负载策略
round robin
随机均衡算法
多权重负载
session 粘连
其它
安全特性，支持 HTTPS，账户鉴权，及其它安全特性支持
灰度发布，可以针对服务版本或者租户等特性做灰度发布
API 聚合，将多个后端接口聚合，减少客户端调用次数
API 编排，通过编排来串接多个 API 完成特定业务&lt;/p>
&lt;p>设计要点
可用性，必须保证高可用
扩展性，可以灵活扩展以支持特定业务比如特定业务流控
高性能，通常使用异步 IO 模型框架实现，比如 Java netty，Go Channel
安全，如加密通信，鉴权，DDOS 防御等
运维
应用监控，包括容量，性能，异常检测等
弹性伸缩，具备高弹性能力，以低成本应对高峰值
架构
与业务解耦合，提供扩展扩展机制比如 Plugin，Serverless 的思路支持后端业务
服务隔离，可以按照后端服务划分网关，做到不同服务使用不同网关
网关部署靠近后端，保证网络损耗最小，性能最佳&lt;/p>
&lt;h2 id="服务注册与服务发现">服务注册与服务发现&lt;/h2>
&lt;h2 id="服务协调">服务协调&lt;/h2>
&lt;h3 id="配置中心">配置中心&lt;/h3>
&lt;h2 id="服务编排">服务编排&lt;/h2>
&lt;h2 id="service-mesh">Service Mesh&lt;/h2>
&lt;p>sidecar 把所有流量都劫持了，在网络层面做治理。在 service mesh 里面，分成数据面和控制面，数据面就是 sidecar，把所有网络流量都拿在手里。控制面就包括服务发现，sidecar 的配置管理。&lt;/p>
&lt;p>价值
分离控制与逻辑，分离业务逻辑与路由，流控，熔断，幂等，服务发现，鉴权等控制组件
适用场景
老系统改造扩展，Sidebar 进程与服务进程部署在同一个节点，通过网络协议通讯
多语言混合分布式系统扩展
应用程序由多方提供
设计要点
标准服务协议，Sidebar 到 Service，Sidebar 到 Sidebar 协议尽可能与语言解耦
聚合控制逻辑比如流控，熔断，幂等，重试，减少业务逻辑
不要使用对服务侵入的方式进行进程间通讯如信号量，共享内存，优先使用本地网络通讯的方式比如 TPCP 或者 HTTP&lt;/p>
&lt;h1 id="部署">部署&lt;/h1>
&lt;p>在项目迭代的过程中，不可避免需要”上线“。上线对应着部署，或者重新部署；部署对应着修改；修改则意味着风险。&lt;/p>
&lt;h2 id="bluegreen-deployment--蓝绿部署">Blue/Green Deployment | 蓝绿部署&lt;/h2>
&lt;p>蓝绿部署是不停老版本，部署新版本然后进行测试，确认 OK，将流量切到新版本，然后老版本同时也升级到新版本。&lt;/p>
&lt;h1 id="架构模式">架构模式&lt;/h1>
&lt;h2 id="eda">EDA&lt;/h2>
&lt;h2 id="cqrs">CQRS&lt;/h2>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/022685baba7d" target="_blank" rel="noopener">https://www.jianshu.com/p/022685baba7d&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Nginx-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/nginx-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/03.system/microcn/nginx-cheatsheet/</guid><description>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://blog.commando.io/content/images/2014/11/1-Tg9FYCN99FlNj0gn9u8s7A-5-2.jpeg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="nginx-cheatsheet--nginx-配置详解与生产环境实践">Nginx CheatSheet | Nginx 配置详解与生产环境实践&lt;/h1>
&lt;h2 id="一nginx-简介">一、Nginx 简介&lt;/h2>
&lt;h3 id="11-简介">1.1 简介&lt;/h3>
&lt;p>Nginx（engine x）是一个免费的，开源的，高性能的 HTTP 服务器， IMAP/POP3 代理服务器 和 TCP/UDP 代理服务器，通常可以用于进行反向代理和实现基于软件的负载均衡，除此之外，它还具备以下特性：&lt;/p>
&lt;ul>
&lt;li>Nginx 在设计时遵循模块化的设计方案，可以通过组合模块来扩展实现不同的功能，具备很高的扩展性。&lt;/li>
&lt;li>Nginx 遵循 matser \ worker 架构，主进程负责管理一个或者多个 worker 进程，每个 worker 进程负责处理实际的连接，当某个 worker 进程出错时，主进程会迅速创建一个新的 worker 来继续处理连接请求，从而保证高可用。&lt;/li>
&lt;li>Nginx 在高连接数的情况下仍然可以保持极低的内存占用，从而可以支持高并发量地访问。&lt;/li>
&lt;li>Nginx 支持热部署和配置热加载，并支持在不停机的情况下进行版本升级。&lt;/li>
&lt;li>有免费的开源版本和商业版本 ( Nginx Plus )，可以按需选择或者进行二次开发。&lt;/li>
&lt;li>在高并发环境下，Nginx 比其他 WEB 服务器有更快的响应速度。&lt;/li>
&lt;/ul>
&lt;h3 id="12-正向代理和反向代理">1.2 正向代理和反向代理&lt;/h3>
&lt;p>Nginx 能够同时支持正向代理和反向代理，这两种代理模式的区别如下：&lt;/p>
&lt;ul>
&lt;li>正向代理发生在客户端，是客户端主动发起的代理。如我们不能直接访问某个服务器，但可以间接通过中间的代理服务器去进行访问，然后将访问结果再返回给我们。&lt;/li>
&lt;li>反向代理发生在服务端，客户端并不知道发生了代理，示例如下。用户只知道将请求发送给 Nginx，但是并不知道请求被转发了，也不知道被转发给了哪一台应用服务器。实际上对于用户来说，他也没必要知道，因为请求结果都是相同的。&lt;/li>
&lt;/ul>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/nginx-plus.png"/> &lt;/div>
&lt;h2 id="二基本命令">二、基本命令&lt;/h2>
&lt;p>Nginx Shell 的基本使用格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">nginx &lt;span class="o">[&lt;/span>-?hvVtTq&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-s signal&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-c filename&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-p prefix&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-g directives&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>-?,-h&lt;/strong> ：显示帮助信息；&lt;/li>
&lt;li>&lt;strong>-v&lt;/strong>：查看版本号；&lt;/li>
&lt;li>&lt;strong>-V&lt;/strong>：查看版本号及配置信息；&lt;/li>
&lt;li>&lt;strong>-t&lt;/strong>：检测配置文件是否有语法错误；&lt;/li>
&lt;li>&lt;strong>-q&lt;/strong>：静默模式，在检测配置期间除了错误提示外，不输出其他消息；&lt;/li>
&lt;li>&lt;strong>-s signal&lt;/strong>：向 Master 进程发送信号，支持以下信号类型：stop ( 立即停止 )，quit ( 优雅停止 )，reload ( 重新加载配置文件 )，reopen (打开一个新的日志文件来继续记录日志) ；&lt;/li>
&lt;li>&lt;strong>-p prefix&lt;/strong> ：指定路径的前缀，默认为安装目录，如 &lt;code>/usr/app/nginx-1.16.1/&lt;/code> ；&lt;/li>
&lt;li>&lt;strong>-c filename&lt;/strong> ：指定配置文件的位置， 默认值为 &lt;code>conf/nginx.conf&lt;/code>，其实际指向的路径为 &lt;code>prefix + filename&lt;/code>；&lt;/li>
&lt;li>&lt;strong>-g directives&lt;/strong>：从指定的配置文件中设置全局指令。&lt;/li>
&lt;/ul>
&lt;h2 id="三配置格式">三、配置格式&lt;/h2>
&lt;h3 id="31-基本配置格式">3.1 基本配置格式&lt;/h3>
&lt;p>Nginx 的配置由全局配置和局部配置（指令块）共同组成，所有的指令块都遵循相同的配置格式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;lt;section&amp;gt;{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">&amp;lt;directive&amp;gt;&lt;/span> &lt;span class="s">&amp;lt;parameters&amp;gt;;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指令块使用大括号进行划分，大括号内是独立的配置上下文，包含指令和具体的参数，每行指令以分号作为结尾。除此之外，Nginx 的配置中还支持以下操作：&lt;/p>
&lt;ul>
&lt;li>支持使用 &lt;code>include&lt;/code> 语法来引入外部配置文件，从而可以将每个独立的配置拆分到单独的文件中；&lt;/li>
&lt;li>支持使用 &lt;code>#&lt;/code> 符号来添加注释；&lt;/li>
&lt;li>支持使用 &lt;code>$&lt;/code> 符号来引用变量；&lt;/li>
&lt;li>部分指令的参数支持使用正则表达式。&lt;/li>
&lt;/ul>
&lt;h3 id="32-时间和空间单位">3.2 时间和空间单位&lt;/h3>
&lt;p>Nginx 的配置文件支持以下空间和时间单位：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>空间单位&lt;/strong>：不加任何单位默认就是 bytes，除此之外还支持 k/K，m/M，g/G 等常用单位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>时间单位&lt;/strong>：支持 ms (毫秒) ，s (秒) ，m (分钟) ，h (小时) ，d (天)，w (星期)，M (月，30 天)，y (年，365 天) 等常用单位，并支持组合使用，如 &lt;code>1h 30m&lt;/code> (1 小时 30 分)，&lt;code>1y 6M&lt;/code>（1 年零 6 个月）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="33-官方配置模板">3.3 官方配置模板&lt;/h3>
&lt;p>在安装 Nginx 后，在安装目录的 conf 目录下会有一个官方的配置样例 nginx.conf ，其内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用这个参数来配置worker进程的用户和组，如果没有指定组，则默认为指定用户所处的组，默认值为nobody&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">user&lt;/span> &lt;span class="s">nobody;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 指定用于处理客户端连接的worker进程的数量，通常设置为CPU的核心数。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果是为IO密集型操作进行负载，可以设置为核心数的1.5 ~ 2倍&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">worker_processes&lt;/span> &lt;span class="s">1;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 指定日志的位置和日志级别，日志级别按照由低到高的顺序如下：[debug|info|notice|warn|error|crit]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">error_log&lt;/span> &lt;span class="s">logs/error.log;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#error_log logs/error.log notice;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#error_log logs/error.log info;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 指定记录主进程的ID的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pid&lt;/span> &lt;span class="s">logs/nginx.pid;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">events&lt;/span> &lt;span class="s">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 指定每个工程线程的最大连接数，总的连接数 max_clients = worker_processes * worker_connections&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">worker_connections&lt;/span> &lt;span class="s">1024;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">http&lt;/span> &lt;span class="s">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 使用include来引用外部文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">include&lt;/span> &lt;span class="s">mime.types;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 指定默认MIME类型&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">default_type&lt;/span> &lt;span class="s">application/octet-stream;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 定义日志的输出格式，使用$来进行变量引用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">#log_format main &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># &amp;#39;&amp;#34;$http_user_agent&amp;#34; &amp;#34;$http_x_forwarded_for&amp;#34;&amp;#39;;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 定义访问日志的存放位置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">access_log&lt;/span> &lt;span class="s">logs/access.log main;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 是否开启系统调用方法sendfile(),开启后可以直接在内核空间完成文件的发送，即零拷贝&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">sendfile&lt;/span> &lt;span class="s">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 是否开启Socket选项,它只有在sendfile启用后才会生效&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">tcp_nopush&lt;/span> &lt;span class="s">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 连接超时时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">keepalive_timeout&lt;/span> &lt;span class="s">65;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 开启文件压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">gzip&lt;/span> &lt;span class="s">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 配置nginx服务器(虚拟主机)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 监听端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">listen&lt;/span> &lt;span class="s">80;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server_name&lt;/span> &lt;span class="s">localhost;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 默认字符集&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">charset&lt;/span> &lt;span class="s">koi8-r;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 配置当前虚拟主机的访问日志的存放位置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">access_log&lt;/span> &lt;span class="s">logs/host.access.log main;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 虚拟主机对应的映射目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">location&lt;/span> &lt;span class="s">/ {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">root&lt;/span> &lt;span class="s">html;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">index&lt;/span> &lt;span class="s">index.html index.htm;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 错误重定向页面&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># error_page 404 /404.html;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">error_page&lt;/span> &lt;span class="s">500 502 503 504 /50x.html;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">location&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">/50x.html {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">root&lt;/span> &lt;span class="s">html;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 禁止访问根目录下以ht结尾的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">location&lt;/span> &lt;span class="s">~ /\.ht {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">deny&lt;/span> &lt;span class="s">all;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 支持配置多台虚拟主机&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">#server {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># listen 8000;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># listen somename:8080;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># server_name somename alias another.alias;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># location / {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># root html;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># index index.html index.htm;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">#}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 配置Https服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">listen&lt;/span> &lt;span class="s">443 ssl;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server_name&lt;/span> &lt;span class="s">localhost;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 指定数字证书&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">ssl_certificate&lt;/span> &lt;span class="s">cert.pem;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 指定密匙&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">ssl_certificate_key&lt;/span> &lt;span class="s">cert.key;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 设置存储session的缓存类型和大小&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">ssl_session_cache&lt;/span> &lt;span class="s">shared:SSL:1m;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># session缓存时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">ssl_session_timeout&lt;/span> &lt;span class="s">5m;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 返回客户端支持的密码列表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">ssl_ciphers&lt;/span> &lt;span class="s">HIGH:!aNULL:!MD5;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">ssl_prefer_server_ciphers&lt;/span> &lt;span class="s">on;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">location&lt;/span> &lt;span class="s">/ {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">root&lt;/span> &lt;span class="s">html;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">index&lt;/span> &lt;span class="s">index.html index.htm;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="四部署静态网站">四、部署静态网站&lt;/h2>
&lt;p>Nginx 通常用作 HTTP 服务器来部署静态资源，其具体的操作步骤如下：&lt;/p>
&lt;h3 id="41-增加配置">4.1 增加配置&lt;/h3>
&lt;p>修改 &lt;code>nginx.conf&lt;/code> ，并在 http 指令块中增加如下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 监听端口号&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">listen&lt;/span> &lt;span class="s">9010;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 如果有域名的话，可以在这里进行配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server_name&lt;/span> &lt;span class="s">_;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 存放静态页面的目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">root&lt;/span> &lt;span class="s">/usr/web;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 主页面&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">index&lt;/span> &lt;span class="s">index.html;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>/usr/web&lt;/code> 目录下新建一个测试页面 index.html，内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&amp;lt;!DOCTYPE html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">html&lt;/span> &lt;span class="na">lang&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;en&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">meta&lt;/span> &lt;span class="na">charset&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;UTF-8&amp;#34;&lt;/span> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">meta&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;viewport&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">content&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;width=device-width, user-scalable=no, initial-scale=1.0,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> maximum-scale=1.0, minimum-scale=1.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">meta&lt;/span> &lt;span class="na">http-equiv&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;X-UA-Compatible&amp;#34;&lt;/span> &lt;span class="na">content&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;ie=edge&amp;#34;&lt;/span> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Nginx静态资源网站&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">h1&lt;/span> &lt;span class="na">style&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;text-align: center&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Nginx静态资源网站&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">h1&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="42-检查配置">4.2 检查配置&lt;/h3>
&lt;p>使用 &lt;code>-t&lt;/code> 参数来检查配置，出现 successful 则代表配置正确：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@node1 web&lt;span class="o">]&lt;/span>&lt;span class="c1"># nginx -t -c conf/nginx.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx: the configuration file /usr/app/nginx-1.16.1/conf/nginx.conf syntax is ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx: configuration file /usr/app/nginx-1.16.1/conf/nginx.conf &lt;span class="nb">test&lt;/span> is successful
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="43-重载配置">4.3 重载配置&lt;/h3>
&lt;p>启动 Nginx ，如果 Nginx 已经启动，可以使用如下命令重载配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">nginx -s reload
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问 http://hostname:9010/index.html ，即可查看到静态网站首页。&lt;/p>
&lt;h2 id="五实现负载均衡">五、实现负载均衡&lt;/h2>
&lt;h3 id="51-部署后台服务">5.1 部署后台服务&lt;/h3>
&lt;p>这里我使用 Docker 来部署两个 Tomcat，之后将测试项目 WAR 包分别拷贝到 &lt;code>/usr/webapps001&lt;/code> 和 &lt;code>/usr/webapps002&lt;/code> 两个挂载的容器卷下，程序会自动解压并运行，两个项目的端口号分别为 8080 和 8090：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">run -d -it --privileged&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> -v /usr/webapps01:/usr/local/tomcat/webapps &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>-p 8080:8080 --name tomcat8080 96c4e536d0eb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">run -d -it --privileged&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> -v /usr/webapps02:/usr/local/tomcat/webapps &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>-p 8090:8080 --name tomcat8090 96c4e536d0eb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="52-负载均衡配置">5.2 负载均衡配置&lt;/h3>
&lt;p>修改 &lt;code>nginx.conf&lt;/code> ，并在 http 指令块中增加如下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 这里指令块的名称可以随意指定，只要和下面的proxy_pass的值相同即可，通常配置为项目名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">upstream&lt;/span> &lt;span class="s">springboot {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">192.168.0.226:8080;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">192.168.0.226:8090;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">server&lt;/span> &lt;span class="s">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">listen&lt;/span> &lt;span class="s">9020;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">location&lt;/span> &lt;span class="s">/ {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">proxy_pass&lt;/span> &lt;span class="s">http://springboot;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> }&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重载配置后，打开浏览器，通过 9020 端口访问项目，此时 Nginx 会以轮询的方式将请求分发到 8080 和 8090 端口上。在测试负载均衡策略的时候，最好将浏览器的缓存功能关闭，避免造成影响。&lt;/p>
&lt;h3 id="53-负载均衡策略">5.3 负载均衡策略&lt;/h3>
&lt;p>在上面的配置中，我们没有配置任何负载均衡策略，默认采用的是轮询策略，除此之外，Nginx 还支持以下负载均衡策略：&lt;/p>
&lt;h4 id="1-权重策略--weighted-load-balancing-">1. 权重策略 ( Weighted load balancing )&lt;/h4>
&lt;p>通过为不同的服务分配不同的权重来进行转发，配置示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="na">upstream&lt;/span> &lt;span class="s">myapp1 {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv1.example.com weight=3;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv2.example.com weight=2;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv3.example.com;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-最少连接策略--least-connected-load-balancing-">2. 最少连接策略 ( Least connected load balancing )&lt;/h4>
&lt;p>将请求转发给连接数最少的服务，配置实例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="na">upstream&lt;/span> &lt;span class="s">myapp1 {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> least_conn;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv1.example.com;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv2.example.com;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv3.example.com;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-ip-策略--ip-hash-load-balancing-">3. IP 策略 ( IP Hash load balancing )&lt;/h4>
&lt;p>通过对请求的 IP 地址进行哈希运算并取模来决定转发对象，配置示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-properties" data-lang="properties">&lt;span class="line">&lt;span class="cl">&lt;span class="na">upstream&lt;/span> &lt;span class="s">myapp1 {&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err"> ip_hash;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv1.example.com;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv2.example.com;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">server&lt;/span> &lt;span class="s">srv3.example.com;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上是 Nginx 内置的基础的负载均衡策略，如果想要实现其他更加复杂的负载均衡策略，可以通过第三方模块来实现。&lt;/p>
&lt;h3 id="44-声明备用服务">4.4 声明备用服务&lt;/h3>
&lt;p>在上面任何负载均衡策略当中，都可以通过 backup 参数来添加备用服务，示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">server backup1.example.com:8080 backup&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>处于备用状态下的服务并不会参与负载均衡，除非所有主服务都已宕机，此时 Nginx 才会将请求转发到备用服务上。&lt;/p>
&lt;h2 id="六实现动静分离">六、实现动静分离&lt;/h2>
&lt;h3 id="61-动静分离配置">6.1 动静分离配置&lt;/h3>
&lt;p>Nginx 能够支持高并发的访问，并具有静态资源缓存等特性，因此相比于 Tomcat 等动态资源应用服务器，其更加适合于部署静态资源。想要实现动静分离，只需要在 server 指令块中通过正则表达式来划分静态资源，并指定其存放位置，示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">server &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> listen 9020&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> location / &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> proxy_pass http://springboot&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 通过正则来控制所需要分离的静态资源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> location ~ .*&lt;span class="se">\.&lt;/span>&lt;span class="o">(&lt;/span>html&lt;span class="p">|&lt;/span>htm&lt;span class="p">|&lt;/span>gif&lt;span class="p">|&lt;/span>jpg&lt;span class="p">|&lt;/span>jpeg&lt;span class="p">|&lt;/span>bmp&lt;span class="p">|&lt;/span>png&lt;span class="p">|&lt;/span>ico&lt;span class="p">|&lt;/span>txt&lt;span class="p">|&lt;/span>js&lt;span class="p">|&lt;/span>css&lt;span class="o">)&lt;/span>$ &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 静态资源存放目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> root /usr/resources/&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="62-常见配置异常">6.2 常见配置异常&lt;/h3>
&lt;h4 id="1-no-such-file-or-directory">1. No such file or directory&lt;/h4>
&lt;p>第一个常见的问题是找不到静态资源，此时可以查看 logs 目录下的 &lt;code>error.log&lt;/code> 日志，通常输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">2019/09/01 17:12:43 &lt;span class="o">[&lt;/span>error&lt;span class="o">]&lt;/span> 12402#0: *163 open&lt;span class="o">()&lt;/span> &lt;span class="s2">&amp;#34;/usr/resources/spring-boot-tomcat/css/show.css&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">failed &lt;span class="o">(&lt;/span>2: No such file or directory&lt;span class="o">)&lt;/span>, client: 192.168.0.106, server: ,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">request: &lt;span class="s2">&amp;#34;GET /spring-boot-tomcat/css/show.css HTTP/1.1&amp;#34;&lt;/span>, host: &lt;span class="s2">&amp;#34;192.168.0.226:9020&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">referrer: &lt;span class="s2">&amp;#34;http://192.168.0.226:9020/spring-boot-tomcat/index&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出现这个问题，是因为 Nginx 要求静态资源的请求路径必须和原有请求路径完全相同，这里我的项目在 Tomcat 中解压后的项目名为 &lt;code>pring-boot-tomcat&lt;/code>，以 show.css 文件为例，其正确的存储路径应该为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">/usr/resources/spring-boot-tomcat/css/show.css
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即： 静态资源根目录 + 项目名 + 原有路径，通常我们在创建目录时会忽略掉项目名这一层级，从而导致异常。&lt;/p>
&lt;h4 id="2-permission-denied">2. Permission denied&lt;/h4>
&lt;p>路径正确后，另外一个常见的问题是权限不足，错误日志如下。此时需要保证配置文件中的 user 用户必须具有静态资源所处目录的访问权限，或者在创建静态资源目录时，直接使用 user 配置的用户来创建：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">2019/09/01 17:15:14 &lt;span class="o">[&lt;/span>error&lt;span class="o">]&lt;/span> 12402#0: *170 open&lt;span class="o">()&lt;/span> &lt;span class="s2">&amp;#34;/usr/resources/spring-boot-tomcat/css/show.css&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">failed &lt;span class="o">(&lt;/span>13: Permission denied&lt;span class="o">)&lt;/span>, client: 192.168.0.106, server: ,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">request: &lt;span class="s2">&amp;#34;GET /spring-boot-tomcat/css/show.css HTTP/1.1&amp;#34;&lt;/span>, host: &lt;span class="s2">&amp;#34;192.168.0.226:9020&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">referrer: &lt;span class="s2">&amp;#34;http://192.168.0.226:9020/spring-boot-tomcat/index&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="参考资料">参考资料&lt;/h1>
&lt;p>官方文档：&lt;a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">nginx documentation&lt;/a> ，&lt;a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank" rel="noopener">Using nginx as HTTP load balancer&lt;/a>&lt;/p></description></item></channel></rss>