<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Theory | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/</link><atom:link href="https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/index.xml" rel="self" type="application/rss+xml"/><description>Theory</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Theory</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/</link></image><item><title>Compiler-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/compiler-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/compiler-cheatsheet/</guid><description>&lt;h1 id="compiler-cheatsheet--编译原理概览">Compiler CheatSheet | 编译原理概览&lt;/h1>
&lt;p>Compiler theory is the theory of writing compilers (or more generally, translators); programs which translate a program written in one language into another form. The actions of a compiler are traditionally broken up into syntax analysis (scanning and parsing), semantic analysis (determining what a program should do), optimization (improving the performance of a program as indicated by some metric; typically execution speed) and code generation (generation and output of an equivalent program in some target language; often the instruction set of a CPU).&lt;/p>
&lt;p>词法分析，将 SQL 字符串拆分成包含关键词识别的字符段（Tokens）。
语法分析，利用自顶向下或自底向上的算法，将 Tokens 解析为 AST，可以手动，也可以自动。
错误检测、恢复、提示推断，都需要利用语法分析产生的 AST。
语义分析，做完这一步就可以执行 SQL 语句了，不过对前端而言，不需要深入到这一步，可以跳过。&lt;/p>
&lt;p>词法分析阶段，能够根据输入的字符流能够识别出符号的含义，它们所包含的关键字、数字、字符串、分隔符、数字等。&lt;/p>
&lt;pre>&lt;code> 词法分析阶段以后，就是把对应的输出作为语法分析。语法分析的作用就是把从词法分析识别出的符号流中识别出符合编程语言语法的语句。语法分析的结果以树型结构保存，称之为语法树。语法树承载了源程序的全部信息，后续的转换工作就与源程序无关了。
在当前，我们有很多不同的硬件平台，intel、ARM、PowerPC，以及32位和64位等等，为了能够把我们的程序更好的在不同硬件平台上运行，编译器把语法树先转换为一个通用的，抽象的“CPU指令”，这就是中间代码最初的设计思路，然后根据具体选定的CPU，将中间代码落实到具体CPU的目标代码。
选定具体CPU，操作系统后，中间代码就转换为目标代码--汇编代码。然后汇编器依照选定操作系统的目标文件格式，将汇编文件转换为具体的目标文件。对于linux而言是.o文件，window系统是.obj文件。目标文件已经是选定CPU的机器指令了。
最后一步就是链接器把一个或多个目标文件链接成符合操作系统指定格式的可执行文件。通过操作系统，可执行程序就可以被载入内存执行了。
&lt;/code>&lt;/pre>
&lt;p>1、词法分析
编译器将源码看作一个很长的字符串，首先对它进行从左到右的扫描，然后对其做初步分析，识别出代码中的单词（称作 Token），分为基本字、标识符、常数、运算符和界符等，方便编译的后续步骤。&lt;/p>
&lt;pre>&lt;code> 在该过程中如果发现不符合词法规则的token，将做出错处理。
&lt;/code>&lt;/pre>
&lt;p>2、语法分析
语法分析是对词法分析得到的单词流，按语法规则做进一步的分析，识别出语法单位，如表达式、短语、子句、句子和程序等，从而形成一颗“语法树”。&lt;/p>
&lt;pre>&lt;code> 在该过程中如果发现不符合语法规则的单词流，将做出错处理。
&lt;/code>&lt;/pre>
&lt;p>3、语义分析
经过词法分析和语法分析，程序如果没有错误，就可以按照语义要求对其进行“翻译”，形成被称为“四元式”的中间代码。&lt;/p>
&lt;p>4、优化
语义分析生成的中间代码不依赖于实际的硬件，便于优化和移植，针对实际状况做一些等效变换，使程序占用内存更小，执行更快。&lt;/p>
&lt;p>5、目标代码生成
根据优化后的中间代码，可生成有效的目标代码。而通常编译器将其翻译为汇编代码，此时还需要将汇编代码经汇编器汇编为目标机器的机器语言。&lt;/p>
&lt;p>6、出错处理
编译的各个阶段都有可能发现源码中的错误，尤其是语法分析阶段可能会发现大量的错误，因此编译器需要做出错处理，报告错误类型及错误位置等信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/44029860-7870c4a6-9f31-11e8-8cee-c0ac7c53264f.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>编译
前端（平台无关）
词法分析：形象点说就是扫描器，将字符识别为有意义的记号：关键字、标识符、字面量（数字、字符串）、操作符等，顺便将标示符放到符号表，数字、字符串放到文字表等，链接阶段要用。
语法分析：对每个表达式构造语法树-操作符在父节点上，左右操作数在左右孩子上。
语义分析：语法对不代表这句话有意义，不过这阶段只能做静态语义分析，给每个语法树节点标上类型，静态类型检查、类型转换等都是在这个阶段完成。
看完数学之美会知道，自然语言处理已经放弃了语义分析这些传统方法，转而采用统计学方法，一大原因就是自然语言是上下文相关的，而人类发明的高级语言是上下文无关的。
源代码优化：将语法树用 三地址码（x = y OP z）等格式表达，容易做优化，优化的代码包括常量相加之类。
后端（平台相关）
汇编语言生成：将中间代码转化为汇编指令。
汇编指令优化：比如用移位代替乘法等。
汇编
这项工作比较简单，将汇编指令转化为机器指令，参考汇编指令与机器指令对照表一对一翻译。
最终获得的文件称为可重定位或共享目标文件。&lt;/p>
&lt;h1 id="links">Links&lt;/h1></description></item><item><title>FunctionalProgramming-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/functionalprogramming-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/functionalprogramming-cheatsheet/</guid><description>&lt;h1 id="functional-programming-cheatsheet">Functional Programming CheatSheet&lt;/h1>
&lt;h1 id="functional-programming-jargon--函数式编程术语">Functional Programming Jargon | 函数式编程术语&lt;/h1>
&lt;p>本部分的主要目的即是希望能够有一种通俗易懂的方式来阐述函数式编程中常见的理论术语概念。&lt;/p>
&lt;h2 id="terminology--术语">Terminology | 术语&lt;/h2>
&lt;h3 id="arity--参数数目">Arity | 参数数目&lt;/h3>
&lt;p>Arity 代指一个函数的参数数量，该关键字来源于类似于 unary、binary、ternary 等等，由两个后缀&lt;code>-ary&lt;/code>、&lt;code>-ity&lt;/code>组成。譬如，如果一个函数允许输入两个参数，那就称为所谓的 binary function( 二元函数 )，或者一个有两个参数的函数。有时候这种函数也会被喜欢拉丁语法的人称为 &amp;ldquo;dyadic( 二价的 )&amp;rdquo; 函数。以此类推，不定参数的方程也就被称为&lt;code>variadic( 可变参数函数 )&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">arity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">sum&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">arity&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// =&amp;gt; 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// The arity of sum is 2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="side-effects--purity--副作用与纯函数">Side effects &amp;amp; Purity | 副作用与纯函数&lt;/h2>
&lt;p>如果一个函数，除了返回值之外，还会修改某些其它状态，或者与外部函数等有可观测的交互，那么就称其有副作用:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;IO is a side effect!&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个没有任何副作用，并且返回值只由输入决定的函数成为纯函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">greet&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;yo&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">greet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toUpperCase&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// YO;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">greet&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// yo;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As opposed to:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">numbers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">numbers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">splice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">numbers&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// []
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="composition--组合">Composition | 组合&lt;/h2>
&lt;p>感觉有点像设计模式里的 Decorator，即能够将两个指定类型组合转化为一个新值的函数；最常见的组合即是常见的函数组合，允许你将不同的函数组合成一个返回单值的函数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">compose&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">// Definition
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">floorAndToString&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">compose&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">floor&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">floorAndToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">121.212121&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// &amp;#34;121&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="higher-order-functions-hof--高阶函数">Higher-Order Functions (HOF) | 高阶函数&lt;/h3>
&lt;p>一个接收某个函数作为参数的函数成为高等函数，该函数可以选择返回一个函数也可以返回其他类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 构建可动态设置过滤条件的高阶函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">pred&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">xs&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">xs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">idx&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">pred&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">xs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">]))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">xs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">idx&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 声明过滤条件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">is&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">type&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nb">Object&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nx">type&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 执行过滤
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">filter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">is&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Number&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">//=&amp;gt; [0, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="partial-application--局部封装">Partial Application | 局部封装&lt;/h3>
&lt;p>将原本一个多参数值的函数封装为固定参数数目的函数的过程称为 Partial Application&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// partially applying `a` to `40`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">partial&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">sum&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Invoking it with `b`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">partial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//=&amp;gt; 42
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="currying">Currying&lt;/h3>
&lt;p>将一个 N 参数值的函数转化为 N 个一元函数的组合，Currying 与 Partial Application 的区别在于 Partial Application 最终生成的函数允许接收多个值，而 Currying 生成的函数序列中的每个函数只允许接收一个参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">curriedSum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">curriedSum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">40&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 42.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="transform--转换">Transform | 转换&lt;/h2>
&lt;h2 id="object-type--对象类型">Object Type | 对象类型&lt;/h2>
&lt;h3 id="setoid">Setoid&lt;/h3>
&lt;p>实现了&lt;code>equals&lt;/code>函数的对象，即可以与其他对象进行对比判断是否属于同一类型，被称为 Setoid。下面对于原型的扩充可以将 Array 变成 Setoid。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">prototype&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">equals&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">len&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">len&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="nx">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="nx">equals&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">[(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)].&lt;/span>&lt;span class="nx">equals&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// false
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="idempotency-幂等性">Idempotency: 幂等性&lt;/h2>
&lt;blockquote>
&lt;p>多次执行下都不会产生副作用的函数被称为具有幂等性的函数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>f(f(x)) = f(x)&lt;/code>&lt;/p>
&lt;p>&lt;code>Math.abs(Math.abs(10))&lt;/code>&lt;/p>
&lt;hr>
&lt;h2 id="point-free-style">Point-Free Style&lt;/h2>
&lt;blockquote>
&lt;p>那些并没有线性定义参数的函数风格被称为 Point-Free Style，这类型往往需要&lt;a href="#currying">currying&lt;/a> 或者 &lt;a href="#higher-order-functions-hof">Higher-Order functions&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Given
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">map&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fn&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fn&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">add&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Then
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Not points-free - `numbers` is an explicit parameter
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">incrementAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">numbers&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">))(&lt;/span>&lt;span class="nx">numbers&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Points-free - The list is an implicit parameter
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">incrementAll2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>incrementAll&lt;/code>明确规定了参数&lt;code>numbers&lt;/code>, 而&lt;code>incrementAll2&lt;/code>是对于参数的封装，并没有显性说明&lt;code>numbers&lt;/code>参数，因此它可以被称为 Points Free。一般来说，Points-free 的函数都不会用常见的&lt;code>function&lt;/code>或者&lt;code>=&amp;gt;&lt;/code>关键字来定义。&lt;/p>
&lt;hr>
&lt;h2 id="contracts">Contracts&lt;/h2>
&lt;h2 id="暂无">暂无&lt;/h2>
&lt;h2 id="guarded-functions">Guarded Functions&lt;/h2>
&lt;h2 id="暂无-1">暂无&lt;/h2>
&lt;h2 id="categories-分类">Categories: 分类&lt;/h2>
&lt;blockquote>
&lt;p>关联到遵循某些规则的函数的对象，譬如&lt;a href="#monoid">monoid&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="value-值">Value: 值&lt;/h2>
&lt;blockquote>
&lt;p>计算中常用到的一些复合值 (complex) 或者简单值 (primitive)，包括函数。一般来说，函数式编程中的值都被认为是不可变值。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">Object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">freeze&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;John&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">30&lt;/span>&lt;span class="p">})&lt;/span> &lt;span class="c1">// The `freeze` function enforces immutability.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，譬如&lt;a href="#functor">Functor&lt;/a>, &lt;a href="#monad">Monad&lt;/a>这样包含其他值的结构体本身也是值，这就是说，这些复合值也可以相互包含。&lt;/p>
&lt;hr>
&lt;h2 id="constant-常量">Constant: 常量&lt;/h2>
&lt;blockquote>
&lt;p>对于一个值的不可变引用，不能跟变量相混淆。Variable 即指那些可能在任意点被更改的引用。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">five&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">john&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">30&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常量一般认为是透明的，也就是说，它们可以被值本身代替而不影响最终的计算结果，上面的两个常量也可以用下述方式表述：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">john&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">five&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;John&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">30&lt;/span> &lt;span class="p">}.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述表达式会一直返回真。&lt;/p>
&lt;hr>
&lt;h2 id="functor">Functor&lt;/h2>
&lt;blockquote>
&lt;p>Functor 即指那些可以引用&lt;code>map&lt;/code>函数的对象，JavaScript 中最简单的函数就是&lt;code>Array&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// [4,6,8]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设&lt;code>func&lt;/code>构造为一个实现了&lt;code>map&lt;/code>函数的对象，&lt;code>f&lt;/code>、&lt;code>g&lt;/code>则是任意的函数，只要&lt;code>func&lt;/code>遵循以下规则就可以将&lt;code>func&lt;/code>称为一个 functor: Let &lt;code>func&lt;/code> be an object implementing a &lt;code>map&lt;/code> function, and &lt;code>f&lt;/code>, &lt;code>g&lt;/code> be arbitrary functions, then &lt;code>func&lt;/code> is said to be a functor if the map function adheres to the following rules:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">func&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">func&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以及&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">func&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)))&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">func&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将&lt;code>Array&lt;/code>称为 Functor，也是因为它遵循了以下规则：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// = [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以及&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">f&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)));&lt;/span> &lt;span class="c1">// = [3, 5, 7]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// = [3, 5, 7]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="pointed-functor">Pointed Functor&lt;/h2>
&lt;blockquote>
&lt;p>实现了&lt;code>of&lt;/code>方法的 Functor，&lt;code>Of&lt;/code>会将任何单值转化为一个 Functor&lt;/p>
&lt;/blockquote>
&lt;p>Pointed Functor 在 Array 中的实现为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">Array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">prototype&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">of&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[].&lt;/span>&lt;span class="k">of&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// [1]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="lift">Lift&lt;/h2>
&lt;blockquote>
&lt;p>Lift 很类似于&lt;code>map&lt;/code>，不过它可以用于多个 Functors：&lt;/p>
&lt;/blockquote>
&lt;p>在单值函数下，Map 与 Lift 的作用是一致的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">lift&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)([&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// [4,6,8]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而 Lift 可以允许输入多个值：&lt;/p>
&lt;pre tabindex="0">&lt;code>lift((a, b) =&amp;gt; a * b)([1, 2], [3]); // [3, 6]
&lt;/code>&lt;/pre>&lt;hr>
&lt;h2 id="referential-transparency-透明引用">Referential Transparency: 透明引用&lt;/h2>
&lt;blockquote>
&lt;p>一个可以直接用其值来替换而不会影响到程序表现的表达式称为透明引用&lt;/p>
&lt;/blockquote>
&lt;p>譬如我们有一个叫&lt;code>greet&lt;/code>的引用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">greet&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;Hello World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="任何对于greet的调用都可以被hello-world直接替换因此可以将greet称为透明引用">任何对于&lt;code>greet()&lt;/code>的调用都可以被&lt;code>Hello World!&lt;/code>直接替换，因此可以将&lt;code>greet&lt;/code>称为透明引用。&lt;/h2>
&lt;h2 id="equational-reasoning">Equational Reasoning&lt;/h2>
&lt;blockquote>
&lt;p>当一个应用由表达式组合而成并且没有任何副作用的时候，该系统可以由部分推导而来&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="lazy-evaluation-懒计算">Lazy evaluation: 懒计算&lt;/h2>
&lt;blockquote>
&lt;p>Lazy evaluation 即是所谓的只有在需要某个值的时候才进行计算的机制。在函数式语言中，这个机制就允许对于那些近乎无限的列表进行操作。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">rand&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">yield&lt;/span> &lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">random&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">randIter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">rand&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">randIter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">next&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// Each exectuion gives a random value, expression is evaluated on need.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="monoid-独异点">Monoid: 独异点&lt;/h2>
&lt;blockquote>
&lt;p>一个 monoid 就是与某个恒等值进行组合之后不会影响现有结果的数据类型&lt;/p>
&lt;/blockquote>
&lt;p>一个最简单的 Monoid 就是如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数据类型是 number，函数是&lt;code>+&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>恒等式的值是&lt;code>0&lt;/code>, 将&lt;code>0&lt;/code>与任何数相加并不会改变值。有时候，monoid 类型进行不同的交换操作也不会影响结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// true
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数组连接也可以认为是一个 monoid:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">concat&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// [1, 2, 3, 4]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>恒等值即是空数组: &lt;code>[]&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">concat&lt;/span>&lt;span class="p">([]);&lt;/span> &lt;span class="c1">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="monad">Monad&lt;/h2>
&lt;blockquote>
&lt;p>一个 Monad 就是拥有&lt;a href="#pointed-functor">&lt;code>of&lt;/code>&lt;/a>以及&lt;code>chain&lt;/code>函数的对象。&lt;code>Chain&lt;/code> 类似于 &lt;a href="#functor">map&lt;/a>只不过它会扁平化最终求得的嵌套式结果。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;cat,dog&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;fish,bird&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="nx">chain&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// [&amp;#39;cat&amp;#39;,&amp;#39;dog&amp;#39;,&amp;#39;fish&amp;#39;,&amp;#39;bird&amp;#39;]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//Contrast to map
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;cat,dog&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;fish,bird&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">].&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">// [[&amp;#39;cat&amp;#39;,&amp;#39;dog&amp;#39;], [&amp;#39;fish&amp;#39;,&amp;#39;bird&amp;#39;]]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You may also see &lt;code>of&lt;/code> and &lt;code>chain&lt;/code> referred to as &lt;code>return&lt;/code> and &lt;code>bind&lt;/code> (not be confused with the JS keyword/function&amp;hellip;) in languages which provide Monad-like constructs as part of their standard library (e.g. Haskell, F#), on &lt;a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="noopener">Wikipedia&lt;/a> and in other literature. It&amp;rsquo;s also important to note that &lt;code>return&lt;/code> and &lt;code>bind&lt;/code> are not part of the &lt;a href="https://github.com/fantasyland/fantasy-land" target="_blank" rel="noopener">Fantasy Land spec&lt;/a> and are mentioned here only for the sake of people interested in learning more about Monads.&lt;/p>
&lt;hr>
&lt;h2 id="comonad-余单子">Comonad: 余单子&lt;/h2>
&lt;blockquote>
&lt;p>实现了&lt;code>extract&lt;/code>与&lt;code>extend&lt;/code>函数的对象&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">CoIdentity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">val&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">extract&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">extend&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">CoIdentity&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Extract 可以将值从 Functor 中吐出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">CoIdentity&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">extract&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Extend 则是会返回一个跟 Commonad 相同值的函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">CoIdentity&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">extend&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">co&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">co&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">extract&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// CoIdentity(2)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="applicative-可适用的--functor">Applicative( 可适用的 ) Functor&lt;/h2>
&lt;blockquote>
&lt;p>一个 Applicative Functor 就是一个实现了&lt;code>ap&lt;/code>函数的对象，&lt;code>Ap&lt;/code>可以将某个对象中的某个值转化为另一个对象中的相同类型的值&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">ap&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// [2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="morphism-态射">Morphism: 态射&lt;/h2>
&lt;blockquote>
&lt;p>一个转化函数&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="isomorphism-同态转换">Isomorphism: 同态转换&lt;/h2>
&lt;blockquote>
&lt;p>用不同方式存储的能够表明相同数据的转换&lt;/p>
&lt;/blockquote>
&lt;p>譬如，一个二维的数组可以存储为数组：&lt;code>[2,3]&lt;/code>或者对象：&lt;code>{x: 2, y: 3}&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Providing functions to convert in both directions makes them isomorphic.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">pairToCoords&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">pair&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">({&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">pair&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nx">y&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">pair&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">coordsToPair&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">coords&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">coords&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">coords&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">y&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coordsToPair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pairToCoords&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">]));&lt;/span> &lt;span class="c1">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">pairToCoords&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">coordsToPair&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="p">}));&lt;/span> &lt;span class="c1">// {x: 1, y: 2}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;hr>
&lt;h2 id="semigroup-半群">Semigroup: 半群&lt;/h2>
&lt;p>一个拥有&lt;code>concat&lt;/code>，即将另一个对象转化为相同类型的函数，函数的对象称为 Semigroup。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">concat&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="foldable-可折叠">Foldable: 可折叠&lt;/h2>
&lt;blockquote>
&lt;p>实现了 reduce 函数，即可以将一个对象转化为其他类型的函数，的对象称为 Foldable 对象。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reduce&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">acc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">acc&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">sum&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 6
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="traversable">Traversable&lt;/h2>
&lt;h2 id="暂无-2">暂无&lt;/h2>
&lt;h2 id="type-signatures-类型签名">Type Signatures: 类型签名&lt;/h2>
&lt;blockquote>
&lt;p>一般来说，函数都会注释表明它们的参数类型和返回值类型&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// functionName::firstArgType -&amp;gt; secondArgType -&amp;gt; returnType
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// add::Number -&amp;gt; Number -&amp;gt; Number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">add&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// increment::Number -&amp;gt; Number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">increment&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果一个函数接收其他函数作为参数，譬如这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// call::(a -&amp;gt; b) -&amp;gt; a -&amp;gt; b
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">call&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的&lt;code>a&lt;/code>, &lt;code>b&lt;/code>, &lt;code>c&lt;/code>, &lt;code>d&lt;/code>表明参数可以是任意类型，不过它会将类型&lt;code>a&lt;/code>转化为另一个类型&lt;code>b&lt;/code>，而对于下面这个 map，它的注释表明了它会输入一个 a 类型的列表，然后转化为另一个包含了 b 类型的列表。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// map::(a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">let&lt;/span> &lt;span class="nx">map&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>GC-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/gc-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/gc-cheatsheet/</guid><description>&lt;h1 id="overview--概述">Overview | 概述&lt;/h1>
&lt;p>Application memory management involves supplying the memory needed for a program’s objects and data structures from the limited resources available, and recycling that memory for reuse when it is no longer required. Because application programs cannot in general predict in advance how much memory they are going to require, they need additional code to handle their changing memory requirements.&lt;/p>
&lt;p>基于引用计数与基于 trace 这两大类别的自动内存管理方式最大的不同之处在于：前者只需要局部信息，而后者需要全局信息。引用计数方式最基本的形态就是让每个被管理的对象与一个引用计数器关联在一起，该计数器记录着该对象当前被引用的次数，每当创建一个新的引用指向该对象时其计数器就加 1，每当指向该对象的引用失效时计数器就减 1。当该计数器的值降到 0 就认为对象死亡。每个计数器只记录了其对应对象的局部信息——被引用的次数，而没有（也不需要）一份全局的对象图的生死信息。由于只维护局部信息，所以不需要扫描全局对象图就可以识别并释放死对象；但也因为缺乏全局对象图信息，所以无法处理循环引用的状况。更高级的引用计数实现会引入“弱引用”的概念来打破某些已知的循环引用，但那是另一个话题了。&lt;/p>
&lt;p>在实际实现中，引用计数存在什么地方是个有趣的话题。可以侵入式的存在对象内，例如 CPython 就把引用计数存在每个受自动内存管理的 Python 对象的对象头里（PyObject 的 ob_refcnt 字段），或者 COM 的 IUnknown::AddRef()/Release()；也可以非侵入式的存在对象外面，例如 C++11 标准库里的 std::shared_ptr。计数器的管理（自增/自减）可能由人工完成，例如老的 Objective-C，或者是从 C++里使用 COM，等等；也可能是自动管理，例如 CPython、使用“自动引用计数”（ARC）的 Objective-C、C++/CX 的“hat”、前面提到的 C++11 的 std::shared_ptr 等等。如果能自动管理，那么必然有一套明确的规则说明何种情况下一个引用会被认为失效；以 std::shared_ptr 为例的话，其析构函数被调用（例如离开作用域时）或者其指向别的对象时，原本指向的对象的引用计数就会减 1。&lt;/p>
&lt;p>Tracing GC 与引用计数正好相反，需要全局的对象图信息，从对象图的“根”（也就是必然活的引用）出发扫描出去，基于引用的可到达性来判断对象的生死。这使得对象的生死状态只能批量的被识别出来，然后批量释放死对象。Tracing GC 不显式维护对象的引用计数，只在 trace 的时候才能回答“有”还是“没有”活引用指向某个对象。实际上，在内存充裕的前提下，tracing GC 的整体开销比引用计数方式更低一些，所以吞吐量（throughput）高一些。因为引用计数方式通常需要统计冗余的局部信息，而 tracing GC 则可以通过全局信息一口气批量判断对象的生死；如果是带整理的 tracing GC，则其内存分配通常也会更快。不过 tracing GC 通常会比引用计数方式的延迟（latency）大一些，而且内存越紧张的时候 tracing GC 的效率反而越低，所以在内存不太充裕的地方使用引用计数仍然是个合理的选择（例如 iOS5 上的 ARC）。&lt;/p>
&lt;h2 id="tasks--任务">Tasks | 任务&lt;/h2>
&lt;p>Allocation&lt;/p>
&lt;p>When the program requests a block of memory, the memory manager must allocate that block out of the larger blocks it has received from the operating system. The part of the memory manager that does this is known as the allocator. There are many ways to perform allocation, a few of which are discussed in Allocation techniques.
Recycling&lt;/p>
&lt;p>When memory blocks have been allocated, but the data they contain is no longer required by the program, then the blocks can be recycled for reuse. There are two approaches to recycling memory: either the programmer must decide when memory can be reused (known as manual memory management); or the memory manager must be able to work it out (known as automatic memory management).&lt;/p>
&lt;h2 id="metric--指标">Metric | 指标&lt;/h2>
&lt;p>CPU overhead&lt;/p>
&lt;p>The additional time taken by the memory manager while the program is running.
Pause times&lt;/p>
&lt;p>The time it takes for the memory manager to complete an operation and return control to the program.&lt;/p>
&lt;p>This affects the program’s ability to respond promptly to interactive events, and also to any asynchronous event such as a network connection.&lt;/p>
&lt;p>Memory overhead&lt;/p>
&lt;p>How much space is wasted for administration, rounding (known as internal fragmentation), and poor layout (known as external fragmentation).&lt;/p>
&lt;h1 id="challenge--挑战">Challenge | 挑战&lt;/h1>
&lt;p>The basic problem in managing memory is knowing when to keep the data it contains, and when to throw it away so that the memory can be reused.&lt;/p>
&lt;p>Premature frees and dangling pointers&lt;/p>
&lt;p>Many programs give up memory, but attempt to access it later and crash or behave randomly. This condition is known as a premature free, and the surviving reference to the memory is known as a dangling pointer. This is usually confined to manual memory management.
Memory leak&lt;/p>
&lt;p>Some programs continually allocate memory without ever giving it up and eventually run out of memory. This condition is known as a memory leak.
External fragmentation&lt;/p>
&lt;p>A poor allocator can do its job of giving out and receiving blocks of memory so badly that it can no longer give out big enough blocks despite having enough spare memory. This is because the free memory can become split into many small blocks, separated by blocks still in use. This condition is known as external fragmentation.
Poor locality of reference&lt;/p>
&lt;p>Another problem with the layout of allocated blocks comes from the way that modern hardware and operating system memory managers handle memory: successive memory accesses are faster if they are to nearby memory locations. If the memory manager places far apart the blocks a program will use together, then this will cause performance problems. This condition is known as poor locality of reference.
Inflexible design&lt;/p>
&lt;p>Memory managers can also cause severe performance problems if they have been designed with one use in mind, but are used in a different way. These problems occur because any memory management solution tends to make assumptions about the way in which the program is going to use memory, such as typical block sizes, reference patterns, or lifetimes of objects. If these assumptions are wrong, then the memory manager may spend a lot more time doing bookkeeping work to keep up with what’s happening.
Interface complexity&lt;/p>
&lt;p>If objects are passed between modules, then the interface design must consider the management of their memory.&lt;/p>
&lt;h2 id="maunal--atomic">Maunal &amp;amp; Atomic&lt;/h2>
&lt;p>Manual memory management is where the programmer has direct control over when memory may be recycled. Usually this is either by explicit calls to heap management functions (for example, malloc and free(2) in C), or by language constructs that affect the control stack (such as local variables).&lt;/p>
&lt;p>some manual memory managers perform better when there is a shortage of memory. 不过开发者必须编写大量的额外的内存管理相关的代码，并且极有可能过量分配内存或者造成其他的错误。&lt;/p>
&lt;p>Automatic memory management is a service, either as a part of the language or as an extension, that automatically recycles memory that a program would not otherwise use again. Automatic memory managers (often known as garbage collectors, or simply collectors) usually do their job by recycling blocks that are unreachable from the program variables (that is, blocks that cannot be reached by following pointers). memory may be retained because it is reachable, but won’t be used again;
automatic memory managers (currently) have limited availability.&lt;/p></description></item><item><title>MemoryManagement-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/memorymanagement-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/memorymanagement-cheatsheet/</guid><description>&lt;h1 id="memory-management-cheatsheet--内存管理">Memory Management CheatSheet | 内存管理&lt;/h1>
&lt;p>所谓的内存管理(Memory Management)，即是如何在计算机系统中协调与控制内存的使用，其往往会关注三个层次：MMUs, RAM 这样的硬件内存管理；Virtual Memory, Protection 这样的操作系统级内存管理；以及内存的分配、垃圾回收等应用级的内存管理。&lt;/p></description></item><item><title>PLT-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/plt-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/plt-cheatsheet/</guid><description>&lt;h1 id="编程语言理论速览">编程语言理论速览&lt;/h1>
&lt;p>计算机不能直接理解 高级语言，只能直接理解 机器语言，所以必须要把高级语言“翻译”成机器语言，计算机才能执行高级语言编写的程序。&lt;/p>
&lt;p>我们可以粗略地把编程语言分为两类：编译型语言 和解释型语言（常用的 C/C++，Pascal 和最近流行的 Go 语言都是编译型语言，而 Python、Ruby 等则是解释型语言，解释型语言也被称作”脚本语言“）。&lt;/p>
&lt;p>对于它们的“翻译”，则分别称之为“编译”和“解释”。解释：解释型语言在程序运行时有一个专门的解释器，将代码翻译为机器语言，一边翻译一边执行。&lt;/p>
&lt;p>编译：而编译型语言写的程序，在执行之前都必须有一个“编译”的过程，将源码编译为机器语言的文件（比如 windows 下的 exe 文件），运行的时候直接运行编译后的文件。&lt;/p></description></item><item><title>ReactiveProgramming-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/reactiveprogramming-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/theory/reactiveprogramming-cheatsheet/</guid><description>&lt;h1 id="reactive-programming-cheatsheet">Reactive Programming CheatSheet&lt;/h1>
&lt;p>Reactive Programming is an asynchronous programming paradigm concerned with data streams and the propagation of change.&lt;/p>
&lt;p>React to User&amp;rsquo;s Input X, and respond ASAP，而非简单地 Response to X。响应一般来说，对应的英文为 Response、动词为 Respond、形容词为 Responsive。在 The Reactive Manifesto 中的 Reactive 实际上是指一个副词，表示系统总是会积极主动、甚至是智能地对内外的变化做出反应，其中包括：&lt;/p>
&lt;p>React to user：Respond ASAP，尽可能快速地对用户的请求给出应答——即时响应性，这也是最终目的和核心商业价值。
React to load，尽可能地对上游给出的压力做出反应，包括智能限流、回压、百分比丢弃等策略，为的是尽可能地降低对用户体验的损害，同时保护系统。
React to failure，尽可能地在系统发生失败时，对失败进行妥善处理，而非不受控的级联失败。&lt;/p>
&lt;h1 id="反应式系统特性">反应式系统特性&lt;/h1>
&lt;p>即时响应性:：只要有可能，系统就会及时地做出响应。即时响应是可用性和实用性的基石，而更加重要的是，即时响应意味着可以快速地检测到问题并且有效地对其进行处理。即时响应的系统专注于提供快速而一致的响应时间，确立可靠的反馈上限，以提供一致的服务质量。这种一致的行为转而将简化错误处理、建立最终用户的信任并促使用户与系统作进一步的互动。
回弹性：系统在出现失败时依然保持即时响应性。这不仅适用于高可用的、任务关键型系统——任何不具备回弹性的系统都将会在发生失败之后丢失即时响应性。回弹性是通过复制、遏制、隔离以及委托来实现的。失败的扩散被遏制在了每个组件内部，与其他组件相互隔离，从而确保系统某部分的失败不会危及整个系统，并能独立恢复。每个组件的恢复都被委托给了另一个（外部的）组件，此外，在必要时可以通过复制来保证高可用性。（因此）组件的客户端不再承担组件失败的处理。
弹性：系统在不断变化的工作负载之下依然保持即时响应性。反应式系统可以对输入（负载）的速率变化做出反应，比如通过增加或者减少被分配用于服务这些输入（负载）的资源。这意味着设计上并没有争用点和中央瓶颈，得以进行组件的分片或者复制，并在它们之间分布输入（负载）。通过提供相关的实时性能指标，反应式系统能支持预测式以及反应式的伸缩算法。这些系统可以在常规的硬件以及软件平台上实现成本高效的弹性。
消息驱动：反应式系统依赖异步的消息传递，从而确保了松耦合、隔离、位置透明的组件之间有着明确边界。这一边界还提供了将失败作为消息委托出去的手段。使用显式的消息传递，可以通过在系统中塑造并监视消息流队列，并在必要时应用回压，从而实现负载管理、弹性以及流量控制。使用位置透明的消息传递作为通信的手段，使得跨集群或者在单个主机中使用相同的结构成分和语义来管理失败成为了可能。非阻塞的通信使得接收者可以只在活动时才消耗资源，从而减少系统开销。&lt;/p>
&lt;p>任务划分
Scheduler 调度器
Context 支持：Coroutine Context 和 Reactor Context
但是有几点是目前 Coroutine 是做不到的：&lt;/p>
&lt;p>Reactive 几乎所有的语言都支持，但是协程未必所有语言都支持，JavaScript 好像就没有
Reactive 的编程体验是一致的：不管你使用任何语言，使用 Reactive，代码就得这样写，每一个人都能编写，而且容易阅读
Reactor 的 Operator：Reactive 提供了大量操作方法，各种数学操作简单明了，RxJava 的 &lt;a href="https://github.com/akarnokd/RxJava2Extensions" target="_blank" rel="noopener">https://github.com/akarnokd/RxJava2Extensions&lt;/a> Reactor 的 addons &lt;a href="https://github.com/reactor/reactor-addons" target="_blank" rel="noopener">https://github.com/reactor/reactor-addons&lt;/a> 相反使用协程你需要自己搞定 Java 同学一直头疼的空指针问题，在 Reactive 中也非常容易地规避。这些 Operator 方法都非常使用，而且使用流畅。&lt;/p>
&lt;p>Akka Stream: Akka 比较老牌，Actor 模式大家都知道，Akka Stream 主要是瞄准 Reactive 的，而且扩展也非常多 &lt;a href="https://github.com/akka/alpakka" target="_blank" rel="noopener">https://github.com/akka/alpakka&lt;/a> 就是非常复杂，普通 Java 程序员上手太慢，如果你喜欢 Scala 那就另当别论啦。
Reactor：最年轻的，所以通过一个 Adapter，可以将 RxJava 和 Akka Stream 都能转换到 Reactor 上。Reactor 最大的优势是和 Spring 社区的整合，如果你已经使用 Spring Framework 啦，那最好使用 Reactor，你坐享 Spring 带来的 Reactive 成果就可以啦，什么 Reactive JPA，R2DBC, Webflux，包括 RSocket，全部 ready 啦。另外个人认为，Spring 相关产品的 API 设计都是最佳的，学习和使用成本都是最低的。&lt;/p></description></item></channel></rss>