<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/zoo/rust/</link>
      <atom:link href="https://ng-tech.icu/books/awesome-cheatsheets/1.cs/zoo/rust/index.xml" rel="self" type="application/rss+xml" />
    <description>Rust</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>Rust</title>
      <link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/zoo/rust/</link>
    </image>
    
    <item>
      <title>Rust-CheatSheet</title>
      <link>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/zoo/rust/rust-cheatsheet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/awesome-cheatsheets/1.cs/zoo/rust/rust-cheatsheet/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Rust CheatSheet 是对于 Rust 学习/实践过程中的语法与技巧进行盘点，其属于 &lt;a href=&#34;https://github.com/wx-chevalier/Awesome-CheatSheets/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome CheatSheet&lt;/a&gt; 系列，致力于提升学习速度与研发效能，即可以将其当做速查手册，也可以作为轻量级的入门学习资料。本文参考了许多优秀的文章与代码示范，统一声明在了 &lt;a href=&#34;https://github.com/wx-chevalier/Awesome-Lists&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Rust List&lt;/a&gt;；如果希望深入了解某方面的内容，可以继续阅读&lt;a href=&#34;https://github.com/wx-chevalier/Rust-Series&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rust-Series&lt;/a&gt;，或者前往 &lt;a href=&#34;https://github.com/wx-chevalier/rust-examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rust-examples&lt;/a&gt; 查看使用 Rust 解决常见的数据结构与算法、设计模式、业务功能方面的代码实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;rust-语法速览实践技巧与开源工具清单&#34;&gt;Rust 语法速览、实践技巧与开源工具清单&lt;/h1&gt;
&lt;p&gt;Rust 是为工业应用而生，并不拘泥于遵循某个范式（Paradigm），笔者认为其最核心的特性为 Ownership 与 Lifetime；能够在没有 GC 与 Runtime 的情况下，防止近乎所有的段错误，并且保证线程安全(prevents nearly all segfaults, and guarantees thread safety)。Rust 为每个引用与指针设置了 Lifetime，对象则不允许在同一时间有两个和两个以上的可变引用，并且在编译阶段即进行了内存分配(栈或者堆)；Rust 还提供了 Closure 等函数式编程语言的特性、编译时多态(Compile-time Polymorphism)、衍生的错误处理机制、灵活的模块系统等。&lt;/p&gt;
&lt;p&gt;对于 Rust 的语法速览可以参考本目录下的 &lt;a href=&#34;./rust-snippets.rs&#34;&gt;rust-snippets&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://cheats.rs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cheats.rs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;hello-world&#34;&gt;Hello World&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rs&#34; data-lang=&#34;rs&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;fm&#34;&gt;println!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello, world!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;//&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Line comment, use these to document code flow or &lt;em&gt;internals&lt;/em&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;///&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Outer line &lt;strong&gt;doc comment&lt;/strong&gt;, use these on types.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;//!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inner line doc comment, mostly used at start of file to document module.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/*...*/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Block comment.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/**...*/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Outer block doc comment.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/*!...*/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inner block doc comment.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rust ...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;In doc comments, include a &lt;a href=&#34;https://doc.rust-lang.org/rustdoc/documentation-tests.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;doc test&lt;/a&gt; (doc code running on &lt;code&gt;cargo test&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;In doc tests, hide line from documentation (&lt;code&gt;# use x::hidden;&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;variables&#34;&gt;Variables&lt;/h2&gt;
&lt;p&gt;通过关键字定义的数据类型和存储位置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;struct S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define a &lt;strong&gt;struct&lt;/strong&gt; with named fields.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;struct S { x: T }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define struct with named field &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;struct S&lt;/code&gt; &lt;code&gt;(T);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define &amp;ldquo;tupled&amp;rdquo; struct with numbered field &lt;code&gt;.0&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;struct S;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define &lt;strong&gt;zero sized&lt;/strong&gt; unit struct. Occupies no space, optimized away.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enum E {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define an &lt;strong&gt;enum&lt;/strong&gt;, &lt;em&gt;c&lt;/em&gt;. &lt;a href=&#34;https://en.wikipedia.org/wiki/Algebraic_data_type&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;algebraic data types&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Tagged_union&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tagged unions&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enum E { A, B``(), C {} }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define variants of enum; can be unit- &lt;code&gt;A&lt;/code&gt;, tuple- &lt;code&gt;B&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; and struct-like &lt;code&gt;C{}&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enum E { A = 1 }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If variants are only unit-like, allow discriminant values, e.g., for FFI.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;union U {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsafe C-like &lt;strong&gt;union&lt;/strong&gt; for FFI compatibility.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static X: T = T();&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Global variable&lt;/strong&gt; with &lt;code&gt;&#39;static&lt;/code&gt; lifetime, single memory location.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X: T = T();&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Defines &lt;strong&gt;constant&lt;/strong&gt; . Copied into a temporary when used.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let x: T;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Allocate &lt;code&gt;T&lt;/code&gt; bytes on stack bound as &lt;code&gt;x&lt;/code&gt;. Assignable once, not mutable.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let mut x: T;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Like &lt;code&gt;let&lt;/code&gt;, but allow for &lt;strong&gt;mutability&lt;/strong&gt; and mutable borrow.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x = y;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Moves &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, invalidating &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not &lt;strong&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/strong&gt;, and copying &lt;code&gt;y&lt;/code&gt; otherwise.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;绑定变量（Bound Variables）存在于堆栈中，用于同步代码。在 &lt;code&gt;async {}&lt;/code&gt; 代码中，它们成为异步状态机的一部分，可能驻留在堆上。从技术上讲，可变性和不变性是误称。不可变的绑定或共享引用可能仍包含 Cell，从而提供内部可变性。创建和访问数据结构；以及其他一些西语类型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { x: y }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Create &lt;code&gt;struct S {}&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;&amp;lsquo;ed &lt;code&gt;enum E::S {}&lt;/code&gt; with field &lt;code&gt;x&lt;/code&gt; set to &lt;code&gt;y&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { x }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but use local variable &lt;code&gt;x&lt;/code&gt; for field &lt;code&gt;x&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { ..s }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Fill remaining fields from &lt;code&gt;s&lt;/code&gt;, esp. useful with &lt;a href=&#34;https://doc.rust-lang.org/std/default/trait.Default.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Default&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { 0: x }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Like &lt;code&gt;S&lt;/code&gt; &lt;code&gt;(x)&lt;/code&gt; below, but set field &lt;code&gt;.0&lt;/code&gt; with struct syntax.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt; &lt;code&gt;(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Create &lt;code&gt;struct S&lt;/code&gt; &lt;code&gt;(T)&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;&amp;lsquo;ed &lt;code&gt;enum E::S&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; with field &lt;code&gt;.0&lt;/code&gt; set to &lt;code&gt;x&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;S&lt;/code&gt; is unit &lt;code&gt;struct S;&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;&amp;lsquo;ed &lt;code&gt;enum E::S&lt;/code&gt; create value of &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;E::C { x: y }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Create enum variant &lt;code&gt;C&lt;/code&gt;. Other methods above also work.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Empty tuple, both literal and type, aka &lt;strong&gt;unit&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Parenthesized expression.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(x,)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Single-element &lt;strong&gt;tuple&lt;/strong&gt; expression.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(S,)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Single-element tuple type.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[S]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Array type of unspecified length, i.e., &lt;strong&gt;slice&lt;/strong&gt;. Can&amp;rsquo;t live on stack.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[S; n]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Array type&lt;/strong&gt; of fixed length &lt;code&gt;n&lt;/code&gt; holding elements of type &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x; n]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Array instance with &lt;code&gt;n&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x, y]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Array instance with given elements &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x[0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Collection indexing. Overloadable &lt;a href=&#34;https://doc.rust-lang.org/std/ops/trait.Index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Index&lt;/a&gt;, &lt;a href=&#34;https://doc.rust-lang.org/std/ops/trait.IndexMut.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IndexMut&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x[..]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Collection slice-like indexing via &lt;a href=&#34;https://doc.rust-lang.org/std/ops/struct.RangeFull.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RangeFull&lt;/a&gt;, &lt;em&gt;c&lt;/em&gt;. slices.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x[a..]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Collection slice-like indexing via &lt;a href=&#34;https://doc.rust-lang.org/std/ops/struct.RangeFrom.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RangeFrom&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x[..b]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Collection slice-like indexing &lt;a href=&#34;https://doc.rust-lang.org/std/ops/struct.RangeTo.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RangeTo&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x[a..b]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Collection slice-like indexing via &lt;a href=&#34;https://doc.rust-lang.org/std/ops/struct.Range.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Range&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a..b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Right-exclusive &lt;strong&gt;range&lt;/strong&gt; creation, also seen as &lt;code&gt;..b&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a..=b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inclusive range creation, also seen as &lt;code&gt;..=b&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s.x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Named &lt;strong&gt;field access&lt;/strong&gt;, might try to &lt;a href=&#34;https://doc.rust-lang.org/std/ops/trait.Deref.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Deref&lt;/a&gt; if &lt;code&gt;x&lt;/code&gt; not part of type &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s.0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Numbered field access, used for tuple types &lt;code&gt;S&lt;/code&gt; &lt;code&gt;(T)&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些签名不适合任何其他类别，但是很高兴知道。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Always empty &lt;strong&gt;never type&lt;/strong&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unnamed variable binding, e.g., `&lt;/td&gt;
&lt;td&gt;x, _&lt;/td&gt;
&lt;td&gt;{}`.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let _ = x;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unnamed assignment is no-op, does &lt;strong&gt;not&lt;/strong&gt; move out &lt;code&gt;x&lt;/code&gt; or preserve scope!&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Variable binding explicitly marked as unused.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;1_234_567&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Numeric separator for visual clarity.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;1_u8&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type specifier for &lt;strong&gt;numeric literals&lt;/strong&gt; (also &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &amp;hellip;).&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0xBEEF&lt;/code&gt;, &lt;code&gt;0o777&lt;/code&gt;, &lt;code&gt;0b1001&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Hexadecimal (&lt;code&gt;0x&lt;/code&gt;), octal (&lt;code&gt;0o&lt;/code&gt;) and binary (&lt;code&gt;0b&lt;/code&gt;) integer literals.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;r#foo&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;strong&gt;raw identifier&lt;/strong&gt; for edition compatibility.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Statement&lt;/strong&gt; terminator, &lt;em&gt;c&lt;/em&gt;. &lt;strong&gt;expressions&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;references--pointers&#34;&gt;References &amp;amp; Pointers&lt;/h2&gt;
&lt;p&gt;授予对未拥有的内存的访问权限。另请参见“泛型和约束”部分。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shared &lt;strong&gt;reference&lt;/strong&gt; (space for holding &lt;em&gt;any&lt;/em&gt; &lt;code&gt;&amp;amp;s&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;[S]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Special slice reference that contains (&lt;code&gt;address&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Special string reference that contains (&lt;code&gt;address&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;mut S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Exclusive reference to allow mutability (also &lt;code&gt;&amp;amp;mut [S]&lt;/code&gt;, &lt;code&gt;&amp;amp;mut dyn S&lt;/code&gt;, &amp;hellip;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;dyn T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Special &lt;strong&gt;trait object&lt;/strong&gt; reference that contains (&lt;code&gt;address&lt;/code&gt;, &lt;code&gt;vtable&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*const S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Immutable &lt;strong&gt;raw pointer type&lt;/strong&gt; w/o memory safety.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*mut S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mutable raw pointer type w/o memory safety.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shared &lt;strong&gt;borrow&lt;/strong&gt; (e.g., address, len, vtable, &amp;hellip; of &lt;em&gt;this&lt;/em&gt; &lt;code&gt;s&lt;/code&gt;, like &lt;code&gt;0x1234&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;mut s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Exclusive borrow that allows &lt;strong&gt;mutability&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ref s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Bind by reference&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let ref r = s;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Equivalent to &lt;code&gt;let r = &amp;amp;s&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let S { ref mut x } = s;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mutable ref binding (&lt;code&gt;let x = &amp;amp;mut s.x&lt;/code&gt;), shorthand destructuring version.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Dereference&lt;/strong&gt; a reference &lt;code&gt;r&lt;/code&gt; to access what it points to.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*r = s;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;r&lt;/code&gt; is a mutable reference, move or copy &lt;code&gt;s&lt;/code&gt; to target memory.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s = *r;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Make &lt;code&gt;s&lt;/code&gt; a copy of whatever &lt;code&gt;r&lt;/code&gt; references, if that is &lt;code&gt;Copy&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s = *my_box;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.reddit.com/r/rust/comments/b4so6i/what_is_exactly/ej8xwg8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Special case&lt;/a&gt; for &lt;code&gt;Box&lt;/code&gt; that can also move out Box&amp;rsquo;ed content if it isn&amp;rsquo;t &lt;code&gt;Copy&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;strong&gt;lifetime parameter&lt;/strong&gt;,, duration of a flow in static analysis.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&#39;a S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Only accepts a &lt;code&gt;s&lt;/code&gt; with an address that lives &lt;code&gt;&#39;a&lt;/code&gt; or longer.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&#39;a mut S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but allow content of address to be changed.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;struct S&amp;lt;&#39;a&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Signals &lt;code&gt;S&lt;/code&gt; will contain address with lifetime &lt;code&gt;&#39;a&lt;/code&gt;. Creator of &lt;code&gt;S&lt;/code&gt; decides &lt;code&gt;&#39;a&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;trait T&amp;lt;&#39;a&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Signals a &lt;code&gt;S&lt;/code&gt; which &lt;code&gt;impl T for S&lt;/code&gt; might contain address.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f&amp;lt;&#39;a&amp;gt;(t: &amp;amp;&#39;a T)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, for function. Caller decides &lt;code&gt;&#39;a&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;static&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Special lifetime lasting the entire program execution.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;types&#34;&gt;Types&lt;/h2&gt;
&lt;p&gt;类型的简写名称，以及将一种类型转换为另一种类型的方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;type T = S;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Create a &lt;strong&gt;type alias&lt;/strong&gt;, i.e., another name for &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Self&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type alias for &lt;strong&gt;implementing type&lt;/strong&gt;, e.g. &lt;code&gt;fn new() -&amp;gt; Self&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;self&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Method subject in &lt;code&gt;fn f(self) {}&lt;/code&gt;, same as &lt;code&gt;fn f(self: Self) {}&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;self&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but refers to self as borrowed, same as &lt;code&gt;f(self: &amp;amp;Self)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;mut self&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but mutably borrowed, same as &lt;code&gt;f(self: &amp;amp;mut Self)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;self: Box&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/withoutboats/rfcs/blob/arbitray-receivers/text/0000-century-of-the-self-type.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Arbitrary self type&lt;/a&gt;, add methods to smart pointers (&lt;code&gt;my_box.f_of_self()&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S as T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Disambiguate&lt;/strong&gt; type &lt;code&gt;S&lt;/code&gt; as trait &lt;code&gt;T&lt;/code&gt;, e.g., &lt;code&gt;::f()&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S as R&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;In &lt;code&gt;use&lt;/code&gt; of symbol, import &lt;code&gt;S&lt;/code&gt; as &lt;code&gt;R&lt;/code&gt;, e.g., &lt;code&gt;use a::S as R&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x as u32&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Primitive &lt;strong&gt;cast&lt;/strong&gt;, may truncate and be a bit surprising.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;functions--behavior&#34;&gt;Functions &amp;amp; Behavior&lt;/h2&gt;
&lt;p&gt;定义代码单元及其抽象。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;trait T {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define a &lt;strong&gt;trait&lt;/strong&gt;; common behavior others can implement.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;trait T : R {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt; is subtrait of &lt;strong&gt;supertrait&lt;/strong&gt; &lt;code&gt;R&lt;/code&gt;. Any &lt;code&gt;S&lt;/code&gt; must &lt;code&gt;impl R&lt;/code&gt; before it can &lt;code&gt;impl T&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;impl S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Implementation&lt;/strong&gt; of functionality for a type &lt;code&gt;S&lt;/code&gt;, e.g., methods.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;impl T for S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Implement trait &lt;code&gt;T&lt;/code&gt; for type &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;impl !T for S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Disable an automatically derived &lt;strong&gt;auto trait&lt;/strong&gt; .&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f() {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Definition of a &lt;strong&gt;function&lt;/strong&gt;; or associated function if inside &lt;code&gt;impl&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f() -&amp;gt; S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, returning a value of type S.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f(&amp;amp;self) {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define a &lt;strong&gt;method&lt;/strong&gt;, e.g., within an &lt;code&gt;impl S {}&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const fn f() {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Constant &lt;code&gt;fn&lt;/code&gt; usable at compile time, e.g., &lt;code&gt;const X: u32 = f(Y)&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;async fn f() {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Async&lt;/strong&gt; function transformation, makes &lt;code&gt;f&lt;/code&gt; return an &lt;code&gt;impl&lt;/code&gt; &lt;strong&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/strong&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;async fn f() -&amp;gt; S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but make &lt;code&gt;f&lt;/code&gt; return an &lt;code&gt;impl Future&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;async { x }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Used within a function, make &lt;code&gt;{ x }&lt;/code&gt; an &lt;code&gt;impl Future&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn() -&amp;gt; S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Function pointers&lt;/strong&gt;,, memory holding address of a callable.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Fn() -&amp;gt; S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Callable Trait&lt;/strong&gt;, (also &lt;code&gt;FnMut&lt;/code&gt;, &lt;code&gt;FnOnce&lt;/code&gt;), implemented by closures, fn&amp;rsquo;s &amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;{}`&lt;/td&gt;
&lt;td&gt;A &lt;strong&gt;closure&lt;/strong&gt; that borrows its &lt;strong&gt;captures&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;{}`&lt;/td&gt;
&lt;td&gt;Closure with a bound parameter &lt;code&gt;x&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x + x`&lt;/td&gt;
&lt;td&gt;Closure without block expression; may only consist of single expression.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`move&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x + y`&lt;/td&gt;
&lt;td&gt;Closure taking ownership of its captures.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`return&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;true`&lt;/td&gt;
&lt;td&gt;Closures sometimes look like logical ORs (here: return a closure).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If you enjoy debugging segfaults Friday night; &lt;strong&gt;unsafe code&lt;/strong&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;unsafe f() {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Sort-of means &amp;ldquo;&lt;em&gt;can cause UB, &lt;strong&gt;YOU must check&lt;/strong&gt; requirements&lt;/em&gt;&amp;rdquo;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;unsafe {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Guarantees to compiler &amp;ldquo;&lt;strong&gt;*I have checked&lt;/strong&gt; requirements, trust me*&amp;rdquo;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;control-flow&#34;&gt;Control Flow&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;while x {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Loop&lt;/strong&gt;, run while expression &lt;code&gt;x&lt;/code&gt; is true.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;loop {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Loop infinitely&lt;/strong&gt; until &lt;code&gt;break&lt;/code&gt;. Can yield value with &lt;code&gt;break x&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;for x in iter {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Syntactic sugar to loop over &lt;strong&gt;iterators&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if x {} else {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Conditional branch&lt;/strong&gt; if expression is true.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;label: loop {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Loop label&lt;/strong&gt;, useful for flow control in nested loops.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;break&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Break expression&lt;/strong&gt; to exit a loop.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;break x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but make &lt;code&gt;x&lt;/code&gt; value of the loop expression (only in actual &lt;code&gt;loop&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;break &#39;label&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Exit not only this loop, but the enclosing one marked with &lt;code&gt;&#39;label&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Continue expression&lt;/strong&gt; to the next loop iteration of this loop.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;continue &#39;label&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but instead of enclosing loop marked with &lt;code&gt;&#39;label&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;If &lt;code&gt;x&lt;/code&gt; is &lt;a href=&#34;https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Err&lt;/a&gt; or &lt;a href=&#34;https://doc.rust-lang.org/std/option/enum.Option.html#variant.None&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;None&lt;/a&gt;, &lt;strong&gt;return and propagate&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x.await&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Only works inside &lt;code&gt;async&lt;/code&gt;. Yield flow until &lt;strong&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/strong&gt; or Stream &lt;code&gt;x&lt;/code&gt; ready.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;return x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Early return from function. More idiomatic way is to end with expression.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;f()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Invoke callable &lt;code&gt;f&lt;/code&gt; (e.g., a function, closure, function pointer, &lt;code&gt;Fn&lt;/code&gt;, &amp;hellip;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x.f()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Call member function, requires &lt;code&gt;f&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &amp;hellip; as first argument.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::f(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same as &lt;code&gt;x.f()&lt;/code&gt;. Unless &lt;code&gt;impl Copy for X {}&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; can only be called once.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::f(&amp;amp;x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same as &lt;code&gt;x.f()&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::f(&amp;amp;mut x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same as &lt;code&gt;x.f()&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S::f(&amp;amp;x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same as &lt;code&gt;x.f()&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; &lt;a href=&#34;https://doc.rust-lang.org/std/ops/trait.Deref.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;derefs&lt;/a&gt; to &lt;code&gt;S&lt;/code&gt;, i.e., &lt;code&gt;x.f()&lt;/code&gt; finds methods of &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T::f(&amp;amp;x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same as &lt;code&gt;x.f()&lt;/code&gt; if &lt;code&gt;X impl T&lt;/code&gt;, i.e., &lt;code&gt;x.f()&lt;/code&gt; finds methods of &lt;code&gt;T&lt;/code&gt; if in scope.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::f()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Call associated function, e.g., &lt;code&gt;X::new()&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;::f()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Call trait method &lt;code&gt;T::f()&lt;/code&gt; implemented for &lt;code&gt;X&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;pattern-matching&#34;&gt;Pattern Matching&lt;/h2&gt;
&lt;p&gt;在 match 或 let 表达式或函数参数中找到的构造。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;match m {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Initiate &lt;strong&gt;pattern matching&lt;/strong&gt;, then use match arms, &lt;em&gt;c&lt;/em&gt;. next table.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let S(x) = get();&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Notably, &lt;code&gt;let&lt;/code&gt; also &lt;strong&gt;destructures&lt;/strong&gt; similar to the table below.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let S { x } = s;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Only &lt;code&gt;x&lt;/code&gt; will be bound to value &lt;code&gt;s.x&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let (_, b, _) = abc;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Only &lt;code&gt;b&lt;/code&gt; will be bound to value &lt;code&gt;abc.1&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let (a, ..) = abc;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Ignoring &amp;rsquo;the rest&amp;rsquo; also works.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let (.., a, b) = (1, 2);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Specific bindings take precedence over &amp;rsquo;the rest&amp;rsquo;, here &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;let Some(x) = get();&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Won&amp;rsquo;t&lt;/strong&gt; work if pattern can be &lt;strong&gt;refuted&lt;/strong&gt;, use &lt;code&gt;if let&lt;/code&gt; instead.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;if let Some(x) = get() {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Branch if pattern can be assigned (e.g., &lt;code&gt;enum&lt;/code&gt; variant), syntactic sugar.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f(S { x }: S)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Function parameters also work like &lt;code&gt;let&lt;/code&gt;, here &lt;code&gt;x&lt;/code&gt; bound to &lt;code&gt;s.x&lt;/code&gt; of &lt;code&gt;f(s)&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;匹配表达式中的模式匹配臂。这些臂的左侧也可以在 let 表达式中找到。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Match Arm&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;E::A =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match enum variant &lt;code&gt;A&lt;/code&gt;, &lt;em&gt;c&lt;/em&gt;. &lt;strong&gt;pattern matching&lt;/strong&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;E::B ( .. ) =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match enum tuple variant &lt;code&gt;B&lt;/code&gt;, wildcard any index.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;E::C { .. } =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match enum struct variant &lt;code&gt;C&lt;/code&gt;, wildcard any field.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { x: 0, y: 1 } =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match struct with specific values (only accepts &lt;code&gt;s&lt;/code&gt; with &lt;code&gt;s.x&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;s.y&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt;).&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { x: a, y: b } =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match struct with &lt;em&gt;any&lt;/em&gt;(!) values and bind &lt;code&gt;s.x&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;s.y&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { x, y } =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but shorthand with &lt;code&gt;s.x&lt;/code&gt; and &lt;code&gt;s.y&lt;/code&gt; bound as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; respectively.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { .. } =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match struct with any values.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;D =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match enum variant &lt;code&gt;E::D&lt;/code&gt; if &lt;code&gt;D&lt;/code&gt; in &lt;code&gt;use&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;D =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match anything, bind &lt;code&gt;D&lt;/code&gt;; possibly false friend of &lt;code&gt;E::D&lt;/code&gt; if &lt;code&gt;D&lt;/code&gt; not in &lt;code&gt;use&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_ =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Proper wildcard that matches anything / &amp;ldquo;all the rest&amp;rdquo;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(a, 0) =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match tuple with any value for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; for second.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[a, 0] =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Slice pattern&lt;/strong&gt;, match array with any value for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; for second.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[1, ..] =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match array starting with &lt;code&gt;1&lt;/code&gt;, any value for rest; &lt;strong&gt;subslice pattern&lt;/strong&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[2, .., 5] =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match array starting with &lt;code&gt;1&lt;/code&gt;, ending with &lt;code&gt;5&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[2, x @ .., 5] =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but also bind &lt;code&gt;x&lt;/code&gt; to slice representing middle (&lt;em&gt;c.&lt;/em&gt; next entry).&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x @ 1..=5 =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bind matched to &lt;code&gt;x&lt;/code&gt;; &lt;strong&gt;pattern binding&lt;/strong&gt;, here &lt;code&gt;x&lt;/code&gt; would be &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &amp;hellip; or &lt;code&gt;5&lt;/code&gt;.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`0&lt;/td&gt;
&lt;td&gt;1 =&amp;gt; {}`&lt;/td&gt;
&lt;td&gt;Pattern alternatives (or-patterns).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`E::A&lt;/td&gt;
&lt;td&gt;E::Z`&lt;/td&gt;
&lt;td&gt;Same, but on enum variants.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`E::C {x}&lt;/td&gt;
&lt;td&gt;E::D {x}`&lt;/td&gt;
&lt;td&gt;Same, but bind &lt;code&gt;x&lt;/code&gt; if all variants have it.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S { x } if x &amp;gt; 10 =&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Pattern &lt;strong&gt;match guards&lt;/strong&gt;, condition must be true as well to match.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;macros--attributes&#34;&gt;Macros &amp;amp; Attributes&lt;/h2&gt;
&lt;p&gt;代码生成结构在实际编译发生之前就已扩展。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;m!()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Macro&lt;/strong&gt; invocation, also &lt;code&gt;m!{}&lt;/code&gt;, &lt;code&gt;m![]&lt;/code&gt; (depending on macro).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;#[attr]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Outer &lt;strong&gt;attribute&lt;/strong&gt;., annotating the following item.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;#![attr]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inner attribute, annotating the surrounding item.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在声明性宏中的示例 macro_rules！实现这些工作：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Within Macros&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:ty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Macro capture, with the &lt;code&gt;ty&lt;/code&gt; part being:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:item&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;An item, like a function, struct, module, etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:block&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A block &lt;code&gt;{}&lt;/code&gt; of statements or expressions, e.g., &lt;code&gt;{ let x = 5; }&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:stmt&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A statement, e.g., &lt;code&gt;let x = 1 + 1;&lt;/code&gt;, &lt;code&gt;String::new();&lt;/code&gt; or &lt;code&gt;vec![];&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;An expression, e.g., &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;1 + 1&lt;/code&gt;, &lt;code&gt;String::new()&lt;/code&gt; or &lt;code&gt;vec![]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:pat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A pattern, e.g., &lt;code&gt;Some(t)&lt;/code&gt;, &lt;code&gt;(17, &#39;a&#39;)&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:ty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A type, e.g., &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt; or &lt;code&gt;Vec&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:ident&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;An identifier, for example in &lt;code&gt;let x = 0;&lt;/code&gt; the identifier is &lt;code&gt;x&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:path&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A path (e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;::std::mem::replace&lt;/code&gt;, &lt;code&gt;transmute::&amp;lt;_, int&amp;gt;&lt;/code&gt;, …).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:literal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A literal (e.g. &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, &lt;code&gt;b&amp;quot;bar&amp;quot;&lt;/code&gt;, etc.).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:lifetime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A lifetime (e.g. &lt;code&gt;&#39;a&lt;/code&gt;, &lt;code&gt;&#39;static&lt;/code&gt;, etc.).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:meta&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A meta item; the things that go inside &lt;code&gt;#[...]&lt;/code&gt; and &lt;code&gt;#![...]&lt;/code&gt; attributes.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A visibility modifier; &lt;code&gt;pub&lt;/code&gt;, &lt;code&gt;pub(crate)&lt;/code&gt;, etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x:tt&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A single token tree, &lt;a href=&#34;https://stackoverflow.com/a/40303308&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;see here&lt;/a&gt; for more details.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Macro substitution, e.g., use the captured &lt;code&gt;$x:ty&lt;/code&gt; from above.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$(x),*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Macro repetition &amp;ldquo;zero or more times&amp;rdquo; in macros by example.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$(x),?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but &amp;ldquo;zero or one time&amp;rdquo;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$(x),+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but &amp;ldquo;one or more times&amp;rdquo;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$(x)&amp;lt;&amp;lt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;In fact separators other than &lt;code&gt;,&lt;/code&gt; are also accepted. Here: &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$crate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Special hygiene variable, crate where macros is defined.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;generics--constraints&#34;&gt;Generics &amp;amp; Constraints&lt;/h2&gt;
&lt;p&gt;Generics combine with many other constructs such as struct S&lt;T&gt;, fn f&lt;T&gt;(), &amp;hellip;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A &lt;strong&gt;generic&lt;/strong&gt; type with a type parameter (&lt;code&gt;T&lt;/code&gt; is placeholder name here).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type short hand &lt;strong&gt;trait bound&lt;/strong&gt; specification (&lt;code&gt;R&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be actual trait).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T: R, P: S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Independent trait bounds&lt;/strong&gt; (here one for &lt;code&gt;T&lt;/code&gt; and one for &lt;code&gt;P&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T: R, S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Compile error, you probably want compound bound &lt;code&gt;R + S&lt;/code&gt; below.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T: R + S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Compound trait bound&lt;/strong&gt;, &lt;code&gt;T&lt;/code&gt; must fulfill &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T: R + &#39;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but w. lifetime. &lt;code&gt;T&lt;/code&gt; must fulfill &lt;code&gt;R&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; has lifetimes, must outlive &lt;code&gt;&#39;a&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T: ?Sized&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Opt out of a pre-defined trait bound, here &lt;code&gt;Sized&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T: &#39;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type &lt;strong&gt;lifetime bound&lt;/strong&gt; ; if T has references, they must outlive &lt;code&gt;&#39;a&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T: &#39;static&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same; does esp. &lt;em&gt;not&lt;/em&gt; mean value &lt;code&gt;t&lt;/code&gt; &lt;em&gt;will&lt;/em&gt; live &lt;code&gt;&#39;static&lt;/code&gt;, only that it could.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;b: &#39;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Lifetime &lt;code&gt;&#39;b&lt;/code&gt; must live at least as long as (i.e., &lt;em&gt;outlive&lt;/em&gt;) &lt;code&gt;&#39;a&lt;/code&gt; bound.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S where T: R&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same as &lt;code&gt;S&lt;/code&gt; but more pleasant to read for longer bounds.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Default type parameter&lt;/strong&gt; for associated type.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&amp;lt;&#39;_&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inferred &lt;strong&gt;anonymous lifetime&lt;/strong&gt;; asks compiler to &lt;em&gt;&amp;lsquo;figure it out&amp;rsquo;&lt;/em&gt; if obvious.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inferred &lt;strong&gt;anonymous type&lt;/strong&gt;, e.g., as &lt;code&gt;let x: Vec&amp;lt;_&amp;gt; = iter.collect()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S::&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Turbofish&lt;/strong&gt; call site type disambiguation, e.g. &lt;code&gt;f::()&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;trait T {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;A trait generic over &lt;code&gt;X&lt;/code&gt;. Can have multiple &lt;code&gt;impl T for S&lt;/code&gt; (one per &lt;code&gt;X&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;trait T { type X; }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Defines &lt;strong&gt;associated type&lt;/strong&gt; &lt;code&gt;X&lt;/code&gt;. Only one &lt;code&gt;impl T for S&lt;/code&gt; possible.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;type X = R;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Set associated type within &lt;code&gt;impl T for S { type X = R; }&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;impl S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Implement functionality for any &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;S&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;impl S {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Implement functionality for exactly &lt;code&gt;S&lt;/code&gt; (e.g., &lt;code&gt;S&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f() -&amp;gt; impl T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Existential types&lt;/strong&gt;, returns an unknown-to-caller &lt;code&gt;S&lt;/code&gt; that &lt;code&gt;impl T&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f(x: &amp;amp;impl T)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Trait bound,&amp;quot;&lt;strong&gt;impl traits&lt;/strong&gt;&amp;quot;, somewhat similar to &lt;code&gt;fn f(x: &amp;amp;S)&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f(x: &amp;amp;dyn T)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Marker for &lt;strong&gt;dynamic dispatch&lt;/strong&gt;, &lt;code&gt;f&lt;/code&gt; will not be monomorphized.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f() where Self: R;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;In &lt;code&gt;trait T {}&lt;/code&gt;, make &lt;code&gt;f&lt;/code&gt; accessible only on types known to also &lt;code&gt;impl R&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fn f() where Self: R {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Esp. useful w. default methods (non dflt. would need be impl&amp;rsquo;ed anyway).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;for&amp;lt;&#39;a&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Higher-ranked trait bounds.&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;trait T: for&amp;lt;&#39;a&amp;gt; R&amp;lt;&#39;a&amp;gt; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Any &lt;code&gt;S&lt;/code&gt; that &lt;code&gt;impl T&lt;/code&gt; would also have to fulfill &lt;code&gt;R&lt;/code&gt; for any lifetime.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;data-structures&#34;&gt;Data Structures&lt;/h1&gt;
&lt;h1 id=&#34;organizing-code&#34;&gt;Organizing Code&lt;/h1&gt;
&lt;p&gt;将项目分割成较小的单元，并最大程度地减少依赖性。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mod m {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define a &lt;strong&gt;module&lt;/strong&gt;, get definition from inside &lt;code&gt;{}&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mod m;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Define a module, get definition from &lt;code&gt;m.rs&lt;/code&gt; or &lt;code&gt;m/mod.rs&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a::b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Namespace &lt;strong&gt;path&lt;/strong&gt; to element &lt;code&gt;b&lt;/code&gt; within &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;mod&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &amp;hellip;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;::b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Search &lt;code&gt;b&lt;/code&gt; relative to crate root.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;crate::b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Search &lt;code&gt;b&lt;/code&gt; relative to crate root.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;self::b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Search &lt;code&gt;b&lt;/code&gt; relative to current module.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;super::b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Search &lt;code&gt;b&lt;/code&gt; relative to parent module.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;use a::b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Use&lt;/strong&gt; &lt;code&gt;b&lt;/code&gt; directly in this scope without requiring &lt;code&gt;a&lt;/code&gt; anymore.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;use a::{b, c};&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Same, but bring &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; into scope.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;use a::b as x;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bring &lt;code&gt;b&lt;/code&gt; into scope but name &lt;code&gt;x&lt;/code&gt;, like &lt;code&gt;use std::error::Error as E&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;use a::b as _;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bring &lt;code&gt;b&lt;/code&gt; anonymously into scope, useful for traits with conflicting names.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;use a::*;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bring everything from &lt;code&gt;a&lt;/code&gt; into scope.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pub use a::b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bring &lt;code&gt;a::b&lt;/code&gt; into scope and reexport from here.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pub T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;ldquo;Public if parent path is public&amp;rdquo; &lt;strong&gt;visibility&lt;/strong&gt; for &lt;code&gt;T&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pub(crate) T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Visible at most in current crate.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pub(self) T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Visible at most in current module.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pub(super) T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Visible at most in parent.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pub(in a::b) T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Visible at most in &lt;code&gt;a::b&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;extern crate a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Declare dependency on external &lt;strong&gt;crate&lt;/strong&gt; ; just &lt;code&gt;use a::b&lt;/code&gt; in .&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;extern &amp;quot;C&amp;quot; {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Declare&lt;/em&gt; external dependencies and ABI (e.g., &lt;code&gt;&amp;quot;C&amp;quot;&lt;/code&gt;) from &lt;strong&gt;FFI&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;extern &amp;quot;C&amp;quot; fn f() {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Define&lt;/em&gt; function to be exported with ABI (e.g., &lt;code&gt;&amp;quot;C&amp;quot;&lt;/code&gt;) to FFI.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;内存结构&#34;&gt;内存结构&lt;/h1&gt;
&lt;h2 id=&#34;basic-types&#34;&gt;Basic Types&lt;/h2&gt;
&lt;h2 id=&#34;字符串&#34;&gt;字符串&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;...&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;String literal&lt;/strong&gt;, UTF-8, will interpret &lt;code&gt;\n&lt;/code&gt; as &lt;em&gt;line break&lt;/em&gt; &lt;code&gt;0xA&lt;/code&gt;, &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;r&amp;quot;...&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Raw string literal&lt;/strong&gt;. UTF-8, won&amp;rsquo;t interpret &lt;code&gt;\n&lt;/code&gt;, &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;r#&amp;quot;...&amp;quot;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Raw string literal, UTF-8, but can also contain &lt;code&gt;&amp;quot;&lt;/code&gt;. Number of &lt;code&gt;#&lt;/code&gt; can vary.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;b&amp;quot;...&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Byte string literal&lt;/strong&gt;; constructs ASCII &lt;code&gt;[u8]&lt;/code&gt;, not a string.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;br&amp;quot;...&amp;quot;&lt;/code&gt;, &lt;code&gt;br#&amp;quot;...&amp;quot;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Raw byte string literal, ASCII &lt;code&gt;[u8]&lt;/code&gt;, combination of the above.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;🦀&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Character literal&lt;/strong&gt;, fixed 4 byte unicode &amp;lsquo;&lt;strong&gt;char&lt;/strong&gt;&amp;rsquo;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;b&#39;x&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ASCII &lt;strong&gt;byte literal&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;tbd&#34;&gt;TBD&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mojotv.cn/rust/rust-cheatsheet-01-data-structures&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mojotv.cn/rust/rust-cheatsheet-01-data-structures&lt;/a&gt; Rust-CheatSheet&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://colobu.com/2020/03/05/A-half-hour-to-learn-Rust/?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://colobu.com/2020/03/05/A-half-hour-to-learn-Rust/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
