<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>4.Infrastructure | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/</link><atom:link href="https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/index.xml" rel="self" type="application/rss+xml"/><description>4.Infrastructure</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>4.Infrastructure</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/</link></image><item><title>Blockchain-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/blockchain-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/blockchain-cheatsheet/</guid><description>&lt;h1 id="区块链">区块链&lt;/h1>
&lt;p>In essence, the blockchain is a shared, programmable, cryptographically secure and therefore trusted ledger which no single user controls and which can be inspected by anyone.- Klaus Schwab&lt;/p>
&lt;p>区块链技术是最近在互联网技术前沿比较火的一个课题，它的出现解决了在点对点通信中一直存在的一个基本问题，即著名的拜占庭将军问题。通俗地讲就是在一个去中心化的网络中如何对一个信息传递(比如一笔支付)达成全网共识。&lt;/p>
&lt;p>区块链由时间序列的链式数据块构成，提供了拜占庭容错、并基于共识协议保证了最终一致性的分布式数据库。&lt;/p>
&lt;p>区块链本质上是一个去中心化的分布式账本数据库，是比特币的底层技术，和比特币是相伴相生的关系。区块链本身其实是一串使用密码学相关联所产生的数据块，每一个数据块中包含了多次比特币网络交易有效确认的信息。
每当有加密交易产生时，网络中有强大运算能力的矿工(Miner)就开始利用算法解密验证交易，创造出新的区块来记录最新的交易。新的区块按照时间顺序线性地被补充到原有的区块链末端，这个账本就会不停地增长和延长。&lt;/p>
&lt;p>通过复杂的公共钥匙和私人钥匙的设置，区块链网络将整个金融网络的所有交易的账本实时广播，实时将交易记录分发到每一个客户端，同时还能保证每个人只能对自己的财产进行修改。当然，账本里也有别人的交易记录，虽然可以看到数值和对应的交易地址(基本上这是由一段冗长的乱序字母和数字组成)，但是如果不借用其他&lt;/p>
&lt;p>技术手段也根本无法知道交易者的真实身份。
如果从不同的技术角度来剖析，我们可以这样看待区块链：它是一种数据库、一种分布式系统，也是一种网络底层协议。
(1)数据库。区块链是一种公共数据库，它记录了网际间所有的交易信息，随时更新，让每个用户可以通过合法的手段从中读取信息，写入信息。但又有一套特殊的机制，防止以往的数据被篡改。
(2)分布式系统。区块链是一种分布式系统，它不存储放置在某一两个特定的服务器或安全节点上，而是分布式地存在于网络上所有的完整节点上，在每一个节点保留信息备份。
(3)网络底层协议。区块链是一种共识协议，基于这种协议，可以在其上开发出数目繁多的应用。这些应用在每一时刻都保存一条最长的、最具权威的、共同认可的数据记录，并遵循共同认可的机制进行无须中间权威仲裁的、直接的、点对点的交互信息。&lt;/p>
&lt;h1 id="数字货币">数字货币&lt;/h1>
&lt;p>数字货币应用方向&lt;/p>
&lt;p>数字货币是区块链的第一大应用类型，其实你可以简单理解为一种无主权、社区自治的货币形式。数字货币通常是基于区块链技术、在全球范围内公开发行的、并且没有任何国家政府背书的虚拟货币，这种虚拟货币具有“去信任”、“点对点”、“公开记账”、“不可篡改”等特征。&lt;/p>
&lt;p>总量透明公开。数字货币的发行是在项目创建之初，是白皮书事先就规定好了的，白皮书通常是一个区块链项目公开发布的一种阐述性文档，其中简述了项目的宗旨和愿景以及设计蓝图。&lt;/p>
&lt;p>数字货币缓慢释放。数字货币缓慢释放。挖矿为数字货币的缓慢释放提供了一种方法。&lt;/p>
&lt;p>代码执行规则。由于我们在白皮书中规定好了总量和数字货币释放的机制，白皮书的内容会成为整个社区的基础共识，所以在项目的主网上线之后，数字货币的释放不再是人为控制，而是在代码层面体现，代码将负责控制数字货币的释放，这里去除了人为操作的因素。&lt;/p>
&lt;p>数字资产&lt;/p>
&lt;p>虚拟资产一般包括有金融资产、游戏代币、数字版权、域名、用户流量等。由于虚拟资产不需要与实体资产进行挂钩，所以在对应到区块链上更为方便。它具体的应用形式在供应链金融、票据市场都有所体现。&lt;/p>
&lt;p>我们在这里，简单从技术的角度介绍一下 ICO，ICO 的中文名是首次代币发行，又称为区块链众筹，这是一种新型的融资模式，投资者可以用手中的比特币 或其他代币投 到一些区块链创始项目。&lt;/p>
&lt;h1 id="区块链的衍化">区块链的衍化&lt;/h1>
&lt;h2 id="第一代">第一代&lt;/h2>
&lt;p>第一代区块链技术发展出的去中心化、不依赖第三方认证的防止多重支付的技术解决方案，大幅度降低了中间交易和支付费用。另外就是依赖于密码技术，解决了参与方的信任问题。
但是这一代技术，在于哲学思维上对全民选举形成共识机制的过于理想化的坚持，导致了效率的低下。比如比特币的任何交易和支付需要至少 10 分钟才能初步完成(通过改进的其他系统，可以&lt;/p>
&lt;p>比特币的区块链应用于价值传递，就是转账，所以最简单的应用就是在金融领域，比如跨境转账，支付汇兑。严格说起来，数字货币其实是区块链最简单、最直接的应用场景。绝大多数的区块链项目，都会有自己的内生代币。&lt;/p>
&lt;p>共识机制，就是所有记账节点之间如何区域达成共识，来选择和认定记录的真实性和有效性。全网认可的是最长的一条区块链，因为在此之上的工作量最大。如果想要修改某个区块内的交易信息，就必须将该区块和后面所有区块的信息进行修改。这种共识机制既可以作为认定的手段，又可以避免虚假交易和信息篡改。&lt;/p>
&lt;h2 id="区块与账本">区块与账本&lt;/h2>
&lt;p>区块链网络中，数据以文件的形式被永久记录，我们称之为区块。一个区块是一些或所有最新比特币交易的记录集，且未被其他先前的区块记录。区块可以想像为一个城市记录者的记录本上的单独一页纸(对房地产产权的变更记录)或者是股票交易所的总帐本。在绝大多数情况下，新区块被加入到记录最后(在比特币中的名称为：块链)，一旦写上，就再也不能改变或删除。每个区块记录了它被创建之前发生的所有事件。&lt;/p>
&lt;p>每个区块包括一些或所有近期交易、前一个区块的引用，以及其他数据。它还包括一个挖矿难度的答案——该答案对每个区块是唯一的。新区块如果没有正确答案，不能被发送到网络中——“挖矿”的过程本质上是在竞争中 “解决”当前区块。每个区块中的数学问题难以解决，但是一旦发现了一个有效解，其他网络节点很容易验证这个解的正确性，对于给定的区块可能有多个有效解，但对于要解决的区块来说只需一个解。
因为每解决一个区块，都会得到新产生的比特币奖励，每个区块包含一个记录，记录中的比特币地址是有权获得比特币奖励的地址。这个纪录被称为生产交易或者 Coinbase 交易，它经常是每个区块的第一个交易。每个区块生产的比特币数量是 50 个，每产生 21 万个区块后减少一半(时间大约是 4 年)。&lt;/p>
&lt;p>发送者在网络中广播比特币交易，所有试图解决区块的矿工节点，收集了这些交易记录，把它们加到矿工节点正在解决的区块中。
挖矿难度由比特币网络自动调整，使之实现平均每小时解决 6 个区块的目标。每 2016 个区块(大约两周)后，所有客户端把新区块的实际数目与目标数量相比较，并且按照差异的百分比调整目标 Hash 值，来增加(或降低)产生区块的难度。&lt;/p>
&lt;h2 id="共识机制与工作量证明">共识机制与工作量证明&lt;/h2>
&lt;p>POW：Proof of Work，工作证明。
比特币在 Block 的生成过程中使用了 POW 机制，一个符合要求的 Block Hash 由 N 个前导零构成，零的个数取决于网络的难度值。要得到合理的 Block Hash 需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的 Block Hash 值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理 Hash 是一个概率事件。当节点拥有占全网 n% 的算力时，该节点即有 n/100 的概率找到 Block Hash。
POS：Proof of Stake，股权证明。
POS，也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。
简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明 POS 模式下，有一个名词叫币龄，每个币每天产生 1 币龄，比如你持有 100 个币，总共持有了 30 天，那么，此时你的币龄就为 3000，这个时候，如果你发现了一个 POS 区块，你的币龄就会被清空为 0。你每被清空 365 币龄，你将会从区块中获得 0.05 个币的利息(假定利息可理解为年利率 5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41 个币，这下就很有意思了，持币有利息。&lt;/p>
&lt;ol start="2">
&lt;li>瑞波币(Ripple)
瑞波币是 Ripple 网络运行的基础货币，就像比特币一样可以在整个网络中流通，而不必局限于熟人圈子。瑞波币引入网关系统，它类似于货币兑换机构，允许人们把法定货币注入、抽离 Ripple 网络，并可充当借贷双方的桥梁。&lt;/li>
&lt;li>莱特币(Litecoin)
莱特币与比特币相比具有三种显著差异：第一，莱特币网络大约每 2.5 分钟(而不是 10 分钟)就可以处理一个块，因此可以提供更快的交易确认；第二，莱特币网络预期产出 8400 万个莱特币，是比特币网络发行货币量的四倍之多；第三，莱特币在其工作量证明算法中使用了由 Colin Percival(科林 · 珀西瓦尔)首次提出的 Scrypt 加密算法，这使得相比于比特币，在普通计算机上进行莱特币挖掘更为容易(在 ASIC 矿机诞生之前)。每一个莱特币被分成 100000000 个更小的单位，通过 8 位小数来界定。不同于比特币，Scrypt 所具有的内存密集特性让莱特币更适合用图形处理器(GPU)进行“挖矿”。为 Scrypt 实施的 FPGA(现场可编辑逻辑门阵列)和 ASIC(专用集成电路)，相比于比特币使用的 sha256，更为昂贵。&lt;/li>
&lt;/ol>
&lt;h2 id="第二代">第二代&lt;/h2>
&lt;h3 id="智能合约">智能合约&lt;/h3>
&lt;p>1.以太坊(Ethereum)
以太坊是下一代密码学账本，支持众多的高级功能，包括用户发行货币、智能协议、去中心化的交易、普遍认为的第一个完全的去中心化自治组织(DAOs)或去中心化自治公司(DACs)应用。使以太坊与众不同的是实现这些功能的方式。以太坊并不是把每一单个类型的功能作为特性来特别支持，相反，以太坊包括一个内置的图灵完备的脚本语言，允许通过被称为“合同”的机制来为自己想实现的特性写代码。一个合同就像一个自动的代理，每当接收到一笔交易，合同就会运行特定的一段代码，这段代码能修改合同内部的数据存储或者发送交易。高级的合同甚至能修改自身的代码。&lt;/p>
&lt;p>智能合约，完全由代码组成、自动执行的合约。可以自动核查某事是否发生、某物是否存在、某事是否完成等“条件判断”类条款，并据此对资金进行相应的转移。&lt;/p>
&lt;h3 id="代议制">代议制&lt;/h3>
&lt;p>第二代区块链技术的一个方向就是像美国的 Ripple 公司(详见本书第四章第三节)那样，开始考虑用人民代表大会的代议制度来达成系统共识——就是对各种交易和支付的认定，不是传统中心化的单一中心认定，也不是第一代区块链技术的全民参与认定，而是依靠大家信任的人民代表大会制度来代议。&lt;/p>
&lt;h2 id="第三代">第三代&lt;/h2>
&lt;p>第三代区块链技术版本的核心用一句话概括，就是变“绝对去中心化”为“有效去中心化”。&lt;/p>
&lt;h1 id="应用与不足">应用与不足&lt;/h1>
&lt;ol>
&lt;li>公开记账&lt;/li>
&lt;/ol>
&lt;p>每家每户都记账，账簿上不再记载每户村民的余额，而只记载每一笔 Transaction，即记载每一笔交易的付款人、收款人和付款金额。“公开记账”就是全网所有人都可以随时查看一套账本，然后按照规则透明公开地进行记账。&lt;/p>
&lt;ol start="2">
&lt;li>创建创世区块&lt;/li>
&lt;/ol>
&lt;p>创世区块是我们生成全村公开账本的第一笔交易的第一个信封，好比一篇文章总得有个开头一样。&lt;/p>
&lt;ol start="3">
&lt;li>交易&lt;/li>
&lt;/ol>
&lt;p>村长写好 Transaction 以后，还需要拿出自己的印章，在 Transaction 上盖章，这个盖章的过程也就相当于区块链中的签名。这个章，全村人都可以拿扫描器扫一下验证是否有效，即验证付款人的章是否有效。&lt;/p>
&lt;p>用自己的私钥签名，证明交易是自己发起的。用对方的公钥加密，以保证只有正确的接收方才能获得信息。&lt;/p>
&lt;ol start="4">
&lt;li>打包 Transaction（挖矿）&lt;/li>
&lt;/ol>
&lt;p>是为了让打包交易的人能够在信封上署名，表示这次打包是由某某某打包的，其次全村的交易可能非常多，需要装配标号，方便大家查询。我们用一个特殊的信封把 Transaction 装起来，这个信封就是区块链中的“区块”，这个封装过程就是“打包交易”。&lt;/p>
&lt;p>我给大家出一个难题，谁先解出这个难题的答案，谁就有权利把 Transaction 装到一个信封中，并且要在此信封上盖上自己的章。答案非常好验证，但是计算过程是一个尝试的过程，需要耗费大量的精力。而在真实的比特币中，采用的是寻找符合条件的目标哈希，这也就是比特币矿工所做的事情。&lt;/p>
&lt;p>矿工在打包之后能够获得对应的奖励&lt;/p>
&lt;ol start="5">
&lt;li>广播交易&lt;/li>
&lt;/ol>
&lt;p>广播的内容分两种，一种是广播 Transaction，一种是广播信封。第一种广播是意味着还有未被打包的 Transaction，而第二种广播信封则意味着这个 Transaction 已经被某个矿工确认。&lt;/p>
&lt;p>收到了广播的通知后，大家先验证信封上难题的答案是否正确，这样便可以验证出信封是否被伪造，接着验里面的每笔交易，最后还要验证信封背面的内容，即上一个信封的摘要是否正确。因为上一个信封大家都已经确认，所以这样可以极大地规避作弊的可能。如果觉得没问题，就可以存入本地数据库中了。&lt;/p>
&lt;p>比特币的发布时间为 2009 年 1 月 9 号，预计它的挖矿可以一直持续到 2140 年，发行总量收敛到 2100 万。比特币的出块时间是 10 分钟，出块时间是指全网平均产生一个区块的时间间隔。&lt;/p>
&lt;p>以太坊是一个区块链应用平台，它的极大创新在于它提供了智能合约这种可以自定义业务逻辑的工具，智能合约是一种可编程的合约，合约是由用户编写并且部署到区块链上的。
以太坊的优势是为全世界的开发者们提供了一种开发工具，这种工具让所有人都能释放出巨大的创造力，所以基本上可以看成：只要是有一定技术基础的开发者，通过智能合约可以随时为以太坊贡献内容。&lt;/p>
&lt;p>瑞波币（Ripple）是一个比较另类的区块链项目，因为从本质上来说，它更像是一种支付结算协议，瑞波币不需要挖矿，它是通过一种叫“Open Coin”的算法，提供瑞波协议共识来达到记账的目的。
瑞波币旨在为全球跨境机构提供了高效率的支付过程，提供较好的全球支付体验。因为涉及了机构之间的资产转移，瑞波币被设计成需要准入许可才能进入瑞波的支付网络，这一点有些像我们所说的联盟链。&lt;/p>
&lt;p>匿名性区块链项目是指：使用交易匿名技术，让公开可查询的交易内容变成私密的匿名性区块链项目。市值比较不错的有门罗币、达世币、Zcash 三种，它们分别使用了不同类型的匿名技术，为区块链技术的匿名特性发展做出了贡献。&lt;/p>
&lt;h1 id="共识机制">共识机制&lt;/h1>
&lt;p>共识机制是区块链是核心的组成要素之一，它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等等，是最为关键的技术要素之一。&lt;/p>
&lt;p>共识机制主要解决了两个问题：&lt;/p>
&lt;p>谁有权利；
作弊问题。&lt;/p>
&lt;p>PoW（Proof of Work）工作量证明可以解决上述的两个问题，PoW（Proof of Work）工作量证明可以解决上述的两个问题，这个问题可以简化成谁拥有的计算资源更多，谁就拥有整个系统的最大概率的记账权。一旦这个概率超过一半以上，那么这个系统就有一定的中心化风险。&lt;/p>
&lt;p>而影响记账权的唯一因素只有计算资源（算力）的大小，如果想篡改交易，只能投入大量的计算资源与整个系统中其他所有人进行对抗，这是十分困难的，尤其在整个系统有一定基础计算资源（算力）的情况下。&lt;/p>
&lt;p>PoW 中一个有趣的设计是激励机制，在 PoW 共识机制下，我们假设所有参与者都是理性的，理性的人如果作弊、篡改账本肯定需要投入成本，也就是计算资源，收益是篡改账本获得的收益减去投入成本，这个收益往往小于诚实计算所获得的收益。所以，作弊者在作弊过程中投入的计算资源过大，反而得不偿失。&lt;/p>
&lt;p>双花攻击是指一个代币被花费了两次，这在任意的区块链系统中是不被允许的。如果避免了双花问题，基本就能避免上述作弊中收益过大的问题，因为攻击者首先要窃取到你的私钥，同时又能控制了你的计算资源（算力）。&lt;/p>
&lt;p>规则一：一个代币如果已经被花费，那么会被标记成已花费，如果再次接收到这个代币被花费的请求，那么记账节点会拒绝打包这笔交易；&lt;/p>
&lt;p>规则二：如果同时接收到两个信封，这两个信封中装的两笔交易出现了一个代币被花费了两次的情况，这种情况也就是我们所说的分叉（Fork），那么选择挖矿难度比较大的那个信封。&lt;/p>
&lt;p>简单来说，区块链是一个提供了拜占庭容错、并保证了最终一致性的分布式数据库；从数据结构上看，它是基于时间序列的链式数据块结构，区块链按时间序列化区块数据，整个网络有一个最终确定状态；从节点拓扑上看，它所有的节点互为冗余备份；从操作上看，它提供了基于密码学的公私钥管理体系来管理账户。&lt;/p>
&lt;p>通过以上我们可以发现比特币、以太坊等公链是偏重高可用性、分区容忍性（AP），满足最终一致性（C）且 TPS 较低的分布式系统。
我们在讨论区块链时，通常指的是公有区块链。&lt;/p>
&lt;p>，我们采用什么样的算法（共识机制）才能够为它提供一个可信任的环境，并且使得：&lt;/p>
&lt;p>节点之间的数据交换过程不可篡改，并且已生成的历史记录不可被篡改；
每个节点的数据会同步到最新数据，并且会验证最新数据的有效性；
基于少数服从多数的原则，整体节点维护的数据本身可以客观反映交换历史。&lt;/p>
&lt;p>所谓联盟链，就是这个区块链具有准入许可，不像公链，任何人都可以随时进入。准入许可也就意味着候选节点进入区块链时需要得到已经在网络中的节点许可，所以联盟链也叫做许可链。&lt;/p>
&lt;p>除了公链和联盟链的概念，还有一种区块链概念，叫作侧链。&lt;/p>
&lt;p>侧链是一种双向挂钩技术，将主链中的代币锁定到侧链中使用。所以可以将主链看作主干道，侧链看作与主链相对独立的一条分支道，作为主链功能的低耦合拓展。&lt;/p>
&lt;p>比特币的 P2P 网络基于 TCP 构建，主网默认通信端口为 8333。&lt;/p>
&lt;p>以太坊的 P2P 网络则与比特币不太相同，以太坊 P2P 网络是一个完全加密的网络，提供 UDP 和 TCP 两种连接方式，主网默认 TCP 通信端口是 30303，推荐的 UDP 发现端口为 30301。&lt;/p>
&lt;ol>
&lt;li>P2P 网络协议
P2P 网络协议是所有区块链的最底层模块，负责交易数据的网络传输和广播、节点发现和维护。&lt;/li>
&lt;/ol>
&lt;p>通常我们所用的都是比特币 P2P 网络协议模块，它遵循一定的交互原则。比如：初次连接到其他节点会被要求按照握手协议来确认状态，在握手之后开始请求 Peer 节点的地址数据以及区块数据。&lt;/p>
&lt;p>这套 P2P 交互协议也具有自己的指令集合，指令体现在在消息头（Message Header) 的命令（command）域中，这些命令为上层提供了节点发现、节点获取、区块头获取、区块获取等功能。&lt;/p>
&lt;ol start="2">
&lt;li>分布式一致性算法
在经典分布式计算领域，我们有 Raft 和 Paxos 算法家族代表的非拜占庭容错算法，以及具有拜占庭容错特性的 PBFT 共识算法。&lt;/li>
&lt;/ol>
&lt;p>如果从技术演化的角度来看，我们可以得出一个图，其中，区块链技术把原来的分布式算法进行了经济学上的拓展。&lt;/p>
&lt;p>而在区块链领域，多采用 PoW 工作量证明算法、PoS 权益证明算法，以及 DPoS 代理权益证明算法，以上三种是业界主流的共识算法，这些算法与经典分布式一致性算法不同的是融入了经济学博弈的概念，下面我分别简单介绍这三种共识算法。&lt;/p>
&lt;p>PoW：通常是指在给定的约束下，求解一个特定难度的数学问题，谁解的速度快，谁就能获得记账权（出块）权利。这个求解过程往往会转换成计算问题，所以在比拼速度的情况下，也就变成了谁的计算方法更优，以及谁的设备性能更好。比特币本身的演化很好地诠释了这个问题，中本聪设计的思路本来是由 CPU 计算。随着市场发展，人们发现 GPU 也可以参与其中，而且效率可以达到十倍百倍，现在，这项工作基本以 ASIC 专业挖矿芯片为主。&lt;/p>
&lt;p>PoS：这是一种股权证明机制，它的基本概念是产生区块的难度应该与你在网络里所占的股权（所有权占比）成比例，目前有三个版本 PoS1.0、PoS2.0、PoS3.0。它实现的核心思路是：使用你所锁定代币的币龄（CoinAge）以及一个小的工作量证明，去计算一个目标值，当满足目标值时，你将可能获取记账权。&lt;/p>
&lt;p>DPoS：简单来理解就是将 PoS 共识算法中的记账者转换为指定节点数组成的小圈子，而不是所有人都可以参与记账，这个圈子可能是 21 个节点，也有可能是 101 个节点。这一点取决于设计，只有这个圈子中的节点才能获得记账权。这将极大地提高系统的吞吐量，因为更少的节点也就意味着网络和节点的可控。&lt;/p>
&lt;ol start="3">
&lt;li>加密签名算法&lt;/li>
&lt;/ol>
&lt;p>在区块链领域，哈希算法是应用得最多的算法。哈希算法具有抗碰撞性、原像不可逆、难题友好性等特征。&lt;/p>
&lt;p>当然，除了挖矿算法，我们还会使用到 RIPEMD160 算法，主要用于生成地址，众多的比特币衍生代码中，绝大部分都采用了比特币的地址设计。&lt;/p>
&lt;p>除了地址，我们还会使用到最核心的，也是区块链 Token 系统的基石：公私钥密码算法。&lt;/p>
&lt;p>在比特币大类的代码中，基本上使用的都是 ECDSA。ECDSA 是 ECC 与 DSA 的结合，整个签名过程与 DSA 类似，所不一样的是签名中采取的算法为 ECC（椭圆曲线函数）。&lt;/p>
&lt;ol start="4">
&lt;li>账户与交易模型&lt;/li>
&lt;/ol>
&lt;p>区块链的账本特性，通常分为 UTXO 结构以及基于 Account-Balance 结构的账本结构，我们也称为账本模型。UTXO 是“unspent transaction input/output”的缩写，翻译过来就是指“未花费的交易输入输出”。&lt;/p>
&lt;p>区块链的共识算法，我在某些场合直接称作基于经济学的博弈算法，以区别于经典分布式一致性算法思路，它的整体思路就是让攻击者的攻击成本远远大于收益。&lt;/p>
&lt;p>区块链中的共识算法目前具有工业成熟度的是 PoW，另外两种比较成熟的是 PoS 和 DPoS，其次还有一些变种和单一币种使用的共识算法，例如 Ripple 共识、PoC 共识（概念性证明）、PoE 共识（存在性证明）。&lt;/p>
&lt;p>在使用 PoW 共识算法的情况下，容错阈值是 50%，而 PBFT 及其变种的容错阈值是 33% 左右，这里的百分比是指作弊节点占全网节点的 比例。&lt;/p>
&lt;p>PoX 类的算法其实都延续了 PoW 的设计理念，相比较经典分布式一致性算法，PoX 类算法通过 概率选择记账者降低了潜在的提案者，另外是延长了达成最终一致性的时间。&lt;/p>
&lt;p>第一条降低了系统通信复杂度，每次记账系统的确定性其实是概率确定的，又由于被选中需要付出成本，此处才提高了记账成本阈值，结合区块链的基础代币设计，是一个非常天才的想法。&lt;/p></description></item><item><title>DataVis-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/datavis-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/datavis-cheatsheet/</guid><description>&lt;h1 id="data-visualization-cheatsheet">Data Visualization CheatSheet&lt;/h1>
&lt;p>数据可视化研究的是，如何将数据转化成为交互的图形或图像等，以视觉可以感受的方式表达，增强人的认知能力，达到发现、解释、分析、探索、决策和学习的目的。&lt;/p>
&lt;p>数据库可视化并非仅指图表，而是对于交互、视觉、体验等完整用户链路的延伸，&lt;a href="https://parg.co/6AH" target="_blank" rel="noopener">UI CheatSheet&lt;/a> 是可视化的基础知识。&lt;/p>
&lt;h1 id="canvas">Canvas&lt;/h1>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/cdnight/article/details/48468653" target="_blank" rel="noopener">https://blog.csdn.net/cdnight/article/details/48468653&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docker-Cheatsheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/docker-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/docker-cheatsheet/</guid><description>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/45699770-5d0a0f00-bb9d-11e8-8ce7-82650bfcbb39.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>📖 节选自 &lt;a href="https://parg.co/o9d" target="_blank" rel="noopener">Awesome CheatSheet/Docker CheatSheet&lt;/a>，对来自&lt;a href="https://docs.docker.com/" target="_blank" rel="noopener">官方文档&lt;/a>及 &lt;a href="https://parg.co/o90" target="_blank" rel="noopener">Docker Links&lt;/a> 中链接内容的归档整理，包含了日常工作中常用的 Docker 概念与命令，如果对于 Linux 常用操作尚不熟悉的可以参考 &lt;a href="https://parg.co/oiT" target="_blank" rel="noopener">Linux Commands CheatSheet&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="docker-cheatsheet--docker-配置与实践清单">Docker CheatSheet | Docker 配置与实践清单&lt;/h1>
&lt;p>容器是在操作系统中建立隔离上下文的一种方法。实际上，这意味着它们中的每一个都有一个单独的包含了一组已安装的软件和相关配置的虚拟文件系统。由于它们是相互隔离的，因此任何容器都不能直接访问或影响其他容器或底层宿主操作系统。Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/43813144-f630ba5c-9af6-11e8-8443-175666d4615a.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>虚拟机最大的瓶颈在于其需要特殊硬件虚拟化技术支持，并且携带完整的操作系统；而 Docker 没有硬件虚拟化，可以运行在物理机、虚拟机, 甚至嵌套运行在 Docker 容器内，并且其不携带操作系统的，会轻巧很多。在调用宿主机的内存、CPU、磁盘等等资源时，虚拟机是利用 Hypervisor 去虚拟化内存，整个调用过程是虚拟内存-&amp;gt;虚拟物理内存-&amp;gt;真正物理内存，但是 Docker 是利用 Docker Engine 去调用宿主的的资源，这时候过程是虚拟内存-&amp;gt;真正物理内存。&lt;/p>
&lt;p>Docker 综合运用了 Cgroup, Linux Namespace，Secomp capability, Selinux 等机制，在 &lt;a href="./Docker-Internals-CheatSheet">Docker Internals CheatSheet&lt;/a> 中我们会有详细的讨论，或者前往 &lt;a href="https://github.com/wx-chevalier/Backend-Boilerplate/tree/master/docker" target="_blank" rel="noopener">Backend Boilerplate/docker&lt;/a> 浏览常见服务/应用的 Docker 配置案例。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/44158672-dec2d480-a0e7-11e8-9f50-ce83c9638853.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="安装与配置">安装与配置&lt;/h1>
&lt;h2 id="docker-ce">Docker CE&lt;/h2>
&lt;p>这里我们使用&lt;a href="https://mirrors.ustc.edu.cn/help/docker-ce.html" target="_blank" rel="noopener">科大的 Docker CE 源&lt;/a>进行安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 更改 Ubuntu 默认源地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo sed -i &lt;span class="s1">&amp;#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&amp;#39;&lt;/span> /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装必备的系统命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo apt-get install -y python-software-properties
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg &lt;span class="p">|&lt;/span> sudo apt-key add -
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo add-apt-repository &lt;span class="s2">&amp;#34;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu &lt;/span>&lt;span class="k">$(&lt;/span>lsb_release -cs&lt;span class="k">)&lt;/span>&lt;span class="s2"> stable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo apt-get update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ apt-cache policy docker-ce &lt;span class="c1"># 列举 docker-ce 版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ apt-get install docker-ce&lt;span class="o">=&lt;/span>17.03.2-ce....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="daemon-configuration">Daemon Configuration&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 配置开机自启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl &lt;span class="nb">enable&lt;/span> docker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 取消开机自启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl disable docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还需要修改存储路径，指定镜像存储地址，允许远程访问；此时我们可以修改 systemd 中的配置文件，也可以修改 &lt;code>/etc/docker/daemon.json&lt;/code>，此处以修改服务为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用 systemctl 命令行修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl edit docker.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 或者查找配置地址并使用 Vim 修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ systemctl status docker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 修改文件内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Service&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">ExecStart&lt;/span>&lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">ExecStart&lt;/span>&lt;span class="o">=&lt;/span>/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375 -H unix:///var/run/docker.sock --insecure-registry 10.196.108.176:5000 --dns 114.114.114.114 --dns 8.8.8.8 --dns 8.8.4.4 -g /mnt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后重启服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重新载入服务配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重启 Docker&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo systemctl restart docker.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 判断是否配置成功&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo netstat -lntp &lt;span class="p">|&lt;/span> grep dockerd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-swarm">Docker Swarm&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在主节点启动 Swarm&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker swarm init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看 Swarm 密钥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker swarm join-token -q worker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在主节点启动 Procontainer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在主节点启动 Registry&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -d -p 5000:5000 --restart&lt;span class="o">=&lt;/span>always --name registry registry:2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将子节点加入到 Swarm&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker swarm join &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--token &lt;span class="si">${&lt;/span>&lt;span class="nv">TOKEN&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>10.196.108.176:2377
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常用配置">常用配置&lt;/h2>
&lt;h3 id="代理">代理&lt;/h3>
&lt;p>鉴于 gcr 域名的不可用，我们需要利用 &lt;a href="https://hub.docker.com/r/bluebu/shadowsocks-privoxy/" target="_blank" rel="noopener">ss-privoxy&lt;/a> 等工具搭建 Docker 源代理，也可以参考&lt;a href="https://www.jianshu.com/p/13f4b23824d8" target="_blank" rel="noopener">这里&lt;/a>手动配置客户端：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker run -i -t -e &lt;span class="nv">SERVER_ADDR&lt;/span>&lt;span class="o">=&lt;/span>ss.server.ip -e &lt;span class="nv">SERVER_PORT&lt;/span>&lt;span class="o">=&lt;/span>port -e &lt;span class="nv">PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">123456&lt;/span> bluebu/shadowsocks-privoxy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果需要手动安装，需要先安装 sslocal 命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ apt install python3-pip
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>写入你的配置文件到例如 &lt;code>config.json&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;server&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;...&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;server_port&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="err">...&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;local_port&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1080&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;password&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;method&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;chacha20-ietf-poly1305&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;timeout&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">600&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ sslocal -c config.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时一个 socks5 代理在你本机就启动了。下面安装配置 privoxy 把他转成 http/https 代理。安装略。修改/添加两个 privoxy 的配置(对于 ubuntu, 在 /etc/privoxy/config)：&lt;/p>
&lt;pre tabindex="0">&lt;code>listen-address 0.0.0.0:8118 # 所有 interface 上监听流量
forward-socks5 / 127.0.0.1:1080 . # 流量导向本机上的 ss 代理
&lt;/code>&lt;/pre>&lt;p>这时可以访问一下不存在的网站测试一下：&lt;/p>
&lt;pre tabindex="0">&lt;code>HTTP_PROXY=127.0.0.1:8118 HTTPS_PROXY=127.0.0.1:8118 curl https://www.google.com
&lt;/code>&lt;/pre>&lt;p>下面修改各台机器的 docker 配置(假定我们的 master 内网地址 &lt;code>1.1.1.2&lt;/code>, 其他两台机器地址为 &lt;code>1.1.1.3&lt;/code> 和 &lt;code>1.1.1.4&lt;/code>)：&lt;/p>
&lt;pre tabindex="0">&lt;code>[Environment]
Environment=&amp;#34;HTTP_PROXY=127.0.0.1:8118&amp;#34; &amp;#34;HTTPS_PROXY=127.0.0.1:8118&amp;#34; &amp;#34;NO_PROXY=localhost,127.0.0.1,1.1.1.2,1.1.1.3,1.1.1.4&amp;#34;
...
&lt;/code>&lt;/pre>&lt;p>环境变量 &lt;code>NO_PROXY&lt;/code> 顾名思义，它不支持 CIDR 应该，所以需要你枚举一下集群主机地址。&lt;/p>
&lt;h3 id="存储与日志">存储与日志&lt;/h3>
&lt;p>线上系统中我们往往也需要对于 Docker 产生的&lt;/p>
&lt;h1 id="镜像">镜像&lt;/h1>
&lt;p>镜像描述了 Docker 容器运行的初始文件系统, 包含运行应用所需的所有依赖。即可以是一个完整的操作系统, 也可以仅包含应用所需的最小 bin/lib 文件集合。Docker 镜像和容器采用分层文件系统结构, 每个容器包含一层薄薄的可写层, 只读部分是共享的，这种机制保证了资源的可复用性，减少了镜像与容器的空间占用。Docker 镜像存储引擎有 aufs, devicemapper, overlay 等多种实现。&lt;/p>
&lt;h2 id="构建与拉取">构建与拉取&lt;/h2>
&lt;p>编写完成 Dockerfile 之后，可以通过 &lt;code>docker build&lt;/code> 命令来创建镜像；关于 Dockfile 的具体语法，可以查看下文。Dockfile 基本的格式为 &lt;code>docker build [ 选项 ] 路径&lt;/code>，该命令将读取指定路径下(包括子目录)的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 &lt;code>.dockerignore&lt;/code> 文件(每一行添加一条匹配模式)来让 Docker 忽略路径下的目录和文件。&lt;/p>
&lt;p>镜像的完整 tag 不仅包含镜像名字, 还指明了镜像从哪里来, 要到哪里去, 就像一个 URL。可以通过 &lt;code>-t&lt;/code> 选项指定镜像的标签信息，譬如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ sudo docker build -t myrepo/myapp /tmp/test1/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker build -t username/image_name:tag_name .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker tag SOURCE_IMAGE&lt;span class="o">[&lt;/span>:TAG&lt;span class="o">]&lt;/span> TARGET_IMAGE&lt;span class="o">[&lt;/span>:TAG&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Docker 支持从 Registry 拉取镜像，或者将某个容器保存为镜像：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 拉取镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker pull image_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将某个容器保存为镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker commit -m “commit message” -a “author” container_name username/image_name:tag
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Docker 支持将镜像保存为文件，以方便镜像的导出与加载：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 保存镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker save --output saved-image.tar my-image:1.0.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker save my-image:1.0.0 &amp;gt; saved-image.tar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker save my_image:my_tag &lt;span class="p">|&lt;/span> gzip &amp;gt; my_image.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导入镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker load --input saved-image.tar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker load &amp;lt; saved-image.tar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="镜像管理">镜像管理&lt;/h2>
&lt;p>&lt;code>docker images&lt;/code> 命令会列举出全部的镜像:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
mynewimage latest 4d2eab1c0b9a 5 minutes ago 278.1 MB
ubuntu 14.04 ad892dd21d60 11 days ago 275.5 MB
&amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 6b0a59aa7c48 11 days ago 169.4 MB
&amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 6cfa4d1f33fb 7 weeks ago 0 B
&lt;/code>&lt;/pre>&lt;p>Docker 中镜像主要分为三种状态:&lt;/p>
&lt;ul>
&lt;li>已使用镜像(used image): 指所有已被容器（包括已停止的）关联的镜像。即 docker ps -a 看到的所有容器使用的镜像。&lt;/li>
&lt;li>未引用镜像(unreferenced image): 没有被分配或使用在容器中的镜像，但它有 Tag 信息。&lt;/li>
&lt;li>悬空镜像(dangling image): 未配置任何 Tag（也就无法被引用）的镜像，所以悬空。这通常是由于镜像 build 的时候没有指定 -t 参数配置 Tag 导致的。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列举未使用的&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker images --filter &lt;span class="s2">&amp;#34;dangling=true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除所有无用的镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rmi &lt;span class="k">$(&lt;/span>docker images -q -f &lt;span class="nv">dangling&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="dockfile">Dockfile&lt;/h2>
&lt;p>Dockerfile 由一行行命令语句组成，并且支持以 &lt;code>#&lt;/code> 开头的注释行。一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令；指令的一般格式为 &lt;code>INSTRUCTION arguments&lt;/code>，指令包括 &lt;code>FROM&lt;/code>、&lt;code>MAINTAINER&lt;/code>、&lt;code>RUN&lt;/code> 等。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># MongoDB Dockerfile&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># https://github.com/dockerfile/mongodb&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Pull base image.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM dockerfile/ubuntu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ENV SOURCE http://downloads-distro.mongodb.org/repo/ubuntu-upstart
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Install MongoDB.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;deb $SOURCE dist 10gen&amp;#39;&lt;/span> &amp;gt; /etc/apt/sources.list.d/mongodb.list &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> apt-get install -y mongodb-org &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> rm -rf /var/lib/apt/lists/*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ENV PATH /usr/local/mongo/bin:&lt;span class="nv">$PATH&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Define mountable directories.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">VOLUME &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;/data/db&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Define working directory.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WORKDIR /data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Define default command.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CMD &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;mongod&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Expose ports.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># - 27017: process&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># - 28017: http&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">EXPOSE &lt;span class="m">27017&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">EXPOSE &lt;span class="m">28017&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。后面则是镜像操作指令，例如 &lt;code>RUN&lt;/code> 指令，&lt;code>RUN&lt;/code> 指令将对镜像执行跟随的命令。每运行一条 &lt;code>RUN&lt;/code> 指令，镜像添加新的一层，并提交。最后是 &lt;code>CMD&lt;/code> 指令，来指定运行容器时的操作命令。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>指令名&lt;/th>
&lt;th>格式&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>FROM&lt;/td>
&lt;td>格式为 &lt;code>FROM &amp;lt;image&amp;gt;&lt;/code>或&lt;code>FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;&lt;/code>&lt;/td>
&lt;td>第一条指令必须为 &lt;code>FROM&lt;/code> 指令&lt;/td>
&lt;td>如果在同一个 Dockerfile 中创建多个镜像时，可以使用多个 &lt;code>FROM&lt;/code> 指令(每个镜像一次)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MAINTAINER&lt;/td>
&lt;td>格式为 &lt;code>MAINTAINER &amp;lt;name&amp;gt;&lt;/code>&lt;/td>
&lt;td>指定维护者信息，&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RUN&lt;/td>
&lt;td>&lt;code>RUN &amp;lt;command&amp;gt;&lt;/code>或&lt;code>RUN [&amp;quot;executable&amp;quot;, &amp;quot;param1&amp;quot;, &amp;quot;param2&amp;quot;]&lt;/code>&lt;/td>
&lt;td>前者将在 shell 终端中运行命令，即 &lt;code>/bin/sh -c&lt;/code>；后者则使用 &lt;code>exec&lt;/code> 执行。指定使用其它终端可以通过第二种方式实现，例如 &lt;code>RUN [&amp;quot;/bin/bash&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo hello&amp;quot;]&lt;/code>&lt;/td>
&lt;td>每条 &lt;code>RUN&lt;/code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 &lt;code>\&lt;/code> 来换行，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CMD&lt;/td>
&lt;td>支持三种格式,&lt;code>CMD [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]&lt;/code> 使用 &lt;code>exec&lt;/code> 执行，推荐方式；&lt;code>CMD command param1 param2&lt;/code> 在 &lt;code>/bin/sh&lt;/code> 中执行，提供给需要交互的应用；&lt;code>CMD [&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]&lt;/code> 提供给 &lt;code>ENTRYPOINT&lt;/code> 的默认参数；&lt;/td>
&lt;td>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 &lt;code>CMD&lt;/code> 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 &lt;code>CMD&lt;/code> 指定的命令&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EXPOSE&lt;/td>
&lt;td>&lt;code>EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;...]&lt;/code>&lt;/td>
&lt;td>告诉 Docker 服务端容器暴露的端口号，供互联系统使用&lt;/td>
&lt;td>在启动容器时需要通过 -p 来指定端口映射，Docker 主机会自动分配一个端口转发到指定的端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ENV&lt;/td>
&lt;td>&lt;code>ENV&amp;lt;key&amp;gt;&amp;lt;value&amp;gt;&lt;/code>。指定一个环境变量，会被后续 &lt;code>RUN&lt;/code> 指令使用，并在容器运行时保持&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ADD&lt;/td>
&lt;td>&lt;code>ADD&amp;lt;src&amp;gt;&amp;lt;dest&amp;gt;&lt;/code>&lt;/td>
&lt;td>该命令将复制指定的 &lt;code>&amp;lt;src&amp;gt;&lt;/code> 到容器中的 &lt;code>&amp;lt;dest&amp;gt;&lt;/code>，&lt;/td>
&lt;td>&lt;code>&amp;lt;src&amp;gt;&lt;/code> 可以是 Dockerfile 所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件(自动解压为目录)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>COPY&lt;/td>
&lt;td>&lt;code>COPY &amp;lt;src&amp;gt;&amp;lt;dest&amp;gt;&lt;/code>&lt;/td>
&lt;td>复制本地主机的 &lt;code>&amp;lt;src&amp;gt;&lt;/code>(为 Dockerfile 所在目录的相对路径)到容器中的 &lt;code>dest&lt;/code>&lt;/td>
&lt;td>当使用本地目录为源目录时，推荐使用 &lt;code>COPY&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ENTRYPOINT&lt;/td>
&lt;td>&lt;code>ENTRYPOINT [&amp;quot;executable&amp;quot;, &amp;quot;param1&amp;quot;, &amp;quot;param2&amp;quot;]&lt;/code>，使用指定可执行文件执行；&lt;code>ENTRYPOINT command param1 param2&lt;/code>，会在 Shell 中执行&lt;/td>
&lt;td>配置容器启动后执行的命令，并且不可被 &lt;code>docker run&lt;/code> 提供的参数覆盖。每个 Dockerfile 中只能有一个 &lt;code>ENTRYPOINT&lt;/code>，当指定多个时，只有最后一个起效，&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VOLUME&lt;/td>
&lt;td>&lt;code>VOLUME [&amp;quot;/data&amp;quot;]&lt;/code>&lt;/td>
&lt;td>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>USER&lt;/td>
&lt;td>&lt;code>USER daemon&lt;/code>&lt;/td>
&lt;td>指定运行容器时的用户名或 UID，后续的 &lt;code>RUN&lt;/code> 也会使用指定用户&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>WORKDIR&lt;/td>
&lt;td>&lt;code>WORKDIR /path/to/workdir&lt;/code>&lt;/td>
&lt;td>为后续的 &lt;code>RUN&lt;/code>、&lt;code>CMD&lt;/code>、&lt;code>ENTRYPOINT&lt;/code> 指令配置工作目录&lt;/td>
&lt;td>可以使用多个 &lt;code>WORKDIR&lt;/code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：&lt;code>RUN groupadd -r postgres &amp;amp;&amp;amp; useradd -r -g postgres postgres&lt;/code>；要临时获取管理员权限可以使用 &lt;code>gosu&lt;/code>，而不推荐 &lt;code>sudo&lt;/code>。&lt;/p>
&lt;p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。ENTRYPOINT 配置容器启动时运行的命令。我们经常可以使用 ENTRYPOINT 指定固定命令，使用 CMD 动态传入参数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ENTRYPOINT&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/bin/echo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;world&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># docker run -it &amp;lt;image&amp;gt;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># Hello world&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># docker run -it &amp;lt;image&amp;gt; John&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># Hello John&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Docker 推荐的是单个容器执行单个任务的关注点分离策略，容器的主进程会负责管理所有的子进程。如果我们未在自定义初始化脚本中考虑太多子进程生命周期管理的操作，那么可以使用 &lt;code>--init&lt;/code> 参数来允许 Docker 自动注入 init 进程作为主进程，其会在容器关闭时候自动处理所有的派生的子进程，并且相对于完整的 sysvinit 或者 systemd 更为轻量级。如果我们希望在单个容器中运行多个进程，则可以使用 supervisord 或者&lt;a href="https://docs.docker.com/config/containers/multi-service_container/" target="_blank" rel="noopener">自定义脚本&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> ubuntu:latest&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt-get install -y supervisor&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> mkdir -p /var/log/supervisor&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> supervisord.conf /etc/supervisor/conf.d/supervisord.conf&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> my_first_process my_first_process&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> my_second_process my_second_process&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/usr/bin/supervisord&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="registry">Registry&lt;/h2>
&lt;p>Docker 允许我们建立私有的 Registry 来存放于管理镜像，直接运行如下命令即可创建私有 Registry：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker run -d -p 5000:5000 --restart&lt;span class="o">=&lt;/span>always --name registry registry:2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参考上文描述我们可知，镜像名的前缀即表示该镜像所属的 Registry 地址，因此我们可以通过 tag 方式将某个镜像推送到私有仓库：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 拉取公共镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker pull ubuntu:16.04
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 为镜像添加 Registry 信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker tag ubuntu:16.04 custom-domain:5000/my-ubuntu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将其推送到私有镜像库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker push custom-domain:5000/my-ubuntu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 从私有镜像库中拉取镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker pull custom-domain:5000/my-ubuntu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以指定镜像库的存放地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">-v /mnt/registry:/var/lib/registry
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很多情况下我们的内部仓库并不会配置 HTTPS，如果希望以 HTTP 方式访问，那么需要在任何需要推送/拉取镜像的机器上配置非安全域名：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span> &lt;span class="nt">&amp;#34;insecure-registries&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;myregistry.example.com:5000&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有时候我们也需要为私有仓库配置权限认证，那么首先需要添加 TLS 支持，并且配置认证文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ mkdir auth
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --entrypoint htpasswd &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> registry:2 -Bbn cscan cscancscan &amp;gt; ~/auth/htpasswd
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ openssl req -new -newkey rsa:4096 -days &lt;span class="m">365&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -subj &lt;span class="s2">&amp;#34;/CN=localhost&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -nodes -x509 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -keyout ~/certs/domain.key &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -out ~/certs/domain.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后可以使用 Compose 文件来描述所需要的 TLS 以及 AUTH 参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">registry-srv&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">restart&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">always&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">registry:2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">5000&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">5000&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">REGISTRY_HTTP_TLS_CERTIFICATE&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/certs/domain.crt&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">REGISTRY_HTTP_TLS_KEY&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/certs/domain.key&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">REGISTRY_AUTH&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">htpasswd&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">REGISTRY_AUTH_HTPASSWD_PATH&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/auth/htpasswd&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">REGISTRY_AUTH_HTPASSWD_REALM&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Registry Realm&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">/opt/registry:/var/lib/registry&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">~/certs:/certs&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">~/auth:/auth&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来使用 Docker Compose 命令启动服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker-compose up -d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 登录到镜像服务器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker login myregistrydomain.com:5000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="多阶段构建">多阶段构建&lt;/h2>
&lt;p>随着 17.05 版本的发布，Docker 对于镜像构建这块也作了一项重要更新，那就是 multi-stage build（多阶段构建），这有助于方便源代码控制，减小镜像体积。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># First stage: complete build environment&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> maven:3.5.0-jdk-8-alpine AS builder&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># add pom.xml and source code&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> ./pom.xml pom.xml&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> ./src src/&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># package jar&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> mvn clean package&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># Second stage: minimal runtime environment&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">From&lt;/span>&lt;span class="s"> openjdk:8-jre-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># copy jar from the first stage&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>builder target/msb-1.0.jar msb.jar&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># run jar&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;java&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;-jar&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;msb.jar&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 multi-stage build，其关键点主要有两点：&lt;/p>
&lt;p>在前面阶段的 FROM 指令后面增加了一个 AS 参数，可为该构建阶段命名，便于后续构建阶段引用，格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>FROM image[:tag | @digest] AS stage
&lt;/code>&lt;/pre>&lt;p>在后续阶段的 COPY 指令后面增加了&amp;ndash;from 参数，指明引用前面哪一个构建阶段的成果，格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>COPY --from=stage ...
&lt;/code>&lt;/pre>&lt;p>同理，多阶段构建同样可以很方便地将多个彼此依赖的项目通过一个 Dockerfile 就可轻松构建出期望的容器镜像，而不用担心镜像太大、源码泄露等风险。&lt;/p>
&lt;h1 id="容器">容器&lt;/h1>
&lt;p>Docker 中镜像是只读的, 创建容器时只是在镜像上面新建一个可写层, 不需要复制整个文件系统, 因而可以实现毫秒级创建。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/45262735-4f42e400-b44f-11e8-96a0-79c305006be8.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="启停控制">启停控制&lt;/h2>
&lt;ul>
&lt;li>&lt;code>docker create&lt;/code>: 创建一个容器但是不启动。&lt;/li>
&lt;li>&lt;code>docker rename&lt;/code>: 允许重命名容器。&lt;/li>
&lt;li>&lt;code>docker run&lt;/code>: 在同一个操作中创建并启动一个容器。&lt;/li>
&lt;li>&lt;code>docker rm&lt;/code>: 删除容器。&lt;/li>
&lt;li>&lt;code>docker update&lt;/code>: 更新容器的资源限制。&lt;/li>
&lt;/ul>
&lt;p>容器会在结束命令之后自动退出，使用以下的命令选项可以将容器保持在激活状态：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>-i&lt;/code> 即使在没有附着的情况下依然保持 STDIN 处于开启。单纯使用 -i 命令是不会出现 &lt;code>root@689d580b6416:/&lt;/code> 这种前缀&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-t&lt;/code> 分配一个伪 TTY 控制台&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建，并且启动某个容器以执行某个命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -ti --name container_name image_name &lt;span class="nb">command&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建，启动容器执行某个命令然后删除该容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --rm -ti image_name &lt;span class="nb">command&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建，启动容器，并且映射卷与端口，同时设置环境变量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --rm -p 8080:8080 -v /path/to/agent.jar:/agent.jar -e &lt;span class="nv">JAVA_OPTS&lt;/span>&lt;span class="o">=&lt;/span>”-javaagent:/agent.jar” tomcat:8.0.29-jre8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建容器，指定网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --network&lt;span class="o">=&lt;/span>&amp;lt;NETWORK&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 直接使用宿主机的网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --rm -d --network host --name my_nginx nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 指定标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -l my-label --label com.example.foo&lt;span class="o">=&lt;/span>bar ubuntu bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下，创建容器时，它不会将其任何端口发布到外部世界。要使端口可用于 Docker 之外的服务或未连接到容器网络的 Docker 容器，请使用 &amp;ndash;publish 或-p 标志。这会创建一个防火墙规则，将容器端口映射到 Docker 主机上的端口。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标志值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>-p 8080:80&lt;/code>&lt;/td>
&lt;td>将容器的 80 端口映射到 Docker 主机的 8080 端口(TCP)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>-p 8080:80/udp&lt;/code>&lt;/td>
&lt;td>将容器的 80 端口映射到 Docker 主机的 8080 端口(UDP)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>-p 8080:80/tcp -p 8080:80/udp&lt;/code>&lt;/td>
&lt;td>将容器的 80 端口映射到 Docker 主机的 8080 端口(TCP 和 UDP)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动/停止某个容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker &lt;span class="o">[&lt;/span>start&lt;span class="p">|&lt;/span>stop&lt;span class="o">]&lt;/span> container_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在某个容器内执行某条命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker &lt;span class="nb">exec&lt;/span> -ti container_name command.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看某个容器的输出日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker logs -ft container_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="状态查询">状态查询&lt;/h2>
&lt;ul>
&lt;li>docker ps 查看运行中的所有容器。&lt;/li>
&lt;li>docker logs 从容器中获取日志。(你也可以使用自定义日志驱动，不过在 1.10 中，它只支持 json-file 和 journald)&lt;/li>
&lt;li>docker inspect 查看某个容器的所有信息(包括 IP 地址)。&lt;/li>
&lt;li>docker events 从容器中获取事件(events)。&lt;/li>
&lt;li>docker port 查看容器的公开端口。&lt;/li>
&lt;li>docker top 查看容器中活动进程。&lt;/li>
&lt;li>docker stats 查看容器的资源使用情况统计信息。&lt;/li>
&lt;li>docker diff 查看容器的 FS 中有变化文件信息。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据条件过滤查询&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker ps --filter &lt;span class="s2">&amp;#34;name=nostalgic&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示正在运行的容器列表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker stats --all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 批量查看日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> i in &lt;span class="k">$(&lt;/span>docker ps -qf &lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>wsat_slave*&lt;span class="k">)&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;==================&lt;/span>&lt;span class="nv">$i&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> docker logs &lt;span class="nv">$i&lt;/span> &lt;span class="p">|&lt;/span> grep aisec&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="管理配置">管理配置&lt;/h2>
&lt;p>创建容器时也可以容器的重启策略，即是当容器出错退出或者宿主机重启时候，容器的应对策略；重启策略同样会保证相关联的容器以正确的顺序重启，避免意外的错误。&lt;/p>
&lt;ul>
&lt;li>no: 不进行重启&lt;/li>
&lt;li>on-failure: 当容器以非零状态码退出时重启容器&lt;/li>
&lt;li>unless-stopped: 当某个容器被显性关闭或者 Docker 本身关闭或重启时重启&lt;/li>
&lt;li>always: 无论出现任何情况都重启容器&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置重启策略&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Off, On-failure, Unless-stopped, Always&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -dit — restart unless-stopped &lt;span class="o">[&lt;/span>CONTAINER&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以通过多种过滤条件来进行容器的移除：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 关闭所有正在运行的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker &lt;span class="nb">kill&lt;/span> &lt;span class="k">$(&lt;/span>docker ps -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 批量重启容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker restart &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据 ID或Name 移除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm idOrName
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 移除所有停止的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据状态移除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -q -f &lt;span class="s1">&amp;#39;status=exited&amp;#39;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据标签移除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -a &lt;span class="p">|&lt;/span> grep rabbitmq &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{print $1}&amp;#39;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -a &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;46 hours ago&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以对容器中的文件进行导入导出操作:&lt;/p>
&lt;ul>
&lt;li>docker cp 在容器和本地文件系统之间复制文件或文件夹。&lt;/li>
&lt;li>docker export 将容器的文件系统切换为压缩包(tarball archive stream)输出到 STDOUT。&lt;/li>
&lt;/ul>
&lt;h2 id="资源配额">资源配额&lt;/h2>
&lt;p>我们可以使用 &lt;code>docker stats&lt;/code> 命令来查看 Docker 容器的性能状态与资源占用:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker stats redis1 redis2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CONTAINER CPU % MEM USAGE / LIMIT MEM % NET IO BLOCK IO
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis1 0.07% &lt;span class="m">796&lt;/span> KB / &lt;span class="m">64&lt;/span> MB 1.21% &lt;span class="m">788&lt;/span> B / &lt;span class="m">648&lt;/span> B 3.568 MB / &lt;span class="m">512&lt;/span> KB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="memory">Memory&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker run -it -m 300M ubuntu:14.04 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cpu">CPU&lt;/h3>
&lt;p>在线上环境中，我们即希望能够尽量避免 CPU 空间时间片，最大化资源利用率，也要保障重点业务的资源占用，避免因某个异常容器占用或不合理使用整机 CPU 资源，造成宿主机上大量容器异常；此时单容器的 CPU 资源约束及上限将变得非常重要，既不能限得太死，又不能限不住，将通过内核和调度系统的限制机制来保障资源稳定性。Docker 允许使用 cpus, cpuset-cpus, cpu-shares 等来限制容器的计算资源占用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 指定容器可占用的 CPU 核编号，0-3 表示占用四个核，1,3 表示占用两个核&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --cpuset-cpus&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1,3&amp;#34;&lt;/span> ubuntu /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 最多允许占用单 CPU 50% 的计算资源，如果双核 CPU，则可以设置为 1.5 等&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --cpus&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;.5&amp;#34;&lt;/span> ubuntu /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 不同的值能够指定不同的容器权重，用于动态分配 CPU 资源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --cpu-shares&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;512&amp;#34;&lt;/span> ubuntu /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>CPU Set 保障了容器的 CPU 核数，安全性较强，但是整体资源利用率低。如果容器实际并不需要如此多核的 CPU 资源来处理任务则会造成资源浪费，并且导致其他容器上的任务无法利用该容器上的 CPU 空闲时间片，人为阻断了 CPU 闲时复用的能力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU Share 允许通过共享的方式获得 CPU 资源，不同的容器共享一定总量的 CPU 计算能力，每个容器都绑定全量核，而每个容器获取一定份额的 CPU 计算力。该模式下，每个容器的 CPU 资源分配不再以整核分配，而是可精细到 CPU 时间片份额的粒度，并且是连续的 CPU 核能力值。当整机闲时，可以让较为繁忙的业务获得整机空闲。采用 CPU 资源共享的机制，其资源隔离性没有 set 模式强，对于极个别 CPU 资源敏感型业务，有可能出现偶尔等待 CPU 时间片的情况，而影响业务稳定性。对于极少数的这类业务，我们容许继续使用 CPU set 模式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="storage">Storage&lt;/h3>
&lt;p>如果使用 Device Mapper 作为底层存储驱动，则可以通过 Docker daemon 的如下参数来全局限制单个容器占用空间的大小:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 限制单个容器最多占用 20G 空间，将应用于任何新建容器。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ --storage-opt dm.basesize&lt;span class="o">=&lt;/span>20G
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是 btrfs 存储驱动，可使用其提供的 subvolume 功能来实现。一个容器会对应一个 subvolume。针对容器对应的 subvolume 启用并配置 quota 即可限制其磁盘空间:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ btrfs qgroup limit -e 50G /var/lib/docker/btrfs/subvolumes/&amp;lt;CONTAINER_ID&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>授予对单个设备访问权限:&lt;/p>
&lt;pre tabindex="0">&lt;code>docker run -it --device=/dev/ttyUSB0 debian bash
&lt;/code>&lt;/pre>&lt;p>授予所有设备访问权限:&lt;/p>
&lt;pre tabindex="0">&lt;code>docker run -it --privileged -v /dev/bus/usb:/dev/bus/usb debian bash
&lt;/code>&lt;/pre>&lt;h1 id="资源配置">资源配置&lt;/h1>
&lt;h2 id="volume--数据卷">Volume | 数据卷&lt;/h2>
&lt;p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(Volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。&lt;/p>
&lt;p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数据卷可以在容器之间共享和重用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对数据卷的修改会立马生效&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对数据卷的更新，不会影响镜像&lt;/p>
&lt;/li>
&lt;li>
&lt;p>卷会一直存在，直到没有容器使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据卷的使用，类似于 Linux 下对目录或文件进行 mount。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>For example,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># the following creates a tmpfs volume called foo with a size of 100 megabyte and uid of 1000.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker volume create --driver &lt;span class="nb">local&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --opt &lt;span class="nv">type&lt;/span>&lt;span class="o">=&lt;/span>tmpfs &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --opt &lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>tmpfs &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --opt &lt;span class="nv">o&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">size&lt;/span>&lt;span class="o">=&lt;/span>100m,uid&lt;span class="o">=&lt;/span>&lt;span class="m">1000&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> foo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>nother example that uses nfs to mount the /path/to/dir in rw mode from 192.168.1.1:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker volume create --driver &lt;span class="nb">local&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --opt &lt;span class="nv">type&lt;/span>&lt;span class="o">=&lt;/span>nfs &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --opt &lt;span class="nv">o&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nv">addr&lt;/span>&lt;span class="o">=&lt;/span>192.168.1.1,rw &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --opt &lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>:/path/to/dir &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> foo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker run -d &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -it &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --name devtest &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v myvol2:/app &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> nginx:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;Mounts&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;volume&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;myvol2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Source&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/var/lib/docker/volumes/myvol2/_data&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Destination&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/app&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Driver&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;local&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Mode&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;RW&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;Propagation&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">]&lt;/span>&lt;span class="err">,&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Docker &lt;code>-v&lt;/code> 标记也可以指定挂载一个本地主机的目录 / 文件到容器中去：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Docker 挂载数据卷的默认权限是读写，用户也可以通过 `:ro` 指定为只读。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">training/webapp python app.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">VOLUME /data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="network--网络">Network | 网络&lt;/h2>
&lt;p>Linux 在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；Docker 利用这一特性，实现不容器间的网络隔离，并且引入 Veth 设备对来实现在不同网络命名空间的通信。Linux 系统包含一个完整的路由功能，当 IP 层在处理数据发送或转发的时候，会使用路由表来决定发往哪里。Netfilter 负责在内核中执行各种挂接的规则(过滤、修改、丢弃等)，运行在内核模式中；Iptables 模式是在用户模式下运行的进程，负责协助维护内核中 Netfilter 的各种规则表；通过二者的配合来实现整个 Linux 网络协议栈中灵活的数据包处理机制。Docker 的网络子系统采用了基于驱动的可插拔机制，其默认包含了如下驱动模式：&lt;/p>
&lt;ul>
&lt;li>&lt;code>bridge&lt;/code>: 默认的网络驱动，常用于多个应用运行与独立容器中并且需要相互通讯的时候。&lt;/li>
&lt;li>&lt;code>host&lt;/code>: 移除容器与 Docker 主机之间的网络隔离，直接使用宿主机所在的网络。底层与宿主机共用一个 Network Namespace，容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。&lt;/li>
&lt;li>&lt;code>overlay&lt;/code>: Overlay 网络用语连接多个 Docker Daemon，保证 Docker Swarm 服务的正常运行；独立的容器与 Swarm 服务，或者不同宿主机上的容器同样能够通过 Overlay 进行通信。&lt;/li>
&lt;li>&lt;code>none&lt;/code>: 对于指定容器禁止所有的网络通信。&lt;/li>
&lt;li>&lt;code>macvlan&lt;/code>: Macvlan 网络会允许直接为容器分配 MAC 地址，使其作为真正的物理设备接入到宿主机所在的网络中。&lt;/li>
&lt;/ul>
&lt;p>我们使用 network 命令可以查看到默认的网络：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker network ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NETWORK ID NAME DRIVER SCOPE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">f707aa0ef50d bridge bridge &lt;span class="nb">local&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">97dd7a032d96 host host &lt;span class="nb">local&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">d5a1bed0b12d none null &lt;span class="nb">local&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>桥接模式下，当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，即软件交换机，在挂载到它的网口之间进行转发。同时，Docker 随机分配一个本地未占用的私有网段(在 RFC1918 中定义)中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。&lt;/p>
&lt;p>桥接模式下，创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口(当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包)。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头(例如 vethAQI2QT)。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建新的网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker network create --driver bridge isolated
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 指定网段，宿主机会作为默认网关&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker network create --driver&lt;span class="o">=&lt;/span>bridge --subnet&lt;span class="o">=&lt;/span>192.168.2.0/24 --gateway&lt;span class="o">=&lt;/span>192.168.2.10 new_subnet
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建时将某个容器连接到网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --network&lt;span class="o">=&lt;/span>isolated -itd --name&lt;span class="o">=&lt;/span>docker-nginx nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将某个运行中容器连接到某个网络，在该网络内可以通过容器名自由访问&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker network connect multi-host-network container1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dns">DNS&lt;/h3>
&lt;p>默认情况下，容器从 Docker 守护进程继承 DNS 设置，包括 /etc/hosts 和 /etc/resolv.conf。可以基于每个容器覆盖这些设置。&lt;/p>
&lt;ul>
&lt;li>-h HOSTNAME or &amp;ndash;hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker ps 中显示，也不会在其他的容器的 /etc/hosts 看到。&lt;/li>
&lt;li>&amp;ndash;link=CONTAINER_NAME:ALIAS 选项会在创建容器的时候，添加一个其他容器的主机名到 /etc/hosts 文件中，让新容器的进程可以使用主机名 ALIAS 就可以连接它。&lt;/li>
&lt;li>&amp;ndash;dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。&lt;/li>
&lt;li>&amp;ndash;dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS 不仅搜索 host，还会搜索 host.example.com。注意：如果没有上述最后 2 个选项，Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。&lt;/li>
&lt;/ul>
&lt;h2 id="空间清理">空间清理&lt;/h2>
&lt;p>Docker 使用过程中，可能会发现宿主节点的磁盘容量持续增长，譬如 volume 或者 overlay2 目录占用了大量的空间；如果任其发展，可能将磁盘空间耗尽进而引发宿主机异常，进而对业务造成影响。Docker 的内置 df 指令可用于查询镜像(Images)、容器(Containers)和本地卷(Local Volumes)等空间使用大户的空间占用情况。而容器的占用的总空间，包含其最顶层的读写层(writable layer)和底部的只读镜像层(base image layer，read-only)，我们可以使用 &lt;code>ps -s&lt;/code> 参数来显示二者的空间占用情况:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看当前目录下的文件空间占用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ du -h --max-depth&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="p">|&lt;/span> sort
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 空间占用总体分析&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker system df
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 输出空间占用细节&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker system df -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 输出容器的空间占用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker ps -s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>docker system prune&lt;/code> 指令能够进行自动地空间清理，其默认会清除已停止的容器、未被任何容器所使用的卷、未被任何容器所关联的网络、所有悬空镜像:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 一并清除所有未使用的镜像和悬空镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker system prune --all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列举悬空镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker images -f &lt;span class="nv">dangling&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除全部悬空镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker image prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除所有未被使用的镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker image prune -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除指定模式的镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker images -a &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;pattern&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{print $3}&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> xargs docker rmi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除全部镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rmi &lt;span class="k">$(&lt;/span>docker images -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除全部停止的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -a -f &lt;span class="nv">status&lt;/span>&lt;span class="o">=&lt;/span>exited -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据指定模式删除容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -a -f &lt;span class="nv">status&lt;/span>&lt;span class="o">=&lt;/span>exited -f &lt;span class="nv">status&lt;/span>&lt;span class="o">=&lt;/span>created -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -a &lt;span class="p">|&lt;/span> grep rabbitmq &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;{print $1}&amp;#39;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除全部容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker stop &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker rm &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列举并删除未被使用的卷&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker volume ls -f &lt;span class="nv">dangling&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker volume prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据指定的模式删除卷&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker volume prune --filter &lt;span class="s2">&amp;#34;label!=keep&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除未被关联的网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker network prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker network prune --filter &lt;span class="s2">&amp;#34;until=24h&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以手动指定日志文件的尺寸或者清空日志文件:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置日志文件最大尺寸&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ dockerd ... --log-opt max-size&lt;span class="o">=&lt;/span>10m --log-opt max-file&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空当前日志文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">truncate -s &lt;span class="m">0&lt;/span> /var/lib/docker/containers/*/*-json.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="服务治理">服务治理&lt;/h1>
&lt;h2 id="docker-compose">Docker Compose&lt;/h2>
&lt;p>Docker Compose 是用于定义和运行复杂 Docker 应用的工具。你可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成；简单的 Compose 文件定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 指定 Docker Compose 文件版本&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">web&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 指定从本地目录进行编译&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 指定导出端口&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;5000:5000&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 替换默认的 CMD 命令&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">python app.py&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 将本地目录绑定到容器内目录&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">.:/code&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">redis&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 镜像的 ID&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;redis:alpine&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里用到的 Python Web 应用的 Dockerfile 如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.4-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> . /code&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /code&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install -r requirements.txt&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;app.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>值得注意的是，我们在代码中直接使用服务名作为连接地址，即可访问到 Redis 数据库：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-py" data-lang="py">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cache&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">redis&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Redis&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;redis&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">port&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">6379&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后使用 docker-compose 命令启动：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 交互式启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker-compose up
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 守护进程式启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker-compose up -d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看运行情况&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker-compose ps
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker-compose stop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 移除内部卷&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker-compose down --volumes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在涉及到数据存储的场景下，我们同样可以指定 docker-compose 创建命名数据卷，并将其挂载到容器中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3.2&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">web&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">volume&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">source&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mydata&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">target&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volume&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">nocopy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bind&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">source&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./static&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">target&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/opt/app/static&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">db&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">postgres:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;dbdata:/var/lib/postgresql/data&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">mydata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">dbdata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果某个数据卷天然需要映射到本地文件，则可以指定 driver 的类型为 local:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">wsat_etc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">driver&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">local&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">driver_opts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">o&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bind&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">none&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">device&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/etc/wsat/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-swarm-1">Docker Swarm&lt;/h2>
&lt;p>Swarm 是 Docker 公司在 2014 年 12 月初发布的一套较为简单的工具，用来管理 Docker 集群，它将一群 Docker 宿主机变成一个单一的，虚拟的主机。Swarm 使用标准的 Docker API 接口作为其前端访问入口，换言之，各种形式的 Docker Client(dockerclient in go, docker_py, docker 等)均可以直接与 Swarm 通信。&lt;/p>
&lt;p>Swarm Deamon 只是一个调度器(Scheduler)和路由器(Router)，Swarm 自己不运行容器，它只是接受 Docker 客户端发送过来的请求，调度适合的节点来运行容器，这意味着，即使 Swarm 由于某些原因挂掉了，集群中的节点也会照常运行，当 Swarm 重新恢复运行之后，它会收集重建集群信息。并且 Swarm 提供的路由匹配(服务发现、负载均衡、跨容器通讯)非常可靠。在单个端口上运行一个服务，Swarm 节点的任意主机都可以访问，负载均衡完全在后台实现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/44953944-dfbc7a00-aecd-11e8-93dc-1fe6258aafd0.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Swarm 在 Scheduler 节点运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：Random, Binpack, Spread。&lt;/p>
&lt;p>Random 顾名思义，就是随机选择一个 Node 来运行容器，一般用作调试用。Spread 和 Binpack 策略会根据各个节点的可用的 CPU, RAM 以及正在运行的容器的数量来计算应该运行容器的节点。在同等条件下，Spread 策略会选择运行容器最少的那台节点来运行新的容器，Binpack 策略会选择运行容器最集中的那台机器来运行新的节点。&lt;/p>
&lt;p>使用 Spread 策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。Binpack 策略最大化的避免容器碎片化，就是说 Binpack 策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在一个节点上面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建一个新的服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service create &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--image nginx &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--replicas &lt;span class="m">2&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 更新服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service update &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>--image nginx:alpine &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span>nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service rm nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 缩容，而不是直接删除服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service scale &lt;span class="nv">nginx&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 扩容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service scale &lt;span class="nv">nginx&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列出所有的服务&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列出一个服务的所有实例(包括服务的健康状况)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service ps nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 服务的详细信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service inspect nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 增加和删除DNS&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service update --dns-add 222.222.222.222 tender_hofstadter
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service update --dns-rm 222.222.222.222 tender_hofstadter
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 增加和删除端口映射&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service update --publish-add 80:80 xenodochial_ritchie
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker service update --publish-rm 80:80 xenodochial_ritchie
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以使用 Docker Compose 的脚本来进行批次部署：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ docker stack deploy application
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">web&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">registry.gitlab.com/example/example&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># you need to use external image&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">npm run prod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">80&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">update_config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">parallelism&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">delay&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">10s&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">restart_policy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">condition&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">on&lt;/span>-&lt;span class="l">failure&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Linux-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/linux-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/linux-cheatsheet/</guid><description>&lt;h1 id="linux-cheatsheet">Linux CheatSheet&lt;/h1>
&lt;p>BIOS：&lt;/p>
&lt;p>Basic Input Output System 的缩略词，直译&amp;quot;基本输入输出系统&amp;quot;。&lt;/p>
&lt;p>它是一组固化到计算机内主板上一个 ROM 芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从 CMOS 中读写系统设置的具体信息。其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。&lt;/p>
&lt;p>GRUB：&lt;/p>
&lt;p>GRand Unified Bootloader 简称“GRUB”，是一个来自 GNU 项目的多操作系统启动程序。&lt;/p>
&lt;p>UEFI&lt;/p>
&lt;p>Unified Extensible Firmware Interface，全称“统一的可扩展固件接口”&lt;/p>
&lt;p>是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上。&lt;/p>
&lt;p>可扩展固件接口（Extensible Firmware Interface，EFI）是 Intel 为 PC 固件的体系结构、接口和服务提出的建议标准。其主要目的是为了提供一组在 OS 加载之前（启动前）在所有平台上一致的、正确指定的启动服务，被看做是有近 20 多年历史的 BIOS 的继任者。UEFI 是由 EFI1.10 为基础发展起来的，它的所有者已不再是 Intel，而是一个称作 Unified EFI Form 的国际组织。&lt;/p>
&lt;h1 id="systemd">Systemd&lt;/h1>
&lt;p>&lt;a href="./Linux-CheatSheet.md">init 进程&lt;/a>是 Linux 系统 Booting 之后的首个进程，其作为守护进程运行直至系统关闭；传统的 Linux 中的服务控制方式也主要依赖于 sysvinit 机制:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ sudo /etc/init.d/apache2 start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 或者&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ service apache2 start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当 sysvinit 系统初始化的时候，它是串行启动，并且会将所有可能用到的后台服务进程全部启动运行；系统必须等待所有的服务都启动就绪之后，才允许用户登录，导致启动时间过长与系统资源浪费。并且 init 进程只是执行启动脚本，不管其他事情，脚本需要自己处理各种情况，使得脚本复杂度增加很多。Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/45408944-64fb1800-b6a0-11e8-97a3-83bb4c681aff.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="用户进程">用户进程&lt;/h1>
&lt;p>Linux 在操作这些物理内存时，不会直接操作物理内存，而是建立一个虚拟地址（可以理解成跟物理内存相对应的映射），即在物理内存跟进程之间增加一个中间层。&lt;/p>
&lt;p>系统将虚拟地址分为两部分：一部分专门给系统内核使用，另一部分给用户进程使用。对于 32 位的系统，虚拟地址范围是 0x00000000 ~ 0xFFFFFFFF，即最大虚拟内存为 2^32 Bytes = 4GB，系统将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF）分配内核使用，此区域称作内核空间；另外将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。由于虚拟地址是物理内存的映射，相当于系统将物理内存分成两部分单独使用。所以，现在有两个概念：&lt;/p>
&lt;p>内核空间：系统内核使用的内存空间；当一个进程执行调用系统命令(例如 read, write)时，会进入内核代码的执行，进程此时的状态我们称之为内核态。
用户空间：用户进程使用的内存空间；当一个进程执行用户自己的代码时，该进程此时的状态为用户态。&lt;/p>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Network-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/network-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/network-cheatsheet/</guid><description>&lt;h1 id="http-cheatsheet--http-相关必知必会tcphttp2httpsdns请求响应缓存">HTTP CheatSheet | HTTP 相关必知必会：TCP/HTTP2/HTTPS/DNS，请求，响应，缓存&lt;/h1>
&lt;p>HTTP, 等网络协议是我们日常开发、面试中常见的知识要点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">http://rob:abcd1234@www.example.co.uk/path/index.html?query1&lt;span class="o">=&lt;/span>test&lt;span class="p">&amp;amp;&lt;/span>&lt;span class="nv">silly&lt;/span>&lt;span class="o">=&lt;/span>willy&lt;span class="p">&amp;amp;&lt;/span>field&lt;span class="o">[&lt;/span>0&lt;span class="o">]=&lt;/span>zero&lt;span class="p">&amp;amp;&lt;/span>field&lt;span class="o">[&lt;/span>2&lt;span class="o">]=&lt;/span>two#test&lt;span class="o">=&lt;/span>hash&lt;span class="p">&amp;amp;&lt;/span>&lt;span class="nv">chucky&lt;/span>&lt;span class="o">=&lt;/span>cheese
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="基础">基础&lt;/h1>
&lt;h2 id="uri--url">URI &amp;amp; URL&lt;/h2>
&lt;p>The difference between them is straightforward after knowing their definitions:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Uniform Resource Identifier (URI)&lt;/strong> − a sequence of characters that allows the complete identification of any abstract or physical resource&lt;/li>
&lt;li>&lt;strong>Uniform Resource Locator (URL)&lt;/strong> − a subset of URI that, in addition to identifying where a resource is available, describes the primary mechanism to access it&lt;/li>
&lt;/ul>
&lt;p>Every URI, regardless if it’s a URL or not, follows a particular form:&lt;/p>
&lt;pre tabindex="0">&lt;code>scheme:[//authority][/path][?query][#fragment]
&lt;/code>&lt;/pre>&lt;p>Where each part is described as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>*scheme*&lt;/strong> − for URLs, is the name of the protocol used to access the resource, for other URIs, is a name that refers to a specification for assigning identifiers within that scheme&lt;/li>
&lt;li>&lt;strong>authority&lt;/strong> − an optional part comprised of user authentication information, a host and an optional port&lt;/li>
&lt;li>&lt;strong>*path*&lt;/strong> − it serves to identify a resource within the scope of its &lt;em>scheme&lt;/em> and &lt;em>authority&lt;/em>&lt;/li>
&lt;li>&lt;strong>*query*&lt;/strong> − additional data that, along with the &lt;em>path,&lt;/em> serves to identify a resource. For URLs, this is the query string&lt;/li>
&lt;li>&lt;strong>*fragment*&lt;/strong> − an optional identifier to a specific part of the resource&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>To easily identify if a particular URI is also a URL, we can check its scheme&lt;/strong>. Every URL has to start with any of these schemes: &lt;em>ftp&lt;/em>, &lt;em>http&lt;/em>, &lt;em>https,&lt;/em> &lt;em>gopher&lt;/em>, &lt;em>mailto&lt;/em>, &lt;em>news&lt;/em>, &lt;em>nntp&lt;/em>, &lt;em>telnet&lt;/em>, &lt;em>wais&lt;/em>, &lt;em>file&lt;/em>, or &lt;em>prospero&lt;/em>. If it doesn’t start with it, then it’s not a URL.&lt;/p>
&lt;h1 id="请求">请求&lt;/h1>
&lt;h1 id="响应">响应&lt;/h1>
&lt;h2 id="常用响应头">常用响应头&lt;/h2>
&lt;ul>
&lt;li>Content-Disposition&lt;/li>
&lt;/ul>
&lt;p>Content-Disposition 属性是作为对下载文件的一个标识字段，属性有两种类型: inline 将文件内容直接显示在页面, attachment 弹出对话框让用户下载:&lt;/p>
&lt;pre tabindex="0">&lt;code>Content-Type: image/jpeg
Content-Disposition: inline;filename=hello.jpg
Content-Description: just a small picture of me
&lt;/code>&lt;/pre>&lt;h1 id="缓存">缓存&lt;/h1>
&lt;h1 id="tcp">TCP&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/48391511-ea06ba00-e741-11e8-832f-ac9d994f0b21.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这是因为 Linux 不像其他操作系统在收到 SYN 为该连接立马分配一块内存空间用于存储相关的数据和结构，而是延迟到接收到 client 的 ACK，即三次握手 真正完成后才分配空间，这是为了防范 SYN flooding 攻击。如果是这种情况，那么就会出现 client 端未 ESTABLISHED 状态，server 为 SYN_RECV 状态。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CLOSED&lt;/th>
&lt;th>没有使用这个套接字[netstat 无法显示 closed 状态]&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>LISTEN&lt;/td>
&lt;td>套接字正在监听连接[调用 listen 后]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SYN_SENT&lt;/td>
&lt;td>套接字正在试图主动建立连接[发送 SYN 后还没有收到 ACK]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SYN_RECEIVED&lt;/td>
&lt;td>正在处于连接的初始同步状态[收到对方的 SYN，但还没收到自己发过去的 SYN 的 ACK]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ESTABLISHED&lt;/td>
&lt;td>连接已建立&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CLOSE_WAIT&lt;/td>
&lt;td>远程套接字已经关闭：正在等待关闭这个套接字[被动关闭的一方收到 FIN]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FIN_WAIT_1&lt;/td>
&lt;td>套接字已关闭，正在关闭连接[发送 FIN，没有收到 ACK 也没有收到 FIN]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CLOSING&lt;/td>
&lt;td>套接字已关闭，远程套接字正在关闭，暂时挂起关闭确认[在 FIN_WAIT_1 状态下收到被动方的 FIN]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LAST_ACK&lt;/td>
&lt;td>远程套接字已关闭，正在等待本地套接字的关闭确认[被动方在 CLOSE_WAIT 状态下发送 FIN]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FIN_WAIT_2&lt;/td>
&lt;td>套接字已关闭，正在等待远程套接字关闭[在 FIN_WAIT_1 状态下收到发过去 FIN 对应的 ACK]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TIME_WAIT&lt;/td>
&lt;td>这个套接字已经关闭，正在等待远程套接字的关闭传送[FIN、ACK、FIN、ACK 都完毕，这是主动方的最后一个状态，在过了 2MSL 时间后变为 CLOSED 状态]&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>TCP 协议规定，对于已经建立的连接，网络双方要进行四次握手才能成功断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。在众多 TCP 状态中，最值得注意的状态有两个：CLOSE_WAIT 和 TIME_WAIT。&lt;/p>
&lt;p>CLOSE_WAIT 对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成 CLOSE_WAIT 此时我方要调用 close()来使得连接正确关闭；TIME_WAIT 是我方主动调用 close()断开连接，收到对方确认后状态变为 TIME_WAIT。TCP 协议规定 TIME_WAIT 状态会一直持续 2MSL(即两倍的分段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于 TIME_WAIT 状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情况下，尽量不要主动断开连接，以减少 TIME_WAIT 状态造成的资源浪费。&lt;/p>
&lt;h1 id="https">HTTPS&lt;/h1>
&lt;p>HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/611143f05132923bf8cd4086.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/6111440f5132923bf8cda2a9.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="http2">HTTP/2&lt;/h1>
&lt;h1 id="websocket">WebSocket&lt;/h1>
&lt;h1 id="dns">DNS&lt;/h1>
&lt;p>Dns 系统主要是依靠权威 dns，和递归 dns 来工作的。权威 dns 做的事情主要是管理某个或多个特定域的 dns 服务。一般大一点的公司，都有自己的权威 dns&lt;/p>
&lt;p>比如所有”.alipay.com”结尾的域名都由 alipay 来管理&lt;/p>
&lt;p>所有”.alibaba.com”结尾的域名都由 alibaba 来管理(alipay 和 alibaba 实际又是同一家公司来管理)&lt;/p>
&lt;p>所有“.baidu.com”结尾的域名都由 baidu 来管理&lt;/p>
&lt;p>Alibaba 和 baidu 各管各的，没有交互。一级域要去根上注册，像 com 域，net 域就属于一级域&lt;/p>
&lt;p>Com 域（也就是所有以“.com”结尾的老祖 com 域）要去根上注册 com 域的域名服务器（nameserver）列表。&lt;/p>
&lt;p>Net 域（也就是所有以”.net”结尾的老祖 net 域）要去根上注册 net 域的域名服务器（nameserver）列表。二级域一般要到一级域上去注册&lt;/p>
&lt;p>alibaba.com 要到 com 域去注册自己的域名服务器 nameserver 列表&lt;/p>
&lt;p>Baidu.com 也要到 com 域去注册自己的域名服务器 nameserver 列表&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/40573917-a5b3da1c-60fb-11e8-8be9-7ad479c05daa.jpg" alt="i20180520_181112_186" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>递归 DNS（Recursion DNS）&lt;/p>
&lt;p>那用户访问 &lt;a href="https://www.alibaba.com" target="_blank" rel="noopener">www.alibaba.com&lt;/a>，请求又是如何到 alibaba 的权威 dns 服务器上面找到 &lt;a href="https://www.alibaba.com" target="_blank" rel="noopener">www.alibaba.com&lt;/a> 的 ip 呢？&lt;/p>
&lt;p>这个时候递归 dns（我们一般叫做 local dns）就介入了。递归 dns 也就是我们常说的缓存 dns，local dns，公共 dns（提供专门递归服务的 dns），这样一步步的从根“.”到&amp;quot;com&amp;quot;,再到“alibaba.com”,最后到“www.alibaba.com”的过程叫做递归过程
Dns 请求一般是 udp 报文（也可以是 tcp 的报文），所以同样也是要有源 ip，目标 ip，等等这些网络数据包的底层信息，递归过程的每一步，目标 ip 都必须是很明确的
各个域的 namserver 实际上是有多台的，比如根的 namserver 的 ip 有 13 个，com 的 namserver 的 ip 也有 13 个，递归 dns 在进行递归时需要选择其中一个 ip 作为目标 ip 进行下一步请求即可（目前主流 dns 实现软件，如 bind 会选择延时最小的那个 ip 作为下一步请求的目标 ip）dns 中用的多的是 anycast 技术，一个 ip 实际上对了很多个物理服务器，到各个权威 nameserver 上，也有 lvs，ospf 等等一些负载均衡技术把同一个 ip 对应到多个物理服务器上面。
递归 dns 还会把图中递归第一步，第二步，第三步向各级权威 dns 发起的请求结果给缓存到自己的内存中，直到这条结果的 ttl 超期失效（超期时间一般为几分钟到几小时几天等等），在这个 ttl 超期之前，任何其他用户发起的 &lt;a href="https://www.alibaba.com" target="_blank" rel="noopener">www.alibaba.com&lt;/a> 的 dns 请求，递归 dns 都会直接从自己的内存中把缓存结果直接返回给客户端（不会去递归了）。如果 ttl 超期了，才会去重新递归。&lt;/p>
&lt;p>有的 dns 既是权威 dns，又是递归 dns，这并不冲突，这种 dns 在遇到域名是自己管理的域的后缀结尾时，会直接进行应答（无论是否存在结果），如果不是自己管理的域的后缀域名，则进行递归，同样吧递归结果进行缓存。&lt;/p></description></item><item><title>Raspberry-CheatSheet</title><link>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/raspberry-cheatsheet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/raspberry-cheatsheet/</guid><description>&lt;h1 id="raspberry-cheatsheet--树莓派资料索引">Raspberry CheatSheet | 树莓派资料索引&lt;/h1>
&lt;ul>
&lt;li>博通 BCM2837B0 SoC，集成四核 ARM Cortex-A53（ARMv8）64 位@ 1.4GHz CPU，集成博通 Videocore-IV GPU&lt;/li>
&lt;li>内存：1GB LPDDR2 SDRAM&lt;/li>
&lt;li>有线网络：千兆以太网（通过 USB2.0 通道，最大吞吐量 300Mbps）&lt;/li>
&lt;li>无线网络:2.4GHz 和 5GHz 双频 Wi-Fi，支持 802.11b/g/n/ac&lt;/li>
&lt;li>蓝牙：蓝牙 4.2&amp;amp;低功耗蓝牙（BLE）&lt;/li>
&lt;li>存储：Micro-SD&lt;/li>
&lt;li>其他接口：HDMI，3.5mm 模拟音频视频插孔，4x USB 2.0，以太网，摄像机串行接口（CSI），显示器串行接口（DSI），MicroSD 卡座，40pin 扩展双排插针&lt;/li>
&lt;li>尺寸：82mmx 56mmx 19.5mm，50 克&lt;/li>
&lt;/ul>
&lt;h1 id="安装与配置">安装与配置&lt;/h1>
&lt;h2 id="系统安装">系统安装&lt;/h2>
&lt;p>我们首先需要准备 SD 卡并且将系统烧录到其中，在 MAC 系统中，可以通过 df 命令查看分区情况：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ df -lh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Filesystem Size Used Avail Capacity iused ifree %iused Mounted on
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/dev/disk1s1 234Gi 170Gi 60Gi 75% &lt;span class="m">5903759&lt;/span> &lt;span class="m">9223372036848872048&lt;/span> 0% /
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/dev/disk1s4 234Gi 3.0Gi 60Gi 5% &lt;span class="m">3&lt;/span> &lt;span class="m">9223372036854775804&lt;/span> 0% /private/var/vm
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/dev/disk4s1 15Gi 2.4Mi 15Gi 1% &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 100% /Volumes/NO NAME
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 可选，格式化磁盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo diskutil eraseDisk FAT32 CAM_STORE MBRFormat /dev/disk4s1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果提示 Resource Busy，则可进行卸载&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ diskutil unmount /dev/disk4s1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 烧写系统&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo dd &lt;span class="nv">bs&lt;/span>&lt;span class="o">=&lt;/span>4m &lt;span class="k">if&lt;/span>&lt;span class="o">=&lt;/span>rpi_35_v6_1_2_3_jessie_kernel_4_4_50.img &lt;span class="nv">of&lt;/span>&lt;span class="o">=&lt;/span>/dev/disk4s1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 卸载系统&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ diskutil unmountDisk /dev/disk4s1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="系统配置">系统配置&lt;/h2>
&lt;p>如果通过 ssh 连接树莓派出现 Access denied 这个提示则说明 ssh 服务没有开启。要手动开启的话，和 WiFi 配置相似，同样在 boot 分区新建一个文件，空白的即可，文件命名为 ssh。注意要小写且不要有任何扩展名。&lt;/p>
&lt;p>树莓派在启动之后会在检测到这个文件之后自动启用 ssh 服务。随后即可通过登录路由器找到树莓派的 IP 地址，通过 ssh 连接到树莓派了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置 root 账户密码&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo passwd root
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 解锁 root&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo passwd --unlock root
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ su
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo apt-get remove python3-pip&lt;span class="p">;&lt;/span> sudo apt-get install python3-pip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="网络配置">网络配置&lt;/h2>
&lt;p>用户可以在未启动树莓派的状态下单独修改 /boot/wpa_supplicant.conf 文件配置 WiFi 的 SSID 和密码，这样树莓派启动后会自行读取 wpa_supplicant.conf 配置文件连接 WiFi 设备。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">country=CN
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
# WiFi 使用WPA/WPA2加密
network={
ssid=&amp;#34;WiFi-A&amp;#34;
psk=&amp;#34;12345678&amp;#34;
key_mgmt=WPA-PSK
# 连接优先级，数字越大优先级越高（不可以是负数）
priority=1
}
network={
ssid=&amp;#34;WiFi-B&amp;#34;
psk=&amp;#34;12345678&amp;#34;
key_mgmt=WPA-PSK
priority=2
# 连接隐藏 WiFi 时需要指定该值为 1
scan_ssid=1
}
# WiFi 没有密码
network={
ssid=&amp;#34;你的无线网络名称（ssid）&amp;#34;
key_mgmt=NONE
}
# WiFi 使用WEP加密
network={
ssid=&amp;#34;你的无线网络名称（ssid）&amp;#34;
key_mgmt=NONE
wep_key0=&amp;#34;你的wifi密码&amp;#34;
}
&lt;/code>&lt;/pre>&lt;h1 id="gpio">GPIO&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://imgsa.baidu.com/exp/pic/item/9304c888d43f8794e438169fd51b0ef41ad53a78.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="输出">输出&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-py" data-lang="py">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">RPi.GPIO&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">GPIO&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">setup&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setmode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">BOARD&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">OUT&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">OUT&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">LOW&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">LOW&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">destroy&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">LOW&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">LOW&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">IN&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">IN&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">openLed&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">setup&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">HIGH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">HIGH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">LOW&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># destroy()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">cleanup&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">openLed&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="输入">输入&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/5803001/44529356-7d6db780-a71e-11e8-8e9f-ee98249adeee.png" alt="image" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-py" data-lang="py">&lt;span class="line">&lt;span class="cl">&lt;span class="ch">#!/usr/bin/env python&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># encoding: utf-8&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">RPi.GPIO&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">R&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">G&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">18&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">14&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 按钮输出针脚连接的GPIO口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">btnR&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">btnG&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">btnB&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">21&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">16&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setmode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">BCM&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">OUT&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">G&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">OUT&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">OUT&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 按钮连接的GPIO针脚的模式设置为信号输入模式，同时默认拉高GPIO口电平，&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 当GND没有被接通时，GPIO口处于高电平状态，取的的值为1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 注意到这是一个可选项，如果不在程序里面设置，通常的做法是通过一个上拉电阻连接到VCC上使之默认保持高电平&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">btnR&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">IN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pull_up_down&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PUD_UP&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">btnG&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">IN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pull_up_down&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PUD_UP&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">btnB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">IN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pull_up_down&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PUD_UP&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">G&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.01&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 检测按钮1是否被按下，如果被按下(低电平)，则亮红灯(输出低电平)，否则关红灯&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">btnR&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">R&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 检测按钮2是否被按下，如果被按下(低电平)，则亮绿灯(输出低电平)，否则关绿灯&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">btnG&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">G&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">G&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 检测按钮3是否被按下，如果被按下(低电平)，则亮蓝灯(输出低电平)，否则关蓝灯&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">btnB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">except&lt;/span> &lt;span class="ne">KeyboardInterrupt&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">RPi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">GPIO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">cleanup&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="蓝牙">蓝牙&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Mini Bluetooth Speaker&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo apt-get update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo apt-get upgrade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install pi-bluetooth &lt;span class="o">(&lt;/span> &lt;span class="s2">&amp;#34;already the newest version&amp;#34;&lt;/span> &lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install blueman pulseaudio pavucontrol pulseaudio-module-bluetooth
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo reboot
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">hcitool dev &lt;span class="o">(&lt;/span>look &lt;span class="k">for&lt;/span> bluetooth address of the built-in adapter&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">(&lt;/span>&lt;span class="k">if&lt;/span> don&lt;span class="err">&amp;#39;&lt;/span>t see it: sudo hciconfig
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bluetoothctl
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># devices&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># power on&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># pairable on&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># discoverable on&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># scan on&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># devices&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Device 30:22:12:01:0C:52 Y88
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># paired-devices&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># agent on&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># default-agent&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># trust 30:22:12:01:0C:52&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># pair 30:22:12:01:0C:52&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Attempting to pair with 30:22:12:01:0C:52
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>CHG&lt;span class="o">]&lt;/span> Device 30:22:12:01:0C:52 Connected: yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>CHG&lt;span class="o">]&lt;/span> Device 30:22:12:01:0C:52 Modalias: usb:v05ACp022Cd0100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>CHG&lt;span class="o">]&lt;/span> Device 30:22:12:01:0C:52 UUIDs:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 00001108-0000-1000-8000-00805f9b34fb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 0000110b-0000-1000-8000-00805f9b34fb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 0000110c-0000-1000-8000-00805f9b34fb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 0000110e-0000-1000-8000-00805f9b34fb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 0000111e-0000-1000-8000-00805f9b34fb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 00001124-0000-1000-8000-00805f9b34fb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 00001200-0000-1000-8000-00805f9b34fb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>CHG&lt;span class="o">]&lt;/span> Device 30:22:12:01:0C:52 Paired: yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Pairing successful
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># paired-devices&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Device 30:22:12:01:0C:52 Y88
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># connect 30:22:12:01:0C:52&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Attempting to connect to 30:22:12:01:0C:52
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>CHG&lt;span class="o">]&lt;/span> Device 30:22:12:01:0C:52 Connected: yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># exit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ alsamixer &lt;span class="o">(&lt;/span>&lt;span class="nb">set&lt;/span> volume to 85% - normal&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo apt-get install omxplayer
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ omxplayer YouBetterRun.mp3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-py" data-lang="py">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">os&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">sys&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">subprocess&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">blue_it&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;ls /dev/input/event0 2&amp;gt;/dev/null&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">status&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Bluetooth UP&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">status&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;mplayer http://addressToSomeStream.com&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;ls /dev/input/event0 2&amp;gt;/dev/null&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">waiting&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">waiting&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;killall -9 pulseaudio&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;pulseaudio --start&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;ls /dev/input/event0 2&amp;gt;/dev/null&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">status&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Bluetooth DOWN&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">status&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;~/scripts/autopair&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">subprocess&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;ls /dev/input/event0 2&amp;gt;/dev/null&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shell&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">blue_it&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">blue_it&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>