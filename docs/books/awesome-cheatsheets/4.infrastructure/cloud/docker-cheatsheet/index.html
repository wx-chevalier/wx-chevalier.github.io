<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="📖 节选自 Awesome CheatSheet/Docker CheatSheet，对来自官方文档及 Docker Links 中链接内容的归档整理，包含了日常工作中常用的 Docker 概念与命令，如果对于 Linux 常用操作尚不熟悉的可以参考 Linux Commands CheatSheet。 Docker CheatSheet | Docker 配置与实践清单 容器"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/cloud/docker-cheatsheet/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/cloud/docker-cheatsheet/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/awesome-cheatsheets/4.infrastructure/cloud/docker-cheatsheet/"><meta property="og:title" content="Docker-Cheatsheet | Next-gen Tech Edu"><meta property="og:description" content="📖 节选自 Awesome CheatSheet/Docker CheatSheet，对来自官方文档及 Docker Links 中链接内容的归档整理，包含了日常工作中常用的 Docker 概念与命令，如果对于 Linux 常用操作尚不熟悉的可以参考 Linux Commands CheatSheet。 Docker CheatSheet | Docker 配置与实践清单 容器"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><meta property="article:modified_time" content="2023-04-16T20:01:58+08:00"><title>Docker-Cheatsheet | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=b18ff93fa0e9711b67c3fcb3d7e907dd><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">Cloud</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id0ec61351a690292b4038fdf8847a1a69")' href=#id0ec61351a690292b4038fdf8847a1a69 aria-expanded=false aria-controls=id0ec61351a690292b4038fdf8847a1a69 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/>4.Infrastructure</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id0ec61351a690292b4038fdf8847a1a69 aria-expanded=false aria-controls=id0ec61351a690292b4038fdf8847a1a69><i class="fa-solid fa-angle-down" id=caret-id0ec61351a690292b4038fdf8847a1a69></i></a></div><ul class="nav docs-sidenav collapse show" id=id0ec61351a690292b4038fdf8847a1a69><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idfcc42c0f835b56cc6b0714a3567894bd")' href=#idfcc42c0f835b56cc6b0714a3567894bd aria-expanded=false aria-controls=idfcc42c0f835b56cc6b0714a3567894bd aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/cloud/>Cloud</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idfcc42c0f835b56cc6b0714a3567894bd aria-expanded=false aria-controls=idfcc42c0f835b56cc6b0714a3567894bd><i class="fa-solid fa-angle-down" id=caret-idfcc42c0f835b56cc6b0714a3567894bd></i></a></div><ul class="nav docs-sidenav collapse show" id=idfcc42c0f835b56cc6b0714a3567894bd><li class="child level active"><a href=/books/awesome-cheatsheets/4.infrastructure/cloud/docker-cheatsheet/>Docker-Cheatsheet</a></li><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id5370d4ccf91142356bddfd79d787fbdc")' href=#id5370d4ccf91142356bddfd79d787fbdc aria-expanded=false aria-controls=id5370d4ccf91142356bddfd79d787fbdc aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/cloud/k8s/>K8s</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id5370d4ccf91142356bddfd79d787fbdc aria-expanded=false aria-controls=id5370d4ccf91142356bddfd79d787fbdc><i class="fa-solid fa-angle-right" id=caret-id5370d4ccf91142356bddfd79d787fbdc></i></a></div><ul class="nav docs-sidenav collapse" id=id5370d4ccf91142356bddfd79d787fbdc><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/cloud/k8s/kubectl-cheatsheet/>Kubectl-CheatSheet</a></li></ul></div></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id36b7d77cc42c5a1135a68a2701dcde7f")' href=#id36b7d77cc42c5a1135a68a2701dcde7f aria-expanded=false aria-controls=id36b7d77cc42c5a1135a68a2701dcde7f aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/dataengineering/>DataEngineering</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id36b7d77cc42c5a1135a68a2701dcde7f aria-expanded=false aria-controls=id36b7d77cc42c5a1135a68a2701dcde7f><i class="fa-solid fa-angle-right" id=caret-id36b7d77cc42c5a1135a68a2701dcde7f></i></a></div><ul class="nav docs-sidenav collapse" id=id36b7d77cc42c5a1135a68a2701dcde7f><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/dataengineering/datavis-cheatsheet/>DataVis-CheatSheet</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idf149a3607b88a5be72f1a1682cd40ed4")' href=#idf149a3607b88a5be72f1a1682cd40ed4 aria-expanded=false aria-controls=idf149a3607b88a5be72f1a1682cd40ed4 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/distributed/>Distributed</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idf149a3607b88a5be72f1a1682cd40ed4 aria-expanded=false aria-controls=idf149a3607b88a5be72f1a1682cd40ed4><i class="fa-solid fa-angle-right" id=caret-idf149a3607b88a5be72f1a1682cd40ed4></i></a></div><ul class="nav docs-sidenav collapse" id=idf149a3607b88a5be72f1a1682cd40ed4><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/distributed/blockchain-cheatsheet/>Blockchain-CheatSheet</a></li><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/distributed/concurrentprogramming-cheatsheet/>ConcurrentProgramming-CheatSheet</a></li><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/distributed/distributedsystem-cheatsheet/>DistributedSystem-CheatSheet</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide7931dd59e0902d9791c5564dd53c0ce")' href=#ide7931dd59e0902d9791c5564dd53c0ce aria-expanded=false aria-controls=ide7931dd59e0902d9791c5564dd53c0ce aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/infosecurity/>InfoSecurity</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide7931dd59e0902d9791c5564dd53c0ce aria-expanded=false aria-controls=ide7931dd59e0902d9791c5564dd53c0ce><i class="fa-solid fa-angle-right" id=caret-ide7931dd59e0902d9791c5564dd53c0ce></i></a></div><ul class="nav docs-sidenav collapse" id=ide7931dd59e0902d9791c5564dd53c0ce><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/infosecurity/codec-cheatsheet/>Codec-CheatSheet</a></li><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/infosecurity/websecurity-cheatsheet/>WebSecurity-CheatSheet</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id7d89ef7c82ef0628fa28b2c38d26a60f")' href=#id7d89ef7c82ef0628fa28b2c38d26a60f aria-expanded=false aria-controls=id7d89ef7c82ef0628fa28b2c38d26a60f aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/messagequeue/>MessageQueue</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id7d89ef7c82ef0628fa28b2c38d26a60f aria-expanded=false aria-controls=id7d89ef7c82ef0628fa28b2c38d26a60f><i class="fa-solid fa-angle-right" id=caret-id7d89ef7c82ef0628fa28b2c38d26a60f></i></a></div><ul class="nav docs-sidenav collapse" id=id7d89ef7c82ef0628fa28b2c38d26a60f><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ida974d8f14b774f2bfe535909bbe67434")' href=#ida974d8f14b774f2bfe535909bbe67434 aria-expanded=false aria-controls=ida974d8f14b774f2bfe535909bbe67434 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/messagequeue/kafka/>Kafka</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ida974d8f14b774f2bfe535909bbe67434 aria-expanded=false aria-controls=ida974d8f14b774f2bfe535909bbe67434><i class="fa-solid fa-angle-right" id=caret-ida974d8f14b774f2bfe535909bbe67434></i></a></div><ul class="nav docs-sidenav collapse" id=ida974d8f14b774f2bfe535909bbe67434><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/messagequeue/kafka/kafka-cheatsheet/>Kafka-CheatSheet</a></li></ul></div><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/messagequeue/pulsar-cheatsheet/>Pulsar-CheatSheet</a></li><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/messagequeue/rabbitmq-cheatsheet/>RabbitMQ-CheatSheet</a></li><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/messagequeue/rocketmq-cheatsheet/>RocketMQ-CheatSheet</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idd676629d51d89d19a18158ae64594497")' href=#idd676629d51d89d19a18158ae64594497 aria-expanded=false aria-controls=idd676629d51d89d19a18158ae64594497 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/network/>Network</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idd676629d51d89d19a18158ae64594497 aria-expanded=false aria-controls=idd676629d51d89d19a18158ae64594497><i class="fa-solid fa-angle-right" id=caret-idd676629d51d89d19a18158ae64594497></i></a></div><ul class="nav docs-sidenav collapse" id=idd676629d51d89d19a18158ae64594497><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/network/network-cheatsheet/>Network-CheatSheet</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id34b2bda25b80a5bd1f6cc7ede017f582")' href=#id34b2bda25b80a5bd1f6cc7ede017f582 aria-expanded=false aria-controls=id34b2bda25b80a5bd1f6cc7ede017f582 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/os/>OS</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id34b2bda25b80a5bd1f6cc7ede017f582 aria-expanded=false aria-controls=id34b2bda25b80a5bd1f6cc7ede017f582><i class="fa-solid fa-angle-right" id=caret-id34b2bda25b80a5bd1f6cc7ede017f582></i></a></div><ul class="nav docs-sidenav collapse" id=id34b2bda25b80a5bd1f6cc7ede017f582><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idb622a5bd9b9ce63653a8d111c70d3f00")' href=#idb622a5bd9b9ce63653a8d111c70d3f00 aria-expanded=false aria-controls=idb622a5bd9b9ce63653a8d111c70d3f00 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/os/linux/>Linux</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idb622a5bd9b9ce63653a8d111c70d3f00 aria-expanded=false aria-controls=idb622a5bd9b9ce63653a8d111c70d3f00><i class="fa-solid fa-angle-right" id=caret-idb622a5bd9b9ce63653a8d111c70d3f00></i></a></div><ul class="nav docs-sidenav collapse" id=idb622a5bd9b9ce63653a8d111c70d3f00><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id8e2f2cf5a05961e3380a95da2127d054")' href=#id8e2f2cf5a05961e3380a95da2127d054 aria-expanded=false aria-controls=id8e2f2cf5a05961e3380a95da2127d054 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/os/linux/commands/>Commands</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id8e2f2cf5a05961e3380a95da2127d054 aria-expanded=false aria-controls=id8e2f2cf5a05961e3380a95da2127d054><i class="fa-solid fa-angle-right" id=caret-id8e2f2cf5a05961e3380a95da2127d054></i></a></div><ul class="nav docs-sidenav collapse" id=id8e2f2cf5a05961e3380a95da2127d054><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/os/linux/commands/bash-pitfalls/>Bash Pitfalls</a></li><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/os/linux/commands/heibaiying-linux-commands-cheatsheet/>Heibaiying-Linux-Commands-CheatSheet</a></li><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/os/linux/commands/trinib-linux-commands-cheatsheet/>Trinib-Linux-Commands-CheatSheet</a></li></ul></div><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/os/linux/linux-cheatsheet/>Linux-CheatSheet</a></li><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ideee592579f4f926ed062ab4c30116231")' href=#ideee592579f4f926ed062ab4c30116231 aria-expanded=false aria-controls=ideee592579f4f926ed062ab4c30116231 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/awesome-cheatsheets/4.infrastructure/os/linux/shell/>Shell</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ideee592579f4f926ed062ab4c30116231 aria-expanded=false aria-controls=ideee592579f4f926ed062ab4c30116231><i class="fa-solid fa-angle-right" id=caret-ideee592579f4f926ed062ab4c30116231></i></a></div><ul class="nav docs-sidenav collapse" id=ideee592579f4f926ed062ab4c30116231><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/os/linux/shell/linux-shell-cheatsheet/>Linux-Shell-CheatSheet</a></li></ul></div></ul></div><li class="child level"><a href=/books/awesome-cheatsheets/4.infrastructure/os/raspberry-cheatsheet/>Raspberry-CheatSheet</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#docker-ce>Docker CE</a></li><li><a href=#daemon-configuration>Daemon Configuration</a></li><li><a href=#docker-swarm>Docker Swarm</a></li><li><a href=#常用配置>常用配置</a><ul><li><a href=#代理>代理</a></li><li><a href=#存储与日志>存储与日志</a></li></ul></li></ul><ul><li><a href=#构建与拉取>构建与拉取</a></li><li><a href=#镜像管理>镜像管理</a></li><li><a href=#dockfile>Dockfile</a></li><li><a href=#registry>Registry</a></li><li><a href=#多阶段构建>多阶段构建</a></li></ul><ul><li><a href=#启停控制>启停控制</a></li><li><a href=#状态查询>状态查询</a></li><li><a href=#管理配置>管理配置</a></li><li><a href=#资源配额>资源配额</a><ul><li><a href=#memory>Memory</a></li><li><a href=#cpu>CPU</a></li><li><a href=#storage>Storage</a></li></ul></li></ul><ul><li><a href=#volume--数据卷>Volume | 数据卷</a></li><li><a href=#network--网络>Network | 网络</a><ul><li><a href=#dns>DNS</a></li></ul></li><li><a href=#空间清理>空间清理</a></li></ul><ul><li><a href=#docker-compose>Docker Compose</a></li><li><a href=#docker-swarm-1>Docker Swarm</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>Docker-Cheatsheet</h1><div class=article-style><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://user-images.githubusercontent.com/5803001/45699770-5d0a0f00-bb9d-11e8-8ce7-82650bfcbb39.png alt=image loading=lazy data-zoomable></div></div></figure></p><blockquote><p>📖 节选自 <a href=https://parg.co/o9d target=_blank rel=noopener>Awesome CheatSheet/Docker CheatSheet</a>，对来自<a href=https://docs.docker.com/ target=_blank rel=noopener>官方文档</a>及 <a href=https://parg.co/o90 target=_blank rel=noopener>Docker Links</a> 中链接内容的归档整理，包含了日常工作中常用的 Docker 概念与命令，如果对于 Linux 常用操作尚不熟悉的可以参考 <a href=https://parg.co/oiT target=_blank rel=noopener>Linux Commands CheatSheet</a>。</p></blockquote><h1 id=docker-cheatsheet--docker-配置与实践清单>Docker CheatSheet | Docker 配置与实践清单</h1><p>容器是在操作系统中建立隔离上下文的一种方法。实际上，这意味着它们中的每一个都有一个单独的包含了一组已安装的软件和相关配置的虚拟文件系统。由于它们是相互隔离的，因此任何容器都不能直接访问或影响其他容器或底层宿主操作系统。Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://user-images.githubusercontent.com/5803001/43813144-f630ba5c-9af6-11e8-8443-175666d4615a.png alt=image loading=lazy data-zoomable></div></div></figure></p><p>虚拟机最大的瓶颈在于其需要特殊硬件虚拟化技术支持，并且携带完整的操作系统；而 Docker 没有硬件虚拟化，可以运行在物理机、虚拟机, 甚至嵌套运行在 Docker 容器内，并且其不携带操作系统的，会轻巧很多。在调用宿主机的内存、CPU、磁盘等等资源时，虚拟机是利用 Hypervisor 去虚拟化内存，整个调用过程是虚拟内存->虚拟物理内存->真正物理内存，但是 Docker 是利用 Docker Engine 去调用宿主的的资源，这时候过程是虚拟内存->真正物理内存。</p><p>Docker 综合运用了 Cgroup, Linux Namespace，Secomp capability, Selinux 等机制，在 <a href=./Docker-Internals-CheatSheet>Docker Internals CheatSheet</a> 中我们会有详细的讨论，或者前往 <a href=https://github.com/wx-chevalier/Backend-Boilerplate/tree/master/docker target=_blank rel=noopener>Backend Boilerplate/docker</a> 浏览常见服务/应用的 Docker 配置案例。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://user-images.githubusercontent.com/5803001/44158672-dec2d480-a0e7-11e8-9f50-ce83c9638853.png alt=image loading=lazy data-zoomable></div></div></figure></p><h1 id=安装与配置>安装与配置</h1><h2 id=docker-ce>Docker CE</h2><p>这里我们使用<a href=https://mirrors.ustc.edu.cn/help/docker-ce.html target=_blank rel=noopener>科大的 Docker CE 源</a>进行安装：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 更改 Ubuntu 默认源地址</span>
</span></span><span class=line><span class=cl>$ sudo sed -i <span class=s1>&#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39;</span> /etc/apt/sources.list
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 安装必备的系统命令</span>
</span></span><span class=line><span class=cl>$ sudo apt-get install -y python-software-properties
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg <span class=p>|</span> sudo apt-key add -
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo add-apt-repository <span class=s2>&#34;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu </span><span class=k>$(</span>lsb_release -cs<span class=k>)</span><span class=s2> stable&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo apt-get update
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ apt-cache policy docker-ce <span class=c1># 列举 docker-ce 版本</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ apt-get install docker-ce<span class=o>=</span>17.03.2-ce....
</span></span></code></pre></div><h2 id=daemon-configuration>Daemon Configuration</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 配置开机自启动</span>
</span></span><span class=line><span class=cl>$ sudo systemctl <span class=nb>enable</span> docker
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 取消开机自启动</span>
</span></span><span class=line><span class=cl>$ sudo systemctl disable docker
</span></span></code></pre></div><p>我们还需要修改存储路径，指定镜像存储地址，允许远程访问；此时我们可以修改 systemd 中的配置文件，也可以修改 <code>/etc/docker/daemon.json</code>，此处以修改服务为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 使用 systemctl 命令行修改</span>
</span></span><span class=line><span class=cl>$ sudo systemctl edit docker.service
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 或者查找配置地址并使用 Vim 修改</span>
</span></span><span class=line><span class=cl>$ systemctl status docker
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 修改文件内容</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375 -H unix:///var/run/docker.sock --insecure-registry 10.196.108.176:5000 --dns 114.114.114.114 --dns 8.8.8.8 --dns 8.8.4.4 -g /mnt
</span></span></code></pre></div><p>然后重启服务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 重新载入服务配置</span>
</span></span><span class=line><span class=cl>$ sudo systemctl daemon-reload
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 重启 Docker</span>
</span></span><span class=line><span class=cl>$ sudo systemctl restart docker.service
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 判断是否配置成功</span>
</span></span><span class=line><span class=cl>$ sudo netstat -lntp <span class=p>|</span> grep dockerd
</span></span></code></pre></div><h2 id=docker-swarm>Docker Swarm</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 在主节点启动 Swarm</span>
</span></span><span class=line><span class=cl>$ docker swarm init
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看 Swarm 密钥</span>
</span></span><span class=line><span class=cl>$ docker swarm join-token -q worker
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在主节点启动 Procontainer</span>
</span></span><span class=line><span class=cl>$ docker run -it -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在主节点启动 Registry</span>
</span></span><span class=line><span class=cl>$ docker run -d -p 5000:5000 --restart<span class=o>=</span>always --name registry registry:2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将子节点加入到 Swarm</span>
</span></span><span class=line><span class=cl>$ docker swarm join <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--token <span class=si>${</span><span class=nv>TOKEN</span><span class=si>}</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>10.196.108.176:2377
</span></span></code></pre></div><h2 id=常用配置>常用配置</h2><h3 id=代理>代理</h3><p>鉴于 gcr 域名的不可用，我们需要利用 <a href=https://hub.docker.com/r/bluebu/shadowsocks-privoxy/ target=_blank rel=noopener>ss-privoxy</a> 等工具搭建 Docker 源代理，也可以参考<a href=https://www.jianshu.com/p/13f4b23824d8 target=_blank rel=noopener>这里</a>手动配置客户端：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker run -i -t -e <span class=nv>SERVER_ADDR</span><span class=o>=</span>ss.server.ip -e <span class=nv>SERVER_PORT</span><span class=o>=</span>port -e <span class=nv>PASSWORD</span><span class=o>=</span><span class=m>123456</span> bluebu/shadowsocks-privoxy
</span></span></code></pre></div><p>如果需要手动安装，需要先安装 sslocal 命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ apt install python3-pip
</span></span><span class=line><span class=cl>$ pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
</span></span></code></pre></div><p>写入你的配置文件到例如 <code>config.json</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;server&#34;</span><span class=p>:</span> <span class=s2>&#34;...&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;server_port&#34;</span><span class=p>:</span> <span class=err>...</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;local_port&#34;</span><span class=p>:</span> <span class=mi>1080</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;password&#34;</span><span class=p>:</span> <span class=s2>&#34;...&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;method&#34;</span><span class=p>:</span> <span class=s2>&#34;chacha20-ietf-poly1305&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;timeout&#34;</span><span class=p>:</span> <span class=mi>600</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>启动：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sslocal -c config.json
</span></span></code></pre></div><p>这时一个 socks5 代理在你本机就启动了。下面安装配置 privoxy 把他转成 http/https 代理。安装略。修改/添加两个 privoxy 的配置(对于 ubuntu, 在 /etc/privoxy/config)：</p><pre tabindex=0><code>listen-address 0.0.0.0:8118        # 所有 interface 上监听流量
forward-socks5 / 127.0.0.1:1080 .  # 流量导向本机上的 ss 代理
</code></pre><p>这时可以访问一下不存在的网站测试一下：</p><pre tabindex=0><code>HTTP_PROXY=127.0.0.1:8118 HTTPS_PROXY=127.0.0.1:8118 curl https://www.google.com
</code></pre><p>下面修改各台机器的 docker 配置(假定我们的 master 内网地址 <code>1.1.1.2</code>, 其他两台机器地址为 <code>1.1.1.3</code> 和 <code>1.1.1.4</code>)：</p><pre tabindex=0><code>[Environment]
Environment=&#34;HTTP_PROXY=127.0.0.1:8118&#34; &#34;HTTPS_PROXY=127.0.0.1:8118&#34; &#34;NO_PROXY=localhost,127.0.0.1,1.1.1.2,1.1.1.3,1.1.1.4&#34;

...
</code></pre><p>环境变量 <code>NO_PROXY</code> 顾名思义，它不支持 CIDR 应该，所以需要你枚举一下集群主机地址。</p><h3 id=存储与日志>存储与日志</h3><p>线上系统中我们往往也需要对于 Docker 产生的</p><h1 id=镜像>镜像</h1><p>镜像描述了 Docker 容器运行的初始文件系统, 包含运行应用所需的所有依赖。即可以是一个完整的操作系统, 也可以仅包含应用所需的最小 bin/lib 文件集合。Docker 镜像和容器采用分层文件系统结构, 每个容器包含一层薄薄的可写层, 只读部分是共享的，这种机制保证了资源的可复用性，减少了镜像与容器的空间占用。Docker 镜像存储引擎有 aufs, devicemapper, overlay 等多种实现。</p><h2 id=构建与拉取>构建与拉取</h2><p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code> 命令来创建镜像；关于 Dockfile 的具体语法，可以查看下文。Dockfile 基本的格式为 <code>docker build [ 选项 ] 路径</code>，该命令将读取指定路径下(包括子目录)的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 <code>.dockerignore</code> 文件(每一行添加一条匹配模式)来让 Docker 忽略路径下的目录和文件。</p><p>镜像的完整 tag 不仅包含镜像名字, 还指明了镜像从哪里来, 要到哪里去, 就像一个 URL。可以通过 <code>-t</code> 选项指定镜像的标签信息，譬如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo docker build -t myrepo/myapp /tmp/test1/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker build -t username/image_name:tag_name .
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker tag SOURCE_IMAGE<span class=o>[</span>:TAG<span class=o>]</span> TARGET_IMAGE<span class=o>[</span>:TAG<span class=o>]</span>
</span></span></code></pre></div><p>Docker 支持从 Registry 拉取镜像，或者将某个容器保存为镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 拉取镜像</span>
</span></span><span class=line><span class=cl>$ docker pull image_name
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将某个容器保存为镜像</span>
</span></span><span class=line><span class=cl>$ docker commit -m “commit message” -a “author”  container_name username/image_name:tag
</span></span></code></pre></div><p>Docker 支持将镜像保存为文件，以方便镜像的导出与加载：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 保存镜像</span>
</span></span><span class=line><span class=cl>$ docker save --output saved-image.tar my-image:1.0.0
</span></span><span class=line><span class=cl>$ docker save my-image:1.0.0 &gt; saved-image.tar
</span></span><span class=line><span class=cl>$ docker save my_image:my_tag <span class=p>|</span> gzip &gt; my_image.tar.gz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 导入镜像</span>
</span></span><span class=line><span class=cl>$ docker load --input saved-image.tar
</span></span><span class=line><span class=cl>$ docker load &lt; saved-image.tar
</span></span></code></pre></div><h2 id=镜像管理>镜像管理</h2><p><code>docker images</code> 命令会列举出全部的镜像:</p><pre tabindex=0><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
mynewimage          latest              4d2eab1c0b9a        5 minutes ago       278.1 MB
ubuntu              14.04               ad892dd21d60        11 days ago         275.5 MB
&lt;none&gt;              &lt;none&gt;              6b0a59aa7c48        11 days ago         169.4 MB
&lt;none&gt;              &lt;none&gt;              6cfa4d1f33fb        7 weeks ago         0 B
</code></pre><p>Docker 中镜像主要分为三种状态:</p><ul><li>已使用镜像(used image): 指所有已被容器（包括已停止的）关联的镜像。即 docker ps -a 看到的所有容器使用的镜像。</li><li>未引用镜像(unreferenced image): 没有被分配或使用在容器中的镜像，但它有 Tag 信息。</li><li>悬空镜像(dangling image): 未配置任何 Tag（也就无法被引用）的镜像，所以悬空。这通常是由于镜像 build 的时候没有指定 -t 参数配置 Tag 导致的。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 列举未使用的</span>
</span></span><span class=line><span class=cl>$ docker images --filter <span class=s2>&#34;dangling=true&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除所有无用的镜像</span>
</span></span><span class=line><span class=cl>$ docker rmi <span class=k>$(</span>docker images -q -f <span class=nv>dangling</span><span class=o>=</span><span class=nb>true</span><span class=k>)</span>
</span></span></code></pre></div><h2 id=dockfile>Dockfile</h2><p>Dockerfile 由一行行命令语句组成，并且支持以 <code>#</code> 开头的注释行。一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令；指令的一般格式为 <code>INSTRUCTION arguments</code>，指令包括 <code>FROM</code>、<code>MAINTAINER</code>、<code>RUN</code> 等。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># MongoDB Dockerfile</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># https://github.com/dockerfile/mongodb</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Pull base image.</span>
</span></span><span class=line><span class=cl>FROM dockerfile/ubuntu
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ENV SOURCE http://downloads-distro.mongodb.org/repo/ubuntu-upstart
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Install MongoDB.</span>
</span></span><span class=line><span class=cl>RUN <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10 <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=nb>echo</span> <span class=s1>&#39;deb $SOURCE dist 10gen&#39;</span> &gt; /etc/apt/sources.list.d/mongodb.list <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  apt-get update <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  apt-get install -y mongodb-org <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  rm -rf /var/lib/apt/lists/*
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ENV PATH /usr/local/mongo/bin:<span class=nv>$PATH</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Define mountable directories.</span>
</span></span><span class=line><span class=cl>VOLUME <span class=o>[</span><span class=s2>&#34;/data/db&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Define working directory.</span>
</span></span><span class=line><span class=cl>WORKDIR /data
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Define default command.</span>
</span></span><span class=line><span class=cl>CMD <span class=o>[</span><span class=s2>&#34;mongod&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Expose ports.</span>
</span></span><span class=line><span class=cl><span class=c1>#   - 27017: process</span>
</span></span><span class=line><span class=cl><span class=c1>#   - 28017: http</span>
</span></span><span class=line><span class=cl>EXPOSE <span class=m>27017</span>
</span></span><span class=line><span class=cl>EXPOSE <span class=m>28017</span>
</span></span></code></pre></div><p>其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。后面则是镜像操作指令，例如 <code>RUN</code> 指令，<code>RUN</code> 指令将对镜像执行跟随的命令。每运行一条 <code>RUN</code> 指令，镜像添加新的一层，并提交。最后是 <code>CMD</code> 指令，来指定运行容器时的操作命令。</p><table><thead><tr><th>指令名</th><th>格式</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>格式为 <code>FROM &lt;image></code>或<code>FROM &lt;image>:&lt;tag></code></td><td>第一条指令必须为 <code>FROM</code> 指令</td><td>如果在同一个 Dockerfile 中创建多个镜像时，可以使用多个 <code>FROM</code> 指令(每个镜像一次)</td></tr><tr><td>MAINTAINER</td><td>格式为 <code>MAINTAINER &lt;name></code></td><td>指定维护者信息，</td><td></td></tr><tr><td>RUN</td><td><code>RUN &lt;command></code>或<code>RUN ["executable", "param1", "param2"]</code></td><td>前者将在 shell 终端中运行命令，即 <code>/bin/sh -c</code>；后者则使用 <code>exec</code> 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN ["/bin/bash", "-c", "echo hello"]</code></td><td>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 <code>\</code> 来换行，</td></tr><tr><td>CMD</td><td>支持三种格式,<code>CMD ["executable","param1","param2"]</code> 使用 <code>exec</code> 执行，推荐方式；<code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；<code>CMD ["param1","param2"]</code> 提供给 <code>ENTRYPOINT</code> 的默认参数；</td><td>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 <code>CMD</code> 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令</td><td></td></tr><tr><td>EXPOSE</td><td><code>EXPOSE &lt;port> [&lt;port>...]</code></td><td>告诉 Docker 服务端容器暴露的端口号，供互联系统使用</td><td>在启动容器时需要通过 -p 来指定端口映射，Docker 主机会自动分配一个端口转发到指定的端口</td></tr><tr><td>ENV</td><td><code>ENV&lt;key>&lt;value></code>。指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持</td><td></td><td></td></tr><tr><td>ADD</td><td><code>ADD&lt;src>&lt;dest></code></td><td>该命令将复制指定的 <code>&lt;src></code> 到容器中的 <code>&lt;dest></code>，</td><td><code>&lt;src></code> 可以是 Dockerfile 所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件(自动解压为目录)</td></tr><tr><td>COPY</td><td><code>COPY &lt;src>&lt;dest></code></td><td>复制本地主机的 <code>&lt;src></code>(为 Dockerfile 所在目录的相对路径)到容器中的 <code>dest</code></td><td>当使用本地目录为源目录时，推荐使用 <code>COPY</code></td></tr><tr><td>ENTRYPOINT</td><td><code>ENTRYPOINT ["executable", "param1", "param2"]</code>，使用指定可执行文件执行；<code>ENTRYPOINT command param1 param2</code>，会在 Shell 中执行</td><td>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code>，当指定多个时，只有最后一个起效，</td><td></td></tr><tr><td>VOLUME</td><td><code>VOLUME ["/data"]</code></td><td>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等</td><td></td></tr><tr><td>USER</td><td><code>USER daemon</code></td><td>指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 也会使用指定用户</td><td></td></tr><tr><td>WORKDIR</td><td><code>WORKDIR /path/to/workdir</code></td><td>为后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令配置工作目录</td><td>可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径</td></tr></tbody></table><p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：<code>RUN groupadd -r postgres && useradd -r -g postgres postgres</code>；要临时获取管理员权限可以使用 <code>gosu</code>，而不推荐 <code>sudo</code>。</p><p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。ENTRYPOINT 配置容器启动时运行的命令。我们经常可以使用 ENTRYPOINT 指定固定命令，使用 CMD 动态传入参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;/bin/echo&#34;</span><span class=p>,</span> <span class=s2>&#34;Hello&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;world&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># docker run -it &lt;image&gt;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Hello world</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># docker run -it &lt;image&gt; John</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Hello John</span><span class=err>
</span></span></span></code></pre></div><p>Docker 推荐的是单个容器执行单个任务的关注点分离策略，容器的主进程会负责管理所有的子进程。如果我们未在自定义初始化脚本中考虑太多子进程生命周期管理的操作，那么可以使用 <code>--init</code> 参数来允许 Docker 自动注入 init 进程作为主进程，其会在容器关闭时候自动处理所有的派生的子进程，并且相对于完整的 sysvinit 或者 systemd 更为轻量级。如果我们希望在单个容器中运行多个进程，则可以使用 supervisord 或者<a href=https://docs.docker.com/config/containers/multi-service_container/ target=_blank rel=noopener>自定义脚本</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> ubuntu:latest</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> apt-get install -y supervisor<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir -p /var/log/supervisor<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> supervisord.conf /etc/supervisor/conf.d/supervisord.conf<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> my_first_process my_first_process<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> my_second_process my_second_process<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;/usr/bin/supervisord&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><h2 id=registry>Registry</h2><p>Docker 允许我们建立私有的 Registry 来存放于管理镜像，直接运行如下命令即可创建私有 Registry：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker run -d -p 5000:5000 --restart<span class=o>=</span>always --name registry registry:2
</span></span></code></pre></div><p>参考上文描述我们可知，镜像名的前缀即表示该镜像所属的 Registry 地址，因此我们可以通过 tag 方式将某个镜像推送到私有仓库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 拉取公共镜像</span>
</span></span><span class=line><span class=cl>$ docker pull ubuntu:16.04
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 为镜像添加 Registry 信息</span>
</span></span><span class=line><span class=cl>$ docker tag ubuntu:16.04 custom-domain:5000/my-ubuntu
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将其推送到私有镜像库</span>
</span></span><span class=line><span class=cl>$ docker push custom-domain:5000/my-ubuntu
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 从私有镜像库中拉取镜像</span>
</span></span><span class=line><span class=cl>$ docker pull custom-domain:5000/my-ubuntu
</span></span></code></pre></div><p>我们也可以指定镜像库的存放地址：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>-v /mnt/registry:/var/lib/registry
</span></span></code></pre></div><p>很多情况下我们的内部仓库并不会配置 HTTPS，如果希望以 HTTP 方式访问，那么需要在任何需要推送/拉取镜像的机器上配置非安全域名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span> <span class=nt>&#34;insecure-registries&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;myregistry.example.com:5000&#34;</span><span class=p>]</span> <span class=p>}</span>
</span></span></code></pre></div><p>有时候我们也需要为私有仓库配置权限认证，那么首先需要添加 TLS 支持，并且配置认证文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ mkdir auth
</span></span><span class=line><span class=cl>$ docker run <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --entrypoint htpasswd <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  registry:2 -Bbn cscan cscancscan &gt; ~/auth/htpasswd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ openssl req -new -newkey rsa:4096 -days <span class=m>365</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>                -subj <span class=s2>&#34;/CN=localhost&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>                -nodes -x509  <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>                -keyout ~/certs/domain.key <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>                -out ~/certs/domain.crt
</span></span></code></pre></div><p>然后可以使用 Compose 文件来描述所需要的 TLS 以及 AUTH 参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>registry-srv</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>restart</span><span class=p>:</span><span class=w> </span><span class=l>always</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry:2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=m>5000</span><span class=p>:</span><span class=m>5000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>REGISTRY_HTTP_TLS_CERTIFICATE</span><span class=p>:</span><span class=w> </span><span class=l>/certs/domain.crt</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>REGISTRY_HTTP_TLS_KEY</span><span class=p>:</span><span class=w> </span><span class=l>/certs/domain.key</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>REGISTRY_AUTH</span><span class=p>:</span><span class=w> </span><span class=l>htpasswd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>REGISTRY_AUTH_HTPASSWD_PATH</span><span class=p>:</span><span class=w> </span><span class=l>/auth/htpasswd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>REGISTRY_AUTH_HTPASSWD_REALM</span><span class=p>:</span><span class=w> </span><span class=l>Registry Realm</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>/opt/registry:/var/lib/registry</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>~/certs:/certs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>~/auth:/auth</span><span class=w>
</span></span></span></code></pre></div><p>接下来使用 Docker Compose 命令启动服务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker-compose up -d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 登录到镜像服务器</span>
</span></span><span class=line><span class=cl>$ docker login myregistrydomain.com:5000
</span></span></code></pre></div><h2 id=多阶段构建>多阶段构建</h2><p>随着 17.05 版本的发布，Docker 对于镜像构建这块也作了一项重要更新，那就是 multi-stage build（多阶段构建），这有助于方便源代码控制，减小镜像体积。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=c># First stage: complete build environment</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> maven:3.5.0-jdk-8-alpine AS builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># add pom.xml and source code</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> ./pom.xml pom.xml<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> ./src src/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># package jar</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mvn clean package<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Second stage: minimal runtime environment</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>From</span><span class=s> openjdk:8-jre-alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># copy jar from the first stage</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder target/msb-1.0.jar msb.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># run jar</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;java&#34;</span><span class=p>,</span> <span class=s2>&#34;-jar&#34;</span><span class=p>,</span> <span class=s2>&#34;msb.jar&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>对于 multi-stage build，其关键点主要有两点：</p><p>在前面阶段的 FROM 指令后面增加了一个 AS 参数，可为该构建阶段命名，便于后续构建阶段引用，格式如下：</p><pre tabindex=0><code>FROM image[:tag | @digest] AS stage
</code></pre><p>在后续阶段的 COPY 指令后面增加了&ndash;from 参数，指明引用前面哪一个构建阶段的成果，格式如下：</p><pre tabindex=0><code>COPY --from=stage ...
</code></pre><p>同理，多阶段构建同样可以很方便地将多个彼此依赖的项目通过一个 Dockerfile 就可轻松构建出期望的容器镜像，而不用担心镜像太大、源码泄露等风险。</p><h1 id=容器>容器</h1><p>Docker 中镜像是只读的, 创建容器时只是在镜像上面新建一个可写层, 不需要复制整个文件系统, 因而可以实现毫秒级创建。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://user-images.githubusercontent.com/5803001/45262735-4f42e400-b44f-11e8-96a0-79c305006be8.png alt=image loading=lazy data-zoomable></div></div></figure></p><h2 id=启停控制>启停控制</h2><ul><li><code>docker create</code>: 创建一个容器但是不启动。</li><li><code>docker rename</code>: 允许重命名容器。</li><li><code>docker run</code>: 在同一个操作中创建并启动一个容器。</li><li><code>docker rm</code>: 删除容器。</li><li><code>docker update</code>: 更新容器的资源限制。</li></ul><p>容器会在结束命令之后自动退出，使用以下的命令选项可以将容器保持在激活状态：</p><ul><li><p><code>-i</code> 即使在没有附着的情况下依然保持 STDIN 处于开启。单纯使用 -i 命令是不会出现 <code>root@689d580b6416:/</code> 这种前缀</p></li><li><p><code>-t</code> 分配一个伪 TTY 控制台</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 创建，并且启动某个容器以执行某个命令</span>
</span></span><span class=line><span class=cl>$ docker run -ti --name container_name image_name <span class=nb>command</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建，启动容器执行某个命令然后删除该容器</span>
</span></span><span class=line><span class=cl>$ docker run --rm -ti image_name <span class=nb>command</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建，启动容器，并且映射卷与端口，同时设置环境变量</span>
</span></span><span class=line><span class=cl>$ docker run -it --rm -p 8080:8080 -v /path/to/agent.jar:/agent.jar -e <span class=nv>JAVA_OPTS</span><span class=o>=</span>”-javaagent:/agent.jar” tomcat:8.0.29-jre8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建容器，指定网络</span>
</span></span><span class=line><span class=cl>$ docker run --network<span class=o>=</span>&lt;NETWORK&gt;
</span></span><span class=line><span class=cl><span class=c1># 直接使用宿主机的网络</span>
</span></span><span class=line><span class=cl>$ docker run --rm -d --network host --name my_nginx nginx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定标签</span>
</span></span><span class=line><span class=cl>$ docker run -l my-label --label com.example.foo<span class=o>=</span>bar ubuntu bash
</span></span></code></pre></div><p>默认情况下，创建容器时，它不会将其任何端口发布到外部世界。要使端口可用于 Docker 之外的服务或未连接到容器网络的 Docker 容器，请使用 &ndash;publish 或-p 标志。这会创建一个防火墙规则，将容器端口映射到 Docker 主机上的端口。</p><table><thead><tr><th>标志值</th><th>描述</th></tr></thead><tbody><tr><td><code>-p 8080:80</code></td><td>将容器的 80 端口映射到 Docker 主机的 8080 端口(TCP)</td></tr><tr><td><code>-p 8080:80/udp</code></td><td>将容器的 80 端口映射到 Docker 主机的 8080 端口(UDP)</td></tr><tr><td><code>-p 8080:80/tcp -p 8080:80/udp</code></td><td>将容器的 80 端口映射到 Docker 主机的 8080 端口(TCP 和 UDP)</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 启动/停止某个容器</span>
</span></span><span class=line><span class=cl>$ docker <span class=o>[</span>start<span class=p>|</span>stop<span class=o>]</span> container_name
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在某个容器内执行某条命令</span>
</span></span><span class=line><span class=cl>$ docker <span class=nb>exec</span> -ti container_name command.sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看某个容器的输出日志</span>
</span></span><span class=line><span class=cl>$ docker logs -ft container_name
</span></span></code></pre></div><h2 id=状态查询>状态查询</h2><ul><li>docker ps 查看运行中的所有容器。</li><li>docker logs 从容器中获取日志。(你也可以使用自定义日志驱动，不过在 1.10 中，它只支持 json-file 和 journald)</li><li>docker inspect 查看某个容器的所有信息(包括 IP 地址)。</li><li>docker events 从容器中获取事件(events)。</li><li>docker port 查看容器的公开端口。</li><li>docker top 查看容器中活动进程。</li><li>docker stats 查看容器的资源使用情况统计信息。</li><li>docker diff 查看容器的 FS 中有变化文件信息。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 根据条件过滤查询</span>
</span></span><span class=line><span class=cl>$ docker ps --filter <span class=s2>&#34;name=nostalgic&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示正在运行的容器列表</span>
</span></span><span class=line><span class=cl>$ docker stats --all
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 批量查看日志</span>
</span></span><span class=line><span class=cl><span class=k>for</span> i in <span class=k>$(</span>docker ps -qf <span class=nv>name</span><span class=o>=</span>wsat_slave*<span class=k>)</span><span class=p>;</span> <span class=k>do</span> <span class=nb>echo</span> <span class=s2>&#34;==================</span><span class=nv>$i</span><span class=s2>&#34;</span> <span class=o>&amp;&amp;</span> docker logs <span class=nv>$i</span>  <span class=p>|</span> grep aisec<span class=p>;</span> <span class=k>done</span>
</span></span></code></pre></div><h2 id=管理配置>管理配置</h2><p>创建容器时也可以容器的重启策略，即是当容器出错退出或者宿主机重启时候，容器的应对策略；重启策略同样会保证相关联的容器以正确的顺序重启，避免意外的错误。</p><ul><li>no: 不进行重启</li><li>on-failure: 当容器以非零状态码退出时重启容器</li><li>unless-stopped: 当某个容器被显性关闭或者 Docker 本身关闭或重启时重启</li><li>always: 无论出现任何情况都重启容器</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 设置重启策略</span>
</span></span><span class=line><span class=cl><span class=c1># Off, On-failure, Unless-stopped, Always</span>
</span></span><span class=line><span class=cl>$ docker run -dit — restart unless-stopped <span class=o>[</span>CONTAINER<span class=o>]</span>
</span></span></code></pre></div><p>可以通过多种过滤条件来进行容器的移除：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 关闭所有正在运行的容器</span>
</span></span><span class=line><span class=cl>$ docker <span class=nb>kill</span> <span class=k>$(</span>docker ps -q<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 批量重启容器</span>
</span></span><span class=line><span class=cl>$ docker restart <span class=k>$(</span>docker ps -a -q<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 根据 ID或Name 移除</span>
</span></span><span class=line><span class=cl>$ docker rm idOrName
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 移除所有停止的容器</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -a -q<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 根据状态移除</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -q -f <span class=s1>&#39;status=exited&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 根据标签移除</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -a <span class=p>|</span> grep rabbitmq <span class=p>|</span> awk <span class=s1>&#39;{print $1}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -a <span class=p>|</span> grep <span class=s2>&#34;46 hours ago&#34;</span><span class=k>)</span>
</span></span></code></pre></div><p>我们也可以对容器中的文件进行导入导出操作:</p><ul><li>docker cp 在容器和本地文件系统之间复制文件或文件夹。</li><li>docker export 将容器的文件系统切换为压缩包(tarball archive stream)输出到 STDOUT。</li></ul><h2 id=资源配额>资源配额</h2><p>我们可以使用 <code>docker stats</code> 命令来查看 Docker 容器的性能状态与资源占用:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker stats redis1 redis2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET IO             BLOCK IO
</span></span><span class=line><span class=cl>redis1              0.07%               <span class=m>796</span> KB / <span class=m>64</span> MB        1.21%               <span class=m>788</span> B / <span class=m>648</span> B       3.568 MB / <span class=m>512</span> KB
</span></span></code></pre></div><h3 id=memory>Memory</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker run -it -m 300M ubuntu:14.04 /bin/bash
</span></span></code></pre></div><h3 id=cpu>CPU</h3><p>在线上环境中，我们即希望能够尽量避免 CPU 空间时间片，最大化资源利用率，也要保障重点业务的资源占用，避免因某个异常容器占用或不合理使用整机 CPU 资源，造成宿主机上大量容器异常；此时单容器的 CPU 资源约束及上限将变得非常重要，既不能限得太死，又不能限不住，将通过内核和调度系统的限制机制来保障资源稳定性。Docker 允许使用 cpus, cpuset-cpus, cpu-shares 等来限制容器的计算资源占用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 指定容器可占用的 CPU 核编号，0-3 表示占用四个核，1,3 表示占用两个核</span>
</span></span><span class=line><span class=cl>$ docker run -it --cpuset-cpus<span class=o>=</span><span class=s2>&#34;1,3&#34;</span> ubuntu /bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 最多允许占用单 CPU 50% 的计算资源，如果双核 CPU，则可以设置为 1.5 等</span>
</span></span><span class=line><span class=cl>$ docker run -it --cpus<span class=o>=</span><span class=s2>&#34;.5&#34;</span> ubuntu /bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 不同的值能够指定不同的容器权重，用于动态分配 CPU 资源</span>
</span></span><span class=line><span class=cl>$ docker run -it --cpu-shares<span class=o>=</span><span class=s2>&#34;512&#34;</span> ubuntu /bin/bash
</span></span></code></pre></div><ul><li><p>CPU Set 保障了容器的 CPU 核数，安全性较强，但是整体资源利用率低。如果容器实际并不需要如此多核的 CPU 资源来处理任务则会造成资源浪费，并且导致其他容器上的任务无法利用该容器上的 CPU 空闲时间片，人为阻断了 CPU 闲时复用的能力。</p></li><li><p>CPU Share 允许通过共享的方式获得 CPU 资源，不同的容器共享一定总量的 CPU 计算能力，每个容器都绑定全量核，而每个容器获取一定份额的 CPU 计算力。该模式下，每个容器的 CPU 资源分配不再以整核分配，而是可精细到 CPU 时间片份额的粒度，并且是连续的 CPU 核能力值。当整机闲时，可以让较为繁忙的业务获得整机空闲。采用 CPU 资源共享的机制，其资源隔离性没有 set 模式强，对于极个别 CPU 资源敏感型业务，有可能出现偶尔等待 CPU 时间片的情况，而影响业务稳定性。对于极少数的这类业务，我们容许继续使用 CPU set 模式。</p></li></ul><h3 id=storage>Storage</h3><p>如果使用 Device Mapper 作为底层存储驱动，则可以通过 Docker daemon 的如下参数来全局限制单个容器占用空间的大小:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 限制单个容器最多占用 20G 空间，将应用于任何新建容器。</span>
</span></span><span class=line><span class=cl>$ --storage-opt dm.basesize<span class=o>=</span>20G
</span></span></code></pre></div><p>如果是 btrfs 存储驱动，可使用其提供的 subvolume 功能来实现。一个容器会对应一个 subvolume。针对容器对应的 subvolume 启用并配置 quota 即可限制其磁盘空间:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ btrfs qgroup limit -e 50G /var/lib/docker/btrfs/subvolumes/&lt;CONTAINER_ID&gt;
</span></span></code></pre></div><p>授予对单个设备访问权限:</p><pre tabindex=0><code>docker run -it --device=/dev/ttyUSB0 debian bash
</code></pre><p>授予所有设备访问权限:</p><pre tabindex=0><code>docker run -it --privileged -v /dev/bus/usb:/dev/bus/usb debian bash
</code></pre><h1 id=资源配置>资源配置</h1><h2 id=volume--数据卷>Volume | 数据卷</h2><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(Volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><p>数据卷可以在容器之间共享和重用</p></li><li><p>对数据卷的修改会立马生效</p></li><li><p>对数据卷的更新，不会影响镜像</p></li><li><p>卷会一直存在，直到没有容器使用</p></li><li><p>数据卷的使用，类似于 Linux 下对目录或文件进行 mount。</p></li></ul><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># the following creates a tmpfs volume called foo with a size of 100 megabyte and uid of 1000.</span>
</span></span><span class=line><span class=cl>$ docker volume create --driver <span class=nb>local</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --opt <span class=nv>type</span><span class=o>=</span>tmpfs <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --opt <span class=nv>device</span><span class=o>=</span>tmpfs <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --opt <span class=nv>o</span><span class=o>=</span><span class=nv>size</span><span class=o>=</span>100m,uid<span class=o>=</span><span class=m>1000</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    foo
</span></span></code></pre></div><p>nother example that uses nfs to mount the /path/to/dir in rw mode from 192.168.1.1:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker volume create --driver <span class=nb>local</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --opt <span class=nv>type</span><span class=o>=</span>nfs <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --opt <span class=nv>o</span><span class=o>=</span><span class=nv>addr</span><span class=o>=</span>192.168.1.1,rw <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --opt <span class=nv>device</span><span class=o>=</span>:/path/to/dir <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    foo
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker run -d <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -it <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --name devtest <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -v myvol2:/app <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  nginx:latest
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=s2>&#34;Mounts&#34;</span><span class=err>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Type&#34;</span><span class=p>:</span> <span class=s2>&#34;volume&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Name&#34;</span><span class=p>:</span> <span class=s2>&#34;myvol2&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Source&#34;</span><span class=p>:</span> <span class=s2>&#34;/var/lib/docker/volumes/myvol2/_data&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Destination&#34;</span><span class=p>:</span> <span class=s2>&#34;/app&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Driver&#34;</span><span class=p>:</span> <span class=s2>&#34;local&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Mode&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;RW&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Propagation&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>]</span><span class=err>,</span>
</span></span></code></pre></div><p>Docker <code>-v</code> 标记也可以指定挂载一个本地主机的目录 / 文件到容器中去：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 挂载目录</span>
</span></span><span class=line><span class=cl>$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 挂载文件</span>
</span></span><span class=line><span class=cl>$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Docker 挂载数据卷的默认权限是读写，用户也可以通过 `:ro` 指定为只读。</span>
</span></span><span class=line><span class=cl>$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro
</span></span><span class=line><span class=cl>training/webapp python app.py
</span></span></code></pre></div><p>注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>VOLUME /data</span><span class=w>
</span></span></span></code></pre></div><h2 id=network--网络>Network | 网络</h2><p>Linux 在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；Docker 利用这一特性，实现不容器间的网络隔离，并且引入 Veth 设备对来实现在不同网络命名空间的通信。Linux 系统包含一个完整的路由功能，当 IP 层在处理数据发送或转发的时候，会使用路由表来决定发往哪里。Netfilter 负责在内核中执行各种挂接的规则(过滤、修改、丢弃等)，运行在内核模式中；Iptables 模式是在用户模式下运行的进程，负责协助维护内核中 Netfilter 的各种规则表；通过二者的配合来实现整个 Linux 网络协议栈中灵活的数据包处理机制。Docker 的网络子系统采用了基于驱动的可插拔机制，其默认包含了如下驱动模式：</p><ul><li><code>bridge</code>: 默认的网络驱动，常用于多个应用运行与独立容器中并且需要相互通讯的时候。</li><li><code>host</code>: 移除容器与 Docker 主机之间的网络隔离，直接使用宿主机所在的网络。底层与宿主机共用一个 Network Namespace，容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</li><li><code>overlay</code>: Overlay 网络用语连接多个 Docker Daemon，保证 Docker Swarm 服务的正常运行；独立的容器与 Swarm 服务，或者不同宿主机上的容器同样能够通过 Overlay 进行通信。</li><li><code>none</code>: 对于指定容器禁止所有的网络通信。</li><li><code>macvlan</code>: Macvlan 网络会允许直接为容器分配 MAC 地址，使其作为真正的物理设备接入到宿主机所在的网络中。</li></ul><p>我们使用 network 命令可以查看到默认的网络：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker network ls
</span></span><span class=line><span class=cl>NETWORK ID          NAME                DRIVER              SCOPE
</span></span><span class=line><span class=cl>f707aa0ef50d        bridge              bridge              <span class=nb>local</span>
</span></span><span class=line><span class=cl>97dd7a032d96        host                host                <span class=nb>local</span>
</span></span><span class=line><span class=cl>d5a1bed0b12d        none                null                <span class=nb>local</span>
</span></span></code></pre></div><p>桥接模式下，当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，即软件交换机，在挂载到它的网口之间进行转发。同时，Docker 随机分配一个本地未占用的私有网段(在 RFC1918 中定义)中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。</p><p>桥接模式下，创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口(当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包)。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头(例如 vethAQI2QT)。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 创建新的网络</span>
</span></span><span class=line><span class=cl>$ docker network create --driver bridge isolated
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定网段，宿主机会作为默认网关</span>
</span></span><span class=line><span class=cl>$ docker network create --driver<span class=o>=</span>bridge --subnet<span class=o>=</span>192.168.2.0/24 --gateway<span class=o>=</span>192.168.2.10 new_subnet
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建时将某个容器连接到网络</span>
</span></span><span class=line><span class=cl>$ docker run --network<span class=o>=</span>isolated -itd --name<span class=o>=</span>docker-nginx nginx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将某个运行中容器连接到某个网络，在该网络内可以通过容器名自由访问</span>
</span></span><span class=line><span class=cl>$ docker network connect multi-host-network container1
</span></span></code></pre></div><h3 id=dns>DNS</h3><p>默认情况下，容器从 Docker 守护进程继承 DNS 设置，包括 /etc/hosts 和 /etc/resolv.conf。可以基于每个容器覆盖这些设置。</p><ul><li>-h HOSTNAME or &ndash;hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker ps 中显示，也不会在其他的容器的 /etc/hosts 看到。</li><li>&ndash;link=CONTAINER_NAME:ALIAS 选项会在创建容器的时候，添加一个其他容器的主机名到 /etc/hosts 文件中，让新容器的进程可以使用主机名 ALIAS 就可以连接它。</li><li>&ndash;dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</li><li>&ndash;dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS 不仅搜索 host，还会搜索 host.example.com。注意：如果没有上述最后 2 个选项，Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。</li></ul><h2 id=空间清理>空间清理</h2><p>Docker 使用过程中，可能会发现宿主节点的磁盘容量持续增长，譬如 volume 或者 overlay2 目录占用了大量的空间；如果任其发展，可能将磁盘空间耗尽进而引发宿主机异常，进而对业务造成影响。Docker 的内置 df 指令可用于查询镜像(Images)、容器(Containers)和本地卷(Local Volumes)等空间使用大户的空间占用情况。而容器的占用的总空间，包含其最顶层的读写层(writable layer)和底部的只读镜像层(base image layer，read-only)，我们可以使用 <code>ps -s</code> 参数来显示二者的空间占用情况:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 查看当前目录下的文件空间占用</span>
</span></span><span class=line><span class=cl>$ du -h --max-depth<span class=o>=</span><span class=m>1</span> <span class=p>|</span> sort
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 空间占用总体分析</span>
</span></span><span class=line><span class=cl>$ docker system df
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输出空间占用细节</span>
</span></span><span class=line><span class=cl>$ docker system df -v
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输出容器的空间占用</span>
</span></span><span class=line><span class=cl>$ docker ps -s
</span></span></code></pre></div><p><code>docker system prune</code> 指令能够进行自动地空间清理，其默认会清除已停止的容器、未被任何容器所使用的卷、未被任何容器所关联的网络、所有悬空镜像:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 一并清除所有未使用的镜像和悬空镜像</span>
</span></span><span class=line><span class=cl>$ docker system prune --all
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 列举悬空镜像</span>
</span></span><span class=line><span class=cl>$ docker images -f <span class=nv>dangling</span><span class=o>=</span><span class=nb>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除全部悬空镜像</span>
</span></span><span class=line><span class=cl>$ docker image prune
</span></span><span class=line><span class=cl><span class=c1># 删除所有未被使用的镜像</span>
</span></span><span class=line><span class=cl>$ docker image prune -a
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除指定模式的镜像</span>
</span></span><span class=line><span class=cl>$ docker images -a <span class=p>|</span> grep <span class=s2>&#34;pattern&#34;</span> <span class=p>|</span> awk <span class=s1>&#39;{print $3}&#39;</span> <span class=p>|</span> xargs docker rmi
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除全部镜像</span>
</span></span><span class=line><span class=cl>$ docker rmi <span class=k>$(</span>docker images -a -q<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除全部停止的容器</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -a -f <span class=nv>status</span><span class=o>=</span>exited -q<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 根据指定模式删除容器</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -a -f <span class=nv>status</span><span class=o>=</span>exited -f <span class=nv>status</span><span class=o>=</span>created -q<span class=k>)</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -a <span class=p>|</span> grep rabbitmq <span class=p>|</span> awk <span class=s1>&#39;{print $1}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除全部容器</span>
</span></span><span class=line><span class=cl>$ docker stop <span class=k>$(</span>docker ps -a -q<span class=k>)</span>
</span></span><span class=line><span class=cl>$ docker rm <span class=k>$(</span>docker ps -a -q<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 列举并删除未被使用的卷</span>
</span></span><span class=line><span class=cl>$ docker volume ls -f <span class=nv>dangling</span><span class=o>=</span><span class=nb>true</span>
</span></span><span class=line><span class=cl>$ docker volume prune
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 根据指定的模式删除卷</span>
</span></span><span class=line><span class=cl>$ docker volume prune --filter <span class=s2>&#34;label!=keep&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除未被关联的网络</span>
</span></span><span class=line><span class=cl>$ docker network prune
</span></span><span class=line><span class=cl>$ docker network prune --filter <span class=s2>&#34;until=24h&#34;</span>
</span></span></code></pre></div><p>我们也可以手动指定日志文件的尺寸或者清空日志文件:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 设置日志文件最大尺寸</span>
</span></span><span class=line><span class=cl>$ dockerd ... --log-opt max-size<span class=o>=</span>10m --log-opt max-file<span class=o>=</span><span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 清空当前日志文件</span>
</span></span><span class=line><span class=cl>truncate -s <span class=m>0</span> /var/lib/docker/containers/*/*-json.log
</span></span></code></pre></div><h1 id=服务治理>服务治理</h1><h2 id=docker-compose>Docker Compose</h2><p>Docker Compose 是用于定义和运行复杂 Docker 应用的工具。你可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成；简单的 Compose 文件定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># 指定 Docker Compose 文件版本</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>web</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 指定从本地目录进行编译</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 指定导出端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;5000:5000&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 替换默认的 CMD 命令</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=l>python app.py</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 将本地目录绑定到容器内目录</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>.:/code</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>redis</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 镜像的 ID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;redis:alpine&#34;</span><span class=w>
</span></span></span></code></pre></div><p>这里用到的 Python Web 应用的 Dockerfile 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> python:3.4-alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> . /code<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /code</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pip install -r requirements.txt<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;python&#34;</span><span class=p>,</span> <span class=s2>&#34;app.py&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>值得注意的是，我们在代码中直接使用服务名作为连接地址，即可访问到 Redis 数据库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>cache</span> <span class=o>=</span> <span class=n>redis</span><span class=o>.</span><span class=n>Redis</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;redis&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>6379</span><span class=p>)</span>
</span></span></code></pre></div><p>然后使用 docker-compose 命令启动：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 交互式启动</span>
</span></span><span class=line><span class=cl>$ docker-compose up
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 守护进程式启动</span>
</span></span><span class=line><span class=cl>$ docker-compose up -d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看运行情况</span>
</span></span><span class=line><span class=cl>$ docker-compose ps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 关闭</span>
</span></span><span class=line><span class=cl>$ docker-compose stop
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 移除内部卷</span>
</span></span><span class=line><span class=cl>$ docker-compose down --volumes
</span></span></code></pre></div><p>在涉及到数据存储的场景下，我们同样可以指定 docker-compose 创建命名数据卷，并将其挂载到容器中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>web</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:alpine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>source</span><span class=p>:</span><span class=w> </span><span class=l>mydata</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>target</span><span class=p>:</span><span class=w> </span><span class=l>/data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volume</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>nocopy</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>bind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>source</span><span class=p>:</span><span class=w> </span><span class=l>./static</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>target</span><span class=p>:</span><span class=w> </span><span class=l>/opt/app/static</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>db</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>postgres:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;dbdata:/var/lib/postgresql/data&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>mydata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>dbdata</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></div><p>如果某个数据卷天然需要映射到本地文件，则可以指定 driver 的类型为 local:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>wsat_etc</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>driver</span><span class=p>:</span><span class=w> </span><span class=l>local</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>driver_opts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>o</span><span class=p>:</span><span class=w> </span><span class=l>bind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>none</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>device</span><span class=p>:</span><span class=w> </span><span class=l>/etc/wsat/</span><span class=w>
</span></span></span></code></pre></div><h2 id=docker-swarm-1>Docker Swarm</h2><p>Swarm 是 Docker 公司在 2014 年 12 月初发布的一套较为简单的工具，用来管理 Docker 集群，它将一群 Docker 宿主机变成一个单一的，虚拟的主机。Swarm 使用标准的 Docker API 接口作为其前端访问入口，换言之，各种形式的 Docker Client(dockerclient in go, docker_py, docker 等)均可以直接与 Swarm 通信。</p><p>Swarm Deamon 只是一个调度器(Scheduler)和路由器(Router)，Swarm 自己不运行容器，它只是接受 Docker 客户端发送过来的请求，调度适合的节点来运行容器，这意味着，即使 Swarm 由于某些原因挂掉了，集群中的节点也会照常运行，当 Swarm 重新恢复运行之后，它会收集重建集群信息。并且 Swarm 提供的路由匹配(服务发现、负载均衡、跨容器通讯)非常可靠。在单个端口上运行一个服务，Swarm 节点的任意主机都可以访问，负载均衡完全在后台实现。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://user-images.githubusercontent.com/5803001/44953944-dfbc7a00-aecd-11e8-93dc-1fe6258aafd0.png alt=image loading=lazy data-zoomable></div></div></figure></p><p>Swarm 在 Scheduler 节点运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：Random, Binpack, Spread。</p><p>Random 顾名思义，就是随机选择一个 Node 来运行容器，一般用作调试用。Spread 和 Binpack 策略会根据各个节点的可用的 CPU, RAM 以及正在运行的容器的数量来计算应该运行容器的节点。在同等条件下，Spread 策略会选择运行容器最少的那台节点来运行新的容器，Binpack 策略会选择运行容器最集中的那台机器来运行新的节点。</p><p>使用 Spread 策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。Binpack 策略最大化的避免容器碎片化，就是说 Binpack 策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在一个节点上面。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 创建一个新的服务</span>
</span></span><span class=line><span class=cl>$ docker service create <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--image nginx <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--replicas <span class=m>2</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>nginx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 更新服务</span>
</span></span><span class=line><span class=cl>$ docker service update <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--image nginx:alpine <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>nginx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除服务</span>
</span></span><span class=line><span class=cl>$ docker service rm nginx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 缩容，而不是直接删除服务</span>
</span></span><span class=line><span class=cl>$ docker service scale <span class=nv>nginx</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 扩容</span>
</span></span><span class=line><span class=cl>$ docker service scale <span class=nv>nginx</span><span class=o>=</span><span class=m>5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 列出所有的服务</span>
</span></span><span class=line><span class=cl>$ docker service ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 列出一个服务的所有实例(包括服务的健康状况)</span>
</span></span><span class=line><span class=cl>$ docker service ps nginx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 服务的详细信息</span>
</span></span><span class=line><span class=cl>$ docker service inspect nginx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 增加和删除DNS</span>
</span></span><span class=line><span class=cl>$ docker service update --dns-add 222.222.222.222 tender_hofstadter
</span></span><span class=line><span class=cl>$ docker service update --dns-rm 222.222.222.222 tender_hofstadter
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 增加和删除端口映射</span>
</span></span><span class=line><span class=cl>$ docker service update --publish-add 80:80 xenodochial_ritchie
</span></span><span class=line><span class=cl>$ docker service update --publish-rm 80:80 xenodochial_ritchie
</span></span></code></pre></div><p>我们也可以使用 Docker Compose 的脚本来进行批次部署：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker stack deploy application
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>web</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/example/example</span><span class=w> </span><span class=c># you need to use external image</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=l>npm run prod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>80</span><span class=p>:</span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>deploy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>6</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>update_config</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>parallelism</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>delay</span><span class=p>:</span><span class=w> </span><span class=l>10s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>restart_policy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>condition</span><span class=p>:</span><span class=w> </span><span class=kc>on</span>-<span class=l>failure</span><span class=w>
</span></span></span></code></pre></div></div><div class=article-widget><div class="container-xl row post-nav"></div></div><div class=body-footer><p>最近更新于 2023-04-16</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div><script type=text/javascript id=clstr_globe async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>