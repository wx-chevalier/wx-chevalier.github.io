<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="组件驱动开发 Component Driven Development is a way of building user interfaces (UIs) by starting with their smallest parts: the components. Emphasis on components is a theme in UI development that has been gaining momentum since the introduction of modern UI libraries like React. CDD denotes a set of tools (such as React Storybook) and a way of developing applications to really take advantage of this change in emphasis. Some advantages of CDD include: The ability to parallelize work as different people work on different components. The ability to use a “Visu"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.fab3cd1900ae35687457073b2d518207.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"><meta property="og:title" content="组件驱动开发 | Next-gen Tech Edu"><meta property="og:description" content="组件驱动开发 Component Driven Development is a way of building user interfaces (UIs) by starting with their smallest parts: the components. Emphasis on components is a theme in UI development that has been gaining momentum since the introduction of modern UI libraries like React. CDD denotes a set of tools (such as React Storybook) and a way of developing applications to really take advantage of this change in emphasis. Some advantages of CDD include: The ability to parallelize work as different people work on different components. The ability to use a “Visu"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>组件驱动开发 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=8e1d841c7e4a4ca1056a7312d99a147a><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">组件化</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id803d7b873e27dabf2a818e2992be3a1e")' href=#id803d7b873e27dabf2a818e2992be3a1e aria-expanded=false aria-controls=id803d7b873e27dabf2a818e2992be3a1e aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/>03.组件化与模块化</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id803d7b873e27dabf2a818e2992be3a1e aria-expanded=false aria-controls=id803d7b873e27dabf2a818e2992be3a1e><i class="fa-solid fa-angle-down" id=caret-id803d7b873e27dabf2a818e2992be3a1e></i></a></div><ul class="nav docs-sidenav collapse show" id=id803d7b873e27dabf2a818e2992be3a1e><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id0b376297ea57355147b6464d2fb4777a")' href=#id0b376297ea57355147b6464d2fb4777a aria-expanded=false aria-controls=id0b376297ea57355147b6464d2fb4777a aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idcbee11b38b4926b98bef5d8df84d6b08")' href=#idcbee11b38b4926b98bef5d8df84d6b08 aria-expanded=false aria-controls=idcbee11b38b4926b98bef5d8df84d6b08 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E5%8E%9F%E5%AD%90-css/>原子 CSS</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idcbee11b38b4926b98bef5d8df84d6b08 aria-expanded=false aria-controls=idcbee11b38b4926b98bef5d8df84d6b08><i class="fa-solid fa-angle-right" id=caret-idcbee11b38b4926b98bef5d8df84d6b08></i></a></div><ul class="nav docs-sidenav collapse" id=idcbee11b38b4926b98bef5d8df84d6b08><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E5%8E%9F%E5%AD%90-css/tailwindcss/>TailwindCSS</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idc66f903a4ae392d2287d4bb2a7177e55")' href=#idc66f903a4ae392d2287d4bb2a7177e55 aria-expanded=false aria-controls=idc66f903a4ae392d2287d4bb2a7177e55 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BA%A6%E5%AE%9A%E5%91%BD%E5%90%8D/>约定命名</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idc66f903a4ae392d2287d4bb2a7177e55 aria-expanded=false aria-controls=idc66f903a4ae392d2287d4bb2a7177e55><i class="fa-solid fa-angle-right" id=caret-idc66f903a4ae392d2287d4bb2a7177e55></i></a></div><ul class="nav docs-sidenav collapse" id=idc66f903a4ae392d2287d4bb2a7177e55><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BA%A6%E5%AE%9A%E5%91%BD%E5%90%8D/bem/>BEM</a></li><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BA%A6%E5%AE%9A%E5%91%BD%E5%90%8D/oocss/>OOCSS</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide3484aaf3b85ae9ff8c6ae0f5d03ac72")' href=#ide3484aaf3b85ae9ff8c6ae0f5d03ac72 aria-expanded=false aria-controls=ide3484aaf3b85ae9ff8c6ae0f5d03ac72 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%9B%BD%E9%99%85%E5%8C%96/>主题与国际化</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide3484aaf3b85ae9ff8c6ae0f5d03ac72 aria-expanded=false aria-controls=ide3484aaf3b85ae9ff8c6ae0f5d03ac72><i class="fa-solid fa-angle-right" id=caret-ide3484aaf3b85ae9ff8c6ae0f5d03ac72></i></a></div><ul class="nav docs-sidenav collapse" id=ide3484aaf3b85ae9ff8c6ae0f5d03ac72><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%9B%BD%E9%99%85%E5%8C%96/formatjs/>FormatJS</a></li><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%9B%BD%E9%99%85%E5%8C%96/internationalization-api/>Internationalization API</a></li><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%9B%BD%E9%99%85%E5%8C%96/%E5%8A%A8%E6%80%81%E4%B8%BB%E9%A2%98/>动态主题</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idfc183b93acc8f41ad738cd011cc39998")' href=#idfc183b93acc8f41ad738cd011cc39998 aria-expanded=false aria-controls=idfc183b93acc8f41ad738cd011cc39998 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/>组件化</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idfc183b93acc8f41ad738cd011cc39998 aria-expanded=false aria-controls=idfc183b93acc8f41ad738cd011cc39998><i class="fa-solid fa-angle-down" id=caret-idfc183b93acc8f41ad738cd011cc39998></i></a></div><ul class="nav docs-sidenav collapse show" id=idfc183b93acc8f41ad738cd011cc39998><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/>依赖注入</a></li><li class="child level"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E8%A7%84%E8%8C%83/>组件规范</a></li><li class="child level active"><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/>组件驱动开发</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#组件规范>组件规范</a><ul><li><a href=#合理使用对象结构与属性扩展>合理使用对象结构与属性扩展</a></li></ul></li><li><a href=#jsx-规范>JSX 规范</a></li><li><a href=#方法规范>方法规范</a><ul><li><a href=#使用箭头函数减少冗余代码>使用箭头函数减少冗余代码</a></li></ul></li><li><a href=#input>Input</a></li><li><a href=#output>Output</a></li></ul><ul><li><a href=#使用-react-的childrenapi>使用 React 的<code>children</code>API</a></li><li><a href=#将子组件以属性方式传入>将子组件以属性方式传入</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>组件驱动开发</h1><div class=article-style><h1 id=组件驱动开发>组件驱动开发</h1><p>Component Driven Development is a way of building user interfaces (UIs) by starting with their smallest parts: the components. Emphasis on components is a theme in UI development that has been gaining momentum since the introduction of modern UI libraries like React.</p><p>CDD denotes a set of tools (such as React Storybook) and a way of developing applications to really take advantage of this change in emphasis. Some advantages of CDD include:</p><ul><li>The ability to parallelize work as different people work on different components.</li><li>The ability to use a “Visual TDD” approach to allow building UIs in a more rigorous fashion.</li><li>Increased communication opportunities between designers and other product people and the developers building the components.</li><li>Reuse of components between applications and features.</li></ul><p>I’ll talk more about why I think CDD is great in future posts, but hopefully some of these advantages will become clear as we develop our todo list app.</p><h1 id=组件代码风格>组件代码风格</h1><p>本小节我们关注如何写出漂亮的组件，你或许可以认为萝卜青菜各有所爱，但是代码本身是应当保证其可读性，特别是在一个团队中，你的代码是注定要被其他人阅读的。计算机是不会在意这些的，不管你朝它们扔过去什么，它们都会老老实实的解释，但是你的队友们可不会这样，他们会把丑陋的代码扔回到你的脸上。一般来说，漂亮的组件应该具备以下特征：</p><ul><li>即使没有任何注释的情况下也易于理解</li><li>比乱麻般的代码有更好的性能表现</li><li>更易于进行 Bug 追溯</li><li>简洁明了，一句顶一万句</li></ul><p>在讨论语法的语法细节之前，我们应该遵循如下的基本原则：</p><p>-  每个文件中只包含一个 React 组件。
-  尽可能地使用 JSX 语法。
-  除非不用 JSX 语法创建一个应用，否则不要使用<code>React.createElement</code>方法。</p><h2 id=组件规范>组件规范</h2><p>### Class 与 React.createClass 方法</p><p>尽可能地使用 ES6 中的类的语法，除非有特殊的对于 Mixin 的需求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>Listing</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>createClass</span><span class=p>({</span>
</span></span><span class=line><span class=cl>  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>Listing</span> <span class=kr>extends</span> <span class=nx>React</span><span class=p>.</span><span class=nx>Component</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>###  组件命名</p><p>-  扩展名：使用.jsx 作为 React 组件的扩展名。
-  文件名：使用帕斯卡命名法命名文件，譬如 ReservationCard.jsx。
-  引用命名：使用帕斯卡命名法命名组件和 camelCase 命名实例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>reservationCard</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;./ReservationCard&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>ReservationCard</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;./ReservationCard&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>ReservationItem</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>ReservationCard</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>reservationItem</span> <span class=o>=</span> <span class=o>&lt;</span><span class=nx>ReservationCard</span> <span class=o>/&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p>### Props</p><p>-  对于 Props 的命名使用 camelCase。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=nx>Foo</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>UserName</span><span class=o>=</span><span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>phone_number</span><span class=o>=</span><span class=p>{</span><span class=mi>12345678</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=err>/&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=nx>Foo</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>userName</span><span class=o>=</span><span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>phoneNumber</span><span class=o>=</span><span class=p>{</span><span class=mi>12345678</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=err>/&gt;</span>
</span></span></code></pre></div><p>-  将 Props 或者 State 的声明写在类外。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>import</span> <span class=nx>React</span><span class=p>,</span> <span class=p>{</span> <span class=nx>Component</span><span class=p>,</span> <span class=nx>PropTypes</span> <span class=p>}</span> <span class=nx>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>propTypes</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>id</span><span class=o>:</span> <span class=nx>PropTypes</span><span class=p>.</span><span class=nx>number</span><span class=p>.</span><span class=nx>isRequired</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>url</span><span class=o>:</span> <span class=nx>PropTypes</span><span class=p>.</span><span class=nx>string</span><span class=p>.</span><span class=nx>isRequired</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>text</span><span class=o>:</span> <span class=nx>PropTypes</span><span class=p>.</span><span class=nx>string</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>defaultProps</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>text</span><span class=o>:</span> <span class=s2>&#34;Hello World&#34;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=k>default</span> <span class=kr>class</span> <span class=nx>Link</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>static</span> <span class=nx>methodsAreOk</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=nx>a</span> <span class=nx>href</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>url</span><span class=p>}</span> <span class=nx>data</span><span class=o>-</span><span class=nx>id</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>text</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=err>/a&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>Link</span><span class=p>.</span><span class=nx>propTypes</span> <span class=o>=</span> <span class=nx>propTypes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>Link</span><span class=p>.</span><span class=nx>defaultProps</span> <span class=o>=</span> <span class=nx>defaultProps</span><span class=p>;</span>
</span></span></code></pre></div><p>### Declaration(声明)</p><p>-  不要使用 displayName 来命名组件，而使用引用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span><span class=err> </span><span class=k>default</span><span class=err> </span><span class=nx>React</span><span class=p>.</span><span class=nx>createClass</span><span class=p>({</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>displayName</span><span class=o>:</span><span class=err> </span><span class=s1>&#39;ReservationCard&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=c1>// stuff goes here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>export</span><span class=err> </span><span class=k>default</span><span class=err> </span><span class=kr>class</span><span class=err> </span><span class=nx>ReservationCard</span><span class=err> </span><span class=kr>extends</span><span class=err> </span><span class=nx>React</span><span class=p>.</span><span class=nx>Component</span><span class=err> </span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=合理使用对象结构与属性扩展>合理使用对象结构与属性扩展</h3><p>大的组件往往受困于<code>this.props</code>过长的窘境，典型的如下所示:</p><pre tabindex=0><code>render() {
  return (
  &lt;ProductPrice
  hidePriceFulfillmentDisplay=
 {this.props.hidePriceFulfillmentDisplay}
  primaryOffer={this.props.primaryOffer}
  productType={this.props.productType}
  productPageUrl={this.props.productPageUrl}
  inventory={this.props.inventory}
  submapType={this.props.submapType}
  ppu={this.props.ppu}
  isLoggedIn={this.props.isLoggedIn}
  gridView={this.props.isGridView}
  /&gt;
  );
}
</code></pre><p>这么多的 Props 估计看着都头疼，如果我们要将这些 Props 继续传入下一层，大概就要变成下面这个样子了:</p><pre tabindex=0><code>render() {
  const {
  hidePriceFulfillmentDisplay,
  primaryOffer,
  productType,
  productPageUrl,
  inventory,
  submapType,
  ppu,
  isLoggedIn,
  gridView
  } = this.props;
  return (
  &lt;ProductPrice
  hidePriceFulfillmentDisplay={hidePriceFulfillmentDisplay}
  primaryOffer={primaryOffer}
  productType={productType}
  productPageUrl={productPageUrl}
  inventory={inventory}
  submapType={submapType}
  ppu={ppu}
  isLoggedIn={isLoggedIn}
  gridView={isGridView}
  /&gt;
  );
}
</code></pre><p>暂时不考虑 unKnown Props，我们可以使用解构赋值来实现这个功能:</p><pre tabindex=0><code>render() {
  const props = this.props;
  return &lt;ProductPrice {...props} /&gt;
}
</code></pre><h2 id=jsx-规范>JSX 规范</h2><p>### Alignment(对齐)</p><p>-  跟随如下的 JSX 的语法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=nx>Foo</span><span class=err> </span><span class=nx>superLongParam</span><span class=o>=</span><span class=s2>&#34;bar&#34;</span>
</span></span><span class=line><span class=cl><span class=err>     </span><span class=nx>anotherSuperLongParam</span><span class=o>=</span><span class=s2>&#34;baz&#34;</span><span class=err> </span><span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=nx>Foo</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>superLongParam</span><span class=o>=</span><span class=s2>&#34;bar&#34;</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>anotherSuperLongParam</span><span class=o>=</span><span class=s2>&#34;baz&#34;</span>
</span></span><span class=line><span class=cl><span class=err>/&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// if props fit in one line then keep it on the same line
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=nx>Foo</span><span class=err> </span><span class=nx>bar</span><span class=o>=</span><span class=s2>&#34;bar&#34;</span><span class=err> </span><span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// children get indented normally
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=nx>Foo</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>superLongParam</span><span class=o>=</span><span class=s2>&#34;bar&#34;</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>anotherSuperLongParam</span><span class=o>=</span><span class=s2>&#34;baz&#34;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=o>&lt;</span><span class=nx>Spazz</span><span class=err> </span><span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=err>/Foo&gt;</span>
</span></span></code></pre></div><p>### Quotes</p><p>对于 JSX 的属性用双引号表示，对于其他属性，用单引号表示。</p><pre tabindex=0><code>// bad
&lt;Foo bar=&#39;bar&#39; /&gt;

// good
&lt;Foo bar=&#34;bar&#34; /&gt;

// bad
&lt;Foo style={{ left: &#34;20px&#34; }} /&gt;

// good
&lt;Foo style={{ left: &#39;20px&#39; }} /&gt;
</code></pre><p>### Spacing(空格)</p><p>-  在自闭合的标签中仅使用单空格。</p><pre tabindex=0><code>// bad
&lt;Foo/&gt;

// very bad
&lt;Foo                 /&gt;

// bad
&lt;Foo
 /&gt;

// good
&lt;Foo /&gt;
</code></pre><p>###  多段</p><p>-  当 JSX 包含多行代码时，将它们包含在小括号中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>/// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>render</span><span class=p>()</span><span class=err> </span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=k>return</span><span class=err> </span><span class=o>&lt;</span><span class=nx>MyComponent</span><span class=err> </span><span class=nx>className</span><span class=o>=</span><span class=s2>&#34;long body&#34;</span><span class=err> </span><span class=nx>foo</span><span class=o>=</span><span class=s2>&#34;bar&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=err>           </span><span class=o>&lt;</span><span class=nx>MyChild</span><span class=err> </span><span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=err>         </span><span class=o>&lt;</span><span class=err>/MyComponent&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>render</span><span class=p>()</span><span class=err> </span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=k>return</span><span class=err> </span><span class=p>(</span>
</span></span><span class=line><span class=cl><span class=err>    </span><span class=o>&lt;</span><span class=nx>MyComponent</span><span class=err> </span><span class=nx>className</span><span class=o>=</span><span class=s2>&#34;long body&#34;</span><span class=err> </span><span class=nx>foo</span><span class=o>=</span><span class=s2>&#34;bar&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=err>      </span><span class=o>&lt;</span><span class=nx>MyChild</span><span class=err> </span><span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=err>    </span><span class=o>&lt;</span><span class=err>/MyComponent&gt;</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good, when single line
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>render</span><span class=p>()</span><span class=err> </span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=kr>const</span><span class=err> </span><span class=nx>body</span><span class=err> </span><span class=o>=</span><span class=err> </span><span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=nx>hello</span><span class=o>&lt;</span><span class=err>/div&gt;;</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=k>return</span><span class=err> </span><span class=o>&lt;</span><span class=nx>MyComponent</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>body</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/MyComponent&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=方法规范>方法规范</h2><p>### Naming(方法命名)</p><p>-  对于一个 React 组件的内部方法，不要使用下划线作为前缀。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// bad
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>React</span><span class=p>.</span><span class=nx>createClass</span><span class=p>({</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>_onClickSubmit</span><span class=p>()</span><span class=err> </span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=err>    </span><span class=c1>// do stuff
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>  </span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=c1>// other stuff
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span><span class=err> </span><span class=kr>extends</span><span class=err> </span><span class=nx>React</span><span class=p>.</span><span class=nx>Component</span><span class=err> </span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=nx>onClickSubmit</span><span class=p>()</span><span class=err> </span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=err>    </span><span class=c1>// do stuff
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>  </span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>  </span><span class=c1>// other stuff
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span></code></pre></div><p>### Ordering(顺序)</p><p>- React.Component 子类</p><p>1. constructor
2. optional static methods
3. getChildContext
4. componentWillMount
5. componentDidMount
6. componentWillReceiveProps
7. shouldComponentUpdate
8. componentWillUpdate
9. componentDidUpdate
10. componentWillUnmount
11. <em>clickHandlers or eventHandlers</em> like onClickSubmit() or onChangeDescription()
12. <em>getter methods for render</em> like getSelectReason() or getFooterContent()
13. <em>Optional render methods</em> like renderNavigation() or renderProfilePicture()
14. render</p><p>- React.createClass</p><p>1. displayName
2. propTypes
3. contextTypes
4. childContextTypes
5. mixins
6. statics
7. defaultProps
8. getDefaultProps
9. getInitialState
10. getChildContext
11. componentWillMount
12. componentDidMount
13. componentWillReceiveProps
14. shouldComponentUpdate
15. componentWillUpdate
16. componentDidUpdate
17. componentWillUnmount
18. <em>clickHandlers or eventHandlers</em> like onClickSubmit() or onChangeDescription()
19. <em>getter methods for render</em> like getSelectReason() or getFooterContent()
20. <em>Optional render methods</em> like renderNavigation() or renderProfilePicture()
21. render</p><h3 id=使用箭头函数减少冗余代码>使用箭头函数减少冗余代码</h3><p>箭头函数是 ES6 引入的新特性之一，其不仅可以帮我们避免手动绑定<code>this</code>指针，还能让我们不用声明过多的<code>function</code>关键字，譬如我觉得非常适用 Arrow Function 的地方就是 Redux 的 mapStateToProps 函数:</p><pre tabindex=0><code>const mapStateToProps = ({isLoading}) =&gt; {
  return ({
  loading: isLoading,
  });
};
</code></pre><p>需要注意的是，如果你返回的是 Object，你需要包裹在大括号内:</p><pre tabindex=0><code>const mapStateToProps = ({isLoading}) =&gt; ({
  loading: isLoading
});
</code></pre><p># Communication
React 组件一个很大的特性在于其拥有自己完整的生命周期，因此我们可以将 React 组件视作可自运行的小型系统，它拥有自己的内部状态、输入与输出。</p><h2 id=input>Input</h2><p>对于 React 组件而言，其输入的来源就是 Props，我们会用如下方式向某个 React 组件传入数据:</p><pre tabindex=0><code class=language-// data-lang=//>class Title extends React.Component {
  render() {
    return &lt;h1&gt;{ this.props.text }&lt;/h1&gt;;
  }
};
Title.propTypes = {
  text: React.PropTypes.string
};
Title.defaultProps = {
  text: &#39;Hello world&#39;
};

// App.jsx
class App extends React.Component {
  render() {
    return &lt;Title text=&#39;Hello React&#39; /&gt;;
  }
};
</code></pre><p><code>text</code>是<code>Text</code>组件自己的输入域，父组件<code>App</code>在使用子组件<code>Title</code>时候应该提供<code>text</code>属性值。除了标准的属性名之外，我们还会用到如下两个设置:</p><ul><li>propTypes:用于定义 Props 的类型，这有助于追踪运行时误设置的 Prop 值。</li><li>defaultProps:定义 Props 的默认值，这个在开发时很有帮助</li></ul><p>Props 中还有一个特殊的属性<code>props.children</code>可以允许我们使用子组件:</p><pre tabindex=0><code class=language-class data-lang=class>  render() {
    return (
      &lt;h1&gt;
        { this.props.text }
        { this.props.children }
      &lt;/h1&gt;
    );
  }
};

class App extends React.Component {
  render() {
    return (
      &lt;Title text=&#39;Hello React&#39;&gt;
        &lt;span&gt;community&lt;/span&gt;
      &lt;/Title&gt;
    );
  }
};
</code></pre><p>注意，如果我们不主动在<code>Title</code>组件的<code>render</code>函数中设置<code>{this.props.children}</code>，那么<code>span</code>标签是不会被渲染出来的。除了 Props 之外，另一个隐性的组件的输入即是<code>context</code>，整个 React 组件树会拥有一个<code>context</code>对象，它可以被树中挂载的每个组件所访问到，关于此部分更多的内容请参考<a href=https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection target=_blank rel=noopener>依赖注入</a>这一章节。</p><h2 id=output>Output</h2><p>组件最明显的输出就是渲染后的 HTML 文本，即是 React 组件渲染结果的可视化展示。当然，部分包含了逻辑的组件也可能发送或者触发某些 Action 或者 Event。</p><pre tabindex=0><code class=language-class data-lang=class>  render() {
    return (
      &lt;h1&gt;
        &lt;a onClick={ this.props.logoClicked }&gt;
          &lt;img src=&#39;path/to/logo.png&#39; /&gt;
        &lt;/a&gt;
      &lt;/h1&gt;
    );
  }
};

class App extends React.Component {
  render() {
    return &lt;Title logoClicked={ this.logoClicked } /&gt;;
  }
  logoClicked() {
    console.log(&#39;logo clicked&#39;);
  }
};
</code></pre><p>在<code>App</code>组件中我们向<code>Title</code>组件传入了可以从<code>Title</code>调用的回调函数，在<code>logoClicked</code>函数中我们可以设置或者修改需要传回父组件的数据。需要注意的是，React 并没有提供可以访问子组件状态的 API，换言之，我们不能使用<code>this.props.children[0].state</code>或者类似的方法。正确的从子组件中获取数据的方法应该是在 Props 中传入回调函数，而这种隔离也有助于我们定义更加清晰的 API 并且促进了所谓单向数据流。</p><h1 id=composition>Composition</h1><p>React 最大的特性之一即是其强大的组件的可组合性，实际上除了 React 之外，笔者并不知道还有哪个框架能够提供如此简单易用的方式来创建与组合各式各样的组件。本章我们会一起讨论些常用的组合技巧，我们以一个简单的例子来进行讲解。假设在我们的应用中有一个页首栏目，并且其中放置了导航栏。我们创建了三个独立的 React 组件:<code>App</code>,<code>Header</code>以及<code>Navigation</code>。将这三个组件依次嵌套组合，可以得到以下的代码:</p><pre tabindex=0><code class="language-<App>" data-lang="<App>">  &lt;Header&gt;
    &lt;Navigation&gt; ... &lt;/Navigation&gt;
  &lt;/Header&gt;
&lt;/App&gt;
</code></pre><p>而在 JSX 中组合这些组件的方式就是在需要的时候引用它们:</p><pre tabindex=0><code class=language-// data-lang=//>import Header from &#39;./Header.jsx&#39;;

export default class App extends React.Component {
  render() {
    return &lt;Header /&gt;;
  }
}

// Header.jsx
import Navigation from &#39;./Navigation.jsx&#39;;

export default class Header extends React.Component {
  render() {
    return &lt;header&gt;&lt;Navigation /&gt;&lt;/header&gt;;
  }
}

// Navigation.jsx
export default class Navigation extends React.Component {
  render() {
    return (&lt;nav&gt; ... &lt;/nav&gt;);
  }
}
</code></pre><p>不过这种方式却可能存在以下的问题:</p><ul><li>我们将<code>App</code>当做各个组件间的连接线，也是整个应用的入口，因此在<code>App</code>中进行各个独立组件的组合是个不错的方法。不过<code>Header</code>元素中可能包含像图标、搜索栏或者 Slogan 这样的元素。而如果我们需要另一个不包含<code>Navigation</code>功能的<code>Header</code>组件时，像上面这种直接将<code>Navigation</code>组件硬编码进入<code>Header</code>的方式就会难于修改。</li><li>这种硬编码的方式会难以测试，如果我们在<code>Header</code>中加入一些自定义的业务逻辑代码，那么在测试的时候当我们要创建<code>Header</code>实例时，因为其依赖于其他组件而导致了这种依赖层次过深(这里不包含<a href=https://facebook.github.io/react/docs/test-utils.html#shallow-rendering target=_blank rel=noopener>Shallow Rendering</a>这种仅渲染父组件而不渲染嵌套的子组件方式)。</li></ul><h2 id=使用-react-的childrenapi>使用 React 的<code>children</code>API</h2><p>React 为我们提供了<code>this.props.children</code>来允许父组件访问其子组件，这种方式有助于保证我们的<code>Header</code>独立并且不需要与其他组件解耦合。</p><pre tabindex=0><code class=language-// data-lang=//>export default class App extends React.Component {
  render() {
    return (
      &lt;Header&gt;
        &lt;Navigation /&gt;
      &lt;/Header&gt;
    );
  }
}

// Header.jsx
export default class Header extends React.Component {
  render() {
    return &lt;header&gt;{ this.props.children }&lt;/header&gt;;
  }
};
</code></pre><p>这种方式也有助于测试，我们可以选择输入空白的<code>div</code>元素，从而将要测试的目标元素隔离开来而专注于我们需要测试的部分。</p><h2 id=将子组件以属性方式传入>将子组件以属性方式传入</h2><p>React 组件可以接受 Props 作为输入，我们也可以选择将需要封装的组件以 Props 方式传入:</p><pre tabindex=0><code class=language-// data-lang=//>class App extends React.Component {
  render() {
    var title = &lt;h1&gt;Hello there!&lt;/h1&gt;;

    return (
      &lt;Header title={ title }&gt;
        &lt;Navigation /&gt;
      &lt;/Header&gt;
    );
  }
};

// Header.jsx
export default class Header extends React.Component {
  render() {
    return (
      &lt;header&gt;
        { this.props.title }
        &lt;hr /&gt;
        { this.props.children }
      &lt;/header&gt;
    );
  }
};
</code></pre><p>这种方式在我们需要对传入的待组合组件进行一些修正时非常适用。</p><h1 id=higher-order-components>Higher-order components</h1><p>Higher-Order Components 模式看上去非常类似于装饰器模式，它会用于包裹某个组件然后为其添加一些新的功能。这里展示一个简单的用于构造 Higher-Order Component 的函数:</p><pre tabindex=0><code class=language-var data-lang=var>  class Enhance extends React.Component {
    render() {
      return (
        &lt;Component
          {...this.state}
          {...this.props}
        /&gt;
      )
    }
  };

export default enhanceComponent;
</code></pre><p>通常情况下我们会构建一个工厂函数，接收原始的组件然后返回一个所谓的增强或者包裹后的版本，譬如:</p><pre tabindex=0><code class=language-var data-lang=var>class App extends React.Component {
  render() {
    return React.createElement(enhanceComponent(OriginalComponent));
  }
};
</code></pre><p>一般来说，高阶组件的首要工作就是渲染原始的组件，我们经常也会将 Props 与 State 传递进去，将这两个属性传递进去会有助于我们建立一个数据代理。HOC 模式允许我们控制组件的输入，即将需要传入的数据以 Props 传递进去。譬如我们需要为原始组件添加一些配置:</p><pre tabindex=0><code class=language-var data-lang=var>var enhanceComponent = (Component) =&gt;
  class Enhance extends React.Component {
    render() {
      return (
        &lt;Component
          {...this.state}
          {...this.props}
          title={ config.appTitle }
        /&gt;
      )
    }
  };
</code></pre><p>这里对于<code>configuration</code>的细节实现会被隐藏到高阶组件中，原始组件只需要了解从 Props 中获取到<code>title</code>变量然后渲染到界面上。原始组件并不会关心变量存于何地，从何而来，这种模式最大的优势在于我们能够以独立的模式对该组件进行测试，并且可以非常方便地对该组件进行 Mocking。在 HOC 模式下我们的原始组件会变成这样子:</p><pre tabindex=0><code class=language-var data-lang=var></code></pre><h1 id=dependency-injection>Dependency injection</h1><p>我们写的大部分组件与模块都会包含一些依赖，合适的依赖管理有助于创建良好可维护的项目结构。而所谓的依赖注入技术正是解决这个问题的常用技巧，无论是在 Java 还是其他应用程序中，依赖注入都受到了广泛的使用。而 React 中对于依赖注入的需要也是显而易见的，让我们假设有如下的应用树结构:</p><pre tabindex=0><code class=language-// data-lang=//>export default function Title(props) {
  return &lt;h1&gt;{ props.title }&lt;/h1&gt;;
}

// Header.jsx
import Title from &#39;./Title.jsx&#39;;
export default function Header() {
  return (
    &lt;header&gt;
      &lt;Title /&gt;
    &lt;/header&gt;
  );
}

// App.jsx
import Header from &#39;./Header.jsx&#39;;
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { title: &#39;React in patterns&#39; };
  }
  render() {
    return &lt;Header /&gt;;
  }
};
</code></pre><p><code>title</code>这个变量的值是在<code>App</code>组件中被定义好的，我们需要将其传入到<code>Title</code>组件中。最直接的方法就是将其从<code>App</code>组件传入到<code>Header</code>组件，然后再由<code>Header</code>组件传入到<code>Title</code>组件中。这种方法在这里描述的简单的仅有三个组件的应用中还是非常清晰可维护的，不过随着项目功能与复杂度的增加，这种层次化的传值方式会导致很多的组件要去考虑它们并不需要的属性。在上文所讲的 HOC 模式中我们已经使用了数据注入的方式，这里我们使用同样的技术来注入<code>title</code>变量:</p><pre tabindex=0><code class=language-// data-lang=//>var title = &#39;React in patterns&#39;;
var enhanceComponent = (Component) =&gt;
  class Enhance extends React.Component {
    render() {
      return (
        &lt;Component
          {...this.state}
          {...this.props}
          title={ title }
        /&gt;
      )
    }
  };
export default enhanceComponent;

// Header.jsx
import enhance from &#39;./enhance.jsx&#39;;
import Title from &#39;./Title.jsx&#39;;

var EnhancedTitle = enhance(Title);
export default function Header() {
  return (
    &lt;header&gt;
      &lt;EnhancedTitle /&gt;
    &lt;/header&gt;
  );
}
</code></pre><p>在上文这种 HOC 模式中，<code>title</code>变量被包含在了一个隐藏的中间层中，我们将其作为 Props 值传入到原始的<code>Title</code>变量中并且得到一个新的组件。这种方式思想是不错，不过还是只解决了部分问题。现在我们可以不去显式地将<code>title</code>变量传递到<code>Title</code>组件中即可以达到同样的<code>enhance.jsx</code>效果。
React 为我们提供了<code>context</code>的概念，<code>context</code>是贯穿于整个 React 组件树允许每个组件访问的对象。有点像所谓的 Event Bus，一个简单的例子如下所示:</p><pre tabindex=0><code class=language-// data-lang=//>var context = { title: &#39;React in patterns&#39; };
class App extends React.Component {
  getChildContext() {
    return context;
  }
  ...
};
App.childContextTypes = {
  title: React.PropTypes.string
};

// a place where we need data
class Inject extends React.Component {
  render() {
    var title = this.context.title;
    ...
  }
}
Inject.contextTypes = {
  title: React.PropTypes.string
};
</code></pre><p>注意，我们要使用 context 对象必须要通过<code>childContextTypes</code>与<code>contextTypes</code>指明其构成。如果在<code>context</code>对象中未指明这些那么<code>context</code>会被设置为空，这可能会添加些额外的代码。因此我们最好不要将<code>context</code>当做一个简单的 object 对象而为其设置一些封装方法:</p><pre tabindex=0><code class=language-// data-lang=//>export default {
  data: {},
  get(key) {
    return this.data[key];
  },
  register(key, value) {
    this.data[key] = value;
  }
}
</code></pre><p>这样，我们的<code>App</code>组件会被改造成这样子:</p><pre tabindex=0><code class=language-import data-lang=import>dependencies.register(&#39;title&#39;, &#39;React in patterns&#39;);

class App extends React.Component {
  getChildContext() {
    return dependencies;
  }
  render() {
    return &lt;Header /&gt;;
  }
};
App.childContextTypes = {
  data: React.PropTypes.object,
  get: React.PropTypes.func,
  register: React.PropTypes.func
};
</code></pre><p>而在<code>Title</code>组件中，我们需要进行如下设置:</p><pre tabindex=0><code class=language-// data-lang=//>export default class Title extends React.Component {
  render() {
    return &lt;h1&gt;{ this.context.get(&#39;title&#39;) }&lt;/h1&gt;
  }
}
Title.contextTypes = {
  data: React.PropTypes.object,
  get: React.PropTypes.func,
  register: React.PropTypes.func
};
</code></pre><p>当然我们不希望在每次要使用<code>contextTypes</code>的时候都需要显式地声明一下，我们可以将这些声明细节包含在一个高阶组件中。</p><pre tabindex=0><code class=language-// data-lang=//>import wire from &#39;./wire&#39;;

function Title(props) {
  return &lt;h1&gt;{ props.title }&lt;/h1&gt;;
}

export default wire(Title, [&#39;title&#39;], function resolve(title) {
  return { title };
});
</code></pre><p>这里的<code>wire</code>函数的第一个参数是 React 组件对象，第二个参数是一系列需要注入的依赖值，注意，这些依赖值务必已经调用过<code>register</code>函数。最后一个参数则是所谓的映射函数，它接收存储在<code>context</code>中的某个原始值然后返回 React Props 中需要的值。因为在这个例子里<code>context</code>中存储的值与<code>Title</code>组件中需要的值都是<code>title</code>变量，因此我们直接返回即可。不过在真实的应用中可能是一个数据集合、配置等等。</p><pre tabindex=0><code class=language-export data-lang=export>  class Inject extends React.Component {
    render() {
      var resolved = dependencies.map(this.context.get.bind(this.context));
      var props = mapper(...resolved);

      return React.createElement(Component, props);
    }
  }
  Inject.contextTypes = {
    data: React.PropTypes.object,
    get: React.PropTypes.func,
    register: React.PropTypes.func
  };
  return Inject;
};
</code></pre><p>这里的 Inject 就是某个可以访问<code>context</code>的高阶组件，而<code>mapper</code>就是用于接收<code>context</code>中的数据并将其转化为组件所需要的 Props 的函数。实际上现在大部分的依赖注入的解决方案都是基于<code>context</code>，我觉得了解这种方式的底层原理还是很有意义的。譬如现在流行的<code>Redux</code>，其核心的<code>connect</code>函数与<code>Provider</code>组件都是基于<code>context</code>。</p><h1 id=one-direction-data-flow>One direction data flow</h1><p>单向数据流是 React 中主要的数据驱动模式，其核心概念在于组件并不会修改它们接收到的数据，它们只是负责接收新的数据而后重新渲染到界面上或者发出某些 Action 以触发某些专门的业务代码来修改数据存储中的数据。我们先设置一个包含一个按钮的<code>Switcher</code>组件，当我们点击该按钮时会触发某个<code>flag</code>变量的改变:</p><pre tabindex=0><code class=language-class data-lang=class>  constructor(props) {
    super(props);
    this.state = { flag: false };
    this._onButtonClick = e =&gt; this.setState({ flag: !this.state.flag });
  }
  render() {
    return (
      &lt;button onClick={ this._onButtonClick }&gt;
        { this.state.flag ? &#39;lights on&#39; : &#39;lights off&#39; }
      &lt;/button&gt;
    );
  }
};

// ... and we render it
class App extends React.Component {
  render() {
    return &lt;Switcher /&gt;;
  }
};
</code></pre><p>此时我们将所有的数据放置到组件内，换言之，<code>Switcher</code>是唯一的包含我们<code>flag</code>变量的地方，我们来尝试下将这些数据托管于专门的 Store 中:</p><pre tabindex=0><code class=language-var data-lang=var>  _flag: false,
  set: function(value) {
    this._flag = value;
  },
  get: function() {
    return this._flag;
  }
};

class Switcher extends React.Component {
  constructor(props) {
    super(props);
    this.state = { flag: false };
    this._onButtonClick = e =&gt; {
      this.setState({ flag: !this.state.flag }, () =&gt; {
        this.props.onChange(this.state.flag);
      });
    }
  }
  render() {
    return (
      &lt;button onClick={ this._onButtonClick }&gt;
        { this.state.flag ? &#39;lights on&#39; : &#39;lights off&#39; }
      &lt;/button&gt;
    );
  }
};

class App extends React.Component {
  render() {
    return &lt;Switcher onChange={ Store.set.bind(Store) } /&gt;;
  }
};
</code></pre><p>这里的<code>Store</code>对象是一个简单的单例对象，可以帮助我们设置与获取<code>_flag</code>属性值。而通过将<code>getter</code>函数传递到组件内，可以允许我们在<code>Store</code>外部修改这些变量，此时我们的应用工作流大概是这样的:</p><pre tabindex=0><code class="language-User's" data-lang="User's"> |
Switcher -------&gt; Store
</code></pre><p>假设我们已经将<code>flag</code>值保存到某个后端服务中，我们需要为该组件设置一个合适的初始状态。此时就会存在一个问题在于同一份数据保存在了两个地方，对于 UI 与<code>Store</code>分别保存了各自独立的关于<code>flag</code>的数据状态，我们等于在<code>Store</code>与<code>Switcher</code>之间建立了双向的数据流:<code>Store ---> Switcher</code>与<code>Switcher ---> Store</code></p><pre tabindex=0><code class=language-// data-lang=//>&lt;Switcher
  value={ Store.get() }
  onChange={ Store.set.bind(Store) } /&gt;

// ... in Switcher component
constructor(props) {
  super(props);
  this.state = { flag: this.props.value };
  ...
</code></pre><p>此时我们的数据流向变成了:</p><pre tabindex=0><code class="language-User's" data-lang="User's"> |
Switcher &lt;-------&gt; Store
^ |
| |
| |
| v
Service communicating
with our backend
</code></pre><p>在这种双向数据流下，如果我们在外部改变了<code>Store</code>中的状态之后，我们需要将改变之后的最新值更新到<code>Switcher</code>中，这样也在无形之间增加了应用的复杂度。而单向数据流则是解决了这个问题，它强制在全局只保留一个状态存储，通常是存放在 Store 中。在单向数据流下，我们需要添加一些订阅 Store 中状态改变的响应函数:</p><pre tabindex=0><code class=language-var data-lang=var>  _handlers: [],
  _flag: &#39;&#39;,
  onChange: function(handler) {
    this._handlers.push(handler);
  },
  set: function(value) {
    this._flag = value;
    this._handlers.forEach(handler =&gt; handler())
  },
  get: function() {
    return this._flag;
  }
};
</code></pre><p>然后我们在<code>App</code>组件中设置了钩子函数，这样每次<code>Store</code>改变其值的时候我们都会强制重新渲染:</p><pre tabindex=0><code class=language-class data-lang=class>  constructor(props) {
    super(props);
    Store.onChange(this.forceUpdate.bind(this));
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Switcher
          value={ Store.get() }
          onChange={ Store.set.bind(Store) } /&gt;
      &lt;/div&gt;
    );
  }
};
</code></pre><p>注意，这里使用的<code>forceUpdate</code>并不是一个推荐的用法，我们通常会使用 HOC 模式来进行重渲染，这里使用<code>forceUpdate</code>只是用于演示说明。在基于上述的改造，我们就不需要在组件中继续保留内部状态:</p><pre tabindex=0><code class=language-class data-lang=class>  constructor(props) {
    super(props);
    this._onButtonClick = e =&gt; {
      this.props.onChange(!this.props.value);
    }
  }
  render() {
    return (
      &lt;button onClick={ this._onButtonClick }&gt;
        { this.props.value ? &#39;lights on&#39; : &#39;lights off&#39; }
      &lt;/button&gt;
    );
  }
};
</code></pre><p>这种模式的优势在于会将我们的组件改造为简单的<code>Store</code>中数据的呈现，此时才是真正无状态的 View。我们可以以完全声明式的方式来编写组件，而将应用中复杂的业务逻辑放置到单独的地方。此时我们应用程序的流图变成了:</p><pre tabindex=0><code class=language-Service data-lang=Service>with our backend
^
|
v
Store &lt;-----
||
v|
Switcher ----&gt;
^
|
|
User input
</code></pre><p>在这种单向数据流中我们不再需要同步系统中的多个部分，这种单向数据流的概念并不仅仅适用于基于 React 的应用。</p></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>上一页</div><a href=/books/web-engineering-notes/03.%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/%E7%BB%84%E4%BB%B6%E5%8C%96/%E7%BB%84%E4%BB%B6%E8%A7%84%E8%8C%83/ rel=next>组件规范</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div><script type=text/javascript id=clstr_globe async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>