<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>99.参考资料 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link><atom:link href="https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml"/><description>99.参考资料</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>99.参考资料</title><link>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link></image><item><title>2018-Depth in React，详谈 Fiber 架构</title><link>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2018-depth-in-react%E8%AF%A6%E8%B0%88-fiber-%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2018-depth-in-react%E8%AF%A6%E8%B0%88-fiber-%E6%9E%B6%E6%9E%84/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="http://taoweng.site" target="_blank" rel="noopener">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="depth-in-react详谈-fiber-架构">Depth in React，详谈 Fiber 架构&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。&lt;/p>
&lt;p>React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。&lt;/p>
&lt;p>所以我&lt;strong>今年&lt;/strong>(对，没错，就是一年)就是想完全的学透 React，所以开了一个 &lt;strong>Deep In React&lt;/strong> 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。&lt;/p>
&lt;p>我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。&lt;/p>
&lt;h3 id="react-的核心思想">React 的核心思想&lt;/h3>
&lt;p>&lt;strong>内存中维护一颗虚拟 DOM 树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中&lt;/strong>。&lt;/p>
&lt;h3 id="react-16-之前的不足">React 16 之前的不足&lt;/h3>
&lt;p>首先我们了解一下 React 的工作过程，当我们通过&lt;code>render() &lt;/code>和 &lt;code>setState()&lt;/code> 进行组件渲染和更新的时候，React 主要有两个阶段：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-06-25-151228.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;strong>调和阶段(Reconciler)：&lt;/strong>&lt;a href="https://zh-hans.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">官方解释&lt;/a>。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。&lt;/p>
&lt;p>&lt;strong>渲染阶段(Renderer)&lt;/strong>：遍历更新队列，通过调用宿主环境的 API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。&lt;/p>
&lt;p>在协调阶段阶段，由于是采用的递归的遍历方式，这种也被成为 &lt;strong>Stack Reconciler&lt;/strong>，主要是为了区别 &lt;strong>Fiber Reconciler&lt;/strong> 取的一个名字。这种方式有一个特点：一旦任务开始进行，就&lt;strong>无法中断&lt;/strong>，那么 js 将一直占用主线程， 一直要等到整棵 Virtual DOM 树计算完成之后，才能把执行权交给渲染引擎，那么这就会导致一些用户交互、动画等任务无法立即得到处理，就会有卡顿，非常的影响用户体验。&lt;/p>
&lt;h3 id="如何解决之前的不足">如何解决之前的不足&lt;/h3>
&lt;blockquote>
&lt;p>之前的问题主要的问题是任务一旦执行，就无法中断，js 线程一直占用主线程，导致卡顿。&lt;/p>
&lt;/blockquote>
&lt;p>可能有些接触前端不久的不是特别理解上面为什么 js 一直占用主线程就会卡顿，我这里还是简单的普及一下。&lt;/p>
&lt;h4 id="浏览器每一帧都需要完成哪些工作">浏览器每一帧都需要完成哪些工作？&lt;/h4>
&lt;p>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。&lt;/p>
&lt;p>1s 60 帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-06-25-151230.png" alt="image-20190603163205451" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;em>浏览器一帧内的工作&lt;/em>&lt;/p>
&lt;p>通过上图可看到，一帧内需要完成如下六个步骤的任务：&lt;/p>
&lt;ul>
&lt;li>处理用户的交互&lt;/li>
&lt;li>JS 解析执行&lt;/li>
&lt;li>帧开始。窗口尺寸变更，页面滚去等的处理&lt;/li>
&lt;li>rAF(requestAnimationFrame)&lt;/li>
&lt;li>布局&lt;/li>
&lt;li>绘制&lt;/li>
&lt;/ul>
&lt;p>如果这六个步骤中，任意一个步骤所占用的时间过长，总时间超过 16ms 了之后，用户也许就能看到卡顿。&lt;/p>
&lt;p>而在上一小节提到的&lt;strong>调和阶段&lt;/strong>花的时间过长，也就是 js 执行的时间过长，那么就有可能在用户有交互的时候，本来应该是渲染下一帧了，但是在当前一帧里还在执行 JS，就导致用户交互不能麻烦得到反馈，从而产生卡顿感。&lt;/p>
&lt;h4 id="解决方案">解决方案&lt;/h4>
&lt;p>**把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。**这种策略叫做 &lt;a href="https://www.w3.org/TR/requestidlecallback/" target="_blank" rel="noopener">Cooperative Scheduling（合作式调度）&lt;/a>，操作系统常用任务调度策略之一。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>补充知识&lt;/strong>，操作系统常用任务调度策略：先来先服务（FCFS）调度算法、短作业（进程）优先调度算法（SJ/PF）、最高优先权优先调度算法（FPF）、高响应比优先调度算法（HRN）、时间片轮转法（RR）、多级队列反馈法。&lt;/p>
&lt;/blockquote>
&lt;p>合作式调度主要就是用来分配任务的，当有更新任务来的时候，不会马上去做 Diff 操作，而是先把当前的更新送入一个 Update Queue 中，然后交给 &lt;strong>Scheduler&lt;/strong> 去处理，Scheduler 会根据当前主线程的使用情况去处理这次 Update。为了实现这种特性，使用了&lt;code>requestIdelCallback&lt;/code>API。对于不支持这个 API 的浏览器，React 会加上 pollyfill。&lt;/p>
&lt;p>在上面我们已经知道浏览器是一帧一帧执行的，在两个执行帧之间，主线程通常会有一小段空闲时间，&lt;code>requestIdleCallback&lt;/code>可以在这个&lt;strong>空闲期（Idle Period）调用空闲期回调（Idle Callback）&lt;/strong>，执行一些任务。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-06-25-151231.png" alt="image-20190625225130226" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>低优先级任务由&lt;code>requestIdleCallback&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>高优先级任务，如动画相关的由&lt;code>requestAnimationFrame&lt;/code>处理；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>requestIdleCallback &lt;/code>可以在多个空闲期调用空闲期回调，执行任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>requestIdleCallback &lt;/code>方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞 UI 渲染而导致掉帧；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这个方案看似确实不错，但是怎么实现可能会遇到几个问题：&lt;/p>
&lt;ul>
&lt;li>如何拆分成子任务？&lt;/li>
&lt;li>一个子任务多大合适？&lt;/li>
&lt;li>怎么判断是否还有剩余时间？&lt;/li>
&lt;li>有剩余时间怎么去调度应该执行哪一个任务？&lt;/li>
&lt;li>没有剩余时间之前的任务怎么办？&lt;/li>
&lt;/ul>
&lt;p>接下里整个 Fiber 架构就是来解决这些问题的。&lt;/p>
&lt;h2 id="什么是-fiber">什么是 Fiber&lt;/h2>
&lt;p>为了解决之前提到解决方案遇到的问题，提出了以下几个目标：&lt;/p>
&lt;ul>
&lt;li>暂停工作，稍后再回来。&lt;/li>
&lt;li>为不同类型的工作分配优先权。&lt;/li>
&lt;li>重用以前完成的工作。&lt;/li>
&lt;li>如果不再需要，则中止工作。&lt;/li>
&lt;/ul>
&lt;p>为了做到这些，我们首先需要一种方法将任务分解为单元。从某种意义上说，这就是 Fiber，Fiber 代表一种&lt;strong>工作单元&lt;/strong>。&lt;/p>
&lt;p>但是仅仅是分解为单元也无法做到中断任务，因为函数调用栈就是这样，每个函数为一个工作，每个工作被称为&lt;strong>堆栈帧&lt;/strong>，它会一直工作，直到堆栈为空，无法中断。&lt;/p>
&lt;p>所以我们需要一种增量渲染的调度，那么就需要重新实现一个堆栈帧的调度，这个堆栈帧可以按照自己的调度算法执行他们。另外由于这些堆栈是可以自己控制的，所以可以加入并发或者错误边界等功能。&lt;/p>
&lt;p>因此 Fiber 就是重新实现的堆栈帧，本质上 Fiber 也可以理解为是一个&lt;strong>虚拟的堆栈帧&lt;/strong>，将可中断的任务拆分成多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的同步渲染改为异步渲染。&lt;/p>
&lt;p>所以我们可以说 Fiber 是一种数据结构(堆栈帧)，也可以说是一种解决可中断的调用任务的一种解决方案，它的特性就是&lt;strong>时间分片(time slicing)&lt;strong>和&lt;/strong>暂停(supense)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>如果了解&lt;strong>协程&lt;/strong>的可能会觉得 Fiber 的这种解决方案，跟协程有点像(区别还是很大的)，是可以中断的，可以控制执行顺序。在 JS 里的 generator 其实就是一种协程的使用方式，不过颗粒度更小，可以控制函数里面的代码调用的顺序，也可以中断。&lt;/p>
&lt;/blockquote>
&lt;h2 id="fiber-是如何工作的">Fiber 是如何工作的&lt;/h2>
&lt;ol>
&lt;li>&lt;code>ReactDOM.render()&lt;/code> 和 &lt;code>setState&lt;/code> 的时候开始创建更新。&lt;/li>
&lt;li>将创建的更新加入任务队列，等待调度。&lt;/li>
&lt;li>在 requestIdleCallback 空闲时执行任务。&lt;/li>
&lt;li>从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。&lt;/li>
&lt;li>生成 effectList。&lt;/li>
&lt;li>根据 EffectList 更新 DOM。&lt;/li>
&lt;/ol>
&lt;p>下面是一个详细的执行过程图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-06-25-151232.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>第一部分从 &lt;code>ReactDOM.render()&lt;/code> 方法开始，把接收的 React Element 转换为 Fiber 节点，并为其设置优先级，创建 Update，加入到更新队列，这部分主要是做一些初始数据的准备。&lt;/li>
&lt;li>第二部分主要是三个函数：&lt;code>scheduleWork&lt;/code>、&lt;code>requestWork&lt;/code>、&lt;code>performWork&lt;/code>，即安排工作、申请工作、正式工作三部曲，React 16 新增的异步调用的功能则在这部分实现，这部分就是 &lt;strong>Schedule 阶段&lt;/strong>，前面介绍的 Cooperative Scheduling 就是在这个阶段，只有在这个解决获取到可执行的时间片，第三部分才会继续执行。具体是如何调度的，后面文章再介绍，这是 React 调度的关键过程。&lt;/li>
&lt;li>第三部分是一个大循环，遍历所有的 Fiber 节点，通过 Diff 算法计算所有更新工作，产出 EffectList 给到 commit 阶段使用，这部分的核心是 beginWork 函数，这部分基本就是 &lt;strong>Fiber Reconciler ，包括 reconciliation 和 commit 阶段&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h3 id="fiber-node">Fiber Node&lt;/h3>
&lt;p>FIber Node，承载了非常关键的上下文信息，可以说是贯彻整个创建和更新的流程，下来分组列了一些重要的 Fiber 字段。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stateNode&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 单链表树结构
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="c1">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="c1">// 指向自己的第一个子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sibling&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 更新相关
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">pendingProps&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 新的变动带来的新的props
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">memoizedProps&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 上一次渲染完成之后的props
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">updateQueue&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">UpdateQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">any&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 该Fiber对应的组件产生的Update会存放在这个队列里面
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">memoizedState&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 上一次渲染的时候的state
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Scheduler 相关
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 代表任务在未来的哪个时间点应该被完成，不包括他的子树产生的任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 快速确定子树中是否有不在等待的变化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">childExpirationTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 我们称他为`current &amp;lt;==&amp;gt; workInProgress`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 在渲染完成之后他们会交换位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">alternate&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Effect 相关的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">effectTag&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">SideEffectTag&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 用来记录Side Effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nextEffect&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 单链表用来快速查找下一个side effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">firstEffect&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 子树中第一个side effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">lastEffect&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 子树中最后一个side effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="fiber-reconciler">Fiber Reconciler&lt;/h3>
&lt;p>在第二部分，进行 Schedule 完，获取到时间片之后，就开始进行 reconcile。&lt;/p>
&lt;p>Fiber Reconciler 是 React 里的调和器，这也是任务调度完成之后，如何去执行每个任务，如何去更新每一个节点的过程，对应上面的第三部分。&lt;/p>
&lt;p>reconcile 过程分为 2 个阶段（phase）：&lt;/p>
&lt;ol>
&lt;li>（可中断）render/reconciliation 通过构造 WorkInProgress Tree 得出 Change。&lt;/li>
&lt;li>（不可中断）commit 应用这些 DOM change。&lt;/li>
&lt;/ol>
&lt;h4 id="reconciliation-阶段">reconciliation 阶段&lt;/h4>
&lt;p>在 reconciliation 阶段的每个工作循环中，每次处理一个 Fiber，处理完可以中断/挂起整个工作循环。通过每个节点更新结束时向上归并 &lt;strong>Effect List&lt;/strong> 来收集任务结果，reconciliation 结束后，&lt;strong>根节点&lt;/strong>的 Effect List 里记录了包括 DOM change 在内的所有 &lt;strong>Side Effect&lt;/strong>。&lt;/p>
&lt;p>render 阶段可以理解为就是 Diff 的过程，得出 Change(Effect List)，会执行声明如下的声明周期方法：&lt;/p>
&lt;ul>
&lt;li>[UNSAFE_]componentWillMount（弃用）&lt;/li>
&lt;li>[UNSAFE_]componentWillReceiveProps（弃用）&lt;/li>
&lt;li>getDerivedStateFromProps&lt;/li>
&lt;li>shouldComponentUpdate&lt;/li>
&lt;li>[UNSAFE_]componentWillUpdate（弃用）&lt;/li>
&lt;li>render&lt;/li>
&lt;/ul>
&lt;p>由于 reconciliation 阶段是可中断的，一旦中断之后恢复的时候又会重新执行，所以很可能 reconciliation 阶段的生命周期方法会被多次调用，所以在 reconciliation 阶段的生命周期的方法是不稳定的，我想这也是 React 为什么要废弃 &lt;code>componentWillMount&lt;/code> 和 &lt;code>componentWillReceiveProps&lt;/code>方法而改为静态方法 &lt;code>getDerivedStateFromProps&lt;/code> 的原因吧。&lt;/p>
&lt;h4 id="commit-阶段">commit 阶段&lt;/h4>
&lt;p>commit 阶段可以理解为就是将 Diff 的结果反映到真实 DOM 的过程。&lt;/p>
&lt;p>在 commit 阶段，在 commitRoot 里会根据 &lt;code>effect &lt;/code>的 &lt;code>effectTag&lt;/code>，具体 effectTag 见&lt;a href="https://github.com/facebook/react/blob/504576306461a5ff339dc99691842f0f35a8bf4c/packages/shared/ReactSideEffectTags.js" target="_blank" rel="noopener">源码&lt;/a> ，进行对应的插入、更新、删除操作，根据 &lt;code>tag&lt;/code> 不同，调用不同的更新方法。&lt;/p>
&lt;p>commit 阶段会执行如下的声明周期方法：&lt;/p>
&lt;ul>
&lt;li>getSnapshotBeforeUpdate&lt;/li>
&lt;li>componentDidMount&lt;/li>
&lt;li>componentDidUpdate&lt;/li>
&lt;li>componentWillUnmount&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>P.S：注意区别 reconciler、reconcile 和 reconciliation，reconciler 是调和器，是一个名词，可以说是 React 工作的一个模块，协调模块；reconcile 是调和器调和的动作，是一个动词；而 reconciliation 只是 reconcile 过程的第一个阶段。&lt;/p>
&lt;/blockquote>
&lt;h3 id="fiber-tree-和-workinprogress-tree">Fiber Tree 和 WorkInProgress Tree&lt;/h3>
&lt;p>React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 &lt;strong>Virtual DOM Tree&lt;/strong>，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 &lt;strong>Fiber Tree&lt;/strong>。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 &lt;strong>current 树（当前树，记录当前页面的状态）。&lt;/strong>&lt;/p>
&lt;p>在后续的更新过程中（setState），每次重新渲染都会重新创建 Element, 但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性，&lt;/p>
&lt;p>Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。&lt;/p>
&lt;p>这个链接的结构是怎么构成的呢，这就要主要到之前 Fiber Node 的节点的这几个字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 单链表树结构
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 指向父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="c1">// 指向自己的第一个子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sibling&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="c1">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每一个 Fiber Node 节点与 Virtual Dom 一一对应，所有 Fiber Node 连接起来形成 Fiber tree, 是个单链表树结构，如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-06-25-151232.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对照图来看，是不是可以知道 Fiber Node 是如何联系起来的呢，Fiber Tree 就是这样一个单链表。&lt;/p>
&lt;p>&lt;strong>当 render 的时候有了这么一条单链表，当调用 &lt;code>setState&lt;/code> 的时候又是如何 Diff 得到 change 的呢？&lt;/strong>&lt;/p>
&lt;p>采用的是一种叫&lt;strong>双缓冲技术（double buffering）&lt;/strong>，这个时候就需要另外一颗树：WorkInProgress Tree，它反映了要刷新到屏幕的未来状态。&lt;/p>
&lt;p>WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后喜新厌旧（把 current 指针指向 WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了。&lt;/p>
&lt;p>这样做的好处：&lt;/p>
&lt;ul>
&lt;li>能够复用内部对象（fiber）&lt;/li>
&lt;li>节省内存分配、GC 的时间开销&lt;/li>
&lt;li>就算运行中有错误，也不会影响 View 上的数据&lt;/li>
&lt;/ul>
&lt;p>每个 Fiber 上都有个&lt;code>alternate&lt;/code>属性，也指向一个 Fiber，创建 WorkInProgress 节点时优先取&lt;code>alternate&lt;/code>，没有的话就创建一个。&lt;/p>
&lt;p>创建 WorkInProgress Tree 的过程也是一个 Diff 的过程，Diff 完成之后会生成一个 Effect List，这个 Effect List 就是最终 Commit 阶段用来处理副作用的阶段。&lt;/p>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>本开始想一篇文章把 Fiber 讲透的，但是写着写着发现确实太多了，想写详细，估计要写几万字，所以我这篇文章的目的仅仅是在没有涉及到源码的情况下梳理了大致 React 的工作流程，对于细节，比如如何调度异步任务、如何去做 Diff 等等细节将以小节的方式一个个的结合源码进行分析。&lt;/p>
&lt;p>说实话，自己不是特别满意这篇，感觉头重脚轻，在讲协调之前写得还挺好的，但是在讲协调这块文字反而变少了，因为我是专门想写一篇文章讲协调的，所以这篇仅仅用来梳理整个流程。&lt;/p>
&lt;p>但是梳理整个流程又发现 Schedule 这块基本没什么体现，哎，不想写了，这篇文章拖太久了，请继续后续的文章。&lt;/p>
&lt;p>可以关注我的 github：&lt;a href="https://github.com/crazylxr/deep-in-react" target="_blank" rel="noopener">Deep In React&lt;/a>&lt;/p>
&lt;h2 id="一些问题">一些问题&lt;/h2>
&lt;p>接下来留一些思考题。&lt;/p>
&lt;ul>
&lt;li>如何去划分任务优先级？&lt;/li>
&lt;li>在 reconcile 过程的 render 阶段是如何去遍历链表，如何去构建 workInProgress 的？&lt;/li>
&lt;li>当任务被打断，如何恢复？&lt;/li>
&lt;li>如何去收集 EffectList？&lt;/li>
&lt;li>针对不同的组件类型如何进行更新？&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="[http://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader4]%28http://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader4%29">完全理解 React Fiber&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://happy-alex.github.io/js/react/fiber/" target="_blank" rel="noopener">Fiber&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/HuJiaoHJ/blog/issues/7#" target="_blank" rel="noopener">React16 源码之 React Fiber 架构&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="详解-diff-过程">详解 Diff 过程&lt;/h1>
&lt;h2 id="前言-1">前言&lt;/h2>
&lt;p>我相信在看这篇文章的读者一般都已经了解过 React 16 以前的 Diff 算法了，这个算法也算是 React 跨时代或者说最有影响力的一点了，使 React 在保持了可维护性的基础上性能大大的提高，但 Diff 过程不仅不是免费的，而且对性能影响很大，有时候更新页面的时候往往 Diff 所花的时间 js 运行时间比 Rendering 和 Painting 花费更多的时间，所以我一直传达的观念是 React 或者说框架的意义是&lt;strong>为了提高代码的可维护性&lt;/strong>，而&lt;strong>不是为了提高性能&lt;/strong>的，现在所做的提升性能的操作，只是在可维护性的基础上对性能的优化。具体可以参考我公众号以前发的这两篇文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ" target="_blank" rel="noopener">别再说虚拟 DOM 快了，要被打脸的&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A" target="_blank" rel="noopener">深入理解虚拟 DOM，它真的不快&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果你对标题不满意，请把文章看完，至少也得把文章最后的结论好好看下&lt;/p>
&lt;/blockquote>
&lt;p>在上一篇将 React Fiber 架构中，已经说到过，React 现在将整体的数据结构从树改为了链表结构。所以相应的 Diff 算法也得改变，以为以前的 Diff 算法就是基于树的。&lt;/p>
&lt;p>老的 Diff 算法提出了三个策略来保证整体界面构建的性能，具体是：&lt;/p>
&lt;ol>
&lt;li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。&lt;/li>
&lt;li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。&lt;/li>
&lt;li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。&lt;/li>
&lt;/ol>
&lt;p>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。&lt;/p>
&lt;p>具体老的算法可以见这篇文章：&lt;a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">React 源码剖析系列 － 不可思议的 react diff&lt;/a>&lt;/p>
&lt;p>说实话，老的 Diff 算法还是挺复杂的，你仅仅看上面这篇文章估计一时半会都不能理解，更别说看源码了。对于 React 16 的 Diff 算法(我觉得都不能把它称作算法，最多叫个 Diff 策略)其实还是蛮简单的，React 16 是整个调度流程感觉比较难，我在前面将 Fiber 的文章已经简单的梳理过了，后面也会慢慢的逐个攻破。&lt;/p>
&lt;p>接下来就开始正式的讲解 React 16 的 Diff 策略吧！&lt;/p>
&lt;h2 id="diff-简介">Diff 简介&lt;/h2>
&lt;p>&lt;strong>做 Diff 的目的就是为了复用节点。&lt;/strong>&lt;/p>
&lt;p>链表的每一个节点是 Fiber，而不是在 16 之前的虚拟 DOM 节点。&lt;/p>
&lt;blockquote>
&lt;p>我这里说的虚拟 DOM 节点是指 React.createElement 方法所产生的节点。虚拟 DOM tree 只维护了组件状态以及组件与 DOM 树的关系，Fiber Node 承载的东西比 虚拟 DOM 节点多很多。&lt;/p>
&lt;/blockquote>
&lt;p>Diff 就是新旧节点的对比，在&lt;a href="https://mp.weixin.qq.com/s/dONYc-Y96baiXBXpwh1w3A" target="_blank" rel="noopener">上一篇&lt;/a>中也说道了，这里面的 Diff 主要是构建 currentInWorkProgress 的过程，同时得到 Effect List，给下一个阶段 commit 做准备。&lt;/p>
&lt;p>React16 的 diff 策略采用从链表头部开始比较的算法，是&lt;strong>层次遍历&lt;/strong>，算法是建立在一个节点的插入、删除、移动等操作都是在节点树的&lt;strong>同一层级&lt;/strong>中进行的。&lt;/p>
&lt;p>对于 Diff， 新老节点的对比，我们以新节点为标准，然后来构建整个 currentInWorkProgress，对于新的 children 会有四种情况。&lt;/p>
&lt;ul>
&lt;li>TextNode(包含字符串和数字)&lt;/li>
&lt;li>单个 React Element(通过该节点是否有 $$typeof 区分)&lt;/li>
&lt;li>数组&lt;/li>
&lt;li>可迭代的 children，跟数组的处理方式差不多&lt;/li>
&lt;/ul>
&lt;p>那么我们就来一步一步的看这四种类型是如何进行 diff 的。&lt;/p>
&lt;h2 id="前置知识介绍">前置知识介绍&lt;/h2>
&lt;p>这篇文章主要是从 React 的源码的逻辑出发介绍的，所以介绍之前了解下只怎么进入到这个 diff 函数的，react 的 diff 算法是从 &lt;code>reconcileChildren&lt;/code> 开始的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="nx">reconcileChildren&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">current&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nextChildren&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">renderExpirationTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">mountChildFibers&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nextChildren&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">renderExpirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">reconcileChildFibers&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nextChildren&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">renderExpirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>reconcileChildren&lt;/code> 只是一个入口函数，如果首次渲染，current 空 null，就通过 &lt;code>mountChildFibers&lt;/code> 创建子节点的 Fiber 实例。如果不是首次渲染，就调用 &lt;code>reconcileChildFibers&lt;/code>去做 diff，然后得出 effect list。&lt;/p>
&lt;p>接下来再看看 mountChildFibers 和 reconcileChildFibers 有什么区别：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">reconcileChildFibers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">ChildReconciler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">mountChildFibers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">ChildReconciler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他们都是通过 &lt;code>ChildReconciler&lt;/code> 函数来的，只是传递的参数不同而已。这个参数叫&lt;code>shouldTrackSideEffects&lt;/code>，他的作用是判断是否要增加一些&lt;code>effectTag&lt;/code>，主要是用来优化初次渲染的，因为初次渲染没有更新操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">reconcileChildFibers&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newChild&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 主要的 Diff 逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>reconcileChildFibers&lt;/code> 就是 Diff 部分的主体代码，这个函数超级长，是一个包装函数，下面所有的 diff 代码都在这里面，详细的源码注释可以见&lt;a href="https://github.com/crazylxr/deep-in-react/blob/master/analysis/06-rencocilerChildren.md" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;p>&lt;strong>参数介绍&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>returnFiber&lt;/code> 是即将 Diff 的这层的父节点。&lt;/li>
&lt;li>&lt;code>currentFirstChild&lt;/code>是当前层的第一个 Fiber 节点。&lt;/li>
&lt;li>&lt;code>newChild&lt;/code> 是即将更新的 vdom 节点(可能是 TextNode、可能是 ReactElement，可能是数组)，不是 Fiber 节点&lt;/li>
&lt;li>&lt;code>expirationTime&lt;/code> 是过期时间，这个参数是跟调度有关系的，本系列还没讲解，当然跟 Diff 也没有关系。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>再次提醒，reconcileChildFibers 是 reconcile(diff) 的一层。&lt;/p>
&lt;/blockquote>
&lt;p>前置知识介绍完毕，就开始详细介绍每一种节点是如何进行 Diff 的。&lt;/p>
&lt;h2 id="diff-textnode">Diff TextNode&lt;/h2>
&lt;p>首先看 TextNode，因为它是最简单的，担心直接看到难的，然后就打击你的信心。&lt;/p>
&lt;p>看下面两个小 demo：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// demo1：当前 ui 对应的节点的 jsx
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">div&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">div&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">xxx&lt;/span>&lt;span class="o">&amp;gt;&amp;lt;&lt;/span>&lt;span class="err">/xxx&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">xxx&lt;/span>&lt;span class="o">&amp;gt;&amp;lt;&lt;/span>&lt;span class="err">/xxx&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="err">/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="err">/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// demo2：更新成功后的节点对应的 jsx
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">div&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">div&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="nx">前端桃园&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="err">/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="err">/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应的单链表结构图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-07-28-134126.png" alt="image-20190714223931338" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对于 diff TextNode 会有两种情况。&lt;/p>
&lt;ol>
&lt;li>currentFirstNode 是 TextNode&lt;/li>
&lt;li>currentFirstNode 不是 TextNode&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>currentFirstNode 是当前该层的第一个节点，reconcileChildFibers 传进来的参数。&lt;/p>
&lt;/blockquote>
&lt;p>**为什么要分两种情况呢？**原因就是为了复用节点&lt;/p>
&lt;p>&lt;strong>第一种情况&lt;/strong>。xxx 是一个 TextNode，那么就代表这这个节点可以复用，有复用的节点，对性能优化很有帮助。既然新的 child 只有一个 TextNode，那么复用节点之后，就把剩下的 aaa 节点就可以删掉了，那么 div 的 child 就可以添加到 workInProgress 中去了。&lt;/p>
&lt;p>源码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">currentFirstChild&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tag&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">HostText&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// We already have an existing node so let&amp;#39;s just update it and delete
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// the rest.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">deleteRemainingChildren&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">existing&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useFiber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">textContent&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">existing&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">existing&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在源码里 &lt;code>useFiber&lt;/code> 就是复用节点的方法，&lt;code>deleteRemainingChildren&lt;/code> 就是删除剩余节点的方法，这里是从 &lt;code>currentFirstChild.sibling&lt;/code> 开始删除的。&lt;/p>
&lt;p>**第二种情况。**xxx 不是一个 TextNode，那么就代表这个节点不能复用，所以就从 &lt;code>currentFirstChild&lt;/code>开始删掉剩余的节点，对应到上面的图中就是删除掉 xxx 节点和 aaa 节点。&lt;/p>
&lt;p>对于源码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">deleteRemainingChildren&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">created&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createFiberFromText&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">textContent&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mode&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">created&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>createFiberFromText&lt;/code> 就是根据 &lt;code>textContent&lt;/code> 来创建节点的方法。&lt;/p>
&lt;blockquote>
&lt;p>注意：删除节点不会真的从链表里面把节点删除，只是打一个 delete 的 tag，当 commit 的时候才会真正的去删除。&lt;/p>
&lt;/blockquote>
&lt;h2 id="diff-react-element">Diff React Element&lt;/h2>
&lt;p>有了上面 TextNode 的 Diff 经验，那么来理解 React Element 的 Diff 就比较简单了，因为他们的思路是一致的：先找有没有可以复用的节点，如果没有就另外创建一个。&lt;/p>
&lt;p>那么就有一个问题，&lt;strong>如何判断这个节点是否可以复用呢？&lt;/strong>&lt;/p>
&lt;p>有两个点：1. key 相同。 2. 节点的类型相同。&lt;/p>
&lt;p>如果以上两点相同，就代表这个节点只是变化了内容，不需要创建新的节点，可以复用的。&lt;/p>
&lt;p>对应的源码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tag&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">Fragment&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">?&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">type&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">REACT_FRAGMENT_TYPE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">:&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">elementType&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">type&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 为什么要删除老的节点的兄弟节点？
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 因为当前节点是只有一个节点，而老的如果是有兄弟节点是要删除的，是多于的。删掉了之后就可以复用老的节点了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">deleteRemainingChildren&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 复用当前节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">existing&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useFiber&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">type&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">REACT_FRAGMENT_TYPE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">?&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">props&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">children&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">:&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">props&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">existing&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ref&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">coerceRef&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">existing&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">existing&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相信这些代码都很好理解了，除了判断条件跟前面 TextNode 的判断条件不一样，其余的基本都一样，只是 React Element 多了一个跟新 ref 的过程。&lt;/p>
&lt;p>同样，如果节点的类型不相同，就将节点从当前节点开始把剩余的都删除。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">deleteRemainingChildren&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到这里，可能你们就会觉得接下来应该就是讲解当没有可以复用的节点的时候是如果创建节点的。&lt;/p>
&lt;p>不过可惜你们猜错了。因为 Facebook 的工程师很厉害，另外还做了一个工作来优化，来找到复用的节点。&lt;/p>
&lt;p>我们现在来看这种情况：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-07-28-134319.jpg" alt="image-20190714232052778" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这种情况就是有可能更新的时候删除了一个节点，但是另外的节点还留着。&lt;/p>
&lt;p>那么在对比 xxx 节点和 AAA 节点的时候，它们的节点类型是不一样，按照我们上面的逻辑，还是应该把 xxx 和 AAA 节点删除，然后创建一个 AAA 节点。&lt;/p>
&lt;p>但是你看，明明 xxx 的 slibling 有一个 AAA 节点可以复用，但是被删了，多浪费呀。所以还有另外有一个策略来找 xxx 的所有兄弟节点中有没有可以复用的节点。&lt;/p>
&lt;p>这种策略就是从 div 下面的所有子节点去找有没有可以复用的节点，而不是像 TextNode 一样，只是找第一个 child 是否可以复用，如果当前节点的 key 不同，就代表肯定不是同一个节点，所以把当前节点删除，然后再去找当前节点的兄弟节点，直到找到 key 相同，并且节点的类型相同，否则就删除所有的子节点。&lt;/p>
&lt;blockquote>
&lt;p>你有木有这样的问题：为什么 TextNode 不采用这样的循环策略来找可以复用的节点呢？这个问题留给你思考，欢迎在评论区留下你的答案。&lt;/p>
&lt;/blockquote>
&lt;p>对应的源码逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 找到 key 相同的节点，就会复用当前节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">child&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tag&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">Fragment&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">?&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">type&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">REACT_FRAGMENT_TYPE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">:&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">elementType&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">type&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 复用节点逻辑，省略该部分代码，和上面复用节点的代码相同
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// code ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">existing&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">deleteRemainingChildren&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果没有可以复用的节点，就把这个节点删除
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">deleteChild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面这段代码我们需要注意的是，当 key 相同，React 会认为是同一个节点，所以当 key 相同，节点类型不同的时候，React 会认为你已经把这个节点重新覆盖了，所以就不会再去找剩余的节点是否可以复用。只有在 key 不同的时候，才会去找兄弟节点是否可以复用。&lt;/p>
&lt;p>接下来才是我们前面说的，如果没有找到可以复用的节点，然后就重新创建节点，源码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 前面的循环已经把该删除的已经删除了，接下来就开始创建新的节点了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">type&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">REACT_FRAGMENT_TYPE&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">created&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createFiberFromFragment&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">props&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">children&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mode&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">element&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">created&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">created&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">created&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createFiberFromElement&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">element&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mode&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">created&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ref&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">coerceRef&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">element&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">created&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">created&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 Fragment 节点和一般的 Element 节点创建的方式不同，因为 Fragment 本来就是一个无意义的节点，他真正需要创建 Fiber 的是它的 children，而不是它自己，所以 &lt;code>createFiberFromFragment&lt;/code> 传递的不是 &lt;code>element &lt;/code>，而是 &lt;code>element.props.children&lt;/code>。&lt;/p>
&lt;h2 id="diff-array">Diff Array&lt;/h2>
&lt;p>Diff Array 算是 Diff 中最难的一部分了，比较的复杂，因为做了很多的优化，不过请你放心，认真看完我的讲解，最难的也会很容易理解，废话不多说，开始吧！&lt;/p>
&lt;p>因为 Fiber 树是单链表结构，没有子节点数组这样的数据结构，也就没有可以供两端同时比较的尾部游标。所以 React 的这个算法是一个简化的两端比较法，只从头部开始比较。&lt;/p>
&lt;p>前面已经说了，Diff 的目的就是为了复用，对于 Array 就不能像之前的节点那样，仅仅对比一下元素的 key 或者 元素类型就行，因为数组里面是好多个元素。你可以在头脑里思考两分钟如何进行复用节点，再看 React 是怎么做的，然后对比一下孰优孰劣。&lt;/p>
&lt;h3 id="1-相同位置index进行比较">1. 相同位置(index)进行比较&lt;/h3>
&lt;p>相同位置进行对比，这个是比较容易想到的一种方式，还是举个例子加深一下印象。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-07-28-134317.jpg" alt="image-20190721212259855" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这已经是一个非常简单的例子了，div 的 child 是一个数组，有 AAA、BBB 然后还有其他的兄弟节点，在做 diff 的时候就可以从新旧的数组中按照索引一一对比，如果可以复用，就把这个节点从老的链表里面删除，不能复用的话再进行其他的复用策略。&lt;/p>
&lt;p>那如果判断节点是否可以复用呢？有了前面的 ReactElement 和 TextNode 复用的经验，这个也类似，因为是一一对比嘛，相当于是一个节点一个节点的对比。&lt;/p>
&lt;p>不过对于 newChild 可能会有很多种类型，简单的看下源码是如何进行判断的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">oldFiber&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="nx">oldFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面的经验可得，判断是否可以复用，常常会根据 key 是否相同来决定，所以首先获取了老节点的 key 是否存在。如果不存在老节点很可能是 TextNode 或者是 Fragment。&lt;/p>
&lt;p>接下来再看 newChild 为不同类型的时候是如何进行处理的。&lt;/p>
&lt;p>&lt;strong>当 newChild 是 TextNode 的时候&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">typeof&lt;/span> &lt;span class="nx">newChild&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;string&amp;#34;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="k">typeof&lt;/span> &lt;span class="nx">newChild&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;number&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 对于新的节点如果是 string 或者 number，那么都是没有 key 的，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 所有如果老的节点有 key 的话，就不能复用，直接返回 null。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 老的节点 key 为 null 的话，代表老的节点是文本节点，就可以复用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">updateTextNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">oldFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">newChild&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 key 不为 null，那么就代表老节点不是 TextNode，而新节点又是 TextNode，所以返回 null，不能复用，反之则可以复用，调用 &lt;code>updateTextNode&lt;/code> 方法。&lt;/p>
&lt;blockquote>
&lt;p>注意，updateTextNode 里面包含了首次渲染的时候的逻辑，首次渲染的时候回插入一个 TextNode，而不是复用。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>当 newChild 是 Object 的时候&lt;/strong>&lt;/p>
&lt;p>newChild 是 Object 的时候基本上走的就是 ReactElement 的逻辑了，判断 key 和 元素的类型是否相等来判断是否可以复用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">typeof&lt;/span> &lt;span class="nx">newChild&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;object&amp;#34;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">newChild&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 有 $$typeof 代表就是 ReactElement
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">newChild&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">$$typeof&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">REACT_ELEMENT_TYPE&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ReactElement 的逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">REACT_PORTAL_TYPE&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 调用 updatePortal
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">isArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">newChild&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">getIteratorFn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">newChild&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">updateFragment&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">oldFiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newChild&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先判断是否是对象，用的是 &lt;code>typeof newChild === 'object' &amp;amp;&amp;amp; newChild !== null&lt;/code> ，注意要加 &lt;code>!== null&lt;/code>，因为 &lt;code>typeof null&lt;/code> 也是 object。&lt;/p>
&lt;p>然后通过 $$typeof 判断是 REACT_ELEMENT_TYPE 还是 REACT_PORTAL_TYPE，分别调用不同的复用逻辑，然后由于数组也是 Object ，所以这个 if 里面也有数组的复用逻辑。&lt;/p>
&lt;p>我相信到这里应该对于应该对于如何相同位置的节点如何对比有清晰的认识了。另外还有问题，那就是如何循环一个一个对比呢？&lt;/p>
&lt;p>这里要注意，新的节点的 children 是虚拟 DOM，所以这个 children 是一个数组，而对于之前提到的老的节点树是链表。&lt;/p>
&lt;p>那么循环一个一个对比，就是遍历数组的过程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">newIdx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 新数组的索引
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="p">(;&lt;/span> &lt;span class="nx">oldFiber&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">newIdx&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">newChildren&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">newIdx&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 遍历老的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nextOldFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">oldFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 返回复用节点的函数，newFiber 就是复用的节点。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果为空，就代表同位置对比已经不能复用了，循环结束。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">newFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">updateSlot&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">oldFiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newChildren&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">newIdx&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">newFiber&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 其他 code，比如删除复用的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这并不是源码的全部源码，我只是把思路给贴出来了。&lt;/p>
&lt;p>这是第一次遍历新数组，通过调用 &lt;code>updateSlot&lt;/code> 来对比新老元素，前面介绍的如何对比新老节点的代码都是在这个函数里。这个循环会把所以的从前面开始能复用的节点，都复用到。比如上面我们画的图，如果两个链表里面的 **？？？**节点，不相同，那么 newFiber 为 null，这个循环就会跳出。&lt;/p>
&lt;p>跳出来了，就会有两种情况。&lt;/p>
&lt;ul>
&lt;li>新节点已经遍历完毕&lt;/li>
&lt;li>老节点已经遍历完毕&lt;/li>
&lt;/ul>
&lt;h3 id="2-新节点已经遍历完毕">2. 新节点已经遍历完毕&lt;/h3>
&lt;p>如果新节点已经遍历完毕的话，也就是没有要更新的了，这种情况一般就是从原来的数组里面删除了元素，那么直接把剩下的老节点删除了就行了。还是拿上面的图的例子举例，老的链表里**？？？&lt;strong>还有很多节点，而新的链表&lt;/strong>？？？&lt;strong>已经没有节点了，所以老的链表&lt;/strong>？？？**不管是有多少节点，都不能复用了，所以没用了，直接删除。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">newIdx&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">newChildren&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 新的 children 长度已经够了，所以把剩下的删除掉
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">deleteRemainingChildren&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">oldFiber&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">resultingFirstChild&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意这里是直接 &lt;code>return&lt;/code> 了哦，没有继续往下执行了。&lt;/p>
&lt;h3 id="3-老节点已经遍历完毕">3. 老节点已经遍历完毕&lt;/h3>
&lt;p>如果老的节点在第一次循环的时候就被复用完了，新的节点还有，很有可能就是新增了节点的情况。那么这个时候只需要根据把剩余新的节点直接创建 &lt;strong>Fiber&lt;/strong> 就行了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">oldFiber&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果老的节点已经被复用完了，对剩下的新节点进行操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(;&lt;/span> &lt;span class="nx">newIdx&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">newChildren&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">newIdx&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">newFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createChild&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newChildren&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">newIdx&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">resultingFirstChild&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>oldFiber === null&lt;/code> 就是用来判断老的 Fiber 节点变量完了的代码，Fiber 链表是一个单向链表，所以为 null 的时候代表已经结束了。所以就直接把剩余的 newChild 通过循环创建 Fiber。&lt;/p>
&lt;p>到这里，目前简单的对数组进行增、删节点的对比还是比较简单，接下来就是移动的情况是如何进行复用的呢？&lt;/p>
&lt;h3 id="4-移动的情况如何进行节点复用">4. 移动的情况如何进行节点复用&lt;/h3>
&lt;p>对于移动的情况，首先要思考，怎么能判断数组是否发生过移动操作呢？&lt;/p>
&lt;p>如果给你两个数组，你是否能判断出来数组是否发生过移动。&lt;/p>
&lt;p>答案是：老的数组和新的数组里面都有这个元素，而且位置不相同。&lt;/p>
&lt;p>从两个数组中找到相同元素(是指可复用的节点)，方法有很多种，来看看 React 是如何高效的找出来的。&lt;/p>
&lt;p>&lt;strong>把所有老数组元素按 key 或者是 index 放 Map 里，然后遍历新数组，根据新数组的 key 或者 index 快速找到老数组里面是否有可复用的。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">mapRemainingChildren&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">string&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="nx">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">existingChildren&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">string&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="nx">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Map&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">existingChild&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">currentFirstChild&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// currentFirstChild 是老数组链表的第一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">existingChild&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 看到这里可能会疑惑怎么在 Map 里面的key 是 fiber 的key 还是 fiber 的 index 呢？
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 我觉得是根据数据类型，fiber 的key 是字符串，而 index 是数字，这样就能区分了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 所以这里是用的 map，而不是对象，如果是对象的key 就不能区分 字符串类型和数字类型了。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">existingChild&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">existingChildren&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">existingChild&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">existingChild&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">existingChildren&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">existingChild&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">existingChild&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">existingChild&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">existingChild&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">existingChildren&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 &lt;code>mapRemainingChildren&lt;/code> 就是将老数组存放到 Map 里面。元素有 key 就 Map 的键就存 key，没有 key 就存 index，key 一定是字符串，index 一定是 number，所以取的时候是能区分的，所以这里用的是 Map，而不是对象，如果是对象，属性是字符串，就没办法区别是 key 还是 index 了。&lt;/p>
&lt;p>现在有了这个 Map，剩下的就是循环新数组，找到 Map 里面可以复用的节点，如果找不到就创建，这个逻辑基本上跟 &lt;code>updateSlot&lt;/code> 的复用逻辑很像，一个是从老数组链表中获取节点对比，一个是从 Map 里获取节点对比。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 如果前面的算法有复用，那么 newIdx 就不从 0 开始
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="p">(;&lt;/span> &lt;span class="nx">newIdx&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">newChildren&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">newIdx&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">newFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">updateFromMap&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">existingChildren&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">returnFiber&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newIdx&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newChildren&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">newIdx&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 省略删除 existingChildren 中的元素和添加 Placement 副作用的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到这里新数组遍历完毕，也就是&lt;strong>同一层&lt;/strong>的 Diff 过程完毕，接下来进行总结一下。&lt;/p>
&lt;h3 id="效果演示">效果演示&lt;/h3>
&lt;p>以下效果动态演示来自于文章：&lt;a href="https://slane.cn/2018/08/09/react-diff-yuan-ma-fen-xi/" target="_blank" rel="noopener">React Diff 源码分析&lt;/a>，我觉得这个演示非常的形象，有助于理解。&lt;/p>
&lt;p>这里渲染一个可输入的数组。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-07-28-134128.png" alt="1" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当第一种情况，新数组遍历完了，老数组剩余直接删除（12345→1234 删除 5）：&lt;/p>
&lt;p>新数组没完，老数组完了（1234→1234567 插入 567）：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-07-28-134136.gif" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>移动的情况，即之前就存在这个元素，后续只是顺序改变（123 → 4321 插入 4，移动 2 1）：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/2019-07-28-134140.gif" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后删除没有涉及的元素。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>对于数组的 diff 策略，相对比较复杂，最后来梳理一下这个策略，其实还是很简单，只是看源码的时候比较难懂。&lt;/p>
&lt;p>我们可以把整个过程分为三个阶段：&lt;/p>
&lt;ol>
&lt;li>第一遍历新数组，新老数组相同 index 进行对比，通过 &lt;code>updateSlot&lt;/code>方法找到可以复用的节点，直到找到不可以复用的节点就退出循环。&lt;/li>
&lt;li>第一遍历完之后，删除剩余的老节点，追加剩余的新节点的过程。如果是新节点已遍历完成，就将剩余的老节点批量删除；如果是老节点遍历完成仍有新节点剩余，则将新节点直接插入。&lt;/li>
&lt;li>把所有老数组元素按 key 或 index 放 Map 里，然后遍历新数组，插入老数组的元素，这是移动的情况。&lt;/li>
&lt;/ol>
&lt;h2 id="后记-1">后记&lt;/h2>
&lt;p>刚开始阅读源码的过程是非常的痛苦的，但是当你一遍一遍的把作者想要表达的理解了，为什么要这么写 理解了，会感到作者的设计是如此的精妙绝伦，每一个变量，每一行代码感觉都是精心设计过的，然后感受到自己与大牛的差距，激发自己的动力。&lt;/p>
&lt;p>更多的对于 React 原理相关，源码相关的内容，请关注我的 github：&lt;a href="https://github.com/crazylxr/deep-in-react" target="_blank" rel="noopener">Deep In React&lt;/a> 或者 个人博客：&lt;a href="http://www.taoweng.site/" target="_blank" rel="noopener">桃园&lt;/a>&lt;/p>
&lt;p>我是桃翁，一个爱思考的前端 er，想了解关于更多的前端相关的，请关注我的公号：「前端桃园」&lt;/p></description></item><item><title>2018-司徒正美-React Fiber 架构</title><link>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2018-%E5%8F%B8%E5%BE%92%E6%AD%A3%E7%BE%8E-react-fiber-%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2018-%E5%8F%B8%E5%BE%92%E6%AD%A3%E7%BE%8E-react-fiber-%E6%9E%B6%E6%9E%84/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">原文地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="react-fiber-架构">React Fiber 架构&lt;/h1>
&lt;blockquote>
&lt;p>性能优化是一个系统性的工程，如果只看到局部，引入算法，当然是越快越好; 但从整体来看，在关键点引入缓存，可以秒杀 N 多算法，或另辟蹊径，探索事件的本质，可能用户要的并不是快……&lt;/p>
&lt;/blockquote>
&lt;p>React16 启用了全新的架构，叫做 Fiber，其最大的使命是解决大型 React 项目的性能问题，再顺手解决之前的一些痛点。&lt;/p>
&lt;h2 id="痛点">痛点&lt;/h2>
&lt;p>主要有如下几个：&lt;/p>
&lt;ul>
&lt;li>组件不能返回数组，最见的场合是 UL 元素下只能使用 LI，TR 元素下只能使用 TD 或 TH，这时这里有一个组件循环生成 LI 或 TD 列表时，我们并不想再放一个 DIV，这会破坏 HTML 的语义。&lt;/li>
&lt;li>弹窗问题，之前一直使用不稳定的 unstable_renderSubtreeIntoContainer。弹窗是依赖原来 DOM 树的上下文，因此这个 API 第一个参数是组件实例，通过它得到对应虚拟 DOM，然后一级级往上找，得到上下文。它的其他参数也很好用，但这个方法一直没有转正。。。&lt;/li>
&lt;li>异常处理，我们想知道哪个组件出错，虽然有了 React DevTool，但是太深的组件树查找起来还是很吃力。希望有个方法告诉我出错位置，并且出错时能让我有机会进行一些修复工作&lt;/li>
&lt;li>HOC 的流行带来两个问题，毕竟是社区兴起的方案，没有考虑到 ref 与 context 的向下传递。&lt;/li>
&lt;li>组件的性能优化全凭人肉，并且主要集中在 SCU，希望框架能干些事情，即使不用 SCU，性能也能上去。&lt;/li>
&lt;/ul>
&lt;h2 id="解决进度">解决进度&lt;/h2>
&lt;ul>
&lt;li>16.0 让组件支持返回任何数组类型，从而解决数组问题; 推出 createPortal API ,解决弹窗问题; 推出 componentDidCatch 新钩子， 划分出错误组件与边界组件， 每个边界组件能修复下方组件错误一次， 再次出错，转交更上层的边界组件来处理，解决异常处理问题。&lt;/li>
&lt;li>16.2 推出 Fragment 组件，可以看作是数组的一种语法糖。&lt;/li>
&lt;li>16.3 推出 createRef 与 forwardRef 解决 Ref 在 HOC 中的传递问题，推出 new Context API，解决 HOC 的 context 传递问题（主要是 SCU 作崇）&lt;/li>
&lt;li>而性能问题，从 16.0 开始一直由一些内部机制来保证，涉及到批量更新及基于时间分片的限量更新。&lt;/li>
&lt;/ul>
&lt;h2 id="一个小实验">一个小实验&lt;/h2>
&lt;p>我们可以通过以下实验来窥探 React16 的优化思想。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">randomHexColor&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;#&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;0000&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x1000000&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">substr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">setTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getElementById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;root&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">10000&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">k&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">el&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;div&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">el&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">innerHTML&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">k&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">appendChild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">el&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">el&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">style&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cssText&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sb">`background:&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">randomHexColor&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">;height:40px`&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">},&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个拥有 10000 个节点的插入操作，包含了 innerHTML 与样式设置，花掉 1000ms。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-87527d4cd261c4aebad9fdfa827076f0_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们再改进一下，分派次插入节点，每次只操作 100 个节点，共 100 次，发现性能异常的好！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">randomHexColor&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;#&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;0000&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0x1000000&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">toString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nx">substr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">getElementById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;root&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">setTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">loop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">k&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">el&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;div&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">el&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">innerHTML&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">k&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">root&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">appendChild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">el&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">el&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">style&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cssText&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sb">`background:&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">randomHexColor&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">;height:40px`&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">setTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">loop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">loop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">},&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-2cae392020e785dd07986e9f9029205f_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>究其原因是因为浏览器是单线程，它将 GUI 描绘，时间器处理，事件处理，JS 执行，远程资源加载统统放在一起。当做某件事，只有将它做完才能做下一件事。如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化，一些 DOM 操作，内部也会对 reflow 进行处理。reflow 是一个性能黑洞，很可能让页面的大多数元素进行重新布局。&lt;/p>
&lt;p>浏览器的运作流程&lt;/p>
&lt;blockquote>
&lt;p>渲染 -&amp;gt; tasks -&amp;gt; 渲染 -&amp;gt; tasks -&amp;gt; 渲染 -&amp;gt; tasks -&amp;gt; &amp;hellip;.&lt;/p>
&lt;/blockquote>
&lt;p>这些 tasks 中有些我们可控，有些不可控，比如 setTimeout 什么时候执行不好说，它总是不准时; 资源加载时间不可控。但一些 JS 我们可以控制，让它们分派执行，tasks 的时长不宜过长，这样浏览器就有时间优化 JS 代码与修正 reflow！下图是我们理想中的渲染过程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-8a94e1428849853e4ab91407c4f2a85a_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>总结一句，&lt;strong>就是让浏览器休息好，浏览器就能跑得更快&lt;/strong>。&lt;/p>
&lt;h2 id="如何让代码断开重连">如何让代码断开重连&lt;/h2>
&lt;p>JSX 是一个快乐出奇蛋，一下子满足你两个愿望：&lt;strong>组件化&lt;/strong>与&lt;strong>标签化&lt;/strong>。并且 JSX 成为组件化的标准化语言。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">Foo&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">Bar&lt;/span> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">Foo&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但标签化是天然套嵌的结构，意味着它会最终编译成递归执行的代码。因此 React 团队称 React16 之前的调度器为栈调度器，栈没有什么不好，栈显浅易懂，代码量少，但它的坏处不能随意 break 掉，continue 掉。根据我们上面的实验，break 后我们还要重新执行，我们需要一种链表的结构。&lt;/p>
&lt;p>链表是对异步友好的。链表在循环时不用每次都进入递归函数，重新生成什么执行上下文，变量对象，激活对象，性能当然比递归好。&lt;/p>
&lt;p>因此 Reat16 设法将组件的递归更新，改成链表的依次执行。如果页面有多个虚拟 DOM 树，那么就将它们的根保存到一个数组中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ReactDOM&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">A&lt;/span> &lt;span class="o">/&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">node1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ReactDOM&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">B&lt;/span> &lt;span class="o">/&amp;gt;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">node2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//node1与node2不存在包含关系，那么这页面就有两棵虚拟DOM树
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果仔细阅读源码，React 这个纯视图库其实也是三层架构。在 React15 有&lt;code>虚拟DOM层&lt;/code>，它只负责&lt;strong>描述&lt;/strong>结构与逻辑;&lt;code>内部组件层&lt;/code>，它们负责组件的更新, ReactDOM.render、 setState、 forceUpdate 都是与它们打交道，能让你多次 setState，只执行一次真实的渲染, 在适合的时机执行你的组件实例的生命周期钩子; &lt;code>底层渲染层&lt;/code>， 不同的显示介质有不同的渲染方法，比如说浏览器端，它使用元素节点，文本节点，在 Native 端，会调用 oc， java 的 GUI， 在 canvas 中，有专门的 API 方法。。。&lt;/p>
&lt;p>虚拟 DOM 是由 JSX 转译过来的，JSX 的入口函数是 React.createElement, 可操作空间不大， 第三大的底层 API 也非常稳定，因此我们只能改变第二层。&lt;/p>
&lt;p>React16 将内部组件层改成 Fiber 这种数据结构，因此它的架构名也改叫 Fiber 架构。Fiber 节点拥有 return, child, sibling 三个属性，分别对应父节点， 第一个孩子， 它右边的兄弟， 有了它们就足够将一棵树变成一个链表， 实现深度优化遍历。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-453e1f48a4f53356bee021c90ee00bed_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="如何决定每次更新的数量">如何决定每次更新的数量&lt;/h2>
&lt;p>在 React15 中，每次更新时，都是从根组件或 setState 后的组件开始，更新整个子树，我们唯一能做的是，在某个节点中使用 SCU 断开某一部分的更新，或者是优化 SCU 的比较效率。&lt;/p>
&lt;p>React16 则是需要将虚拟 DOM 转换为 Fiber 节点，首先它规定一个时间段内，然后在这个时间段能转换多少个 FiberNode，就更新多少个。&lt;/p>
&lt;p>因此我们需要将我们的更新逻辑分成两个阶段，第一个阶段是将虚拟 DOM 转换成 Fiber, Fiber 转换成组件实例或真实 DOM（不插入 DOM 树，插入 DOM 树会 reflow）。Fiber 转换成后两者明显会耗时，需要计算还剩下多少时间。并且转换实例需要调用一些钩子，如 componentWillMount, 如果是重复利用已有的实例，这时就是调用 componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate,这时也会耗时。&lt;/p>
&lt;p>为了让读者能直观了解 React Fiber 的运作过程，我们简单实现一下 ReactDOM.render, 但不保证会跑起来。&lt;/p>
&lt;p>首先是一些简单的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">queue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ReacDOM&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">render&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">container&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">root&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">updateFiberAndView&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">getVdomFormQueue&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">shift&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">vnode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="nx">vnode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">vnode&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">uuid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">random&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//我们简单的Fiber目前来看，只比vdom多了一个uuid属性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="nx">toFiber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">vnode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">vnode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">uuid&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">vnode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">vnode&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>updateFiberAndView 要实现 React 的时间分片，我们先用 setTimeout 模拟。我们暂时不用理会 updateView 怎么实现，可能它就是 updateComponentOrElement 中将它们放到又一个列队，需再出来执行 insertBefore, componentDidMount 操作呢！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">updateFiberAndView&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">deadline&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">updateView&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">//更新视图，这会耗时，因此需要check时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">deadline&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">vdom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">getVdomFormQueue&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">vdom&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">firstFiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">hasVisited&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//深度优先遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">toFiber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//A处
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">firstFiber&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fibstFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">hasVisited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">uuid&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hasVisited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">uuid&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//根据fiber.type实例化组件或者创建真实DOM
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//这会耗时，因此需要check时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">updateComponentOrElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//向下转换
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">newDate&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nx">deadline&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//时间不够，放入栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//让逻辑跑回A处，不断转换child, child.child, child.child.child
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果组件没有children，那么就向右找
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//让逻辑跑回A处
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 向上找
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">fibstFiber&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">setTimeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">updateFiberAndView&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>里面有一个 do while 循环，每一次都是小心翼翼进行计时，时间不够就将来不及处理的节点放进列队。&lt;/p>
&lt;p>updateComponentOrElement 无非是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">updateComponentOrElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stateNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">props&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">stateNode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">typeof&lt;/span> &lt;span class="nx">type&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;string&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stateNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">type&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">context&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{};&lt;/span> &lt;span class="c1">//暂时免去这个获取细节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stateNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">props&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">stateNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//执行componentWillMount等钩子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">children&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">stateNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">children&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">childen&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//这里只是mount的实现，update时还需要一个oldChildren, 进行key匹配，重复利用已有节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">var&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">children&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">prev&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">prev&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此这样 Fiber 的 return, child, sibling 就有了，可以 happy 地进行深度优先遍历了。&lt;/p>
&lt;h2 id="如何调度时间才能保证流畅">如何调度时间才能保证流畅&lt;/h2>
&lt;p>刚才的 updateFiberAndView 其实有一个问题，我们安排了 100ms 来更新视图与虚拟 DOM，然后再安排 40ms 来给浏览器来做其他事。如果我们的虚拟 DOM 树很小，其实不需要 100ms; 如果我们的代码之后， 浏览器有更多其他事要干， 40ms 可能不够。IE10 出现了 setImmediate，requestAnimationFrame 这些新定时器，让我们这些前端，其实浏览器有能力让页面更流畅地运行起来。&lt;/p>
&lt;p>浏览器本身也不断进化中，随着页面由简单的展示转向 WebAPP，它需要一些新能力来承载更多节点的展示与更新。&lt;/p>
&lt;p>下面是一些自救措施：&lt;/p>
&lt;ul>
&lt;li>requestAnimationFrame&lt;/li>
&lt;li>requestIdleCallback&lt;/li>
&lt;li>web worker&lt;/li>
&lt;li>IntersectionObserver&lt;/li>
&lt;/ul>
&lt;p>我们依次称为浏览器层面的帧数控制调用，闲时调用，多线程调用， 进入可视区调用。&lt;/p>
&lt;p>requestAnimationFrame 在做动画时经常用到，jQuery 新版本都使用它。web worker 在 angular2 开始就释出一些包，实验性地用它进行 diff 数据。IntersectionObserver 可以用到 ListView 中。而 requestIdleCallback 是一个生脸孔，而 React 官方恰恰看上它。&lt;/p>
&lt;p>刚才说 updateFiberAndView 有出两个时间段，一个给自己的，一个给浏览器的。requestAnimationFrame 能帮我们解决第二个时间段，从而确保整体都是 60 帧或 75 帧（这个帧数可以在操作系统的显示器刷新频率中设置）流畅运行。&lt;/p>
&lt;p>我们看 requestIdleCallback 是怎么解决这问题的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-e1ba24e51c372e7c824bdf4df5a41555_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>它的第一个参数是一个回调，回调有一个参数对象，对象有一个 timeRemaining 方法，就相当于&lt;code>new Date - deadline&lt;/code>，并且它是一个高精度数据， 比毫秒更准确， 至少浏览器到底安排了多少时间给更新 DOM 与虚拟 DOM，我们不用管。第二个时间段也不用管，不过浏览器可能 1，2 秒才执行这个回调，因此为了保险起见，我们可以设置第二个参数，让它在回调结束后 300ms 才执行。要相信浏览器，因为都是大牛们写的，时间的调度比你安排更有效率。&lt;/p>
&lt;p>于是我们的 updateFiberAndView 可以改成这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">updateFiberAndView&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">updateView&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">//更新视图，这会耗时，因此需要check时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">timeRemaining&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">vdom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">getVdomFormQueue&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">vdom&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">firstFiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">hasVisited&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//深度优先遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">toFiber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//A处
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">firstFiber&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fibstFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">hasVisited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">uuid&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hasVisited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">uuid&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//根据fiber.type实例化组件或者创建真实DOM
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//这会耗时，因此需要check时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">updateComponentOrElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//向下转换
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">timeRemaining&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//时间不够，放入栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//让逻辑跑回A处，不断转换child, child.child, child.child.child
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//....略
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">requetIdleCallback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">updateFiberAndView&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">timeout&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到这里，ReactFiber 基于时间分片的限量更新讲完了。实际上 React 为了照顾绝大多数的浏览器，自己实现了 requestIdleCallback。&lt;/p>
&lt;h2 id="批量更新">批量更新&lt;/h2>
&lt;p>但 React 团队觉得还不够，需要更强大的东西。因为有的业务对视图的实时同步需求并不强烈，希望将所有逻辑都跑完才更新视图，于是有了 batchedUpdates，目前它还不是一个稳定的 API，因此大家使用它时要这样用 ReactDOM.unstable_batchedUpdates。&lt;/p>
&lt;p>这个东西怎么实现呢？就是搞一个全局的开关，如果打开了，就让 updateView 不起作用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">isBatching&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">batchedUpdates&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">callback&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">event&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">keepbook&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">isBatching&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">isBatching&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">callback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">event&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">isBatching&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">keepbook&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">isBatching&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">requetIdleCallback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">updateFiberAndView&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">timeout&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="nb">Date&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">updateView&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">isBatching&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//更新视图
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>事实上，当然没有这么简单，考虑到大家看不懂 React 的源码，大家可以看一下 anujs 是怎么实现的：&lt;/p>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/RubyLouvre/anu/blob/master/packages/fiber/scheduleWork.js%23L94-L113" target="_blank" rel="noopener">https://github.com/RubyLouvre/anu/blob/master/packages/fiber/scheduleWork.js#L94-L113&lt;/a>&lt;/p>
&lt;p>React 内部也大量使用 batchedUpdates 来优化用户代码，比如说在事件回调中 setState，在 commit 阶段的钩子（componentDidXXX）中 setState 。&lt;/p>
&lt;p>可以说，&lt;code>setState是对单个组件的合并渲染，batchedUpdates是对多个组件的合并渲染&lt;/code>。合并渲染是 React 最主要的优化手段。&lt;/p>
&lt;h2 id="为什么使用深度优化遍历">为什么使用深度优化遍历&lt;/h2>
&lt;p>React 通过 Fiber 将树的遍历变成了链表的遍历，但遍历手段有这么多种，为什么偏偏使用 DFS？！&lt;/p>
&lt;p>这涉及一个很经典的消息通信问题。如果是父子通信，我们可以通过 props 进行通信，子组件可以保存父的引用，可以随时 call 父组件。如果是多级组件间的通信，或不存在包含关系的组件通信就麻烦了，于是 React 发明了上下文对象（context）。&lt;/p>
&lt;p>context 一开始是一个空对象，为了方便起见，我们称之为&lt;strong>unmaskedContext&lt;/strong>。&lt;/p>
&lt;p>当它遇到一个有 getChildContext 方法的组件时，那个方法会产生一个新 context,与上面的合并，然后将新 context 作为 unmaskedContext 往下传。&lt;/p>
&lt;p>当它遇到一个有 contextTypes 的组件，context 就抽取一部分内容给这个组件进行实例化。这个只有部分内容的 context，我们称之为&lt;strong>maskedContext&lt;/strong>。&lt;/p>
&lt;p>组件总是从 unmaskedContext 中割一块肉下来作为自己的 context。可怜！&lt;/p>
&lt;p>如果子组件没有 contextTypes，那么它就没有任何属性。&lt;/p>
&lt;p>在 React15 中，为了传递 unmaskedContext，于是大部分方法与钩子都留了一个参数给它。但这么大架子的 context 竟然在文档中没有什么地位。那时 React 团队还没有想好如何处理组件通信，因此社区一直用舶来品 Redux 来救命。这情况一直到 Redux 的作者入主 React 团队。&lt;/p>
&lt;p>还有一个隐患，它可能被 SCU 比较时是用 maskedContext，而不是 unmaskedContext。&lt;/p>
&lt;p>基于这些问题，终于 new Context API 出来了。首先， unmaskedContext 不再像以前那样各个方法中来往穿梭了，有一个独立的 contextStack。开始时就 push 进一个空对象，到达某个组件需要实例化时，就取它第一个。当再次访问这个组件时， 就像它从栈中弹出。因此我们需要深度优先遍历，保证每点节点都访问两次。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-d629ff51df8b827d6465514c31467179_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>相同的情况还有 container，container 是我们某个元素虚拟 DOM 需要用到的真实父节点。在 React15 中，它会装在一个 containerInfo 对象也层层传送。&lt;/p>
&lt;p>我们知道，虚拟 DOM 分成两大类，一种是组件虚拟 DOM，type 为函数或类，它本身不产生节点，而是生成组件实例，而通过 render 方法，产生下一级的虚拟 DOM。一种是元素虚拟 DOM，type 为标签名，会产生 DOM 节点。上面的元素虚拟 DOM 的 stateNode（DOM 节点），就是下方的元素虚拟 DOM 的 contaner。&lt;/p>
&lt;p>这种独立的栈机制有效地解决了内部方法的参数冗余问题。&lt;/p>
&lt;p>但有一个问题，当第一次渲染完毕后，contextStack 置为空了。然后我们位于虚拟 DOM 树的某个组件 setState，这时它的 context 应该如何获取呢？React 的解决方式是，每次都是从根开始渲染，通过 updateQueue 加速跳过没有更新的 节点——每个组件在 setState 或 forceUpdate 时，都会创建一个 updateQueue 属性在它的上面。anujs 则是保存它之前的 unmaskedContext 到实例上，unmaskedContext 可以看作是上面所有 context 的并集，并且一个可以当多个使用。&lt;/p>
&lt;p>当我们批量更新时，可能有多少不连续的子组件被更新了，其中两个组件之间的某个组件使用了 SCU return false，这个 SCU 应该要被忽视。 因此我们引用一些变量让它透明化。就像 forceUpdate 能让组件无视 SCU 一样。&lt;/p>
&lt;h2 id="为什么要对生命周期钩子大换血">为什么要对生命周期钩子大换血&lt;/h2>
&lt;p>React 将虚拟 DOM 的更新过程划分两个阶段，reconciler 阶段与 commit 阶段。reconciler 阶段对应早期版本的 diff 过程，commit 阶段对应早期版本的 patch 过程。&lt;/p>
&lt;p>一些迷你 React，如 preact 会将它们混合在一起，一边 diff 一边 patch(幸好它使用了 Promise.then 来优化，确保每次只更新一个组件) 。&lt;/p>
&lt;p>有些迷你 React 则是通过减少移动进行优化，于是绞尽脑汁，用上各种算法，最短编辑距离，最长公共子序列，最长上升子序列。。。&lt;/p>
&lt;p>其实基于算法的优化是一种绝望的优化，就类似玛雅文明因为找不到铜矿一直停留于石器时代，诞生了伟大的工匠精神把石器打磨得美伦美奂。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-fa296a08d4a6290397681e7a3b14f572_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>之所以这么说，因为 diff 算法都用于组件的新旧 children 比较，children 一般不会出现过长的情况，有点大炮打蚊子。况且当我们的应用变得非常庞大，页面有上万个组件，要 diff 这么多组件，再卓绝的算法也不能保证浏览器不会累趴。因为他们没想到浏览器也会累趴，也没有想到这是一个长跑的问题。如果是 100 米短跑，或者 1000 米竞赛，当然越快越好。如果是马拉松，就需要考虑到保存体力了，需要注意休息了。性能是一个系统性的工程。&lt;/p>
&lt;p>在我们的代码里面，&lt;code>休息&lt;/code>就是检测时间然后断开 Fiber 链。&lt;/p>
&lt;p>updateFiberAndView 里面先进行 updateView，由于节点的更新是不可控，因此全部更新完，才检测时间。并且我们完全不用担心 updateView 会出问题，因为 updateView 实质上是在 batchedUpdates 中，里面有 try catch。而接下来我们基于 DFS 更新节点，每个节点都要 check 时间，这个过程其实很害怕出错的， 因为组件在挂载过程中会调三次钩子/方法（constructor, componentWillMount, render）， 组件在更新过程中会调 4 次钩子 （componentWillReceiveProps, shouldUpdate, componentWillUpdate）, 总不能每个方法都用 try catch 包起来，这样会性能很差。而 constructor, render 是不可避免的，于是对三个 willXXX 动刀了。&lt;/p>
&lt;p>在早期版本中，componentWillMount 与 componentWillReceiveProps 会做内部优化，执行多次 setState 都会延后到 render 时进行合并处理。因此用户就肆意 setState 了。这些 willXXX 还可以让用户任意操作 DOM。 操作 DOM 会可能 reflow，这是官方不愿意看到的。于是官方推出了 getDerivedStateFromProps，让你在 render 设置新 state，你主要返回一个新对象，它就主动帮你 setState。由于这是一个静态方法，你不能操作 instance，这就阻止了你多次操作 setState。由于没有 instance,也就没有&lt;a href="https://link.zhihu.com/?target=http%3A//instance.refs.xxx" target="_blank" rel="noopener">http://instance.refs.xxx&lt;/a>，你也没有机会操作 DOM 了。这样一来，getDerivedStateFromProps 的逻辑应该会很简单，这样就不会出错，不会出错，就不会打断 DFS 过程。&lt;/p>
&lt;p>getDerivedStateFromProps 取代了原来的 componentWillMount 与 componentWillReceiveProps 方法，而 componentWillUpdate 本来就是可有可无，以前完全是为了对称好看。&lt;/p>
&lt;p>在即使到来的异步更新中，reconciler 阶段可能执行多次，才执行一次 commit，这样也会导致 willXXX 钩子执行多次，违反它们的语义，它们的废弃是不可逆转的。&lt;/p>
&lt;p>在进入 commi 阶段时，组件多了一个新钩子叫 getSnapshotBeforeUpdate，它与 commit 阶段的钩子一样只执行一次。&lt;/p>
&lt;p>如果出错呢，在 componentDidMount/Update 后，我们可以使用 componentDidCatch 方法。于是整个流程变成这样：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-00e64705c849952d58fde002fec930f6_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>reconciler 阶段的钩子都不应该操作 DOM，最好也不要 setState，我们称之为***轻量钩子**。commit 阶段的钩子则对应称之为**重量钩子**。&lt;/p>
&lt;h2 id="任务系统">任务系统&lt;/h2>
&lt;p>updateFiberAndView 是位于一个 requestIdleCallback 中，因此它的时间很有限，分给 DFS 部分的时间也更少，因此它们不能做太多事情。这怎么办呢，标记一下，留给 commit 阶段做。于是产生了一个任务系统。&lt;/p>
&lt;p>每个 Fiber 分配到新的任务时，就通过位操作，累加一个 sideEffect。sideEffect 字面上是副作用的意思，非常重 FP 流的味道，但我们理解为任务更方便我们的理解。&lt;/p>
&lt;p>每个 Fiber 可能有多个任务，比如它要插入 DOM 或移动，就需要加上 Replacement，需要设置样式，需要加上 Update。&lt;/p>
&lt;p>怎么添加任务呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">effectTag&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="nx">Update&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>怎么保证不会重复添加相同的任务？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">effectTag&lt;/span> &lt;span class="o">&amp;amp;=&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="nx">DidCapture&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 commit 阶段，怎么知道它包含了某项任务？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">effectTag&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nx">Update&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*操作属性*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>React 内置这么多任务，从 DOM 操作到 Ref 处理到回调唤起。。。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-bb1513412a67e243c77ba3a918ca475b_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>顺便说一下 anu 的任务名，是基于素数进行乘除。&lt;/p>
&lt;p>&lt;a href="https://link.zhihu.com/?target=https%3A//github.com/RubyLouvre/anu/blob/master/packages/fiber/commitWork.js" target="_blank" rel="noopener">https://github.com/RubyLouvre/anu/blob/master/packages/fiber/commitWork.js&lt;/a>&lt;/p>
&lt;p>无论是位操作还是素数，我们只要保证某个 Fiber 的相同性质任务只执行一次就行了。&lt;/p>
&lt;p>此外，任务系统还有另一个存在意义，保证一些任务优先执行，某些任务是在另一些任务之前。我们称之为任务分拣。这就像快递的仓库管理一样，有了归类才好进行优化。比如说，元素虚拟 DOM 的插入移动操作必须在所有任务之前执行，移除操作必须在 componentWillUnmount 后执行。这些任务之所以是这个顺序，因为这样做才合理，都经过高手们的严密推敲，经过 React15 时代的大众验证。&lt;/p>
&lt;h2 id="fiber-的连体婴结构">Fiber 的连体婴结构&lt;/h2>
&lt;p>连体婴是一个可怕的名词，想想就不舒服，因为事实上 Fiber 就是一个不寻常的结构，直到现在我的 anujs 还没有很好实现这结构。Fiber 有一个叫 alternate 的属性，你们称之为备胎，替死鬼，替身演员。你也可以视它为 git 的开发分支，稳定没错的那个则是 master。每次 setState 时，组件实例 stateNode 上有一个_reactInternalFiber 的对象，就是 master 分支，然后立即复制一个一模一样的专门用来踩雷的 alternate 对象。&lt;/p>
&lt;p>alternate 对象会接受上方传递下来的新 props，然后从 getDerivedStateFromProps 得到新 state，于是 render 不一样的子组件，子组件再 render，渐渐的，master 与 alternate 的差异越来越大，当某一个子组件出错，于是我们又回滚到该边界组件的 master 分支。&lt;/p>
&lt;p>可以说，React16 通过 Fiber 这种数据结构模拟了 git 的三种重要操作， git add, git commit, git revert。&lt;/p>
&lt;p>有关连体婴结构的思考，可以参看我另一篇文章&lt;a href="https://zhuanlan.zhihu.com/p/36476969" target="_blank" rel="noopener">《从错误边界到回滚到 MWI》&lt;/a>，这里就不再展开。&lt;/p>
&lt;h2 id="中间件系统">中间件系统&lt;/h2>
&lt;p>说起中间件系统，大家可能对 koa 与 redux 里面的洋葱模型比较熟悉。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-97f0a2fadcafcc4537d336a925ec58b0_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>早在 React15 时代，已经有一个叫 Transaction 的东西，与洋葱模型一模一样。在 Transaction 的源码中有一幅特别的 ASCII 图，形象的解释了 Transaction 的作用。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-2a02b111480b0f591fbf291f481709ac_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>简单地说，一个 Transaction 就是将需要执行的 method 使用 wrapper 封装起来，再通过 Transaction 提供的 perform 方法执行。而在 perform 之前，先执行所有 wrapper 中的 initialize 方法；perform 完成之后（即 method 执行后）再执行所有的 close 方法。一组 initialize 及 close 方法称为一个 wrapper，从上面的示例图中可以看出 Transaction 支持多个 wrapper 叠加。&lt;/p>
&lt;p>这个东西有什么用呢？ 最少有两个用处，在更新 DOM 时，收集当前获取焦点的元素与选区，更新结束后，还原焦点与选区（因为插入新节点会引起焦点丢失，document.activeElement 变成 body，或者是 autoFocus，让焦点变成其他 input，导致我们正在输入的 input 的光标不见了，无法正常输入）。在更新时，我们需要保存一些非受控组件，在更新后，对非受控组件进行还原（非受控组件是一个隐涩的知识点，目的是让那些没有设置 onChange 的表单元素无法手动改变它的值）。当然了，contextStack, containerStack 的初次入栈与清空也可以做成中间件。中间件就是分布在 batchedUpdates 的两侧，一种非常易于扩展的设计，为什么不多用用呢!&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>React Fiber 是对 React 来说是一次革命，解决了 React 项目严重依赖于手工优化的痛点，通过系统级别的时间调度，实现划时代的性能优化。鬼才般的 Fiber 结构，为异常边界提供了退路，也为限量更新提供了下一个起点。React 团队的人才济济，创造力非凡，别出心裁，从更高的层次处理问题，这是其他开源团队不可多见。这也是我一直选择与学习 React 的原因所在。&lt;/p>
&lt;p>但是和所有人一样，我最初学习 React16 的源码是非常痛苦的。后来观看他们团队的视频，深刻理解时间分片与 Fiber 的链表结构后，渐渐明确整个思路，不需要对 React 源码进行断点调试，也能将大体流程复制出来。俗话说，看不如写（就是写 anujs，欢迎大家加 star, &lt;a href="https://link.zhihu.com/?target=https%3A//github.com/RubyLouvre/anu" target="_blank" rel="noopener">https://github.com/RubyLouvre/anu&lt;/a>），与不如再复述出教会别人。于是便有了本文。&lt;/p></description></item><item><title>2021-「React Fiber」 详细解析</title><link>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-react-fiber-%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/react-notes/05.%E6%9E%B6%E6%9E%84%E6%9C%BA%E5%88%B6/%E5%9F%BA%E4%BA%8E-fiber-%E7%9A%84%E8%B0%83%E5%92%8C/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-react-fiber-%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/424967867" target="_blank" rel="noopener">原文地址&lt;/a>、&lt;a href="https://zhuanlan.zhihu.com/p/439911498" target="_blank" rel="noopener">原文地址&lt;/a> TODO!&lt;/p>
&lt;/blockquote>
&lt;h1 id="react-fiber-详细解析">「React Fiber」 详细解析&lt;/h1>
&lt;p>距离 React Fiber 发布已经两年多的时间了，你有没有真的了解它呢？&lt;/p>
&lt;p>React Fiber 是什么？官方的解释是 “&lt;strong>React Fiber 是对核心算法的一次重新实现”&lt;/strong>。&lt;/p>
&lt;p>使用 React 框架的开发者都知道，React 是靠数据驱动视图改变的一种框架，它的核心驱动方法就是用其提供的 setState 方法设置 state 中的数据从而驱动存放在内存中的虚拟 DOM 树的更新。&lt;/p>
&lt;p>更新方法就是通过 React 的 Diff 算法比较旧虚拟 DOM 树和新虚拟 DOM 树之间的 Change ，然后批处理这些改变。&lt;/p>
&lt;p>在 Fiber 诞生之前，React 处理一次 setState()（首次渲染）时会有两个阶段：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>调度阶段（Reconciler）&lt;/strong>：这个阶段 React 用新数据生成新的 Virtual DOM，遍历 Virtual DOM，然后通过 Diff 算法，快速找出需要更新的元素，放到更新队列中去。&lt;/li>
&lt;li>&lt;strong>渲染阶段（Renderer）&lt;/strong>：这个阶段 React 根据所在的渲染环境，遍历更新队列，将对应元素更新。在浏览器中，就是更新对应的 DOM 元素。&lt;/li>
&lt;/ul>
&lt;p>表面上看，这种设计也是挺合理的，因为更新过程不会有任何 I/O 操作，完全是 CPU 计算，所以无需异步操作，执行到结束即可。&lt;/p>
&lt;p>这个策略像函数调用栈一样，会深度优先遍历所有的 Virtual DOM 节点，进行 Diff 。它一定要等整棵 Virtual DOM 计算完成之后，才将任务出栈释放主线程。对于复杂组件，需要大量的 diff 计算，会严重影响到页面的交互性。&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;blockquote>
&lt;p>假设更新一个组件需要 1ms，如果有 200 个组件要更新，那就需要 200ms，在这 200ms 的更新过程中，浏览器唯一的主线程都在专心运行更新操作，无暇去做任何其他的事情。想象一下，在这 200ms 内，用户往一个 input 元素中输入点什么，敲击键盘也不会获得响应，因为渲染输入按键结果也是浏览器主线程的工作，但是浏览器主线程被 React 占用，抽不出空，最后的结果就是用户敲了按键看不到反应，等 React 更新过程结束之后，那些按键会一下出现在 input 元素里，这就是所谓的界面卡顿。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>React Fiber，就是为了解决渲染复杂组件时严重影响用户和浏览器交互的问题。&lt;/strong>&lt;/p>
&lt;h2 id="fiber-产生的原因">Fiber 产生的原因？&lt;/h2>
&lt;p>为了解决这个问题，react 推出了 Fiber，它能够将渲染工作分割成块并将其分散到多个帧中。同时加入了在新更新进入时暂停，中止或重复工作的能力和为不同类型的更新分配优先级的能力。&lt;/p>
&lt;p>至于上面提到的为什么会影响到用户体验，这里需要简单介绍一下浏览器的工作模式：&lt;/p>
&lt;p>因为浏览器的页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿，转换成时间就是 16ms 内如果当前帧内执行的任务没有完成，就会造成卡顿。&lt;/p>
&lt;p>一帧中执行的工作主要以下图所示的任务执行顺序单线程依次执行。&lt;/p>
&lt;p>如果其中一项任务执行的过久，导致总时长超过了 16ms，用户就会感觉到卡顿了&lt;/p>
&lt;blockquote>
&lt;p>上面提到的调和阶段，就属于下图的 js 的执行阶段。如果调和时间过长导致了这一阶段执行时间过长，那么就有可能在用户有交互的时候，本来应该是渲染下一帧了，但是在当前一帧里还在执行 JS，就导致用户交互不能马上得到反馈，从而产生卡顿感。&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-700f19419e81d9e9518385ccf2a634fa_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="fiber-的设计思路">Fiber 的设计思路&lt;/h2>
&lt;p>React 为了解决这个问题，根据浏览器的每一帧执行的特性，构思出了 Fiber 来将一次任务拆解成单元，以划分时间片的方式，按照 Fiber 的自己的调度方法，根据任务单元优先级，分批处理或吊起任务，将一次更新分散在多次时间片中，另外, 在浏览器空闲的时候, 也可以继续去执行未完成的任务, 充分利用浏览器每一帧的工作特性。&lt;/p>
&lt;p>它的实现的调用栈示意图如下所示，一次更新任务是分时间片执行的，直至完成某次更新。&lt;/p>
&lt;p>这样 React 更新任务就只能在规定时间内占用浏览器线程了, 如果说在这个时候用户有和浏览器的页面交互，浏览器也是可以及时获取到交互内容。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-398077dda18dd8a2055dc21c442e39e6_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="fiber-具体都做了什么">Fiber 具体都做了什么？&lt;/h2>
&lt;p>React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 &lt;strong>Virtual DOM Tree.&lt;/strong> 同时也会基于 Virtual DOM Tree 构建一个“结构相同” &lt;strong>Fiber Tree。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>Virtual DOM Tree 虚拟 DOM 树
虚拟 DOM 树的存在就是为了解决 js 直接操作真实 DOM 而引起的计算机计算能力的浪费。
因为通过 js 直接修改 DOM ，会引起整颗 DOM 树计算和改变，而虚拟 DOM 树的存在可以让真实 DOM 只改变必要改变的部分。&lt;/p>
&lt;/blockquote>
&lt;h3 id="1fiber-的调度单元-fiber-node">1、Fiber 的调度单元： Fiber Node&lt;/h3>
&lt;p>Fiber Node，是 Fiber Tree 的基本构成单元，也可以类比成 &lt;strong>Virtual DOM Tree&lt;/strong> 的一个节点(实际比它的节点多了很多上下文信息)，也是 Fiber 中的一个工作单元。一个 Fiber Node 包含了如下内容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">stateNode&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 单链表树结构
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="c1">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">child&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="c1">// 指向自己的第一个子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">sibling&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 更新相关
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">pendingProps&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 新的变动带来的新的props
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">memoizedProps&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 上一次渲染完成之后的props
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">updateQueue&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">UpdateQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">any&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 该Fiber对应的组件产生的Update会存放在这个队列里面
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">memoizedState&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 上一次渲染的时候的state
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Scheduler 相关
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 代表任务在未来的哪个时间点应该被完成，不包括他的子树产生的任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 快速确定子树中是否有不在等待的变化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">childExpirationTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 我们称他为`current &amp;lt;==&amp;gt; workInProgress`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 在渲染完成之后他们会交换位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">alternate&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Effect 相关的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">effectTag&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">SideEffectTag&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 用来记录Side Effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nextEffect&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 单链表用来快速查找下一个side effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">firstEffect&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 子树中第一个side effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">lastEffect&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 子树中最后一个side effect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中有几个属性需要重点关注：&lt;strong>return(父节点)、child(子节点)、sibling(兄弟节点)、stateNode（对应的 DOM 节点）&lt;/strong>，&lt;strong>expirationTime (到期时间)、Effect (变更)。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>return：向上链接整颗树&lt;/li>
&lt;li>child：向下链接整棵树&lt;/li>
&lt;li>sibling：横向链接整颗树&lt;/li>
&lt;li>stateNode：与 DOM 树相连&lt;/li>
&lt;li>expirationTime：计算节点更新的优先级&lt;/li>
&lt;li>Effect**：**记录节点的变更&lt;/li>
&lt;/ul>
&lt;p>通过节点上的 child（孩子）、return（父）和 sibling （兄弟）属性串联着其他节点，形成了一棵 Fiber Tree (类似 Virtual DOM tree)&lt;/p>
&lt;p>Fiber Tree 是由 Fiber Node 构成的，更像是一个单链表构成的树，便于向上/向下/向兄弟节点转换&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-cfaea6c0e9362b3701b1cf342ed4588b_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>简单总结一下：&lt;/p>
&lt;p>组件是 React 应用中的基础单元，应用以组件树形式组织，渲染组件；&lt;/p>
&lt;p>Fiber 调和的基础单元则是 fiber（调和单元），应用与 Fiber Tree 形式组织，应用 Fiber 算法；&lt;/p>
&lt;p>组件树和 fiber 树结构对应，一个组件实例有一个对应的 fiber 实例；&lt;/p>
&lt;p>Fiber 负责整个应用层面的调和，fiber 实例负责对应组件的调和；&lt;/p>
&lt;h3 id="2规定调度顺序expirationtime-到期时间">2、&lt;strong>规定调度顺序：expirationTime 到期时间&lt;/strong>&lt;/h3>
&lt;p>每个 Fiber Node 都会有一个 ExpirationTime 到期时间来确定当前时间片下是否执行该节点的更新任务。&lt;/p>
&lt;p>它是以任务什么时候该执行完为描述信息的，到期时间越短，则代表优先级越高。&lt;/p>
&lt;blockquote>
&lt;p>在 React 中，为防止某个 update 因为优先级的原因一直被打断而未能执行。React 会设置一个 ExpirationTime，当时间到了 ExpirationTime 的时候，如果某个 update 还未执行的话，React 将会强制执行该 update，这就是 ExpirationTime 的作用。&lt;/p>
&lt;/blockquote>
&lt;p>每一次 update 之前，Fiber 都会根据当下的时间（通过 requestCurrentTime 获取到）和 更新的触发条件为每个入更新队列的 Fiber Node 计算当下的到期时间。&lt;/p>
&lt;p>到期时间的计算有两种方式, 一种是对交互引起的更新做计算 computeInteractiveExpiration , 另一种对普通更新做计算 computeAsyncExpiration&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">computeExpirationForFiber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">currentTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Fiber&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ......
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mode&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nx">ConcurrentMode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">isBatchingInteractiveUpdates&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 交互引起的更新
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">expirationTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">computeInteractiveExpiration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">currentTime&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 普通异步更新
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">expirationTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">computeAsyncExpiration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">currentTime&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ......
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ......
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">expirationTime&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>computeInteractiveExpiration&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">HIGH_PRIORITY_EXPIRATION&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">__DEV__&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">500&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="mi">150&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">HIGH_PRIORITY_BATCH_SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="nx">computeInteractiveExpiration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">currentTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">computeExpirationBucket&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">HIGH_PRIORITY_EXPIRATION&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">//150
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">HIGH_PRIORITY_BATCH_SIZE&lt;/span> &lt;span class="c1">//100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>computeAsyncExpiration&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">LOW_PRIORITY_EXPIRATION&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5000&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">LOW_PRIORITY_BATCH_SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">250&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="nx">computeAsyncExpiration&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentTime&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">computeExpirationBucket&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LOW_PRIORITY_EXPIRATION&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">//5000
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">LOW_PRIORITY_BATCH_SIZE&lt;/span> &lt;span class="c1">//250
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看上面两种方法，我们发现其实他们调用的是同一个方法：computeExpirationBucket，只是传入的参数不一样，而且传入的是常量。computeInteractiveExpiration 传入的是 150、100，computeAsyncExpiration 传入的是 5000、250。说明前者的优先级更高。那么我把前者称为高优先级更新（交互引起），后者称为低优先级更新（其他更新）。&lt;/p>
&lt;p>&lt;strong>computeExpirationBucket&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">UNIT_SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">MAGIC_NUMBER_OFFSET&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">ceiling&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">num&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">precision&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">number&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">number&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(((&lt;/span>&lt;span class="nx">num&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nx">precision&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">precision&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">computeExpirationBucket&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentTime&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expirationInMs&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">bucketSizeMs&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">ExpirationTime&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">MAGIC_NUMBER_OFFSET&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ceiling&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">MAGIC_NUMBER_OFFSET&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">expirationInMs&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nx">UNIT_SIZE&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">bucketSizeMs&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nx">UNIT_SIZE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终的公式是：((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25&lt;/p>
&lt;p>其中只有只有 currentTime 是变量, currentTime 是通过浏览提供的 API（requestCurrentTime）获取的当前时间。&lt;/p>
&lt;p>简单来说，以低优先级来说, 最终结果是以 25 为单位向上增加的，比如说我们输入 102 - 126 之间，最终得到的结果都是 625，但是到了 127 得到的结果就是 650 了，这就是除以 25 取整的效果。
即，低优先级更新的 expirationTime 间隔是 25ms，抹平了 25ms 内计算过期时间的误差，React 让两个相近（25ms 内）的得到 update 相同的 expirationTime ，目的就是让这两个 update 自动合并成一个 Update ，从而达到批量更新。&lt;/p>
&lt;p>高优先级是 10ms 的误差.&lt;/p>
&lt;p>也就是说 expirationTime 的计算是将一个时间段内的所有&lt;strong>任务都统一成一个 expirationTime&lt;/strong> ，并且允许一定误差的存在。&lt;/p>
&lt;p>随着时间的流逝，一个更新的优先级会越来越高，这样就可以避免 &lt;strong>starvation&lt;/strong> 问题（即低优先级的工作一直被高优先级的工作打断，而无法完成）。&lt;/p>
&lt;blockquote>
&lt;p>另外，之前存在过一个 PriorityLevel 的优先级评估变量，但在 16.x 中使用的是 expirationTime 来评估，但为了兼容仍然会考虑 PriorityLevel 来计算 expirationTime。&lt;/p>
&lt;/blockquote>
&lt;h3 id="3workinprogress-tree--保存更新进度快照">3、workInProgress Tree ： 保存更新进度快照&lt;/h3>
&lt;p>workInProgress Tree 保存当先更新中的进度快照，用于下一个时间片的断点恢复, 跟 Fiber Tree 的构成几乎一样, 在一次更新的开始时跟 Fiber Tree 是一样的.&lt;/p>
&lt;h3 id="4fiber-tree-和-workinprogress-tree-的关系">4、Fiber Tree 和 WorkInProgress tree 的关系&lt;/h3>
&lt;p>在首次渲染的过程中，React 通过 react-dom 中提供的方法创建组件和与组件相应的 Fiber (Tree) ，此后就不会再生成新树，运行时永远维护这一棵树，调度和更新的计算完成后 Fiber Tree 会根据 effect 去实现更新。&lt;/p>
&lt;p>而 workInProgress Tree 在每一次刷新工作栈（ prepareFreshStack ）时候都会重新根据当前的 fiber tree 构建一次。&lt;/p>
&lt;p>这两棵树构成了双缓冲树, 以 fiber tree 为主，workInProgress tree 为辅。&lt;/p>
&lt;p>双缓冲具体指的是 workInProgress tree 构造完毕，得到的就是新的 fiber tree ，每个 fiber 上都有个 alternate 属性，也指向一个 fiber ，创建 workInProgress 节点时优先取 alternate ，没有的话就创建一个。&lt;/p>
&lt;p>fiber 与 workInProgress 互相持有引用，把 current 指针指向 workInProgress tree ，丢掉旧的 fiber tree 。旧 fiber 就作为新 fiber 更新的预留空间，达到复用 fiber 实例的目的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-dcc6a08b49d8ae2ab47e01b600d4586d_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一次更新的操作都是在 workInProgress Tree 上完成的，当更新完成后再用 workInProgress Tree 替换掉原有的 Fiber Tree ；&lt;/p>
&lt;p>这样做的好处：&lt;/p>
&lt;ol>
&lt;li>能够复用内部对象（fiber）&lt;/li>
&lt;li>节省内存分配、GC 的时间开销&lt;/li>
&lt;li>就算运行中有错误，也不会影响 View 上的数据&lt;/li>
&lt;/ol>
&lt;h3 id="5更新">5、更新&lt;/h3>
&lt;p>&lt;strong>怎么触发的更新&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>this.setState();&lt;/li>
&lt;li>props 的改变（因为 props 改变也是由父组件的 setState 引起的， 其实也是第一种）;&lt;/li>
&lt;li>this.forceUpdate();&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>触发更新后 Fiber 做了什么&lt;/strong>&lt;/p>
&lt;p>首先, 当前是哪个组件触发的更新, React 是知道的( this 指向), 于是 React 会针对&lt;strong>当前组件&lt;/strong>计算其相应的到期时间(上面提到了&lt;a href="https://link.zhihu.com/?target=https%3A//km.sankuai.com/page/156013163%23id-%E8%A7%84%E5%AE%9A%E8%B0%83%E5%BA%A6%E9%A1%BA%E5%BA%8F---expirationTime%E5%88%B0%E6%9C%9F%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">计算方法&lt;/a>), 并且基于这个到期时间, 创建一个&lt;strong>更新 update ,&lt;/strong> 将引起改变的 payload (比如说 state/props ), 作为此次更新的一个属性, 并插入当前组件对应的 Fiber Node 的更新队列（它是一个单向链表数据结构。只要有 setState 或者其他方式触发了更新，就会在 fiber 上的 updateQueue 里插入一个 update，这样在更新的时候就可以合并一起更新。）中, 之后开始调度任务。&lt;/p>
&lt;p>整个调度的过程是计算并重新构建 workInProgress Tree 的过程，在 workInProgress Tree 和原有 Fiber Tree 对比的时候记录下 Diff，标记对应的 Effect， 完成之后会生成一个 Effect List，这个 Effect List 就是最终 Commit 阶段用来处理副作用的阶段， 如果在这个过程中有了交互事件等高优先级的任务进来，那么 fiber 会终止当前任务， 执行更紧急的任务， 但为了避免 “饥饿现象”， 上一个吊起的任务的优先级会被相应的提升。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span> &lt;span class="nx">workInProgress&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">alternate&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">workInProgress&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...这里很有意思
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">alternate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">current&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">alternate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// We already have an alternate.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Reset the effect tag.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">effectTag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">NoEffect&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// The effect list is no longer valid.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nextEffect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">firstEffect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">workInProgress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lastEffect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="6effect">6、effect&lt;/h3>
&lt;p>每一个 Fiber Node 都有与之相关的 effect ， effect 是用于记录由于 state 和 props 改变引起的工作类型， 对于不同类型的 Fiber Node 有不同的改变类型，比如对 DOM 元素，工作包括添加，更新或删除元素。对于 class 组件，React 可能需要更新 ref 并调用 componentDidMount 和 componentDidUpdate 生命周期方法。&lt;/p>
&lt;p>每个 Fiber Node 都有个 nextEffect 用来快速查找下一个改变 effect，他使得更新的修改能够快速遍历整颗树，跳过没有更改的 Fiber Node。&lt;/p>
&lt;p>例如，我们的更新导致 c2 被插入到 DOM 中，d2 和 c1 被用于更改属性，而 b2 被用于触发生命周期方法。副作用列表会将它们链接在一起，以便 React 稍后可以跳过其他节点。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-69ce531374f9268ff0a53418ca28697b_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以看到具有副作用的节点是如何链接在一起的。当遍历节点时，React 使用 Fiber Node 的 firstEffect 指针来确定列表的开始位置。所以上面的图表可以表示为这样的线性列表：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-52d6e669d39a5bd512cf13626f9a9ea9_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="7获取浏览器的控制权-----requestidlecallback-和-requestanimationframe">7、&lt;strong>获取浏览器的控制权 &amp;mdash; requestIdleCallback 和 requestAnimationFrame&lt;/strong>&lt;/h3>
&lt;p>构建出 Effect List 就已经完成了一次更新的前半部分工作调和，在这个过程中，React 通过浏览器提供的 Api 来开始于暂停其中的调和任务。&lt;/p>
&lt;p>requestIdleCallback(callback) 这是浏览器提供的 API ，他在 window 对象上，作为参数写给这个函数的回调函数，将会在浏览器空闲的时候执行。回调函数会有一个 deadline 参数，deadline.timeRemaining() 会告诉外界，当前时间片还有多少时间。利用这个 API ，结合 Fiber 拆分好的工作单元，在合适的时机来安排工作。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-8b91d684daf36ece04a2edf2761741cf_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>不过这个 API 只负责低优先的级的任务处理，而高优先级的（比如动画相关）则通过 requestAnimationFrame 来控制 。&lt;/p>
&lt;p>如果浏览器支持这两个 API 就直接使用，如果不支持就要重新定义了，如果没有自行定义的&lt;a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a2276d5518825619a027f57" target="_blank" rel="noopener">https://juejin.im/post/5a2276d5518825619a027f57&lt;/a>&lt;/p>
&lt;h3 id="8调度器scheduler">8、调度器（Scheduler）&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>调和器主要作用就是在组件状态变更时，调用组件树各组件的 render 方法，渲染，卸载组件，而 Fiber 使得应用可以更好的协调不同任务的执行，调和器内关于高效协调的实现，我们可以称它为调度器（Scheduler）。
Fiber 中的调度器主要的关注点是：&lt;/p>
&lt;/li>
&lt;li>
&lt;ol>
&lt;li>合并多次更新：没有必要在组件的每一个状态变更时都立即触发更新任务，有些中间状态变更其实是对更新任务所耗费资源的浪费，就比如用户发现错误点击时快速操作导致组件某状态从 A 至 B 再至 C，这中间的 B 状态变更其实对于用户而言并没有意义，那么我们可以直接合并状态变更，直接从 A 至 C 只触发一次更新；&lt;/li>
&lt;li>任务优先级：不同类型的更新有不同优先级，例如用户操作引起的交互动画可能需要有更好的体验，其优先级应该比完成数据更新高；&lt;/li>
&lt;li>推拉式调度：基于推送的调度方式更多的需要开发者编码间接决定如何调度任务，而拉取式调度更方便 React 框架层直接进行全局自主调度；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>调度的实现逻辑主要是&lt;/p>
&lt;ol>
&lt;li>
&lt;ol>
&lt;li>通过 fiber.return 属性，从当前 fiber 实例层层遍历至组件树根组件；&lt;/li>
&lt;li>依次对每一个 fiber 实例进行到期时间判断，若大于传入的期望任务到期时间参数，则将其更新为传入的任务到期时间；&lt;/li>
&lt;li>调用 requestWork 方法开始处理任务，并传入获取的组件树根组件 FiberRoot 对象和任务到期时间；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="fiber-执行流程">Fiber 执行流程&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-9fcf2cfa698301ce7bc78bc3857904ed_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Fiber 总的来说可以分成两个部分，一个是调和过程（可中断），一个是提交过程（不可中断）。&lt;/p>
&lt;p>在调和过程中以 fiber tree 为基础，把每个 fiber 作为一个工作单元，自顶向下逐节点构造 workInProgress tree（构建中的新 fiber tree ）&lt;/p>
&lt;p>具体过程如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-8c3b88ee7471ba1303c4460967da36fa_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通过每个节点更新结束时向上归并 effect list 来收集任务结果，reconciliation 结束后，根节点的 effect list 里记录了包括 DOM change 在内的所有 side effect&lt;/p>
&lt;p>所以，构建 workInProgress tree 的过程就是 diff 的过程，通过 requestIdleCallback 来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次 requestIdleCallback 回调再继续构建 workInProgress tree&lt;/p>
&lt;p>而提交过程阶段是一口气直接做完（同步执行），不被控制和中止，这个阶段的实际工作量是比较大的，所以尽量不要在后 3 个生命周期函数里干重活儿&lt;/p>
&lt;ol>
&lt;li>处理 effect list（包括 3 种处理：更新 DOM 树、调用组件生命周期函数以及更新 ref 等内部状态）&lt;/li>
&lt;li>该阶段结束时，所有更新都 commit 到 DOM 树上了。&lt;/li>
&lt;/ol>
&lt;p>DEMO 对比：&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>未使用 Fiber 的例子： &lt;a href="https://link.zhihu.com/?target=https%3A//claudiopro.github.io/react-fiber-vs-stack-demo/stack.html" target="_blank" rel="noopener">https://claudiopro.github.io/react-fiber-vs-stack-demo/stack.html&lt;/a>&lt;/li>
&lt;li>使用 Fiber 的例子：[https://claudiopro.github.io/re&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="fiber-为什么是-react-性能的一个飞跃">Fiber 为什么是 React 性能的一个飞跃？&lt;/h2>
&lt;h3 id="什么是-fiber">什么是 Fiber&lt;/h3>
&lt;p>Fiber 的英文含义是“纤维”，它是比线程（Thread）更细的线，比线程（Thread）控制得更精密的执行模型。在广义计算机科学概念中，Fiber 又是一种协作的（Cooperative）编程模型（协程），帮助开发者用一种【既模块化又协作化】的方式来编排代码。&lt;/p>
&lt;p>在 React 中，&lt;strong>Fiber 就是 React 16 实现的一套新的更新机制，让 React 的更新过程变得可控，避免了之前采用递归需要一气呵成影响性能的做法&lt;/strong>。&lt;/p>
&lt;h3 id="react-fiber-中的时间分片">React Fiber 中的时间分片&lt;/h3>
&lt;p>把一个&lt;strong>耗时长的任务分成很多小片&lt;/strong>，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都&lt;strong>给其他任务一个执行的机会&lt;/strong>，这样唯一的线程就不会被独占，其他任务依然有运行的机会。&lt;/p>
&lt;p>React Fiber 把更新过程&lt;strong>碎片化&lt;/strong>，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。&lt;/p>
&lt;h3 id="stack-reconciler">Stack Reconciler&lt;/h3>
&lt;p>基于栈的 Reconciler，浏览器引擎会从执行栈的顶端开始执行，执行完毕就弹出当前执行上下文，开始执行下一个函数，&lt;strong>直到执行栈被清空才会停止&lt;/strong>。然后将执行权交还给浏览器。由于 React 将页面视图视作一个个函数执行的结果。每一个页面往往由多个视图组成，这就意味着多个函数的调用。&lt;/p>
&lt;p>如果一个页面足够复杂，形成的函数调用栈就会很深。每一次更新，执行栈需要一次性执行完成，中途不能干其他的事儿，只能&amp;quot;&lt;strong>一心一意&lt;/strong>&amp;quot;。结合前面提到的浏览器刷新率，JS 一直执行，浏览器得不到控制权，就不能及时开始下一帧的绘制。如果这个时间超过 16ms，当页面有动画效果需求时，动画因为浏览器&lt;strong>不能及时绘制下一帧&lt;/strong>，这时动画就会出现卡顿。不仅如此，因为事件响应代码是在每一帧开始的时候执行，如果不能及时绘制下一帧，事件响应也会延迟。&lt;/p>
&lt;h3 id="fiber-reconciler">Fiber Reconciler&lt;/h3>
&lt;h3 id="链表结构">链表结构&lt;/h3>
&lt;p>在 React Fiber 中&lt;strong>用链表遍历的方式替代了 React 16 之前的栈递归方案&lt;/strong>。在 React 16 中使用了大量的链表。&lt;/p>
&lt;ul>
&lt;li>使用多向链表的形式替代了原来的树结构；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;B1&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> B1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;C1&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;B2&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>B2&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-b520d0b65d9149c351a9b01698d79beb_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>副作用单链表；&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-b411c7ecbdc65d40107fc92f929e977b_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>状态更新单链表；&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-2621b96819af8c5d66ac668ad22ab9a9_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>链表是一种简单高效的数据结构，它在当前节点中保存着指向下一个节点的指针；遍历的时候，通过操作指针找到下一个元素。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-f091ecbc95c48b20b050d55a14497c33_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>链表相比顺序结构数据格式的&lt;strong>好处&lt;/strong>就是：&lt;/p>
&lt;ol>
&lt;li>操作更高效，比如顺序调整、删除，只需要改变节点的指针指向就好了。&lt;/li>
&lt;li>不仅可以根据当前节点找到下一个节点，在多向链表中，还可以找到他的父节点或者兄弟节点。&lt;/li>
&lt;/ol>
&lt;p>但链表也不是完美的，&lt;strong>缺点&lt;/strong>就是：&lt;/p>
&lt;ol>
&lt;li>比顺序结构数据更占用空间，因为每个节点对象还保存有指向下一个对象的指针。&lt;/li>
&lt;li>不能自由读取，必须找到他的上一个节点。&lt;/li>
&lt;/ol>
&lt;p>React 用&lt;strong>空间换时间&lt;/strong>，更高效的操作可以方便根据优先级进行操作。同时&lt;strong>可以根据当前节点找到其他节点，在下面提到的挂起和恢复过程中起到了关键作用&lt;/strong>。&lt;/p>
&lt;h3 id="斐波那契数列的-fiber">斐波那契数列的 Fiber&lt;/h3>
&lt;p>递归形式的斐波那契数列写法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>采用 &lt;strong>Fiber 的思路&lt;/strong>将其改写为循环（这个例子并不能和 React Fiber 的对等）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">arg&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">returnAddr&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">consoled&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 标记循环
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">rec&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 当展开完全后，开始计算
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">arg&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 寻找父级
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">returnAddr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">consoled&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在这里打印查看形成的链表形式的 fiber 对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">consoled&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">returnAddr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">arg&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">arg&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">returnAddr&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span> &lt;span class="nx">rec&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 先展开
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">arg&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">arg&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">returnAddr&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">fiber&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="react-fiber-是如何实现更新过程可控">React Fiber 是如何实现更新过程可控？&lt;/h2>
&lt;p>更新过程的可控主要体现在下面几个方面：&lt;/p>
&lt;ul>
&lt;li>任务拆分&lt;/li>
&lt;li>任务挂起、恢复、终止&lt;/li>
&lt;li>任务具备优先级&lt;/li>
&lt;/ul>
&lt;h3 id="任务拆分">任务拆分&lt;/h3>
&lt;p>在 React Fiber 机制中，它采用&amp;quot;&lt;strong>化整为零&lt;/strong>&amp;ldquo;的思想，将调和阶段（Reconciler）递归遍历 VDOM 这个大任务分成若干小任务，每个任务只负责&lt;strong>一个节点&lt;/strong>的处理。&lt;/p>
&lt;h3 id="任务挂起恢复终止">任务挂起、恢复、终止&lt;/h3>
&lt;h3 id="workinprogress-tree">workInProgress tree&lt;/h3>
&lt;p>workInProgress 代表&lt;strong>当前正在执行更新的 Fiber 树&lt;/strong>。在 render 或者 setState 后，会构建一颗 Fiber 树，也就是 workInProgress tree，这棵树在构建每一个节点的时候会&lt;strong>收集当前节点的副作用&lt;/strong>，整棵树构建完成后，会形成一条完整的&lt;strong>副作用链&lt;/strong>。&lt;/p>
&lt;h3 id="currentfiber-tree">currentFiber tree&lt;/h3>
&lt;p>currentFiber 表示&lt;strong>上次渲染构建的 Filber 树&lt;/strong>。&lt;strong>在每一次更新完成后 workInProgress 会赋值给 currentFiber&lt;/strong>。在新一轮更新时 workInProgress tree 再重新构建，新 workInProgress 的节点通过 alternate 属性和 currentFiber 的节点建立联系。&lt;/p>
&lt;p>在新 workInProgress tree 的创建过程中，会同 currentFiber 的对应节点进行 Diff 比较，收集副作用。同时也会&lt;strong>复用&lt;/strong>和 currentFiber 对应的节点对象，减少新创建对象带来的开销。也就是说&lt;strong>无论是创建还是更新、挂起、恢复以及终止操作都是发生在 workInProgress tree 创建过程中的&lt;/strong>。workInProgress tree 构建过程其实就是循环的执行任务和创建下一个任务。&lt;/p>
&lt;h3 id="挂起">挂起&lt;/h3>
&lt;p>当第一个小任务完成后，先判断这一帧是否还有&lt;strong>空闲时间&lt;/strong>，没有就挂起下一个任务的执行，&lt;strong>记住&lt;/strong>当前挂起的节点，让出控制权给浏览器执行更高优先级的任务。&lt;/p>
&lt;h3 id="恢复">恢复&lt;/h3>
&lt;p>在浏览器渲染完一帧后，判断当前帧是否有&lt;strong>剩余时间&lt;/strong>，如果有就恢复执行之前挂起的任务。如果没有任务需要处理，代表调和阶段完成，可以开始进入渲染阶段。&lt;/p>
&lt;p>如何判断一帧是否有空闲时间的呢？&lt;/p>
&lt;p>使用前面提到的 RIC (RequestIdleCallback) 浏览器原生 API，React 源码中为了兼容低版本的浏览器，对该方法进行了 Polyfill。&lt;/p>
&lt;p>恢复执行的时候又是如何知道下一个任务是什么呢？&lt;/p>
&lt;p>是在前面提到的&lt;strong>链表&lt;/strong>。在 React Fiber 中每个任务其实就是在处理一个 FiberNode 对象，然后又生成下一个任务需要处理的 FiberNode。&lt;/p>
&lt;h3 id="终止">终止&lt;/h3>
&lt;p>其实并不是每次更新都会走到提交阶段。当在调和过程中触发了新的更新，在执行下一个任务的时候，判断&lt;strong>是否有优先级更高的执行任务&lt;/strong>，如果有就终止原来将要执行的任务，开始新的 workInProgressFiber 树构建过程，开始新的更新流程。这样可以避免重复更新操作。这也是&lt;strong>在 React 16 以后生命周期函数 componentWillMount 有可能会执行多次&lt;/strong>的原因。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-61d21ff26edd0c49ed969cac6a9f5a93_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="任务具备优先级">任务具备优先级&lt;/h3>
&lt;p>React Fiber 除了通过挂起，恢复和终止来控制更新外，还给每个任务分配了优先级。具体点就是在创建或者更新 FiberNode 的时候，通过算法给每个任务分配一个到期时间（&lt;strong>expirationTime&lt;/strong>）。在每个任务执行的时候除了判断剩余时间，如果当前处理节点已经过期，那么无论现在是否有空闲时间都必须执行该任务。&lt;strong>过期时间的大小还代表着任务的优先级&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>任务在执行过程中顺便收集了每个 FiberNode 的副作用&lt;/strong>，将有副作用的节点通过 firstEffect、lastEffect、nextEffect 形成一条副作用单链表 &lt;code>A1(TEXT)-B1(TEXT)-C1(TEXT)-C1-C2(TEXT)-C2-B1-B2(TEXT)-B2-A&lt;/code>。&lt;/p>
&lt;p>其实&lt;strong>最终都是为了收集到这条副作用链表，有了它，在接下来的渲染阶段就通过遍历副作用链完成 DOM 更新&lt;/strong>。这里需要注意，&lt;strong>更新真实 DOM 的这个动作是一气呵成的&lt;/strong>，不能中断，不然会造成视觉上的不连贯（commit）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;A1&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;B1&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> B1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;C1&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>C1&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;C2&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>C2&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;B2&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>B2&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-45a9e181175c358339a0124b88d5ca59_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="直观展示">直观展示&lt;/h3>
&lt;p>正是基于以上这些过程，使用 Fiber，我们就有了在社区经常看到的&lt;a href="https://link.zhihu.com/?target=https%3A//link.segmentfault.com/%3Fenc%3D76jmA9HJDnS4akh4JaqSqw%3D%3D.LuFE7VzoBqJqJK5ywxrdlubXzRgj6TGqH5UetvbHijpbb13makMvG0o1t5WY27niPurw3i8iW%2FEYroNZnOT%2Bdw%3D%3D" target="_blank" rel="noopener">两张对比图&lt;/a>。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-6d3e3d4bbf86c494dfb293b6d9ae4321_b.jpg" alt="动图封面" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-dd52d924d7c7431c061fde2f4135854b_b.jpg" alt="动图封面" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>清晰展示及交互、源码可通过下面两个链接进入，查看网页源代码。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//link.segmentfault.com/%3Fenc%3DzpcqjyAZz1tpt88CKyVqqA%3D%3D.gzNUmA688u%2Bm2xYbjTlDxamSnl7hOwKwb4yJUBUrGTdtIS%2B0s8Oz%2B16e1mzoWUPCxvYAmJxnBQLzvTK3lvgP%2FEt3LEmB3cve3G6ko9ObtFE%3D" target="_blank" rel="noopener">Stack Example&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//link.segmentfault.com/%3Fenc%3DxXmERgV%2FrJMXXvMZRTOLeA%3D%3D.IMxKYfRNZDqDsZRkTTXDBWpe4h%2FTMFb2c1ua5fahkGj6on2VBDucTyIOBVYBn3s2wYExsgADJ%2FUt2j0lIkMab43f39mZjYHdvlvlTUVdoM0%3D" target="_blank" rel="noopener">Fiber Example&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="fiber-结构长什么样">Fiber 结构长什么样？&lt;/h3>
&lt;p>基于时间分片的增量更新需要&lt;strong>更多的上下文信息&lt;/strong>，之前的 vDOM tree 显然难以满足，所以扩展出了 fiber tree（即 Fiber 上下文的 vDOM tree），更新过程就是根据输入数据以及现有的 fiber tree 构造出新的 fiber tree（workInProgress tree）。&lt;/p>
&lt;p>FiberNode 上的属性有很多，根据笔者的理解，以下这么几个属性是值得关注的：return、child、sibling（主要负责 fiber 链表的链接）；stateNode；effectTag；expirationTime；alternate；nextEffect。各属性介绍参看下面的&lt;code>class FiberNode&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">class&lt;/span> &lt;span class="nx">FiberNode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">tag&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">pendingProps&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 实例属性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">tag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">tag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 标记不同组件类型，如函数组件、类组件、文本、原生组件...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">key&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// react 元素上的 key 就是 jsx 上写的那个 key ，也就是最终 ReactElement 上的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">elementType&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// createElement的第一个参数，ReactElement 上的 type
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 表示fiber的真实类型 ，elementType 基本一样，在使用了懒加载之类的功能时可能会不一样
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stateNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 实例对象，比如 class 组件 new 完后就挂载在这个属性上面，如果是RootFiber，那么它上面挂的是 FiberRoot,如果是原生节点就是 dom 对象
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// fiber
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 父节点，指向上一个 fiber
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 子节点，指向自身下面的第一个 fiber
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 兄弟组件, 指向一个兄弟节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 一般如果没有兄弟节点的话是0 当某个父节点下的子节点是数组类型的时候会给每个子节点一个 index，index 和 key 要一起做 diff
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ref&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// reactElement 上的 ref 属性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pendingProps&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">pendingProps&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 新的 props
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">memoizedProps&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 旧的 props
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">updateQueue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// fiber 上的更新队列执行一次 setState 就会往这个属性上挂一个新的更新, 每条更新最终会形成一个链表结构，最后做批量更新
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">memoizedState&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 对应 memoizedProps，上次渲染的 state，相当于当前的 state，理解成 prev 和 next 的关系
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">mode&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 表示当前组件下的子组件的渲染方式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// effects
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">effectTag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">NoEffect&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 表示当前 fiber 要进行何种更新（更新、删除等）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nextEffect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 指向下个需要更新的fiber
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">firstEffect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 指向所有子节点里，需要更新的 fiber 里的第一个
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lastEffect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 指向所有子节点中需要更新的 fiber 的最后一个
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">expirationTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">NoWork&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 过期时间，代表任务在未来的哪个时间点应该被完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">childExpirationTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">NoWork&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// child 过期时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">alternate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// current 树和 workInprogress 树之间的相互引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/v2-80536897c9c006a20f2c9255a2a5e8b6_1440w.webp" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>图片来源：&lt;a href="https://link.zhihu.com/?target=https%3A//link.segmentfault.com/%3Fenc%3DJ6qPJJLhXgk%2FlqmrRndrew%3D%3D.JhzybPqTzKUeWsc%2F5VjTfVDNgkI%2BmkcF2gw72%2BRySRwaAPtVrPjMHzOdM5f1IsLZ" target="_blank" rel="noopener">完全理解 React Fiber&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">performUnitWork&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">currentFiber&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//beginWork(currentFiber) //找到儿子，并通过链表的方式挂到currentFiber上，没有儿子就找后面那个兄弟
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//有儿子就返回儿子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">currentFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">currentFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">child&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果没有儿子，则找弟弟
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">currentFiber&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//一直往上找
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//completeUnitWork(currentFiber);//将自己的副作用挂到父节点去
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">currentFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">currentFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sibling&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">currentFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">currentFiber&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="concurrent-mode-并发模式">Concurrent Mode （并发模式）&lt;/h3>
&lt;p>Concurrent Mode 指的就是 React 利用上面 Fiber 带来的新特性开启的新模式 (mode)。react17 开始支持 concurrent mode，这种模式的根本目的是为了&lt;strong>让应用保持 cpu 和 io 的快速响应&lt;/strong>，它是一组新功能，&lt;strong>包括 Fiber、Scheduler、Lane&lt;/strong>，可以根据用户硬件性能和网络状况调整应用的响应速度，核心就是为了&lt;strong>实现异步可中断的更新&lt;/strong>。concurrent mode 也是未来 react 主要迭代的方向。&lt;/p>
&lt;p>目前 React 实验版本允许用户选择三种 mode：&lt;/p>
&lt;ol>
&lt;li>Legacy Mode: 就相当于目前稳定版的模式&lt;/li>
&lt;li>Blocking Mode: 应该是以后会代替 Legacy Mode 而长期存在的模式&lt;/li>
&lt;li>Concurrent Mode: 以后会变成 default 的模式&lt;/li>
&lt;/ol>
&lt;p>Concurrent Mode 其实开启了一堆新特性，其中有两个最重要的特性可以用来解决我们开头提到的两个问题：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//link.segmentfault.com/%3Fenc%3DaU7%2FtNBChDWMnwein7oWOg%3D%3D.ztkRkIqDxdwJfR4SyBbUz23JkkZr1Vei7pq3WGiC5maYIsneQwdEb4mCq%2FKISD4G" target="_blank" rel="noopener">Suspense&lt;/a>：Suspense 是 React 提供的一种&lt;strong>异步处理的机制&lt;/strong>, 它不是一个具体的数据请求库。它是 React 提供的原生的组件异步调用原语。&lt;/li>
&lt;li>&lt;a href="https://link.zhihu.com/?target=https%3A//link.segmentfault.com/%3Fenc%3DRbL21xHWKgEDDyx3jWed8Q%3D%3D.8aqbm2Qpz6rip75nCaEMqZNZpefrWKIoCESkQx8S1zOuPnKVdWENgwbbXaW09qxU" target="_blank" rel="noopener">useTrasition&lt;/a>：让页面实现 &lt;code>Pending -&amp;gt; Skeleton -&amp;gt; Complete&lt;/code> 的更新路径, 用户在切换页面时可以停留在当前页面，让页面保持响应。 相比展示一个无用的空白页面或者加载状态，这种&lt;strong>用户体验&lt;/strong>更加友好。&lt;/li>
&lt;/ol>
&lt;p>其中 Suspense 可以用来解决请求阻塞的问题，UI 卡顿的问题其实开启 concurrent mode 就已经解决的，但如何利用 concurrent mode 来实现更友好的交互还是需要对代码做一番改动的。&lt;/p></description></item></channel></rss>