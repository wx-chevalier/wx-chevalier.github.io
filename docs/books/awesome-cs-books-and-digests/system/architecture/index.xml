<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/</link><atom:link href="https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/index.xml" rel="self" type="application/rss+xml"/><description>Architecture</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>Architecture</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/</link></image><item><title>2000-Roy Thomas Fielding-架构风格与基于网络的软件架构设计</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2000-roy-thomas-fielding-%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2000-roy-thomas-fielding-%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/2e3bb2b985a143&lt;/p>
&lt;/blockquote></description></item><item><title>2006-Martin Fowler-企业应用架构模式</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2006-martin-fowler-%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2006-martin-fowler-%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>2010-Eric-领域驱动设计：软件核心复杂性应对之道</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2010-eric-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%BD%AF%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%A4%8D%E6%9D%82%E6%80%A7%E5%BA%94%E5%AF%B9%E4%B9%8B%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2010-eric-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%BD%AF%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%A4%8D%E6%9D%82%E6%80%A7%E5%BA%94%E5%AF%B9%E4%B9%8B%E9%81%93/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>2013-Vaughn-Implementing Domain Driven Design</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2013-vaughn-implementing-domain-driven-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2013-vaughn-implementing-domain-driven-design/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>2013-简约之美：软件设计之道</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2013-%E7%AE%80%E7%BA%A6%E4%B9%8B%E7%BE%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2013-%E7%AE%80%E7%BA%A6%E4%B9%8B%E7%BE%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>2015-Practical Scalability Analysis With The Universal Scalability Law</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2015-practical-scalability-analysis-with-the-universal-scalability-law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2015-practical-scalability-analysis-with-the-universal-scalability-law/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>2015-Scott-Patterns, Principles, and Practices of Domain Driven Design</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2015-scott-patterns-principles-and-practices-of-domain-driven-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2015-scott-patterns-principles-and-practices-of-domain-driven-design/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>2016-架构师-架构漫谈</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2016-%E6%9E%B6%E6%9E%84%E5%B8%88-%E6%9E%B6%E6%9E%84%E6%BC%AB%E8%B0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2016-%E6%9E%B6%E6%9E%84%E5%B8%88-%E6%9E%B6%E6%9E%84%E6%BC%AB%E8%B0%88/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>2017-Martin Fowler-Clean Architecture A Craftsman's Guide</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2017-martin-fowler-clean-architecture-a-craftsmans-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2017-martin-fowler-clean-architecture-a-craftsmans-guide/</guid><description>&lt;h1 id="clean-architecture">Clean Architecture&lt;/h1>
&lt;h1 id="1what-is-design-and-architecture">1.What is design and architecture&lt;/h1>
&lt;p>The word “architecture” is often used in the context of something at a high level that is divorced from the lower-level details,whereas &amp;ldquo;design&amp;rdquo; more often seems to imply structures and decisions at a lower level.The goal of software architecture is to minimize the human resources required to build and maintain the required system.&lt;/p>
&lt;p>架构设计的目的：减少系统构建和维护的成本。引入例子对比不同开发思路下维护软件的成本，说明架构的重要性。&lt;/p>
&lt;h1 id="2a-tale-of-two-values">2.A tale of two values&lt;/h1>
&lt;p>Every software system provides two different values to the stakeholders: behavior and structure. Software developers are responsible for ensuring that both values remain high.&lt;/p>
&lt;p>The first value of software&amp;ndash;behavior&amp;ndash;is urgent but not always particularly important. The second value of software&amp;ndash;architecture&amp;ndash;is important but never particularly urgent.&lt;/p>
&lt;p>只注重功能开发不注重架构的系统是无法延续的。引入 Esenhower Matrix，把要做的事按重要程度和紧急程度划分在四个象限，并且排优先级。架构设计不紧急但是重要，应该放在较高的优先级。&lt;/p>
&lt;h1 id="3paradigm-overview">3.Paradigm overview&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>Structured programming imposes discipline of direct transfer of control.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Object-oriented programming imposes discipline of indirect transfer of control.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Functional programming imposes discipline upon assignment.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Each of the paradigms removes capabilities from programmer. None of them add new capabilities. The three paradigms together remove goto statements, function pointers, and assignment.&lt;/p>
&lt;h1 id="4structured-programming">4.Structured programming&lt;/h1>
&lt;p>Structured programming allows modules to be recursively decomposed into provable units, which in turn means that modules can be functionally decomposed.That is, you can take a large-scale problem statement and decompose it into high-level functions. Each of those functions can then be decomposed into lower-level functions, ad infinitum. Moreover, each of those decomposed functions can be represented using the restricted control structures of structured programming.&lt;/p>
&lt;p>Dijkstra once said, &amp;ldquo;Testing shows the presence ,not the absence ,of bugs.&amp;rdquo; In other words, a program can be proven incorrect by a test ,but it cannot be proven correct. Structured programming forces us to recursively decompose a program into a set of small provable functions. We can then use tests to try to prove those small provable functions incorrect. If such tests fail to prove incorrectness, then we deem the functions to be correct enough for our purposes.&lt;/p>
&lt;h1 id="5object-oriented-programming">5.Object-oriented programming&lt;/h1>
&lt;p>The fact that OO languages provide safe and convenient polymorphism means that any source code dependency ,no matter where it is, can be inverted.&lt;/p>
&lt;p>To the software architect, OO is the ability, through the use of polymorphism, to gain absolute control over every source code dependency in the system. It allows the architect to create a plugin architecture, in which modules that contain high-level policies are independent of modules that contain low-level details.The low-level details are relegated to plugin modules that can be deployed and developed independently from the modules that contain high-level policies.&lt;/p>
&lt;h1 id="6functional-programming">6.Functional programming&lt;/h1>
&lt;p>Variables in functional languages do not vary. All race conditions, deadlock conditions, and concurrent update problems are due to mutable variables.&lt;/p>
&lt;p>Design principles. The SOLID principles tell us how to arrange our functions and data structures into classes, and how those classes should be interconnected.&lt;/p>
&lt;p>The goal of the principles is the creation of mid-level software structures that:&lt;/p>
&lt;ol>
&lt;li>Tolerate change,&lt;/li>
&lt;li>Are easy to understand ,and&lt;/li>
&lt;li>Are the basis of components that can be used in many software systems.&lt;/li>
&lt;/ol>
&lt;h1 id="7sip-the-single-responsibility-principle">7.SIP: The single responsibility principle&lt;/h1>
&lt;p>SIP: A module should be responsible to one ,and only one, actor.&lt;/p>
&lt;p>Now, what do we mean by the word &amp;ldquo;module&amp;rdquo; ? The simplest definition is just a source file. Most of the time that definition works fine. Some languages and development environment, though ,don&amp;rsquo;t use source files to contain their code. In those cases a module is just a cohesive set of functions and data structures.&lt;/p>
&lt;p>The word &amp;ldquo;cohesive&amp;rdquo; implies the SRP. Cohesion is the force that binds together the code responsible to a single actor.&lt;/p>
&lt;h1 id="8ocp-the-open-closed-principle">8.OCP: The open-closed principle&lt;/h1>
&lt;p>OCP: A software artifact should be open for extension but closed for modification.&lt;/p>
&lt;p>The OCP is one of the driving forces behind the architecture of systems. The goal is to make the system easy to extend without incurring a high impact of change. This goal is accomplished by partitioning the system into components, and arranging those components into a dependency hierarchy that protects higher-level components from changes in lower-level components.&lt;/p>
&lt;h1 id="9lspthe-liskov-substitution-principle">9.LSP：The liskov substitution principle&lt;/h1>
&lt;p>LSP: What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.&lt;/p>
&lt;h1 id="10isp-the-interface-segregation-principle">10.ISP: The interface segregation principle&lt;/h1>
&lt;p>The lesson here is that depending on something that carries baggage that you don&amp;rsquo;t need can cause you troubles that you didn&amp;rsquo;t expect.&lt;/p>
&lt;h1 id="11dip-the-dependency-inversion-principle">11.DIP: The dependency inversion principle&lt;/h1>
&lt;p>The DIP tells us that the most flexible systems are those in which source code dependencies refer only to abstractions ,not to concretions. We tend to ignore the stable background of operating system and platform facilities when it comes to DIP. We tolerate those concrete dependencies because we know we can rely on them not to change.&lt;/p>
&lt;p>It is the volatile concrete elements of our system that we want to avoid depending on . Those are the modules that we are actively developing ,and that are undergoing frequent change. Stable architectures are those that avoid depending on volatile concretions, and that favor the use of stable abstract interfaces. This implication boils down to a set of very specific coding practices:&lt;/p>
&lt;p>Don&amp;rsquo;t refer to volatile concrete classes, refer to abstract interfaces instead. It also puts severe constraints on the creation of objects and generally enforces the use of Abstract Factories. Don&amp;rsquo;t derive from volatile concrete classes. Don&amp;rsquo;t override concrete functions. Never mention the name of anything concrete and volatile.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/htx9dGBj/image.png" alt="Use" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Components principles：If the SOLID principles tell us how to arrange the bricks into walls and rooms, then the component principles tell us how to arrange the rooms into buildings.&lt;/p>
&lt;h1 id="12components">12.Components&lt;/h1>
&lt;p>Components are the units of deployment. They are the smallest entities that can be deployed as part of a system.&lt;/p>
&lt;p>Components can be linked together into a single executable.&lt;/p>
&lt;h1 id="13components-cohesion">13.Components cohesion&lt;/h1>
&lt;p>REP: The reuse/release equivalence principle ,the granule of reuse is the granule of release. For a software design and architecture point of view, this principle means that the classes and modules that are formed into a component must belong to a cohesive group. The component cannot simply consist of a random hodgepodge of classes and modules; instead ,there must be some overarching theme or purpose that those modules all share.&lt;/p>
&lt;p>CCP:The common closure principle: Gather into components those classes that change for the same reasons and at same times. Separate into different components those classes that change at different times and for different reasons. The SRP tells us to separate methods into different classes, if they change for different reasons. The CCP tells us to separate classes into different components, if they change for different reasons.&lt;/p>
&lt;p>CRP: The common reuse principle. Don&amp;rsquo;t force users of a component to depend on things they don&amp;rsquo;t need. The CRP is the generic version of the ISP. The ISP advises us not depend on classes that have methods we don&amp;rsquo;t use. The CRP advises us not to depend on components that have classes we don&amp;rsquo;t use.&lt;/p></description></item><item><title>2017-Martin Fowler-架构整洁之道</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2017-martin-fowler-%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2017-martin-fowler-%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</guid><description>&lt;h1 id="架构整洁之道笔记">架构整洁之道笔记&lt;/h1>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.atatech.org/articles/139100?flag_data_from=home_headline" target="_blank" rel="noopener">https://www.atatech.org/articles/139100?flag_data_from=home_headline&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>2018-John Ousterhout-A Philosophy of Software Design</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2018-john-ousterhout-a-philosophy-of-software-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2018-john-ousterhout-a-philosophy-of-software-design/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145，中文地址：http://gdut_yy.gitee.io/doc-aposd/&lt;/p>
&lt;/blockquote>
&lt;h1 id="a-philosophy-of-software-design">A Philosophy of Software Design&lt;/h1>
&lt;p>John Ousterhout 是斯坦福大学的 Bosack Lerner 计算机科学教授。他是 Tcl 脚本语言的创建者，并且以在分布式操作系统和存储系统中的工作而闻名。Ousterhout 在耶鲁大学获得了物理学学士学位，并在卡内基梅隆大学获得了计算机科学博士学位。他是美国国家工程院院士，并获得了无数奖项，包括 ACM 软件系统奖，ACM Grace Murray Hopper 奖，美国国家科学基金会总统年轻研究者奖和 UC Berkeley 杰出教学奖。&lt;/p>
&lt;h1 id="第-21-章-结论">第 21 章 结论&lt;/h1>
&lt;p>这本书是关于一件事的：复杂性。处理复杂性是软件设计中最重要的挑战。这是使系统难以构建和维护的原因，并且通常也使它们变慢。在本书的整个过程中，我试图描述导致复杂性的根本原因，例如依赖性和模糊性。我已经讨论了可以帮助您识别不必要的复杂性的危险标记，例如信息泄漏，不必要的错误情况或名称过于笼统。我已经提出了一些通用的思想，可以用来创建更简单的软件系统，例如，努力研究更深和更通用的类，定义不存在的错误以及将接口文档与实现文档分离。最后，我讨论了产生简单设计所需的投资思路。&lt;/p>
&lt;p>所有这些建议的缺点是它们会在项目的早期阶段创建额外的工作。此外，如果您不习惯于思考设计问题，那么当您学习良好的设计技巧时，您甚至会放慢脚步。如果对您而言唯一重要的事情就是尽快使当前代码工作，那么思考设计就好像是在费劲工作，而这实际上妨碍了您实现真正的目标。&lt;/p>
&lt;p>另一方面，如果良好的设计对您来说是重要的目标，那么本书中的思想应使编程更有趣。设计是一个令人着迷的难题：如何用最简单的结构解决特定问题？探索不同的方法很有趣，找到一种既简单又强大的解决方案是一种很好的感觉。干净，简单和明显的设计是一件美丽的事情。&lt;/p>
&lt;p>此外，您对优质设计的投资将很快获得回报。在项目开始时仔细定义的模块将为您节省时间，因为您一遍又一遍地重复使用它们。您六个月前编写的清晰文档将为您节省返回代码添加新功能的时间。花在磨练设计技能上的时间也将有所回报：随着技能和经验的增长，您会发现可以越来越快地制作出好的设计。一旦知道了什么，一个好的设计实际上并不会比一个简单的设计花费更多的时间。&lt;/p>
&lt;p>成为优秀设计师的好处是，您可以在设计阶段花费大部分时间，这很有趣。可怜的设计师花费大量时间在复杂而脆弱的代码中寻找错误。如果提高设计技能，不仅可以更快地生产出更高质量的软件，而且软件开发过程也将变得更加愉快。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;h2 id="summary-of-design-principles-设计原则摘要">Summary of Design Principles 设计原则摘要&lt;/h2>
&lt;ol>
&lt;li>复杂性是逐步增加的：您必须流汗一些小东西（请参阅第 11 页）。&lt;/li>
&lt;li>工作代码还不够（请参阅第 14 页）。&lt;/li>
&lt;li>持续进行少量投资以改善系统设计（请参阅第 15 页）。&lt;/li>
&lt;li>模块应较深（请参见第 22 页）&lt;/li>
&lt;li>接口的设计应尽可能简化最常见的用法（请参阅第 27 页）。&lt;/li>
&lt;li>一个模块具有一个简单的接口比一个简单的实现更重要（请参阅第 55、71 页）。&lt;/li>
&lt;li>通用模块更深入（请参阅第 39 页）。&lt;/li>
&lt;li>通用和专用代码分开（请参见第 62 页）。&lt;/li>
&lt;li>不同的层应具有不同的抽象（请参见第 45 页）。&lt;/li>
&lt;li>降低复杂度（请参阅第 55 页）。&lt;/li>
&lt;li>定义不存在的错误（和特殊情况）（请参阅第 79 页）。&lt;/li>
&lt;li>设计两次（请参阅第 91 页）。&lt;/li>
&lt;li>注释应描述代码中不明显的内容（请参见第 101 页）。&lt;/li>
&lt;li>软件的设计应易于阅读而不是易于编写（请参见第 149 页）。&lt;/li>
&lt;li>软件开发的增量应该是抽象而不是功能（请参见第 154 页）。&lt;/li>
&lt;/ol>
&lt;h2 id="summary-of-red-flags-红旗摘要">Summary of Red Flags 红旗摘要&lt;/h2>
&lt;ul>
&lt;li>浅模块：类或方法的接口并不比其实现简单得多（请参见第 25、110 页）。&lt;/li>
&lt;li>信息泄漏：设计决策反映在多个模块中（请参阅第 31 页）。&lt;/li>
&lt;li>时间分解：代码结构基于执行操作的顺序，而不是信息隐藏（请参见第 32 页）。&lt;/li>
&lt;li>过度暴露：API 强制调用者注意很少使用的功能，以便使用常用功能（请参阅第 36 页）。&lt;/li>
&lt;li>Pass-Through Method：一种方法几乎不执行任何操作，只是将其参数传递给具有相似签名的另一种方法（请参见第 46 页）。&lt;/li>
&lt;li>重复：一遍又一遍的重复代码（请参见第 62 页）。&lt;/li>
&lt;li>特殊通用混合物：特殊用途代码未与通用代码完全分开（请参阅第 65 页）。&lt;/li>
&lt;li>联合方法：两种方法之间的依赖性很大，以至于很难理解一种方法的实现而又不理解另一种方法的实现（请参阅第 72 页）。&lt;/li>
&lt;li>注释重复代码：注释旁边的代码会立即显示注释中的所有信息（请参阅第 104 页）。&lt;/li>
&lt;li>实施文档污染了界面：界面注释描述了所记录事物的用户不需要的实施细节（请参阅第 114 页）。&lt;/li>
&lt;li>含糊不清的名称：变量或方法的名称过于精确，以至于它不能传达很多有用的信息（请参阅第 123 页）。&lt;/li>
&lt;li>难以选择的名称：很难为实体提供准确而直观的名称（请参见第 125 页）。&lt;/li>
&lt;li>难以描述：为了完整起见，变量或方法的文档必须很长。（请参阅第 131 页）。&lt;/li>
&lt;li>非显而易见的代码：一段代码的行为或含义不容易理解。（请参阅第 148 页）。&lt;/li>
&lt;/ul></description></item><item><title>2018-Martin Fowler-Refactoring Improving the Design of Existing Code</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2018-martin-fowler-refactoring-improving-the-design-of-existing-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/2018-martin-fowler-refactoring-improving-the-design-of-existing-code/</guid><description>&lt;blockquote>
&lt;p>参考地址：https://ngte.cowtransfer.com/s/f7dbad9e43e145&lt;/p>
&lt;/blockquote></description></item><item><title>面向模式的软件架构</title><link>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/awesome-cs-books-and-digests/system/architecture/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</guid><description/></item></channel></rss>