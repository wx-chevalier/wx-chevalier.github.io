<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>界面开发 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/</link><atom:link href="https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><description>界面开发</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>界面开发</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/</link></image><item><title>TableGrid</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/tablegrid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/tablegrid/</guid><description>&lt;h1 id="uicollectionview">UICollectionView&lt;/h1>
&lt;blockquote>
&lt;p>参考资料&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.cnblogs.com/ios8/p/iOS-UICollectionView.html" target="_blank" rel="noopener">UICollectionView 详解&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://blog.csdn.net/x359981514/article/category/1266042" target="_blank" rel="noopener">Creating Custom Collection View Cells in iOS7&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.techotopia.com/index.php/An_iPhone_iOS_6_Storyboard-based_Collection_View_Tutorial" target="_blank" rel="noopener">An iPhone iOS 6 Storyboard-based Collection View Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.raywenderlich.com/78550/beginning-ios-collection-views-swift-part-1" target="_blank" rel="noopener">UICollectionView Tutorial By Swift&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="uicollectionviewcell自定义样式">UICollectionViewCell：自定义样式&lt;/h2>
&lt;h3 id="auto-size">Auto Size&lt;/h3>
&lt;pre tabindex="0">&lt;code>- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
return CGSizeMake(100, 100);
}
&lt;/code>&lt;/pre>&lt;h1 id="uistackview">UIStackView&lt;/h1>
&lt;ol>
&lt;li>UICollectionView is like a grid, UIStackView is only for 1 dimension: vertical or horizontal.&lt;/li>
&lt;/ol>
&lt;p>UICollectionView is like UITableView, but it supports more than single-column layouts.&lt;/p>
&lt;blockquote>
&lt;p>Collection views provide the same general function as table views except that a collection view is able to support more than just single-column layouts. Collection views support customizable layouts that can be used to implement multi-column grids, tiled layouts, circular layouts, and many more. You can even change the layout of a collection view dynamically if you want.&lt;/p>
&lt;/blockquote>
&lt;p>vs&lt;/p>
&lt;blockquote>
&lt;p>The UIStackView class provides a streamlined interface for laying out a collection of views in either a column or a row&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>For me, With StackView, you benefit the &amp;ldquo;AutoLayout&amp;rdquo; feature, for example: you put 4 views in the Stack, this component will decide how those views will be presented on the screen, depending on their size.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="http://www.cocoachina.com/ios/20150623/12233.html" target="_blank" rel="noopener">iOS 9: UIStackView 入门&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.raywenderlich.com/114552/uistackview-tutorial-introducing-stack-views" target="_blank" rel="noopener">uistackview-tutorial-introducing-stack-views&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="uistackview-extension">UIStackView-Extension&lt;/h1>
&lt;h2 id="fdstackviewhttpsgithubcomforkingdogfdstackview">&lt;a href="https://github.com/forkingdog/FDStackView" target="_blank" rel="noopener">FDStackView&lt;/a>&lt;/h2>
&lt;p>直接在 Podfile 中加入 FDStackView，即可以无缝使用 StackView 及其 N 多的功能。&lt;/p>
&lt;h2 id="heading">&lt;/h2>
&lt;h1 id="cardview">CardView&lt;/h1>
&lt;h2 id="kolodahttpsgithubcomyalantiskoloda">&lt;a href="https://github.com/Yalantis/Koloda" target="_blank" rel="noopener">Koloda&lt;/a>&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://github.com/Yalantis/Koloda/raw/master/Koloda_v2_example_animation.gif" alt="Preview" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>UITableView</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/uitableview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/uitableview/</guid><description>&lt;h1 id="uitableview">UITableView&lt;/h1>
&lt;blockquote>
&lt;p>参考资料&lt;/p>
&lt;ul>
&lt;li>[iOS 开发系列&amp;ndash;UITableView 全面解析][1]&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>使用 UITableView 时，一般会要实现两个 Protocol：&lt;/p>
&lt;p>UITableViewDataSource 与 UITableViewDelegate。注意，如果使用 UITableViewController 方法，它使自动继承了上述两个 Protocol，但是他会内置一个 tableview。如果是自己在 Xib 文件中设置了 UITableView，建议还是使用原生的 UIViewController。&lt;/p>
&lt;p>其中 UITableViewDataSource 的需要实现的方法为：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方 法&lt;/th>
&lt;th>返回类型&lt;/th>
&lt;th>说 明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tableView:cellForRowAtIndexPath:&lt;/td>
&lt;td>UITableViewCell*&lt;/td>
&lt;td>为表视图单元格提供数据，该方法是必须实现的方法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:numberOfRowsInSection:&lt;/td>
&lt;td>NSInteger&lt;/td>
&lt;td>返回某个节中的行数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:titleForHeaderInSection:&lt;/td>
&lt;td>NSString&lt;/td>
&lt;td>返回节头的标题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:titleForFooterInSection:&lt;/td>
&lt;td>NSString&lt;/td>
&lt;td>返回节脚的标题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>numberOfSectionsInTableView:&lt;/td>
&lt;td>NSInteger&lt;/td>
&lt;td>返回节的个数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sectionIndexTitlesForTableView:&lt;/td>
&lt;td>NSArray*&lt;/td>
&lt;td>提供表视图节索引标题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:commitEditingStyle:forRowAtIndexPath:&lt;/td>
&lt;td>void&lt;/td>
&lt;td>为删除或修改提供数据&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>UITableViewDelegate 需要实现的方法为：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方 法&lt;/th>
&lt;th>返回类型&lt;/th>
&lt;th>说 明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tableView:viewForHeaderInSection:&lt;/td>
&lt;td>UIView*&lt;/td>
&lt;td>为节头准备自定义视图，iOS 6 之后可以使用 UITableViewHeaderFooterView&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:viewForFooterInSection:&lt;/td>
&lt;td>UIView*&lt;/td>
&lt;td>为节脚准备自定义视图，iOS 6 之后可以使用 UITableViewHeaderFooterView&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:didEndDisplayingHeaderView:forSection:&lt;/td>
&lt;td>void&lt;/td>
&lt;td>该方法在节头从屏幕中消失时触发(iOS 6 之后的方法)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:didEndDisplayingFooterView:forSection:&lt;/td>
&lt;td>void&lt;/td>
&lt;td>当节脚从屏幕中消失时触发(iOS 6 之后的方法)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:didEndDisplayingCell:forRowAtIndexPath:&lt;/td>
&lt;td>void&lt;/td>
&lt;td>当单元格从屏幕中消失时触发(iOS 6 之后的方法)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tableView:didSelectRowAtIndexPath:&lt;/td>
&lt;td>void&lt;/td>
&lt;td>响应选择表视图单元格时调用的方法&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="simple-uitableview">Simple UITableView&lt;/h2>
&lt;p>UITableView 有两种风格：UITableViewStylePlain 和 UITableViewStyleGrouped。这两者操作起来其实并没有本质区别，只是后者按分组样式显示前者按照普通样式显示而已。大家先看一下两者的应用：&lt;/p>
&lt;p>![Group][2]&lt;/p>
&lt;p>![Plain][3]&lt;/p>
&lt;p>这两种不同的呈现模式，可以利用初始化时候指定：&lt;/p>
&lt;pre tabindex="0">&lt;code>self.tableView =[[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];
&lt;/code>&lt;/pre>&lt;p>如果是利用 Xib 来构建一个 UITableView,也可以在&lt;/p>
&lt;p>最简单的完成 UITableView 的时序图如下：&lt;/p>
&lt;p>![][4]&lt;/p>
&lt;h3 id="datasource数据源">DataSource:数据源&lt;/h3>
&lt;p>在完成对于 UITableView 的初始化之后，需要指定 UITableView 的数据源。即指定_tableView 的句柄指向一个实现了 UITableViewDataSource 的类。&lt;/p>
&lt;pre tabindex="0">&lt;code> //设置数据源，注意必须实现对应的UITableViewDataSource协议
_tableView.dataSource=self;
&lt;/code>&lt;/pre>&lt;h4 id="tableviewcellforrowatindexpath">tableView:cellForRowAtIndexPath:&lt;/h4>
&lt;p>数据源的接口中，最重要的就是要完成对于 Cell 的构造。在简单实现中，我们可以调用系统提供的默认样式：&lt;/p>
&lt;pre tabindex="0">&lt;code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath
{
//初始化Cell
static NSString *CellIdentifier = @&amp;#34;CellIdentifier&amp;#34;;
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
if (cell == nil)
{
cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault
reuseIdentifier:CellIdentifier];
}
//为Cell填充数据
NSUInteger row = [indexPath row];
NSDictionary *rowDict = [self.listTeams objectAtIndex:row];
cell.textLabel.text = [rowDict objectForKey:@&amp;#34;name&amp;#34;];
NSString *imagePath = [rowDict objectForKey:@&amp;#34;image&amp;#34;];
imagePath = [imagePath stringByAppendingString:@&amp;#34;.png&amp;#34;];
cell.imageView.image = [UIImage imageNamed:imagePath];
cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
return cell;
}
&lt;/code>&lt;/pre>&lt;p>除了 Default 的样式之外，其他 iOS 还默认提供的 Cell 的样式有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>UITableViewCellStyleSubtitle&lt;/p>
&lt;p>Subtitle 样式：左边一个显示图片的 imageView，上边一个主标题 textLabel，一个副标题 detailTextLabel。主标题字体大且加黑，副标题字体小在主标题下边。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UITableViewCellStyleValue1&lt;/p>
&lt;p>Value1 样式：左边一个显示图片的 imageView，左边一个主标题 textLabel，右边一个副标题 detailTextLabel，主标题字体比较黑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UITableViewCellStyleValue2&lt;/p>
&lt;p>Value2 样式：左边一个主标题 textLabel 字体偏小，挨着右边一个副标题 detailTextLabel，字体大且加黑。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="uitableviewcell自定义样式">UITableViewCell:自定义样式&lt;/h2>
&lt;h3 id="uitableviewcellaccessory">UITableViewCellAccessory&lt;/h3>
&lt;pre tabindex="0">&lt;code>typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) {
UITableViewCellAccessoryNone, // 不显示任何图标
UITableViewCellAccessoryDisclosureIndicator, // 跳转指示图标
UITableViewCellAccessoryDetailDisclosureButton, // 内容详情图标和跳转指示图标
UITableViewCellAccessoryCheckmark, // 勾选图标
UITableViewCellAccessoryDetailButton NS_ENUM_AVAILABLE_IOS(7_0) // 内容详情图标
};
&lt;/code>&lt;/pre>&lt;p>![Cell 操作][5]&lt;/p>
&lt;p>可以通过：&lt;/p>
&lt;pre tabindex="0">&lt;code> cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
&lt;/code>&lt;/pre>&lt;p>方式来进行指定。&lt;/p>
&lt;h3 id="customcell">CustomCell&lt;/h3>
&lt;p>如果需要使用自定义的 Cell，可以先建立一个自定义的 Xib 文件，并将其与某个 View 建立关联。如下图所示：&lt;/p>
&lt;p>![生成自定义Xib文件][6]&lt;/p>
&lt;p>然后，同样的在关于生成 Cell 的 Delegate 方法中，进行 Cell 的配置：&lt;/p>
&lt;pre tabindex="0">&lt;code>- (UITableViewCell *)tableView:(UITableView *)tableView
cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
static NSString *CellIdentifier = @&amp;#34;Cell&amp;#34;;
CustomCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
NSUInteger row = [indexPath row];
NSDictionary *rowDict = [self.listTeams objectAtIndex:row];
cell.name.text = [rowDict objectForKey:@&amp;#34;name&amp;#34;];
NSString *imagePath = [rowDict objectForKey:@&amp;#34;image&amp;#34;];
imagePath = [imagePath stringByAppendingString:@&amp;#34;.png&amp;#34;];
cell.image.image = [UIImage imageNamed:imagePath];
cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
return cell;
}
&lt;/code>&lt;/pre>&lt;p>注意，在上述代码中，不需要再手动对于 Cell 进行初始化了。&lt;/p>
&lt;blockquote>
&lt;p>常见错误&lt;/p>
&lt;p>reason: &amp;lsquo;unable to dequeue a cell with identifier Cell - must register a nib or a class for the identifier or connect a prototype cell in a storyboard’&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//注册一个Class作为ReusableCell
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tableView&lt;/span> &lt;span class="nl">registerClass&lt;/span>&lt;span class="p">:[&lt;/span>&lt;span class="n">HSFriendListView&lt;/span> &lt;span class="k">class&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">forCellReuseIdentifier&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s">@&amp;#34;HSFriendListViewCell&amp;#34;&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//注册一个Nib文件作为ReusableCell
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tableView&lt;/span> &lt;span class="nl">registerNib&lt;/span>&lt;span class="p">:[&lt;/span>&lt;span class="n">UINib&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">nibWithNibName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s">@&amp;#34;HSCommentCell&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">bundle&lt;/span>&lt;span class="p">:[&lt;/span>&lt;span class="n">NSBundle&lt;/span> &lt;span class="n">mainBundle&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">forCellReuseIdentifier&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">reuseIdentifier&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="auto-height">Auto Height&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>[FDTemplateLayoutCell][7]&lt;/p>
&lt;p>[enter description here][8]&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="static-uitableview">Static UITableView&lt;/h1>
&lt;p>&lt;a href="http://www.appcoda.com/ios-static-table-view-storyboard/" target="_blank" rel="noopener">ios-static-table-view-storyboard&lt;/a>&lt;/p>
&lt;h1 id="uitableview-extension">UITableView-Extension&lt;/h1>
&lt;h2 id="quickcreate">QuickCreate&lt;/h2>
&lt;p>这部分总结了一些快速创建表单的辅助。&lt;/p>
&lt;h3 id="eurekahttpsgithubcomxmartlabseurekaintroduction">&lt;a href="https://github.com/xmartlabs/Eureka#introduction" target="_blank" rel="noopener">Eureka&lt;/a>&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://github.com/xmartlabs/Eureka/raw/master/Example/Media/EurekaNavigation.gif" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://github.com/xmartlabs/Eureka/raw/master/Example/Media/EurekaRows.gif" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="folding">Folding&lt;/h2>
&lt;h3 id="folding-cellhttpsgithubcomramotionfolding-cell">&lt;a href="https://github.com/Ramotion/folding-cell" target="_blank" rel="noopener">folding-cell&lt;/a>&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://github.com/Ramotion/folding-cell/raw/master/Screenshots/folding-cell.gif" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="autoheight">AutoHeight&lt;/h1>
&lt;h2 id="tableviewcellwithautolayoutios8httpsgithubcomsmileyborgtableviewcellwithautolayoutios8">&lt;a href="https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8" target="_blank" rel="noopener">TableViewCellWithAutoLayoutiOS8&lt;/a>&lt;/h2></description></item><item><title>界面基础</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>在 iOS 的 UI 框架中，主要由 Scree、Window、UIView 以及 UIViewController 组成。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://img.blog.csdn.net/20150701233641345?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2F1Y2h5d2VpZXJzdHJhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="UIView" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>ViewController 是用来组织和控制视图的，与上图不同的是这里使用了视图控制器 ViewController，不需要直接将 view 指定给 window，相反，只需要给 window 制定一个视图控制器，视图控制器会自动的将他的 view 添加给 window。如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://img.blog.csdn.net/20150701234834234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2F1Y2h5d2VpZXJzdHJhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="UIViewController" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>引入控制器有点像 Android 里面的 Activity。&lt;/p>
&lt;h2 id="size">Size&lt;/h2>
&lt;h3 id="cggeometry">CGGeometry&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CGFloat&lt;/td>
&lt;td>浮点值的基本类型&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CGPoint&lt;/td>
&lt;td>表示一个二维坐标系中的点&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CGSize&lt;/td>
&lt;td>表示一个矩形的宽度和高度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CGRect&lt;/td>
&lt;td>表示一个矩形的位置和大小&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">CGFloat&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">// 32-bit
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">typedef&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">CGFloat&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">// 64-bit
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">CGPoint&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">CGPoint&lt;/span> &lt;span class="n">CGPoint&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">CGSize&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">CGSize&lt;/span> &lt;span class="n">CGSize&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">CGRect&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGPoint&lt;/span> &lt;span class="n">origin&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGSize&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">CGRect&lt;/span> &lt;span class="n">CGRect&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：CGRect 数据结构的高度和宽度可以是负数。例如，一个矩形的原点是[0.0，0.0]和大小是[10.0,10.0]。这个矩形完全等同原点是[10.0，10.0]和大小是[-10.0，-10.0]的矩形。&lt;/p>
&lt;p>使用值来创建几何元素的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGPoint&lt;/span> &lt;span class="nf">CGPointMake&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGSize&lt;/span> &lt;span class="nf">CGSizeMake&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">height&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGRect&lt;/span> &lt;span class="nf">CGRectMake&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">CGFloat&lt;/span> &lt;span class="n">height&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGFloat&lt;/span> &lt;span class="n">ten&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mf">10.0f&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGPoint&lt;/span> &lt;span class="n">point&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CGPointMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.0f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.0f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGSize&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CGSizeMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">10.0f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">10.0f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGRect&lt;/span> &lt;span class="n">rect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CGRectMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">point&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">NSLog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">@&amp;#34;ten: %f&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ten&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">NSLog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">@&amp;#34;point: %@&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">NSStringFromCGPoint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">NSLog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">@&amp;#34;size: %@&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">NSStringFromCGSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">NSLog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">@&amp;#34;rect: %@&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">NSStringFromCGRect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rect&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="uiscreen">UIScreen&lt;/h2>
&lt;p>UIScreen 是与设备有关的物理屏幕。&lt;/p>
&lt;h2 id="uiwindow">UIWindow&lt;/h2>
&lt;p>一般来说，在 AppDelegate.m 文件中的 didFinishLaunchingWithOptions 方法中，会为当前窗口声明一个 UIWindow 对象，具体如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UIWindow&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">window&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">UIWindow&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">initWithFrame&lt;/span>&lt;span class="p">:[[&lt;/span>&lt;span class="n">UIScreen&lt;/span> &lt;span class="n">mainScreen&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">bounds&lt;/span>&lt;span class="p">]];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">levelViewController&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">LevelViewController&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">init&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">rootViewController&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">levelViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 类似于下面这句
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//[window addSubView: levelViewController.view];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">window&lt;/span> &lt;span class="n">makeKeyAndVisible&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//将生成的窗口对象赋值给当前应用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">window&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Swift&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//App第一次运行的时候被执行过一次，每次App从后台激活时都不执行该方法：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">application&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">application&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">UIApplication&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">didFinishLaunchingWithOptions&lt;/span> &lt;span class="n">launchOptions&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">NSObject&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">AnyObject&lt;/span>&lt;span class="p">]?)&lt;/span> &lt;span class="p">-&amp;gt;&lt;/span> &lt;span class="nb">Bool&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nv">viewCtl&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">ViewController&lt;/span>&lt;span class="p">!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">UIWindow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">frame&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">UIScreen&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mainScreen&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">bounds&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">!.&lt;/span>&lt;span class="n">backgroundColor&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">UIColor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">whiteColor&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewCtl&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">ViewController&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nibName&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;ViewController&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bundle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">NSBundle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mainBundle&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">!.&lt;/span>&lt;span class="n">rootViewController&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">viewCtl&lt;/span>&lt;span class="c1">//UIWindow有一个根视图控制器—负责显示的视图&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kc">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">!.&lt;/span>&lt;span class="n">makeKeyAndVisible&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="c1">//让包含视图控制器视图的Window窗口显示在屏幕上&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nv">isKeyWindow&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">!.&lt;/span>&lt;span class="n">keyWindow&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nv">keyWinD&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">UIWindow&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">UIApplication&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sharedApplication&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">keyWindow&lt;/span>&lt;span class="p">!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="mainstoryboard">Main.StoryBoard&lt;/h3>
&lt;p>在创建一个新的 iOS Application 之后，会发现这个新项目包含 2 个类：AppDelegate 和 ViewController，此外还有 Main.storyboard 文件。&lt;/p>
&lt;p>你定义的这个视图控制器被设定为初始视图控制器，但 App 是如何加载的呢？答案就在应用代理(application delegate )当中，打开 &lt;em>AppDelegate.swift&lt;/em>，你会看到如下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-swift" data-lang="swift">&lt;span class="line">&lt;span class="cl">&lt;span class="p">`&lt;/span>&lt;span class="kd">import&lt;/span> &lt;span class="nc">UIKit&lt;/span>&lt;span class="p">``&lt;/span> &lt;span class="p">`&lt;/span> &lt;span class="p">`&lt;/span>&lt;span class="kr">@UIApplicationMain&lt;/span>&lt;span class="p">``&lt;/span>&lt;span class="nc">class&lt;/span> &lt;span class="nc">AppDelegate&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">UIResponder&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nc">UIApplicationDelegate&lt;/span> &lt;span class="p">{``&lt;/span> &lt;span class="p">``&lt;/span>&lt;span class="nc">var&lt;/span>&lt;span class="p">`&lt;/span> &lt;span class="p">`&lt;/span>&lt;span class="nc">window&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">UIWindow&lt;/span>&lt;span class="p">?``&lt;/span> &lt;span class="p">`&lt;/span> &lt;span class="p">`&lt;/span> &lt;span class="p">``&lt;/span>&lt;span class="nc">func&lt;/span> &lt;span class="nc">application&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nc">application&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">UIApplication&lt;/span>&lt;span class="p">!,&lt;/span> &lt;span class="nc">didFinishLaunchingWithOptions&lt;/span> &lt;span class="nc">launchOptions&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">NSDictionary&lt;/span>&lt;span class="p">!)&lt;/span> &lt;span class="p">-&amp;gt;&lt;/span> &lt;span class="nc">Bool&lt;/span> &lt;span class="p">{``&lt;/span> &lt;span class="p">``&lt;/span>&lt;span class="c1">// Override point for customization after application launch.`` ``return` `true`` ``}`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的 &lt;code>@UIApplicationMain&lt;/code> 标记指定这个 AppDelegate 类为该模块的入口。使用 Storyboard 时，应用代理必须继承 &lt;code>UIResponder&lt;/code>，必须含有 &lt;code>UIWindow&lt;/code> 属性，几乎所有的方法都是空的，甚至 &lt;code>application(_:didFinishLaunchingWithOptions:)&lt;/code> 也只是返回 true 而已。&lt;/p>
&lt;p>秘密藏在 Info.plist 文件里，在 Supporting Files Group 里找到并点击 &lt;em>Info.plist&lt;/em>，你会看到这一条：&lt;/p>
&lt;p>&lt;a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/09/09_sb_infoplist.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026991448598.png" alt="Info.plis" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Storyboard 用 &lt;code>UIMainStoryboardFile&lt;/code>(即 Main storyboard file base name 键) 来指明 App 启动时必须加载的 Storyboard 的名称。当设置生效，&lt;code>UIApplication&lt;/code>会加载对应名称的 Storyboard 文件，自动将该 Storyboard 中的初始视图控制器实例化，并将其纳入一个新的 &lt;code>UIWindow&lt;/code> 对象中。&lt;/p>
&lt;p>在 General 分页的 Project Settings 和 Deployment Info 中也可以看到：&lt;/p>
&lt;p>&lt;a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/09/10_sb_targetsummary.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026991373391.png" alt="Project Setting" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>如果我们希望入口界面不是默认的 Main.StoryBoard，就按照上文所述的&lt;code>didFinishLaunchingWithOptions&lt;/code>方法中设置自定义的 ViewController。&lt;/p>
&lt;h1 id="interface-builder">Interface Builder&lt;/h1>
&lt;p>xib 和 storyboard 的比较，一个轻量级一个重量级。他们的共同点是都用来描述软件界面，都用 Interface Builder 工具来编辑。他们的不同点是 Xib 是轻量级的，用来描述局部的 UI 界面；Storyboard 是重量级的，用来描述整个软件的多个界面，并且能展示多个界面之间的跳转关系。&lt;/p>
&lt;p>xib 文件可以被 Xcode 编译成 nib 文件，xib 文件本质上是一个 xml 文件，而 nib 文件就是编译后的二进制文件，该文件将视图等控件对象封装了起来，而在程序运行起来后，这些对象会被激活。xib 文件本质上是一个 xml 文件，可以用 vim 或 cat 命令查看。&lt;/p>
&lt;h2 id="xib">Xib&lt;/h2>
&lt;p>Project Builder 在 Mac OS X 10.3 时被重命名为现在大家所熟知的 Xcode。Xcode 3 以前，Interface Builder 使用一种名为 nib 格式的二进制文件格式。不过由于 nib 不能用肉眼读，也不方便使用版本管理工具来管理，所以 Xcode 3 开始新加入一种名为 xib 的文本文件格式，最后再在项目编译阶段输出为 nib 格式。和产生静态界面布局代码的工具很不同，nib 是不被转译成相应 Objective-C 代码的。用户程序执行时，nib 文件被读入，解包，所以 nib 文件是在运行时动态加载的。&lt;/p>
&lt;h3 id="元素关联动作与输出口">元素关联：动作与输出口&lt;/h3>
&lt;ul>
&lt;li>自动关联：依赖注入&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>参考文章&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>[iOS 操作(action )和输出口(Outlet )][3]&lt;/li>
&lt;/ul>
&lt;p>iOS 以 IBOutlet 与 IBAction 来代表页面元素在代码类中的映射。步骤简单来说，就是：&lt;/p>
&lt;p>( 1)在 Xib 文件对应的 File&amp;rsquo;s Owner 中选择该 Xib 文件对应的 ViewController。&lt;/p>
&lt;p>( 2)选择界面上的某个控件，按下 control+ 鼠标左键拖拽箭头至对应的 ViewController 中。&lt;/p>
&lt;p>( 3)在弹出框内可以选择是需要插入 IBOutlet 还是 IBAction。&lt;/p>
&lt;p>注意，对于 File Owner 为空或者不是 self 的 Xib 界面，是无法与类直接连线产生关联的。&lt;/p>
&lt;p>在使用 IBOutlet 进行关联时，有时候系统默认的会是 weak，但是 Apple 官方推荐的是 strong：&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;And the last option I want to point out is the storage type, which can either be strong or weak. In general you should make your outlet strong, especially if you are connecting an outlet to a subview or to a constraint that&amp;rsquo;s not always going to be retained by the view hierarchy. The only time you really need to make an outlet weak is if you have a custom view that references something back up the view hierarchy and in general that&amp;rsquo;s not recommended.&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>手动关联&lt;/li>
&lt;/ul>
&lt;h2 id="storyboard">StoryBoard&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://www.raywenderlich.com/50308/storyboards-tutorial-in-ios-7-part-1" target="_blank" rel="noopener">storyboards-tutorial-in-ios-7&lt;/a>&lt;/p>
&lt;blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.cocoachina.com/ios/20150112/10892.html" target="_blank" rel="noopener">Swift 语言 Storyboard 教程：第一部分&lt;/a>、&lt;a href="http://www.cocoachina.com/swift/20150114/10924.html" target="_blank" rel="noopener">Swift 语言 Storyboard 教程：第二部分&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>苹果官方是推荐我们将所有的 UI 都使用 Storyboard 去搭建，Storyboard 也是一个很成熟的工具了。使用 Storyboard 去搭建所有界面，我们可以很迅捷地搭建出复杂的界面，也就是说能为我们节省大量的时间。我们还可以很直观地看出各个界面之间的关系，修改起来也很方便。将来如果遇到需要作修改的地方，我们只需要找到相对应的 Storyboard 就可以了，比起以前来说，快捷了不少。如果 App 中包括很多不同的页面，使用 Storyboard 可以帮你&lt;strong>减少实现页面间跳转的胶合代码&lt;/strong>。过去的开发者对应每个视图控制器分别创建界面设计文件(即 “nib”或“xib” 文件)，现在，只要一个 Storyboard 就可以包揽所有视图控制器的界面设计和他们之间的关联。&lt;/p>
&lt;p>Storyboard 有很多优点：&lt;/p>
&lt;ul>
&lt;li>使用 Storyboard 可以更好地了解 App 中所有的视图以及它们之间的关联的概况。掌控全局更加容易，因为所有的设计都包含在一个文件中，而不是分散在很多单独的 nib 文件中。&lt;/li>
&lt;li>Storyboard 可以描述不同视图之间的过渡，这种过渡叫做 “segue”(译注：意为 “ 转场 ”，而 “Storyboard” 原意为 “ 分镜 ”，均源自电影术语)，你可以直接在 Storyboard 中通过连接不同的视图控制器来创建转场。多亏有了转场，打理界面的代码比以前要少了。&lt;/li>
&lt;li>Storyboard 通过新的原型表项(prototype cell )和静态表项(static cell )特性，让处理表视图(table view )的工作更加轻松。几乎完全可以在 Storyboard 编辑器里搞定表视图的设计，同样也减少了代码量。&lt;/li>
&lt;li>Storyboard 使自动布局(Auto Layout )更易用。自动布局功能可以让你通过界面元素之间的数学关系定义来确定元素的位置和尺寸，极大简化了不同尺寸屏幕的适配工作。自动布局不在本教程范围之内，若想了解更多，请参阅&lt;a href="http://www.raywenderlich.com/?p=50317" target="_blank" rel="noopener">自动布局入门&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h3 id="scene--segue">Scene &amp;amp; Segue&lt;/h3>
&lt;p>一个视图控制器在 Storyboard 中的官方术语是 “ 场景(scene ) ”，但这两种叫法是相通的。一个视图控制器在 Storyboard 中可以叫做场景。&lt;/p>
&lt;p>这里可以看到一个包含空视图的视图控制器。在这个视图控制器左边指向它的箭头表明它是这个 Storyboard 中要显示的第一个视图控制器。&lt;/p>
&lt;p>在 Storyboard 编辑器中设计布局的方法是从右下角的 Object Library(对象库)中把控件拖入视图控制器，非常容易。&lt;/p>
&lt;p>注：你会注意到默认场景是一个正方形。Xcode 6 默认为 Storyboard 和 nib 文件开启自动布局(Auto Layout )和尺寸归类(Size Classes )。自动布局和尺寸归类这两项新技术可以构建易于调整大小的用户界面，这对支持不同尺寸的 iPhone 和 iPad 非常有用。&lt;/p>
&lt;p>自动布局由 iOS 6 引入，尺寸归类由 iOS 8 引入。两者都需要一定的学习曲线，所以本教程中暂不使用，但为了支持不同的设备尺寸，以后还是要接触到的。要了解更多，请参阅我们的书籍 &lt;a href="http://www.raywenderlich.com/store/ios-8-by-tutorials" target="_blank" rel="noopener">iOS 8 教程&lt;/a>。&lt;/p>
&lt;p>在继续探索之前，先在当前 Storyboard 的 &lt;em>File inspector(文件检查器)&lt;/em> 中禁用 Auto Layout 和 Size Classes，如图：&lt;/p>
&lt;p>&lt;a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/09/Disable-auto-layout.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026987473646.png" alt="Disabling auto layou" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Xcode 询问操作时，选择保留 &lt;em>iPhone&lt;/em> 的尺寸归类数据，然后点击 &lt;em>Disable Size Classes&lt;/em>：&lt;/p>
&lt;p>&lt;a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/09/DisableSizeClasses.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026988849003.png" alt="Disabling size classe" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>现在，场景变成了 4 英寸 iPhone 尺寸的样子。&lt;/p>
&lt;p>从右下方的对象库里把一些控件拖到空的视图控制器上，感受一下 Storyboard 编辑器的工作方式：&lt;/p>
&lt;p>&lt;a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/09/Drag-controls.gif" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026988970351.gif" alt="Dragging controls into storyboar" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>控件拖进来之后应该会在左边的文档大纲(Document Outline )中显示：&lt;/p>
&lt;p>&lt;a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/09/Document-outline.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026989383347.png" alt="Document outlin" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>如果没看到文档大纲，请点击 Storyboard 面板左下角的这个按钮：&lt;/p>
&lt;p>&lt;a href="http://cdn1.raywenderlich.com/wp-content/uploads/2014/09/Doc-outline-button.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026989731981.png" alt="The document outline butto" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Storyboard 显示所有视图控制器的内容，当前的 Storyboard 中仅有一个视图控制器(场景)，在本教程后面我们会添加其他场景。&lt;/p>
&lt;p>在场景上面还有一个缩小的文档大纲，称作 Dock：&lt;/p>
&lt;p>&lt;a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/09/Dock.png" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://api.cocoachina.com/uploads/image/20150112/1421026990437127.png" alt="Doc" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Dock 显示场景中最上层的对象，每个视图都至少有一个 视图控制器(View Controller ) 对象，一个 第一响应者(First Responder ) 对象，一个 出口(Exit ) 项。除此之外也可以有其他的最上层对象。Dock 方便连接 outlet 和 action，当你想把某个对象连接到视图控制器时，只需把它拖到 Dock 的图标上。&lt;/p>
&lt;h3 id="auto-resize">Auto Resize&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="http://stackoverflow.com/questions/25455945/resize-uiview-with-auto-layout" target="_blank" rel="noopener">resize-uiview-with-auto-layout&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="uiview">UIView&lt;/h1>
&lt;h2 id="lifecycle">LifeCycle&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>函数名&lt;/th>
&lt;th>生命周期&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>init&lt;/td>
&lt;td>NSObject 的类实现一个名为 init 方法。这是你需要发送到 NSObject 的实例初始化初始化消息。因为 init 是主要的(或在这种情况下，只有)NSObject 的初始化方法，我们称之为 the designated 初始化。类可以有多个初始化，但每类中，有一个指定的初始化。指定初始化必须确保每个实例变量有一个有效的价值。只有这样，新创建的实例是有效的。( “ 有效 ” 有不同的含义，但在这方面的含义是，“ 当您发送的消息后，对其进行初始化这个对象，你可以预测的结果会发生什么不好。” )通常情况下，指定的初始化是初始化方法与大多数参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>viewWillAppear&lt;/td>
&lt;td>视图即将可见时调用。默认情况下不执行任何操作&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>viewWillDisappear&lt;/td>
&lt;td>视图被驳回时调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>viewDidDisappear&lt;/td>
&lt;td>视图被驳回后调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>viewDidAppear&lt;/td>
&lt;td>视图已完全过渡到屏幕上时调用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>viewDidLoad&lt;/td>
&lt;td>在视图加载后被调用，如果是在代码中创建的视图加载器，他将会在 loadView 方法后被调用，如果是从 nib 视图页面输出，他将会在视图设置好后后被调用。&lt;strong>只会被调用一次&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>viewDidUnload&lt;/td>
&lt;td>当系统内存吃紧的时候调用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;h3 id="视图加载">视图加载&lt;/h3>
&lt;h4 id="initwithframe">initWithFrame:&lt;/h4>
&lt;p>initWithFrame: 是 UIView 提供的一个内建的初始化方法，可以创建一个指定 Frame 大小的空白的 UIView。&lt;/p>
&lt;pre tabindex="0">&lt;code>var rightView:UIView = UIView(frame:CGRectMake(260,0,40,40))
&lt;/code>&lt;/pre>&lt;h4 id="从-xib-文件加载">从 Xib 文件加载&lt;/h4>
&lt;pre tabindex="0">&lt;code>NSArray* nibView = [[NSBundle mainBundle]
loadNibNamed:@&amp;#34;CenterView&amp;#34; owner:self options:nil];
self =[nibView objectAtIndex:0];
&lt;/code>&lt;/pre>&lt;h2 id="properties">Properties&lt;/h2>
&lt;h3 id="size--position">Size &amp;amp; Position&lt;/h3>
&lt;pre tabindex="0">&lt;code>在一个UIView中，最常见的用来描述其坐标的属性有Frame、Bounds以及Center。
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Frame(CGRect)&lt;/td>
&lt;td>UIview 的 Frame 属性用于描述其在父坐标系中的矩形，默认的它是从左上角开始计算&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Bounds(CGRect)&lt;/td>
&lt;td>Bounds 用于描述该 View 在自身坐标系内的矩形&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Center(CGPoint)&lt;/td>
&lt;td>用于描述 UIView 在其父 View 的坐标系中的中心点位置&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;pre tabindex="0">&lt;code>基本的计算方式如下：
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">frame&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">origin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">center&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bounds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mf">2.0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">center&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">frame&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">origin&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">bounds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mf">2.0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">frame&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bounds&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://i.stack.imgur.com/3jcne.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// view1 will be positioned at x = 30, y = 20 starting the top left corner of [self view]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// [self view] could be the view managed by a UIViewController
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">UIView&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">view1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">UIView&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">initWithFrame&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">CGRectMake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">30.0f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">20.0f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">400.0f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">400.0f&lt;/span>&lt;span class="p">)];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">view1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">backgroundColor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">UIColor&lt;/span> &lt;span class="n">redColor&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="n">view&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">addSubview&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">view1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="coordinate-transform-坐标系转换">Coordinate Transform: 坐标系转换&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 将像素point由point所在视图转换到目标视图view中，返回在目标视图view中的像素值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">CGPoint&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">convertPoint:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">CGPoint&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">point&lt;/span> &lt;span class="nf">toView:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">UIView&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">view&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 将像素point从view中转换到当前视图中，返回在当前视图中的像素值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">CGPoint&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">convertPoint:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">CGPoint&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">point&lt;/span> &lt;span class="nf">fromView:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">UIView&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">view&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">CGRect&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">convertRect:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">CGRect&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">rect&lt;/span> &lt;span class="nf">toView:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">UIView&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">view&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 将rect从view中转换到当前视图中，返回在当前视图中的rect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">CGRect&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">convertRect:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">CGRect&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">rect&lt;/span> &lt;span class="nf">fromView:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">UIView&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">view&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>例把UITableViewCell中的subview(btn)的frame转换到 controllerA中
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// controllerA 中有一个UITableView, UITableView里有多行UITableVieCell，cell上放有一个button
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 在controllerA中实现:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">CGRect&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">cell&lt;/span> &lt;span class="nl">convertRect&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">cell&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">btn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">frame&lt;/span> &lt;span class="nl">toView&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">view&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">或&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGRect&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">view&lt;/span> &lt;span class="nl">convertRect&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">cell&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">btn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">frame&lt;/span> &lt;span class="nl">fromView&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">cell&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 此rc为btn在controllerA中的rect
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">或当已知&lt;/span>&lt;span class="n">btn&lt;/span>&lt;span class="err">时：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGRect&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">btn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superview&lt;/span> &lt;span class="nl">convertRect&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">btn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">frame&lt;/span> &lt;span class="nl">toView&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">view&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">或&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGRect&lt;/span> &lt;span class="n">rc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">view&lt;/span> &lt;span class="nl">convertRect&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">btn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">frame&lt;/span> &lt;span class="nl">fromView&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">btn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superview&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="subviewtree子视图与视图树">SubViewTree：子视图与视图树&lt;/h2>
&lt;h3 id="子视图索引">子视图索引&lt;/h3>
&lt;h4 id="index">Index&lt;/h4>
&lt;h4 id="tag">Tag&lt;/h4>
&lt;pre tabindex="0">&lt;code>var nameLabel:UILabel;
nameLabel.tag = 59;
self.view.addSubview(nameLabel);
nameLabel = self.view.viewWithTag(68) as UILabel;
&lt;/code>&lt;/pre>&lt;h3 id="visiblerect可见区域">VisibleRect：可见区域&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">CGRect&lt;/span> &lt;span class="n">visibleRect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CGRectIntersection&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">frame&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">superview&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">bounds&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="uiviewcontroller">UIViewController&lt;/h1>
&lt;p>在 iOS 中，具体的对 View 的控制还是基于 UIViewController。UIViewController 是 UIView 的子类。&lt;/p>
&lt;h2 id="lifecycle-1">LifeCycle&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://img.blog.csdn.net/20150701234853010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2F1Y2h5d2VpZXJzdHJhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter description here" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="初始化-1">初始化&lt;/h3>
&lt;pre tabindex="0">&lt;code>使用如下方法加载一个
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>levelViewController = [[LevelViewController alloc] init];
&lt;/code>&lt;/pre>&lt;p>上面这句 levelViewController = [[LevelViewController alloc] init]; 在创建自己的控制器的时候会自动调用 loadView 方法。&lt;/p>
&lt;h3 id="视图加载-1">视图加载&lt;/h3>
&lt;pre tabindex="0">&lt;code>UIViewController更多的是负责iOS中的视图逻辑控制，
&lt;/code>&lt;/pre>&lt;h4 id="xib-1">Xib&lt;/h4>
&lt;p>从 Xib 文件中加载视图时，即自动完成了实例化该 Xib 对应的 UIView、将其赋值给该 UIViewController 的 view 属性以及自动将该 UIViewController 的控件变量与实例进行关联。&lt;/p>
&lt;pre tabindex="0">&lt;code>self = [[HSFriendListViewControllerTableViewController alloc] initWithNibName:@&amp;#34;HSFriendListView&amp;#34; bundle:nil];
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>常见错误&lt;/p>
&lt;p>1.Loaded nib but the view outlet was not set&lt;/p>
&lt;p>这种错误是因为在一个 Xib 文件中可能存在多个 UIView，在指定了 FileOwner 之后，需要指定此状态下的根 UIView，如下图所示：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://i.stack.imgur.com/fzu7d.jpg" alt="screenshot" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/blockquote>
&lt;h4 id="storyboard-1">StoryBoard&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">UIStoryboard&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">storyboard&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">storyboard&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">SpecialViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">svc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">storyboard&lt;/span> &lt;span class="nl">instantiateViewControllerWithIdentifier&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s">@&amp;#34;SpecialViewController&amp;#34;&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Configure the new view controller here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="nl">presentViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">svc&lt;/span> &lt;span class="nl">animated&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">YES&lt;/span> &lt;span class="nl">completion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">nil&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="loadview-中自定义视图">loadView 中自定义视图&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="nf">loadView&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UIView&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">view&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="n">UIView&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">initWithFrame&lt;/span>&lt;span class="p">:[&lt;/span>&lt;span class="n">UIScreen&lt;/span> &lt;span class="n">mainScreen&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">applicationFrame&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="n">view&lt;/span> &lt;span class="nl">setBackgroundColor&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">_color&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">view&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">view&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="n">view&lt;/span> &lt;span class="k">release&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>loadView 方法执行如下操作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果你重载了这个方法，则必须创建必要的 view 并且将一个非 nil 值传给 UIViewController 的 view 属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你没有重载这个函数，UIViewController 会默认使用 UIViewController 的 nibName 和 nibBundle 属性尝试从 xib 文件加载 view。如果没有找到 nib 文件，则 ViewController 会通过以下两个步骤找到与其关联的 nib。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>(a) 如果类名包含 Controller，例如 ViewController 的类名是 MyViewController，则查找是否存在 MyView.xib；&lt;/p>
&lt;p>(b) 找跟 ViewController 类名一样的文件，例如 MyViewController，则查找是否存在 MyViewController.xib。&lt;/p>
&lt;p>(c) 如果没有可用的 nib 文件，那么它创建一个空的 UIView 作为它的 view。&lt;/p>
&lt;h2 id="视图切换">视图切换&lt;/h2>
&lt;h3 id="模态视图">模态视图&lt;/h3>
&lt;p>模态视图即类似于 Android 中的 Activity，是一个单一的 UIViewController。利用 UIViewController 自身的 presentModalViewController，进行跳转；调用 dismissModalViewControllerAnimated 方法可以返回。&lt;/p>
&lt;p>简而言之，模态视图的跳转方式为：&lt;/p>
&lt;pre tabindex="0">&lt;code>PickImageViewController *ickImageViewController = [[PickImageViewController alloc] init];
[self presentModalViewController:ickImageViewController animated:YES];
//返回
[self dismissModalViewController Animated:YES];
&lt;/code>&lt;/pre>&lt;p>( 1)指定跳转动画。&lt;/p>
&lt;p>在模态视图跳转时，可以通过 modalTransitionStyle 来指定跳转的动画。&lt;/p>
&lt;pre tabindex="0">&lt;code>registerViewController.modalTransitionStyle =
UIModalTransitionStyleCoverVertical;
&lt;/code>&lt;/pre>&lt;p>常见的常量值有：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>常量值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>UIModalTransitionStyleCoverVertical&lt;/td>
&lt;td>呈现时沿垂直方向由底向上退出，覆盖原来视图，关闭时从上往底部退回&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UIModalTransitionStyleFlipHorizontal&lt;/td>
&lt;td>水平翻转，呈现的时候从右往左翻转，关闭的时候从左往右翻转回来，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UIModalTransitionStyleCrossDissolve&lt;/td>
&lt;td>两个视图交叉淡入淡出，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UIModalTransitionStylePartialCurl&lt;/td>
&lt;td>呈现时模态视图卷起一个边角翻页，关闭时模态视图翻回来，&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>( 2)信息传递&lt;/p>
&lt;p>在页面进行跳转时，或者某个页面结束需要回传信息时，可以利用通知机制进行消息传递：&lt;/p>
&lt;pre tabindex="0">&lt;code>- (void)viewDidLoad
{
[super viewDidLoad];
[[NSNotificationCenter defaultCenter]
addObserver:self
selector:@selector(registerCompletion:)
name:@&amp;#34;RegisterCompletionNotification&amp;#34;
object:nil
];
}
-(void)registerCompletion:(NSNotification*)notification {
NSDictionary *theData = [notification userInfo];
NSString *username = [theData objectForKey:@&amp;#34;username&amp;#34;];
NSLog(@&amp;#34;username = %@&amp;#34;,username);
}
&lt;/code>&lt;/pre>&lt;p>修改 RegisterViewController.m 代码，在 done 方法中的关闭完成 completion 代码块中添加代码投送通知&lt;/p>
&lt;p>RegisterCompletionNotification，其中通知的参数放在字典 dataDict 中：&lt;/p>
&lt;pre tabindex="0">&lt;code>- (IBAction)done:(id)sender {
[self dismissViewControllerAnimated:YES completion:^{
NSLog(@&amp;#34;Modal View done&amp;#34;);
NSDictionary *dataDict = [NSDictionary
dictionaryWithObject:self.txtUsername.text
forKey:@&amp;#34;username&amp;#34;];
[[NSNotificationCenter defaultCenter]
postNotificationName:@&amp;#34;RegisterCompletionNotification&amp;#34;
object:nil
userInfo:dataDict];
}];
}
&lt;/code>&lt;/pre>&lt;h3 id="childviewcontroller子视图控制器">childViewController：子视图控制器&lt;/h3>
&lt;pre tabindex="0">&lt;code>View Controller中可以添加多个sub view，在需要的时候显示出来；可以通过viewController(parent)中可以添加多个child viewController;来控制页面中的sub view，降低代码耦合度；通过切换，可以显示不同的view；替代之前addSubView的管理。在转移到子ViewController之后，有几个方法被子ViewController托管了：
&lt;/code>&lt;/pre>&lt;p>1- Appearance Methods:&lt;/p>
&lt;pre tabindex="0">&lt;code>- viewWillAppear:
- viewDidAppear:
- viewWillDisappear:
- viewDidDisappear:
&lt;/code>&lt;/pre>&lt;p>2- Rotation Methods:&lt;/p>
&lt;pre tabindex="0">&lt;code>- willRotateToInterfaceOrientation:duration:
- willAnimateRotationToInterfaceOrientation:duration:
- didRotateFromInterfaceOrientation:
&lt;/code>&lt;/pre>&lt;p>苹果 API 中所带方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>addChildViewController:
removeFromParentViewController
transitionFromViewController:toViewController:duration:options:animations:completion:
willMoveToParentViewController:
didMoveToParentViewController:
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>创建项目，changeViewController。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加相应的 viewController，MainViewController、FirstViewController、SecondViewController、ThirdViewController。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把 MainViewController 添加到 window 中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="p">-&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">BOOL&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">application:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">UIApplication&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">application&lt;/span> &lt;span class="nf">didFinishLaunchingWithOptions:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">NSDictionary&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">launchOptions&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="n">UIWindow&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">initWithFrame&lt;/span>&lt;span class="p">:[[&lt;/span>&lt;span class="n">UIScreen&lt;/span> &lt;span class="n">mainScreen&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">bounds&lt;/span>&lt;span class="p">]];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Override point for customization after application launch.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">MainViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mainViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="n">MainViewController&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">initWithNibName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s">@&amp;#34;MainViewController&amp;#34;&lt;/span> &lt;span class="nl">bundle&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">nil&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">rootViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">mainViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">window&lt;/span> &lt;span class="n">makeKeyAndVisible&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">YES&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>
&lt;p>在 MainViewController 中添加三个按钮，并且连接 onClickbutton 方法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 MainViewController 中添加三个子 controller&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#pragma mark – View lifecycle - (void)viewDidLoad
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">super&lt;/span> &lt;span class="n">viewDidLoad&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Do any additional setup after loading the view from its nib.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">FirstViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">firstViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="n">FirstViewController&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">initWithNibName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s">@&amp;#34;FirstViewController&amp;#34;&lt;/span> &lt;span class="nl">bundle&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">nil&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="nl">addChildViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">firstViewController&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SecondViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">secondViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="n">SecondViewController&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">initWithNibName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s">@&amp;#34;SecondViewController&amp;#34;&lt;/span> &lt;span class="nl">bundle&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">nil&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="nl">addChildViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">secondViewController&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThirdViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thirdViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="n">ThirdViewController&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nl">initWithNibName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s">@&amp;#34;ThirdViewController&amp;#34;&lt;/span> &lt;span class="nl">bundle&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">nil&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="nl">addChildViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">thirdViewController&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="n">contentView&lt;/span> &lt;span class="nl">addSubview&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">thirdViewController&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">view&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">currentViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">thirdViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>其中要把其中的一个子controller的view添加到根视图中，这样才能显示出相应的视图。
&lt;/code>&lt;/pre>&lt;ol start="6">
&lt;li>点击按钮，切换视图。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-objective-c" data-lang="objective-c">&lt;span class="line">&lt;span class="cl">&lt;span class="p">-(&lt;/span>&lt;span class="kt">IBAction&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nf">onClickbutton:&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="nv">sender&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">FirstViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">firstViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">childViewControllers&lt;/span> &lt;span class="nl">objectAtIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThirdViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thirdViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">childViewControllers&lt;/span> &lt;span class="nl">objectAtIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SecondViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">secondViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">childViewControllers&lt;/span> &lt;span class="nl">objectAtIndex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">currentViewController&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="n">firstViewController&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">sender&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currentViewController&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="n">secondViewController&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">sender&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currentViewController&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="n">thirdViewController&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">sender&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UIViewController&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">oldViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">currentViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">switch&lt;/span> &lt;span class="p">([&lt;/span>&lt;span class="n">sender&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="nl">transitionFromViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">currentViewController&lt;/span> &lt;span class="nl">toViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">firstViewController&lt;/span> &lt;span class="nl">duration&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="nl">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">UIViewAnimationOptionTransitionFlipFromLeft&lt;/span> &lt;span class="nl">animations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="nl">completion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">BOOL&lt;/span> &lt;span class="n">finished&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">finished&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">currentViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">firstViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">currentViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">oldViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="nl">transitionFromViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">currentViewController&lt;/span> &lt;span class="nl">toViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">secondViewController&lt;/span> &lt;span class="nl">duration&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="nl">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">UIViewAnimationOptionTransitionFlipFromTop&lt;/span> &lt;span class="nl">animations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="nl">completion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">BOOL&lt;/span> &lt;span class="n">finished&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">finished&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">currentViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">secondViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">currentViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">oldViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NSLog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">@&amp;#34;好友申请&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nb">self&lt;/span> &lt;span class="nl">transitionFromViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">currentViewController&lt;/span> &lt;span class="nl">toViewController&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">thirdViewController&lt;/span> &lt;span class="nl">duration&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="nl">options&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">UIViewAnimationOptionTransitionFlipFromBottom&lt;/span> &lt;span class="nl">animations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="nl">completion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">BOOL&lt;/span> &lt;span class="n">finished&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">finished&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">currentViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">thirdViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">currentViewController&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">oldViewController&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="layout">Layout&lt;/h1>
&lt;h2 id="autolayout--size-classes">AutoLayout &amp;amp; Size Classes&lt;/h2>
&lt;blockquote>
&lt;p>参考资料&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>[初探 iOS8 中的 Size Class][6]&lt;/li>
&lt;/ul>
&lt;p>AutoLayout 代表的是在某种尺寸下的 Constraints, 而 Size Class 代表了可以在同一个 xib 文件中支持多个尺寸下的 AutoLayout 约束。&lt;/p>
&lt;ol>
&lt;li>update constraints&lt;/li>
&lt;li>update layout&lt;/li>
&lt;li>update display&lt;/li>
&lt;/ol>
&lt;h2 id="customcontrol">CustomControl&lt;/h2>
&lt;p>关于 UIView 的 Layer，IOS 提供了三个方法：&lt;/p>
&lt;p>1、&lt;strong>layoutSubviews&lt;/strong>&lt;/p>
&lt;p>&lt;strong>在 iOS5.1 和之前的版本，此方法的缺省实现不会做任何事情 ( 实现为空 )，iOS5.1 之后 (iOS6 开始 ) 的版本，此方法的缺省实现是使用你设置在此 view 上面的 constraints(Autolayout) 去决定 subviews 的 position 和 size。UIView 的子类如果需要对其 subviews 进行更精确的布局，则可以重写此方法。只有在 autoresizing 和 constraint-based behaviors of subviews 不能提供我们想要的布局结果的时候，我们才应该重写此方法。可以在此方法中直接设置 subviews 的 frame。我们不应该直接调用此方法，而应当用下面两个方法。&lt;/strong>&lt;/p>
&lt;p>layoutSubviews 在以下几种情况下会被调用：&lt;/p>
&lt;p>1、init 初始化不会触发 layoutSubviews&lt;/p>
&lt;p>但是是用 initWithFrame 进行初始化时，当 rect 的值不为 CGRectZero 时, 也会触发&lt;/p>
&lt;p>2、addSubview 会触发 layoutSubviews&lt;/p>
&lt;p>3、设置 view 的 Frame 会触发 layoutSubviews，当然前提是 frame 的值设置前后发生了变化&lt;/p>
&lt;p>4、滚动一个 UIScrollView 会触发 layoutSubviews&lt;/p>
&lt;p>5、旋转 Screen 会触发父 UIView 上的 layoutSubviews 事件&lt;/p>
&lt;p>6、改变一个 UIView 大小的时候也会触发父 UIView 上的 layoutSubviews 事件&lt;/p>
&lt;p>2、setNeedsLayout&lt;/p>
&lt;p>此方法会将 view 当前的 layout 设置为无效的，并在下一个 upadte cycle 里去触发 layout 更新。&lt;/p>
&lt;p>3、layoutIfNeeded&lt;/p>
&lt;p>使用此方法强制立即进行 layout, 从当前 view 开始，此方法会遍历整个 view 层次 ( 包括 superviews) 请求 layout。因此，调用此方法会强制整个 view 层次布局。&lt;/p>
&lt;p>基于约束的 AutoLayer 的方法：&lt;/p>
&lt;p>1、&lt;strong>setNeedsUpdateConstraints&lt;/strong>&lt;/p>
&lt;p>当一个自定义 view 的某个属性发生改变，并且可能影响到 constraint 时，需要调用此方法去标记 constraints 需要在未来的某个点更新，系统然后调用&lt;code>updateConstraints&lt;/code>.&lt;/p>
&lt;p>2、&lt;strong>needsUpdateConstraints&lt;/strong>&lt;/p>
&lt;p>constraint-based layout system 使用此返回值去决定是否需要调用&lt;code>updateConstraints&lt;/code>作为正常布局过程的一部分。&lt;/p>
&lt;p>3、&lt;strong>updateConstraintsIfNeeded&lt;/strong>&lt;/p>
&lt;p>立即触发约束更新，自动更新布局。&lt;/p>
&lt;p>4、&lt;strong>updateConstraints&lt;/strong>&lt;/p>
&lt;p>自定义 view 应该重写此方法在其中建立 constraints. 注意：要在实现在最后调用&lt;code>[super updateConstraints]&lt;/code>&lt;/p>
&lt;h1 id="container-view-controller">Container View Controller&lt;/h1>
&lt;h2 id="navigation-controller">Navigation Controller&lt;/h2>
&lt;p>![Navigation Controller][7]&lt;/p>
&lt;blockquote>
&lt;p>参考资料&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>[ iOS 学习之 UINavigationController 详解与使用][8]&lt;/li>
&lt;/ul>
&lt;p>最左侧是根视图，当用户点击其中的 General 项时，General 视图会滑入屏幕；当用户继续点击 Auto-Lock 项时，Auto-Lock 视图将滑入屏幕。相应地，在对象管理上，导航控制器使用了导航堆栈。根视图控制器在堆栈最底层，接下来入栈的是 General 视图控制器和 Auto-Lock 视图控制器。可以调用 pushViewControllerAnimated: 方法将视图控制器推入栈顶，也可以调用 popViewControllerAnimated: 方法将视图控制器弹出堆。&lt;/p>
&lt;p>![Navigation Controller][9]&lt;/p>
&lt;p>![enter description here][10]&lt;/p>
&lt;h3 id="uibarbuttonitem">UIBarButtonItem&lt;/h3>
&lt;p>( 1)添加 UIBarButtonItem&lt;/p>
&lt;pre tabindex="0">&lt;code>UIBarButtonItem *leftButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:@selector(selectLeftAction:)];
self.navigationItem.leftBarButtonItem = leftButton;
UIBarButtonItem *rightButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:self action:@selector(selectRightAction:)];
self.navigationItem.rightBarButtonItem = rightButton;
&lt;/code>&lt;/pre>&lt;p>![常用的UIBarButton][11]&lt;/p>
&lt;p>(2 )添加响应事件&lt;/p>
&lt;p>在添加 UIBarButtonItem 的时候，可以利用 @select 指定对应的方法。&lt;/p>
&lt;pre tabindex="0">&lt;code>-(void)selectLeftAction:(id)sender
{
UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@&amp;#34;提示&amp;#34; message:@&amp;#34;你点击了导航栏左按钮&amp;#34; delegate:self cancelButtonTitle:@&amp;#34;确定&amp;#34; otherButtonTitles:nil, nil];
[alter show];
}
-(void)selectRightAction:(id)sender
{
UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@&amp;#34;提示&amp;#34; message:@&amp;#34;你点击了导航栏右按钮&amp;#34; delegate:self cancelButtonTitle:@&amp;#34;确定&amp;#34; otherButtonTitles:nil, nil];
[alter show];
}
&lt;/code>&lt;/pre>&lt;h2 id="tab-bar-controller">Tab Bar Controller&lt;/h2>
&lt;p>![Tab Bar Controller][12]&lt;/p>
&lt;h2 id="custom-controller">Custom Controller&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>添加 View&lt;/p>
&lt;p>```&lt;/p>
&lt;/li>
&lt;li>
&lt;p>(void) displayContentController: (UIViewController*) content;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>{&lt;/p>
&lt;p>[self addChildViewController:content]; // 1&lt;/p>
&lt;p>content.view.frame = [self frameForContentController]; // 2&lt;/p>
&lt;p>[self.view addSubview:self.currentClientView];&lt;/p>
&lt;p>[content didMoveToParentViewController:self]; // 3&lt;/p>
&lt;p>}&lt;/p>
&lt;pre tabindex="0">&lt;code>- 删除View
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>(void) hideContentController: (UIViewController*) content&lt;/li>
&lt;/ul>
&lt;p>{&lt;/p>
&lt;p>[content willMoveToParentViewController:nil]; // 1&lt;/p>
&lt;p>[content.view removeFromSuperview]; // 2&lt;/p>
&lt;p>[content removeFromParentViewController]; // 3&lt;/p>
&lt;p>}&lt;/p>
&lt;pre tabindex="0">&lt;code>- 页面切换
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>(void) cycleFromViewController: (UIViewController*) oldC&lt;/p>
&lt;pre tabindex="0">&lt;code> toViewController: (UIViewController*) newC
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>{&lt;/p>
&lt;pre tabindex="0">&lt;code>[oldC willMoveToParentViewController:nil]; // 1
[self addChildViewController:newC];
newC.view.frame = [self newViewStartFrame]; // 2
CGRect endFrame = [self oldViewEndFrame];
[self transitionFromViewController: oldC toViewController: newC // 3
duration: 0.25 options:0
animations:^{
newC.view.frame = oldC.view.frame; // 4
oldC.view.frame = endFrame;
}
completion:^(BOOL finished) {
[oldC removeFromParentViewController]; // 5
[newC didMoveToParentViewController:self];
}];
&lt;/code>&lt;/pre>&lt;p>}&lt;/p>
&lt;pre tabindex="0">&lt;code># Theme
## MaterialDesign
### [CosmicMind - Material For Swift](https://github.com/CosmicMind/Material)
![MaterialSideNavigationViewController](https://camo.githubusercontent.com/e59bda52e7855a55268011a05b8a181b5d23d83b/687474703a2f2f7777772e636f736d69636d696e642e696f2f4d4b2f4d6174657269616c536964654e617669676174696f6e56696577436f6e74726f6c6c65722e676966)
[1]: http://img.blog.csdn.net/20150701233641345?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2F1Y2h5d2VpZXJzdHJhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
[2]: http://img.blog.csdn.net/20150701234834234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2F1Y2h5d2VpZXJzdHJhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
[3]: http://www.ziqiangxuetang.com/ios/ios-action-outlet.html
[4]: http://img.blog.csdn.net/20150701234853010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2F1Y2h5d2VpZXJzdHJhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
[5]: http://i.stack.imgur.com/fzu7d.jpg
[6]: http://blog.csdn.net/yongyinmg/article/details/39315829
[7]: https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/Art/nav_object_diagram_2x.png
[8]: http://blog.csdn.net/totogo2010/article/details/7681879
[9]: http://my.csdn.net/uploads/201206/21/1340245120_7325.png
[10]: http://my.csdn.net/uploads/201206/21/1340243604_5347.png
[11]: http://my.csdn.net/uploads/201206/21/1340247778_6942.png
[12]: https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/Art/tab_bar_diagram_2x.png
&lt;/code>&lt;/pre></description></item><item><title>事件与手势</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%89%8B%E5%8A%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/ios/%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%89%8B%E5%8A%BF/</guid><description>&lt;hr>
&lt;h2 id="tags-cocoaviewcontrollergesture">title: iOS-Gesture&amp;amp;Event
tags: Cocoa,ViewController,Gesture&lt;/h2>
&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>触摸(Cocoa Touch)就是用户的手指放在屏幕上，系统和硬件联合工作，会知道何时触摸屏幕以及触摸屏幕的未知。触摸事件是在 UIView 上进行的，而不是一个 UIResponder 对象。触摸本身是一个 UITouch 对象，每一个手指即会对应一个 UITouch 对象，多个 UITouch 对象包含在一个 UIEvent 中。系统会将 UIEvent 发送到应用程序中，最后应用程序将 UIEvent 传递给当前一个 UIView。&lt;/p>
&lt;blockquote>
&lt;p>参考资料&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://ryantang.me/blog/2013/12/07/ios-event-dispatch-1/" target="_blank" rel="noopener">iOS 事件机制&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="ios-事件分类">iOS 事件分类&lt;/h2>
&lt;p>对于 IOS 设备用户来说，他们操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：&lt;/p>
&lt;p>1、触屏事件(Touch Event)：单点、多点触控以及各种手势操作&lt;/p>
&lt;p>2、运动事件(Motion Event)：重力、加速度传感器等&lt;/p>
&lt;p>3、远端控制事件(Remote-Control Event)：远程遥控 iOS 设备多媒体播放等&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://ryantang.me/images/2013/12/ios_event_dispatch/1.png" alt="iOS事件图例" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="事件封装与响应">事件封装与响应&lt;/h1>
&lt;h2 id="uicontrol-控件事件分类">UIControl 控件事件分类&lt;/h2>
&lt;blockquote>
&lt;p>参考资料&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://blog.csdn.net/g5dsk/article/details/6613943" target="_blank" rel="noopener">iOS UIControl 几个事件的说明&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在控件事件中，简单解释下下面几个事件。&lt;/p>
&lt;p>说明：由于是在“iOS 模拟器”中测试的，所以不能用手指，只能用鼠标。&lt;/p>
&lt;p>1)UIControlEventTouchDown&lt;/p>
&lt;p>指鼠标左键按下(注：只是“按下”)的动作&lt;/p>
&lt;p>2)UIControlEventTouchDownRepeat&lt;/p>
&lt;p>指鼠标左键连续多次重复按下(注：只是“按下”)的动作，比如，鼠标连续双击、三击、……、多次连击。&lt;/p>
&lt;p>说明：多次重复按下时，事件序列是这样的：&lt;/p>
&lt;p>UIControlEventTouchDown -&amp;gt;&lt;/p>
&lt;p>(UIControlEventTouchUpInside) -&amp;gt;&lt;/p>
&lt;p>UIControlEventTouchDown -&amp;gt;&lt;/p>
&lt;p>UIControlEventTouchDownRepeat -&amp;gt;&lt;/p>
&lt;p>(UIControlEventTouchUpInside) -&amp;gt;&lt;/p>
&lt;p>UIControlEventTouchDown -&amp;gt;&lt;/p>
&lt;p>UIControlEventTouchDownRepeat -&amp;gt;&lt;/p>
&lt;p>(UIControlEventTouchUpInside) -&amp;gt;&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>除了第一次按下外，后面每次摁下都是一个 UIControlEventTouchDown 事件，然后紧跟一个 UIControlEventTouchDownRepeat 事件。&lt;/p>
&lt;p>3)UIControlEventTouchDragInside&lt;/p>
&lt;p>指按下鼠标，然后在控件边界范围内拖动。&lt;/p>
&lt;p>4)UIControlEventTouchDragOutside&lt;/p>
&lt;p>与 UIControlEventTouchDragInside 不同的是，拖动时，鼠标位于控件边界范围之外。但首先得有个 UIControlEventTouchDown 事件，然后接一个 UIControlEventTouchDragInside 事件，再接一个 UIControlEventTouchDragExit 事件，这时，鼠标已经位于控件外了，继续拖动就是 UIControlEventTouchDragOutside 事件了。&lt;/p>
&lt;p>具体操作是：在控件里面按下鼠标，然后拖动到控件之外。&lt;/p>
&lt;p>5)UIControlEventTouchDragEnter&lt;/p>
&lt;p>指拖动动作中，从控件边界外到内时产生的事件。&lt;/p>
&lt;p>6)UIControlEventTouchDragExit&lt;/p>
&lt;p>指拖动动作中，从控件边界内到外时产生的事件。&lt;/p>
&lt;p>7)UIControlEventTouchUpInside&lt;/p>
&lt;p>指鼠标在控件范围内抬起，前提先得按下，即 UIControlEventTouchDown 或 UIControlEventTouchDownRepeat 事件。&lt;/p>
&lt;p>8)UIControlEventTouchUpOutside&lt;/p>
&lt;p>指鼠标在控件边界范围外抬起，前提先得按下，然后拖动到控件外，即 UIControlEventTouchDown -&amp;gt; UIControlEventTouchDragInside(n 个) -&amp;gt; UIControlEventTouchDragExit -&amp;gt; UIControlEventTouchDragOutside(n 个) 时间序列，再然后就是抬起鼠标，产生 UIControlEventTouchUpOutside 事件。&lt;/p>
&lt;h3 id="自动关联">自动关联&lt;/h3>
&lt;p>可以通过 Xib 里面的关联口 IBAction 实现。&lt;/p>
&lt;h3 id="手动关联">手动关联&lt;/h3>
&lt;pre tabindex="0">&lt;code>[button addTarget:self action:@selector(navigatePics:) forControlEvents:UIControlEventTouchUpInside];
&lt;/code>&lt;/pre>&lt;h2 id="手势关联">手势关联&lt;/h2>
&lt;p>每一个特定的手势必须关联到 view 对象中才会有作用，一个 view 对象可以关联多个不同的特定手势，但是每一个特定的手势只能与一个 view 相关联。当用户触摸了 view，这个 GestureRecognizer 就会接受到消息，它可以响应特定的触摸事件。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://images.cnitblog.com/blog/133128/201304/30154250-3cc837e5df9b44f59d504c57eee6b8aa.png" alt="enter description here" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://images.cnitblog.com/blog/133128/201304/30154335-9b65e3e1d4024132beba1a3c8360c4b5.png" alt="enter description here" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通俗来说，关联手势与响应分为以下三步:&lt;/p>
&lt;ul>
&lt;li>创建 GestureRecognizer 实例&lt;/li>
&lt;li>addGestureRecognizer&lt;/li>
&lt;li>实现处理手势的方法&lt;/li>
&lt;/ul>
&lt;h3 id="uipangesturerecognizer">UIPanGestureRecognizer&lt;/h3>
&lt;pre tabindex="0">&lt;code>_panGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlerPanGesture:)];
_panGestureRecognizer.delegate = self;
_panGestureRecognizer.maximumNumberOfTouches = 2;
_panGestureRecognizer.minimumNumberOfTouches = 2;
[self.view addGestureRecognizer:_panGestureRecognizer];
- (void)handlerPanGesture:(UIPanGestureRecognizer *)recognizer
{
if ((recognizer.state == UIGestureRecognizerStateBegan) ||
(recognizer.state == UIGestureRecognizerStateChanged))
{
CGPoint offset = [recognizer translationInView:self.view];
CGRect frame = self.rightViewController.view.frame;
frame.origin.x += offset.x;
if (frame.origin.x &amp;gt;= 0 &amp;amp;&amp;amp; frame.origin.x &amp;lt;= kScreenWidth)
{
self.rightViewController.view.frame = frame;
}
[recognizer setTranslation:CGPointZero inView:self.view];
}
else if (recognizer.state == UIGestureRecognizerStateEnded)
{
BOOL isVisible = self.rightViewController.view.frame.origin.x &amp;lt; kScreenWidth / 2;
[self showRightView:isVisible];
}
}
&lt;/code>&lt;/pre>&lt;h1 id="事件分发event-delivery">事件分发(Event Delivery)&lt;/h1>
&lt;p>第一响应者(First responder)指的是当前接受触摸的响应者对象(通常是一个 UIView 对象)，即表示当前该对象正在与用户交互，它是响应者链的开端。整个响应者链和事件分发的使命都是找出第一响应者。&lt;/p>
&lt;p>UIWindow 对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件(通过消息)传递给响应者链中的下一个响应者，看看它是否可以进行处理。&lt;/p>
&lt;p>iOS 系统检测到手指触摸(Touch)操作时会将其打包成一个 UIEvent 对象，并放入当前活动 Application 的事件队列，单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的 UIWindow 来处理，UIWindow 对象首先会使用 hitTest:withEvent:方法寻找此次 Touch 操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为 hit-test view。&lt;/p>
&lt;h1 id="复杂手势控制complex-gesture-event">复杂手势控制(Complex Gesture Event)&lt;/h1>
&lt;p>在 iOS 中一个事件用一个 UIEvent 对象表示，UITouch 用来表示一次对屏幕的操作动作，由多个 UITouch 对象构成了一个 UIEvent 对象。另外，UIResponder 是所有响应者的父类，UIView、UIViewController、UIWindow、UIApplication 都直接或间接的集成了 UIResponder。&lt;/p>
&lt;h2 id="gesture-recognizers手势识别器">Gesture Recognizers(手势识别器)&lt;/h2>
&lt;p>Gesture Recognizers 是一类手势识别器对象，它可以附属在你指定的 View 上，并且为其设定指定的手势操作，例如是点击、滑动或者是拖拽。当触控事件 发生时，设置了 Gesture Recognizers 的 View 会先通过识别器去拦截触控事件，如果该触控事件是事先为 View 设定的触控监听事件，那么 Gesture Recognizers 将会发送动作消息给目标处理对象，目标处理对象则对这次触控事件进行处理，先看看如下流程图。&lt;/p>
&lt;p>&lt;a href="http://ryantang.me/images/2013/12/ios_event_dispatch/2.png" target="_blank" rel="noopener">Action 传递模型&lt;/a>&lt;/p>
&lt;p>在 iOS 中，View 就是我们在屏幕上看到的各种 UI 控件，当一个触控事件发生时，Gesture Recognizers 会先获取到指定的事件，然后发送动作消息(action message)给目标对象(target)，目标对象就是 ViewController，在 ViewController 中通过事件方法完成对该事件的处理。Gesture Recognizers 能设置诸如单击、滑动、拖拽等事件，通过 Action-Target 这种设计模式，好处是能动态为 View 添加各种事件监听，而不用去实现一个 View 的子类去完成这些功能。&lt;/p>
&lt;p>以上过程就是我们在开发中在方法中常见的设置 action 和设置 target，例如为 UIButton 设置监听事件等。&lt;/p>
&lt;h3 id="常用手势识别类">常用手势识别类&lt;/h3>
&lt;p>在 UIKit 框架中，系统为我们事先定义好了一些常用的手势识别器，包括点击、双指缩放、拖拽、滑动、旋转以及长按。通过这些手势识别器我们可以构造丰富的操作方式。&lt;/p>
&lt;p>&lt;a href="http://ryantang.me/images/2013/12/ios_event_dispatch/3.png" target="_blank" rel="noopener">手势识别类列表&lt;/a>&lt;/p>
&lt;p>在上表中可以看到，UIKit 框架中已经提供了诸如 UITapGestureRecognizer 在内的六种手势识别器，如果你需要实现自定义的手势识别器，也可以通过继承 UIGestureRecognizer 类并重写其中的方法来完成，这里我们就不详细讨论了。&lt;/p>
&lt;p>每一个 Gesture Recognizer 关联一个 View，但是一个 View 可以关联多个 Gesture Recognizer，因为一个 View 可能还能响应多种触控操作方式。当一个触控事件发生时，Gesture Recognizer 接收一个动作消息要先于 View 本身，结果就是 Gesture Recognizer 作为 View 处理触控事件的代表，或者叫代理。当 Gesture Recognizer 接收到指定的事件时，它就会发送一条动作消息(action message)给 ViewController 并处理。&lt;/p>
&lt;h3 id="连续和不连续动作">连续和不连续动作&lt;/h3>
&lt;p>&lt;a href="http://ryantang.me/images/2013/12/ios_event_dispatch/4.png" target="_blank" rel="noopener">连续与不连续动作&lt;/a>&lt;/p>
&lt;p>触控动作同时分为连续动作(continuous)和不连续动作(discrete)，连续动作例如滑动和拖拽，它会持续一小段时间，而不连续动作例如单击，它瞬间就会完成，在这两类事件的处理上又稍有不同。对于不连续动作，Gesture Recognizer 只会给 ViewContoller 发送一个单一的动作消息(action message),而对于连续动作，Gesture Recognizer 会发送多条动作消息给 ViewController，直到所有的事件都结束。&lt;/p>
&lt;p>为一个 View 添加 GestureRecognizer 有两种方式，一种是通过 InterfaceBuilder 实现，另一种就是通过代码实现，我们看看通过代码来如何实现。&lt;/p>
&lt;h2 id="drag拖拽">Drag(拖拽)&lt;/h2>
&lt;h2 id="zoom缩放">Zoom(缩放)&lt;/h2></description></item></channel></rss>