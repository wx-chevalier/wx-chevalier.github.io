<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>系统功能 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/android/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD/</link><atom:link href="https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/android/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD/index.xml" rel="self" type="application/rss+xml"/><description>系统功能</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>系统功能</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/android/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD/</link></image><item><title>高性能 OkHttp</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/android/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD/%E9%AB%98%E6%80%A7%E8%83%BD-okhttp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/android/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD/%E9%AB%98%E6%80%A7%E8%83%BD-okhttp/</guid><description>&lt;h1 id="高性能的-okhttp">高性能的 OkHttp&lt;/h1>
&lt;p>&lt;a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp&lt;/a> 是笔者在为为 &lt;a href="https://www.khanacademy.org/" target="_blank" rel="noopener">Khan Academy&lt;/a>开发这个 &lt;a href="https://play.google.com/store/apps/details?id=org.khanacademy.android" target="_blank" rel="noopener">Android app&lt;/a>时候的必用库之一。OkHttp 库本身已经提供了非常优秀的功能配置，但是下面是我们在实践中总结出来的一些能够有效增加资源利用率的步骤：&lt;/p>
&lt;h1 id="使用文件系统级别的响应缓存">使用文件系统级别的响应缓存&lt;/h1>
&lt;p>默认情况下，OkHttp 并没有将包含&lt;code>Cache-Control&lt;/code>头部文件的响应进行缓存。因此你的客户端可能会浪费时间与带宽去重复请求相同的资源，而不是简单地读取初次请求时候的缓存副本。为了保证基于文件系统的响应缓存，应该配置一个&lt;code>com.squareup.okhttp.Cache&lt;/code>实例并且把它传递给&lt;code>OkHttpClient&lt;/code>的&lt;code>setCache&lt;/code>方法。在初始化该&lt;code>Cache&lt;/code>时，需要指定一个&lt;code>File&lt;/code>对象来指代文件目录以及最大的缓存容量。响应会被缓存写入指定的文件夹，如果缓存大小已经超过了文件夹的指定大小，会根据 LRU 规则来进行筛选。下面是笔者的具体实践：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Base directory recommended by http://stackoverflow.com/a/32752861/400717.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Guard against null, which is possible according to
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// https://groups.google.com/d/msg/android-developers/-694j87eXVU/YYs4b6kextwJ and
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// http://stackoverflow.com/q/4441849/400717.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">final&lt;/span> &lt;span class="nd">@Nullable&lt;/span> &lt;span class="n">File&lt;/span> &lt;span class="n">baseDir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getCacheDir&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">baseDir&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">final&lt;/span> &lt;span class="n">File&lt;/span> &lt;span class="n">cacheDir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">File&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">baseDir&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;HttpResponseCache&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">okHttpClient&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Cache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cacheDir&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">HTTP_RESPONSE_DISK_CACHE_MAX_SIZE&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，我们建议的&lt;code>HTTP_RESPONSE_DISK_CACHE_MAX_SIZE&lt;/code> 值为&lt;code>10 * 1024 * 1024&lt;/code>, 或者 10 MB。&lt;/p>
&lt;h1 id="使用-stetho">使用 Stetho&lt;/h1>
&lt;p>&lt;a href="http://facebook.github.io/stetho/" target="_blank" rel="noopener">Stetho&lt;/a> 是来自于 Facebook 的一个很有用的辅助库，能够允许开发者使用 &lt;a href="https://developers.google.com/web/tools/setup/workspace/setup-devtools" target="_blank" rel="noopener">Chrome Developer Tools&lt;/a> 来监测 Android 应用。除了能够允许开发者监测 SQLite 数据库以及视图层级之外，Stetho 还能辅助监测所有的来自 OkHttp 的网络请求与响应。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://omgitsmgp.com/assets/images/posts/stetho-inspector-network.png" alt="Image of Stetho" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这样的自检方法能够保证服务器返回恰当的带有缓存控制的响应，同时还能监测当缓存资源存在时是否确定没有请求被发出。如果要使用 Stetho，只需要简单地来添加一个&lt;code>StethoInterceptor&lt;/code>实例到网络拦截器中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">okHttpClient&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">networkInterceptors&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">StethoInterceptor&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，在应用运行之后，打开 Chrome 并且跳转到&lt;code>chrome://inspect&lt;/code>界面，既可以看到上述画面。&lt;/p>
&lt;h1 id="与-picasso-以及-retrofit-混合使用">与 Picasso 以及 Retrofit 混合使用&lt;/h1>
&lt;p>笔者是直接使用了 Picasso 进行网络图片的加载，以及使用 Retrofit 来简化请求构造以及响应解码。默认情况下，这两个库是使用了 OkHttpClient 进行底层的网络交互。以 Picasso 的 2.5.2 版本的&lt;code>OkHttpDownloader&lt;/code>为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">OkHttpClient&lt;/span> &lt;span class="nf">defaultOkHttpClient&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">OkHttpClient&lt;/span> &lt;span class="n">client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">OkHttpClient&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setConnectTimeout&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Utils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">DEFAULT_CONNECT_TIMEOUT_MILLIS&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setReadTimeout&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Utils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">DEFAULT_READ_TIMEOUT_MILLIS&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setWriteTimeout&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Utils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">DEFAULT_WRITE_TIMEOUT_MILLIS&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MILLISECONDS&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">client&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Retrofit 有一个很类似的工厂方法。在应用中，图片往往是常用的大型资源之一，Picasso 本身维护了一个基于 LRU 规则的缓存系统，是直接在内存中的缓存。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">final&lt;/span> &lt;span class="n">Picasso&lt;/span> &lt;span class="n">picasso&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Picasso&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Builder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">downloader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">OkHttpDownloader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">okHttpClient&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// The client should inject this instance whenever it is needed, but replace the singleton
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// instance just in case.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Picasso&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setSingletonInstance&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">picasso&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="定制一个-user-agent-拦截器">定制一个 User Agent 拦截器&lt;/h1>
&lt;p>对于由客户端提供的包含在 User-Agent 头文件中的详细的本机信息是往往用来日志记录与分析的重要来源。默认情况下，OkHttp 中自带的 User-Agent 属性会说明 OkHttp 的版本。如果需要定制自己的 User-Agent 信息，可以通过创建一个拦截器并且替换以下这些值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">UserAgentInterceptor&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Interceptor&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">USER_AGENT_HEADER_NAME&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;User-Agent&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">userAgentHeaderValue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">UserAgentInterceptor&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">userAgentHeaderValue&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">userAgentHeaderValue&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Preconditions&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">checkNotNull&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">userAgentHeaderValue&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="nf">intercept&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Chain&lt;/span> &lt;span class="n">chain&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">final&lt;/span> &lt;span class="n">Request&lt;/span> &lt;span class="n">originalRequest&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">chain&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">request&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">final&lt;/span> &lt;span class="n">Request&lt;/span> &lt;span class="n">requestWithUserAgent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">originalRequest&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">newBuilder&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">removeHeader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">USER_AGENT_HEADER_NAME&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">addHeader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">USER_AGENT_HEADER_NAME&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">userAgentHeaderValue&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">chain&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">proceed&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">requestWithUserAgent&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在构造传入拦截器的具体的 User-Agent 的值时，我们使用了如下信息：&lt;/p>
&lt;ul>
&lt;li>Android 的版本信息&lt;/li>
&lt;li>&lt;code>Build.MODEL&lt;/code>, 或者用户可见的终端产品名&lt;/li>
&lt;li>&lt;code>Build.BRAND&lt;/code>&lt;/li>
&lt;li>&lt;code>Build.VERSION.SDK_INT&lt;/code>&lt;/li>
&lt;li>&lt;code>BuildConfig.APPLICATION_ID&lt;/code>&lt;/li>
&lt;li>&lt;code>BuildConfig.VERSION_NAME&lt;/code>&lt;/li>
&lt;li>&lt;code>BuildConfig.VERSION_CODE&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>最后三个值是 Gradle 文件中包含的版本信息。如果你是使用的 WebView，则可以直接在 WebView 中进行构造：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">WebSettings&lt;/span> &lt;span class="n">settings&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">webView&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getSettings&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">settings&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setUserAgentString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">userAgentHeaderValue&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="明确合理的超时时间">明确合理的超时时间&lt;/h1>
&lt;p>Picasso specifies:&lt;/p>
&lt;ul>
&lt;li>A connect timeout of 15 seconds.&lt;/li>
&lt;li>A read timeout of 20 seconds.&lt;/li>
&lt;li>A write timeout of 20 seconds.&lt;/li>
&lt;/ul>
&lt;p>Whereas Retrofit specifies:&lt;/p>
&lt;ul>
&lt;li>A connect timeout of 15 seconds.&lt;/li>
&lt;li>A read timeout of 20 seconds.&lt;/li>
&lt;li>No write timeout.&lt;/li>
&lt;/ul></description></item><item><title>网络请求</title><link>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/android/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/frontend-series/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/android/%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>笔者没有把 OkHttp 归纳到 Android 体系内，还是放置到了 Java 体系内。Retrofit 本身就是对于 OkHttp 的封装。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://packetzoom.com/blog/images/httplibs.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="comparison-比较-">Comparison( 比较 )&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://stackoverflow.com/questions/16902716/comparison-of-android-networking-libraries-okhttp-retrofit-volley#" target="_blank" rel="noopener">comparison-of-android-networking-libraries-okhttp-retrofit-volley&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>目前基本上每个应用都会使用 HTTP/HTTPS 协议来作为主要的传输协议来传输数据。即使你没有直接使用 HTTP 协议，也会有成堆的 SDK 会包含这些协议，譬如分析、Crash 反馈等等。当然，目前也有很多优秀的 HTTP 的协议库，可以很方便的帮助开发者构建应用，本篇博文中会尽可能地涵盖这些要点。Android 的开发者在选择一个合适的 HTTP 库时需要考虑很多的要点，譬如在使用 Apache Client 或者 HttpURLConnection 时可能会考虑：&lt;/p>
&lt;ul>
&lt;li>能够取消现有的网络请求&lt;/li>
&lt;li>能够并发请求&lt;/li>
&lt;li>连接池能够复用存在的 Socket 连接&lt;/li>
&lt;li>本地对于响应的缓存&lt;/li>
&lt;li>简单的异步接口来避免主线程阻塞&lt;/li>
&lt;li>对于 REST API 的封装&lt;/li>
&lt;li>重连策略&lt;/li>
&lt;li>能够有效地载入与传输图片&lt;/li>
&lt;li>支持对于 JSON 的序列化&lt;/li>
&lt;li>支持 SPDY、HTTP/2 最早的时候 Android 只有两个主要的 HTTP 客户端: &lt;a href="http://developer.android.com/reference/java/net/HttpURLConnection.html" target="_blank" rel="noopener">HttpURLConnection&lt;/a>, &lt;a href="https://developer.android.com/sdk/api_diff/22/changes/android.net.http.AndroidHttpClient.html" target="_blank" rel="noopener">Apache HTTP Client&lt;/a>。根据 Google 官方博客的内容，HttpURLConnection 在早期的 Android 版本中可能存在一些 Bug:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>在 Froyo 版本之前，HttpURLConnection 包含了一些很恶心的错误。特别是对于关闭可读的 InputStream 时候可能会污染整个连接池。&lt;/p>
&lt;/blockquote>
&lt;p>同样，Google 官方并不想转到 Apache HTTP Client 中：&lt;/p>
&lt;blockquote>
&lt;p>Apache HTTP Client 中复杂的 API 设计让人们根本不想用它，Android 团队并不能够有效地工作。&lt;/p>
&lt;/blockquote>
&lt;p>而对于大部分普通开发者而言，它们觉得应该根据不同的版本使用不同的客户端。对于 Gingerbread(2.3) 以及之后的版本，HttpURLConnection 会是最佳的选择，它的 API 更简单并且体积更小。透明压缩与数据缓存可以减少网络压力，提升速度并且能够节约电量。当我们审视 Google Volley 的源代码的时候，可以看得出来它也是根据不同的 Android 版本选择了不同的底层的网络请求库：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Build&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">VERSION&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SDK_INT&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HurlStack&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Prior to Gingerbread, HttpUrlConnection was unreliable.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HttpClientStack&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">AndroidHttpClient&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">newInstance&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">userAgent&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过这样会很让开发者头疼，2013 年，Square 为了解决这种分裂的问题发布了 OkHttp。OkHttp 是直接架构与 Java Socket 本身而没有依赖于其他第三方库，因此开发者可以直接用在 JVM 中，而不仅仅是 Android。为了简化代码迁移速度，OkHttp 也实现了类似于 HttpUrlConnection 与 Apache Client 的接口。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://packetzoom.com/blog/images/okhttp.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>OkHttp 获得了巨大的社区的支持，以至于 Google 最终是将它作为了 Android 4.4 默认的 Engine，并且会在 5.1 之后弃用 Apache Client。目前 OkHttp V2.5.0 支持如下特性：&lt;/p>
&lt;ul>
&lt;li>HTTP/2 以及 SPDY 的支持多路复用&lt;/li>
&lt;li>连接池会降低并发连接数&lt;/li>
&lt;li>透明 GZIP 加密减少下载体积&lt;/li>
&lt;li>响应缓存避免大量重复请求&lt;/li>
&lt;li>同时支持同步的阻塞式调用与异步回调式调用&lt;/li>
&lt;/ul>
&lt;p>笔者关于 OkHttp 最喜欢的一点是它能够将异步请求较好的展示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">OkHttpClient&lt;/span> &lt;span class="n">client&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">OkHttpClient&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">Exception&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Request&lt;/span> &lt;span class="n">request&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Builder&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">url&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;http://publicobject.com/helloworld.txt&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">newCall&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">enqueue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Callback&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">onFailure&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Request&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Throwable&lt;/span> &lt;span class="n">throwable&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">throwable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">onResponse&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Response&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isSuccessful&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">IOException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Unexpected code &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">body&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">string&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个用起来非常方便，因为往往大的数据请求都不能放置在 UI 主线程中进行。事实上，从 Android 3.0(Honeycomb 11) 开始，所有的网络操作都必须强制在单独的线程中进行。在当时如果要把 HttpUrlConnection 和 AsyncTask 结合起来使用，还是比较复杂的。而 2013 年的 Google IO 大会上，Google 提出了 Volley，一个提供了如下便利的 HTTP 库：&lt;/p>
&lt;ul>
&lt;li>Automatic scheduling of network requests.&lt;/li>
&lt;li>Multiple concurrent network connections.&lt;/li>
&lt;li>Transparent disk and memory response caching with standard HTTP cache coherence.&lt;/li>
&lt;li>Support for request prioritization.&lt;/li>
&lt;li>Cancellation request API. You can cancel a single request, or you can set blocks or scopes of requests to cancel.&lt;/li>
&lt;li>Ease of customization, for example, for retry and backoff.&lt;/li>
&lt;li>Strong ordering that makes it easy to correctly populate your UI with data fetched asynchronously from the network.&lt;/li>
&lt;li>Debugging and tracing tools.&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://packetzoom.com/blog/images/volley_arch.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Volley 主要架构在 HttpUrlConnection 之上，如果希望能够抓取图片或者 JSON 数据，Volley 有自定义的抽象类型 ImageRequest 与 JsonObjectRequest，可以自动转化为 HTTP 请求。同时，Volley 也有一个硬编码的网络连接池大小：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">DEFAULT_NETWORK_THREAD_POOL_SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过 OkHttp 可以自定义连接池的大小：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxRequests&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">64&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxRequestsPerHost&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">executorService&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadPoolExecutor&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MAX_VALUE&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">60&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="o">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">new&lt;/span> &lt;span class="n">LinkedBlockingQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Runnable&lt;/span>&lt;span class="o">&amp;gt;(),&lt;/span> &lt;span class="n">Util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">threadFactory&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;OkHttp Dispatcher&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在某些情况下，OkHttp 可以通过使用多线程来有更好的性能体现。不过如果现有的程序中已经用 Volley 做了顶层封装，那么也可以使用&lt;a href="https://gist.github.com/bryanstern/4e8f1cb5a8e14c202750" target="_blank" rel="noopener">HttpStack implementation&lt;/a>这个来使用 OkHttp 的请求与响应接口来替换 HttpUrlConnection。&lt;/p>
&lt;p>到这里已经可以发现，OkHttp 本质上是自定义了一套底层的网络请求架构。目前 HTTP 客户端已经逐步转化为了支持大量图片，特别是那种无限滚动与图片传输的应用。同时，REST API 已经成为了业界标准，基本上每位开发者都需要处理大量标准化的任务，类似于 JSON 序列化与将 REST 请求映射到 Java 的接口上。Square 也在不久之后针对这两个问题提出了自己的解决方案：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit&lt;/a> - &lt;strong>一个类型安全的 HTTP 客户端支持 REST 接口&lt;/strong>&lt;/li>
&lt;li>&lt;a href="http://square.github.io/picasso/" target="_blank" rel="noopener">Picasso&lt;/a> - &lt;strong>针对 Android 的图片下载与缓存库&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Retrofit 提供了一个面向 Java 代码与 REST 接口之间的桥接，可以迅速将 HTTP API 转化到 Java 接口中并且自动生成带有完整文档的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">GitHubService&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@GET&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/users/{user}/repos&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Call&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Repo&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="nf">listRepos&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@Path&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;user&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Retrofit&lt;/span> &lt;span class="n">retrofit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Retrofit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Builder&lt;/span>&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">baseUrl&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;https://api.github.com&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">GitHubService&lt;/span> &lt;span class="n">service&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">retrofit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">create&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">GitHubService&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外，Retrofit 也支持面向 JSON、XML 以及 Protocol Buffers 的数据转化。在&lt;a href="http://instructure.github.io/blog/2013/12/09/volley-vs-retrofit/" target="_blank" rel="noopener">另一篇博客&lt;/a>中将 AsyncTask 与 Volley 以及 Retrofit 做了一个比较，其性能对比如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://i.imgur.com/tIdZkl3.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item></channel></rss>