<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>05.KISS | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/</link>
      <atom:link href="https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/index.xml" rel="self" type="application/rss+xml" />
    <description>05.KISS</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>05.KISS</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/</link>
    </image>
    
    <item>
      <title>避免提早优化</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E9%81%BF%E5%85%8D%E6%8F%90%E6%97%A9%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E9%81%BF%E5%85%8D%E6%8F%90%E6%97%A9%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h1 id=&#34;避免提早优化&#34;&gt;避免提早优化&lt;/h1&gt;
&lt;p&gt;Donald Knuth 1974 年在 ACM Journal 上发表的文章《Structured Programming with go to Statements》中写道：Premature optimizationComplexity is the root of all evil or: How I Learned to Stop Worrying and Love the Monolith。其意就是在没有量化的性能测试检测出真正存在的性能问题前，各种在代码层面的“炫技式”优化，可能不仅提升不了性能，反而会导致更多 bug。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s1.ax1x.com/2020/03/16/8JFiGQ.png&#34; alt=&#34;重构的危害&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;复杂性是万恶之源，总结而言，我们在注重整体架构与性能的同时，要避免过早地优化、避免过度优化。&lt;/p&gt;
&lt;h1 id=&#34;如何考虑性能&#34;&gt;如何考虑性能&lt;/h1&gt;
&lt;p&gt;要解决的第一个问题是“您在正常的开发过程中应该为性能多少担心？” 如果您尝试优化每条语句以获得最大速度，则它将减慢开发速度并产生许多不必要的复杂性。此外，许多“优化”实际上对性能没有帮助。另一方面，如果您完全忽略了性能问题，则很容易导致遍及整个代码的大量效率低下。结果系统很容易比所需的速度慢 5–10 倍。在这种“千刀砍死”的情况下，以后很难再回来提高性能了，因为没有单一的改进会产生很大的影响。&lt;/p&gt;
&lt;p&gt;最好的方法是介于这两种极端之间，在这种极端情况下，您可以使用性能的基本知识来选择“自然高效”但又干净又简单的设计替代方案。关键是要了解哪些操作根本是昂贵的。以下是一些今天相对昂贵的操作示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络通信：即使在数据中心内，往返消息交换也可能花费 10–50 µs，这是数以万计的指令时间。广域往返可能需要 10 到 100 毫秒。&lt;/li&gt;
&lt;li&gt;I/O 到辅助存储：磁盘 I/O 操作通常需要 5 到 10 毫秒，这是数百万条指令时间。闪存存储需要 10–100 µs。新出现的非易失性存储器的速度可能高达 1 µs，但这仍约为 2000 条指令时间。&lt;/li&gt;
&lt;li&gt;动态内存分配（C 语言中的 malloc，C ++或 Java 中的新增功能）通常涉及分配，释放和垃圾回收的大量开销。&lt;/li&gt;
&lt;li&gt;高速缓存未命中：将数据从 DRAM 提取到片上处理器高速缓存中需要数百条指令时间；在许多程序中，整体性能取决于缓存未命中和计算成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解哪些东西最昂贵的最好方法是运行微基准测试（小型程序，这些程序单独测量单个操作的成本）。在 RAMCloud 项目中，我们创建了一个简单的程序，该程序提供了微基准测试的框架。创建该框架花了几天时间，但是该框架使在五到十分钟内添加新的微基准成为可能。这使我们积累了几十个微基准。我们既可以使用它们来了解 RAMCloud 中使用的现有库的性能，也可以衡量为 RAMCloud 编写的新类的性能。&lt;/p&gt;
&lt;p&gt;一旦对什么是昂贵和什么便宜有了一般的认识，就可以使用该信息尽可能地选择便宜的业务。在许多情况下，更有效的方法将与较慢的方法一样简单。例如，当存储将使用键值查找的大量对象时，可以使用哈希表或有序映射。两者都通常在库包中提供，并且都简单易用。但是，哈希表可以轻松地快 5-10 倍。因此，除非需要映射提供的排序属性，否则应始终使用哈希表。&lt;/p&gt;
&lt;p&gt;作为另一个示例，请考虑使用诸如 C 或 C ++之类的语言分配结构数组。有两种方法可以执行此操作。一种方法是让数组保留指向结构的指针，在这种情况下，您必须首先为数组分配空间，然后为每个单独的结构分配空间。将结构存储在数组本身中效率要高得多，因此您只为所有内容分配一个大块。如果提高效率的唯一方法是增加复杂性，那么选择就更加困难。如果更高效的设计仅增加了少量复杂性，并且复杂性是隐藏的，因此它不影响任何接口，那么它可能是值得的（但要注意：复杂性是递增的）。如果更快的设计增加了很多实现复杂性，或者导致更复杂的接口，那么最好是从更简单的方法开始，然后在性能出现问题时进行优化。但是，如果您有明确的证据表明性能在特定情况下很重要，那么您最好立即实施更快的方法。&lt;/p&gt;
&lt;p&gt;在 RAMCloud 项目中，我们的总体目标之一是为客户端计算机通过数据中心网络访问存储系统提供尽可能低的延迟。结果，我们决定使用特殊的硬件进行联网，从而使 RAMCloud 绕过内核并直接与网络接口控制器进行通信以发送和接收数据包。即使增加了复杂性，我们还是做出了这个决定，因为我们从先前的测量中知道，基于内核的网络太慢了，无法满足我们的需求。在其余的 RAMCloud 系统中，我们能够进行简单设计。解决这个大问题“对”使其他事情变得更加容易。&lt;/p&gt;
&lt;p&gt;通常，较简单的代码往往比复杂的代码运行更快。如果您定义了特殊情况和例外，则无需代码即可检查这些情况，并且系统运行速度更快。深层类比浅层类更有效，因为它们为每个方法调用完成了更多工作。浅类会导致更多的层交叉，并且每个层交叉都会增加开销。&lt;/p&gt;
&lt;h1 id=&#34;修改前的度量&#34;&gt;修改前的度量&lt;/h1&gt;
&lt;p&gt;但是，即使您如上所述进行设计，也请假设您的系统仍然太慢。根据您对慢速运动的直觉，急于着手开始进行性能调整。不要这样！程序员对性能的直觉是不可靠的。即使对于有经验的开发人员也是如此。如果您开始根据直觉进行更改，则会浪费时间在实际上无法提高性能的事情上，并且可能会使系统变得更加复杂。&lt;/p&gt;
&lt;p&gt;进行任何更改之前，请测量系统的现有行为。这有两个目的。首先，这些测量将确定性能调整将产生最大影响的地方。仅仅测量顶级系统性能是不够的。这可能会告诉您系统速度太慢，但不会告诉您原因。您需要进行更深入的衡量，以详细确定影响整体绩效的因素；目标是确定系统当前花费大量时间的少量非常具体的地方，以及您有改进想法的地方。测量的第二个目的是提供基线，以便您可以在进行更改后重新测量性能，以确保性能得到实际改善。如果这些更改并未在效果上带来可衡量的变化，然后将其退出（除非它们使系统更简单）。除非能够显着提高速度，否则保持复杂性毫无意义。&lt;/p&gt;
&lt;h1 id=&#34;围绕关键路径进行设计&#34;&gt;围绕关键路径进行设计&lt;/h1&gt;
&lt;p&gt;在这一点上，我们假设您已经仔细分析了性能，并确定了一段缓慢的代码来影响整个系统的性能。改善其性能的最佳方法是进行“根本”更改，例如引入缓存，或使用其他算法方法（例如，平衡树与列表）。我们决定绕过内核进行 RAMCloud 中的网络通信的决定是一个基本修补程序的示例。如果您可以确定基本修复程序，则可以使用前面各章中讨论的设计技术来实施它。&lt;/p&gt;
&lt;p&gt;不幸的是，有时会出现一些根本无法解决的情况。这将我们带到本章的核心问题，即如何重新设计现有代码，使其运行更快。这应该是您的不得已的方法，并且不应该经常发生，但是在某些情况下它可能会带来很大的不同。关键思想是围绕关键路径设计代码。&lt;/p&gt;
&lt;p&gt;首先，问自己在通常情况下执行所需任务必须执行的最少代码量是多少。忽略任何现有的代码结构。相反，想象一下您正在编写一个仅实现关键路径的新方法，这是在最常见的情况下必须执行的最少代码量。当前的代码可能充满特殊情况。在此练习中，请忽略它们。当前的代码可能会在关键路径上通过多个方法调用。想象一下，您可以将所有相关代码放在一个方法中。当前代码还可以使用各种变量和数据结构。仅考虑关键路径所需的数据，并假定最适合关键路径的任何数据结构。例如，将多个变量合并为一个值可能很有意义。假设您可以完全重新设计系统，以最大程度地减少必须为关键路径执行的代码。我们将此代码称为“理想”。&lt;/p&gt;
&lt;p&gt;理想的代码可能会与您现有的类结构冲突，并且可能不切实际，但它提供了一个很好的目标：这代表了代码可能是最简单，最快的。下一步是寻找一种新设计，使其尽可能接近理想状态，同时又要保持干净的结构。您可以应用本书前面各章中的所有设计思想，但要保持（最好）保持理想代码的附加约束。您可能需要在理想情况下添加一些额外的代码，以允许使用简洁的抽象。例如，如果代码涉及哈希表查找，则可以向通用哈希表类引入额外的方法调用。以我的经验，几乎总是可以找到干净简洁的设计，但非常接近理想。&lt;/p&gt;
&lt;p&gt;在此过程中发生的最重要的事情之一是从关键路径中除去特殊情况。当代码运行缓慢时，通常是因为它必须处理各种情况，并且代码经过结构化以简化所有不同情况的处理。每个特殊情况都以额外的条件语句和/或方法调用的形式向关键路径添加了一些代码。这些添加中的每一个都会使代码变慢。重新设计性能时，请尝试减少必须检查的特殊情况的数量。理想情况下，开头应该有一个 if 语句，该语句可以通过一个测试检测所有特殊情况。在正常情况下，只需要进行一项测试，之后就可以执行关键路径，而对于特殊情况则无需进行其他测试。如果初始测试失败（这意味着发生了特殊情况），则代码可以分支到关键路径之外的单独位置以进行处理。对于特殊情况，性能并不是那么重要，因此您可以为简化而不是性能来构造特殊情况的代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>单源一致性</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E5%8D%95%E6%BA%90%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E5%8D%95%E6%BA%90%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h1 id=&#34;sso-singe-source-of-truth&#34;&gt;SSO Singe Source of Truth&lt;/h1&gt;
&lt;p&gt;一致性是降低系统复杂性并使其行为更明显的强大工具。如果系统是一致的，则意味着相似的事情以相似的方式完成，而不同的事情则以不同的方式完成。一致性会产生认知影响力：一旦您了解了某个地方的工作方式，就可以使用该知识立即了解其他使用相同方法的地方。如果系统的实施方式不一致，则开发人员必须分别了解每种情况。这将花费更多时间。&lt;/p&gt;
&lt;p&gt;一致性减少了错误。如果系统不一致，则实际上两种情况可能不同，但两种情况可能看起来相同。开发人员可能会看到一个看起来很熟悉的模式，并根据以前对该模式的遭遇做出错误的假设。另一方面，如果系统是一致的，则基于熟悉情况的假设将是安全的。一致性允许开发人员以更少的错误来更快地工作。&lt;/p&gt;
&lt;p&gt;一致性是投资心态的另一个例子。确保一致性的工作将需要一些额外的工作：确定约定，创建自动检查程序，寻找类似情况以模仿新代码，以及进行代码审查以教育团队。这项投资的回报是您的代码将更加明显。开发人员将能够更快，更准确地了解代码的行为，这将使他们能够以更少的错误来更快地工作。&lt;/p&gt;
&lt;h1 id=&#34;一致性示例&#34;&gt;一致性示例&lt;/h1&gt;
&lt;p&gt;一致性可以应用于系统中的许多级别。这里有一些例子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编码样式。如今，开发组织通常拥有样式指南，这些样式指南将程序结构限制在编译器所强制执行的规则之外。现代风格指南解决了一系列问题，例如缩进，大括号放置，声明顺序，命名，注释以及对认为危险的语言功能的限制。样式指南使代码更易于阅读，并且可以减少某些类型的错误。&lt;/li&gt;
&lt;li&gt;接口。具有多个实现的接口是一致性的另一个示例。一旦了解了接口的一种实现，其他任何实现都将变得更易于理解，因为您已经知道它将必须提供的功能。&lt;/li&gt;
&lt;li&gt;设计模式。设计模式是某些常见问题的普遍接受的解决方案，例如用于用户界面设计的模型视图控制器方法。如果您可以使用现有的设计模式来解决问题，则实现会更快地进行，更有可能起作用，并且您的代码对读者来说也会更明显。&lt;/li&gt;
&lt;li&gt;不变量。不变式是始终为真的变量或结构的属性。例如，存储文本行的数据结构可能会强制要求每行以换行符终止。不变式减少了代码中必须考虑的特殊情况的数量，并使推理行为的方式变得更加容易。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;确保一致性&#34;&gt;确保一致性&lt;/h1&gt;
&lt;p&gt;一致性很难维护，尤其是当许多人长时间从事一个项目时。一组人可能不了解另一组中建立的约定。新来者不了解规则，因此他们无意间违反了约定并创建了与现有约定冲突的新约定。以下是建立和保持一致性的一些技巧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文献。创建一个列出最重要的总体约定的文档，例如编码样式准则。将文档放置在开发人员可能会看到的位置，例如项目 Wiki 上的显眼位置。鼓励新成员加入小组阅读文档，并鼓励现有人员不时审阅该文档。Web 上已经发布了来自各个组织的一些样式指南；考虑从其中之一开始。对于局部性更强的约定，例如不变式，请在代码中找到合适的位置进行记录。如果您不写下约定，那么其他人不太可能会遵循它们。&lt;/li&gt;
&lt;li&gt;执行。即使有好的文档，开发人员也很难记住所有约定。实施约定的最佳方法是编写一个检查违规的工具，并确保除非通过检查程序，否则代码无法提交到存储库。自动检查器对于底层语法约定特别有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我最近的一个项目有行终止字符的问题。一些开发人员在 Unix 上工作，行被换行终止;其他的工作在 Windows 上，行通常由一个 carriage-return 后跟一个换行符来结束。如果一个系统上的开发人员对先前在另一个系统上编辑过的文件进行了小的编辑，那么编辑器有时会将所有行终止符替换为适合该系统的行终止符。这给人的感觉是文件的每一行都被修改了，这使得跟踪有意义的更改变得很困难。我们建立了一个约定，即文件应该只包含换行，但是很难确保每个开发人员使用的每个工具都遵循这个约定。每当一个新的开发人员加入这个项目，我们就会经历一连串的线路终止问题，而那个开发人员就会适应这个约定。&lt;/p&gt;
&lt;p&gt;我们最终通过编写一个简短的脚本解决了这个问题，该脚本在更改提交到源代码存储库之前自动执行。该脚本检查所有已修改的文件，如果其中任何一个包含回车符，则中止提交。还可以通过用换行符替换回车/换行符序列来手动运行脚本以修复损坏的文件。这立即消除了问题，并且还帮助培训了新开发人员。代码审查为实施约定和向新开发者提供有关约定的教育提供了另一个机会。代码审阅者越挑剔，团队中的每个人都将更快地学习约定，并且代码越干净。&lt;/p&gt;
&lt;p&gt;在罗马时……最重要的约定是每个开发人员都应遵循古老的格言“在罗马时，就像罗马人一样。” 在处理新文件时，请环顾四周以了解现有代码的结构。是否在私有变量和方法之前声明了所有公共变量和方法？方法是否按字母顺序排列？变量是否使用 firstServerName 中的“ camel case”或使用 first_server_name 中的“ snake case”？当您看到任何看起来可能是约定的内容时，请遵循该约定。在做出设计决策时，请问自己是否有可能在项目的其他地方做出了类似的决策；如果是这样，请找到一个现有示例，并在新代码中使用相同的方法。&lt;/p&gt;
&lt;p&gt;不要更改现有约定。抵制“改善”现有公约的冲动。拥有一个“更好的主意”不足以引起矛盾。您的新想法可能确实更好，但是一致性胜于不一致的价值几乎总是大于一种方法胜过另一种方法的价值。在引入不一致的行为之前，请问自己两个问题。首先，您是否拥有大量的新信息来证明您的方法在建立旧约定时是不可用的？其次，新方法是否好得多，值得花时间更新所有旧用法？如果您的组织同意对两个问题的回答均为“是”，则继续进行升级；否则，请进行升级。完成后，应该没有旧约定的迹象。然而，您仍然冒着其他开发人员不了解新约定的风险，因此他们将来可能会重新引入旧方法。总体而言，重新考虑已建立的约定很少会很好地利用开发人员时间。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>可视化设计</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h1 id=&#34;可视化设计&#34;&gt;可视化设计&lt;/h1&gt;
&lt;h1 id=&#34;业务可视化和可配置化&#34;&gt;业务可视化和可配置化&lt;/h1&gt;
&lt;p&gt;好的领域建模可以降低应用的复杂性，而可视化和可配置化主要是帮助大家（主要是非技术人员，比如产品，业务和客户）直观地了解系统和配置系统。要注意的是可视化和可配置化难免会给系统增加额外的复杂度，必须慎之又慎，最好是能使可视化和配置化的逻辑与业务逻辑尽量少的耦合，否则破坏了原有的架构，把事情搞的更复杂就得不偿失了。&lt;/p&gt;
&lt;p&gt;我们将领域的行为（也叫能力）和扩展点用可视化的方式呈现出来，并对于一些不需要编码实现的扩展点用配置的方式去完成呢。比如还是转账的例子，对于透支策略 OverdraftPolicy 这个业务扩展点，新来一个业务说透支额度不能超过 1000，我们可以完全结合规则引擎进行配置化完成，而不需要编码。&lt;/p&gt;
&lt;p&gt;通过 Annotation 注解的方式对领域能力和扩展点进行标注，然后在系统 bootstrap 阶段，通过代码扫描的方式，将这些能力点和扩展点收集起来上传到中心服务器，然后再通过 GUI 的方式呈现出来，从而做到业务的可视化和可配置化。大概的示意图如下：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/item/20230430221144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里要分清楚两个概念，业务逻辑流和工作流，很多同学混淆了这两个概念。业务逻辑流是响应一次用户请求的业务处理过程，其本身就是业务逻辑，对其编排和可视化的意义并不是很大，无外乎只是把代码逻辑可视化了。而工作流是指完成一项任务所需要不同节点的连接，节点主要分为自动节点和人工节点，其中每个人工节点都需要用户的参与，也就是响应一次用户的请求，比如审批流程中的经理审批节点，CRM 销售过程的业务员的处理节点等等。此时可以考虑使用工作流引擎，特别是当你的系统需要让用户自定义流程的时候，那就不得不使用可视化和可配置的工作流引擎了，除此之外，最好不要自找麻烦。&lt;/p&gt;
&lt;h1 id=&#34;扩展点设计&#34;&gt;扩展点设计&lt;/h1&gt;
&lt;h2 id=&#34;身份识别&#34;&gt;身份识别&lt;/h2&gt;
&lt;p&gt;业务身份识别在我们的应用中非常重要，因为我们的 CRM 系统要服务不同的业务方，而且每个业务方又有多个租户。比如中供销售，中供拍档，中供商家都是不同的业务方，而拍档下的每个公司，中供商家下的每个供应商又是不同的租户。所以传统的基于多租户（TenantId）的业务身份识别还不能满足我们的要求，于是在此基础上我们又引入了业务码（BizCode）来标识业务。所以我们的业务身份实际上是（BizCode，TenantId）二元组。在每一个业务身份下面，又可以有多个扩展点（ExtensionPoint），所以一个扩展点实现（Extension）实际上是一个三维空间中的向量。我给它起了个名字叫扩展坐标，这个坐标可以用（ExtensionPoint，BizCode，TenantId）来唯一标识。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/item/20230430221120.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;扩展点机制&#34;&gt;扩展点机制&lt;/h2&gt;
&lt;p&gt;扩展点的设计是这样的，所有的扩展点（ExtensionPoint）必须通过接口申明，扩展实现（Extension）是通过 Annotation 的方式标注的，Extension 里面使用 BizCode 和 TenantId 两个属性用来标识身份，框架的 Bootstrap 类会在 Spring 启动的时候做类扫描，进行 Extension 注册，在 Runtime 的时候，通过 TenantContext 来选择要使用的 Extension。TenantContext 是通过 Interceptor 在调用业务逻辑之前进行初始化的。整个过程如下图所示：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://assets.ng-tech.icu/item/20230430221104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>注释与文档</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/05.kiss/%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%96%87%E6%A1%A3/</guid>
      <description>&lt;h1 id=&#34;注释与文档&#34;&gt;注释与文档&lt;/h1&gt;
&lt;p&gt;代码内文档在软件设计中起着至关重要的作用。注释对于帮助开发人员理解系统和有效工作至关重要，但是注释的作用不止于此。文档在抽象中也起着重要作用。没有注释，您就无法隐藏复杂性。最后，编写注释的过程（如果正确完成）将实际上改善系统的设计。相反，如果没有很好的文档记录，那么好的软件设计会失去很多价值。&lt;/p&gt;
&lt;p&gt;不幸的是，这种观点并未得到普遍认同。生产代码的很大一部分基本上不包含任何注释。许多开发人员认为注释是浪费时间。其他人则看到了注释中的价值，但不知何故从不动手编写它们。幸运的是，许多开发团队认识到了文档的价值，并且感觉这些团队的普及率正在逐渐提高。但是，即使在鼓励文档的团队中，注释也经常被视为繁琐的工作，而且许多开发人员也不了解如何编写注释，因此生成的文档通常是平庸的。文档不足会给软件开发带来巨大且不必要的拖累。&lt;/p&gt;
&lt;p&gt;当开发人员不写注释时，他们通常会以以下一种或多种借口为自己的行为辩护：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“好的代码可以自我记录。”&lt;/li&gt;
&lt;li&gt;“我没有时间写注释。”&lt;/li&gt;
&lt;li&gt;“注释过时，并会产生误导。”&lt;/li&gt;
&lt;li&gt;“我所看到的注释都是毫无价值的；何必？”&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;不写注释的借口&#34;&gt;不写注释的借口&lt;/h1&gt;
&lt;h2 id=&#34;好的代码可以自我记录self-documenting&#34;&gt;！好的代码可以自我记录（self-documenting）&lt;/h2&gt;
&lt;p&gt;有人认为，如果代码编写得当，那么显而易见，不需要注释。这是一个美味的神话，就像谣言说冰淇淋对您的健康有益：我们真的很想相信！不幸的是，事实并非如此。可以肯定的是，在编写代码时可以做一些事情来减少对注释的需求，例如选择好的变量名。尽管如此，仍有大量设计信息无法用代码表示。例如，只能在代码中正式指定类接口的一小部分，例如其方法的签名。接口的非正式方面，例如对每种方法的作用或其结果含义的高级描述，只能在注释中描述。&lt;/p&gt;
&lt;p&gt;一些开发人员认为，如果其他人想知道某个方法的作用，那么他们应该只阅读该方法的代码：这将比任何注释都更准确。读者可能会通过阅读其代码来推断该方法的抽象接口，但这既费时又痛苦。另外，如果在编写代码时期望用户会阅读方法实现，则将尝试使每个方法尽可能短，以便于阅读。如果该方法执行了一些重要操作，则将其分解为几个较小的方法。这将导致大量浅层方法。此外，它并没有真正使代码更易于阅读：为了理解顶层方法的行为，读者可能需要了解嵌套方法的行为。&lt;/p&gt;
&lt;p&gt;此外，注释是抽象的基础。抽象的目的是隐藏复杂性：抽象是实体的简化视图，该实体保留必要的信息，但忽略了可以安全忽略的细节。如果用户必须阅读方法的代码才能使用它，则没有任何抽象：方法的所有复杂性都将暴露出来。没有注释，方法的唯一抽象就是其声明，该声明指定其名称以及其参数和结果的名称和类型。该声明缺少太多基本信息，无法单独提供有用的抽象。例如，提取子字符串的方法可能有两个参数，开始和结束，表示要提取的字符范围。仅凭宣言，无法确定提取的子字符串是否将包含 end 指示的字符，或者如果 start &amp;gt; end 会发生什么。注释使我们能够捕获调用者所需的其他信息，从而在隐藏实现细节的同时完成简化的视图。用人类语言（例如英语）写注释也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。&lt;/p&gt;
&lt;h2 id=&#34;我没有时间写注释&#34;&gt;！我没有时间写注释&lt;/h2&gt;
&lt;p&gt;优先考虑低于其他开发任务的注释是很诱人的。在添加新功能和记录现有功能之间做出选择之后，选择新功能似乎合乎逻辑。但是，软件项目几乎总是处于时间压力之下，并且总会有比编写注释优先级更高的事情。因此，如果您允许取消对文档的优先级，则最终将没有文档。&lt;/p&gt;
&lt;p&gt;如果您想要一个干净的软件结构，可以长期有效地工作，那么您必须花一些额外的时间才能创建该结构。好的注释对软件的可维护性有很大的影响，因此花费在它们上面的精力将很快收回成本。此外，撰写注释不需要花费很多时间。询问自己，假设您不包含任何注释，那么您花费了多少开发时间来键入代码（与设计，编译，测试等相对）。我怀疑答案是否超过 10％。现在假设您花在输入注释上的时间与输入代码所花费的时间一样多。这应该是一个安全的上限。基于这些假设，撰写好的注释不会增加您的开发时间约 10％。拥有良好文档的好处将迅速抵消这一成本。&lt;/p&gt;
&lt;p&gt;此外，许多最重要的注释是与抽象有关的注释，例如类和方法的顶级文档。这些注释应作为设计过程的一部分编写，并且编写文档的行为是改善整体设计的重要设计工具。这些注释立即付诸行动。&lt;/p&gt;
&lt;h2 id=&#34;注释过时并产生误导&#34;&gt;！注释过时并产生误导&lt;/h2&gt;
&lt;p&gt;注释有时确实会过时，但这实际上并不是主要问题。使文档保持最新状态并不需要付出巨大的努力。仅当对代码进行了较大的更改时才需要对文档进行大的更改，并且代码更改将比文档的更改花费更多的时间。我们应该更好地组织文档，以便在修改代码后尽可能容易地对其进行更新（主要思想是避免重复的文档并使文档与相应的代码保持一致）。代码审查提供了一种检测和修复陈旧注释的强大机制。&lt;/p&gt;
&lt;h2 id=&#34;我所看到的所有注释都是毫无价值的&#34;&gt;！我所看到的所有注释都是毫无价值的&lt;/h2&gt;
&lt;p&gt;在这四个借口中，这可能是最有价值的借口。每个软件开发人员都看到没有提供有用信息的注释，并且大多数现有文档充其量都是这样。幸运的是，这个问题是可以解决的。一旦知道了如何编写可靠的文档并不难。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
