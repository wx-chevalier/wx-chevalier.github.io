<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>01.架构思维 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/</link>
      <atom:link href="https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/index.xml" rel="self" type="application/rss+xml" />
    <description>01.架构思维</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>01.架构思维</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/</link>
    </image>
    
    <item>
      <title>持续设计</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%8C%81%E7%BB%AD%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%8C%81%E7%BB%AD%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h1 id=&#34;持续设计&#34;&gt;持续设计&lt;/h1&gt;
&lt;h1 id=&#34;设计它两次&#34;&gt;设计它两次&lt;/h1&gt;
&lt;p&gt;设计软件非常困难，因此您对如何构造模块或系统的初步思考不太可能会产生最佳的设计。如果为每个主要设计决策考虑多个选项，最终将获得更好的结果：设计两次。假设您正在设计用于管理 GUI 文本编辑器文件文本的类。第一步是定义该类将呈现给编辑器其余部分的接口。与其选择想到的第一个想法，不如考虑几种可能性。一种选择是面向行的界面，该界面具有插入，修改和删除整行文本的操作。另一个选择是基于单个字符插入和删除的接口。第三种选择是面向字符串的接口，该接口可对可能跨越线边界的任意范围的字符进行操作。您无需确定每个替代方案的每个功能；在这一点上，勾勒出一些最重要的方法就足够了。&lt;/p&gt;
&lt;p&gt;尝试选择彼此根本不同的方法；这样您将学到更多。即使您确定只有一种合理的方法，无论您认为有多糟糕，都应该考虑第二种设计。考虑该设计的弱点并将它们与其他设计的特征进行对比将很有启发性。在对备选方案进行粗略设计之后，列出每个方案的优缺点。接口最重要的考虑因素是高级软件的易用性。在上面的示例中，面向行的界面和面向字符的界面都需要使用文本类的软件中的额外工作。面向行的界面将需要更高级别的软件来在部分行和多行操作（例如剪切和粘贴所选内容）期间拆分和合并行。面向字符的接口将需要循环来实现修改多个字符的操作。还值得考虑其他因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种选择是否具有比另一种更简单的界面？在文本示例中，所有文本界面都相对简单。&lt;/li&gt;
&lt;li&gt;一个接口比另一个接口更通用吗？&lt;/li&gt;
&lt;li&gt;一个接口是否比另一个接口更有效地实现？在文本示例中，面向字符的方法可能比其他方法慢得多，因为它需要为每个字符单独调用文本模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较了备选设计之后，您将可以更好地确定最佳设计。最佳选择可能是这些选择之一，或者您可能发现可以将多个选择的功能组合到一个比任何原始选择都要好的新设计中。有时，没有其他选择特别有吸引力。发生这种情况时，请查看是否可以提出其他方案。使用您在原始替代方案中发现的问题来推动新设计。如果您在设计文本类并且仅考虑面向行和面向字符的方法，则可能会注意到每个替代方案都比较笨拙，因为它需要更高级别的软件来执行其他文本操作。那是一个危险信号：如果要有一个文本类，它应该处理所有文本操作。为了消除其他文本操作，文本界面需要更紧密地匹配高级软件中发生的操作。这些操作并不总是对应于单个字符或一行。&lt;/p&gt;
&lt;p&gt;两次设计原则可以在系统的许多级别上应用。对于模块，您可以首先使用此方法来选择接口，如上所述。然后，您可以在设计实现时再次应用它：对于文本类，您可以考虑实现这些实现，例如行的链接列表，固定大小的字符块或“间隙缓冲区”。实现的目标与接口的目标是不同的：对于实现，最重要的是简单性和性能。在系统的更高层次上探索多种设计也很有用，例如在为用户界面选择功能或将系统分解为主要模块时。在每种情况下，如果您可以比较几种选择，则更容易确定最佳方法。&lt;/p&gt;
&lt;p&gt;对其进行两次设计不需要花费很多额外的时间。对于较小的模块（如课程），您可能不需要一两个小时就能考虑替代方法。与您将花费数天或数周时间来实施该课程相比，这是很少的时间。最初的设计实验可能会导致明显更好的设计，这将比花两次设计时间所花的时间多。对于较大的模块，您将花费更多的时间进行初始设计探索，但是实现也将花费更长的时间，并且更好的设计所带来的好处也会更高。&lt;/p&gt;
&lt;p&gt;“两次设计”方法不仅可以改善您的设计，而且可以提高您的设计技能。设计和比较多种方法的过程将教您使设计更好或更坏的因素。随着时间的流逝，这将使您更容易排除不良的设计并磨练真正的出色设计。&lt;/p&gt;
&lt;h1 id=&#34;演进式架构&#34;&gt;演进式架构&lt;/h1&gt;
&lt;p&gt;与传统的前期、重量级的企业架构设计相比，我们建议采用演进式架构（Evolutionary Architecture）。它提供了企业架构的好处，却没有试图准确预测未来所带来的问题。演进式架构不需要猜测组件将如何被重用，而是支持适应性，使用适当的抽象、数据库迁移、测试套件、持续集成和重构来收获系统内发生的重用。系统的驱动技术需求应该尽早确定，以确保在后续的设计和实现中正确处理这些需求。我们主张将决策延迟到最近的负责时刻，事实上，对于一些决策来说，可能是前期的。&lt;/p&gt;
&lt;p&gt;敏捷软件开发的一个原则是最后负责时刻的概念。这个概念应用于架构的考虑，在传统架构师中是有争议的。我们认为，只要有适当的原则和适当的测试套件，架构可以不断进化，以满足系统不断变化的需求，允许在不影响系统完整性的情况下，在最后负责的时刻做出架构决策。我们将这种方法称为进化架构，因为我们允许架构随着时间的推移而演变，始终尊重架构指导原则。&lt;/p&gt;
&lt;p&gt;演进式架构借用自进化计算而引入的适应度函数，可以客观地展示应用程序及架构是否正在偏离期望的指标，实际上是可以集成到发布流水线中的测试。依赖漂移适应度函数追踪应用程序一个主要指标，即应用依赖的库、API 或环境组件的新鲜度，并可以将过时需要更新的依赖标记出来。随着 Dependabot、Snyk 这类用于检测依赖漂移的工具日趋成熟，我们可以轻松地在软件发布流程中加入依赖漂移适应度函数，以保证应用程序依赖的更新。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>抽象思维</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%8A%BD%E8%B1%A1%E6%80%9D%E7%BB%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%8A%BD%E8%B1%A1%E6%80%9D%E7%BB%B4/</guid>
      <description>&lt;h1 id=&#34;抽象思维&#34;&gt;抽象思维&lt;/h1&gt;
&lt;h1 id=&#34;links&#34;&gt;Links&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cubox.pro/c/FdOgPY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cubox.pro/c/FdOgPY&lt;/a&gt; 当程序员具备了抽象思维&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>架构师</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E5%B8%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E5%B8%88/</guid>
      <description>&lt;h1 id=&#34;架构师&#34;&gt;架构师&lt;/h1&gt;
&lt;p&gt;架构师是一个角色，定义角色其实是定义职责，架构师的职责是：识别并定义问题，创建、选择或调整架构，从而找到最优的方案，解决问题。按 TOGAF 的定义，架构师的职责是了解并关注实际上关系重大但未变得过载的一些关键细节和界面，架构师的角色有：理解并解析需求，创建有用的模型，确认、细化并扩展模型，管理架构。架构师是一个既能掌控整体又能洞悉局部瓶颈并依据具体的业务场景给出解决方案的团队领导型人物。&lt;/p&gt;
&lt;p&gt;架构师不是一个人，他需要建立高效卓越的体系，带领团队去攻城略地，在规定的时间内完成项目。架构师的角色有：理解并解析需求，创建有用的模型，确认、细化并扩展模型，管理架构。架构师需要能够识别定义确认需求，能够进行系统分解形成整体架构，能够正确的技术选型，能够制定技术规格说明并有效推动实施落地。&lt;/p&gt;
&lt;h1 id=&#34;什么是问题&#34;&gt;什么是问题？&lt;/h1&gt;
&lt;p&gt;架构师要定义和解决的问题，就是特定领域中的矛盾，解决了矛盾，就得到了发展，取得了收益。&lt;/p&gt;
&lt;h2 id=&#34;如何区分问题手段挑战&#34;&gt;如何区分问题、手段、挑战&lt;/h2&gt;
&lt;p&gt;每一个问题可以向下不断展开不断细化，下一级的问题是上一级问题的具体解决手段，当你把“提升性能”当做你主的问题时，提升帧率、提高页面秒开率、优化启动耗时就成为了你的具体解决手段；而手段的下一级问题，就是你将面临的挑战，比如你要优化网络耗时，你要面临的挑战就有弱网环境、一些国家区域的带宽问题等等。同理，当你把“提升用户体验”当做你主的问题，“提升性能”就变成了你的具体手段，帧率、秒开率、启动耗时就成为了挑战。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>战术与战略</title>
      <link>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%88%98%E6%9C%AF%E4%B8%8E%E6%88%98%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-notes/00.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/01.%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/%E6%88%98%E6%9C%AF%E4%B8%8E%E6%88%98%E7%95%A5/</guid>
      <description>&lt;h1 id=&#34;编程之中的战术与战略&#34;&gt;编程之中的战术与战略&lt;/h1&gt;
&lt;p&gt;好的软件设计中最重要的元素之一是您在执行编程任务时所采用的思维方式。许多组织都鼓励采取战术思维方式，着眼于使功能尽快运行。但是，如果您想要一个好的设计，则必须采取更具战略性的方法，在此上花费时间来制作干净的设计并解决问题。本章讨论了从长远来看，为什么战略方法可以产生更好的设计，而实际上却比战术方法便宜。&lt;/p&gt;
&lt;p&gt;好的设计不是免费的。它必须是您不断投资的东西，这样小问题才不会累积成大问题。幸运的是，好的设计最终会收回成本，而且比您想象的要早。始终如一地运用战略方法并将投资视为今天而不是明天要做的事情至关重要。当您陷入危机时，很容易推迟清理，直到危机结束之后。但是，这是一个湿滑的斜坡。在当前紧缩之后，几乎肯定会再出现一次。一旦开始延迟设计改进，就很容易使延迟永久化，并使您的文化陷入战术方法中。您等待解决设计问题的时间越长，问题就会变得越大；解决方案变得更加令人生畏，这使得轻松推迟解决方案变得更加容易。最有效的方法是，每位工程师都对良好的设计进行连续的少量投资。&lt;/p&gt;
&lt;h1 id=&#34;战术编程tactical-programming&#34;&gt;战术编程（Tactical Programming）&lt;/h1&gt;
&lt;p&gt;大多数程序员以我称为战术编程的心态来进行软件开发。在战术方法中，您的主要重点是使某些功能正常工作，例如新功能或错误修复。乍一看，这似乎是完全合理的：还有什么比编写有效的代码更重要的呢？但是，战术编程几乎不可能产生出良好的系统设计。战术编程的问题是它是短视的。如果您是战术编程人员，那么您将尝试尽快完成任务。也许您有一个艰难的期限。因此，为未来做计划不是优先事项。您不会花费太多时间来寻找最佳设计。您只想尽快使某件事起作用。您告诉自己，可以增加一些复杂性或引入一两个小错误，如果这样可以使当前任务更快地完成，则可以。&lt;/p&gt;
&lt;p&gt;如果您进行战术编程，则每个编程任务都会带来一些此类复杂性。为了快速完成当前任务，他们每个人似乎都是一个合理的折衷方案。但是，复杂性迅速累积，尤其是如果每个人都在战术上进行编程的时候。不久之后，某些复杂性将开始引起问题，并且您将开始希望您没有采用这些早期的捷径。但是，您会告诉自己，使下一个功能正常工作比返回并重构现有代码更为重要。从长远来看，重构可能会有所帮助，但是肯定会减慢当前的任务。因此，您需要快速修补程序来解决遇到的任何问题。这只会增加复杂性，然后需要更多补丁。很快代码变得一团糟，但是到现在为止，情况已经很糟糕了，清理它需要花费数月的时间。您的日程安排无法容忍这种延迟，解决一个或两个问题似乎并没有太大的区别，因此您只是在战术上保持编程。&lt;/p&gt;
&lt;p&gt;几乎每个软件开发组织都有至少一个将战术编程发挥到极致的开发人员：战术龙卷风（The tactical tornado）。战术龙卷风是一位多产的程序员，他抽出代码的速度比其他人快得多，但完全以战术方式工作。实施快速功能时，没有人能比战术龙卷风更快地完成任务。在某些组织中，管理层将战术龙卷风视为英雄。但是，战术龙卷风留下了毁灭的痕迹。他们很少被将来必须使用其代码的工程师视为英雄。通常，其他工程师必须清理战术龙卷风留下的混乱局面，这使得那些工程师（他们是真正的英雄）的进步似乎比战术龙卷风慢。&lt;/p&gt;
&lt;h1 id=&#34;战略规划strategic-programming&#34;&gt;战略规划（Strategic programming）&lt;/h1&gt;
&lt;p&gt;成为一名优秀的软件设计师的第一步是要意识到仅工作代码是不够的。引入不必要的复杂性以更快地完成当前任务是不可接受的。最重要的是系统的长期结构。任何系统中的大多数代码都是通过扩展现有代码库编写的，因此，作为开发人员，最重要的工作就是促进这些将来的扩展。因此，尽管您的代码当然必须工作，但您不应将“工作代码”视为主要目标。您的主要目标必须是制作出出色的设计，并且这种设计也会起作用。这是战略计划。&lt;/p&gt;
&lt;p&gt;战略性编程需要一种投资心态。您必须花费时间来改进系统的设计，而不是采取最快的方式来完成当前的项目。这些投资会在短期内让您放慢脚步，但从长远来看会加快您的速度。一些投资将是积极的。例如，值得花一些时间为每个新类找到一个简单的设计。而不是实施想到的第一个想法，请尝试几种替代设计并选择最简洁的设计。试想一下将来可能需要更改系统的几种方式，并确保设计容易。编写好的文档是主动投资的另一个例子。&lt;/p&gt;
&lt;p&gt;其他投资将是被动的。无论您预先投入多少，设计决策中都不可避免地会出现错误。随着时间的流逝，这些错误将变得显而易见。发现设计问题时，不要只是忽略它或对其进行修补。花一些额外的时间来修复它。如果您进行战略性编程，则将不断对系统设计进行小幅改进。这与战术编程相反，在战术编程中，您不断增加一些复杂性，这些复杂性将来会引起问题。&lt;/p&gt;
&lt;h1 id=&#34;投资的权衡&#34;&gt;投资的权衡&lt;/h1&gt;
&lt;p&gt;那么，正确的投资额是多少？大量的前期投资（例如尝试设计整个系统）将不会有效。这是瀑布方法，我们知道它不起作用。随着您对系统的了解，理想的设计趋于零碎出现。因此，最好的方法是连续进行大量小额投资 ​​。我建议您将总开发时间的 10％到 20％用于投资。该金额足够小，不会对您的日程安排产生重大影响，但又足够大，可以随着时间的推移产生重大收益。因此，您的初始项目将比纯战术方法花费 10-20％的时间。额外的时间将带来更好的软件设计，并且您将在几个月内开始体验到这些好处。不久之后，您的开发速度将比战术编程快至少 10–20％。在这一点上，您的投资将免费：您过去投资的收益将节省足够的时间来支付未来投资的费用。您将迅速收回初始投资的成本。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s3.ax1x.com/2021/01/26/sXmoPU.png&#34; alt=&#34;this figure is intended only as a qualitative illustration&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一开始，战术性的编程方法将比战略性方法更快地取得进展。但是，在战术方法下，复杂性积累得更快，从而降低了生产率。随着时间的流逝，战略方针会带来更大的进步。注意：此图仅用于定性说明；我不知道对曲线精确形状的任何经验测量。相反，如果您进行战术编程，则可以将第一个项目完成的速度提高 10％到 20％，但是随着时间的推移，复杂性的累积会降低开发速度。不久之后，您的编程速度至少会降低 10–20％。您将很快退回在开始时节省的所有时间，并且在系统的整个生命周期中，与采用策略性方法相比，您的开发速度将更加缓慢。如果您从未使用过严重降级的代码库，请与有经验的人联系。他们会告诉您不良的代码质量会使开发速度至少降低 20％。&lt;/p&gt;
&lt;h1 id=&#34;创业与投资&#34;&gt;创业与投资&lt;/h1&gt;
&lt;p&gt;在某些环境中，强大的力量与战略方法背道而驰。例如，早期的初创公司感到巨大的压力，需要尽快发布其早期版本。在这些公司中，甚至 10％至 20％的投资似乎也负担不起。结果，许多初创公司采取了战术性的方法，在设计上花费了很少的精力，而在问题出现时则花费了更少的精力进行清理。他们认为，如果成功，他们将有足够的钱聘请额外的工程师来清理问题，从而使其合理化。如果您是一家朝着这个方向发展的公司，则应该意识到，一旦代码库变成了意大利面条，几乎是不可能修复的。您可能会为产品的使用寿命付出高昂的开发成本。此外，好的（或坏的）设计的回报很快就会到来，因此战术方法很有可能甚至不会加快您的首个产品发布的速度。&lt;/p&gt;
&lt;p&gt;要考虑的另一件事是，公司成功的最重要因素之一就是工程师的素质。降低开发成本的最佳方法是聘请优秀的工程师：他们的成本不会比普通工程师高很多，但生产率却高得多。但是，最好的工程师对良好的设计深感兴趣。如果您的代码库已经崩溃，那么再多的挽救会变得毫无用处，这将使您难以招募。结果，您最终可能会遇到普通的工程师。这将增加您的未来成本，并可能导致系统结构进一步退化。&lt;/p&gt;
&lt;p&gt;Facebook 是一个鼓励战术编程的创业公司的例子。多年来，公司的座右铭是“快速行动并打破困境”。鼓励刚大学毕业的新工程师立即深入公司的代码库；工程师在工作的第一周将承诺投入生产是很正常的。从积极的一面来看，Facebook 作为一家赋予员工权力的公司而享有声誉。工程师拥有极大的自由度，并且几乎没有任何规则和限制。Facebook 作为一家公司已经取得了令人瞩目的成功，但是由于该公司的战术方法，其代码库受到了影响。许多代码不稳定且难以理解，几乎没有注释或测试，并且使用起来很痛苦。随着时间的流逝，该公司意识到其文化是不可持续的。最终，Facebook 改变了座右铭，即“以坚实的基础架构快速移动”，以鼓励其工程师在良好的设计上进行更多的投资。Facebook 是否能够成功清除多年来战术编程中积累的问题还有待观察。&lt;/p&gt;
&lt;p&gt;为了公平起见，我应该指出，Facebook 的代码可能并不比初创公司的平均水平差很多。战术编程在初创企业中司空见惯。Facebook 恰好是一个特别明显的例子。幸运的是，通过战略方法也有可能在硅谷取得成功。Google 和 VMware 与 Facebook 差不多同时成长，但是这两家公司都采用了更具战略意义的方法。两家公司都非常重视高质量的代码和良好的设计，并且两家公司都开发了复杂的产品，这些产品通过可靠的软件系统解决了复杂的问题。公司的强大技术文化在硅谷广为人知。很少有其他公司可以与他们竞争聘请顶级技术人才。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
