<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GAMES101 课程笔记 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</link><atom:link href="https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><description>GAMES101 课程笔记</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>GAMES101 课程笔记</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</link></image><item><title>01.Overview of Computer Graphics</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/01.overview-of-computer-graphics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/01.overview-of-computer-graphics/</guid><description>&lt;h1 id="overview-of-computer-graphics">Overview of Computer Graphics&lt;/h1>
&lt;p>对课程内容进行大致介绍，同时对图形学进行介绍。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216416.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216448.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216472.jpg" alt="Why Study Computer Graphics" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>介绍一下图形学是什么，以及为什么学图形学；之后介绍了课程包含的四大内容：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216490.jpg" alt="Rasterization" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216505.jpg" alt="Curves and Meshes" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216521.jpg" alt="Ray Tracings" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216536.jpg" alt="Animation/Simulation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>02.Review of Linear Algebra</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/02.review-of-linear-algebra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/02.review-of-linear-algebra/</guid><description>&lt;h1 id="review-of-linear-algebra">Review of Linear Algebra&lt;/h1>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a href="https://ng-tech.icu/books/Mathematics-Series" target="_blank" rel="noopener">Mathematics-Notes&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这节课主要回顾了一下线性代数相关的基础知识，包括向量、向量运算、矩阵、矩阵运算等等。基本在本科覆盖范围内，因此叫 Review。&lt;/p></description></item><item><title>03-04.Transformation</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/03-04.transformation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/03-04.transformation/</guid><description>&lt;h1 id="transformation">Transformation&lt;/h1>
&lt;h1 id="basic-of-transformation">Basic of Transformation&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216606.jpg" alt="Why Transformation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>首先用几个例子（摄像机在空间中的运动、机器人运动、视角变换）介绍一下为什么要用 Transformation，之后介绍几种二维上的基本变换。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216620.jpg" alt="Scale" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216636.jpg" alt="Reflection Matrix" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216651.jpg" alt="Shear Matrix" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216665.jpg" alt="Rotation Martrix" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216679.jpg" alt="Translation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>平移变换，但通常在齐次坐标下进行。合在一起成为仿射变换：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216692.jpg" alt="Affine Transformations" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216706.jpg" alt="Inverse Transform" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216720.jpg" alt="Composing Transforms" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216734.jpg" alt="3D Transformations" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216749.jpg" alt="3D Transformations" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>3D 的缩放、镜像、切变基本和 2D 可直接类比。但是旋转会有一些麻烦。这是一种解决方案，将任意旋转分解为绕坐标轴旋转。并且这里需要注意坐标系，课程中使用的是右手坐标系，部分 API 和软件会使用左手坐标系。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216762.jpg" alt="Rodrigues&amp;amp;rsquo; Rotation Formula" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="camera-transformation">Camera Transformation&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216778.jpg" alt="View/Camera Transformation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216792.jpg" alt="View/Camera Transformation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>三维摄像机有 7 个维度&lt;/p>
&lt;ul>
&lt;li>位置：3 维&lt;/li>
&lt;li>朝向：3 维&lt;/li>
&lt;li>画面旋转：1 维&lt;/li>
&lt;/ul>
&lt;p>通常用三个向量进行对应&lt;/p>
&lt;ul>
&lt;li>位置向量&lt;/li>
&lt;li>朝向向量&lt;/li>
&lt;li>上方向量（由于一定和朝向正交，所以会冗余 2 维）&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216807.jpg" alt="View/Camera Transformation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>正向考虑摄像机变换的矩阵是比较麻烦的一件事情：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216821.jpg" alt="View/Camera Transformation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但反向考虑则比较容易，所以可以通过反向考虑，配合矩阵求逆得到结果。&lt;/p>
&lt;h1 id="projection-transformation">Projection Transformation&lt;/h1>
&lt;p>投影变换本身是一个降维变换，图形学中主要针对于将三维投影至二维：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216837.jpg" alt="Projection Transformation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>3D 至 2D 的投影主要有两种：平行投影和透视投影：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216853.jpg" alt="Orthographic Projection" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>平行投影的操作比较简单，直接丢掉坐标中的 Z 分量即可。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216868.jpg" alt="Orthographic Projection" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但通常需要 canonical，即首先将视图空间中心平移至原点，再缩放为标准正方体。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216883.jpg" alt="Orthographic Projection" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>整理一下可知这一系列操作对应的矩阵。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216898.jpg" alt="Perspective Projection" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>透视投影本质上是将空间投影至一个点，但在过程中用一个平面（如胶片）截下。而对于透视变换，可以考虑将其先变换为平行，再用平行投影。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172216912.jpg" alt="Perspective Projection" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这个矩阵并不直观，但是可以通过设立条件对矩阵进行推导&lt;/p>
&lt;ul>
&lt;li>胶片所在平面不发生变化&lt;/li>
&lt;li>而远处的平面大小缩放至和胶片一样大，且中心对齐，但 Z 值不变&lt;/li>
&lt;/ul></description></item><item><title>05-06.Rasterization</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/05-06.rasterization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/05-06.rasterization/</guid><description>&lt;h1 id="rasterization">Rasterization&lt;/h1>
&lt;p>这节课主要介绍光栅化本身，和现代光栅化的对象–三角形 相关的一些操作。即在经过将场景进行基本变换后，如何将变换后的正方形内容呈现在屏幕上。&lt;/p>
&lt;h1 id="介绍成像">介绍成像&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217643.jpg" alt="Canonical Cube to Screen" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>首先弄清楚什么是屏幕。 再弄清楚像素，Pixel 原来是 picture element 的浓缩版。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217686.jpg" alt="Canonical Cube to Screen" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>定义屏幕空间，和每个像素的坐标表示方法，此时介绍一下各种成像设备（不仅仅是矩阵式像素成像、甚至不仅仅是屏幕）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217705.jpg" alt="CNC Sharpie Drawing Machine" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217728.jpg" alt="Laser Cutters" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>绘制机也算作成像设备，但并非用屏幕，事实上即使用屏幕，也不一定是像素阵列。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217751.jpg" alt="Oscilloscope" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217765.jpg" alt="Television - Raster Display CRT" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217782.jpg" alt="LCD Pixel" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217795.jpg" alt="LED Array Display" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217808.jpg" alt="Electronic Ink Display" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="三角形">三角形&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217820.jpg" alt="Triangles" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>选用三角形作为基本形体单位的原因。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217834.jpg" alt="What Pixel Values Approximate a Triangle" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但应该如何把一个三角形给光栅化呢？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217850.jpg" alt="Sample If Each Pixel Center Is Inside Triangle" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一种方式是对每个像素去采样，中心在三角形内即标内部颜色，否则标外部颜色。判断像素是否在三角形以内可以用叉积判断点是否在三条边（全逆时针或全顺时针）的同侧。同即内部，否则外部。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217863.jpg" alt="Edge Cases" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对于刚好在边界的情况，通常只要自己定义清楚就行，在哪边都不会有太大影响（OpenGL 会根据是否是左上的边进行区别选择）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217881.jpg" alt="Checking All Pixels on the Screen?" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217897.jpg" alt="Incremental Triangle Traversal" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些加速遍历的方法：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217914.jpg" alt="Real LCD Screen Pixels" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些实际机器上的像素排列。三星 Galaxy S5 的排列方式可以节省一些像素点。绿色偏多是由于人眼对绿色更敏感。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217930.jpg" alt="三星" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些其他的成像算法。比如打印机用这种排列，目的主要是为了节省油墨。&lt;/p>
&lt;h1 id="antialiasing-and-z-buffering">Antialiasing and Z-buffering&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217943.jpg" alt="Pixels are uniformly-colored squares" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217956.jpg" alt="Aliasing" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>事实上仅仅用上节提到的采样方法，会得到这样的结果。非常不像我们想要的三角形。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217973.jpg" alt="Moire Patterns in Imaging" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>甚至还有更严重的事情发生，比如采样得到了完全不同的花纹，这已经不是锯齿的问题了。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217990.jpg" alt="Wagon Wheel Illusion" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还有这种运动错觉（同偶尔看到车轮反转的错觉）这些问题出在哪呢？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217003.jpg" alt="Sampling Artifacts" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>都是采样造成的问题，对于其中的锯齿问题：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217017.jpg" alt="Sample Image Sensor Plane" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如果考察照相机（照片一般不会有这种问题），会发现位于边界的每个像素会吸收边界两边的光子，得到一个混合的结果，使整体看上去边界顺滑自然。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217031.jpg" alt="Antialiased Sampling" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>采样时也理应可以做到人工边界模糊，达到接近相机的效果。比如先模糊，再采样。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217048.jpg" alt="Antialiasing" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>效果还不错：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217064.jpg" alt="Blurred Aliasing" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但做这种事情时需要注意顺序：需要先模糊再采样，而非先采样再模糊。&lt;/p>
&lt;h1 id="背后的信号原理">背后的信号原理&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217078.jpg" alt="Why?" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>针对于前面的现象，应该如何解释呢？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217093.jpg" alt="Fourier Transform" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这可以追溯至傅立叶变换：高频信号需要更高的采样率才能保证不失真。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217106.jpg" alt="Higher Frequencies Need Faster Sampling" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>越高频的信号要求越高频的采样，否则会出现走样，对于图片而言，也可以进行二维的傅立叶分解&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217121.jpg" alt="Visualizing Image Frequency Content" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>频域上的两条直线线主要由于做变换时等效于将图片横纵重复了很多次，而边界往往是非常难匹配的，即对应了高频变化。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217135.jpg" alt="Filter Out Low Frequencies Only" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>频域上越远离中心，在时域上越对应突变的边：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217149.jpg" alt="Filter Out High Frequencies（Blur）" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>低频则对应于模糊：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217163.jpg" alt="Convolution Theorem" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>卷积定理：时域上的卷积，对应频域上的乘积。而频域上的卷积，对应时域上的乘积。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217177.jpg" alt="Convolution Theorem" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>卷积定理的一个例子：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217198.jpg" alt="Sampling" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而对于一个时域上的函数 a，对其进行固定间隔采样的操作实质等效于用一系列冲击函数 c 去和 a 乘，最后得到 e。根据卷积定理，时域上的乘积对应频域上的卷积。假设 a 对应的频域为 b。而冲击函数 c 对应的频域为 d。b 和 d 卷积后则理应得到 f。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217215.jpg" alt="Aliasing" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这时我们可以看出如果原始函数比较低频，即对应的频域函数局限在较小区域，则在采样之后不会有重叠。否则，则会在频域上有重叠，进而对于重叠部分无法区分是重叠导致的，还是原始信号天生如此，造成走样。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217234.jpg" alt="How can we reduce Aliasing Error" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>据此，分析反走样的原理也就比较容易了。要么提高采样频率，相当于增大频域上的间隔，使其不容易重叠。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217249.jpg" alt="Antialiasing = Limiting, then repeatings" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也可以通过模糊化操作，使其不包含高频信号，以至于不会重叠：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217264.jpg" alt="Antialiasing By Averaging Values in Pixel Area" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217278.jpg" alt="Antialiasing by Computing Average Pixel Value" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>除了模糊化以外，还可以采用对单个像素密集采样求平均的方法来减少锯齿或走样问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217293.jpg" alt="4x4 Supersampling" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也能达到很好的效果，不过与此同时也需要付出计算代价。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217315.jpg" alt="Antialiasing Today" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="光栅化一个场景">光栅化一个场景&lt;/h1>
&lt;p>知道了如何光栅化一个三角形，再介绍如何光栅化一个场景。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217333.jpg" alt="Painter&amp;amp;rsquo;s Algorithm" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为了解决远近覆盖问题。容易想到的一种处理方式是画家算法：由远往近依次画。画的时候近处物体覆盖远处物体。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217349.jpg" alt="Painter&amp;amp;rsquo;s Algorithm" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但这样做也是有局限的。特别是有些情况下难以对三角形进行远近排序。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217365.jpg" alt="Z-Buffer" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对三角形难以远近排序，对像素却是可以做到的，所以有了 Z-Buffer 算法。每个像素用 Z 最近的光栅化值。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217381.jpg" alt="Z-Buffer Example" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>实际上等效于在记录 RGB 三色的同时，加入 Depth 的记录。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172217400.jpg" alt="Z-Buffer Complexity" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由于只用找最小，而不是排序，所以 Z-Buffer 复杂度仅 𝑂(𝑛)，且为了更高的运行效率， Z-Buffer 已经集成在了各个 GPU 内部，直接硬件层面支持。&lt;/p></description></item><item><title>07-09.Shading, Pipeline and Texture Mapping</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/07-09.shading-pipeline-and-texture-mapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/07-09.shading-pipeline-and-texture-mapping/</guid><description>&lt;h1 id="shading-shadingpipeline-and-texture-mapping">Shading: Shading,Pipeline and Texture Mapping&lt;/h1>
&lt;h1 id="71-目前的进度和局限">7.1 目前的进度和局限&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218826.jpg" alt="Rotating Cubes" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>能够用上面的方法绘制场景，即可做出如图的效果。但这样是不够的。我们想得到下面的效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218849.jpg" alt="Rotating Cubes Expected" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为什么会这样呢？为什么“相同”颜色的方块的每一面颜色不一致呢？容易发现，是环境光的影响。我们看到的物体画面是由物体本身和环境光共同作用得到的结果。所以需要考虑环境光。这个共同作用的方式，则体现出了物体的材质。&lt;/p>
&lt;h1 id="72-shading-是什么">7.2 Shading 是什么&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218866.jpg" alt="Shading: Definition" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而 Shading 在本课中则对应着将材质应用于物体本身的过程。&lt;/p>
&lt;h1 id="73-blinn-phong-模型介绍">7.3 Blinn-Phong 模型介绍&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218887.jpg" alt="A Simple Shading Model" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Blinn-Phong 是经验总结下的容易实现的材质模型。其原理来自于观察：当光源和观察者的方向接近时，物体的颜色会变得更亮。而当光源和观察者的方向相反时，物体的颜色会变得更暗。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218909.jpg" alt="Perceptual Observations" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>类似于绘画中的三大面。可以把物体表面分为高光区域、漫反射区域、环境光区域。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218927.jpg" alt="Shading is Local" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>需要注意的是，Shading 有局部性，只关心每个三角形本身，不关心三角形相互的作用，&lt;/p>
&lt;h1 id="74-blinn-phong-漫反射">7.4 Blinn-Phong 漫反射&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218941.jpg" alt="Lambertian (Diffuse) Shading" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Blinn-Phong 模型中，漫反射的颜色受到三个部分影响&lt;/p>
&lt;ul>
&lt;li>材料的固有色，对应一个系数（可为颜色向量）$k_d$&lt;/li>
&lt;li>反光点和光源的距离光源，距离越远亮度越底，对应于 $𝐼/𝑟^2$&lt;/li>
&lt;li>表面法线与光线的夹角，夹角越大则单位面积能反射的光子理应越少，一旦大过 $𝜋/2$ 则意味着背光，不再漫反射。于是对应于 $𝑚𝑎𝑥(0,𝑛∗𝑙)$&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218956.jpg" alt="Lambertian (Diffuse) Shading" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>仅利用漫反射模型，且单一灰阶的固有色即可渲染出上面的效果。&lt;/p>
&lt;h1 id="81-blinn-phong-高光">8.1 Blinn-Phong 高光&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218968.jpg" alt="Specular Term" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>再考虑高光项。高光对应于镜面反射，摄像机越接近光源的镜面反射的出方向，则应接受到越强的镜面反射光。度量这个“接近度”有一个聪明的比较容易的计算的方法，是比较光源方向和摄像机方向的中间方向（很容易计算）和法线方向的夹角，夹角越大则越不接近。&lt;/p>
&lt;p>且对于这个接近度可以取一个次数 $p$，使整体更容易调整，且接近想要的效果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218981.jpg" alt="Cosine Power Plots" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>$p$ 越高，高亮区域越小。通常而言会用到 100 ～ 200。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218993.jpg" alt="Blinn-Phong" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>加入了高光项后，可以得到上图效果，且可以看出两个参数在调整时对结果的影响。&lt;/p>
&lt;h1 id="82-blinn-phong-环境光">8.2 Blinn-Phong 环境光&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218008.jpg" alt="Ambient Term" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后，对于暗部，并不希望全黑，所以可以加入环境光项，当然，并没有办法保证有光，也不可能环境光处处相同，所以这只是个不符合物理的趋近方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218020.jpg" alt="Blinn-Phong Reflection Model" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后综合 漫反射、高光、环境光 三项后可以得到上图效果。&lt;/p>
&lt;h1 id="83-shading-频率">8.3 Shading 频率&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218034.jpg" alt="Shading Frequencies" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>同样是应用 Blinn-Phong，也可以由于面向对象不同得到不同结果，上方三张图依次对应于&lt;/p>
&lt;ul>
&lt;li>低频：面向三角形&lt;/li>
&lt;li>中频：面向顶点，三角形内部应用重心坐标差值&lt;/li>
&lt;li>高频：面向像素&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218048.jpg" alt="Shade each triangle" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>面向三角形的 Shading 计算量最小。但对于不够高面又光滑曲面的物体而言会不再光滑。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218063.jpg" alt="Shade each vertex" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对顶点着色，并应用差值：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218076.jpg" alt="Shade each pixel" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对每个像素着色。这里的 Phong Shading 对应于着色频率，而非 Blinn-Phong 着色模型。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218088.jpg" alt="Shading Frequency: Face, Vertex or Pixel" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这几种着色频率对应足够高面的模型而言表现是近似的。所以如果足够多面，应优先选择更低频的着色方式，减少计算量。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218101.jpg" alt="Defining Per-Vertex Normal Vectors" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对逐顶点着色而言，是需要获得顶点的法线的。可以采用相邻三角形法线的简单平均，或者根据三角形面积加权平均。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218115.jpg" alt="Defining Per-Pixel Normal Vectors" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对逐像素着色而言，则需要获得每个像素的法线方向，通常使用自己和附近面的法线用一些方式加权平均。&lt;/p>
&lt;h1 id="84-渲染管线">8.4 渲染管线&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218127.jpg" alt="Graphics Pipeline" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>将一次渲染分成几步，大部分集成在 GPU 内部，成为硬件逻辑。部分可以编程。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218141.jpg" alt="Graphics Pipeline" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>比如一开始先处理顶点（等效于处理三角形，因为三角形被顶点决定）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218155.jpg" alt="Graphics Pipeline" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218170.jpg" alt="Rasterization Pipeline" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对片面的测试和处理（也可以算作光栅化的一部分）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218182.jpg" alt="Graphics Pipeline" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Shading 根据不同着色频率可以对应至这两个步骤。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218196.jpg" alt="Graphics Pipeline Texture mapping" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>纹理映射也属于 Shading 一部分：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218210.jpg" alt="Snail Shader Program" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>纯靠 Shader 代码 800 行绘制出蜗牛。&lt;/p>
&lt;h1 id="85-纹理映射">8.5 纹理映射&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218226.jpg" alt="Visualization of Texture Coordinates" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>将二维的表面和一张二维的图逐点一一对应：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218243.jpg" alt="Texture can be used multiple times!" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些纹理是可以上下左右拼接的，做到重复利用。&lt;/p>
&lt;h1 id="91-三角形重心坐标">9.1 三角形重心坐标&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218256.jpg" alt="Interpolation Across Triangles" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218272.jpg" alt="Barycentric Coordinates" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用对面三角形面积占比计算：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218290.jpg" alt="Barycentric Coordinates: Formulas" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="92-应用纹理">9.2 应用纹理&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218306.jpg" alt="Texture Magnification - Easy Case" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>直接采样，又会有锯齿问题。可以通过双线性插值(Bilinear)一定程度解决。当然还可以用 Bicubic 三阶差值（取周围 16 个点），得到更好的效果：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218322.jpg" alt="Bilinear Interpolation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>双线性插值的方法：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218336.jpg" alt="Point Sampling Textures" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当纹理过大也会有问题，问题源自一个像素对应了纹理上太多像素：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218351.jpg" alt="Screen Pixel &amp;amp;ldquo;Footprint&amp;amp;rdquo; in Texture" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218367.jpg" alt="Will Supersampling Do Antialiasing?" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>超采样可以解决，但计算量过大：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218380.jpg" alt="Mipmap" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Mipmap 是一种对贴图进行预处理后很好的一种方式：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218393.jpg" alt="Visualization of Mipmap Level" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>使用 Mipmap 的情况下，如果直接为每个像素点指定一个层级，会让过渡比较硬。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218408.jpg" alt="Trilinear Interpolation" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以用相邻两个层级进行线性插值：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218421.jpg" alt="Visualization of Mipmap Level" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>得到更好的结果：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218434.jpg" alt="Mipmap Limitations" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>不过 Mipmap 依旧不能解决这个问题：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218448.jpg" alt="Irregular Pixel Footprint in Texture" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这是由于 Mipmap 擅长解决正方形的采样，但不擅长非正方形的采样：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218461.jpg" alt="Anisotropic Filtering" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以后来还有 Ripmaps 可以支持任意正放的长方形采样，还有 EWA 更加复杂，但可以支持把任意形状分成多个圆形。但也意味着多次查询需要的更多开销。&lt;/p>
&lt;h1 id="101-贴图的其他应用">10.1 贴图的其他应用&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218476.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>记录环境光&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218490.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>环境光可以记录在球上，但球的两极会有扭曲，所以一般记录在正方体的表面&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218503.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还可以记录表面相对高度，即凹凸贴图（与法线贴图目标近似，但计算和优势不同）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218517.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>二维上计算法线的方式是查分求导再旋转。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218530.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>三维也类似&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218545.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还可以在处理顶点时事实地改变顶点位置。&lt;/p>
&lt;p>不过这要求模型的精细度足够高，以保证有足够多的顶点可以随贴图改变。目前 Direct X 支持这种情况下动态改变模型的精细度。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218559.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>纹理也可以是 3D 的，甚至是函数化的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218573.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还可以用于预烘培，提前计算一些阴影啥的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172218586.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>或者记录三维信息&lt;/p></description></item><item><title>10-12.Geometry</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/10-12.geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/10-12.geometry/</guid><description>&lt;h2 id="10geometryintroduction">10.Geometry:Introduction&lt;/h2>
&lt;p>由于图形学表现的对象，总需要用几何方法表示或者记录以及检索。所以相关几何知识是必要的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219974.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个复杂的描述对象的例子&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219996.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>几何的隐式表示：&lt;/p>
&lt;ol>
&lt;li>方便查询和检查&lt;/li>
&lt;li>不方便遍历&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219009.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>几何的显式表示&lt;/p>
&lt;ol>
&lt;li>方便遍历、采样&lt;/li>
&lt;li>不方便查询&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219025.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219042.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通过布尔运算组合出复杂形状&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219060.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通过距离函数定义几何表面&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219076.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>距离函数的定义方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219089.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用距离函数进行组合粘连&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219103.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>水平集隐式描述&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219116.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用水平集存储医学数据&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219129.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>利用水平集进行物理模拟&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219143.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>分型&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219157.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>隐式表示的优劣&lt;/p>
&lt;h2 id="11geometrycurves-and-surface">11.Geometry:Curves and surface&lt;/h2>
&lt;h3 id="111-简介">11.1 简介&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219172.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通过 Mesh 定义表面&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219187.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用点云定义物体&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219201.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>常用的 Mesh 文件格式 .obj&lt;/p>
&lt;p>例子中定义了一个正立方体&lt;/p>
&lt;ul>
&lt;li>v 是其各个顶点的坐标&lt;/li>
&lt;li>vn 是其各个面的法线方向（理应只有 6 个面，但由于计算机生成时的精度问题，偶尔会多生成一些）&lt;/li>
&lt;li>vt 记录一些纹理坐标&lt;/li>
&lt;li>f 记录三角形关系，其格式为:
&lt;ul>
&lt;li>第一个顶点的顶点序号/第一个顶点的法线序号/第一个顶点的纹理坐标序号[空格]第二个顶点的顶点序号/…&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219215.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而对于线条，还可能会在动画运动中有用处&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219228.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也在矢量图中有应用&lt;/p>
&lt;h3 id="112-贝塞尔曲线">11.2 贝塞尔曲线&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219241.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>贝塞尔曲线的定义：&lt;/p>
&lt;ol>
&lt;li>会经过起点后终点两个控制点&lt;/li>
&lt;li>起点的速度和起点与第二个点的连线同向，大小成正比&lt;/li>
&lt;li>终点的速度和倒数第二个点与终点的连线同向，大小成正比&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219254.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>二次（三个控制点）贝塞尔曲线的一种显式画法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219269.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>三次（四个控制点）贝塞尔曲线的一种显式画法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219283.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>任意次的贝塞尔曲线画法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219296.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>贝塞尔曲线的一些性质，特别是有包围盒性质：曲线一定位于控制点所在的凸多边形内&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219310.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>多个贝塞尔曲线相连&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219324.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>𝐶1 连续，即函数连续、且导数连续&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219337.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其他类型的线条：Spline，会通过控制点且固定阶导数连续&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219350.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>B 样条&lt;/p>
&lt;h3 id="113-贝塞尔曲面">11.3 贝塞尔曲面&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219362.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219376.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219389.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>相当于对点阵，基于行（或列）先计算一个方向的贝塞尔曲线，再基于计算出的几条曲线从列（或行）再计算一个贝塞尔曲线。&lt;/p>
&lt;p>两次即可得到一个贝塞尔平面。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219402.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>具体的 16 个点的贝塞尔曲线插值计算方式。&lt;/p>
&lt;h2 id="12geometryothers">12.Geometry:Others&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219416.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>介绍自动升降面数和正规化模型的算法&lt;/p>
&lt;h3 id="121-subdivision">12.1 Subdivision&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219431.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>LOOP(名称，不是循环的意思)细分的方法。&lt;/p>
&lt;p>简单而言分为两步：&lt;/p>
&lt;ol>
&lt;li>创建更多的三角形&lt;/li>
&lt;li>调整三角形的顶点位置&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219444.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>首先基于每个三角形的边中点，将任一三角形细分为四个。&lt;/p>
&lt;p>但仅仅细分三角形是不会在视觉上产生差异的。&lt;/p>
&lt;p>需要再调整各个顶点的位置。&lt;/p>
&lt;p>对新的顶点和老的顶点的位置更新算法略有不同。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219456.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>新顶点的调整算法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219471.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>老顶点的调整算法。看起来会相对复杂一些，但核心思路就是基于自己和与自己相临的其他老顶点的高度进行加权平均。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219485.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后达到如上图的细分效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219497.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Catmull-Clark 细分，是与 LOOP 细分不同的另一种细分方法。&lt;/p>
&lt;p>其主要针对于不全是由三角形构成的 Mesh。&lt;/p>
&lt;p>考虑四边形为正常的几何结构。四边形细分非常容易，取中点连线再加权即可。&lt;/p>
&lt;p>主要问题是处理三角形结构。&lt;/p>
&lt;p>三角形一定会成对出现，有三角形存在的地方一定存在两个度非 4 的顶点。&lt;/p>
&lt;p>将顶点根据其度区别为正常顶点和奇异顶点（度非 4 的顶点），奇异顶点一定会成对出现，其连线会将一个四边形划分为两个三角形，此时为这两个三角形每个补充一个顶点（补充的也将是奇异顶点）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219511.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>并如图连接，达到细分的效果。&lt;/p>
&lt;p>且可以发现，细分之后全部都是四边形，不再存在三角形。但奇异点会继续保持为奇异点。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219525.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还可以进一步细分下去&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219540.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其顶点的更新算法。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219554.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>两种算法的效果&lt;/p>
&lt;h3 id="122-mesh-simplification">12.2 Mesh Simplification&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219568.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>区别于细分，Mesh 简化也是常见的需求。&lt;/p>
&lt;p>特别对于游戏，实时渲染需要控制场景的总面数，一种合理的策略是让较远的物体面数偏低，近处的物体面数偏高。&lt;/p>
&lt;p>为进一步提升实时性，通常需要同时保存多级模型，即 LOD。分级的过程能自动化则远比手动调整效率高。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219585.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为达到这个目的，边坍缩是一种容易想到的方式。即把相邻的两个点压缩到一起&lt;/p>
&lt;p>但实际操作中这个方法并不容易，因为其面临一些隐藏问题：&lt;/p>
&lt;ol>
&lt;li>坍缩哪些边？理应优先坍缩不重要的边，但哪些边是不重要的呢？&lt;/li>
&lt;li>坍缩后的顶点位置也不应该是平均值位置，如图而言讲道理需要高一些，但如何描述呢？&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219606.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>度量贡献度和寻找最小误差的一个方法是二次误差度量法。&lt;/p>
&lt;p>核心思路非常类似于线性回归的误差度量。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219621.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>基于二次误差度量，就可以寻找坍缩代价最小的边，用代价最小的坍缩方式进行坍缩。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219638.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>基于二次误差度量进行简化的效果&lt;/p>
&lt;h3 id="123-shadow-mapping">12.3 Shadow Mapping&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219652.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>光栅化由于其局部性问题，想直接实现阴影效果是不行的，需要一些额外的方法。&lt;/p>
&lt;p>Shadow Mapping 就是这样的一种普遍的处理方式。不过 Shadow Mapping 只能处理点光源的问题，但对一般的游戏而言通常是足够的。&lt;/p>
&lt;p>核心思路是：阴影是那些能直达摄像机，但不能直达光源的像素点。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219668.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>因此，可以首先将摄像机放在光源位置，看看哪些点能被光源直接照亮。&lt;/p>
&lt;p>但记录哪些点可以被照亮是一件很难的事情，因为点是可以无限稠密的。&lt;/p>
&lt;p>所以一种方式是进行一次深度图渲染。用于保存光源看到的深度信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219681.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>接着，再从眼睛的位置看向场景，渲染每个像素时，计算其在之前光源的深度图中的像素位置，并对比眼睛看到的点的光源深度和之前记录的光源深度。&lt;/p>
&lt;p>如果两者深度一致则意味着这个点可以被光源照亮，否则不能被光源照亮。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219695.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个场景的例子&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219708.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Shadow Mapping 之后的阴影对应的深度图映射在眼睛视角上的效果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219721.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219735.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>使用 Shadow Mapping 的游戏&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172219749.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但由于 Shadow Mapping 只能处理点光源。于是只能得到硬阴影。而现实世界的光源往往是面光源，因而通常是软阴影，这使 Shadow Mapping 一定程度上不够真实。&lt;/p>
&lt;p>要处理这个问题则需要光追算法。&lt;/p></description></item><item><title>13-15.Ray Tracing</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-15.ray-tracing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-15.ray-tracing/</guid><description>&lt;h2 id="13ray-tracing-1">13.Ray Tracing 1&lt;/h2>
&lt;h3 id="131-ray-tracing-introduction">13.1 Ray Tracing Introduction&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221359.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>使用光线追踪目的自然是为了解决光栅化做得还不够好的一些问题。&lt;/p>
&lt;p>由于光栅化的算法原理，有很多表现上的限制，比如：&lt;/p>
&lt;ol>
&lt;li>无法表现真实的软阴影&lt;/li>
&lt;li>无法表现毛玻璃等粗糙的反射效果&lt;/li>
&lt;li>无法表现非直接光照（只能用全局光照代替）&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221388.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以对比起来，光栅化快，但是效果差。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221405.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而光线追踪速度慢，但是效果好&lt;/p>
&lt;h3 id="132-basic-ray-tracing-algorithm">13.2 Basic Ray Tracing Algorithm&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221422.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对光线有一些基本性质的假设（和真实光仍略有区别）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221437.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>曾经很多人以为眼睛能看到东西，是类似于蝙蝠一般，由眼睛发射出“感知光线”，并且此理论被很多名人或哲学家支持。&lt;/p>
&lt;p>现在来看，这种理论虽然有问题，但基于图形学中的“光路可逆性”而言，为了效率，渲染时采取的方法正是从摄像机发出“感知光线”进行渲染。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221450.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Ray Casting 方式就是从摄像机，沿每个像素发射出感知光线，并考虑其是否能被光源照亮，可以的话则计算着色。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221464.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对于一个场景而言，则需要找“感知光线”达到的第一个面&lt;/p>
&lt;h3 id="133-whitted-style-ray-tracing">13.3 Whitted-Style Ray Tracing&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221479.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>将光线进行多次的弹射或折射。即是 Whitted 光线追踪。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221492.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>每次弹射或者折射出新光线后，当新光线碰撞到某个面之后，再基于光源进行着色，并考虑损耗，最后加和到最初的像素点。&lt;/p>
&lt;p>总之就是在模拟光线传播的过程。&lt;/p>
&lt;p>但这个过程理解容易，但在实现时会有不少技术问题，下面依次结果&lt;/p>
&lt;h3 id="134-ray-surface-intersection">13.4 Ray-Surface Intersection&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221507.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>首先定义光线为一根射线&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221521.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>相交意味着两个方程有解&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221535.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>射线和球的交点是比较好求的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221549.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>进一步推广到射线和其他表面的交点。求解通常用数值的方式，不需要把表达式求出来即可得到数值结果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221563.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如果对于一个 Mesh 物体，则需要判断光线与各个三角形的交点。&lt;/p>
&lt;p>这又有两个明显的问题：&lt;/p>
&lt;ol>
&lt;li>如何求射线与三角形的交点&lt;/li>
&lt;li>一个场景，甚至一个 Mesh 都可能有非常多的三角形，每次光线折射都需要全部求一次计算量过大，如何优化&lt;/li>
&lt;/ol>
&lt;p>首先，对于第一个问题，可以进一步分解成两步：&lt;/p>
&lt;ol>
&lt;li>求射线与三角形所在平面的交点&lt;/li>
&lt;li>判断交点是否在三角形内部&lt;/li>
&lt;/ol>
&lt;p>第二个问题则主要诉诸数据结构中的搜索树，以优化查询复杂度，详见后文&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221581.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>先求射线与三角形平面的交点，再求交点的重心坐标，根据坐标的正负性判断在三角形内或外，这是常用的思路。&lt;/p>
&lt;p>而 Moller Trumbore 是一种简化后可快速求射线与三角形所在平面交点的重心坐标的方法&lt;/p>
&lt;h3 id="134-accelerating-ray-surface-intersection">13.4 Accelerating Ray-Surface Intersection&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221598.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有些场景的面数非常高，每次都求光线与每个面的交点导致的计算量会非常恐怖。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221611.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一种加速方式是给每个物体加上包围盒。&lt;/p>
&lt;p>碰撞判断时首先判断是否和包围盒碰撞，如果有碰撞再检测和其中的三角形是否碰撞。&lt;/p>
&lt;p>这样可以使没碰撞到包围盒的物体的检测次数降低至一次。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221626.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>包围盒的碰撞检测方式是求射线与三组平行平面的交点&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221640.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对每个平面求得与射线的交点之后进行裁剪（即取解集的交集），以获得最终结果。&lt;/p>
&lt;p>如果裁剪之后没有位于包围盒以内的线段则意味着不相交。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221654.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当射线与与三组平行平面都有相交时，则与包围盒相交。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221669.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由于是求射线与平面的交点而不是直线与平面，所以需要考虑解的符号，进行特殊判断。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221684.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>之所以尽可能使用与坐标轴对齐的包围盒主要是为了节省计算量。&lt;/p>
&lt;h2 id="14ray-tracing-2">14.Ray Tracing 2&lt;/h2>
&lt;h3 id="141-uniform-spatial-partitiongrids">14.1 Uniform Spatial Partition(Grids)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221698.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对空间进行均匀的网格划分，将物体注册到所占的空间中的格子。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221712.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>探测时仅检测光线与当前所在格子的物体是否有碰撞即可，减少检测总量。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221726.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>格子过密或者过梳都可能出现问题：&lt;/p>
&lt;ol>
&lt;li>过密导致检测总量依旧偏多，需要花费大量计算于格子的定位和检测&lt;/li>
&lt;li>过梳则导致一个格子包含太多物体，可能和不划分格子没有差异&lt;/li>
&lt;/ol>
&lt;p>所以一个经验公式是：格子的数量=27*物体数量&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221741.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>网格优化方式对于物体较小且分布较均匀的场景比较有效。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221755.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但对于物体大小差异很大的场景则优化效率非常有限，甚至反而增加计算总量&lt;/p>
&lt;h3 id="142-spatial-partitionstrees">14.2 Spatial Partitions（Trees）&lt;/h3>
&lt;p>于是另一种方式是非均匀的空间划分&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221769.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对此也有几种划分方式，本质都是构建搜索树：&lt;/p>
&lt;ol>
&lt;li>八叉树对空间均匀划分，且在某种条件下停止划分（比如格子里的物体小于等于 1 个）
&lt;ul>
&lt;li>缺点是在一些应用中需要对高维空间进行划分，会导致每次划分出 2𝑛 个子节点，略爆炸，所以一般不倾向于用八叉树。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>KD-Tree 对空间进行动态的二分划分
&lt;ul>
&lt;li>每次轮流沿 xy、yz、zx 平面（可以相对均匀）对空间进行一次划分，不需要均分。整个结构类似于二叉树。且可以通过算法找比较好的划分位置，使物体尽可能少地跨越多个格子&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>BSP-Tree 类似 KD-Tree 的二分方法，但允许不延轴向平面。&lt;/li>
&lt;/ol>
&lt;p>在图形学中 BSP-Tree 会导致判断时计算量相对于 KD-Tree 更高(前面的 AABB 判断)，所以一般更倾向于使用 KD-Tree。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221783.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>KD-Tree 的处理即不断循环找一个轴向平面对空间进行划分。得到一个二叉树。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221797.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其数据结构如上&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221812.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>碰撞检测时，用类似 AABB 的方式不断求交定位节点，如果有子节点则进一步求交即可。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221826.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后找到叶子节点中的物体进行相交判断，得到最终结果。&lt;/p>
&lt;h3 id="143-object-partitionbounding-volume-hierarchy">14.3 Object Partition:Bounding Volume Hierarchy&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221841.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对三角形集的包围盒进行对象划分，每次也划分出两块，得到一棵二叉树。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221859.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对一个节点进行多次划分的情况&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221873.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>划分的过程总结&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221887.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>每次划分的一些原则&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221902.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>BVH 的数据结构&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221916.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对空间划分和对对象两种方式性质的比较&lt;/p>
&lt;h3 id="144-radiometrymotivation">14.4 Radiometry:Motivation&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221930.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如果想使渲染效果尽可能地符合现实世界。&lt;/p>
&lt;p>则需要研究现实世界的光的性质和传播原理。&lt;/p>
&lt;p>也由此需要学习辐射度量学。&lt;/p>
&lt;h3 id="145-radiometryenergy-and-flux">14.5 Radiometry:Energy and Flux&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221944.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Radiant 是辐射能量&lt;/p>
&lt;p>Radiant Flux 是辐射强度，单位为瓦特。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221959.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Radiant Flux 也可以理解为单位时间通过单位平面的光子数量。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221974.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>三种复合的光线度量：&lt;/p>
&lt;ol>
&lt;li>Radiant Intensity：一个光源的辐射强度（单位 坎德拉 Candela 或 流明/单位角）
&lt;ul>
&lt;li>度量某角度上的 Radiant Intensity 有一个单位是 流明=坎德拉*球面度。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Irradiance：一个点接受的辐射强度（单位：流明/平方米）&lt;/li>
&lt;li>Radiance：一根线上的辐射强度（单位：nit 或 流明/单位角/平方米）&lt;/li>
&lt;/ol>
&lt;h3 id="146-radiometryradiant-intensity">14.6 Radiometry:Radiant Intensity&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221999.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221017.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>立体角的定义或计算方式。（这也可以看出弧度相对于角度的好处：可以容易地往高维推广）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221036.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>立体角的微元，即球面的微元&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221054.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>完整空间的立体角即单位球的表面积 4𝜋&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221079.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>因此对于一个各向同性的点光源而言：&lt;/p>
&lt;p>Radiant Flux=Radiant Intensity * 4𝜋&lt;/p>
&lt;p>或者 Radiant Intensity = Radiant Flux / 4𝜋&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221098.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而 Radiant Flux 对应度量单位 Lumen（流明）。由此可知一个 815 流明的灯，如果向各个方向辐射的强度一致，其 Radiant Intensity 即 65 坎德拉。&lt;/p>
&lt;h3 id="151-radiometryirradiance">15.1 Radiometry:Irradiance&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221117.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Irradiance 即辐射强度在面积上的强度&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221135.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>基于此可以容易知道在光栅化的 Lambert 渲染方式中 cos 的物理意义。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221153.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>同时一个杂知识：春夏秋冬温度变换不是由于地球公转离太阳远近，而是由于地球自转轴相对于黄道平面的偏角导致南北半球随公转接受的 Irradiance 也跟着变化，进而有了春夏秋冬。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221171.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Irradiance 是会随着距离平方反比进行衰减的（即使不考虑介质吸收的能量）&lt;/p>
&lt;h3 id="152-radiance">15.2 Radiance&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221188.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Radiance 是描述光线在环境中传播最基础的量。&lt;/p>
&lt;p>渲染基本上就是在计算 Radiance&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221204.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Radiance 是 Radiant Intensity 在面积上的微分&lt;/p>
&lt;p>Radiance 也是 Irradiance Intensity 在球面角上的微分&lt;/p>
&lt;p>其单位为 nit&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172221228.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item><item><title>17.Materials and Appearances</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/17.materials-and-appearances/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/17.materials-and-appearances/</guid><description>&lt;h2 id="17materials-and-appearances">17.Materials and Appearances&lt;/h2>
&lt;h3 id="171-appearances">17.1 Appearances&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223541.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>现实世界中的光影材质非常多样和复杂。&lt;/p>
&lt;p>比如光可能会在光路上和微粒碰撞漫反射出一条光路。&lt;/p>
&lt;p>比如头发的丝质感，和微透明的感觉。&lt;/p>
&lt;p>比如布料的纹理通常甚至需要考虑到其针织的方式。&lt;/p>
&lt;p>日出的双彩虹现象。&lt;/p>
&lt;p>还比如三文鱼肉的次表面反射。&lt;/p>
&lt;p>等等&lt;/p>
&lt;h3 id="172-material">17.2 Material&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223565.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们可以为一个模型指定不同的材质。&lt;/p>
&lt;p>在渲染方程中，决定材质的正是 BRDF&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223583.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个应用不同的 BRDF 的例子&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223602.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个各向同性的点，接受的光和漫反射的光能量一致，可以根据能量守恒计算出其 BRDF 系数为 1/𝜋&lt;/p>
&lt;p>所以要自然地定义一个漫反射点的反射系数，其值应该位于 [0,1/𝜋]&lt;/p>
&lt;p>通常把这个值称为 albedo&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223617.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而这种靠近镜面反射，但又综合了漫反射性质的毛金属材质&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223638.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还有的材质可以折射透过表面，达到玻璃效果。&lt;/p>
&lt;h3 id="173-reflection">17.3 Reflection&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223652.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由入射光方向，计算镜面反射的出射的方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223666.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个镜面反射的例子&lt;/p>
&lt;h3 id="174-refraction">17.4 Refraction&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223681.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>折射的一些例子，偶尔需要对不同波长的光采用不同的折射率以模拟散射&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223695.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>高中物理中的折射定律&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223714.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>折射定律，且当入射角过大则不再有折射而发生全反射&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223731.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个全反射的例子：在泳池中往上看，只有正中一块区域能看到外部。周围都只会反射而不再能看到水面以上。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223746.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>菲涅尔反射现象：入射光与法线角度越大越容易反射&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223762.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>绝缘体的菲涅尔项的大致走势&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223777.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>导体的菲涅尔项的大致走势&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223795.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>菲涅尔项的一个常用近似函数&lt;/p>
&lt;h3 id="175-microfacet-material">17.5 Microfacet Material&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223810.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>同样的物体在不同的 Scale 下表现差异可能很大。比如海面波涛汹涌，但远看几乎光滑。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223831.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>因此光滑或者粗糙等性质其实是相对的，需要基于尺度。即使是人们用的镜子，放大看依旧是粗糙不堪的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223852.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>或者体现在反射方向的分布方差越小，视觉上越光滑&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223868.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也是因此有菲涅尔项，因为通常越是斜着看，表面的凹凸越容易被相互遮挡而隐藏，留下相对光滑的表现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223884.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些精细建模并渲染的例子&lt;/p>
&lt;h3 id="175-isotropic">17.5 Isotropic&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223897.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>各向异性的例子。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223913.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>源自于其材料在微观上表现有方向上的明显差异&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223929.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>各项异性的 BRDF&lt;/p>
&lt;p>由于对于这种材质需要考虑入射光和出射光关于材质本身的旋转角度，所以需要额外增加一维进行描述其 BRDF&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223942.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>设置这类材质时需要考虑其生产或打磨的方式。比如锅是旋转拉丝制作的，所以其纹路呈环状&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223956.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>尼龙由于其制作方式是织，导致 90 度和 45 度视角下表现有差异，虽然整体已经稍接近各向同性&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223969.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但天鹅绒，由于其局部的毛可能一起朝向一个方向，使其各向异性非常明显。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223984.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>天鹅绒沙发的各向异性非常明显&lt;/p>
&lt;h3 id="176-properties-of-brdfs">17.6 Properties of BRDFs&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223999.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>非负性和可加性&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223015.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可逆性和能量守恒性&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223033.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>前文的各向同性或各向异性&lt;/p>
&lt;h3 id="177-measuring-brdfs">17.7 Measuring BRDFs&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223052.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>物理上的一些材质性质和人工模拟的差别有可能很大。&lt;/p>
&lt;p>所以用测量的方式可以更好地确定目标物体的性质，以达到更好的渲染结果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223068.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>测量方式即遍历入射角和出射角&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223084.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个实际的测量机器&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223102.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由于枚举入射和出射方向，数据量是四维的，量很恐怖，有一些方式可以略减少测量数据量&lt;/p>
&lt;p>比如如果材质是各项同性的，则可以利用对称性，少测量一个维度。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223120.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>测量 BRDF 的一些挑战&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223137.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>保存或表示 BRDF 的方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172223155.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个 BRDF 的数据库:MERL BRDF Database&lt;/p></description></item><item><title>18.Advanced Topics in Rendering</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/18.advanced-topics-in-rendering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/18.advanced-topics-in-rendering/</guid><description>&lt;h2 id="18advanced-topics-in-rendering">18.Advanced Topics in Rendering&lt;/h2>
&lt;h3 id="181-advanced-light-transport">18.1 Advanced Light Transport&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222201.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>无偏光线传播方法：BDPT、MLT&lt;/p>
&lt;p>有偏光线传播方法：光子映射、VCM&lt;/p>
&lt;p>实时路径追踪方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222231.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有偏性、一致性说明&lt;/p>
&lt;h3 id="182-bidirectional-path-tracing">18.2 Bidirectional Path Tracing&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222249.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>从光源和摄像机分别出一些光线并连接在一起&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222268.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对于主要由间接光照照亮的场景而言，双向路径追踪的效率会高于单向路径追踪&lt;/p>
&lt;h3 id="183-metropolis-light-transport">18.3 Metropolis Light Transport&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222283.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Metropolis 是人名而非大都市&lt;/p>
&lt;p>基于马尔可夫链的采样方式，由上一个采样样本生成下一个新样本，进行估计函数值。&lt;/p>
&lt;p>这种方式可以使采样的分布和实际 pdf 的分布一致，保证方差比较小，收敛效率比较高。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222297.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对于复杂的场景渲染效果很好。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222310.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但这个方法也有坏处，主要是不好估计什么时候会没有噪声。&lt;/p>
&lt;p>并且，各个点的收敛率不同，导致图可能比较脏，以至于还不能应用于动画&lt;/p>
&lt;h3 id="184-photon-mapping">18.4 Photon Mapping&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222324.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>光子映射方法，非常适合于渲染光线聚焦产生特殊图案（caustics 现象）的场景&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222340.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一种实现方式是分成两步：&lt;/p>
&lt;ol>
&lt;li>先打出光子，并停在漫反射物体上&lt;/li>
&lt;li>第二步从视角出发打到表面上&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222358.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对局部进行密度估计，值越高则越亮&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222372.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但这种方法的关键是取光子数量，数量太少会噪声，数量太大会糊&lt;/p>
&lt;p>仅当光子数量非常多之后才能接近正确结果。&lt;/p>
&lt;p>所以是有偏但是一致的方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222386.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>渲染中直观地理解有偏和一致的方法是：&lt;/p>
&lt;ol>
&lt;li>如果糊则有偏&lt;/li>
&lt;li>如果无限时不糊则一致&lt;/li>
&lt;/ol>
&lt;h3 id="185-vertex-connection-and-merging">18.5 Vertex Connection and Merging&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222400.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>结合了光子映射和双向路径追踪的思路，不让任何一个路径被浪费，最后表现也不错&lt;/p>
&lt;h3 id="186-instant-radiosity">18.6 Instant Radiosity&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222414.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>将被照亮的表面也当作光源，并取上面的一些点作为虚拟点光源&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222429.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在有的场景中效果不错&lt;/p>
&lt;p>但偶尔会有亮点，主要因为面积估计时偶尔会以一个极近的距离，导致最后除下来亮度非常高&lt;/p>
&lt;h3 id="187-advanced-appearance-modelingintoduction">18.7 Advanced Appearance Modeling:Intoduction&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222442.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对一些材质用真实微观建模的方式表现和渲染&lt;/p>
&lt;h3 id="188-participating-media">18.8 Participating Media&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222456.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>比如对于散射介质：雾&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222477.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222492.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用一个相位函数来表达其散射方式&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222506.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>光线和体积进行作用最后到达眼睛&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222521.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>散射介质超能特工队中的应用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222536.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>散射介质在刺客信条中的应用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222552.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>即使是巧克力也会有一些光线会进入体积内再穿透出来&lt;/p>
&lt;p>人的皮肤也是如此&lt;/p>
&lt;h3 id="189-participating-mediahair">18.9 Participating Media:Hair&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222566.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>头发也是这样的例子&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222582.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以仅仅把头发当成一个圆柱并只考虑一次反射&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222596.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但这样得到的效果并不算非常好&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222610.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而当进一步把头发当成一个可被穿透的圆柱&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222626.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>考虑直接反射(R)，折射再折射(TT)，折射反射再折射(TRT)三种光线&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222640.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>便能得到非常不错的结果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222654.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最终幻想里，头发建模的应用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222669.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>疯狂动物城中头发建模的应用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222684.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>事实上，人类的头发和动物的毛发也是不同的，直接套用也会使结果显得不那么自然&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222698.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这是由于人类和动物毛发中 Medulla 占比不一致导致的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222719.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个改变 Medulla 得到不同结果的例子。可见微观性质差异有时候对宏观的影响也是非常显著的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222734.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>考虑 Medulla 后对头发渲染的影响&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222748.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用双圆柱模拟含 Medulla 的头发模型&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222762.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>几种光线作用后的效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222776.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>巨量的建模细节和采样率&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222791.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>双层圆柱毛发模型在猩球崛起中的应用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222805.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>双层圆柱毛发模型在狮子王中的应用&lt;/p>
&lt;h3 id="1810-granular-material">18.10 Granular Material&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222821.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Granular Material 的一些例子&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222836.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222850.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Pixar 应用 Granular Material 的动画短片&lt;/p>
&lt;h3 id="1811-translucent-material">18.11 Translucent Material&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222864.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>玉&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222880.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>次表面反射&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222895.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>描述次表面反射需要对渲染方程增加额外一个维度&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222910.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Dipole 有一种模拟的近似方案是在表面下方加入一个光源，模拟次表面反射的效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222925.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>仅用表面反射表现大理石&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222939.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>加入次表面反射后的大理石&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222954.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>是否有考虑次表面反射的皮肤效果对比&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222970.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>BSSRDF 渲染出的三个人物，非常接近真实照片&lt;/p>
&lt;h3 id="1812-cloth">18.12 Cloth&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222984.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>理解布料需要从其层级结构说起&lt;/p>
&lt;p>首先由纤维(Fibers) 相互缠绕，形成股(Ply)&lt;/p>
&lt;p>再由股(Ply)相互缠绕，形成线(Yarn)&lt;/p>
&lt;p>最后线再通过不同的纺织方式，最后得到布料&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222999.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>各种不同的编织方式会得到不同的布料效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222014.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当然，也可以把布料当作一个表面取渲染。但效果经常是有限的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222029.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以一种更复杂但表现效果好的方式是真实地把布料建模成有体积有纺织方式的空间物体，再进行渲染，可以得到非常好的效果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222044.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>甚至把纤维细节都给建模出来进行渲染&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222059.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>布料在电影中的一些应用&lt;/p>
&lt;h3 id="1813-detailed-appearance">18.13 Detailed Appearance&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222080.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>渲染出的车和鼠标都略有不真实的感觉&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222098.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>主要是由于现实中的这些物体都不会太完美，表面应有划痕等等&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222114.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>没有细节的水壶&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222130.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>对比有细节的水壶&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222146.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>统计学上的正态分布和实际的正态分布是有区别的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222162.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以加入噪声函数去影响表面&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222177.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当然，要达到那种细节刻画度，会非常难以渲染&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222193.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>并且也主要难在有效采样&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222209.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一种优化方式是把对应反射区域的法线分布给算出来，作为近似&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222225.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>不同尺度下，这个近似的差异有可能比较大，尺度越大通常越平滑，尺度越小通常越有特征&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222241.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些特殊的发现贴图采样后分布也会呈现不同的性质&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222257.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这种算法线分布方法进行渲染的一些应用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222274.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222293.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="1814-wave-optics">18.14 Wave Optics&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222309.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当对于微观时，如果进一步考虑光波的性质则会出现一些新的问题，比如光波会衍射等等&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222326.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>比如照一个拉丝过的金属表面，会看见有很多颜色&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222343.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如 Macbook 放大后也是非白色，会有很多彩色的点&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222359.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>要处理的话需要考虑光的波动方程，并在复数域上积分&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222377.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>非常复杂，但一旦做出来，能够得到很接近照片的效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222393.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>放大看&lt;/p>
&lt;h3 id="1815-procedural-appearance">18.15 Procedural Appearance&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222411.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用噪声函数去随用随取地表达空间中任一一点的纹理参数&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172222429.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>噪声函数生成纹理的实例&lt;/p></description></item><item><title>19-20.Cameras, Lenses and Light Fields</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/19-20.cameras-lenses-and-light-fields/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/19-20.cameras-lenses-and-light-fields/</guid><description>&lt;h2 id="19cameraslenses-and-light-fields">19.Cameras,Lenses and Light Fields&lt;/h2>
&lt;h3 id="191-camera">19.1 Camera&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225547.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>相机或眼睛用类似凸透镜的成像本质和小孔类似，但相比于小孔成像，透镜能聚焦更多光子&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225575.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>相机的感光元件记录的是 Irradiance，因此必须要有小孔或者透镜，否则会直接糊掉&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225592.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>小孔成像虽然光子少但是效果也不一定差&lt;/p>
&lt;h3 id="192-field-of-view">19.2 Field of View&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225613.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>同样大小的感光片情况下，焦距越小，视角越大&lt;/p>
&lt;p>同样的焦距下，感光片越大视角越大&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225629.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>相机焦距和视角的关系（且统一使用 36*24mm 的底片为计算标准，非标准底片需要相应折算）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225648.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这是调焦距可以调整画面“远近”的原因，但并非真实的“远近”，和把相机放近后拍照得到的透视关系有区别&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225663.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>感光器的大小区别&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225676.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="193-exposure">19.3 Exposure&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225689.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>显然，每个感光元件在一次曝光情况下接受的能量=时间*irradiance&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225702.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通常有三种方式可以调整曝光度：光圈大小、快门速度、ISO&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225715.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>用这三种方式调整会有各自的特征和利弊&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225728.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>ISO 由于是直接对数据进行放大，自然也会放大噪声。所以通常不倾向采用这种调整方式&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225746.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>调整光圈大小，且通常用 FN 来表示，其中 N 和光圈直径呈反比&lt;/p>
&lt;p>调整光圈还会影响景深效果：光圈越小精深效果越弱。恰如近视眼虚眼看东西会清晰一些的原理&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225759.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>快门速度可能导致运动模糊&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225773.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但运动模糊并不一定不好，很多时候反而是有更好，比如电影和游戏&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225787.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>快门由于是机械式，开关有一个过程，所以拍摄高速物体时可能产生畸变&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225800.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为达到相同的曝光度，在不调整 ISO 的情况下需要相反地调整快门速度和光圈&lt;/p>
&lt;p>所以可能要么牺牲一些景深，要么产生一些运动模糊，需要在这两者间根据照片目标效果进行平衡取舍&lt;/p>
&lt;h3 id="194-fast-and-slow-photography">19.4 Fast and Slow Photography&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225813.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>极高的快门速度，于是一般需要配合极大的光圈或者高 ISO&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225827.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>长曝光效果&lt;/p>
&lt;h3 id="195-thin-lens-approximation">19.5 Thin Lens Approximation&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225840.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在实际工业界，由于很多场景下空间不可能达到焦距要求的长度，通常使用多个镜片组合模拟出单凸透镜的效果。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225853.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>事实上很多情况下镜片聚焦也不在一个点上&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225865.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但我们通常只考虑最理想的透镜&lt;/p>
&lt;h3 id="196-defocus-blur">19.6 Defocus Blur&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225878.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>失焦模糊的原理。并由此产生景深&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225890.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225903.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>光圈大小对于景深的影响&lt;/p>
&lt;h3 id="197-ray-tracing-ideal-thin-lenses">19.7 Ray Tracing Ideal Thin Lenses&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225916.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由此在渲染中也可以根据这样的性质，主动建模出一个透镜和感光片（用以代替普通光线追踪的小孔成像模型）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225929.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>并渲染出带景深效果的渲染图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225942.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由于实际的相机是有像素是离散的，可以如上考虑一个像素大小的景深模糊情况。&lt;/p>
&lt;h2 id="20color-and-perception">20.Color and Perception&lt;/h2>
&lt;h3 id="201-light-field">20.1 Light Field&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225956.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们看到场景是因为场景有光发射向我们的眼睛&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225969.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但如果一个屏幕能够模拟屏幕后方所有光矢，则理应让我们无法分辨真假，真裸眼 3D&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225983.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>记录一个点在一个时刻的广场，需要三个参数：&lt;/p>
&lt;ol>
&lt;li>两维记录视角&lt;/li>
&lt;li>一维记录波长&lt;/li>
&lt;/ol>
&lt;p>最后用函数记录这个视角下这个波长的光的能量&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225000.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如果要记录全时全局的广场，则需要额外再增加一维时间，和三维坐标，一共七维进行记录&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225013.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有了它我们可以重建任意画面&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225030.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如果对于一个有限的区域，则只需要一个盒子，和盒子上每一点的光场信息即可复刻&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225043.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为此一种痛常的做法是用两个平面，记录单平面光场，不考虑时间和光波长的话，刚好是 4 维&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225058.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这是一个光场采样的实例&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225072.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>斯坦福的光场采集阵列&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225086.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>生物的复眼，本质也是一个光场相机&lt;/p>
&lt;h3 id="202-light-field-camera">20.2 Light Field Camera&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225100.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>已经商业化量产的光场相机&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225113.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>光场相机的每个像素都是一个相机&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225128.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>如果我们只想用光场相机拍一张普通照片，则统一取一个方向的光即可&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225146.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当然，光场相机如此牛逼的表现下，也是有极大的代价的&lt;/p>
&lt;h3 id="203-physical-basis-of-color">20.3 Physical Basis of Color&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225160.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可见光的光谱&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225174.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>可以用谱功率密度记录一时刻一束光的性质&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225188.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225203.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些常见的光源的谱功率密度分布&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225217.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>且光是可以线性组合的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225232.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>而颜色只是我们的感知，物理世界并不存在颜色的概念&lt;/p>
&lt;h3 id="204-biological-basis-of-color">20.4 Biological Basis of Color&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225252.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>人眼中的视杆细胞和视锥细胞&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225269.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>三种视锥细胞对光波频率的响应曲线&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225284.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>很神奇的一点是事实上每个人眼中的三种细胞的分布差异极大&lt;/p>
&lt;p>每个人看到世界的感觉极大可能并不相同&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225299.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>视锥细胞响应光波的计算方式&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225314.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>大脑视觉感知的数据就仅仅来自于这些细胞的有限的处理后的信息&lt;/p>
&lt;h3 id="205-metamerism">20.5 Metamerism&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225328.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由于大脑接受到的是视细胞处理后的信号，相对于无穷维的光谱，大脑能接受的仅三维信号。所以是有信息缺失的。&lt;/p>
&lt;p>比如大脑就无法分辨如图的几种广谱，看起来都是一种颜色&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225345.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也是因为这样，显示器调色也只是调出感觉上较一致的光谱，而远非实际的光谱。&lt;/p>
&lt;h3 id="206-color-reproduction-or-matching">20.6 Color Reproduction or Matching&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225364.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>找实验人员来混合 RGB 使其和单光源的光看起来接近&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225379.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但有的时候，靠 RGB 加和，是达不到目标光源的效果的，有可能需要对光源进行补光&lt;/p>
&lt;p>这是则会导致 RGB 中产生负值分量&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225394.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>负值分量在单色光谱谱配中，红色是比较明显的&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225410.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>所以，在 CIE 颜色匹配系统中，采用的是这样的匹配方式&lt;/p>
&lt;h3 id="207-color-spaces">20.7 Color Spaces&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225425.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>我们通常常用的颜色空间 sRGB&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225440.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>科学界常用的人造颜色空间 CIE XYZ&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225455.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>将 XYZ 归一化后可以减少一维，展示出其实际颜色空间&lt;/p>
&lt;p>单一波长光对应的坐标分布在边沿（但粉红边不对应自然中的单波光）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225470.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>其他一些系统的色域则位于中间的一部分&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225488.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>HSV 颜色空间，由于比较直观，在美术工作中比较常用&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225503.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>CIELAB 颜色空间，用三组互补色确立三维颜色空间&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225519.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>颜色是相对的，是感知的实例（视觉白平衡，和蓝金衣服是一个原理）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172225534.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>打印用的减色颜色空间&lt;/p>
&lt;p>理论上只用品红、蓝、黄即可，黑色可以由这三个颜色混合而成。但实际为了节省颜料费用，会单独使用黑色颜料（黑色颜料使用量大，且便宜）。&lt;/p></description></item><item><title>21-22.Animation</title><link>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/21-22.animation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/games101-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/21-22.animation/</guid><description>&lt;h1 id="animation">Animation&lt;/h1>
&lt;h2 id="21animation">21.Animation&lt;/h2>
&lt;h3 id="211-historical-points-in-animation">21.1 Historical Points in Animation&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226596.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>远古时期的壁画，可以连成动图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226627.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>后来可以通过旋转得到动图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226645.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>第一步手绘的完整动画&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226662.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>里程碑式作品&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226678.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>第一个纯计算机渲染的动画，当时还用的是光栅化&lt;/p>
&lt;h3 id="212-keyfram-animation">21.2 Keyfram Animation&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226694.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最早由艺术家绘制关键帧，由助手补上中间的帧&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226709.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>关键帧插值&lt;/p>
&lt;h3 id="213-physical-simulation">21.3 Physical Simulation&lt;/h3>
&lt;p>而现在的动画制作，为了更好的效果往往需要模拟或者仿真&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226724.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226739.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>布料仿真&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226753.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>流体仿真&lt;/p>
&lt;h3 id="214-mass-spring-system">21.4 Mass Spring System&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226768.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226784.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226799.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>模拟的布料，建模得足够好之后非常接近真实效果&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226814.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个简单的质点弹簧模型&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226829.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>带静态长度的弹簧&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226844.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>带能量损失的弹簧，摩擦力与质点速度相反&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226859.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>增加与相对速度相反的摩擦力的模型&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226874.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通常用的质点弹簧系统的模型，同时考虑很多性质&lt;/p>
&lt;ol>
&lt;li>多个角度牵拉&lt;/li>
&lt;li>弯折&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226888.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>也可以用有限元方法建模和仿真，可以替代弹簧系统&lt;/p>
&lt;h3 id="215-particle-systems">21.5 Particle Systems&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226903.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>有些东西不太适合有限元或者质点弹簧系统&lt;/p>
&lt;p>但可以利用粒子系统，并模拟粒子间的作用（碰撞、引力等等）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226918.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>粒子系统模拟的粗略过程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226933.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>粒子系统的一些力&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226947.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>粒子系统模拟水&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226962.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>粒子系统模拟鸟群&lt;/p>
&lt;p>给每只鸟定义其运动模式，合起来即可模拟鸟群&lt;/p>
&lt;h3 id="216-forward-kinematics">21.6 Forward Kinematics&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226976.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>正向运动学是定义模型并操作模型运动&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226991.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>只要从根依次运算即可&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226006.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>坏处是艺术家们并不太方便使用这种不直观的设置方式，更喜欢能够直接拖拽的控制&lt;/p>
&lt;h3 id="217-inverse-kinematics">21.7 Inverse Kinematics&lt;/h3>
&lt;p>于是有了逆运动学&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226022.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>比如设定好想要的轨迹，自动反解出各个关节应该在的地方&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226037.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>两个关节的反解例子&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226055.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但由于解往往并不惟一，容易导致抖动，这是求解比较难的原因之一&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226075.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>并且，有的时候还可能并不存在解&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226090.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>通常的求解方法类似机器学习，定义误差矩阵，采用梯度下降&lt;/p>
&lt;h3 id="218-rigging">21.8 Rigging&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226105.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>设置控制点进行控制&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226120.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226135.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>模型插值，可以利用控制点进行插值&lt;/p>
&lt;h3 id="219-motion-capture">21.9 Motion Capture&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226150.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226165.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>运动捕捉的优劣&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226179.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>为了让捕捉尽可能全面，遮挡少，可能需要大量摄像机并配合图像识别&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226194.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>面部动画的一大问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226209.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>面部表情捕捉&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226225.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>工业界动画制作流程&lt;/p>
&lt;h2 id="22animation">22.Animation&lt;/h2>
&lt;h3 id="221-single-particle-simulation">22.1 Single Particle Simulation&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226240.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>模拟粒子在力场中的运动&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226256.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>容易想到的方式是用微分方程&lt;/p>
&lt;p>但微分方程往往难以求解析解&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226271.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>于是通常需要用差分的方式去模拟，即欧拉方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226286.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>但这样做往往类似三体问题，导致很大误差&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226303.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>甚至是会导致模式上都非常偏离真实解的误差&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226319.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>数值模拟求解导致的误差和不稳定性&lt;/p>
&lt;h3 id="222-combating-instability">22.2 Combating Instability&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226335.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一些提升欧拉方法稳定性的方法&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226352.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>比如可以每次先用欧拉方法计算下一个位置，但并不直接用下一个位置，而是取当前和下一个位置的中点，用中点的力去计算最后用的下一个位置。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226367.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>另一种方式是类似泰勒展开一般，多利用一个二阶导项，以减小误差&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226383.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还有一种结合了前面方法的方法，可以设置误差阈值，每次先取中点计算，如果和直接计算的差异足够小则停止，否则继续砍半计算。&lt;/p>
&lt;p>这种自适应性在计算和结果稳定性上获得了很好的平衡，效果比较好。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226399.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>还有一种隐式欧拉法。需要求解方程（往往用牛顿法）&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226416.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>隐式欧拉方法的误差是 𝑂(ℎ2) 比较小&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226431.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>荣格库塔方法族也是很有效的模拟方式，可以直接使用其迭代方程，方程的推导需要参考《数值分析》课程。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226447.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>最后一种不基于物理，直接基于位置的一些逻辑去模拟，是相对物理的简化方式，在某些场景下效果已经足够。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226463.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>刚体的模拟方式，需要考虑位置、朝向、速度、角速度这几个量&lt;/p>
&lt;h3 id="223-fluid-simulation">22.3 Fluid Simulation&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226480.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>水体基于位置的一种模拟方法。&lt;/p>
&lt;p>将水的性质进行一些假设，比如水不可压缩，体积不变。&lt;/p>
&lt;p>如果某块区域的的水的密度出现相对于静态时的变化，则做相反的调整。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226498.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>两种对待大量颗粒的方式：&lt;/p>
&lt;ol>
&lt;li>拉格朗日法：把每个质点看作独立个体，定义性质，进行模拟&lt;/li>
&lt;li>欧拉法：把质点们当作整体，考虑各区域的性质，进行模拟&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/202304172226515.jpg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>拉格朗日和欧拉法也可以结合起来应用&lt;/p></description></item></channel></rss>