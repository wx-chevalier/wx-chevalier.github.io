<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="20 Three.js 优化之合并对象 前面学习了 Three.js 入门、基础、技巧，今天开始学习 Three.js 的性能优化。 关于性能优化有很多方式，最基础也是最常见的方式就是——合并几何对象。 在 “Three.js 基础之图元” 那篇文章中，我们将几何体称"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.fab3cd1900ae35687457073b2d518207.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/"><meta property="og:title" content="20.Three.js 优化之合并对象 | Next-gen Tech Edu"><meta property="og:description" content="20 Three.js 优化之合并对象 前面学习了 Three.js 入门、基础、技巧，今天开始学习 Three.js 的性能优化。 关于性能优化有很多方式，最基础也是最常见的方式就是——合并几何对象。 在 “Three.js 基础之图元” 那篇文章中，我们将几何体称"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>20.Three.js 优化之合并对象 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=16bc632722f8913ccd89f58d733b223e><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">2021-puxiao-《Three.js 系列教程》</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idbb95a2d75baa1d08a35c84b8efe5ad00")' href=#idbb95a2d75baa1d08a35c84b8efe5ad00 aria-expanded=false aria-controls=idbb95a2d75baa1d08a35c84b8efe5ad00 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>99.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idbb95a2d75baa1d08a35c84b8efe5ad00 aria-expanded=false aria-controls=idbb95a2d75baa1d08a35c84b8efe5ad00><i class="fa-solid fa-angle-down" id=caret-idbb95a2d75baa1d08a35c84b8efe5ad00></i></a></div><ul class="nav docs-sidenav collapse show" id=idbb95a2d75baa1d08a35c84b8efe5ad00><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E5%9B%BE%E8%A7%A3-webgl-%E5%8F%8A-three.js-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/>2017-图解 WebGL 及 Three.js 工作原理</a></li><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide04f28caa67ef746c1e042a66bd26df7")' href=#ide04f28caa67ef746c1e042a66bd26df7 aria-expanded=false aria-controls=ide04f28caa67ef746c1e042a66bd26df7 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/>2021-puxiao-《Three.js 系列教程》</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide04f28caa67ef746c1e042a66bd26df7 aria-expanded=false aria-controls=ide04f28caa67ef746c1e042a66bd26df7><i class="fa-solid fa-angle-down" id=caret-ide04f28caa67ef746c1e042a66bd26df7></i></a></div><ul class="nav docs-sidenav collapse show" id=ide04f28caa67ef746c1e042a66bd26df7><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/01.three.js-%E7%AE%80%E4%BB%8B/>01.Three.js 简介</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/02.%E5%88%9D%E5%A7%8B%E5%8C%96three.js-%E9%A1%B9%E7%9B%AE/>02.初始化Three.js 项目</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/03.%E7%BC%96%E5%86%99hellothreejs/>03.编写HelloThreejs</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/04.%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/>04.添加一些自适应</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/05.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%85%83/>05.Three.js 基础之图元</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/06.%E5%9B%BE%E5%85%83%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B/>06.图元练习示例</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/07.%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/>07.图元之3D文字</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/08.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/>08.Three.js 基础之场景</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/09.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/>09.Three.js 基础之材质</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/10.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%B9%E7%90%86/>10.Three.js 基础之纹理</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/11.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/>11.Three.js 基础之灯光</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/12.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%95%9C%E5%A4%B4/>12.Three.js 基础之镜头</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/13.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%B4%E5%BD%B1/>13.Three.js 基础之阴影</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/14.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%BE/>14.Three.js 基础之雾</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/15.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/>15.Three.js 基础之离屏渲染</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/16.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%A0%E4%BD%95%E4%BD%93/>16.Three.js 基础之自定义几何体</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/17.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8C%89%E9%9C%80%E6%B8%B2%E6%9F%93/>17.Three.js 技巧之按需渲染</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/18.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%B0%83%E8%AF%95/>18.Three.js 技巧之调试</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/>19.Three.js 技巧之画布</a></li><li class="child level active"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/>20.Three.js 优化之合并对象</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/21.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E7%94%BB/>21.Three.js 优化之合并对象的动画</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/22.three.js-%E4%BC%98%E5%8C%96%E4%B9%8Boffscreencanvas%E4%B8%8Ewebworker/>22.Three.js 优化之OffscreenCanvas与WebWorker</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/23.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/>23.Three.js 解决方案之加载.obj模型</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/24.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/>24.Three.js 解决方案之加载.gLTF模型</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/25.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/>25.Three.js 解决方案之添加背景和天空盒</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/26.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%8F%E6%98%8E%E5%BA%A6bug/>26.Three.js 解决方案之透明度bug</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/27.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%A4%9A%E7%94%BB%E5%B8%83%E5%A4%9A%E5%9C%BA%E6%99%AF/>27.Three.js 解决方案之多画布、多场景</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/28.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%89%E4%B8%AD%E6%8B%BE%E5%8F%96%E6%9F%90%E7%89%A9%E4%BD%93/>28.Three.js 解决方案之选中、拾取某物体</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/three.js-%E5%AE%9E%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/>Three.js 实用知识点笔记</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#基础示例helloearth>基础示例：HelloEarth</a><ul><li></li></ul></li><li><a href=#优化代码合并对象>优化代码：合并对象</a><ul><li></li></ul></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>20.Three.js 优化之合并对象</h1><div class=article-style><h1 id=20-threejs-优化之合并对象>20 Three.js 优化之合并对象</h1><p>前面学习了 Three.js 入门、基础、技巧，今天开始学习 Three.js 的性能优化。</p><p>关于性能优化有很多方式，最基础也是最常见的方式就是——合并几何对象。</p><blockquote><p>在 “Three.js 基础之图元” 那篇文章中，我们将几何体称呼为 图元，现在我们修改一下这个称呼，本文以后，绝大多数情况下我们都使用 “几何体” 来代替 “图元”。</p></blockquote><p>既然谈到性能优化，就不能使用简单的示例，要不然根本无法体现出 优化前和优化后 的区别。</p><p>激动人心的时刻到了。</p><h4 id=本文我们的目标制作并优化一个显示地球人口人数分布的可视化-3d-地球>本文我们的目标：制作并优化一个显示地球人口人数分布的可视化 3D 地球</h4><p>你可以先访问以下网址，先感受一下我们本文要模仿的效果：</p><p><a href=https://globe.chromeexperiments.com/ target=_blank rel=noopener>https://globe.chromeexperiments.com/</a></p><blockquote><p>补充说明：这个网站，是谷歌浏览器为了向大众演示 WebGL 技术而制作的一个演示网页。</p></blockquote><p>我相信你第一次看到这种基于浏览器的 3D 地球数据展示，一定会被震撼到的。</p><p>接下来我们就要逐步分析，找出实现方式。</p><p><strong>我们先考虑怎么把这个场景实现出来，然后再考虑优化的事。</strong></p><h4 id=核心模块分析>核心模块分析</h4><p>我们要先搞明白这个 3D 数字地球的核心模块。</p><ol><li><p>3D 地球</p><blockquote><p>就是一个球体，添加一个地球纹理图片</p><blockquote><p>图片为一个矩形地球展开图，本示例使用的地球纹理图片资源：<br><a href=https://threejsfundamentals.org/threejs/resources/images/world.jpg target=_blank rel=noopener>https://threejsfundamentals.org/threejs/resources/images/world.jpg</a></p></blockquote></blockquote></li><li><p>表示人口多少的柱状物</p><blockquote><p>某个地区人口多则柱状物就比较高，反之人口少则柱状物比较低</p></blockquote></li><li><p>鼠标可交互</p><blockquote><p>这个直接使用 OrbitControls 就可以
只不过本示例只允许左右、上下拖拽查看，但不允许修改镜头轨道的远近距离</p></blockquote></li></ol><p>上面的核心模块 1 、3 都很容易实现，重点我们进一步拆解一下 “表示人口多少的柱状物”。</p><h4 id=如何实现表示人口多少的柱状物>如何实现“表示人口多少的柱状物”？</h4><p>我们通过以下 3 个灵魂追问，来梳理思路。</p><p><strong>第 1 问：人口数据从哪里来？</strong></p><p>原网页提供 3 个年份的人口数量统计，分别是 1990、1995、2000 年。</p><p>美国国家航天局(NASA)提供的统计结果介绍页：
<a href=https://sedac.ciesin.columbia.edu/data/set/gpw-v4-admin-unit-center-points-population-estimates-rev11/data-download target=_blank rel=noopener>https://sedac.ciesin.columbia.edu/data/set/gpw-v4-admin-unit-center-points-population-estimates-rev11/data-download</a></p><p>请注意，该页面还提供最近年份的统计结果，但是下载时候提示需要注册。</p><p>我们选择不使用最新的 2020 年数据，而是使用 2010 年的结果。</p><p>为了方便你获得到 2010 年男性人口统计结果，你可以直接点击下面这个地址，直接下载：</p><p><a href=https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc target=_blank rel=noopener>https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc</a></p><blockquote><p>反正我们本文的重点是模仿效果，至于数据时效性不必纠结</p></blockquote><blockquote><p>该人口统计数据文件格式为 .asc，至于如何解析该文件，我们会稍后讲解</p></blockquote><blockquote><p>为啥是男性人口统计？女性人口呢？为什么不是全部人口统计呢？<br>因为在下一篇文章中，就会有女性人口统计，然后做出同一个地区 男女人口数量比较 的动画<br>为了简化，本文下面文字中，将忽略 “男性人口数量” 这个概念，统一称呼为 “人口数据”</p></blockquote><p><strong>第 2 问：人口数据和地区的对应关系，如何表现在地球上？</strong></p><p>我们把刚才下载得到的人口统计数据文件，重命名为 gpw_v4_014mt_2010.asc，然后将该文件移动到：src/assets/data/ 目录中。</p><p>点击该文件，用记事本查看该文件内容，你会发现里面大致为以下内容：</p><pre tabindex=0><code>ncols         360
nrows         145
xllcorner     -180
yllcorner     -60
cellsize      0.99999999999994
NODATA_value  -9999
-9999 -9999 -9999 -9999 -9999 -999...
...
...
</code></pre><p>这里面的数据内容为：<strong>矩形地球地图上，不同点(经纬度)对应的数值(人口数量)</strong>。</p><blockquote><p>补充：这里面的人口数量值并不是具体人口数量(比如 45932551 个人)，而是具有一定比例单位的值(例如 458.6)</p><p>具体单位值对应的人口我还不清楚，或许是 万，也或许是百万，不过不影响我们本示例，你只需把他当成数字即可</p></blockquote><p>我们需要将数据与地图纹理图片进行点对点的位置匹配。</p><blockquote><p>.asc 后缀的文件有特别多种用途和场景，我们这里提到的 .asc 文件是指：以 <code>PGP (Pretty Good Privacy) ASCII Armored File</code>形式存在的栅格化结构的数据文件。</p></blockquote><blockquote><p><strong>.asc 栅格化结构的数据文件说明：</strong></p><table><thead><tr><th>关键字</th><th>对应含义</th></tr></thead><tbody><tr><td>ncols(number colos)</td><td>表示该数据内容有多少列</td></tr><tr><td>nrows(number rows)</td><td>表示该数据内容有多少行</td></tr><tr><td>xllcorner(x-low-left-corner)</td><td>栅格的左下角坐标 x 的值</td></tr><tr><td>yllcorner(y-low-left-corner)</td><td>栅格的左下角坐标 y 的值</td></tr><tr><td>cellsize(cell size)</td><td>每个单元格元的尺寸</td></tr><tr><td>NODATA_value</td><td>单元格内没有值时对应的值</td></tr></tbody></table><blockquote><p>你可以把 .asc 文件 想象成一个数据表格，每个单元格为一项，nrows 行 ncols 列 个单元格构建成了一个 数据网格。</p><p>除了 .asc 开头的属性值键对外，后面的就是依次填入数据单元网格中的数据。</p></blockquote></blockquote><p><strong>第 3 问：根据人口多少，如何创建对应的柱状物？</strong></p><p>当得到地球某个经纬度(地球纹理图片上的某个坐标)上对应的人口数据后，就可以根据人口数量按照一定比例，创建柱状物。</p><p>原理讲过后，那接下来就是实际操作了。</p><h2 id=基础示例helloearth>基础示例：HelloEarth</h2><p>接下来，将通过以下几个步骤，逐步实现我们的目标示例。</p><p><strong>特别说明：</strong></p><p>以下几个步骤中的代码，重点是向你讲解具体的功能和思路，并不是最终的代码。</p><p>最终完整的示例代码中，会对这些每个步骤中的代码进行新的组织。</p><h4 id=第-1-步加载人口数据文件gpw_v4_014mt_2010asc>第 1 步：加载人口数据文件(gpw_v4_014mt_2010.asc)</h4><ol><li><p><strong>数据文件路径为 ./src/assets/data/gpw_v4_014mt_2010.asc</strong></p></li><li><p><strong>由于我们使用 alias 来得到 .asc 文件编译后的路径，所以请记得：</strong></p><ol><li><p>tsconfig.pahts.json 的 paths 中添加 <code>"@/assets/*": ["./src/assets/*"]</code></p></li><li><p>global.d.ts 中添加 <code>declare module '*.asc';</code></p></li><li><p>以上 2 处均配置正确后，才可以让我们在代码中方便使用 <code>require('@/assets/xx/xx.asc').default</code> 来获取 .asc 资源的路径</p><blockquote><p>假设你并不是使用 react + typescript + alias，那么你可以忽略我提到的配置，直接请求一个固定的网络资源(.asc 文件)就好了。</p></blockquote></li></ol></li><li><p><strong>通过 window.fetch() 这个函数来获取 .asc 文件内容</strong></p><blockquote><p>我们这里没有使用 xhr 或 axios 来请求获取文件资源，而是使用了 fetch 这个 Web API</p><p>关于 fetch 的用法，请参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API</p></blockquote></li></ol><p><strong>具体的代码：</strong></p><pre tabindex=0><code>const loadDataFile = async (url: string) =&gt; {
    try {
        const res = await window.fetch(url)
        const text = await res.text() // text 就是 .asc 文件里的内容
    } catch (error) {
        console.log(&#39;加载数据出错&#39;)
    }
}

const ascURL = require(&#39;@/assets/data/gpw_v4_014mt_2010.asc&#39;).default
loadDataFile(ascURL)
</code></pre><blockquote><p>额外说一个事情，本文对应的是 Three.js 官方教程 <a href=https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects.html target=_blank rel=noopener>https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects.html</a></p><p>我在阅读英文原文时，当时他代码中使用的是：</p><pre tabindex=0><code>async function loadFile(url) {
  const req = await fetch(url);
  return req.text();
}
</code></pre><p>我认为不应该将返回值使用变量 req(request)，而应该是 res(response)，于是我就提交了一个合并请求(PR)，然后很快就得到 <a href=https://github.com/greggman target=_blank rel=noopener>greggman</a> 的回应，我的 PR 已被合并到 master 中。</p><p>呵，我也顺带成为了这个项目中的一名 贡献者(contributor)。</p></blockquote><h4 id=第-2-步解析人口数据>第 2 步：解析人口数据</h4><ol><li><p><strong>为了方便我们以后代码提示，我们先使用 TypeScript 定义解析 .asc 数据后的格式</strong></p><pre tabindex=0><code>type DataType = (number | undefined)[][]
type ASCData = {
    data: DataType,
    ncols: number,
    nrows: number,
    xllcorner: number,
    yllcorner: number,
    cellsize: number,
    NODATA_value: number,
    max: number,
    min: number,
}
</code></pre><blockquote><p>data 为栅格化的世界人口数据，一共 nrows 条，每一条是由 ncols 个数字构成</p><p>假设某个点对应有人口数据则值为具体的数字，若没有人口则值为 undefined。</p><p>请记得没有人口数据的值为 undefined，而不是 0。</p><p>max、min 分别为我们添加的自定义属性，用来记录所有地区人口数据中最多和最少的人口数量，以此我们方便计算出 柱状高度比例</p></blockquote></li><li><p><strong>开始解析 .asc 文件内容，大体步骤如下：</strong></p><ol><li><p>首先我们知道 .asc 中每一行对应一条数据，那么就可以使用换行符 &lsquo;\n&rsquo; 来分隔出每一条数据，然后针对每一条数据进行解析</p><pre tabindex=0><code>text.split(&#39;\n&#39;).forEach((line) =&gt; { ... })
</code></pre></li><li><p>被分隔出来的每一行数据，再进一步转化和分析：</p><ol><li><p>由于可能存在多个连续空格，因此我们对每一条数据，再通过正则表达式 <code>/\s+/</code> 进一步分隔</p><pre tabindex=0><code>// 在正则表达式 ‘/\s+/’ 中 s 表示为空格，+ 表示 1个或多个
const parts = line.trim().split(/\s+/)
</code></pre></li><li><p>位于 .asc 文件开头，描述栅格化数据的一些属性，例如 ncols、nrows&mldr;，这些数据的结构为：<code>属性名 + 空格 + 值</code> 构成的</p><pre tabindex=0><code>if (parts.length === 2) { ... }
</code></pre></li><li><p>位于 .asc 文件中间，一行行，一条条具体的数据值，这些数据的结构为：<code>数字 + 空格 + 数字 + ...</code></p><pre tabindex=0><code>if (parts.length &gt; 2) { ... }
</code></pre></li><li><p>位于 .asc 文件尾部，可能存在的、无用的空白换行，这些空白换行是需要被我们通过条件判断来忽略掉的</p><pre tabindex=0><code>由于前面已经进行了 length === 2 或 &gt; 2 的判断，那么剩下的就肯定是空白无用的换行，我们什么也不做处理就好。
</code></pre></li></ol></li><li><p>在解析所有人口数据的过程中，我们要不断记录、得出 人口最大数值和最小数值</p></li><li><p>最终将解析好的数据结果对象，通过 TS 的 as 断言，对外返回出结果</p></li><li><p>补充一点：由于我们从 text 中读取到的 “数字” 其实是 字符串，所以在解析过程中都需要使用 parseFloat() 这个函数将 string 转化为 number</p></li><li><p>再补充一个细节，在初始化 max 和 min 时：</p><ol><li>让 max 初始化值为 0，因为我们知道有人口数据的值一定是大于 0 的</li><li>让 min 初始化值为 99999，因为我们知道一定有人口数据的值一定是小于 99999 的，且人口数量一定不会是负数</li></ol></li></ol><p><strong>具体的代码：</strong></p><pre tabindex=0><code>const parseData = (text: string) =&gt; {
    const data: (number|undefined)[][] = []
    const settings: { [key: string]: any } = { data }
    let max:number = 0
    let min:number = 99999
    text.split(&#39;\n&#39;).forEach((line) =&gt; {
        const parts = line.trim().split(/\s+/)
        if (parts.length === 2) {
            settings[parts[0]] = parseFloat(parts[1])
        } else if(parts.length &gt; 2) {
            const values = parts.map((item) =&gt; {
                const value = parseFloat(item)
                if (value === settings[&#39;NODATA_value&#39;]) {
                    return undefined
                }
                max = Math.max(max, value)
                min = Math.min(min, value)
                return value
            })
            data.push(values)
        }
    })
    return { ...settings, ...{ max, min } } as ASCData
}
</code></pre></li></ol><h4 id=第-3-步加载地球纹理图片>第 3 步：加载地球纹理图片</h4><pre tabindex=0><code>const loader = new Three.TextureLoader()
const texture = loader.load(require(&#39;@/assets/imgs/world.jpg&#39;).default,render)
const material = new Three.MeshPhongMaterial({
    map: texture
})
const geometry = new Three.SphereBufferGeometry(2, 32, 32)
const earth = new Three.Mesh(geometry, material)
scene.add(earth)
</code></pre><blockquote><p>请注意上述代码中，loader.load(xxx, render)，我们希望当纹理图片加载完成后，才执行 render 渲染</p></blockquote><h4 id=第-4-步将人口数据与地球纹理图片进行位置上的匹配>第 4 步：将人口数据与地球纹理图片进行位置上的匹配</h4><p><strong>先不考虑球体，假设我们仅仅想获得一张显示人口数量分布、平面的世界地图，该如何做呢？</strong></p><p><strong>代码思路：</strong></p><ol><li>我们通过 第 2 步骤已经拿到了栅格化后的世界人口分布数据</li><li>并且我们知道栅格化的数据是由 nrow(145) 行、ncols(360) 列组成</li><li>假设 1 个数据点 对应 1 像素，那么栅格化的数据实际上对应的是一个 高 145 像素、宽 360 像素的图形</li><li>假设 数据点最小(人口最少)的地方，我们用黑色来填充，而数据点最大(人口最多)的地方用红色填充，处于中间数量的点按照比例依次进行颜色变化，那么就可以得到我们想要的图形了。<ol><li>关于某个点填充的颜色，我们使用 HSL(色相、饱和度、亮度)，其中当 人口少时 L 的值越接近于 0 (黑色)、人口多时 L 的值越接近 1 (红色)</li><li>向画布(canvas) 某个点填充颜色，需要用到 canvas 一些相关知识，请自行先学习了解一下 canvas 相关知识</li></ol></li></ol><p><strong>对应的代码：</strong></p><pre tabindex=0><code>const hsl = (h: number, s: number, l: number) =&gt; {
    return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
}

const drawData = (ascData: ASCData) =&gt; {
    if (canvasRef.current === null) { return }
    const ctx = canvasRef.current.getContext(&#39;2d&#39;)
    if (ctx === null) { return }

    const range = ascData.max - ascData.min
    ctx.canvas.width = ascData.ncols
    ctx.canvas.height = ascData.nrows
    ctx.fillStyle = &#39;#444&#39;
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
    ascData.data.forEach((row, rowIndex) =&gt; {
        row.forEach((value, colIndex) =&gt; {
            if (value === undefined) { return }
            const amount = (value - ascData.min) / range
            const hue = 1
            const saturation = 1
            const lightness = amount
            ctx.fillStyle = hsl(hue, saturation, lightness)
            ctx.fillRect(colIndex,rowIndex,1,1)
        })
    })
}
</code></pre><p>为了让你比较直观看清，这里贴出目前我们已经写出来的代码。</p><blockquote><p>请注意下面的代码并不是我们真正示例的代码，你可以实际运行以下，查看效果</p></blockquote><pre tabindex=0><code>import { useEffect, useRef } from &#39;react&#39;

const loadDataFile = async (url: string) =&gt; {
    const res = await window.fetch(url)
    const text = await res.text()
    return text
}

type DataType = (number | undefined)[][]
type ASCData = {
    data: DataType,
    ncols: number,
    nrows: number,
    xllcorner: number,
    yllcorner: number,
    cellsize: number,
    NODATA_value: number,
    max: number,
    min: number,
}

const parseData = (text: string) =&gt; {
    const data: DataType = []
    const settings: { [key: string]: any } = { data }
    let max: number = 0
    let min: number = 99999
    text.split(&#39;\n&#39;).forEach((line) =&gt; {
        const parts = line.trim().split(/\s+/)
        if (parts.length === 2) {
            settings[parts[0]] = parseFloat(parts[1])
        } else if (parts.length &gt; 2) {
            const values = parts.map((item) =&gt; {
                const value = parseFloat(item)
                if (value === settings[&#39;NODATA_value&#39;]) {
                    return undefined
                }
                max = Math.max(max, value)
                min = Math.min(min, value)
                return value
            })
            data.push(values)
        }
    })
    return { ...settings, ...{ max, min } } as ASCData
}

const hsl = (h: number, s: number, l: number) =&gt; {
    return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
}

const HelloEarth = () =&gt; {
    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)

    const drawData = (ascData: ASCData) =&gt; {
        if (canvasRef.current === null) { return }
        const ctx = canvasRef.current.getContext(&#39;2d&#39;)
        if (ctx === null) { return }

        const range = ascData.max - ascData.min
        ctx.canvas.width = ascData.ncols
        ctx.canvas.height = ascData.nrows
        ctx.fillStyle = &#39;#444&#39;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
        ascData.data.forEach((row, rowIndex) =&gt; {
            row.forEach((value, colIndex) =&gt; {
                if (value === undefined) { return }
                const amount = (value - ascData.min) / range
                const hue = 1
                const saturation = 1
                const lightness = amount
                ctx.fillStyle = hsl(hue, saturation, lightness)
                ctx.fillRect(colIndex,rowIndex,1,1)
            })
        })

    }

    useEffect(() =&gt; {
        if (canvasRef.current === null) { return }
        const ascURL = require(&#39;@/assets/data/gpw_v4_014mt_2010.asc&#39;).default
        const doSomthing = async () =&gt; {
            try {
                const text = await loadDataFile(ascURL)
                const ascData = parseData(text)
                drawData(ascData)
            } catch (error) {
                console.log(error)
            }
        }
        doSomthing()

        return () =&gt; {

        }
    }, [canvasRef])

        return (
        &lt;canvas ref={canvasRef} /&gt;
    )
}

export default HelloEarth
</code></pre><p>实际运行后，就会看到一张 世界人口分布的地图</p><blockquote><p>请注意这个 “看似是世界地图”的图片并不是真正的世界地理位置地图，而是人口数量分布图。</p></blockquote><p><strong>如果你已经看懂了上面的代码，那么接下来就可以真正去制作 3D 立体地球示例了。</strong></p><blockquote><p>本示例是我们做过的最复杂的例子，尽管我们已经进行了详细的思路解读，你一定要多看，多敲几遍，否则接下来的代码你可能更加难以理解。</p></blockquote><p><strong>我们需要将之前的 drawData() 修改 为 addBoxes()，并且不再是在 canvas 中绘制点，而是在球体上添加柱状物：</strong></p><pre tabindex=0><code>const addBoxes = (ascData: ASCData, scene: Three.Scene) =&gt; {
    const geometry = new Three.BoxBufferGeometry(1, 1, 1)
    geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))

    const lonHelper = new Three.Object3D()
    scene.add(lonHelper)

    const latHelper = new Three.Object3D()
    lonHelper.add(latHelper)

    const positionHelper = new Three.Object3D()
    positionHelper.position.z = 1
    latHelper.add(positionHelper)

    const range = ascData.max - ascData.min
    const lonFudge = Math.PI * 0.5
    const latFudge = Math.PI * -0.135
    ascData.data.forEach((row, latIndex) =&gt; {
        row.forEach((value, lonIndex) =&gt; {
            if (value === undefined) { return }
            const amount = (value - ascData.min) / range
            const material = new Three.MeshBasicMaterial()
            const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
            const saturation = 1
            const lightness = Three.MathUtils.lerp(0.1, 1, amount)
            material.color.setHSL(hue, saturation, lightness)
            const mesh = new Three.Mesh(geometry, material)
            scene.add(mesh)

            lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
            latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge

            positionHelper.updateWorldMatrix(true, false)
            mesh.applyMatrix4(positionHelper.matrixWorld)
            mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
        })
    })
}
</code></pre><blockquote><p>上面代码中牵扯到了非常多新的、之前从未使用过的一些函数或属性。</p></blockquote><p><strong>解释说明：</strong></p><ol><li><p>栅格化数据 和 纹理图片 均可看作是 2D 矩形坐标，最终需要转化为 3D 球体坐标，转化过程中 lonFudge、latFudge 具体作用机理，暂时还没搞明白。</p><blockquote><p>先记住转化公式，以后再慢慢研究</p></blockquote><blockquote><p>栅格化数据 为 360 _ 145、纹理图片为 2048 _ 1024</p></blockquote></li><li><p>Three.Matrix4：WebGL 中的矩阵库</p></li><li><p>Three.MathUtils：Three.js 中内置的一些计算函数</p><blockquote><p>关于这些新的对象具体详细介绍，请查阅 Three.js 官方文档</p></blockquote></li><li><p>lonHelper 用于赤道上的经度旋转、latHelper 用于维度旋转、positionHelper 用于 Z 轴(地球地面)上的偏移。</p></li><li><p>lonFudge 的值为 Math.PI * 0.5，也就是相当于 1/4 个圆(地球 1/4 圈)</p></li><li><p>latFudge 的值为 Math.PI * -0.135，这里的 -0.135 不太清楚是怎么得出来的，但是大概率推测它是用来将柱状物与纹理图片对齐的</p></li></ol><p><strong>示例所需其他代码块：</strong></p><ol><li>创建 3D 地球、以及加载纹理图片</li><li>添加 OrbitControls 控制，并且开启 “弹性结束控制”</li><li>添加场景渲染函数 render，并且添加 “按需渲染” 相关代码</li></ol><p><strong>最终完整的示例代码：</strong></p><pre tabindex=0><code>import { useEffect, useRef } from &#39;react&#39;
import * as Three from &#39;three&#39;
import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;

import &#39;./index.scss&#39;

const loadDataFile = async (url: string) =&gt; {
    const res = await window.fetch(url)
    const text = await res.text()
    return text
}

type DataType = (number | undefined)[][]
type ASCData = {
    data: DataType,
    ncols: number,
    nrows: number,
    xllcorner: number,
    yllcorner: number,
    cellsize: number,
    NODATA_value: number,
    max: number,
    min: number,
}

const parseData = (text: string) =&gt; {
    const data: DataType = []
    const settings: { [key: string]: any } = { data }
    let max: number = 0
    let min: number = 99999
    text.split(&#39;\n&#39;).forEach((line) =&gt; {
        const parts = line.trim().split(/\s+/)
        if (parts.length === 2) {
            settings[parts[0]] = parseFloat(parts[1])
        } else if (parts.length &gt; 2) {
            const values = parts.map((item) =&gt; {
                const value = parseFloat(item)
                if (value === settings[&#39;NODATA_value&#39;]) {
                    return undefined
                }
                max = Math.max(max, value)
                min = Math.min(min, value)
                return value
            })
            data.push(values)
        }
    })
    return { ...settings, ...{ max, min } } as ASCData
}

// const hsl = (h: number, s: number, l: number) =&gt; {
//     return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
// }

let renderRequested = false

const HelloEarth = () =&gt; {
    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)

    // const drawData = (ascData: ASCData) =&gt; {
    //     if (canvasRef.current === null) { return }
    //     const ctx = canvasRef.current.getContext(&#39;2d&#39;)
    //     if (ctx === null) { return }

    //     const range = ascData.max - ascData.min
    //     ctx.canvas.width = ascData.ncols
    //     ctx.canvas.height = ascData.nrows
    //     ctx.fillStyle = &#39;#444&#39;
    //     ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
    //     ascData.data.forEach((row, rowIndex) =&gt; {
    //         row.forEach((value, colIndex) =&gt; {
    //             if (value === undefined) { return }
    //             const amount = (value - ascData.min) / range
    //             const hue = 1
    //             const saturation = 1
    //             const lightness = amount
    //             ctx.fillStyle = hsl(hue, saturation, lightness)
    //             ctx.fillRect(colIndex, rowIndex, 1, 1)
    //         })
    //     })
    // }

    const addBoxes = (ascData: ASCData, scene: Three.Scene) =&gt; {
        const geometry = new Three.BoxBufferGeometry(1, 1, 1)
        geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))

        const lonHelper = new Three.Object3D()
        scene.add(lonHelper)

        const latHelper = new Three.Object3D()
        lonHelper.add(latHelper)

        const positionHelper = new Three.Object3D()
        positionHelper.position.z = 1
        latHelper.add(positionHelper)

        const range = ascData.max - ascData.min
        const lonFudge = Math.PI * 0.5
        const latFudge = Math.PI * -0.135
        ascData.data.forEach((row, latIndex) =&gt; {
            row.forEach((value, lonIndex) =&gt; {
                if (value === undefined) { return }
                const amount = (value - ascData.min) / range
                const material = new Three.MeshBasicMaterial()
                const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
                const saturation = 1
                const lightness = Three.MathUtils.lerp(0.1, 1, amount)
                material.color.setHSL(hue, saturation, lightness)
                const mesh = new Three.Mesh(geometry, material)
                scene.add(mesh)

                lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
                latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge

                positionHelper.updateWorldMatrix(true, false)
                mesh.applyMatrix4(positionHelper.matrixWorld)
                mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
            })
        })
    }

    useEffect(() =&gt; {
        if (canvasRef.current === null) { return }

        const canvas = canvasRef.current
        const renderer = new Three.WebGLRenderer({ canvas })
        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
        camera.position.z = 4
        const scene = new Three.Scene()
        scene.background= new Three.Color(0x000000)

        const controls = new OrbitControls(camera, canvas)
        controls.enableDamping = true
        controls.enablePan =false
        controls.update()

        const render = () =&gt; {
            renderRequested = false
            controls.update()
            renderer.render(scene, camera)
        }

        const handleChange =() =&gt;{
            if(renderRequested === false){
                renderRequested = true
                window.requestAnimationFrame(render)
            }
        }
        controls.addEventListener(&#39;change&#39;,handleChange)

        const loader = new Three.TextureLoader()
        const texture = loader.load(require(&#39;@/assets/imgs/world.jpg&#39;).default, render)
        const material = new Three.MeshBasicMaterial({
            map: texture
        })
        const geometry = new Three.SphereBufferGeometry(1, 64, 32)
        const earth = new Three.Mesh(geometry, material)
        scene.add(earth)

        const handleResize = () =&gt; {
            const width = canvas.clientWidth
            const height = canvas.clientHeight
            camera.aspect = width / height
            camera.updateProjectionMatrix()
            renderer.setSize(width, height, false)

            window.requestAnimationFrame(render)
        }
        handleResize()
        window.addEventListener(&#39;resize&#39;, handleResize)

        const ascURL = require(&#39;@/assets/data/gpw_v4_014mt_2010.asc&#39;).default
        const doSomthing = async () =&gt; {
            try {
                const text = await loadDataFile(ascURL)
                const ascData = parseData(text)
                //drawData(ascData)
                addBoxes(ascData, scene)
                render()
            } catch (error) {
                console.log(error)
            }
        }
        doSomthing()

        return () =&gt; {
            controls.removeEventListener(&#39;change&#39;,handleChange)
            window.removeEventListener(&#39;resize&#39;, handleResize)
        }
    }, [canvasRef])

    return (
        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
    )
}

export default HelloEarth
</code></pre><p>调试运行，首先就会看到一个 3D 立体地球，等待 1 秒左右，待 .asc 数据加载并解析、添加地球上的柱状物后，就会看到本示例所想演示的最终效果。</p><blockquote><p>终于终于到这一步了</p></blockquote><p>不过当你鼠标拖动地球时，会感受到略微卡顿，或者说不够流畅。</p><p>那么接下来，就到了本文的核心内容：通过 合并对象 来达到优化场景的目的。</p><h4 id=补充启用浏览器-调试工具-devtool-的-rendering-查看渲染性能>补充：启用浏览器 调试工具 DevTool 的 Rendering 查看渲染性能</h4><p>除了浏览器本身的 性能(Performance) 面板外，还有另外一个重要的、方便我们查看页面渲染性能的工具——Rendering。</p><p><strong>通过谷歌调试工具 Rendering，查看当前页面渲染性能情况：</strong></p><ol><li><p>打开浏览器调试工具 DevTool</p></li><li><p>点击右侧 3 个小圆点</p></li><li><p>鼠标移动到 More tools</p></li><li><p>点击 Rendering</p></li><li><p>在新出现的 Rendering 面板中，勾选 Frame Rendering Stats</p><blockquote><p>备注：在旧的谷歌浏览器中，应该勾选的是 Show FPS meter</p></blockquote></li></ol><p>这样就可以在网页左上角，实时看到当前渲染性能状况。</p><p><strong>性能数据解读：</strong></p><p>性能展示的数据，主要 2 个模块：Frames 和 GPU</p><p><strong>GPU 相关：</strong></p><ol><li><p>GPU raster ：on 表示 GPU 光栅化已开启</p></li><li><p>GPU memory：GPU 已用大小、GPU 最大可用大小</p><blockquote><p>在本示例中，通常是当修改浏览器尺寸时，此时需要大量计算，会显示出 GPU memory</p><p>在普通的 鼠标拖拽 改变地球视角时，不会显示 GPU memory</p></blockquote></li></ol><p><strong>Frames 相关：</strong></p><p>假设某一时刻，渲染性能结果为 Frames：63% 1082(0m) dropped of 2737</p><p>对应的解读为：</p><p>第 1 个数字 63% —— 63% 的帧按时渲染完成</p><p>第 2 个数字 1082 —— 有 1082 个合成帧丢失(未渲染)</p><p>第 3 个数字 0m —— 有 0 个帧丢失</p><p>第 4 个数字 2737 —— 原本计划渲染 2737 个帧</p><p>数字之间的计算关系为 63% ≈ 1 - (1082 + 0 )/ 2737</p><p>也就是说 第 2 个数字(丢失的合成帧)越小，那么整体按时完成渲染帧的百分比(第 1 个数字)越大，意味着此刻网页越流畅。</p><h2 id=优化代码合并对象>优化代码：合并对象</h2><h4 id=核心代码分析>核心代码分析</h4><p>在上面的示例代码中，lonHelper 用于赤道上的经度旋转、latHelper 用于维度旋转、positionHelper 用于 Z 轴(地球地面)上的偏移。</p><blockquote><p>默认 Three.js 中物体是有 1/2 位于 Z 轴之下的，通过 Z 轴的偏移让柱状物可以完全出现在地面上</p></blockquote><p>每一个数据点(柱状物)都创建了一个 MeshBasicMaterial 和 Mesh。</p><p>我们的数据点一共为 145 行、360 列，那么就意味着假设全部数据点都有数据，那么数据点总数量为：145 * 360 = 52200，但是考虑到有非常多的数据点的值为 -9999(NODATA_value)，也就是没有值，不需要绘制，那么减去这些没有数据点，<strong>最终需要绘制的数据点(柱状物)大约为 19000 个</strong>。</p><p><strong>柱状物 19000 个，再加上对应的 3 个辅助对象(lonHelper、latHelper、positionHelper)，相当于总绘制数量为 19000 * 4 = 76000。</strong></p><p>也就是说每一次场景更新，大约需要绘制 7.6 万个对象，所以这才造成了卡顿现象。</p><p><strong>如何解决卡顿？减少需要渲染对象的数量！</strong></p><p>还记得我们刚才统计的渲染对象数量吗？</p><ol><li>柱状体 约 19000 个</li><li>每个柱状体对应 3 个辅助对象 19000 * 3</li></ol><p>我们需要做的就是把所有的柱状体合并成一个物体，也就是说原本需要渲染 19000 个柱状体，合并之后只需渲染 1 个，让柱状体数量减少 18999 个。</p><p><strong>修改 addBoxes 函数代码：</strong></p><pre tabindex=0><code>import { BufferGeometryUtils } from &#39;three/examples/jsm/utils/BufferGeometryUtils&#39;

const addBoxes = (ascData: ASCData, scene: Three.Scene) =&gt; {
    //const geometry = new Three.BoxBufferGeometry(1, 1, 1)
    //geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))

    const lonHelper = new Three.Object3D()
    scene.add(lonHelper)

    const latHelper = new Three.Object3D()
    lonHelper.add(latHelper)

    const positionHelper = new Three.Object3D()
    positionHelper.position.z = 1
    latHelper.add(positionHelper)

    const originHelper = new Three.Object3D()
    originHelper.position.z = 0.5
    positionHelper.add(originHelper)

    const range = ascData.max - ascData.min
    const lonFudge = Math.PI * 0.5
    const latFudge = Math.PI * -0.135
    const geometries: Three.BoxBufferGeometry[] = []
    const color = new Three.Color()
    ascData.data.forEach((row, latIndex) =&gt; {
        row.forEach((value, lonIndex) =&gt; {
            if (value === undefined) { return }
            const amount = (value - ascData.min) / range
            //const material = new Three.MeshBasicMaterial()
            //const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
            //const saturation = 1
            //const lightness = Three.MathUtils.lerp(0.1, 1, amount)
            //material.color.setHSL(hue, saturation, lightness)
            //const mesh = new Three.Mesh(geometry, material)
            //scene.add(mesh)

            const geometry = new Three.BoxBufferGeometry(1, 1, 1)

            lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
            latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge

            //positionHelper.updateWorldMatrix(true, false)
            //mesh.applyMatrix4(positionHelper.matrixWorld)
            //mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))

            positionHelper.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.01, 0.5, amount))
            originHelper.updateWorldMatrix(true, false)
            geometry.applyMatrix4(originHelper.matrixWorld)

            const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
            const saturation = 1
            const lightness = Three.MathUtils.lerp(0.1, 1, amount)
            color.setHSL(hue, saturation, lightness)
            const rgb = color.toArray().map((value) =&gt; {
                return value * 255
            })

            const numVerts = geometry.getAttribute(&#39;position&#39;).count
            const itemSize = 3
            const colors = new Uint8Array(itemSize * numVerts)

            //这里有一个稍微奇葩点的写法，就是使用下划线 _ 来起到参数占位的作用
            colors.forEach((_, index) =&gt; {
                colors[index] = rgb[index % 3]
            })

            const normalized = true
            const colorAttrib = new Three.BufferAttribute(colors, itemSize, normalized)
            geometry.setAttribute(&#39;color&#39;, colorAttrib)

            geometries.push(geometry)
        })
    })
    const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries)
    //const material = new Three.MeshBasicMaterial({ color: &#39;red&#39; })
    const material = new Three.MeshBasicMaterial({
        vertexColors: true
    })
    const mesh = new Three.Mesh(mergedGeometry, material)
    scene.add(mesh)
}
</code></pre><blockquote><p>上述代码中，注释部分为之前 addBoxes() 函数的代码，除了 //const material = new Three.MeshBasicMaterial({ color: &lsquo;red&rsquo; }) 这一行</p></blockquote><p><strong>代码解析：</strong></p><ol><li><p>合并所有的柱状物，使用到了一个新的函数 BufferGeometryUtils.mergeBufferGeometries()</p><blockquote><p>注意：BufferGeometryUtils 并非来自 Three，而是来自 &rsquo;three/examples/jsm/utils/BufferGeometryUtils&rsquo;</p></blockquote></li><li><p>柱状物的颜色，不再使用 color 设定，而是启用了 “顶点着色”。</p></li></ol><blockquote><p>关于这 2 个大的知识点，可以去阅读 Three.js 官方文档</p></blockquote><blockquote><p>需要恶补官方文档，如果只是看了本教程，那么还会有大量的知识点未曾接触。</p></blockquote><p>经过合并优化后的场景，在浏览器中运行，比之前的流畅非常多，没有卡顿的现象了。</p><blockquote><p>我本机电脑硬件配置比较高，我分别记录了 Rendering 面板中 优化前后的 Frames 值。</p><p>优化前：顺利渲染帧的百分比约为 60%</p><p>优化后：顺利渲染帧的百分比约为 90%</p><p>可见网页流畅度确实提高了很多</p></blockquote><h4 id=本文小结>本文小结：</h4><p><strong>在 Three.js 大型的场景中，绝大多数都需要采用合并对象的策略来优化渲染性能。</strong></p><p>合并对象可以减少需要渲染的对象数量，并且还可以将有一些根本不可见的面进行删除，减少渲染面，提高渲染性能。</p><p>你以为就这样可以结束了？</p><p>事实上还有优化空间，本文先到这里结束。</p><p>下一篇将继续优化这个场景。</p></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>上一页</div><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/ rel=next>19.Three.js 技巧之画布</a></div><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/21.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E7%94%BB/ rel=prev>21.Three.js 优化之合并对象的动画</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div><script type=text/javascript id=clstr_globe async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>