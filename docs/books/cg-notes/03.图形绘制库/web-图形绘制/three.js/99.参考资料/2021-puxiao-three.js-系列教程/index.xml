<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2021-puxiao-《Three.js 系列教程》 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</link><atom:link href="https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><description>2021-puxiao-《Three.js 系列教程》</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>2021-puxiao-《Three.js 系列教程》</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</link></image><item><title>01.Three.js 简介</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/01.three.js-%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/01.three.js-%E7%AE%80%E4%BB%8B/</guid><description>&lt;h1 id="01-threejs-简介">01 Three.js 简介&lt;/h1>
&lt;h2 id="threejs-简介概述">Three.js 简介概述&lt;/h2>
&lt;p>&lt;strong>Three.js 概述&lt;/strong>&lt;/p>
&lt;p>Three.js 是基于 WebGL 技术，用于浏览器中开发 3D 交互场景的 JS 引擎。&lt;/p>
&lt;blockquote>
&lt;p>默认 WebGL 只支持简单的 点、线、三角，Three.js 就是在此 WebGL 基础之上，封装出强大且使用起来简单的 JS 3D 类库。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>目前主流现代浏览器都已支持 WebGL，也意味着支持 Three.js。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Three.js 优缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Three.js 擅长 WebGL 场景渲染，作为 JS 类库特别原生、灵活、自由度高&lt;/li>
&lt;li>Three.js 不擅长物理碰撞，因此不适合开发 3D 游戏&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>先感受几个 Three.js 示例&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>3D 沙发产品在线预览：http://app.xuanke3d.com/apps/trayton/#/show&lt;/p>
&lt;/li>
&lt;li>
&lt;p>游乐园可交互场景：http://letsplay.ouigo.com/&lt;/p>
&lt;/li>
&lt;li>
&lt;p>跟随音乐楼房跳动：http://analysis.4sceners.de/&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Three.js 应用场景&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>3D 数据可视化场景&lt;/li>
&lt;li>产品 720 度在线预览&lt;/li>
&lt;li>H5/微信小游戏&lt;/li>
&lt;li>科技教学 3D 模型展示&lt;/li>
&lt;li>网页 VR、网页 VR 看房&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Three.js 相关资料官网&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Three.js 官网：https://threejs.org/&lt;/li>
&lt;li>threejs.org 中文文档：https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene&lt;/li>
&lt;li>threejs.org 官方教程：https://threejsfundamentals.org/threejs/lessons/zh_cn/&lt;/li>
&lt;li>Three.js Github：https://github.com/mrdoob/three.js&lt;/li>
&lt;li>hewebgl.com Three.js 基础教程：http://www.hewebgl.com/article/articledir/1&lt;/li>
&lt;li>webgl3d.cn Three.js 教程：http://www.webgl3d.cn/Three.js/&lt;/li>
&lt;/ul>
&lt;h2 id="threejs-中的技术名词">Three.js 中的技术名词&lt;/h2>
&lt;h3 id="3-大核心关键模块">3 大核心关键模块&lt;/h3>
&lt;p>&lt;strong>场景(scene)&lt;/strong>&lt;/p>
&lt;p>场景是所有物体的容器。&lt;/p>
&lt;p>&lt;strong>相机(camera)&lt;/strong>&lt;/p>
&lt;p>决定场景中哪些角度的内容会显示出来。&lt;/p>
&lt;p>当然你也可以把&lt;code>相机&lt;/code> 称呼为 &lt;code>摄像头&lt;/code> 、&lt;code>镜头&lt;/code>、&lt;code>摄像机&lt;/code> 等。&lt;/p>
&lt;blockquote>
&lt;p>本系列文章中，绝大多数时候都会使用 “镜头” 这个称呼&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>渲染器(renderer)&lt;/strong>&lt;/p>
&lt;p>将 &lt;code>相机&lt;/code> 中的内容渲染到浏览器页面中。&lt;/p>
&lt;h3 id="其他技术关键词">其他技术关键词&lt;/h3>
&lt;p>&lt;strong>几何体(Geometry)&lt;/strong>&lt;/p>
&lt;p>顾名思义，就是几何体，例如 球体、立方体、平面、以及自定义的几何体(汽车、动物、房子、数目等)。&lt;/p>
&lt;p>在 Three.js 中，一个几何体的来源有 3 个：&lt;/p>
&lt;ol>
&lt;li>Three.js 中内置的一些基本几何体&lt;/li>
&lt;li>自己创建自定义的几何体&lt;/li>
&lt;li>通过文件加载进来的几何体&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>材质(Material)&lt;/strong>&lt;/p>
&lt;p>几何体的表面属性，包括颜色、光亮程度。&lt;/p>
&lt;blockquote>
&lt;p>光亮程度是指物体表面反射光的能力值。Three.js 内置了不同的材质，不同材质对应不同的光亮程度。&lt;/p>
&lt;p>内置材质 MeshBasicMaterial 是一种不可以反射光的材质，请注意这里说的不可以反射光并不是指该物体向黑洞那样连光都能吸收，而是指无论什么光源以何种角度照射到该物体上，该物体都不显示 “光亮”，而仅仅以材质本身的颜色或纹理来显示。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>幸亏以前我学些过 C4D，所以对于这些名词和概念不是那么陌生&lt;/p>
&lt;/blockquote>
&lt;p>一个材质可以引用一个或多个纹理。&lt;/p>
&lt;p>&lt;strong>纹理(Texture)&lt;/strong>&lt;/p>
&lt;p>纹理可以简单理解为一种图像或一张图片，用来包裹到几何体表面上。&lt;/p>
&lt;p>纹理来源可以是：&lt;/p>
&lt;ol>
&lt;li>通过文件加载进来&lt;/li>
&lt;li>在画布上生成&lt;/li>
&lt;li>由另外一个场景渲染出&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>网格(Mesh)&lt;/strong>&lt;/p>
&lt;p>一种特定的 几何体和材质 绘制出的一个特定的几何体系。&lt;/p>
&lt;blockquote>
&lt;p>网格包含的内容为：几何体、几何体的材质、几何体的自身网格坐标体系&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>同一个材质和几何体可以被多个网格对象使用。&lt;/p>
&lt;p>一个场景可以同时添加多个网格。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>光源(Light)&lt;/strong>&lt;/p>
&lt;p>指不同种类的光。&lt;/p>
&lt;p>&lt;strong>视椎(frustum)&lt;/strong>&lt;/p>
&lt;p>透视镜头(PerspectiveCamera)所创造出的一种视觉可见空间。&lt;/p>
&lt;p>以上提到的所有关键词和概念，会在后续学习过程中，逐个细致学习掌握。&lt;/p>
&lt;p>加油！&lt;/p></description></item><item><title>02.初始化Three.js 项目</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/02.%E5%88%9D%E5%A7%8B%E5%8C%96three.js-%E9%A1%B9%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/02.%E5%88%9D%E5%A7%8B%E5%8C%96three.js-%E9%A1%B9%E7%9B%AE/</guid><description>&lt;h1 id="02-初始化-threejs-项目">02 初始化 Three.js 项目&lt;/h1>
&lt;p>本文以 Yarn 而不是 NPM 安装 Three.js。&lt;/p>
&lt;p>&lt;strong>第 1 步：全局安装 create-react-app&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>yarn global add create-react-app
&lt;/code>&lt;/pre>&lt;p>&lt;strong>第 2 步：初始化 React+TypeScript 项目&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>我用的是 create-react-app 4.0.2 版本，对应的是 React 17.0.1&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>yarn create react-app test-threejs --template typescript
&lt;/code>&lt;/pre>&lt;p>&lt;strong>第 3 步：初次修改 tsconfig.json 配置&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>修改 TS 编译目标 ES 版本为 es2017&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;target&amp;#34;: &amp;#34;es2017&amp;#34;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>添加一些本人 TS 配置偏好&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;noUnusedLocals&amp;#34;: true,
&amp;#34;noUnusedParameters&amp;#34;: true,
&amp;#34;sourceMap&amp;#34;: true,
&amp;#34;removeComments&amp;#34;: false
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>第 4 步：配置 alias，安装对应模块&lt;/strong>&lt;/p>
&lt;p>由 create-react-app 创建的 React 项目中，配置 alias(路径映射)，我采用的方案是：react-app-rewired + react-app-rewire-alias&lt;/p>
&lt;pre tabindex="0">&lt;code>yarn add --dev react-app-rewired react-app-rewire-alias
&lt;/code>&lt;/pre>&lt;p>&lt;strong>第 5 步：完善 alias 配置&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在项目根目录，新建文件 tsconfig.paths.json，内容暂时设置为：&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;compilerOptions&amp;#34;: {
&amp;#34;baseUrl&amp;#34;: &amp;#34;.&amp;#34;,
&amp;#34;paths&amp;#34;: {
&amp;#34;@/src/*&amp;#34;: [&amp;#34;./src/*&amp;#34;],
&amp;#34;@/components/*&amp;#34;: [&amp;#34;./src/components/*&amp;#34;]
}
}
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>我们暂时先添加 2 个路径映射 src 和 components，具体路径还会根据将来实际开发过程中所需要创建不同的目录结构进行修改。&lt;/p>
&lt;p>补充：根据 typescript 官方更新说明文档，baseUrl 这一项是可以省略的，但是上面代码中还是遵循了之前的配置方式，继续添加上了 baseUrl。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在项目根目录，新建文件 config-overrides.js，内容为：&lt;/p>
&lt;pre tabindex="0">&lt;code>const { alias, configPaths } = require(&amp;#39;react-app-rewire-alias&amp;#39;)
module.exports = function override(config) {
alias(configPaths(&amp;#39;./tsconfig.paths.json&amp;#39;))(config)
return config
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>注意是 .js 文件 而不是 .ts 文件，鼠标放到 require 上后也许会显示提示文字：文件是 CommonJS 模块；它可能会转换为 ES6 模块。&lt;/p>
&lt;p>请忽略这个提示，这并不是什么错误信息。&lt;/p>
&lt;p>require 是 Nodejs 导入模块的方式，TypeScript 导入模块使用的是 import。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在项目根目录，新建文件 global.d.ts，内容为：&lt;/p>
&lt;blockquote>
&lt;p>注意：本步骤的目的是为了让 TS 忽略对 react-app-rewire-alias 和其他一些非常规格式文件的导入检查。&lt;/p>
&lt;p>本步骤是可选的，不是必须的，你可以跳过本步骤。&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>declare module &amp;#39;*.png&amp;#39;;
declare module &amp;#39;*.gif&amp;#39;;
declare module &amp;#39;*.jpg&amp;#39;;
declare module &amp;#39;*.jpeg&amp;#39;;
declare module &amp;#39;*.svg&amp;#39;;
declare module &amp;#39;*.css&amp;#39;;
declare module &amp;#39;*.less&amp;#39;;
declare module &amp;#39;*.scss&amp;#39;;
declare module &amp;#39;*.sass&amp;#39;;
declare module &amp;#39;*.styl&amp;#39;;
declare module &amp;#39;react-app-rewire-alias&amp;#39;;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>修改 tsconfig.json 文件，添加以下一行内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;extends&amp;#34;: &amp;#34;./tsconfig.paths.json&amp;#34;,
&amp;#34;compilerOptions&amp;#34;: {
...
}
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意 extends 是和 compilerOptions 平级的。&lt;/p>
&lt;/blockquote>
&lt;p>至此，我们的 tsconfig.json 最终内容如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;extends&amp;#34;: &amp;#34;./tsconfig.paths.json&amp;#34;,
&amp;#34;compilerOptions&amp;#34;: {
&amp;#34;target&amp;#34;: &amp;#34;es2017&amp;#34;,
&amp;#34;lib&amp;#34;: [
&amp;#34;dom&amp;#34;,
&amp;#34;dom.iterable&amp;#34;,
&amp;#34;esnext&amp;#34;
],
&amp;#34;allowJs&amp;#34;: true,
&amp;#34;skipLibCheck&amp;#34;: true,
&amp;#34;esModuleInterop&amp;#34;: true,
&amp;#34;allowSyntheticDefaultImports&amp;#34;: true,
&amp;#34;strict&amp;#34;: true,
&amp;#34;forceConsistentCasingInFileNames&amp;#34;: true,
&amp;#34;noFallthroughCasesInSwitch&amp;#34;: true,
&amp;#34;module&amp;#34;: &amp;#34;esnext&amp;#34;,
&amp;#34;moduleResolution&amp;#34;: &amp;#34;node&amp;#34;,
&amp;#34;resolveJsonModule&amp;#34;: true,
&amp;#34;isolatedModules&amp;#34;: true,
&amp;#34;noEmit&amp;#34;: true,
&amp;#34;jsx&amp;#34;: &amp;#34;react-jsx&amp;#34;,
&amp;#34;noUnusedLocals&amp;#34;: true,
&amp;#34;noUnusedParameters&amp;#34;: true,
&amp;#34;sourceMap&amp;#34;: true,
&amp;#34;removeComments&amp;#34;: false
},
&amp;#34;include&amp;#34;: [
&amp;#34;src&amp;#34;
]
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>第 6 步：修改 package.json 中的 scripts 命令&lt;/strong>&lt;/p>
&lt;p>将命令中 start、build、test 3 条命令中的 react-scripts 修改为 react-app-rewired&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#34;scripts&amp;#34;: {
&amp;#34;start&amp;#34;: &amp;#34;react-app-rewired start&amp;#34;,
&amp;#34;build&amp;#34;: &amp;#34;react-app-rewired build&amp;#34;,
&amp;#34;test&amp;#34;: &amp;#34;react-app-rewired test&amp;#34;,
&amp;#34;eject&amp;#34;: &amp;#34;react-scripts eject&amp;#34;
},
&lt;/code>&lt;/pre>&lt;p>&lt;strong>第 7 步：安装 scss&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>yarn add node-sass --dev
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>假设你使用的是较早版本的 create-react-app，那么当时还不支持最新版 node-sass 5.0，所以你只能安装： &lt;code>yarn add node-sass@4.14.1 --dev&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>第 8 步：安装 three.js&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>//npm install --save three
yarn add three
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>以下更新于 2021.04.11&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>关于 .d.ts 文件的特别说明：&lt;/strong>&lt;/p>
&lt;p>写这篇文章的时候是 2020 年 11 月底，当时应该是 r124 版本，当时的 Three.js 版本里内置了 .d.ts 文件，但是随着 Three.js 版本升级，大约在 r126 版本以后官方已经将内置的 .d.ts 文件移除，目前最新的版本是 r128。&lt;/p>
&lt;p>&lt;strong>所以，我们现在还需要额外安装对应的 .d.ts 文件包：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>//npm install @types/three
yarn add @types/three
&lt;/code>&lt;/pre>&lt;br>
&lt;p>本系列教程前面相当一部分示例是基于 Three.js 0.124.0 的，而这些示例有可能会在最新版本 0.127.0 中不能正常运行，特此说明。&lt;/p>
&lt;blockquote>
&lt;p>所谓不能正常运行，多数都是因为某些类在新版本中引入路径发生了变化，可根据 VSCode 中的提示进行修改。&lt;/p>
&lt;/blockquote>
&lt;p>我们会在第 23 小节开始，使用 Three.js 最新版本 r127。&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>以上更新于 2021.04.11&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>第 9 步：给 package.json 添加 homepage 字段&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;name&amp;#34;: &amp;#34;test-threejs&amp;#34;,
&amp;#34;homepage&amp;#34;: &amp;#34;.&amp;#34;,
...
}
&lt;/code>&lt;/pre>&lt;p>homepage 字段是用来设定 html 中文件资源(编译后的 js 或 css) 的根 URL 地址。&lt;/p>
&lt;p>假设不添加 homepage 字段，则默认使用网站根目录作为 资源根目录。&lt;/p>
&lt;blockquote>
&lt;p>我猜测 homepage 的默认值是 &amp;ldquo;/&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>如果你的项目将来并不是发布在网站根目录，那么设置 homepage 字段会非常有用。&lt;/p>
&lt;p>举例：&lt;/p>
&lt;p>假设将来项目网址为：https://threejs.puxiao.com，那么你完全可以跳过本步骤，不作任何修改。&lt;/p>
&lt;p>但若将来项目网址为：https://threejs.puxiao.com/demo/，那么此时所有文件资源存放在 demo 这个目录下(并不是网站根目录)，那么必须给 package.json 添加 &amp;ldquo;homepage&amp;rdquo;: &amp;ldquo;.&amp;quot;，不然文件资源都会出现 404 状态。&lt;/p>
&lt;p>&lt;strong>第 10 步：清理默认 create-react-app 创建的一些无用内容&lt;/strong>&lt;/p>
&lt;p>以下为我个人的习惯，你可以根据自己喜好对应选择是否清理。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>清除掉 index.tsx 中 &amp;lt;React.StrictMode&amp;gt; 、reportWebVitals()&lt;/p>
&lt;blockquote>
&lt;p>目前 React 最新版中对应的 tsconfig.json 默认就使用的是严格模式，因此 &amp;lt;React.StrictMode&amp;gt; 是可以删除掉的&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>删除掉 src 目录下 setupTests.ts、reportWebVitals.ts、App.test.tsx 文件&lt;/p>
&lt;blockquote>
&lt;p>这些都是用来做 React 自动单元调试的，暂且用不到&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>删除掉 public 目录下 logo192.png、logo512.png、manifest.json、robots.txt&lt;/p>
&lt;/li>
&lt;li>
&lt;p>清除掉 public 目录下 index.html 中无用的代码，只保留最基础的标签。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;#34;zh-CN&amp;#34;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt;
&amp;lt;link rel=&amp;#34;icon&amp;#34; href=&amp;#34;%PUBLIC_URL%/favicon.ico&amp;#34; /&amp;gt;
&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34; /&amp;gt;
&amp;lt;meta name=&amp;#34;theme-color&amp;#34; content=&amp;#34;#000000&amp;#34; /&amp;gt;
&amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;Web site created using create-react-app&amp;#34; /&amp;gt;
&amp;lt;title&amp;gt;Hello Threejs&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;noscript&amp;gt;You need to enable JavaScript to run this app.&amp;lt;/noscript&amp;gt;
&amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>经过以上 10 个步骤之后，已经创建好了一个基础的开发环境：React + TypeScript + Scss + Alias + Threejs&lt;/p>
&lt;p>下一章，终于要开始编写 hello world 了。&lt;/p></description></item><item><title>03.编写HelloThreejs</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/03.%E7%BC%96%E5%86%99hellothreejs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/03.%E7%BC%96%E5%86%99hellothreejs/</guid><description>&lt;h1 id="03-编写-hellothreejs">03 编写 HelloThreejs&lt;/h1>
&lt;p>终于要真正第一次亲密接触 Three.js 了。&lt;/p>
&lt;p>我们先梳理一下创建一个 Three.js 示例所需要的过程，认真阅读并理解整个过程，会更加容易让你读懂我后面的示例代码。&lt;/p>
&lt;h2 id="从引入-three-到创建示例的过程">从引入 Three 到创建示例的过程&lt;/h2>
&lt;h3 id="第-1-环节引入-threejs">第 1 环节：引入 Three.js&lt;/h3>
&lt;p>&lt;strong>引入方式 1：将 THREE 一次全部引入&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import THREE from &amp;#39;three&amp;#39;
//当需要使用某个具体的模块时，例如创建场景，则代码如下
const scene = new THREE.Scene()
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>这种方式会将所有 Three.js 相关模块都引入进来，虽然引入代码简介，但是会造成项目打包输出时文件过大，因此并不建议这样引入。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>请注意：默认 three 模块导出的名字就是全部大写的 “THREE”。我个人非常不习惯 模块名称 全部大写，我的代码习惯是使用 “Three”。&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import * as Three from &amp;#39;three&amp;#39;
const scene = new Three.Scene()
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;strong>本系列文章中使用的示例，代码绝大多数都采用这种引入形式，使用 Three 而 不使用 THREE。&lt;br>
所以网上一些教程中可能描述某个类时使用的是 THREE.Xxxx，而我在本系列文章中都会使用 Three.Xxxx 这种方式。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>引入方式 2：按需引入模块&lt;/strong>&lt;/p>
&lt;p>例如我们需要使用 Scene 模块，则仅引入该模块即可&lt;/p>
&lt;pre tabindex="0">&lt;code>import { Scene } from &amp;#39;three&amp;#39;
//当需要使用某个具体的模块时，例如创建场景，则代码如下
const scene = new Scene()
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>本文示例代码，都将采用按需引入的方式。&lt;/p>
&lt;/blockquote>
&lt;h3 id="第-2-环节将-dom-中的-canvas-与-threejs-中的渲染器进行挂钩">第 2 环节：将 DOM 中的 canvas 与 Threejs 中的渲染器进行挂钩&lt;/h3>
&lt;p>&lt;strong>采用 React 的 useEffect + useRef 来实现所谓 “挂钩” 。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>具体参见示例代码&lt;/p>
&lt;/blockquote>
&lt;h3 id="第-3-环节创建-threejs-基础-3-大元素场景可见元素">第 3 环节：创建 Three.js 基础 3 大元素、场景可见元素&lt;/h3>
&lt;p>&lt;strong>基础 3 大元素：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>渲染器 &amp;gt; 本文示例采用的渲染器是 WebGLRenderer&lt;/li>
&lt;li>透视镜头 &amp;gt; 本文示例采用的是 PerspectiveCamera&lt;/li>
&lt;li>场景 &amp;gt; Scen&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>场景可见元素：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>几何体 &amp;gt; 本文示例采用的是 BoxGeometry(立方体)&lt;/li>
&lt;li>几何体的材质(颜色、光亮程度) &amp;gt; 本文示例采用的是 MeshBasicMaterial 或 MeshPhongMaterial&lt;/li>
&lt;li>网格 &amp;gt; Mesh&lt;/li>
&lt;li>光源 &amp;gt; 本文示例采用的是 DirectionalLight(平行光源)&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>你应该发现，除了 场景(Scen)、网格(Mesh) 之外，其他的元素我都注明 “本文示例采用的是&amp;hellip;”。&lt;/p>
&lt;p>因为无论渲染器，还是几何体，以及其他元素，Three.js 都内置了非常多不同种类的元素构造函数，这个会在以后学习中逐渐详细说明举例。&lt;/p>
&lt;h3 id="第-4-环节使用渲染器渲染出画面">第 4 环节：使用渲染器渲染出画面&lt;/h3>
&lt;p>&lt;strong>渲染画面&lt;/strong>&lt;/p>
&lt;p>就是根据第 3 环节中所创建出的 3D 场景，渲染出画面，并将画面内容填充到 canvas 中。&lt;/p>
&lt;p>本文示例中，为了呈现 3D 动画，使用到了浏览器中 window.requestAnimationFrame() 这个函数。&lt;/p>
&lt;blockquote>
&lt;p>关于 window.requestAnimationFrame() 的用法请参考：https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame&lt;/p>
&lt;/blockquote>
&lt;h3 id="补充说明3d-动画是怎么动起来的">补充说明：3D 动画是怎么动起来的？&lt;/h3>
&lt;p>默认情况下，渲染出的 3D 场景都是静止的，所谓 3D 动画，本质上是因为 “场景” 上发生了 “变化” 被渲染器不断重新渲染。&lt;/p>
&lt;p>引起这些所谓 “变化”，简单可归纳为以下几种原因：&lt;/p>
&lt;ol>
&lt;li>镜头不变，但可见场景元素发生了变化，例如几何体发生了变化、网格角度发生了变化等&lt;/li>
&lt;li>可见场景元素不变，但是镜头发生了变化，例如镜头的推近、拉远等&lt;/li>
&lt;li>镜头变化了，同时场景元素也变化了&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h2 id="示例代码">示例代码&lt;/h2>
&lt;h4 id="第-1-步创建并编写-indextsx-代码内容">第 1 步：创建并编写 index.tsx 代码内容&lt;/h4>
&lt;p>在 src/components/hello-threejs 目录下，创建 index.tsx 作为我们自定义的组件。&lt;/p>
&lt;p>编写该组件对应的代码内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>import React, { useRef, useEffect } from &amp;#39;react&amp;#39;
import { WebGLRenderer, PerspectiveCamera, Scene, BoxGeometry, Mesh, DirectionalLight, MeshPhongMaterial } from &amp;#39;three&amp;#39;
const HelloThreejs: React.FC = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current) {
//创建渲染器
const renderer = new WebGLRenderer({ canvas: canvasRef.current })
//创建镜头
//PerspectiveCamera() 中的 4 个参数分别为：
//1、fov(field of view 的缩写)，可选参数，默认值为 50，指垂直方向上的角度，注意该值是度数而不是弧度
//2、aspect，可选参数，默认值为 1，画布的宽高比(宽/高)，例如画布宽300像素，高150像素，那么意味着宽高比为 2
//3、near，可选参数，默认值为 0.1，近平面，限制摄像机可绘制最近的距离，若小于该距离则不会绘制(相当于被裁切掉)
//4、far，可选参数，默认值为 2000，远平面，限制摄像机可绘制最远的距离，若超出该距离则不会绘制(相当于被裁切掉)
//以上 4 个参数在一起，构成了一个 “视椎”，关于视椎的概念理解，暂时先不作详细描述。
const camera = new PerspectiveCamera(75, 2, 0.1, 5)
//创建场景
const scene = new Scene()
//创建几何体
const geometry = new BoxGeometry(1, 1, 1)
//创建材质
//我们需要让立方体能够反射光，所以不使用MeshBasicMaterial，而是改用MeshPhongMaterial
//const material = new MeshBasicMaterial({ color: 0x44aa88 })
const material = new MeshPhongMaterial({ color: 0x44aa88 })
//创建网格
const cube = new Mesh(geometry, material)
scene.add(cube)//将网格添加到场景中
//创建光源
const light = new DirectionalLight(0xFFFFFF, 1)
light.position.set(-1, 2, 4)
scene.add(light)//将光源添加到场景中，若场景中没有任何光源，则可反光材质的物体渲染出的结果是一片漆黑，什么也看不见
//设置透视镜头的Z轴距离，以便我们以某个距离来观察几何体
//之前初始化透视镜头时，设置的近平面为 0.1，远平面为 5
//因此 camera.position.z 的值一定要在 0.1 - 5 的范围内，超出这个范围则画面不会被渲染
camera.position.z = 2
//渲染器根据场景、透视镜头来渲染画面，并将该画面内容填充到 DOM 的 canvas 元素中
//renderer.render(scene, camera)//由于后面我们添加了自动渲染渲染动画，所以此处的渲染可以注释掉
//添加自动旋转渲染动画
const render = (time: number) =&amp;gt; {
time = time * 0.001 //原本 time 为毫秒，我们这里对 time 进行转化，修改成 秒，以便于我们动画旋转角度的递增
cube.rotation.x = time
cube.rotation.y = time
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} /&amp;gt;
)
}
export default HelloThreejs
&lt;/code>&lt;/pre>&lt;h4 id="第-2-步添加对-hellothreejs-组件的使用">第 2 步：添加对 HelloThreejs 组件的使用&lt;/h4>
&lt;p>修改 src/app.tsx 对应的代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>import &amp;#39;./App.scss&amp;#39;
import HelloThreejs from &amp;#39;@/components/hello-threejs&amp;#39;;
const App = () =&amp;gt; {
return (
&amp;lt;HelloThreejs /&amp;gt;
)
}
export default App;
&lt;/code>&lt;/pre>&lt;h4 id="第-3-步查看运行效果">第 3 步：查看运行效果&lt;/h4>
&lt;pre tabindex="0">&lt;code>yarn start
&lt;/code>&lt;/pre>&lt;p>若无意外，你会在浏览器中看到一个 高 150 像素，宽 300 像素的 黑色场景，该场景上一直有一个 3D 立方体在旋转。&lt;/p>
&lt;p>至此，我们的第一个 Three.js 示例完成。&lt;/p>
&lt;h2 id="如何让场景有多个立方体">如何让场景有多个立方体？&lt;/h2>
&lt;p>首先回忆一下 &amp;ldquo;01 Three.js 简介.md&amp;rdquo; 中 “Three.js 中的技术名词” 中关于 网格的介绍。&lt;/p>
&lt;p>&lt;strong>网格：一种特定的 几何体和材质 绘制出的一个特定的几何体系。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>网格包含的内容为：几何体、几何体的材质、几何体的自身网格坐标体系&lt;/strong>&lt;/p>
&lt;p>&lt;strong>在 Three.js 中，要牢记以下几个概念：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一个几何体或材质，可以同时被多个网格使用(引用)&lt;/li>
&lt;li>一个场景内，可以添加多个网格&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>那和让场景中有多个立方体？&lt;/strong>&lt;/p>
&lt;p>答：使用相同或不同的几何体(立方体)，以及相同或不同的材质，去创建多个网格(特定的几何体)，然后将多个网格添加到同一个场景中。&lt;/p>
&lt;blockquote>
&lt;p>注意：为了不同的立方体在场景中不叠加在一起，所以我们还要将网格(特定的几何体)的位置设置成不同的值。&lt;/p>
&lt;/blockquote>
&lt;h4 id="具体代码的修改">具体代码的修改：&lt;/h4>
&lt;p>1、我们假定继续使用原有示例中的立方体，因此创建几何体的代码不变。&lt;/p>
&lt;p>2、为了凸显立方体的区别，我们将创建 3 个不同颜色的材质。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- //创建纹理
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const material = new MeshBasicMaterial({ color: 0x44aa88 })
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ //创建 3 个纹理
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const material1 = new MeshPhongMaterial({ color: 0x44aa88 })
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const material2 = new MeshPhongMaterial({ color: 0xc50d0d })
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const material3 = new MeshPhongMaterial({ color: 0x39b20a })
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>3、创建 3 个网格，每个网格的水平位置不同&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- //创建网格
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const cube = new Mesh(geometry, material)~~
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- scene.add(cube)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ //创建 3 个网格
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const cube1 = new Mesh(geometry, material1)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ cube1.position.x = -2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ scene.add(cube1)//将网格添加到场景中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const cube2 = new Mesh(geometry, material2)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ cube2.position.x = 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ scene.add(cube2)//将网格添加到场景中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const cube3 = new Mesh(geometry, material3)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ cube3.position.x = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ scene.add(cube3)//将网格添加到场景中
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>4、为了便于后面对于不同网格的循环修改，我们将创建包含 3 个网格的一个数组&lt;/p>
&lt;pre tabindex="0">&lt;code>const cubes = [cube1, cube2, cube3]
&lt;/code>&lt;/pre>&lt;p>5、修改自动旋转渲染动画的相关代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- cube.rotation.x = time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- cube.rotation.y = time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ //通过 cube.map 循环遍历修改网格相关属性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ cubes.map(cube =&amp;gt; {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ cube.rotation.x = time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ cube.rotation.y = time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ })
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>6、保存并重新执行 yarn start，若一切正常此时就会看到 画面中有 3 个不同颜色的立方体同时在做旋转动画。&lt;/p>
&lt;blockquote>
&lt;p>目前 3 个立方体仅仅是颜色和位置不同，你可以尝试将立方体设置为不同的尺寸，不同的旋转频率等等，自己发挥吧。&lt;/p>
&lt;/blockquote>
&lt;p>是不是感觉自己对 Three.js 场景有进一步有所掌握 ^_^。&lt;/p>
&lt;p>&lt;strong>下一节，我们将进一步改进这个示例代码。&lt;/strong>&lt;/p></description></item><item><title>04.添加一些自适应</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/04.%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/04.%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/</guid><description>&lt;h1 id="04-添加一些自适应">04 添加一些自适应&lt;/h1>
&lt;p>在上一节中，已经实现了 HelloThree 最为基础的示例。本节将进一步优化那个示例。&lt;/p>
&lt;p>我们将给示例中的 canvas 添加宽高自适应，让它充满整个浏览器。&lt;/p>
&lt;br>
&lt;h3 id="优化第一项修改-canvas-尺寸">优化第一项：修改 canvas 尺寸&lt;/h3>
&lt;p>默认 canvas 尺寸为 高 150 像素，宽 300 像素。我们现在把 canvas 修改为撑满屏幕。&lt;/p>
&lt;br>
&lt;h4 id="第-1-处修改">第 1 处修改：&lt;/h4>
&lt;p>打开项目中 src/indes.scss ，修改 html、body、root 样式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">body{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- margin:0;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">html,body {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ margin: 0;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ padding: 0;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ height: 100%;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ width: 100%;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#root {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ height: inherit;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ width: inherit;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>由于我们已经给 html, body 设置了 宽高 100%，所以 root 宽高 设置为 inherit 即可。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="第-2-处修改">第 2 处修改：&lt;/h4>
&lt;p>新建文件 src/components/hello-threejs/index.scss，添加 canvas 样式：&lt;/p>
&lt;pre tabindex="0">&lt;code>.full-screen {
display: block;
width: inherit;
height: inherit;
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>canvas 宽高继承于 root，root 继承于 body，而 body 宽高均为 100%，所以最终 canvas 宽高也为 100%，撑满整个屏幕。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>特别提醒：&lt;/strong> 在上面样式中，我们设置了 display 为 block，让 canvas 由 内联元素 改为 块级元素。&lt;/p>
&lt;p>为什么要这么做？&lt;/p>
&lt;p>因为我们在后面代码中，需要获取 canvas 的 clientWidth(内部实际宽度) 和 clientHeight(内部实际高度)，而内联元素是无法获取到这 2 两个属性值的，因此我们要将画布修改为块级元素。&lt;/p>
&lt;blockquote>
&lt;p>内联元素和没有 CSS 样式的元素，获取到的 clientWidht 和 clientHeight 的值永远为 0&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="第-3-处修改">第 3 处修改：&lt;/h4>
&lt;p>在 src/components/hello-threejs/index.stx 中引入并添加样式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ import &amp;#39;./index.scss&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">const HelloThreejs: React.FC = () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，再次执行预览 &lt;code>yarn start&lt;/code>，就会发现 canvas 已全屏，充满整个浏览器可见区域。&lt;/p>
&lt;br>
&lt;h4 id="目前存在的问题">目前存在的问题：&lt;/h4>
&lt;p>可以观察到 canvas 是被硬生生由原本的 高 150、像素 宽 300 像素给硬生生拉伸成 100%。&lt;/p>
&lt;p>所以立方体出现了 扭曲、模糊、锯齿。&lt;/p>
&lt;p>那我们继续修改代码。&lt;/p>
&lt;br>
&lt;h4 id="第-4-处修改">第 4 处修改：&lt;/h4>
&lt;p>修改 src/components/hello-threejs/index.stx 中 render 函数的代码，让镜头宽高比跟随着 canvas 宽高比，确保立方体不变形。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const render = (time: number) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> time = time * 0.001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const canvas = renderer.domElement //获取 canvas
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ camera.aspect = canvas.clientWidth / canvas.clientHeight //设置镜头宽高比
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ camera.updateProjectionMatrix() //通知镜头更新视椎(视野)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cubes.map(cube =&amp;gt; { ... }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;h4 id="第-5-处修改">第 5 处修改：&lt;/h4>
&lt;p>第 4 步立方体已经不再变形，但是依然模糊，锯齿感比较明显。原因是渲染器(renderer) 渲染出的画面尺寸小于实际网页 canvas 尺寸。&lt;/p>
&lt;p>继续修改 src/components/hello-threejs/index.tsx 中 render 函数的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const render = (time: number) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> time = time * 0.001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const canvas = renderer.domElement //获取 canvas
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> camera.aspect = canvas.clientWidth / canvas.clientHeight //设置镜头宽高比
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> camera.updateProjectionMatrix() //通知镜头更新视椎(视野)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ //第3个参数为可选参数，默认值为 true，false 意思是阻止因渲染内容尺寸发生变化而去修改 canvas 尺寸
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cubes.map(cube =&amp;gt; { ... }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>经过上面一番修改，浏览器中 canvas 里的立方体会变得不变形，且非常清晰。&lt;/p>
&lt;br>
&lt;p>&lt;strong>关于 renderer.setSize() 第 3 个参数的补充说明：&lt;/strong>&lt;/p>
&lt;p>在本示例中 renderer 是 WebGLRenderer 实例。&lt;/p>
&lt;p>我查看了一下 WebGLRenderer setSize() 源码：https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js&lt;/p>
&lt;p>发现了其中以下代码片段：&lt;/p>
&lt;pre tabindex="0">&lt;code>this.setSize = function ( width, height, updateStyle ) {
...
if ( updateStyle !== false ) {
_canvas.style.width = width + &amp;#39;px&amp;#39;;
_canvas.style.height = height + &amp;#39;px&amp;#39;;
}
...
}
&lt;/code>&lt;/pre>&lt;p>可以看出，假设第 3 个参数不传值，那么该参数值实际调用时为 undefined，undefined !==false 的值为 true 。&lt;/p>
&lt;p>因此我们可以得出结论：&lt;strong>setSize() 第 3 个参数的默认值为 true&lt;/strong>，当我们希望控制尺寸的主动权完全由 canvas 决定时，那么一定要设置第 3 个参数为 false。&lt;/p>
&lt;br>
&lt;h2 id="如何应对高清屏">如何应对高清屏？&lt;/h2>
&lt;p>从上面示例可以看出，浏览器中渲染的画面尺寸，完全是按照 CSS 样式尺寸来显示的。&lt;/p>
&lt;p>对于高清屏(HD-DPI)来说，那 Three.js 渲染的画面又该有何应对呢？&lt;/p>
&lt;br>
&lt;h4 id="第-1-种策略推荐不做任何策略">第 1 种策略(推荐)：不做任何策略&lt;/h4>
&lt;p>假设 HD-DP 比例为 3x，即原本 1 像素 则由 3 x 3 ，共 9 个像素来显示。&lt;/p>
&lt;p>也就是说原本只需渲染 1 像素，现在需要渲染 9 像素，所消耗的性能是原来的 9 倍。&lt;/p>
&lt;p>假设 3D 场景内容稍微复杂一些，那所带来的渲染性能要求会非常高，画面清晰的代价是更高性能的消耗，引起的卡顿 会带来不好的用户体验。&lt;/p>
&lt;p>事实上高清屏本身都会做显示优化，即使不做任何处理，画面清晰度并不会明显特别差。&lt;/p>
&lt;p>因此，什么都不做，其实是一个非常好的策略。&lt;/p>
&lt;br>
&lt;p>假设就是想设置成高清屏，那又该如何操作呢？&lt;/p>
&lt;h4 id="第-2-种策略强烈不推荐通过-renderersetpixelratio-来配置渲染分辨率倍数">第 2 种策略(强烈不推荐)：通过 renderer.setPixelRatio 来配置渲染分辨率倍数&lt;/h4>
&lt;p>在浏览器中，通过 window.devicePixelRatio 可获得当前屏幕物理分辨率与 CSS 样式分辨率的比值。&lt;/p>
&lt;p>然后告知渲染器，以后任何 renderer.setSize 都按照此 比值(倍数) 进行渲染&lt;/p>
&lt;pre tabindex="0">&lt;code>renderer.setPixelRatio(window.devicePixelRatio)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>强烈不推荐这种做法。&lt;/strong>&lt;/p>
&lt;br>
&lt;h4 id="第-3-种策略勉强推荐按屏幕分辨率比值计算出对应渲染尺寸">第 3 种策略(勉强推荐)：按屏幕分辨率比值，计算出对应渲染尺寸&lt;/h4>
&lt;p>这种策略思路是：通过分辨率比值，计算出实际上应该渲染的最大尺寸，然后渲染出这个尺寸，再将画面内容渲染到 canvas 中。&lt;/p>
&lt;p>举例：假设 HD-DP 比例为 3x，即 普通宽 1 像素对应高清屏宽 3 像素。那么可以将 renderer 渲染出比 canvas 实际大 3 倍的画面，然后再将画面以 “压缩” 3 倍的形式填充到 canvas 中，从而实现所谓的 “高清屏渲染”。&lt;/p>
&lt;p>这样的操作，会使 渲染器 renderer 像正常渲染一样来执行各种渲染操作。&lt;/p>
&lt;p>&lt;strong>对应的渲染代码为：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const canvas = renderer.domElement
const ratio = window.devicePixelRatio
const newWidth = Math.floor(canvas.clientWidth * ratio)
const newHeight = Math.floor(canvas.clientHeight * ratio)
renderer.setSize(newWidth,newHeight,false) //特别注意，第 3 个参数一定要为 false
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;strong>尽管第 3 种策略相对第 2 种好一些，但是还是建议选择第 1 种策略，即什么也不做。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>你看在线视频时，关于清晰度会做哪种选择？&lt;br>
A：蓝光 1080P，画面超级清晰，但播放时会有点卡顿&lt;br>
B：高清 720 P，画面清晰度能够接受，播放时也非常流畅&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>至此，关于 Three.js 的入门演示示例，已经结束。&lt;/p>
&lt;br>
&lt;h2 id="等一等我们现在的代码正确吗">等一等，我们现在的代码正确吗？&lt;/h2>
&lt;p>目前来说，虽然实际运行没有一点问题，但代码实际上并不是最优的。&lt;/p>
&lt;p>现在做给渲染器添加尺寸发生变化的代码是放在了 window.requestAnimationFrame() 中，每一次浏览器刷新都重新计算并设置一次，事实上在浪费着性能。&lt;/p>
&lt;p>我们需要改进的地方时：仅在浏览器窗口尺寸发生 resize 事件时去修改 渲染器 即可。&lt;/p>
&lt;br>
&lt;p>&lt;strong>需要说明的地方：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>监听浏览器窗口尺寸变化，对应的是 window.addEventListener(&amp;lsquo;resize&amp;rsquo;, xxxx)&lt;/li>
&lt;li>当 React 卸载后，一定记得移除监听 window.removeEventListener(&amp;lsquo;resize&amp;rsquo;, xxxx)&lt;/li>
&lt;li>为了在移除监听时可以找到 在 useEffect 中定义的 resize 事件处理函数，我们会在示例代码中，再通过 useRef 创建一个变量指向 事件处理函数。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>最终修改后的代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import React, { useRef, useEffect } from &amp;#39;react&amp;#39;
import { WebGLRenderer, PerspectiveCamera, Scene, BoxGeometry, Mesh, DirectionalLight, MeshPhongMaterial } from &amp;#39;three&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const HelloThreejs: React.FC = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const resizeHandleRef = useRef&amp;lt;() =&amp;gt; void&amp;gt;()
useEffect(() =&amp;gt; {
if (canvasRef.current) {
//创建渲染器
const renderer = new WebGLRenderer({ canvas: canvasRef.current })
//创建镜头
//PerspectiveCamera() 中的 4 个参数分别为：
//1、fov(field of view 的缩写)，可选参数，默认值为 50，指垂直方向上的角度，注意该值是度数而不是弧度
//2、aspect，可选参数，默认值为 1，画布的高宽比，例如画布高300像素，宽150像素，那么意味着高宽比为 2
//3、near，可选参数，默认值为 0.1，近平面，限制摄像机可绘制最近的距离，若小于该距离则不会绘制(相当于被裁切掉)
//4、far，可选参数，默认值为 2000，远平面，限制摄像机可绘制最远的距离，若超出该距离则不会绘制(相当于被裁切掉)
//以上 4 个参数在一起，构成了一个 “视椎”，关于视椎的概念理解，暂时先不作详细描述。
const camera = new PerspectiveCamera(75, 2, 0.1, 5)
//创建场景
const scene = new Scene()
//创建几何体
const geometry = new BoxGeometry(1, 1, 1)
//创建材质
//我们需要让立方体能够反射光，所以不使用MeshBasicMaterial，而是改用MeshPhongMaterial
//const material = new MeshBasicMaterial({ color: 0x44aa88 })
const material1 = new MeshPhongMaterial({ color: 0x44aa88 })
const material2 = new MeshPhongMaterial({ color: 0xc50d0d })
const material3 = new MeshPhongMaterial({ color: 0x39b20a })
//创建网格
const cube1 = new Mesh(geometry, material1)
cube1.position.x = -2
scene.add(cube1)//将网格添加到场景中
const cube2 = new Mesh(geometry, material2)
cube2.position.x = 0
scene.add(cube2)//将网格添加到场景中
const cube3 = new Mesh(geometry, material3)
cube3.position.x = 2
scene.add(cube3)//将网格添加到场景中
const cubes = [cube1, cube2, cube3]
//创建光源
const light = new DirectionalLight(0xFFFFFF, 1)
light.position.set(-1, 2, 4)
scene.add(light)//将光源添加到场景中
//设置透视镜头的Z轴距离，以便我们以某个距离来观察几何体
//之前初始化透视镜头时，设置的近平面为 0.1，远平面为 5
//因此 camera.position.z 的值一定要在 0.1 - 5 的范围内，超出这个范围则画面不会被渲染
camera.position.z = 2
//渲染器根据场景、透视镜头来渲染画面，并将该画面内容填充到 DOM 的 canvas 元素中
//renderer.render(scene, camera)//由于后面我们添加了自动渲染渲染动画，所以此处的渲染可以注释掉
//添加自动旋转渲染动画
const render = (time: number) =&amp;gt; {
time = time * 0.001
// cube.rotation.x = time
// cube.rotation.y = time
cubes.forEach(cube =&amp;gt; {
cube.rotation.x = time
cube.rotation.y = time
})
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
const canvas = renderer.domElement
camera.aspect = canvas.clientWidth / canvas.clientHeight
camera.updateProjectionMatrix()
renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
}
handleResize() //默认打开时，即重新触发一次
resizeHandleRef.current = handleResize //将 resizeHandleRef.current 与 useEffect() 中声明的函数进行绑定
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize) //添加窗口 resize 事件处理函数
}
return () =&amp;gt; {
if (resizeHandleRef &amp;amp;&amp;amp; resizeHandleRef.current) {
window.removeEventListener(&amp;#39;resize&amp;#39;, resizeHandleRef.current)
}
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloThreejs
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;strong>再次补充说明：&lt;/strong>&lt;/p>
&lt;p>尽管代码已经有所改进，但上述代码中，创建 3D 场景的代码都集中在 useEffect(() =&amp;gt; { if (canvasRef.current) { &amp;hellip; } }, [canvasRef] ) ，这很显然并不是合理的。&lt;/p>
&lt;p>合理的应该是通过 useState() 去将 renderer、camera、scene 等都独立出来定义。&lt;/p>
&lt;p>将原本集中的代码分散到更多小的 代码块 中。&lt;/p>
&lt;p>包括浏览器窗口 resize 事件处理，都应该添加 防抖 策略。&lt;/p>
&lt;p>这里就先暂时这样，不再做改进，等到将来再去做稍微复杂点的 场景应用 时，会再次优化代码结构。&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>以下内容更新于 2021.05.11&lt;/p>
&lt;/blockquote>
&lt;h4 id="通过-resizeobserver-来监听画布尺寸变化">通过 ResizeObserver 来监听画布尺寸变化&lt;/h4>
&lt;p>在本文以及本教程的所有后面章节中，我们都是通过监听 window resize 事件，在 handleResize 处理函数中重新设置 相机和渲染器 的一些属性配置的。&lt;/p>
&lt;p>由于这些示例中实际上只存在一个 &amp;lt;canvas &amp;gt; 标签，画布(canvas) 的尺寸是充满整个浏览器窗口，画布尺寸发生变化的情况只有一种，即 浏览器窗口尺寸发生变化。&lt;/p>
&lt;p>但是在实际的项目中，有可能 &amp;lt;canvas &amp;gt; 标签仅仅只占 document.body 中的一部分而已，造成 画布(canvas) 尺寸发生变化，还有以下几种可能：&lt;/p>
&lt;ol>
&lt;li>通过 CSS 修改 &amp;lt;canvas &amp;gt; 标签的宽高&lt;/li>
&lt;li>在 flex 布局下，当其他元素尺寸发生变化时，影响到 &amp;lt;canvas &amp;gt; ，从而造成画布发生尺寸变化。&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>很明显，通过 CSS 的变化造成 画布尺寸变化，和 window resize 完全不相关联。&lt;/p>
&lt;p>因此我们要寻找其他监听 画布 标签尺寸发生变化的方式。&lt;/p>
&lt;br>
&lt;p>&lt;strong>我们可以通过浏览器最新的 ResizeObserver 来监听 &amp;lt;canvas &amp;gt; 尺寸变化。&lt;/strong>&lt;/p>
&lt;br>
&lt;p>&lt;strong>ResizeObserver 简介&lt;/strong>&lt;/p>
&lt;p>ResizeObserver 是现代浏览器 API 中一个新的内置类，它可以监控某个 DOM 元素尺寸变化。&lt;/p>
&lt;blockquote>
&lt;p>在 ResizeObserver 出现之前，只能对 window 添加 resize 监听，无法对 DOM 元素添加尺寸变化监听。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;blockquote>
&lt;p>observer 单词意思是 “观察”，也就是设计模式中的 “观察模式”，但是我个人习惯性有时候称呼为 “监控模式”&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>ResizeObserver 一共有 3 个方法：&lt;/p>
&lt;ol>
&lt;li>observe()：开始监控(观察)某元素尺寸变化&lt;/li>
&lt;li>unobserve()：停止监控(观察)某元素尺寸变化&lt;/li>
&lt;li>disconnect()：取消和结束目标元素上所有的监控(观察)&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>更多详细介绍，请查阅：&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver&lt;/a>&lt;/p>
&lt;br>
&lt;p>&lt;strong>实际示例代码：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">const handleResize = () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const canvas = renderer.domElement
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> camera.aspect = canvas.clientWidth / canvas.clientHeight
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> camera.updateProjectionMatrix()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">handleResize()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//我们不再添加 window resize 监控(观察)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//改为使用 ResizeObserver 来监控(观察)尺寸变化
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const resizeObserver = new ResizeObserver(() =&amp;gt; {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ handleResize()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ })
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ resizeObserver.observe(canvasRef.current)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//当我们卸载组件前，一定要 清除掉 监控(观察)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">return () =&amp;gt;{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- window.removeEventListener(&amp;#39;resize&amp;#39;, resizeHandleRef.current)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ resizeObserver.disconnect()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>请注意，resizeObserver.observe() 方法中，可以有第 2 个可选参数。&lt;/p>
&lt;p>例如：resizeObserver.observe(canvasRef.current, { box: &amp;lsquo;border-box&amp;rsquo; })&lt;/p>
&lt;p>如果第 2 个可选参数不填，那么默认值为 { box: &amp;lsquo;content-box&amp;rsquo; }&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>与本文无关的事情&lt;/strong>&lt;/p>
&lt;p>我在查阅 MDN 关于 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver/observe" target="_blank" rel="noopener">ResizeObserver.observer()&lt;/a> 介绍时，发现 简体中文(zh-cn) 介绍页中缺少对第 2 个参数，也就是可选参数的中文介绍，于是我就向 MDN 提交了 PR，添加上了该部分。&lt;/p>
&lt;p>&lt;a href="https://github.com/mdn/translated-content/pull/817" target="_blank" rel="noopener">https://github.com/mdn/translated-content/pull/817&lt;/a>&lt;/p>
&lt;p>目前该 PR 已经被合并进 main 中，但是正常访问的 MDN 网页中还未更新过来，估计过一段时间就会看到。&lt;/p>
&lt;blockquote>
&lt;p>或许此刻已经更新了。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;blockquote>
&lt;p>以上内容更新于 2021.05.11&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>那么接下来，会系统学习一下 Three.js 的一些基础理论。&lt;/p>
&lt;p>&lt;strong>大楼究竟能改多高，取决于地基有多深，加油！&lt;/strong>&lt;/p></description></item><item><title>05.Three.js 基础之图元</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/05.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%85%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/05.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%85%83/</guid><description>&lt;h1 id="05-threejs-基础之图元">05 Three.js 基础之图元&lt;/h1>
&lt;h2 id="图元primitives介绍">图元(Primitives)介绍&lt;/h2>
&lt;p>Primitive 这个单词在百度翻译里的解释是：原始的、远古的&lt;/p>
&lt;p>Primitive 的复数即为 Primitives。&lt;/p>
&lt;p>&lt;strong>所谓 图元 就是 Three.js 内置的一些基础 3D 形状，例如 立方体、球体、圆锥体等。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>有些文章或教程，包括 Three.js 官方文档，都是将 图元 称呼为 几何体。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>但是在本文中，我们依然先使用 图元 这个称呼。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>请注意，内置的图元并不一定都是 3 维体，也可以是 2 维的，例如 平面圆。&lt;/p>
&lt;/blockquote>
&lt;p>例如之前写的 HelloThreejs 示例中，就使用 BoxGeometry 来创建立方体。&lt;/p>
&lt;blockquote>
&lt;p>虽然我们一直称呼为 立方体，但实际在 Three.js 中称呼其为 盒子(box)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在本文后面的一些文章中，也会将图元称呼为几何体。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;br>
&lt;hr>
&lt;blockquote>
&lt;p>以下内容更新于 2021.07.20&lt;/p>
&lt;/blockquote>
&lt;p>之前在写这篇文章的时候，还没有学习过图形学，所以对于一些名词的概念解释都是想当然，甚至是胡说八道，胡言乱语。&lt;/p>
&lt;br>
&lt;h4 id="顶点图元片元图像-他们之间的递进关系">顶点、图元、片元、图像 他们之间的递进关系&lt;/h4>
&lt;p>&lt;strong>顶点&lt;/strong>：就是在 3D 世界中某一个具体的点，即点的位置(x,y,z)。除了位置信息，还可能包括 点的颜色或其他信息。&lt;/p>
&lt;blockquote>
&lt;p>请注意，这些顶点位置都是相对的，依次是 局部位置、全局位置、镜头位置等等。&lt;/p>
&lt;p>在管线渲染流程中，顶点处理模块的作用就是负责将顶点进行坐标转换。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>图元&lt;/strong>：由若干个顶点构成的一组数据，用于构建或描述某种 二维或三维物体。&lt;/p>
&lt;blockquote>
&lt;p>图元 中的 “元” 字可以理解为 “原始”的原，也就是说使用最少的点来描述一个物体的空间信息。&lt;/p>
&lt;p>只有 1 个顶点依然可以是 图元，它只能表示某一个 点。例如 自动驾驶中扫描周围环境得到的 3D 点云数据就是由 一个一个小点 组成的。&lt;/p>
&lt;p>如果是 2 个顶点，则可以表示出是一个 线段，同时 2 个点也可以表示出一个长方体。&lt;/p>
&lt;blockquote>
&lt;p>2 个顶点信息就可以表述出 1 个长方体？
没错的，你可以想象成 这 2 个点分别是长方体的 斜对角线上的 2 个点，例如在 three.js 中 包装盒 Box3 就只有 2 个点的信息：坐标最大的点、坐标最小的点&lt;/p>
&lt;/blockquote>
&lt;p>3 个顶点，则可以表示出一个 三角形，同时 3 个点也可以表示出一个圆。&lt;/p>
&lt;blockquote>
&lt;p>至于为什么 3 个顶点 可以表示出一个圆，你可以自己搜索或脑补。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>请注意：图元依然为一堆顶点数据，而不是图像数据。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>再次补充：假设一个物体有一部分不在显示范围之内，那么 webgl 会通过 裁切体(由镜头视椎体决定的) 对物体进行裁切，只将需要渲染的部分进行渲染，而裁切得到的内容则会重新计算，得到一个新的图元。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>关于图元的额外补充：&lt;/strong>&lt;/p>
&lt;p>实际上在 opengl 、webgl 的概念中，图元分为 2 种：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>几何图元：使用顶点、线段、三角形、曲线等等 用于描述物体 “几何轮廓” 。&lt;/p>
&lt;blockquote>
&lt;p>几何图元可以进行空间转换，例如平移，旋转，缩放等操作&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>图像图元：图像图元又被称为 光栅图元。使用像素阵列 用于直观储存 “图片信息”。&lt;/p>
&lt;blockquote>
&lt;p>通过描述就应该知道，实际上所谓的 图像图元就是材质中的纹理贴图。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>图像图元不可进行空间转换&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>几何图元 经过变换、投影、光栅化后，到达片元操作环节的。&lt;/p>
&lt;p>图像图元(也就是纹理)是直接到达片元操作环节的。&lt;/p>
&lt;p>最终在片元操作环节，几何图元 + 图像图元，最终合成得到物体图像。&lt;/p>
&lt;blockquote>
&lt;p>当然还需要其他操作，例如光线反射等&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>而实际中，我们通常不会使用 “图像图元” 这个名词，而是使用 “纹理”。&lt;/p>
&lt;p>所以在本文或者一些常见的教程中，“图元” 往往都是指 “几何图元”。&lt;/p>
&lt;br>
&lt;p>&lt;strong>片元&lt;/strong>：包含图像颜色、位置、深度的信息数据。你可以把片元简单理解为 “未完全加工完成的图像数据”。&lt;/p>
&lt;blockquote>
&lt;p>在 3D 图形管线渲染的流程中，经过裁切处理模块和图元组装模块之后，下一步经过光栅化处理模块，会将需要渲染的图元由一堆顶点数据转化为一堆图像数据。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>请注意：片元已经不再是顶点数据，而是图像数据了，只不过这些图像数据是为完全加工完成，可以最终显示在屏幕上的图像数据。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>图像&lt;/strong>：由 片元 经过片元处理模块，得到的最终图像数据。就是 3D 渲染输出到屏幕上的显示结果。&lt;/p>
&lt;blockquote>
&lt;p>片元数据经过处理，用来更新缓存帧 上的像素，最终 缓存帧 上的结果就是最终渲染出的图像。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>请注意：图像是由一个个像素构成。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>以上内容为 图形学 中的相关知识，但是在本文中讲解的 “Three.js 中内置的图元” 是 Three.js 为了帮助我们快速创建一些常见物体所提供的 JS 类。&lt;/p>
&lt;p>所以一定要理解清楚，本文讲解的 图元 和实际图形学中的图元 是有差异。&lt;/p>
&lt;blockquote>
&lt;p>再次重申一遍：本文讲解的 图元 实际上是 JS 的类，帮助我们快速创建某些形状的 顶点数据。&lt;/p>
&lt;p>一组相关的顶点数据才是图形学中的图元。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;blockquote>
&lt;p>以上内容更新于 2021.07.20&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;br>
&lt;h2 id="3d-模型的补充说明">3D 模型的补充说明&lt;/h2>
&lt;p>内置的图元，都是一些基础的形状，相对简单，但也可以组合成相对复杂的 3D 场景。&lt;/p>
&lt;p>&lt;strong>但对于绝大多数 3D 应用来说，通常流程是：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>在专业的 3D 软件 例如 May、Blender、C4D 中创建模型&lt;/li>
&lt;li>将创建好的模型导出成模型文件，文件格式为 .obj 或 .gltf&lt;/li>
&lt;li>Three.js 加载模型文件，然后开始后续操作&lt;/li>
&lt;/ol>
&lt;p>我们先不讨论如何导出或加载模型，那些会在后续操作中讲解。&lt;/p>
&lt;p>此刻还是回归到默认的 图元 学习中。&lt;/p>
&lt;h2 id="图元的种类">图元的种类&lt;/h2>
&lt;h3 id="图元汇总">图元汇总&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>图元种类(按英文首字母排序)&lt;/th>
&lt;th>图元构造函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>盒子(Box)&lt;/td>
&lt;td>BoxBufferGeometry、BoxGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>平面圆(Circle)&lt;/td>
&lt;td>CircleBufferGeometry、CircleGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>锥形(Cone)&lt;/td>
&lt;td>ConeBufferGeometry、ConeGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>圆柱(Cylinder)&lt;/td>
&lt;td>CylinderBufferGeometry、CylinderGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>十二面体(Dodecahedron)&lt;/td>
&lt;td>DodecahedronBufferGeometry、DodecahedronGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受挤压的 2D 形状(Extrude)&lt;/td>
&lt;td>ExtrudeBufferGeometry、ExtrudeGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>二十面体(Icosahedron)&lt;/td>
&lt;td>IcosahedronBufferGeometry、IcosahedronGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>由线旋转形成的形状(Lathe)&lt;/td>
&lt;td>LatheBufferGeometry、LatheGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>八面体(Octahedron)&lt;/td>
&lt;td>OctahedronBufferGeometry、OctahedronGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>由函数生成的形状(Parametric)&lt;/td>
&lt;td>ParametricBufferGeometry、ParametriceGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2D 平面矩形(Plane)&lt;/td>
&lt;td>PlaneBufferGeometry、PlaneGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>多面体(Polyhedron)&lt;/td>
&lt;td>PolyhedronBufferGeometry、PolyhedronGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>环形/孔形(Ring)&lt;/td>
&lt;td>RingBufferGeometry、RingGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2D 形状(Shape)&lt;/td>
&lt;td>ShapeBufferGeometry、ShapeGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>球体(Sphere)&lt;/td>
&lt;td>SphereBufferGeometry、SphereGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>四面体(Tetrahedron)&lt;/td>
&lt;td>TetrahedronBufferGeometry、TetrahedronGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3D 文字(Text)&lt;/td>
&lt;td>TextBufferGeometry、TextGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>环形体(Torus)&lt;/td>
&lt;td>TorusBufferGeometry、TorusGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>环形结(TorusKnot)&lt;/td>
&lt;td>TorusKnotBufferGeometry、TorusKnotGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>管道/管状(Tube)&lt;/td>
&lt;td>TubeBufferGeometry、TubeGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>几何体的所有边缘(Edges)&lt;/td>
&lt;td>EdgesGeometry&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>线框图(Wireframe)&lt;/td>
&lt;td>WireframeGeometry&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>一共有 22 种内置的图元。&lt;/p>
&lt;blockquote>
&lt;p>上面表格中关于图元的中文名字，有些是我根据含义自己编的，我已经尽量靠近英文原意。&lt;br>
不同文章或教程可能对同一图元的称呼略微不同。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>不要被上面那么多图元吓到&lt;/strong>，事实上他们并不复杂，并且多数情况下我们也用不到。&lt;/p>
&lt;p>当需要用到了，只需要去查阅 Three.js 文档即可。&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>以下内容更新于 2021.11.27&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>特别补充说明：内置的图元实际上也是变化多端的！&lt;/strong>&lt;/p>
&lt;p>为什么这么说呢？&lt;/p>
&lt;p>例如：圆柱(Cylinder)，字面上它是用于创建圆柱体的，但是实际上认真阅读官方文档你会发现是这样描述它的构造函数的&lt;/p>
&lt;blockquote>
&lt;p>CylinderGeometry 官方文档：https://threejs.org/docs/index.html#api/zh/geometries/CylinderGeometry&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
radiusTop — 圆柱的顶部半径，默认值是1。
radiusBottom — 圆柱的底部半径，默认值是1。
height — 圆柱的高度，默认值是1。
radialSegments — 圆柱侧面周围的分段数，默认为8。
heightSegments — 圆柱侧面沿着其高度的分段数，默认值为1。
openEnded — 一个Boolean值，指明该圆锥的底面是开放的还是封顶的。默认值为false，即其底面默认是封顶的。
thetaStart — 第一个分段的起始角度，默认为0。（three o&amp;#39;clock position）
thetaLength — 圆柱底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆柱。
&lt;/code>&lt;/pre>&lt;p>请注意最后的 2 个参数：&lt;/p>
&lt;ol>
&lt;li>thetaStart(默认值为 0)&lt;/li>
&lt;li>thetaLength(默认值为 2*Pi)&lt;/li>
&lt;/ol>
&lt;p>也就是说，你不修改这 2 个默认值，&lt;strong>那么默认创建出的是一个完整的圆柱体&lt;/strong>，但是假设你修改了这 2 个值，比如 将 thetaLength 修改成 0.3*Pi (54°)，那么最终将创建出一个 夹角为 54° 的&lt;strong>扇形&lt;/strong>(体)。&lt;/p>
&lt;p>如果感兴趣，可以看一下我发布的这个项目，由数据生成 3D 饼图：https://github.com/puxiao/pie-3d&lt;/p>
&lt;blockquote>
&lt;p>提醒：最好你在看完本系列教程后(不仅是本小节)，再去看上面提到的 pie-3d 。&lt;/p>
&lt;/blockquote>
&lt;p>通过上面对 CylinderGeometry 的描述，我们可以知道 Three.js 默认自带的图元实际上是可以产生很多变化的，得到的不一定仅仅是图元的 &amp;ldquo;字面&amp;rdquo; 物体。&lt;/p>
&lt;blockquote>
&lt;p>以上内容更新于 2021.11.27&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h3 id="buffergeometry-与-geometry-的区别">BufferGeometry 与 Geometry 的区别&lt;/h3>
&lt;p>从上面的图元表格中不难发现，除了 Edges、WireframeGeometry 以外，其他图元的构造函数都是成对出现的。&lt;/p>
&lt;p>&lt;strong>虽然 EdgesGeometry、WireframeGeometry 名字中并未出现 “Buffer”，但和其他所有包含 “Buffer” 字样的图元一样，他们都继承于 BufferGeometry。&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>差异之处&lt;/th>
&lt;th>BufferGeometry&lt;/th>
&lt;th>Geometry&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>运算、渲染所消耗的性能&lt;/td>
&lt;td>快&lt;/td>
&lt;td>慢&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GPU 渲染&lt;/td>
&lt;td>支持&lt;/td>
&lt;td>不支持，&lt;br />需要 Three.js 内部转化为 BufferGeometry 后才支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>修改灵活度、可自定义程度&lt;/td>
&lt;td>不高&lt;/td>
&lt;td>高&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>添加新顶点&lt;/td>
&lt;td>不支持&lt;/td>
&lt;td>支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>简单来说就是：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>BufferGeometry 可自定义地方比较少，但性能高&lt;/li>
&lt;li>Geometry 可自定义地方比较多，但性能低一些&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>所有的 Geometry 对象最终都会被 Three.js 转化为 BufferGeometry 对象，然后再进行渲染。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;blockquote>
&lt;p>以下内容更新于 2021.11.27&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>上面关于 BufferGeometry 和 Geometry 的区别这段话已经过时了&lt;/strong>，因为在较新的 Three.js 版本中已经将 Geometry 从核心类中移除。&lt;/p>
&lt;p>目前你接触到的都应该只有 BufferGeometry。&lt;/p>
&lt;h4 id="一些心里话">一些心里话：&lt;/h4>
&lt;p>首先非常抱歉得说一句：一年前在写本系列文章时，我是一个对图形学一无所知，对 Three.js 好奇但又非常小白的人，我是一边学习一边写下本系列文章的。&lt;/p>
&lt;p>&lt;strong>所以本系列教程绝对不是好的教程——假设 Three.js 是一座大山的话，而我是站在山脚下向你讲述上山道路的那个人，但我自己也未曾上过这座山。&lt;/strong>&lt;/p>
&lt;p>随着我对图形学、webgl、Three.js、Canvas 的一些认知提升，我深深觉得想要写出好教程，一定要站在更高的维度，拥有更高的视野才可以更好向别人指明方向，写出好教程。&lt;/p>
&lt;p>但是本教程对于那些完全小白，完全对 Three.js 一无所知的人，多少还是有些帮助的(尽管我指明的道路并不是最佳道路)，&lt;strong>很感谢那些 Star 本教程的人&lt;/strong>。&lt;/p>
&lt;p>即使看完全部的本教程，那么最多你也仅仅算是学会了个皮毛，简单入门而已，真正复杂难的是 图形学 中的一些知识点，例如 向量，矩阵，齐次坐标，点乘，叉乘，球极坐标，当然最复杂的莫过于 自定义渲染器(shader)。&lt;/p>
&lt;p>关于 3D 技术栈，虽然不够严谨，但是大体上可以这样表述：&lt;strong>图形学(CG) &amp;gt; OpenGL &amp;gt; OpenGL ES 2.0 &amp;gt; WebGL &amp;gt; Three.js&lt;/strong>&lt;/p>
&lt;p>所以 Three.js 仅仅是 web 3D 最基础，表层的知识技术栈，想要深入学习，你会发现这是一条几乎不到头的道路，学秃。&lt;/p>
&lt;blockquote>
&lt;p>图形学就是那种 从入门到放弃 的知识体系。&lt;/p>
&lt;p>但是别灰心，我们实际上并不会真正需要那么深入高深的，学会 Three.js 可以做一些基础的 网页 3D 还是会比一般前端要显得厉害很多。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="buffergeometry-的重要知识点positionnormaluv">BufferGeometry 的重要知识点：position、normal、uv&lt;/h4>
&lt;blockquote>
&lt;p>先普及个基础知识：在 3D 中 Vector3 既可以表示一个 三维坐标，也可以表示一个三维方向。&lt;/p>
&lt;/blockquote>
&lt;p>一个完整的 BufferGeometry 是由若干个 点(Vector3) 构成的：&lt;/p>
&lt;blockquote>
&lt;p>上面提到的 点 准确说应该是 3 维 点坐标，对应的是 Vector3 ：https://threejs.org/docs/index.html#api/zh/math/Vector3&lt;/p>
&lt;/blockquote>
&lt;p>下面的知识实际上是针对 图形学 和 OpenGL 的。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>position：坐标(每个坐标就是一个 vector3，由 3 个数字组成)，所有的坐标就是组成该 BufferGeometry 的所有 点 的信息(对于底层的 BufferGeometry 而言 3 维点的 (x,y,z) 坐标是分开存储值的)。&lt;/p>
&lt;blockquote>
&lt;p>这就是 Three.js 针对 webgl 进行的封装，实际上我们平时更多时候都使用的是 Vector3，而不是具体的 3 个值。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>normal：法线(每个法线就是一个 vector3，由 3 个数字组成)，用于存储每个 3D 坐标点的朝向，用于计算 反光。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>uv：纹理映射坐标(每个 uv 就是一个 vector2，由 2 个数字组成)，用于存储每个 3D 坐标点对应渲染纹理时对应的 位置点信息，用于计算 贴图。&lt;/p>
&lt;blockquote>
&lt;p>对于纹理而言，它都是 二维的平面，因此 uv 的值对应的是 Vector2，由 x,y 2 个坐标值组成，且每个值的取值范围都是 0 - 1。&lt;/p>
&lt;p>你可以简单把 0 - 1 理解成 0% - 100%，对应的是一个百分比的值。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>通过上面的讲述，我们大致可以作出以下结论，如果我们自定义一个 BufferGeometry，那么：&lt;/p>
&lt;blockquote>
&lt;p>对于初学者而言几乎不需要、也做不到 可以 自定义 BufferGeometry 这一步，我这里只是超前提一下。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>假设这个 BufferGeometry 不需要考虑 反光 和 纹理贴图，那么它只需要拥有(设置) positon 就可以了。&lt;/p>
&lt;blockquote>
&lt;p>this.setAttribute(&amp;lsquo;position&amp;rsquo;, new BufferAttribute(this._vertices, 3))&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>假设这个 BufferGeometry 需要考虑反光，但不需要考虑纹理贴图，那么它需要设置 postion 和 normal。&lt;/p>
&lt;blockquote>
&lt;p>this.setAttribute(&amp;lsquo;position&amp;rsquo;, new BufferAttribute(this._vertices, 3))&lt;/p>
&lt;p>this.setAttribute(&amp;rsquo;normal&amp;rsquo;, new BufferAttribute(this._normals, 3))&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>假设这个 BufferGeometry 需要考虑反光和纹理贴图，那么它的 postion 、normal、uv 都需要设置。&lt;/p>
&lt;blockquote>
&lt;p>this.setAttribute(&amp;lsquo;position&amp;rsquo;, new BufferAttribute(this._vertices, 3))&lt;/p>
&lt;p>this.setAttribute(&amp;rsquo;normal&amp;rsquo;, new BufferAttribute(this._normals, 3))&lt;/p>
&lt;p>this.setAttribute(&amp;lsquo;uv&amp;rsquo;, new BufferAttribute(this._uvs, 2))&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>特别强调，上面提到的 position 是一个 BufferGeomerty 所有点信息的集合，它并不是 Mesh(网格，3D 物体) 的 位置信息。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>如果你理解不了我说的这段话，完全没有关系，忽略这段我补充的知识点，我也是学习 Three.js 快 1 年后才明白的。对于现在的你而言不理解是正常的。&lt;/p>
&lt;p>忽略我上面的这段话，继续本教程后面的学习吧。&lt;/p>
&lt;blockquote>
&lt;p>以上内容更新于 2021.11.27&lt;/p>
&lt;/blockquote>
&lt;p>图元理论上的知识就先讲到这里，在下一节中，会编写一些图元示例。&lt;/p></description></item><item><title>06.图元练习示例</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/06.%E5%9B%BE%E5%85%83%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/06.%E5%9B%BE%E5%85%83%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B/</guid><description>&lt;h1 id="06-图元练习示例">06 图元练习示例&lt;/h1>
&lt;p>上一篇文章中，列举了 Three.js 中内置的 22 种图元(Primitives)，那么本文将重点练习，尝试使用这些图元。&lt;/p>
&lt;blockquote>
&lt;p>复习一下图元的概念：图元 就是 Three.js 中内置的 几何体。&lt;/p>
&lt;/blockquote>
&lt;h2 id="示例代码目标">示例代码目标&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>将内置的所有种类图元，除 TextBufferGeometry 以外，其他 21 种图元 逐一练习&lt;/p>
&lt;blockquote>
&lt;p>TextBufferGeometry 比较特殊，会在稍后一节专门讲解&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在练习中，尽量都使用图元的 BufferGeometry 类型，不做过多自定义设置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最终将所有创建出的形状放置在同一场景中，并进行渲染&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="示例代码组织逻辑">示例代码组织逻辑&lt;/h2>
&lt;ol>
&lt;li>创建 src/components/hello-primitives/ 目录，用来存放本示例所有代码&lt;/li>
&lt;li>在该目录下，创建 index.tsx 文件，用来构建 Three.js 3 大基础元素：场景、镜头、渲染器&lt;/li>
&lt;li>在该目录下，创建 index.scss 文件，用来添加需要用到的 CSS 样式&lt;/li>
&lt;li>在该目录下，分别创建 MyBox.ts、MyCircle.ts &amp;hellip; 等文件，用来依次创建不同的图元实例&lt;/li>
&lt;li>在 index.stx 文件中，引入各个图元实例，并加入场景中进行渲染&lt;/li>
&lt;li>修改 App.tsx，将之前编写的 &amp;lt;HelloThreejs /&amp;gt; 替换为我们本示例的组件 &amp;lt;HelloPrimitives /&amp;gt;&lt;/li>
&lt;/ol>
&lt;p>本示例主要用来练习 Three.js，对于示例中使用到的一些 ES6、React Hooks、TypeScript 等相关知识，若非必要，一般情况下就不再过多讲解说明。&lt;/p>
&lt;h2 id="示例代码">示例代码&lt;/h2>
&lt;h3 id="indextsx">index.tsx&lt;/h3>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect, useCallback } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import &amp;#39;./index.scss&amp;#39;
import myBox from &amp;#39;./my-box&amp;#39;
import myCircle from &amp;#39;./my-circle&amp;#39;
import myCone from &amp;#39;./my-cone&amp;#39;
import myCylinder from &amp;#39;./my-cylinder&amp;#39;
import myDodecahedron from &amp;#39;./my-dodecahedron&amp;#39;
import myEdges from &amp;#39;./my-edges&amp;#39;
import myExtrude from &amp;#39;./my-extrude&amp;#39;
import myIcosahedron from &amp;#39;./my-icosahedron&amp;#39;
import myLathe from &amp;#39;./my-lathe&amp;#39;
import myOctahedron from &amp;#39;./my-octahedron&amp;#39;
import myParametric from &amp;#39;./my-parametric&amp;#39;
import myPlane from &amp;#39;./my-plane&amp;#39;
import myPolyhedron from &amp;#39;./my-polyhedron&amp;#39;
import myRing from &amp;#39;./my-ring&amp;#39;
import myShape from &amp;#39;./my-shape&amp;#39;
import mySphere from &amp;#39;./my-sphere&amp;#39;
import myTetrahedron from &amp;#39;./my-tetrahedron&amp;#39;
import myTorus from &amp;#39;./my-torus&amp;#39;
import myTorusKnot from &amp;#39;./my-torus-knot&amp;#39;
import myTube from &amp;#39;./my-tube&amp;#39;
import myWireframe from &amp;#39;./my-wireframe&amp;#39;
const meshArr: (Three.Mesh | Three.LineSegments)[] = []
const HelloPrimitives = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const rendererRef = useRef&amp;lt;Three.WebGLRenderer | null&amp;gt;(null)
const cameraRef = useRef&amp;lt;Three.PerspectiveCamera | null&amp;gt;(null)
const createMaterial = () =&amp;gt; {
const material = new Three.MeshPhongMaterial({ side: Three.DoubleSide })
const hue = Math.floor(Math.random() * 100) / 100 //随机获得一个色相
const saturation = 1 //饱和度
const luminance = 0.5 //亮度
material.color.setHSL(hue, saturation, luminance)
return material
}
const createInit = useCallback(
() =&amp;gt; {
if (canvasRef.current === null) {
return
}
meshArr.length = 0 //以防万一，先清空原有数组
//初始化场景
const scene = new Three.Scene()
scene.background = new Three.Color(0xAAAAAA)
//初始化镜头
const camera = new Three.PerspectiveCamera(40, 2, 0.1, 1000)
camera.position.z = 120
cameraRef.current = camera
//初始化渲染器
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement })
rendererRef.current = renderer
//添加 2 盏灯光
const light0 = new Three.DirectionalLight(0xFFFFFF, 1)
light0.position.set(-1, 2, 4)
scene.add(light0)
const light1 = new Three.DirectionalLight(0xFFFFFF, 1)
light0.position.set(1, -2, -4)
scene.add(light1)
//获得各个 solid 类型的图元实例，并添加到 solidPrimitivesArr 中
const solidPrimitivesArr: Three.BufferGeometry[] = []
solidPrimitivesArr.push(myBox, myCircle, myCone, myCylinder, myDodecahedron)
solidPrimitivesArr.push(myExtrude, myIcosahedron, myLathe, myOctahedron, myParametric)
solidPrimitivesArr.push(myPlane, myPolyhedron, myRing, myShape, mySphere)
solidPrimitivesArr.push(myTetrahedron, myTorus, myTorusKnot, myTube)
//将各个 solid 类型的图元实例转化为网格，并添加到 primitivesArr 中
solidPrimitivesArr.forEach((item) =&amp;gt; {
const material = createMaterial() //随机获得一种颜色材质
const mesh = new Three.Mesh(item, material)
meshArr.push(mesh) //将网格添加到网格数组中
})
//获得各个 line 类型的图元实例，并添加到 meshArr 中
const linePrimitivesArr: Three.BufferGeometry[] = []
linePrimitivesArr.push(myEdges, myWireframe)
//将各个 line 类型的图元实例转化为网格，并添加到 meshArr 中
linePrimitivesArr.forEach((item) =&amp;gt; {
const material = new Three.LineBasicMaterial({ color: 0x000000 })
const mesh = new Three.LineSegments(item, material)
meshArr.push(mesh)
})
//定义物体在画面中显示的网格布局
const eachRow = 5 //每一行显示 5 个
const spread = 15 //行高 和 列宽
//配置每一个图元实例，转化为网格，并位置和材质后，将其添加到场景中
meshArr.forEach((mesh, index) =&amp;gt; {
//我们设定的排列是每行显示 eachRow，即 5 个物体、行高 和 列宽 均为 spread 即 15
//因此每个物体根据顺序，计算出自己所在的位置
const row = Math.floor(index / eachRow) //计算出所在行
const column = index % eachRow //计算出所在列
mesh.position.x = (column - 2) * spread //为什么要 -2 ？
//因为我们希望将每一行物体摆放的单元格，依次是：-2、-1、0、1、2，这样可以使每一整行物体处于居中显示
mesh.position.y = (2 - row) * spread
scene.add(mesh) //将网格添加到场景中
})
//添加自动旋转渲染动画
const render = (time: number) =&amp;gt; {
time = time * 0.001
meshArr.forEach(item =&amp;gt; {
item.rotation.x = time
item.rotation.y = time
})
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
},
[canvasRef],
)
const resizeHandle = () =&amp;gt; {
//根据窗口大小变化，重新修改渲染器的视椎
if (rendererRef.current === null || cameraRef.current === null) {
return
}
const canvas = rendererRef.current.domElement
cameraRef.current.aspect = canvas.clientWidth / canvas.clientHeight
cameraRef.current.updateProjectionMatrix()
rendererRef.current.setSize(canvas.clientWidth, canvas.clientHeight, false)
}
//组件首次装载到网页后触发，开始创建并初始化 3D 场景
useEffect(() =&amp;gt; {
createInit()
resizeHandle()
window.addEventListener(&amp;#39;resize&amp;#39;, resizeHandle)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, resizeHandle)
}
}, [canvasRef, createInit])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloPrimitives
&lt;/code>&lt;/pre>&lt;h3 id="my-boxts">my-box.ts&lt;/h3>
&lt;pre tabindex="0">&lt;code>import { BoxBufferGeometry } from &amp;#34;three&amp;#34;
const width = 8
const height = 8
const depth = 8
const myBox = new BoxBufferGeometry(width, height, depth)
export default myBox
&lt;/code>&lt;/pre>&lt;h3 id="my-circlets">my-circle.ts&lt;/h3>
&lt;pre tabindex="0">&lt;code>import { CircleBufferGeometry } from &amp;#34;three&amp;#34;
const radius = 7
const segments = 24
const myCircle = new CircleBufferGeometry(radius,segments)
export default myCircle
&lt;/code>&lt;/pre>&lt;p>由于图元实在是太多，这里省略掉一些图元相关代码&amp;hellip;&amp;hellip;&lt;/p>
&lt;h3 id="my-wireframets">my-wireframe.ts&lt;/h3>
&lt;pre tabindex="0">&lt;code>import { BoxBufferGeometry, WireframeGeometry } from &amp;#34;three&amp;#34;;
const width = 8;
const height = 8;
const depth = 8
const myWireframe = new WireframeGeometry(new BoxBufferGeometry(width, height, depth))
export default myWireframe
&lt;/code>&lt;/pre>&lt;p>想要查看完整的图元示例代码，可以访问：https://threejsfundamentals.org/threejs/threejs-primitives.html&lt;/p>
&lt;p>本文示例中的代码源头，都来源于上面那个网页，尽管该网页 JS 中创建图元使用的是 JS 而非 TS。&lt;/p>
&lt;blockquote>
&lt;p>你可以通过查看该页面中内嵌的 JS 代码，来补齐其他图元对应的创建写法。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>图元种类这么多，本文只是带着你一块过一遍，具体每一个图元具体的参数含义，以后总会慢慢了解的。&lt;/strong>&lt;/p>
&lt;p>下一节，我们将讲述一下 TextBufferGeometry 的用法。&lt;/p></description></item><item><title>07.图元之3D文字</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/07.%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/07.%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/</guid><description>&lt;h1 id="07-图元之-3d-文字">07 图元之 3D 文字&lt;/h1>
&lt;p>在 Three.js 所有内置的图元中，TextBufferGeometry 是最为特殊的一个。&lt;/p>
&lt;p>**特殊之处在于：在使用 TextBufferGeometry 创建 文字几何对象之前，需要先加载 3D 字体数据。 **&lt;/p>
&lt;p>&lt;strong>字体数据文件通常为 .json 文件，Three.js 提供了一个专门负责加载字体数据的类：FontLoader&lt;/strong>&lt;/p>
&lt;p>&lt;strong>由于需要加载外部字体数据文件，所以创建 3D 文字这个过程是异步的。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>字体数据的补充说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>字体数据 准确来说是描述字体轮廓的&lt;/li>
&lt;li>字体数据 究竟包含哪些字符由 制作 3D 软件决定的，例如有些字体数据只针对字母，并不支持汉字。&lt;/li>
&lt;li>若某个字符并不包含在 字体数据中，那么 Three.js 会将该字符替换为 问号(?)&lt;/li>
&lt;/ol>
&lt;p>我们暂且先不考虑 字体数据文件 是如何在第 3 方 3D 软件中创建、导出的，先看一下如何加载字体数据文件。&lt;/p>
&lt;h2 id="fontloader-用法分析">FontLoader 用法分析&lt;/h2>
&lt;h3 id="fontloader">FontLoader：&lt;/h3>
&lt;p>我先看一下 FontLoader.d.ts 的内容：&lt;/p>
&lt;blockquote>
&lt;p>这是本系列文章 第一次 从 .d.ts 文件角度来分析、推理 某个类的用法。&lt;/p>
&lt;p>这也体现了使用 TypeScript 的好处，你可以随时去查看对应的 .d.ts 文件，去查看各种类的具体的使用方法&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">Loader&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./Loader&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">LoadingManager&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./LoadingManager&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">Font&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./../extras/core/Font&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">FontLoader&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Loader&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">manager?&lt;/span>: &lt;span class="kt">LoadingManager&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">load&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">url&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">onLoad&lt;/span>&lt;span class="o">?:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">responseFont&lt;/span>: &lt;span class="kt">Font&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="k">void&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">onProgress&lt;/span>&lt;span class="o">?:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">event&lt;/span>: &lt;span class="kt">ProgressEvent&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="k">void&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">onError&lt;/span>&lt;span class="o">?:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">event&lt;/span>: &lt;span class="kt">ErrorEvent&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="k">void&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">void&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">json&lt;/span>: &lt;span class="kt">any&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">Font&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>从上面可以看出：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>FontLoader 继承于 Loader&lt;/p>
&lt;blockquote>
&lt;p>不难想象，在 Three.js 中一定还有负责加载其他资源类型的 Loader&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>构造函数接收一个 LoadingManager 实例&lt;/p>
&lt;/li>
&lt;li>
&lt;p>方法 load( url, onLoad, onProgress, onError )，从字面上就能推测出：&lt;/p>
&lt;ol>
&lt;li>url：资源加载地址&lt;/li>
&lt;li>onLoad：加载完成后，触发的事件回调函数&lt;/li>
&lt;li>onProgress：加载过程中，触发的事件回调函数&lt;/li>
&lt;li>onError：加载失败，触发的事件回调函数&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>方法 parse( json ) ，用来解析 JSON 数据，并返回 Font 实例&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>延展说明：&lt;/strong>&lt;/p>
&lt;p>FontLoader 中牵扯到了另外 3 个类：Loader、LoadingManager、Font。&lt;/p>
&lt;p>Loader 和 LoadingManager 内部封装了加载和解析数据的过程，我们暂时不用深究他们的源码和用法，接下来重点看一下 Font。&lt;/p>
&lt;h3 id="font">Font：&lt;/h3>
&lt;pre tabindex="0">&lt;code>import { Shape } from &amp;#39;./Shape&amp;#39;;
export class Font {
constructor( jsondata: any );
/**
* @default &amp;#39;Font&amp;#39;
*/
type: string;
data: string;
generateShapes( text: string, size: number ): Shape[];
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>从上面可以看出：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Font 类是将 原始的字体数据 从 JSON 转化为 Three.js 内部可识别的 字体数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Font 构造函数接收的参数就是 JSON 数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>属性 type 默认值为 &amp;lsquo;Font&amp;rsquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>属性 data 数据类型为字符串，我猜出 data 就是用来保存构造函数中 jsondata 数据的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>方法 generateShapes( text, size ): Shape[]，根据参数来生成所有的 形状(shape)&lt;/p>
&lt;blockquote>
&lt;p>Shape 这个类在前面示例中使用过多次，shape 单词的本意就是 形状&lt;/p>
&lt;p>Shape[] 表示这是一个 元祖数组，数组的每一个元素都必须是 Shape 实例&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>至此，对于 FontLoader、Font 已有大致了解，接下来该去尝试如何使用他们了。&lt;/p>
&lt;h2 id="使用-fontloader-加载字体数据">使用 FontLoader 加载字体数据&lt;/h2>
&lt;p>&lt;strong>我们使用 FontLoader 加载线上的一个字体数据：https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&lt;/strong>&lt;/p>
&lt;h3 id="示例-1使用基础的方式进行加载">示例 1：使用基础的方式进行加载&lt;/h3>
&lt;pre tabindex="0">&lt;code>const loader = new FontLoader()
const url = &amp;#39;https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&amp;#39;
const onLoadHandle = (responseFont: Font) =&amp;gt; {
console.log(responseFont)
}
const onProgressHandle = (event: ProgressEvent&amp;lt;EventTarget&amp;gt;) =&amp;gt; {
console.log(event)
}
const onErrorHandle = (error: ErrorEvent) =&amp;gt; {
console.log(error)
}
loader.load(url, onLoadHandle, onProgressHandle, onErrorHandle)
&lt;/code>&lt;/pre>&lt;p>以上代码中，采用最原始，基础的方式来加载 字体数据。&lt;/p>
&lt;p>字体数据加载完成对应的 onLoadHandle 处理函数中，可以放置后续的操作。&lt;/p>
&lt;h3 id="示例-2使用-asyncawait-封装加载过程">示例 2：使用 async/await 封装加载过程&lt;/h3>
&lt;p>&lt;strong>我们封装的目标：将异步加载过程封装好，然后就可以像写同步代码一样去获取异步结果。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>首先分析一下 示例 1 中几个关键点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>new FontLoader() 实例化一个 加载器&lt;/li>
&lt;li>url：加载地址&lt;/li>
&lt;li>onLoadHandle、onProgressHandle、onErrorHandle 3 个加载事件处理函数&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>封装思路分析：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>实现方式肯定使用 promise + async/awiat&lt;/p>
&lt;/li>
&lt;li>
&lt;p>promise 中的 resolve 刚好对应 onLoadHandle&lt;/p>
&lt;/li>
&lt;li>
&lt;p>promise 中的 reject 刚好对应 onErrorHandle&lt;/p>
&lt;/li>
&lt;li>
&lt;p>至于加载过程 onProgressHandle，我们基本用不到他，所以直接选择忽略该回到函数&lt;/p>
&lt;blockquote>
&lt;p>届时我们会传递一个 undefined 来替代 onProgressHandle&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>封装加载过程：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const loadFont: (url: string) =&amp;gt; Promise&amp;lt;Font&amp;gt; = (url) =&amp;gt; {
const loader = new FontLoader()
return new Promise((resolve, reject: (error: ErrorEvent) =&amp;gt; void) =&amp;gt; {
loader.load(url, resolve, undefined, reject)
})
}
&lt;/code>&lt;/pre>&lt;p>只有在 async 函数中才可以使用到 Promise，所以我们还需要定义以下函数：&lt;/p>
&lt;pre tabindex="0">&lt;code>const createText = async () =&amp;gt; {
const url = &amp;#39;https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&amp;#39;
const font = await loadFont(url) //请注意这行代码，我们可以想使用同步编写的方式，获取到 字体数据
//开始创建 3D 字体 几何对象
...
}
createText()
&lt;/code>&lt;/pre>&lt;h2 id="改造我们之前写的-helloprimitives">改造我们之前写的 HelloPrimitives&lt;/h2>
&lt;h3 id="改造原因">改造原因：&lt;/h3>
&lt;ol>
&lt;li>由于 TextBufferGeometry 创建过程为异步，async/await 具有函数异步传染性，因此我们需要将 index.tsx 中的代码也修改成异步&lt;/li>
&lt;li>之前 index.tsx 中 useEffect( &amp;hellip; ) 内容稍显复杂，我们特意将其中 随机生成材质、获得摆放位置 的响应代码从 useEffect 中提取出来，放到外部。&lt;/li>
&lt;/ol>
&lt;h3 id="my-textts">my-text.ts&lt;/h3>
&lt;pre tabindex="0">&lt;code>import { Font, FontLoader, Mesh, Object3D, TextBufferGeometry } from &amp;#34;three&amp;#34;;
import { createMaterial } from &amp;#39;./index&amp;#39;
const loadFont: (url: string) =&amp;gt; Promise&amp;lt;Font&amp;gt; = (url) =&amp;gt; {
const loader = new FontLoader()
return new Promise((resolve, reject: (error: ErrorEvent) =&amp;gt; void) =&amp;gt; {
loader.load(url, resolve, undefined, reject)
})
}
const createText = async () =&amp;gt; {
const url = &amp;#39;https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&amp;#39;
const font = await loadFont(url) //异步加载 字体数据
//第一个参数 &amp;#39;puxiao&amp;#39; 可以替换成任何其他的英文字母
//特别注意：由于目前我们加载的 字体数据 只是针对英文字母的字体轮廓描述，并没有包含中文字体轮廓
//所以如果设置成 汉字，则场景无法正常渲染出文字
//对于无法渲染的字符，会被渲染成 问号(?) 作为替代
//第二个参数对应的是文字外观配置
const geometry = new TextBufferGeometry(&amp;#39;puxiao&amp;#39;, {
font: font,
size: 3.0,
height: .2,
curveSegments: 12,
bevelEnabled: true,
bevelThickness: 0.15,
bevelSize: .3,
bevelSegments: 5,
})
const mesh = new Mesh(geometry, createMaterial())
//Three.js默认是以文字左侧为中心旋转点，下面的代码是将文字旋转点位置改为文字中心
//实现的思路是：用文字的网格去套进另外一个网格，通过 2 个网格之间的落差来实现将旋转中心点转移到文字中心位置
//具体代码细节，会在以后 场景 中详细学习，此刻你只需要照着以下代码敲就可以
geometry.computeBoundingBox()
geometry.boundingBox?.getCenter(mesh.position).multiplyScalar(-1)
const text = new Object3D()
text.add(mesh)
return text
}
export default createText
&lt;/code>&lt;/pre>&lt;h3 id="indextsx">index.tsx&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">useEffect&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">useCallback&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;react&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="kr">as&lt;/span> &lt;span class="nx">Three&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;three&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="s2">&amp;#34;./index.scss&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myBox&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-box&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myCircle&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-circle&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myCone&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-cone&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myCylinder&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-cylinder&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myDodecahedron&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-dodecahedron&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myEdges&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-edges&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myExtrude&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-extrude&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myIcosahedron&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-icosahedron&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myLathe&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-lathe&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myOctahedron&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-octahedron&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myParametric&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-parametric&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myPlane&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-plane&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myPolyhedron&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-polyhedron&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myRing&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-ring&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myShape&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-shape&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">mySphere&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-sphere&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myTetrahedron&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-tetrahedron&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myTorus&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-torus&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myTorusKnot&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-torus-knot&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myTube&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-tube&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">myWireframe&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-wireframe&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">createText&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./my-text&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">meshArr&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mesh&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">LineSegments&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object3D&lt;/span>&lt;span class="p">)[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span> &lt;span class="c1">//保存所有图形的元数组
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">createMaterial&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">material&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MeshPhongMaterial&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">side&lt;/span>: &lt;span class="kt">Three.DoubleSide&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">hue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">floor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//随机获得一个色相
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">saturation&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//饱和度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">luminance&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//亮度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">material&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">color&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setHSL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">hue&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">saturation&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">luminance&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">material&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//定义物体在画面中显示的网格布局
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">eachRow&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//每一行显示 5 个
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">spread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">15&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//行高 和 列宽
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">getPositionByIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">index&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//我们设定的排列是每行显示 eachRow，即 5 个物体、行高 和 列宽 均为 spread 即 15
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//因此每个物体根据顺序，计算出自己所在的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">floor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">index&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nx">eachRow&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//计算出所在行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">column&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">index&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="nx">eachRow&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//计算出所在列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">column&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">spread&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//为什么要 -2 ？
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//因为我们希望将每一行物体摆放的单元格，依次是：-2、-1、0、1、2，这样可以使每一整行物体处于居中显示
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">row&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">spread&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">HelloPrimitives&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">canvasRef&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">HTMLCanvasElement&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">rendererRef&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">Three.WebGLRenderer&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="na">null&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">cameraRef&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">Three.PerspectiveCamera&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="na">null&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">createInit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useCallback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">async&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">meshArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//以防万一，先清空原有数组
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//初始化场景
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">scene&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Scene&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">scene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">background&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Color&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xaaaaaa&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//初始化镜头
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">camera&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PerspectiveCamera&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">40&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">camera&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">120&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">cameraRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">camera&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//初始化渲染器
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">renderer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WebGLRenderer&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">canvas&lt;/span>: &lt;span class="kt">canvasRef.current&lt;/span> &lt;span class="kr">as&lt;/span> &lt;span class="nx">HTMLCanvasElement&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">rendererRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">renderer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//添加 2 盏灯光
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">light0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DirectionalLight&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">light0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">scene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">light0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">light1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DirectionalLight&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">light0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">scene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">light1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//获得各个 solid 类型的图元实例，并添加到 solidPrimitivesArr 中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">solidPrimitivesArr&lt;/span>: &lt;span class="kt">Three.BufferGeometry&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">solidPrimitivesArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myBox&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myCircle&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myCone&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myCylinder&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myDodecahedron&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">solidPrimitivesArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myExtrude&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myIcosahedron&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myLathe&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myOctahedron&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">myParametric&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">solidPrimitivesArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">myPlane&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myPolyhedron&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myRing&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myShape&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">mySphere&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">solidPrimitivesArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">myTetrahedron&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myTorus&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myTorusKnot&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myTube&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//将各个 solid 类型的图元实例转化为网格，并添加到 primitivesArr 中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">solidPrimitivesArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">forEach&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">item&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">material&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createMaterial&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">//随机获得一种颜色材质
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">mesh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mesh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">item&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">material&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">meshArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mesh&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//将网格添加到网格数组中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//创建 3D 文字，并添加到 mesArr 中，请注意此函数为异步函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">meshArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">await&lt;/span> &lt;span class="nx">createText&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//获得各个 line 类型的图元实例，并添加到 meshArr 中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">linePrimitivesArr&lt;/span>: &lt;span class="kt">Three.BufferGeometry&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">linePrimitivesArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">myEdges&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">myWireframe&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//将各个 line 类型的图元实例转化为网格，并添加到 meshArr 中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">linePrimitivesArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">forEach&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">item&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">material&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">LineBasicMaterial&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">color&lt;/span>: &lt;span class="kt">0x000000&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">mesh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">LineSegments&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">item&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">material&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">meshArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mesh&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//配置每一个图元实例，转化为网格，并位置和材质后，将其添加到场景中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">meshArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">forEach&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">mesh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">index&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">getPositionByIndex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">index&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">scene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mesh&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//将网格添加到场景中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//添加自动旋转渲染动画
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">render&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">time&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mf">0.001&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">meshArr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">forEach&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">item&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">item&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">rotation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">item&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">rotation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">renderer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">scene&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">camera&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requestAnimationFrame&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requestAnimationFrame&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">resizeHandle&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//根据窗口大小变化，重新修改渲染器的视椎
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">rendererRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">cameraRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">canvas&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">rendererRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">domElement&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">cameraRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">aspect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientWidth&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientHeight&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">cameraRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">updateProjectionMatrix&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">rendererRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientWidth&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientHeight&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//组件首次装载到网页后触发，开始创建并初始化 3D 场景
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">useEffect&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">createInit&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">resizeHandle&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">addEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;resize&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">resizeHandle&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">removeEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;resize&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">resizeHandle&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">createInit&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">canvas&lt;/span> &lt;span class="na">ref&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="na">className&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;full-screen&amp;#34;&lt;/span> &lt;span class="p">/&amp;gt;;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="nx">HelloPrimitives&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>特别提醒：虽然针对 index.tsx 进行了修改，但是并不影响之前创建的其他图元，其他图元并不需要修改任何代码。&lt;/p>
&lt;blockquote>
&lt;p>你是否想也赶紧自己去创建一份可以显示中文的 3D 字体数据？&lt;br>
这需要你会一些 3D 软件，例如 C4D(收费软件)、blender(免费开源软件)&lt;br>
在后续的学习中，一定会涉及到自定义字体样式、自定义几何图形，自己建模的，目前主要任务还是先系统学习 Three.js。&lt;/p>
&lt;/blockquote>
&lt;p>至此，Three.js 中内置的 22 种图元，均逐一尝试完毕。&lt;/p>
&lt;p>同时也意味着，我们 Three.js 的 hello world 之旅完成，通过 HelloThreejs、HelloPrimitives，我们该体验的代码也都体验过了。&lt;/p>
&lt;p>&lt;strong>接下来就要逐个开始深入、详细学习 具体的各个模块的用法。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>加油！&lt;/strong>&lt;/p></description></item><item><title>08.Three.js 基础之场景</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/08.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/08.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/</guid><description>&lt;h1 id="08-threejs-基础之场景">08 Three.js 基础之场景&lt;/h1>
&lt;p>再次回顾一下 Three.js 3 大 核心要素：场景、镜头、渲染器&lt;/p>
&lt;p>&lt;strong>本文主要将 Three.js 中的 场景，但是请注意，本文讲的场景实际上是指 场景图(scene graph)，而不是单指 我们之前示例代码中用到过的 场景 Three.Scene。&lt;/strong>&lt;/p>
&lt;p>但是请注意，本文讲的场景实际上是指 场景图(scene graph)，而不是单指 我们之前示例代码中用到过的 场景 Three.Scene。&lt;/p>
&lt;h2 id="场景图scene-graph的概念解释">场景图(scene graph)的概念解释&lt;/h2>
&lt;h3 id="场景与场景图的关系">场景与场景图的关系：&lt;/h3>
&lt;p>&lt;strong>SceneGraph 准确的翻译应该是叫：场景图，但是本文中，我有时依然倔强得把他叫做 &amp;ldquo;场景&amp;rdquo;。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>但无论我怎么称呼它，请你记得：场景(Three.Scene) 只是 场景图 中的一种。&lt;/strong>&lt;/p>
&lt;h3 id="场景图的数据结构">场景图的数据结构：&lt;/h3>
&lt;p>抛开 Three.js 不谈，我们先看一下在数据结构中，树与图 的概念区分。&lt;/p>
&lt;p>&lt;strong>树：一种 分层 数据的抽象模型&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>呈现出的是像大树枝一样的结构，根据结构特征还可以划分为 二叉树、红黑树、大顶树、小顶树等等&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>图：网络结构的抽象模型，是一组由边连接的节点&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>呈现出的是像蜘蛛网、道路网、航班线路一样的结构&lt;/p>
&lt;/blockquote>
&lt;p>回到 Three.js 中。&lt;/p>
&lt;p>&lt;strong>请务必记得：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>场景图 中的 图，并非数据结构中的图&lt;/li>
&lt;li>&lt;strong>场景图的数据结构并非 图，而是 树&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>补充一下：&lt;/strong>&lt;/p>
&lt;p>在有一些教程示例代码中，当循环遍历 场景 中物体对象时，你或许会看到这样的代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>他使用的是：xxx.forEach((node) =&amp;gt; { node ....})
而不是：xxx.forEach((itme) =&amp;gt; { item ...})
&lt;/code>&lt;/pre>&lt;p>尽管无论数组元素变量名是叫 node 还是 item，实际上效果是相同的，但是&lt;strong>他为什么会用 node 这个单词呢？&lt;/strong>&lt;/p>
&lt;p>答：因为&lt;strong>场景图的数据结构是树，而场景上的物体对象实际就是树结构中的一个节点&lt;/strong>，节点对应的单词就是 node。&lt;/p>
&lt;h3 id="场景图空间的含义">场景图(空间)的含义：&lt;/h3>
&lt;p>&lt;strong>在 Three.js 中，场景即空间，而 空间 包含以下几种情况&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>由 Scene 创建的普通场景、普通场景中还可以添加雾(Fog、FogExp2)从而变成具有雾化效果的场景&lt;/p>
&lt;blockquote>
&lt;p>无论哪种场景下，都可以添加 Object3D、Mesh&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Scene 场景下，距离镜头越远的物体看上去越小，但清晰度不变&lt;br>
包含 雾(Fog、FogExp2) 场景下，距离镜头越远的物体不光看上去越小，同时被雾气环绕&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>对于现阶段的我们来说，目前主要以使用 Scene 场景为主，Fog、FogExp2 会在以后学习和使用&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>由 Object3D 创建的 空白空间&lt;/p>
&lt;blockquote>
&lt;p>可以添加 Mesh&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>由 Mesh 创建的 具体的物体所在的网格空间&lt;/p>
&lt;blockquote>
&lt;p>可以添加其他的 Mesh&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>理论上，Object3D 和 Mesh 是可以互相添加，互相嵌套的，最终会构成一个复杂的空间体系&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>请注意，为了避免 “场景图” 这 3 个字过于绕口，以及为了方便理解，在下面文字中，我会将 场景图 称呼为 场景或空间&lt;/p>
&lt;/blockquote>
&lt;h3 id="场景的几个概念">场景的几个概念&lt;/h3>
&lt;h3 id="概念-1一个局部的相对空间即为一个场景">概念 1：一个局部的相对空间，即为一个场景&lt;/h3>
&lt;p>例如太阳系就是一个空间(场景)&lt;/p>
&lt;h3 id="概念-2一个空间场景-又可能是由-几个子空间场景-组合而成">概念 2：一个空间(场景) 又可能是由 几个子空间(场景) 组合而成&lt;/h3>
&lt;p>太阳系由 8 大行星构成&lt;/p>
&lt;p>行星除了本身之外还包卫星，例如地球和月球&lt;/p>
&lt;p>地球上又包含陆地和海洋&lt;/p>
&lt;p>陆地上又包含中国，中国包含你此刻所处的空间&lt;/p>
&lt;h3 id="概念-3表面上添加某场景但实际上执行的是合并场景">概念 3：表面上添加某场景，但实际上执行的是合并场景&lt;/h3>
&lt;p>例如 sceneA.add(sceneB)，表面上看 sceneA 添加了 sceneB，sceneB 称为了 sceneA 的子场景，但事实上根本并不是这样！&lt;/p>
&lt;p>&lt;strong>什么？这岂不是和 概念 2 完全相悖？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>没错！确实是即合并又互相独立。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>所谓独立：sceneB 中的元素(物体、灯光)的坐标位置继续保持独立&lt;/strong>&lt;/p>
&lt;p>&lt;strong>所谓合并：sceneB 中的元素(物体、灯光)被复制添加到其他场景中，例如 场景 B 中的灯光会影响 场景 C&lt;/strong>&lt;/p>
&lt;p>&lt;strong>举一个很容易犯错的例子：&lt;/strong>&lt;/p>
&lt;p>假设有 环境灯光 lightB、lightC，和 场景 sceneA、sceneB、sceneC&lt;/p>
&lt;pre tabindex="0">&lt;code>sceneB.add(lightB) //场景B 中添加 灯光B
sceneC.add(lightC) //场景C 中添加 灯光C
sceneA.add(sceneB) //场景A 中添加 场景B
sceneA.add(sceneC) //场景A 中添加 场景C
renderer.render(sceneA,camera) //使用场景渲染器，将 场景A 渲染出来
&lt;/code>&lt;/pre>&lt;p>&lt;strong>你可能以为 灯光 B 只在 场景 B 中起作用、灯光 C 只在 场景 C 中起作用。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>但事实根本不是这样，上面代码渲染过后，你会发现：场景 B 和 场景 C 中，分别都受到 环境灯光 B 和 环境灯光 C。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>因为环境灯光是全局的、环境灯光在场景中无处不在、会影响场景中全部的物体。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>假设不是环境灯光，而是普通的平行灯光，事实上依然会影响(照耀)到其他 “子场景”上的物体，只不过可能因为距离设定原因，不会像全局环境光那样影响明显。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>为什么会这样？&lt;/strong>&lt;/p>
&lt;p>我们查看一下 scene.add() 函数源码：&lt;/p>
&lt;blockquote>
&lt;p>注意：Scene 继承于 Object3D，所以 scene.add() 方法实际上是由 Object3D 定义的。&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>add: function (object) {
if (arguments.length &amp;gt; 1) {
for (let i = 0; i &amp;lt; arguments.length; i++) {
this.add(arguments[i]);
}
return this;
}
if (object === this) {
console.error(&amp;#34;THREE.Object3D.add: object can&amp;#39;t be added as a child of itself.&amp;#34;, object);
return this;
}
if ((object &amp;amp;&amp;amp; object.isObject3D)) {
if (object.parent !== null) {
object.parent.remove(object);
}
object.parent = this;
this.children.push(object);
object.dispatchEvent(_addedEvent);
} else {
console.error(&amp;#34;THREE.Object3D.add: object not an instance of THREE.Object3D.&amp;#34;, object);
}
return this;
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>源码分析：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>if (object.parent !== null) { object.parent.remove(object); } //如果元素(物体、灯光)拥有父级，则将该元素从父级中删除&lt;/li>
&lt;li>object.parent = this; //将元素(物体、灯光)的父级指向 this(自己)&lt;/li>
&lt;li>this.children.push(object); //将元素(物体、灯光)添加到自己场景中的 children 中&lt;/li>
&lt;/ol>
&lt;p>经过以上 3 步操作，&lt;strong>add() 函数实现了 将 子场景元素拆散、合并到自己(最外层场景、顶场景)中&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>假设我就希望有若干个“子场景”，子场景中的灯光(哪怕是环境光)是独立，不会影响其他 子场景的，怎么实现？&lt;/strong>&lt;/p>
&lt;p>答：只能声明多个 渲染器(WebGLRenderer)，每个渲染器渲染一个场景(Scene)、每个场景内添加一种光源。&lt;/p>
&lt;blockquote>
&lt;p>提前预告：在后续讲解 灯光 那一章节中，就会运用到这个知识点。&lt;/p>
&lt;/blockquote>
&lt;h3 id="概念-4一个子空间场景只需要关注和他最紧密相关的空间即可">概念 4：一个子空间(场景)只需要关注和他最紧密相关的空间即可&lt;/h3>
&lt;p>假设你此刻在家里，那么你的相对空间就只针对家里即可，尽管你此刻所处的地球正在自转，你无需关心这个事情。&lt;/p>
&lt;p>月球也可能只关心它是否围着地球转，而不需要关心他在太阳系中的运动轨迹&lt;/p>
&lt;h4 id="概念-4-引申出来的另外一个概念通过空间嵌套来改变原有的相对状态">概念 4 引申出来的另外一个概念：通过空间嵌套来改变原有的相对状态&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>一个 空间 A 嵌套进入另外一个 空间 B，此时 空间 A 将会拥有 空间 B 的一些属性，例如 空间 A 会随着 空间 B 一起缩放&lt;/strong>&lt;/li>
&lt;li>&lt;strong>两个子空间 A 和 B 都嵌套进另外一个空间 C，此时 空间 A、空间 B 相对独立且共存&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="举例说明-1修改文字对象的旋转中心点">举例说明 1：修改文字对象的旋转中心点&lt;/h4>
&lt;p>默认情况下，Three.js 中创建的 TextBufferGeometry 对象旋转点位于左侧。&lt;/p>
&lt;p>为了让 文字对象 看上去以 中心位置 为中心点旋转，那么可以这样操作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过 new Object3D() 创建 空间 A&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 new Mesh( new TextBufferGeometry({ &amp;hellip; } ), createMaterial() ) 创建文字对象&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改文字的中心点&lt;/p>
&lt;pre tabindex="0">&lt;code>geometry.computeBoundingBox()
geometry.boundingBox?.getCenter(mesh.position).multiplyScalar(-1)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>将 文字对象(网格) 添加到 空间 A 中，同时将 空间 A 添加到场景中&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>经过这样操作过后，即可将 文字对象 文字对象的中心点改为中间。&lt;/p>
&lt;h4 id="举例说明-2创建月球与地球的相对空间">举例说明 2：创建月球与地球的相对空间&lt;/h4>
&lt;p>太阳和地球构成一个相对空间、地球与月亮也构成一个相对空间。&lt;/p>
&lt;p>假设我们现在的目标是创建 月球与地球的相对空间，那么可以这样操作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建地球对象 A、月球对象 B&lt;/p>
&lt;blockquote>
&lt;p>“地球对象”，更加精准的描述应该是：地球对应的网格，也就是 “地球本身的空间”&lt;/p>
&lt;p>为了不让月球和地球重叠在一起，通常情况下会给 月球对象 B 设置 .position.x = xx，好让地球和月球之间存在一定的距离&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>通过 new Object3D() 创建空间 C&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 A、B 都添加到 C 中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 C 添加到主场景中&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>经过这样操作后，主场景中包含 C，而 C 包含 A、B，至此形成了一个 地球和月球 共同存在的空间。&lt;/p>
&lt;h3 id="场景空间的最常见操作">场景(空间)的最常见操作&lt;/h3>
&lt;ol>
&lt;li>将 空间 A 加入到 空间 B：B.add(A)&lt;/li>
&lt;li>设置空间 A 在空间 B 中的位置：A.position.x = xxx&lt;/li>
&lt;/ol>
&lt;h2 id="场景的示例太阳地球月亮">场景的示例：太阳、地球、月亮&lt;/h2>
&lt;h4 id="我们模拟出以下场景">我们模拟出以下场景：&lt;/h4>
&lt;ol>
&lt;li>月球自转的同时，围绕地球旋转&lt;/li>
&lt;li>地球自转的同时，围绕太阳旋转&lt;/li>
&lt;li>太阳仅自转，位置不变&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>本文的重点在于讲解 场景 的概念，若对代码中某些 方法或属性的使用 不太能够理解也没有关系，将来会慢慢学习到。&lt;/p>
&lt;/blockquote>
&lt;h4 id="代码文件说明">代码文件说明：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>我们将在 src/components/hello-scene/ 目录下创建 index.stx 作为本次演示主文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与以往代码不同，这次我们将创建 太阳、地球、月亮、以及 光源 的过程迁移到另外一个单独的文件中 ，好让我们在 useEffect 中的代码更加清爽一些。&lt;/p>
&lt;p>对应的文件为 src/components/hello-scene/create-something.ts&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="代码核心说明">代码核心说明：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>我们将创建一个球体，让太阳、地球、月亮都由这个球体创建而来，只不过每个球体网格在材质(颜色)、大小方面不同。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们将创建 3 个相对空间：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>月球相对地球的轨道空间&lt;/p>
&lt;blockquote>
&lt;p>这个空间中只有月球，因为设置了偏差(poisition.x = 2)，所以月球会做圆形轨道运动&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>地球(含月球)相对太阳的轨道空间&lt;/p>
&lt;blockquote>
&lt;p>这个空间中有地球(含月球)，同样因为设置了偏差(position.x = 10)，所以会整体做圆形轨道运动&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>太阳与地球轨道构成的相对空间&lt;/p>
&lt;blockquote>
&lt;p>这个空间包含太阳、地球(含月球)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h4 id="补充说明">补充说明：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>为了让我们更加容易看到 球体 的自转，所以无论是太阳还是地球或月亮，外形都设置成一个 六边形的球体。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们只是为了演示 相对空间 的使用，所以 太阳、月亮、地球 的尺寸、自转频率、位置关系等是随意设置的值，并不是真实中的大小比例。&lt;/p>
&lt;blockquote>
&lt;p>科普一下：实际中，太阳直径是地球直径的 109 倍、地球直径是月球直径的 4 倍&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h4 id="具体的代码">具体的代码：&lt;/h4>
&lt;h4 id="create-somethingjs">create-something.js&lt;/h4>
&lt;pre tabindex="0">&lt;code>import { Mesh, MeshPhongMaterial, Object3D, PointLight, SphereBufferGeometry } from &amp;#34;three&amp;#34;
//创建一个球体
const sphere = new SphereBufferGeometry(1, 6, 6) //球体为6边形，目的是为了方便我们观察到他在自转
//创建太阳
const sunMaterial = new MeshPhongMaterial({ emissive: 0xFFFF00 })
const sunMesh = new Mesh(sphere, sunMaterial)
sunMesh.scale.set(4, 4, 4) //将球体尺寸放大 4 倍
//创建地球
const earthMaterial = new MeshPhongMaterial({ color: 0x2233FF, emissive: 0x112244 })
const earthMesh = new Mesh(sphere, earthMaterial)
//创建月球
const moonMaterial = new MeshPhongMaterial({ color: 0x888888, emissive: 0x222222 })
const moonMesh = new Mesh(sphere, moonMaterial)
moonMesh.scale.set(0.5, 0.5, 0.5) //将球体尺寸缩小 0.5 倍
//创建一个 3D 空间，用来容纳月球，相当于月球轨迹空间
export const moonOribit = new Object3D()
moonOribit.position.x = 2
moonOribit.add(moonMesh)
//创建一个 3D 空间，用来容纳地球，相当于地球轨迹空间
export const earthOrbit = new Object3D()
earthOrbit.position.x = 10
earthOrbit.add(earthMesh)
earthOrbit.add(moonOribit)
//创建一个 3D 空间，用来容纳太阳和地球(含月球)
export const solarSystem = new Object3D()
solarSystem.add(sunMesh)
solarSystem.add(earthOrbit)
//创建点光源
export const pointLight = new PointLight(0xFFFFFF, 3)
export default {}
&lt;/code>&lt;/pre>&lt;h4 id="indextsx">index.tsx&lt;/h4>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { solarSystem, earthOrbit, moonOribit, pointLight } from &amp;#39;@/components/hello-scene/create-something&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const nodeArr = [solarSystem, earthOrbit, moonOribit] //太阳、地球、月亮对应的网格
const HelloScene = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const rendererRef = useRef&amp;lt;Three.WebGLRenderer | null&amp;gt;(null)
const cameraRef = useRef&amp;lt;Three.PerspectiveCamera | null&amp;gt;(null)
const sceneRef = useRef&amp;lt;Three.Scene | null&amp;gt;(null)
useEffect(() =&amp;gt; {
//创建渲染器
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement })
rendererRef.current = renderer
//创建镜头
const camera = new Three.PerspectiveCamera(40, 2, 0.1, 1000)
camera.position.set(0, 50, 0)
camera.up.set(0, 0, 1)
camera.lookAt(0, 0, 0)
cameraRef.current = camera
//创建场景
const scene = new Three.Scene()
scene.background = new Three.Color(0x111111)
sceneRef.current = scene
//将太阳系、灯光添加到场景中
scene.add(solarSystem)
scene.add(pointLight)
//创建循环渲染的动画
const render = (time: number) =&amp;gt; {
time = time * 0.001
nodeArr.forEach((item) =&amp;gt; {
item.rotation.y = time
})
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
//添加窗口尺寸变化的监听
const resizeHandle = () =&amp;gt; {
const canvas = renderer.domElement
camera.aspect = canvas.clientWidth / canvas.clientHeight
camera.updateProjectionMatrix()
renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
}
resizeHandle()
window.addEventListener(&amp;#39;resize&amp;#39;, resizeHandle)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, resizeHandle)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloScene
&lt;/code>&lt;/pre>&lt;h4 id="上述代码共同构建出的空间体系">上述代码共同构建出的空间体系：&lt;/h4>
&lt;ol>
&lt;li>主场景 Scene 包含 太阳系&lt;/li>
&lt;li>太阳系：太阳系本身 + 太阳 + 地球系(含月球系)&lt;/li>
&lt;li>地球系：地球系本身 + 地球 + 月球系&lt;/li>
&lt;li>月球系：月球系本身 + 月球&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>每一个空间体系都是相互独立运作，但在他们共同作用下，构成了一个复杂的空间体系。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>思考题：如何实现一辆简单的，有 4 个滚动轮子的汽车？&lt;/p>
&lt;/blockquote>
&lt;h2 id="补充一个类axeshelper">补充一个类：AxesHelper&lt;/h2>
&lt;p>在传统的 3D 制作软件中，都会直观的显示出 X、Y、Z 网格线，帮助我们比较直观的查看 物体所在网格的位置。&lt;/p>
&lt;p>在 Three.js 中，可以通过给空间网格添加 AxesHeler 实例来让渲染的时候，显示出 XYZ 网格。&lt;/p>
&lt;p>&lt;strong>具体用法：请将以下代码，添加到本文的示例代码中&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>useEffect(() =&amp;gt; {
...
//显示轴线
nodeArr.forEach((item) =&amp;gt; {
const axes = new Three.AxesHelper()
const material = axes.material as Three.Material
material.depthTest = false
axes.renderOrder = 1 // renderOrder 的该值默认为 0，这里设置为 1 ，目的是为了提高优先级，避免被物体本身给遮盖住
item.add(axes)
})
...
}, [canvasRef])
&lt;/code>&lt;/pre>&lt;p>关于 Three.js 中 场景、空间 的概念和基本用法，先讲解到这里。在后续稍微复杂点的项目中，都会有大量 空间 相互嵌套 的使用需求。&lt;/p>
&lt;p>&lt;strong>空间的相互嵌套才构建出了复杂的 3D 场景。&lt;/strong>&lt;/p>
&lt;p>学习到本篇，是否有些心累的？感觉贴出来的示例代码越来越长，越来越复杂了？ 打起精神，继续加油吧。&lt;/p>
&lt;p>下一节，开始讲一下 决定物体外观被渲染成什么样子的 “材质” 。&lt;/p></description></item><item><title>09.Three.js 基础之材质</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/09.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/09.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/</guid><description>&lt;h1 id="09-threejs-基础之材质">09 Three.js 基础之材质&lt;/h1>
&lt;p>材质(material) 即 线段属性或物体表面的一些颜色、贴图、光亮程度、反光特性、粗糙度等属性。&lt;/p>
&lt;p>按照用途，所以材质大体上可以划分为：&lt;/p>
&lt;ol>
&lt;li>点材质(应用来点、粒子上)&lt;/li>
&lt;li>线性材质(应用在线段或虚线上)&lt;/li>
&lt;li>基础材质(应用在面上的各种材质)&lt;/li>
&lt;li>特殊用途的材质(例如阴影)&lt;/li>
&lt;li>自定义材质&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>上面的分类划分，仅仅是我个人观点，事实上并没有明确的种类划分规定。&lt;/p>
&lt;/blockquote>
&lt;h4 id="材质基础">材质基础&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>材质名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Material&lt;/td>
&lt;td>所有材质的父类&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="点材质">点材质&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>材质名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>PointsMaterial&lt;/td>
&lt;td>点材质(粒子材质)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="线性材质">线性材质&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>材质名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>LineBasicMaterial&lt;/td>
&lt;td>线段材质(颜色、宽度、断点、连接点等属性)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LineDashedMaterial&lt;/td>
&lt;td>虚线材质&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="基础材质针对面">基础材质(针对”面“)&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>材质名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MeshBasicMaterial&lt;/td>
&lt;td>最基础的材质，不反射光，仅显示材质本身颜色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshLambertMaterial&lt;/td>
&lt;td>仅顶点处反射光&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshMatcapMaterial&lt;/td>
&lt;td>自带光效(明暗)的材质&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshPhongMaterial&lt;/td>
&lt;td>任何点都反射光，拥有光泽度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshToonMaterial&lt;/td>
&lt;td>卡通着色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshStandardMaterial&lt;/td>
&lt;td>除光泽度外，还有粗糙度和金属度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshPhysicalMaterial&lt;/td>
&lt;td>除光泽度、粗糙度、金属度外，还有清漆度和清漆粗糙度&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="特殊用途材质">特殊用途材质&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>材质名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ShadowMaterial&lt;/td>
&lt;td>阴影材质&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshDistanceMaterial&lt;/td>
&lt;td>另外一种阴影投射材质&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshDeptMaterial&lt;/td>
&lt;td>远近距离深度着色材质&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MeshNormalMaterial&lt;/td>
&lt;td>网格法向量材质&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SpriteMaterial&lt;/td>
&lt;td>精灵材质/雪碧材质&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="自定义材质">自定义材质&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>材质名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ShaderMaterial&lt;/td>
&lt;td>着色器材质&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RawShaderMaterial&lt;/td>
&lt;td>原始着色器材质&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注意：本文只是大体上讲解一些 Three.js 中的各个材质特性，具体每个材质的详细参数和用法，需要自己查阅 Three.js 官方文档：https://threejs.org/docs/index.html#api/zh/materials/Material&lt;/p>
&lt;h2 id="点材质pointsmaterial">点材质：PointsMaterial&lt;/h2>
&lt;h4 id="pointsmaterial点材质粒子材质">PointsMaterial：点材质/粒子材质&lt;/h4>
&lt;p>用来创建 粒子 材质。&lt;/p>
&lt;h2 id="线性材质linebasicmateriallinedashedmaterial">线性材质：LineBasicMaterial、LineDashedMaterial&lt;/h2>
&lt;h4 id="linebasicmaterial基础的线段材质">LineBasicMaterial：基础的线段材质&lt;/h4>
&lt;p>用来创建 线段 的材质，属性包括：颜色、宽度、断点、连接点等。&lt;/p>
&lt;h4 id="linedashedmaterial虚线材质">LineDashedMaterial：虚线材质&lt;/h4>
&lt;p>LineDashedMaterial 继承于 LineBasicMaterial，用来绘制虚线。&lt;/p>
&lt;h2 id="基础材质讲解说明">基础材质讲解说明&lt;/h2>
&lt;p>Three.js 中基础材质类型，我们先从 MeshPhongMaterial 说起。&lt;/p>
&lt;h4 id="为什么要先讲-meshphongmaterial">为什么要先讲 MeshPhongMaterial？&lt;/h4>
&lt;p>因为 MeshPhongMaterial 是使用最频繁，且处于特殊位置的材质。&lt;/p>
&lt;p>MeshPhongMaterial 可以作为其他材质的参考对象：&lt;/p>
&lt;ol>
&lt;li>比 MeshPhongMaterial 简单的有 MeshBasicMaterial、MeshLambertMaterial&lt;/li>
&lt;li>和 MeshPhongMaterial 相似的有 MeshToonMaterial&lt;/li>
&lt;li>比 MeshPhongMaterial 复杂的有 MeshStandardMaterial、MeshPhysicalMaterial&lt;/li>
&lt;/ol>
&lt;h2 id="meshphongmaterial">MeshPhongMaterial&lt;/h2>
&lt;h3 id="phong-光照模型">Phong 光照模型：&lt;/h3>
&lt;p>Phong 光照模型是最简单、最基础的光照模型，该模型只考虑物体对直线光的反射作用，不考虑物体之间的漫反射光(环境光)。&lt;/p>
&lt;h3 id="phong-的假设前提">Phong 的假设前提：&lt;/h3>
&lt;ol>
&lt;li>物体通常被设置为不透明&lt;/li>
&lt;li>物体表面反射率相同&lt;/li>
&lt;/ol>
&lt;h3 id="phone-的简单用法">Phone 的简单用法：&lt;/h3>
&lt;p>&lt;strong>新建一个 MeshPhongMaterial&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const material = new Three.MeshPhongMaterial({
color:0xFF0000,
flatShading:true
})
&lt;/code>&lt;/pre>&lt;p>或者&lt;/p>
&lt;pre tabindex="0">&lt;code>const material = new Three.MeshPhoneMaterial()
material.color.set(0xFF0000)
material.flatShading = true
&lt;/code>&lt;/pre>&lt;p>&lt;strong>设置颜色的 N 种方式：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>new Three.MeshPhoneMaterial({color:0xFF0000})
new Three.MeshPhoneMaterial({color:&amp;#39;red&amp;#39;})
new Three.MeshPhoneMaterial({color:&amp;#39;#F00&amp;#39;})
new Three.MeshPhoneMaterial({color:&amp;#39;rgb(255,0,0)&amp;#39;})
new Three.MeshPhoneMaterial({color:&amp;#39;hsl(0,100%,50%)&amp;#39;})
&lt;/code>&lt;/pre>&lt;p>修改颜色：&lt;/p>
&lt;pre tabindex="0">&lt;code>material.color.set(0xFF0000)
material.color.set(&amp;#39;red&amp;#39;)
material.color.set(&amp;#39;#F00&amp;#39;)
material.color.set(&amp;#39;rgb(255,0,0)&amp;#39;)
material.color.set(&amp;#39;hsl(0,100%,50%)&amp;#39;)
material.color.setHSL(0,1,0.5)
material.color.setRGB(1,0,0)
&lt;/code>&lt;/pre>&lt;h3 id="phong-的属性flatshading平面着色">Phong 的属性：flatShading(平面着色)&lt;/h3>
&lt;p>&lt;strong>特别强调：flatShading 属性并不是由 MeshPhongMaterial 定义的，而是有父类 Material 定义的。&lt;/strong>&lt;/p>
&lt;p>只不过由于 flatShading 比较重要，因此这里特别讲解一下该属性的作用。&lt;/p>
&lt;p>flatShading 的值为 布尔值，该值指 是否启用 平面着色 模式。&lt;/p>
&lt;blockquote>
&lt;p>默认值为 false，即不启用 平面着色 模式。&lt;/p>
&lt;/blockquote>
&lt;h4 id="补充说明-3-大着色模式">补充说明 3 大着色模式：&lt;/h4>
&lt;p>&lt;strong>什么叫 着色？&lt;/strong>&lt;/p>
&lt;p>在三维图形学中，“着色” 的含义为：根据光照条件重建 物体各表面明暗效果的过程，就叫着色。&lt;/p>
&lt;p>这个 &amp;ldquo;着色&amp;rdquo; 过程中，就牵扯到不同的着色算法，也就是不同的着色模式。&lt;/p>
&lt;h4 id="最常见的-3-种着色算法模式">最常见的 3 种着色算法(模式)：&lt;/h4>
&lt;p>&lt;strong>Flat Shading：平面着色&lt;/strong>&lt;/p>
&lt;p>根据每个三角形的法线计算着色效果，每个面只计算一次，也就是说相同的面采用同一个计算结果。&lt;/p>
&lt;p>这种模式对于 立方体 来说会减小计算量，因为立方体每个面都是平整且唯一的。&lt;/p>
&lt;p>&lt;strong>Gouraud Shading：逐顶着色&lt;/strong>&lt;/p>
&lt;p>针对每个顶点计算，而后对每个顶点的结果颜色进行线性插值得到片源的颜色。&lt;/p>
&lt;p>&lt;strong>Phong Shading：补色渲染&lt;/strong>&lt;/p>
&lt;p>对每个三角形的每个片元进行着色计算。所以 Phong Shading 又被称为 &lt;strong>逐片元着色&lt;/strong>&lt;/p>
&lt;p>由于颜色是按片元着色的，得到的结果比 逐顶着色(Gouraud Shading) 要更加细腻，尤其是用于光亮表面效果更加真实。&lt;/p>
&lt;p>Phong 并不是传统的英文单词，而是 生活在美国的越南籍科学家 Bui Tuong Phong (裴祥风) 的名字。&lt;/p>
&lt;p>所以 Phong Shading 又被称为 冯氏着色。&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>以下内容更新于 2022.02.02&lt;/p>
&lt;/blockquote>
&lt;p>在图形学中有一个被应用非常广泛的简单光照模型：冯氏光照模型&lt;/p>
&lt;blockquote>
&lt;p>注：这里的 简单 是指计算量非常小，但却可以模拟出简单的高光和漫反射。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>冯氏光照模型、冯氏着色法 简介：&lt;/strong>&lt;/p>
&lt;p>&lt;strong>裴祥风&lt;/strong> (1942-1975)，出生于越南，1973 年在美国 尤他大学 取得博士学位，并发明了冯氏光照模型和冯氏着色法，被广大 CG 界采用。&lt;/p>
&lt;p>冯氏光照模型主要有 3 个分量组成：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>环境光照(Ambient Lighting)：物体几乎永远不会是完全黑暗的，环境光照一般是一个常量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响，越是正对着光源的地方越亮。&lt;/p>
&lt;blockquote>
&lt;p>通过计算物体平面某个点的法向量与该点与光源的单位向量进行乘积，得到该点的亮度。&lt;/p>
&lt;p>当这两个向量相互重叠时该点最亮(亮度值为 1)，当这两个向量成九十度则最暗(亮度值为 0)&lt;/p>
&lt;p>向量、法线、乘积(也称内积) 这些都是 线性代数 中的词语，属于图形学中需要掌握的基础知识。如果学会了基础的 Three.js 后一定要去学习图形学，否则以后也做不出什么好的应用。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>最终物体呈现的样子就是以上 3 种光照结果直接叠加后的样子。&lt;/p>
&lt;br>
&lt;p>冯氏着色法(Phong Shading)：每个片元(fragment)或者每个点计算一次光照，点的法向量是通过顶点的法向量插值得到的。冯氏着色更加接近真实，当然计算开销也大。&lt;/p>
&lt;p>与冯氏着色法相对的有：平面着色法(Flat Shading)、高洛德着色法(Gouraud Shading)&lt;/p>
&lt;blockquote>
&lt;p>以上内容更新于 2022.02.02&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;blockquote>
&lt;p>Phong 光照反射模型 也被称为 冯氏反射模型&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>特别补充：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>MeshPhongMaterial 中的 Phong 是指 Phong 光照反射模型&lt;/li>
&lt;li>Phong Shading 中的 Phong 只指 补色渲染&lt;/li>
&lt;li>Phong 光照反射模型、Phong 补色渲染 这 2 个理论都是由 科学家 Bui Tuong Phong 提出的，所以也都以他的名字命名。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>目前来说，补色渲染/逐片元着色，也就是 Phong Sharding 是最好、最复杂的着色方式。&lt;/strong>&lt;/p>
&lt;h3 id="phong-的属性emissive发光颜色">Phong 的属性：emissive(发光颜色)&lt;/h3>
&lt;p>color 指材质的基本颜色，而 emissive 指材质的发光色。&lt;/p>
&lt;p>注意：若将材质的 color 设置为黑色、emissive 设置为 某色 (例如 紫色)，那么此时材质呈现出的是 emissive 颜色。&lt;/p>
&lt;h3 id="phong-的属性shininess光泽度">Phong 的属性：shininess(光泽度)&lt;/h3>
&lt;p>shininess 的值为数字。&lt;/p>
&lt;ol>
&lt;li>最小值可设置为 0，即无光泽度，此时呈现出的效果和 Lambert 相同&lt;/li>
&lt;li>默认值为 30&lt;/li>
&lt;li>该值越大，光泽度越高，呈现的效果越接近 高清玻璃或钢琴烤漆的那种光泽感&lt;/li>
&lt;/ol>
&lt;p>注意：若将材质的 color 设置为黑色、emissive 设置为 某色(例如 紫色)、光泽度 设置为 0，那么此时材质呈现出的是 emissive 颜色，且无光泽度。&lt;/p>
&lt;h2 id="meshbasicmaterialmeshlambertmaterial">MeshBasicMaterial、MeshLambertMaterial&lt;/h2>
&lt;p>当我们对 MeshPhongMaterial 一些特性有所了解后，通过对 光感反射 特性的对比，可以学习了解到 MeshBasicMaterial 和 MeshLambertMaterial。&lt;/p>
&lt;h4 id="几种材质的光感对比">几种材质的光感对比：&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>MeshBasicMaterial：不反射任何光，仅显示材质本身颜色&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>MeshLambertMaterial：仅顶点处反射光&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>MeshPhongMaterial：任何地方都可反射光&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>Lambert 虽然顶点也可以反光，但是相对 Phong 而言，Lambert 整体反光度极其微小、不明显&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h4 id="性能提示">性能提示：&lt;/h4>
&lt;p>关于颜色，以下 3 种情况所呈现出的最终效果完全相同：&lt;/p>
&lt;ol>
&lt;li>基于 MeshBasicMaterial，color 设置为紫色&lt;/li>
&lt;li>基于 MeshLambertMaterial，color 设置为黑色，emissive 设置为 紫色&lt;/li>
&lt;li>基于 MeshPhongMaterial，color 设置为黑色，emissive 设置为 紫色，shininess 设置为 0&lt;/li>
&lt;/ol>
&lt;p>以上 3 种设置下，最终所呈现出的颜色效果完全相同：都是紫色且无光泽。&lt;/p>
&lt;p>但是，从渲染性能上来讲，从上往下 所需要的性能越来越高，因此假设材质不需要 Phone 反光模式 或 镜面高光(光泽)的情况下，应优先选择 较低性能 的材质。&lt;/p>
&lt;h2 id="meshtoonmaterial">MeshToonMaterial&lt;/h2>
&lt;p>MeshToonMaterial 和 MeshPhongMaterial 类似但又不同。&lt;/p>
&lt;p>MeshToonMaterial 并不会像 MeshPhongMaterial 那样使用平滑着色，而是使用渐变贴图( X 乘 1 的纹理) 来决定如何着色。&lt;/p>
&lt;blockquote>
&lt;p>注意：&amp;ldquo;渐变贴图( X 乘 1 的纹理) &amp;quot; 这句话我是从参考教程中看到的，我并没理解这句话的含义。&lt;/p>
&lt;/blockquote>
&lt;p>并不是说必须要设置纹理图片，若不设置则会采用默认的渐变策略：&lt;/p>
&lt;ol>
&lt;li>前 70% 区域 亮度为 70%&lt;/li>
&lt;li>后 30% 区域亮度为 100%&lt;/li>
&lt;/ol>
&lt;p>最终呈现出的效果，看起来特别像卡通动画的风格。所以 &lt;strong>MeshToonMaterial 又被称为 卡通网格材质&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>卡通动画通常大面积为纯色，只在底部增加深色的颜色，以此来表现出立体效果。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>补充一点：&lt;/strong>&lt;/p>
&lt;p>网上很多教程在讲解 MeshToonMaterial 时会提到：&lt;/p>
&lt;p>&lt;code>“MeshToonMaterial 是 MeshPhongMaterial 的扩展”&lt;/code>&lt;/p>
&lt;p>但是我自己通过 MeshToonMaterial.d.ts 源码查询，并未发现 MeshToonMaterial 是继承于 MeshPhongMaterial 的，所以我认为这句话并不正确。&lt;/p>
&lt;h2 id="meshmatcapmaterial">MeshMatcapMaterial&lt;/h2>
&lt;p>一种自带光效(明暗)的材质。&lt;/p>
&lt;h2 id="meshstandardmaterialmeshphysicalmaterial">MeshStandardMaterial、MeshPhysicalMaterial&lt;/h2>
&lt;p>Phong 材质有一个属性 shininess(光泽度)，而 &lt;strong>MeshStandardMaterial&lt;/strong> 有 2 个相对应的属性：&lt;/p>
&lt;ol>
&lt;li>roughness：粗糙度，取值范围为 0 - 1，即 0 为粗糙度最低，此时表现出的光泽度最高&lt;/li>
&lt;li>metalness：金属度，取值范围为 0 - 1，即 0 为非金属、金属度最高为 1&lt;/li>
&lt;/ol>
&lt;p>在 粗糙度和金属度 共同的作用下，呈现出 更加细腻、可控 的光泽度。&lt;/p>
&lt;p>&lt;strong>MeshPhysicalMaterial&lt;/strong> 继承于 MeshStandardMaterial ，新增加 2 个属性：&lt;/p>
&lt;ol>
&lt;li>clearcoat：添加(应用)透明涂层的程度，取值范围为 0 - 1&lt;/li>
&lt;li>clearCoatRoughness：透明涂层的粗糙度，取值范围为 0 - 1&lt;/li>
&lt;/ol>
&lt;p>额外添加的透明涂层，在装修上有一个专业的名词：&lt;strong>清漆&lt;/strong>(又名 凡立水)&lt;/p>
&lt;p>**清漆的含义为：**用透明涂料涂抹在物体表面，形成光滑薄膜，由于是透明的所以原有物体表面的纹理依然清晰可见不受影响。&lt;/p>
&lt;blockquote>
&lt;p>清漆 会让物体呈现出更加光泽的效果。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>因此：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>clearcoat 可以翻译成：添加 清漆 的程度&lt;/li>
&lt;li>clearCoatRoughness 翻译成：清漆粗糙度&lt;/li>
&lt;/ol>
&lt;h2 id="基础材质小总结">基础材质小总结&lt;/h2>
&lt;p>从各种材质渲染所需性能，也就是渲染所需时间的快慢排序，依次是：&lt;/p>
&lt;p>&lt;strong>MeshBasicMaterial &amp;gt; MeshLambertMaterial &amp;gt; MeshPhongMaterial &amp;gt; MeshStandardMaterial &amp;gt; MeshPhysicalMaterial&lt;/strong>&lt;/p>
&lt;p>上面排序中，越靠后的材质所呈现出的 细节 越多、真实感越强。&lt;/p>
&lt;h2 id="特殊材质shadowmaterialmeshdistancematerialmeshdepthmaterialmeshnormalmaterial">特殊材质：ShadowMaterial、MeshDistanceMaterial、MeshDepthMaterial、MeshNormalMaterial&lt;/h2>
&lt;h4 id="shadowmaterial阴影类型的材质">ShadowMaterial：阴影类型的材质&lt;/h4>
&lt;p>我们目前还从未在示例中使用过 ShadowMaterial 材质，ShadowMaterial 是用来创建 阴影 的。&lt;/p>
&lt;h4 id="meshdistancematerial另外一种阴影投射材质">MeshDistanceMaterial：另外一种阴影投射材质&lt;/h4>
&lt;p>相对于 ShadowMaterial 的另外一种阴影投射材质，可以确保内部不透明部分不投射阴影。&lt;/p>
&lt;h4 id="meshdepthmaterial以像素的深度来着色的材质">MeshDepthMaterial：以像素的深度来着色的材质&lt;/h4>
&lt;p>**所谓 “像素的深度” 是指物体距离 镜头(摄像机) 的远近距离。**不同的距离决定不同的着色效果。&lt;/p>
&lt;p>当物体距离镜头越近时会呈现白色、当距离越远时会呈现黑色。&lt;/p>
&lt;blockquote>
&lt;p>你可以想象成在黑夜中去看远方的发光物体，越近的物体所发出的光眼睛看到的越多(显得物体越亮)，越远的物体所发出的光越暗，直至完全消失在黑暗中。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>创建镜头的时候，会有 2 个 参数：near(最近距离)、far(最远距离)&lt;/p>
&lt;/blockquote>
&lt;h4 id="meshnormalmaterial网格法向量材质">MeshNormalMaterial：网格法向量材质&lt;/h4>
&lt;p>该材质是根据 三角面 的 法向量 方向的不同，从而赋予不同的颜色。&lt;/p>
&lt;p>当物体旋转的时候由于各个面的法向量不断发生变化，物体的颜色也是不断发生变化。&lt;/p>
&lt;h4 id="spritematerial精灵材质雪碧材质">SpriteMaterial：精灵材质/雪碧材质&lt;/h4>
&lt;p>精灵材质，也叫 雪碧材质。&lt;/p>
&lt;p>大体来说，就是在场景中，可以加载图片，并且将图片当做纹理贴图，使用在材质上。&lt;/p>
&lt;h2 id="自定义材质shadermaterialrawshadermaterial">自定义材质：ShaderMaterial、RawShaderMaterial&lt;/h2>
&lt;h4 id="shadermaterial使用-threejs-着色器制作自定义材质">ShaderMaterial：使用 Three.js 着色器制作自定义材质&lt;/h4>
&lt;h4 id="rawshadermaterial完全自定义着色器所创建的自定义材质">RawShaderMaterial：完全自定义着色器所创建的自定义材质&lt;/h4>
&lt;p>&lt;strong>特殊材质、自定义材质具体的用法，此刻都不必深究，道路漫漫，时间还长，以后再慢慢研究。&lt;/strong>&lt;/p>
&lt;h2 id="材质通用常用的-2-个属性flatshadingside">材质通用、常用的 2 个属性：flatShading、side&lt;/h2>
&lt;h4 id="flatshading是否平面着色">flatShading：是否平面着色&lt;/h4>
&lt;p>默认值为 false，即使用 渐变过渡着色。&lt;/p>
&lt;p>若设置值为 true，则使用平面着色。&lt;/p>
&lt;blockquote>
&lt;p>若启用平面着色，会让物体看起来更像是多面体，而不是光滑体。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文在讲解 MeshPhongMaterial 的时候已经提到过此属性。&lt;/p>
&lt;/blockquote>
&lt;h4 id="side显示三角形的哪侧边面">side：显示三角形的哪侧边(面)&lt;/h4>
&lt;p>默认值为 Three.FrontSide，即 只显示(渲染) 前面一侧的面。&lt;/p>
&lt;p>若设置值为 Three.BackSide，则 只显示(渲染) 里面一侧的面。&lt;/p>
&lt;blockquote>
&lt;p>对于绝大多数 图元 来说，通常 内部是不可见的，例如 球体或立方体的内部 你是看不见的，只能看见外面。side 通常是针对平面或非实体对象才有效果，例如 一个平面圆形，则背对 镜头的那一面即内面，在物体旋转过程中是可以看到内测那一面的。&lt;/p>
&lt;/blockquote>
&lt;p>若设置值为 Three.DoubleSide，则 两侧(外面和里面) 都将被显示(渲染)。&lt;/p>
&lt;blockquote>
&lt;p>对于实体物体对象(非平面物体) 设置值为 Three.BackSide 或 Three.DoubleSide 都是无意义的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="材质不常用的-1-个属性needsupdate">材质不常用的 1 个属性：needsUpdate&lt;/h2>
&lt;h4 id="第-1-种情况材质种类发生了重大变化">第 1 种情况：材质种类发生了重大变化&lt;/h4>
&lt;p>&lt;strong>针对 面 的材质&lt;/strong>，之前已经提到过，大致分文 3 个类别：基础材质、特殊用途材质、自定义材质&lt;/p>
&lt;p>在实际项目中，通常情况下我们并不会将某个物体的材质进行 3 大类别之间的转换。&lt;/p>
&lt;p>例如我们不太会将某个 物体的材质 由某种基础材质突然变更为 阴影材质。&lt;/p>
&lt;p>尽管实际中发生几率非常小，但万一要发生了呢？&lt;/p>
&lt;h4 id="第-2-种情况材质种类没变但设置发生了变化">第 2 种情况：材质种类没变，但设置发生了变化&lt;/h4>
&lt;p>若材质在被使用过后，发生了以下 2 种设置变化：&lt;/p>
&lt;ol>
&lt;li>flatShading 属性值的改变&lt;/li>
&lt;li>添加或删除 纹理(texture)
&lt;ol>
&lt;li>从不使用纹理变为使用纹理&lt;/li>
&lt;li>从使用纹理变为不使用纹理&lt;/li>
&lt;li>纹理的变更是允许的，并不属于 “添加或删除纹理” 的范畴中&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h4 id="设置-needsupdate-属性">设置 needsUpdate 属性&lt;/h4>
&lt;p>&lt;strong>当上述 2 种情况发生后，此时就需要设置 needsUpdate 属性：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>material.needsUpdate = true
&lt;/code>&lt;/pre>&lt;p>明确告知 Three.js 材质发生了重大变化，请使用新的材质重新渲染。&lt;/p>
&lt;blockquote>
&lt;p>更换新的材质并重新渲染，这个过程将消耗比较多的计算性能。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>在官方教程中，讲解 needsUpdate 属性时还有一句话：&lt;/p>
&lt;p>&lt;code>在从纹理过渡到无纹理的情况下，通常最好使用1x1像素的白色纹理。&lt;/code>&lt;/p>
&lt;p>由于目前还没有学习过纹理，所以我暂时没理解这句话具体的含义是什么。&lt;/p>
&lt;p>关于 材质 的一些基础知识，本文已经讲完。&lt;/p>
&lt;p>&lt;strong>具体的每个材质都需要阅读官方文档，以及经过大量的练习才能掌握。&lt;/strong>&lt;/p>
&lt;p>同一个材质在不同光照、纹理的作用下，可能呈现出的效果相差很大。&lt;/p>
&lt;p>下一节，学习 纹理(Texture)。&lt;/p></description></item><item><title>10.Three.js 基础之纹理</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/10.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/10.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%B9%E7%90%86/</guid><description>&lt;h1 id="10-threejs-基础之纹理">10 Three.js 基础之纹理&lt;/h1>
&lt;h3 id="纹理texture概要">纹理(Texture)概要&lt;/h3>
&lt;p>前面学习的 材质(material) 更多是表达一个物体表面的物理特性和一些简单的外观颜色。&lt;/p>
&lt;p>而 纹理(Texture) 则专门来设置物体表面贴合的彩色图片的，具体做法就是：&lt;/p>
&lt;ol>
&lt;li>使用纹理加载器 TextureLoader 加载外部图片(.jpg 或.png)&lt;/li>
&lt;li>通过设置 物体的 .map 属性，将加载得到的外部图片贴合在物体表面&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>有些 3D 软件教程会直接将 纹理 称呼为 皮肤、贴图&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>纹理加载器的简单示例代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const loader = new Three.TextureLoader()
const material = new Three.MeshBasicMaterial({
map:loader.load(&amp;#39;xxx/xx.jpg&amp;#39;)
})
&lt;/code>&lt;/pre>&lt;p>&lt;strong>补充一点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>在汉语词语中，纹最初指 乌龟壳上的纹路、理最初指 石头上的纹路和细腻程度&lt;/li>
&lt;li>在物理中，纹理指物体表面凸凹不平的沟纹&lt;/li>
&lt;li>在 Three.sj 中，纹理指 物体光滑表面上的彩色图案&lt;/li>
&lt;/ol>
&lt;p>由于纹理牵扯到 图片资源加载，所以我们先补充一下 react 引入图片资源的相关知识。&lt;/p>
&lt;h2 id="在-reacttypescript-中引入图片资源">在 React+TypeScript 中引入图片资源&lt;/h2>
&lt;p>在 React + TypeScript 中引入本地图片资源的方法如下。&lt;/p>
&lt;h4 id="第一件要做的事情srcglobaldts">&lt;strong>第一件要做的事情：src/global.d.ts&lt;/strong>&lt;/h4>
&lt;pre tabindex="0">&lt;code>declare module &amp;#39;*.png&amp;#39;;
declare module &amp;#39;*.gif&amp;#39;;
declare module &amp;#39;*.jpg&amp;#39;;
declare module &amp;#39;*.jpeg&amp;#39;;
declare module &amp;#39;*.svg&amp;#39;;
declare module &amp;#39;*.css&amp;#39;;
declare module &amp;#39;*.less&amp;#39;;
declare module &amp;#39;*.scss&amp;#39;;
declare module &amp;#39;*.sass&amp;#39;;
declare module &amp;#39;*.styl&amp;#39;;
declare module &amp;#39;react-app-rewire-alias&amp;#39;;
&lt;/code>&lt;/pre>&lt;p>我们先要确保项目源码中 src/global.d.ts 中有针对 图片资源 的声明模块。&lt;/p>
&lt;p>例如：&lt;code>declare module '*.jpg';&lt;/code> 是告诉 TypeScript ，允许在 React 代码中 引入 jpg 格式的文件模块&lt;/p>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>declare module &amp;#39;*.jpg&amp;#39;;
&lt;/code>&lt;/pre>&lt;p>上面那行声明代码是一种简写，实际他表示的代码为：&lt;/p>
&lt;pre tabindex="0">&lt;code>declare module &amp;#39;*.jpg&amp;#39; {
const content: string;
export default content;
}
&lt;/code>&lt;/pre>&lt;h4 id="第-1-种使用-import-引入和使用图片">第 1 种：使用 import 引入和使用图片&lt;/h4>
&lt;p>假设图片文件位置为 src/assets/imgs/mapping.jpg，那么引入该图片文件的代码为：&lt;/p>
&lt;pre tabindex="0">&lt;code>import imgSrc from &amp;#39;../assets/imgs/mapping.jpg&amp;#39;
&lt;/code>&lt;/pre>&lt;p>使用该图片，代码为：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;img src={imgSrc}&amp;gt;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意 imgSrc 的实际类型为 string，imgSrc 是 react 编译后该图片资源对应的位置&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>经过 React 编译之后，图片位置最终变为：static/media/mapping.xxxxxxxx.jpg&lt;/p>
&lt;/blockquote>
&lt;h4 id="第-2-种使用-require-引入和使用图片">第 2 种：使用 require 引入和使用图片&lt;/h4>
&lt;p>不需要在顶部 import 图片资源，而是直接使用：require(&amp;lsquo;xxx&amp;rsquo;).default 的形式获得图片资源最终路径：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;img src={require(&amp;#39;../assets/imgs/mapping.jpg&amp;#39;).default}&amp;gt;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意，一定要 要有.default 才可以&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>当需要批量引入很多张图片时，或者动态获得 引入的图片地址时，第 2 种写法就非常方便&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>问题延展：&lt;/strong>&lt;/p>
&lt;p>你是否还记得在讲解 图元 中 TextBufferGeometry 时候，当时字体数据也是靠加载，当时演示的时候加载的是一个网络资源：&lt;/p>
&lt;pre tabindex="0">&lt;code>const url = &amp;#39;https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&amp;#39;
&lt;/code>&lt;/pre>&lt;p>那如果 字体数据文件 .json 在项目本地资源中，又该如何加载呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先可以肯定的是，引入图片资源的方式并不适用于 .json 文件资源&lt;/p>
&lt;blockquote>
&lt;p>.json 文件 对应的 webpack 加载器为 json-loader，他是可以直接将 json 中数据内容解析出来直接给我们使用的&lt;/p>
&lt;p>.jpg 文件对应的是 webpack 加载器为 file-loader，他仅仅是将资源更换目录和重命名，并不会对图片(图片也不需要)内容解析的&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>那该怎么引入？&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个问题我们知识先思考一下，暂时先不去讲如何解决。&lt;/p>
&lt;p>让我们回到 HelloTexture 中。&lt;/p>
&lt;h2 id="示例-1加载一张图实现一个有贴图的立方体">示例 1：加载一张图，实现一个有贴图的立方体&lt;/h2>
&lt;h4 id="示例目标">示例目标&lt;/h4>
&lt;ol>
&lt;li>创建一个正方体&lt;/li>
&lt;li>通过 TextureLoader 加载一张外部图片&lt;/li>
&lt;li>将图片贴在立方体的 6 个面上&lt;/li>
&lt;/ol>
&lt;h4 id="具体示例编写">具体示例编写&lt;/h4>
&lt;p>&lt;strong>第 1 步、添加纹理加载所需的图片资源&lt;/strong>&lt;/p>
&lt;p>网上随便找了一张风景图，存放在项目 src/assets/imgs 目录中，文件名 mapping.jpg&lt;/p>
&lt;p>&lt;strong>第 2 步：添加图片目录对应的 alias 配置&lt;/strong>&lt;/p>
&lt;p>修改项目中 tsconfig.paths.json，向 paths 中添加 src/assets 目录的资源别名：&lt;/p>
&lt;pre tabindex="0">&lt;code> &amp;#34;@/assets/*&amp;#34;: [&amp;#34;./src/assets/*&amp;#34;]
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>备注：以后的章节中，我们还会陆续向 assets 目录中添加其他类型的文件，例如模型文件、asc 数据文件等等。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>第 3 步：编写 HelloTexture&lt;/strong>&lt;/p>
&lt;p>在项目 src/components/hello-texture/ 中创建 index.tsx，代码内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import &amp;#39;./index.scss&amp;#39;
import imgSrc from &amp;#39;@/assets/imgs/mapping.jpg&amp;#39; //引入图片资源
const HelloTexture = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) {
return
}
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement })
const camera = new Three.PerspectiveCamera(40, 2, 0.1, 1000)
camera.position.set(0, 0, 40)
const scene = new Three.Scene()
scene.background = new Three.Color(0xcccccc)
//创建一个 纹理加载器
const loader = new Three.TextureLoader()
//创建一个材质，材质的 map 属性值为 纹理加载器加载的图片资源
const material = new Three.MeshBasicMaterial({
map: loader.load(imgSrc) //loader.load(&amp;#39;xxx.jpg&amp;#39;)返回值为Three.Text类型实例
})
const box = new Three.BoxBufferGeometry(8, 8, 8)
const mesh = new Three.Mesh(box, material)
scene.add(mesh)
const render = (time: number) =&amp;gt; {
time = time * 0.001
mesh.rotation.x = time
mesh.rotation.y = time
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const resizeHandle = () =&amp;gt; {
const canvas = renderer.domElement
camera.aspect = (canvas.clientWidth / canvas.clientHeight)
camera.updateProjectionMatrix()
renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
}
resizeHandle()
window.addEventListener(&amp;#39;resize&amp;#39;, resizeHandle)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, resizeHandle)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloTexture
&lt;/code>&lt;/pre>&lt;p>查看最终效果，终端中执行：yarn start&lt;/p>
&lt;p>若一切正常，就会看到一个包含风景贴图的立方体。&lt;/p>
&lt;h2 id="示例-2加载多张图片实现一个骰子">示例 2：加载多张图片，实现一个骰子&lt;/h2>
&lt;p>在上面的示例中，我们是加载了一张图片资源，然后立方体默认 6 个面都采用这张图来进行贴图渲染。&lt;/p>
&lt;p>那么假设我们希望立方体每个面都使用不同的图片来进行贴图，还如何实现呢？&lt;/p>
&lt;h4 id="骰子的特征就是立方体-6-个面贴图均不相同">骰子的特征就是：立方体 6 个面贴图均不相同&lt;/h4>
&lt;blockquote>
&lt;p>骰(tóu)子，也就是 色(shǎi)子。&lt;/p>
&lt;/blockquote>
&lt;h3 id="实现方式">实现方式&lt;/h3>
&lt;p>在之前的代码中，我们创建物体，也就是网格的代码是：&lt;/p>
&lt;pre tabindex="0">&lt;code>const mesh = new Three.Mesh(box, material)
&lt;/code>&lt;/pre>&lt;p>请注意，上述代码中 material 是单个材质，如果我们想实现将立方体各个面都使用不同材质，&lt;strong>我们可以将 material 替换为一个 数组(数组元素为 6 个 material ) 即可&lt;/strong>。&lt;/p>
&lt;h3 id="第-1-步添加-骰子-的-6-个面图片资源">第 1 步：添加 骰子 的 6 个面图片资源&lt;/h3>
&lt;p>假设我们已经有 骰子 6 个面的图片资源，分别是：&lt;/p>
&lt;ol>
&lt;li>src/assets/imgs/dice0.jpg&lt;/li>
&lt;li>&amp;hellip;.&lt;/li>
&lt;li>src/assets/imgs/dice5.jpg&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>其中 dice0.jpg 对应骰子 1 点、&amp;hellip;、dice5.jpg 对应骰子 6 点&lt;/strong>&lt;/p>
&lt;h3 id="第-2-步引入-6-个图片资源并创建材质数组">第 2 步：引入 6 个图片资源，并创建材质数组&lt;/h3>
&lt;h4 id="第-1-种方式使用-import-引入图片">第 1 种方式：使用 import 引入图片：&lt;/h4>
&lt;p>&lt;strong>依次引入 6 个图片资源&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import imgSrc0 from &amp;#39;@/assets/imgs/dice0.jpg&amp;#39;
import imgSrc1 from &amp;#39;@/assets/imgs/dice1.jpg&amp;#39;
import imgSrc2 from &amp;#39;@/assets/imgs/dice2.jpg&amp;#39;
import imgSrc3 from &amp;#39;@/assets/imgs/dice3.jpg&amp;#39;
import imgSrc4 from &amp;#39;@/assets/imgs/dice4.jpg&amp;#39;
import imgSrc5 from &amp;#39;@/assets/imgs/dice5.jpg&amp;#39;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>创建材质数组，元素为骰子的 6 个面对应的材质&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>//创建一个纹理加载器
const loader = new Three.TextureLoader()
const imgSraArr = [imgSrc0, imgSrc1, imgSrc2, imgSrc3, imgSrc4, imgSrc5]
//创建一组材质，每个材质对应立方体每个面所用到的材质
const materialArr: Three.MeshBasicMaterial[] = []
imgSraArr.forEach((src) =&amp;gt; {
materialArr.push(new Three.MeshBasicMaterial({
map: loader.load(src)
}))
})
&lt;/code>&lt;/pre>&lt;h4 id="第-2-种方式使用-require-引入图片">第 2 种方式：使用 require 引入图片：&lt;/h4>
&lt;p>实际上使用的是 for 循环 + requrie + 字符串模板 生成出图片资源地址&lt;/p>
&lt;pre tabindex="0">&lt;code>//不需要在顶部 import xxx from &amp;#39;xxx.jpg&amp;#39;
//创建一个 纹理加载器
const loader = new Three.TextureLoader()
//创建 6 个面对应的材质
const materialArr: Three.MeshBasicMaterial[] = []
for (let i = 0; i &amp;lt; 6; i++) {
materialArr.push(new Three.MeshBasicMaterial({
map: loader.load(require(`@/assets/imgs/dice${i}.jpg`).default)
}))
}
&lt;/code>&lt;/pre>&lt;h3 id="第-3-步创建网格时使用-材质数组-materialarr">第 3 步：创建网格时，使用 材质数组 materialArr&lt;/h3>
&lt;pre tabindex="0">&lt;code>const box = new Three.BoxBufferGeometry(8, 8, 8)
const mesh = new Three.Mesh(box, materialArr) //注意，此处使用的不再是单个材质，而是一个材质数组
scene.add(mesh)
&lt;/code>&lt;/pre>&lt;p>最终实际运行后，立方体 6 个面分别贴上不同数字的图片，一个 骰子 效果实现了。&lt;/p>
&lt;p>你以为完事了？&lt;/p>
&lt;h3 id="冷静观察并思考骰子数字的分布">冷静观察并思考：骰子数字的分布&lt;/h3>
&lt;p>&lt;strong>经过观察，你会发现，骰子数字目前的分布为：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>数字 1 对面是 数字 2&lt;/li>
&lt;li>数字 3 对面是 数字 4&lt;/li>
&lt;li>数字 5 对面是 数字 6&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>现实中的骰子数字分布规则：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>数字 1 对面是 数字 6&lt;/li>
&lt;li>数字 2 对面是 数字 5&lt;/li>
&lt;li>数字 3 对面是 数字 4&lt;/li>
&lt;/ol>
&lt;p>简而言之就是 对立面 2 边的数字相加必须等于 7。&lt;/p>
&lt;p>如果想模拟出真实的骰子数字分布，那么就要按照这个规则去修改图片编号对应的图片数字。&lt;/p>
&lt;h3 id="加载多张图作为材质的补充说明">加载多张图作为材质的补充说明：&lt;/h3>
&lt;p>上面示例 2 中演示了 加载 6 张图，并贴合到 立方体的 6 个面上。现在，我们思考以下几个问题。&lt;/p>
&lt;p>&lt;strong>问题 1：假设立方体 6 个面，但是材质只有 5 个 或者 4 个，会出现什么情况呢？&lt;/strong>&lt;/p>
&lt;p>答：缺少 N 个面的材质，立方体就会有 N 个面直接显示为空白，当然你也可以说显示为 “透明”、&amp;ldquo;缺失&amp;rdquo;。&lt;/p>
&lt;p>&lt;strong>创建网格时：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>若 Three.Mesh(xx,xx) 构造函数中第 2 个参数值是 单个 材质，则图元实例上所有的面均采用该材质(纹理)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>若第 2 个参数值是 材质组成的数组，则该数组中材质数量不能少于图元实例各个可渲染面的数量。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>问题 2：立方体是 6 个可渲染的面，那其他图元都有几个可渲染的面？&lt;/strong>&lt;/p>
&lt;p>答：&lt;strong>支持多个材质纹理的图元，可需要渲染的面数量也不同&lt;/strong>，例如圆锥体只需要 2 个面(圆锥侧面、圆锥底面)、圆柱体 一共 3 个面，也就是需要 3 个材质贴图(圆柱上下 2 个底 + 圆柱侧面)。&lt;/p>
&lt;p>不是所有材质都支持多个材质纹理的，例如平面圆(CircleBufferGeometry)、平面矩形(PlaneBufferGeometry) 都仅只支持 1 个材质纹理。&lt;/p>
&lt;p>&lt;strong>问题 3：Three.js 纹理是否支持精灵图(雪碧图)？&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>精灵图也被称为雪碧图，比如在网页 CSS 中，可以将多个小图标图片合并放在一张图片上，当不同地方需要使用不同的图标图片时，通过设置图片中的图标对应的位置来只显示该图标。&lt;/p>
&lt;p>这样做的好处是可以让 N 个小图片资源请求 合并为 1 个图片资源请求，降低服务器请求压力。&lt;/p>
&lt;/blockquote>
&lt;p>答：&lt;strong>Three.js 纹理是完全支持 精灵图(雪碧图) 的。&lt;/strong>&lt;/p>
&lt;p>实现方式就是将多张图片合并成一张图片，然后创建成一个 纹理图集(texture atlas)，具体的做法会在之后学习的 构建自定义几何图形时讲解。&lt;/p>
&lt;h2 id="示例-3纹理加载器的不同事件回调函数">示例 3：纹理加载器的不同事件回调函数&lt;/h2>
&lt;p>让我们在回到 示例 1 的代码中，关于纹理加载器的代码片段：&lt;/p>
&lt;pre tabindex="0">&lt;code>//创建一个 纹理加载器
const loader = new Three.TextureLoader()
/创建一个材质，材质的 map 属性值为 纹理加载器加载的图片资源
const material = new Three.MeshBasicMaterial({
map: loader.load(require(&amp;#39;@/assets/imgs/mapping.jpg&amp;#39;).default)
})
&lt;/code>&lt;/pre>&lt;p>上述代码中，我们只是设置了加载图片资源的文件路径，并没有添加图片加载相关的事件处理回调函数。&lt;/p>
&lt;p>关于纹理加载器 load()，相应的 .d.ts 定义为：&lt;/p>
&lt;pre tabindex="0">&lt;code>TextureLoader.load(
url: string,
onLoad?: ((texture: Three.Texture) =&amp;gt; void) | undefined,
onProgress?: ((event: ProgressEvent&amp;lt;EventTarget&amp;gt;) =&amp;gt; void) | undefined,
onError?: ((event: ErrorEvent) =&amp;gt; void) | undefined
): Three.Texture
&lt;/code>&lt;/pre>&lt;p>为了显示更多纹理图片加载过程中的细节，我们可以将代码修改为：&lt;/p>
&lt;pre tabindex="0">&lt;code>//创建一个 纹理加载器
const loader = new Three.TextureLoader()
const material = new Three.MeshBasicMaterial({
map: loader.load(require(&amp;#39;@/assets/imgs/mapping.jpg&amp;#39;).default,
(texture) =&amp;gt; {
console.log(&amp;#39;纹理图片加载完成&amp;#39;)
console.log(texture)
console.log(texture.image.currentSrc) //此处即图片实际加载地址
},
(event) =&amp;gt; {
console.log(&amp;#39;纹理图片加载中...&amp;#39;)
console.log(event)
},
(error) =&amp;gt; {
console.log(&amp;#39;纹理图片加载失败！&amp;#39;)
console.log(error)
}
)
})
&lt;/code>&lt;/pre>&lt;p>&lt;strong>请注意：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在项目调试过程中，由于图片资源位于本地，所以加载所需时间极其短暂。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若项目加载的是网络图片资源，但是由于目前一般网速都比较快，一张 100K 左右的图片下载所需时间非常短暂，所以可能在即运行中，根本触发不了 onProgress 处理函数。&lt;/p>
&lt;blockquote>
&lt;p>此处是存疑的，因为按照我的理解，就算是图片资源加载再快，onProgress 回调函数至少也应该执行一次才对的，可事实是 onProgress 回调函数一次也没有被调用。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>补充说明：谷歌浏览器网络调试&lt;/strong>&lt;/p>
&lt;p>为了能够模拟出网络加载速度较慢的情况，可以通过设置 谷歌浏览器 调试工具中的 网络面板。&lt;/p>
&lt;ol>
&lt;li>勾选上 Disable cache (禁用缓存)&lt;/li>
&lt;li>将网络由 Online 修改为自定义网络网速模式，在创建的自定义网速模式中可是设置下载或上传的网速。&lt;/li>
&lt;/ol>
&lt;h2 id="示例-4使用纹理加载管理器监控多个图片资源的加载">示例 4：使用纹理加载管理器监控多个图片资源的加载&lt;/h2>
&lt;p>在示例 3 中，我们可以直接给 TextureLoader 的 load 方法中传递加载事件处理回调函数。&lt;/p>
&lt;p>假设我们需要加载多个 纹理图片资源，可以新建一个 Three.LoadingManager 实例，并把该实例传递给 TextureLoader 的构造函数。这样，LoadingManager 将来托管和处理 该 TextureLoader 所有的图片加载。&lt;/p>
&lt;p>&lt;strong>具体代码示例：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>//创建所有纹理加载的管理器
const loadingManager = new Three.LoadingManager()
//创建一个 纹理加载器
const loader = new Three.TextureLoader(loadingManager)
//创建 6 个面对应的材质
const materialArr: Three.MeshBasicMaterial[] = []
for (let i = 0; i &amp;lt; 6; i++) {
materialArr.push(new Three.MeshBasicMaterial({
map: loader.load(require(`@/assets/imgs/dice${i}.jpg`).default)
}))
}
//添加加载管理器的各种事件处理函数
loadingManager.onLoad = () =&amp;gt; {
console.log(&amp;#39;纹理图片资源加载完成&amp;#39;)
}
loadingManager.onProgress = (url, loaded, total) =&amp;gt; {
console.log(`图片加载中, 共 ${total} 张，当前已加载 ${loaded} 张 ${url}`)
}
loadingManager.onError = (url) =&amp;gt; {
console.log(`加载失败 ${url}`)
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意，onProgress 中的 loaded 和 total 分别指：&lt;/p>
&lt;ol>
&lt;li>loaded：已加载完成的纹理图片数量&lt;/li>
&lt;li>total：总共需要加载的纹理图片数量&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>在上面代码中，虽然是先执行的 loader.load( &amp;hellip; )，后定义了 onLoad、onProgress、onError，但是由于 load 加载是异步的，执行完成存在延迟性，所以 onLoad、onProgress、onError 是一定会被正确触发执行的。&lt;/p>
&lt;h2 id="纹理占用的内存">纹理占用的内存&lt;/h2>
&lt;h3 id="只与图片尺寸宽高有关与图片文件体积无关">只与图片尺寸(宽高)有关，与图片文件体积无关&lt;/h3>
&lt;h4 id="原则-1纹理图片文件的体积只影响加载完成所需时间">原则 1：纹理图片文件的体积只影响加载完成所需时间&lt;/h4>
&lt;p>加载完成所需时间是由 服务器带宽和你本机下载速度 决定的。&lt;/p>
&lt;h4 id="原则-2纹理图片的尺寸宽高决定所占内存大小">原则 2：纹理图片的尺寸(宽高)决定所占内存大小&lt;/h4>
&lt;p>&lt;strong>占用内存计算公式：width _ height _ 4 * 1.33 字节&lt;/strong>&lt;/p>
&lt;p>举例，假设某个纹理图片的尺寸为 宽 200，高 300，那么这个纹理所占的内存为：&lt;/p>
&lt;p>200 _ 300 _ 4 * 1.33 = 319200 byte(字节) ≈ 319 kb&lt;/p>
&lt;h4 id="原则-3纹理图片的清晰度图片质量并不影响所占内存大小">原则 3：纹理图片的清晰度(图片质量)并不影响所占内存大小&lt;/h4>
&lt;p>纹理图片所占内存只与图片宽高有关，至于图片清晰度(图片质量)，对于所占内存而言是没有区别的。&lt;/p>
&lt;h4 id="原则-4同样尺寸的-jpg-和-png-图片所占内存大小相同">原则 4：同样尺寸的 JPG 和 PNG 图片所占内存大小相同&lt;/h4>
&lt;p>纹理图片所占内存只与图片宽高有关，至于图片是哪种格式(JPG 或 PNG)，对于所占内存而言是没有区别的。&lt;/p>
&lt;p>但是请注意，&lt;strong>由于 PNG 图片包含透明度信息，对于非图像贴图(例如 法线贴图)而言，PNG 包含的像素透明度信息非常有用，此时应选择 PNG 格式。&lt;/strong>&lt;/p>
&lt;p>无论哪种方式，关于纹理图片渲染所占内存和相关计算，都是交由 GPU 来负责计算的。&lt;/p>
&lt;p>&lt;strong>小总结：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>纹理图片所占内存大小仅和宽高有关，因此在保证贴图清晰度的前提下应尽量减小图片尺寸。&lt;/li>
&lt;li>纹理图片的格式、清晰度仅会影响加载资源所需时间。&lt;/li>
&lt;/ol>
&lt;h2 id="纹理图片尺寸与物体渲染尺寸的关系处理">纹理图片尺寸与物体渲染尺寸的关系处理&lt;/h2>
&lt;p>&lt;strong>纹理图片尺寸：是指图片本身的宽高尺寸&lt;/strong>&lt;/p>
&lt;p>&lt;strong>物体渲染面尺寸：是指最终在镜头中物体某一个面所渲染出的尺寸&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>物体渲染尺寸是由 物体本身大小和物体距离镜头的远近来共同决定的。&lt;/p>
&lt;/blockquote>
&lt;p>纹理图片尺寸和物体渲染面尺寸几乎是不可能刚好完全相同的。&lt;/p>
&lt;blockquote>
&lt;p>这个几率几乎不存在&lt;/p>
&lt;/blockquote>
&lt;p>那么我们就需要考虑，假设 2 者尺寸不相同时，Three.js 是如何处理的。&lt;/p>
&lt;p>首先我们先了解一下 mipmap 算法模式。&lt;/p>
&lt;h4 id="什么是-mipmap-">什么是 mipmap ？&lt;/h4>
&lt;p>mipmap 是目前 3D 应用最为广泛的纹理映射技术之一。&lt;/p>
&lt;p>mipmap 的原则是将图片的每个边(宽和高)对应的分辨率只取上一级的 1/2。&lt;/p>
&lt;p>这样便可以通过计算，不断得到 面积为上一级 1/4 的图片数据，直至最终图片为 1 像素 * 1 像素。&lt;/p>
&lt;p>而 Three.js 会选择最接近于物体渲染面尺寸 的那一级渲染图片，并渲染出效果。&lt;/p>
&lt;p>假设 纹理图片尺寸大于渲染面尺寸，此时需要对纹理进行缩小。&lt;/p>
&lt;blockquote>
&lt;p>此处为我个人的理解：假设纹理图片尺寸小于渲染面尺寸，那么此时使用相反计算过程，最终得到一个比较模糊但尺寸符合的贴图数据。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>这样做的好处是？&lt;/strong>&lt;/p>
&lt;p>答：这种策略其实相当于牺牲掉了纹理贴图的精准性，换来了计算所需性能上的提升。&lt;/p>
&lt;p>这也解释了为什么有时候即使纹理图片尺寸非常大，但某些时候渲染出的物体实际上还是略有模糊。&lt;/p>
&lt;h4 id="纹理的缩放模式有哪几种">纹理的缩放模式有哪几种？&lt;/h4>
&lt;p>大体上可以分为 3 种：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>NearestFilter&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LinearFilter&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mipmap 相关的模式&lt;/p>
&lt;blockquote>
&lt;p>mipmap 与 Nearest、Linear 的各种结合&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>缩放模式&lt;/th>
&lt;th>模式说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>NearestFilter&lt;/td>
&lt;td>最接近模式，选择最接近的像素&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NearestMipmapNearestFilter&lt;/td>
&lt;td>选择最贴近目标解析度的 Mip，然后线性过滤器将其渲染&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NearestMipMapNearestFilter&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NearestMipmapLinearFilter&lt;/td>
&lt;td>选择层次最近的 2 个 Mip，将 2 个 Mip 使用线性模式将其混合&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NearestMipMapLinearFilter&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LinearFilter&lt;/td>
&lt;td>线性模式，选择 4 个像素并将进行混合&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LinearMipmapNearestFilter&lt;/td>
&lt;td>选择最贴近目标解析度的 1 个 Mip，然后使用线性模式将其混合&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LinearMipMapNearestFilter&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LinearMipmapLinearFilter&lt;/td>
&lt;td>选择层次最近的 2 个 Mip，然后使用线性模式将其混合&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LinearMipMapLinearFilter&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>上述表格中 Mipmap 和 MipMap 应该是同一个意思的不同书写方式而已。&lt;/p>
&lt;p>除了 NearestFilter 和 LinearFilter 之外，其他模式都属于 Mipmap 模式的变种。&lt;/p>
&lt;/blockquote>
&lt;p>当第一次见到 Mipmap 模式时，一定是有点摸不着头脑，不清楚究竟他们区别是什么，暂时不用担心，先大致了解即可。&lt;/p>
&lt;p>请记住以下原则：&lt;/p>
&lt;p>&lt;strong>Nearest：最接近算法，精确度高，像素感比较强烈，锐化程度比较强烈，所用计算量大&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Linear：线性算法，精确度不高，像素感不强烈，锐化程度不强，相对比较模糊和平滑，所用计算量小&lt;/strong>&lt;/p>
&lt;p>NearestMipmapNearestFilter、NearestMipmapLinearFilter、LinearMipmapNearestFilter、LinearMipmapLinearFilter 都是在 Mipmap 模式下，分别使用 nearest 和 linear 算法的相互结合产物。&lt;/p>
&lt;h4 id="修改之前示例中的纹理相关代码">修改之前示例中的纹理相关代码：&lt;/h4>
&lt;p>在之前示例代码中，我们给某个材质添加纹理都是通过：&lt;/p>
&lt;pre tabindex="0">&lt;code>const loader = new Three.TextureLoader()
const material = new Three.MeshBasicMaterial({
map: loader.load( ... )
})
&lt;/code>&lt;/pre>&lt;p>上面代码中的 loader.load() 返回值就是 Three.Texture 的一个实例。&lt;/p>
&lt;p>为了方便我们设置 Texture，我们可以将上面代码修改为：&lt;/p>
&lt;pre tabindex="0">&lt;code>const loader = new Three.TextureLoader()
const texture: Three.Texture = loader.load( ... )
const material = new Three.MeshBasicMaterial({
map: texture
})
&lt;/code>&lt;/pre>&lt;h3 id="情况-1纹理图片尺寸-大于-物体渲染面的尺寸">情况 1：纹理图片尺寸 大于 物体渲染面的尺寸&lt;/h3>
&lt;p>设置纹理缩小模式的属性：&lt;strong>magFilter&lt;/strong>&lt;/p>
&lt;p>&lt;strong>当纹理图片尺寸 大于 物体渲染面尺寸时，可以通过设置 texture.magFilter 的值来设置纹理的清晰度模式：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>texture.magFilter = &lt;strong>Three.NearestFilter：最接近模式&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>该模式下最终渲染效果更加清晰，但所需内存更多，渲染时间慢&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>texture.magFilter = &lt;strong>Three.LinearFilter：线性模式&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>该模式下最终渲染效果略微模糊，但所需内存更少，渲染时间快&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>默认，magFilter 的值是 Three.LinearFilter。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>注意：纹理图片缩小模式，不可以选择 Mipmap 中的任何一种模式，只能从 NearestFilter、LinearFilter 选择其一。&lt;/p>
&lt;/blockquote>
&lt;h3 id="情况-2纹理图片尺寸-小于-物体渲染面的尺寸">情况 2：纹理图片尺寸 小于 物体渲染面的尺寸&lt;/h3>
&lt;p>设置纹理放大模式的属性：&lt;strong>minFilter&lt;/strong>&lt;/p>
&lt;p>&lt;strong>当纹理图片尺寸 小于 物体渲染面尺寸时，可以通过设置 texture.minFilter 的值来设置纹理的清晰度模式：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>texture.minFilter = &lt;strong>Three.NearestFilet (最接近模式)&lt;/strong>&lt;/li>
&lt;li>texture.minFilter = &lt;strong>Three.LinearFilter (线性模式)&lt;/strong>&lt;/li>
&lt;li>texture.minFilter = &lt;strong>Three.NearestMipmapNearestFileter&lt;/strong>&lt;/li>
&lt;li>texture.minFilter = &lt;strong>Three.NearestMipmapLinearFilter&lt;/strong>&lt;/li>
&lt;li>texture.minFilter = &lt;strong>Three.LinearMipmapNearestFilter&lt;/strong>&lt;/li>
&lt;li>texture.minFilter = &lt;strong>Three.LinearMipmapLinearFilter&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>默认，minFilter 的值是 LinearMipmapLinearFilter。&lt;/strong>&lt;/p>
&lt;h3 id="究竟该选择哪种模式">究竟该选择哪种模式？&lt;/h3>
&lt;p>&lt;strong>纹理需要缩小时，如果对渲染清晰度要求比较高，则选择 NearestFilter&lt;/strong>&lt;/p>
&lt;p>&lt;strong>纹理需要放大时，如无特殊需要，推荐使用默认的 LinearMipmapLinearFilter&lt;/strong>&lt;/p>
&lt;h3 id="在不考虑性能的前提下选择-nearest-是否渲染效果最佳">在不考虑性能的前提下，选择 Nearest 是否渲染效果最佳？&lt;/h3>
&lt;p>事实上，除了性能方面的考虑之外，无非特殊必要，并不推荐使用 Nearest 相关模式。&lt;/p>
&lt;p>原因是若使用 Nearest 相关模式，会让物体无论哪个位置像素感都比较强，也就是 锐化 程度比较强烈，假设物体远处渲染的面比较小，那么此时物体远处渲染效果就会出现 “像素抖动” 的情况。&lt;/p>
&lt;p>而使用 Linear 相关模式，则物体远处像素会比较平滑，不会产生抖动感。&lt;/p>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>&lt;strong>有一种情况除外：采用纹理重复的方式，用极致的小图去渲染比较大的面&lt;/strong>&lt;/p>
&lt;p>满足以下条件：&lt;/p>
&lt;ol>
&lt;li>纹理图片极其小，例如 2 像素 X 2 像素&lt;/li>
&lt;li>希望通过 纹理重复 ，来将比较小的 图片 铺满 整个渲染面&lt;/li>
&lt;/ol>
&lt;p>这个时候就推荐使用 Nearest 模式了，因为只有这样才可以保证渲染出的效果比较清晰。&lt;/p>
&lt;p>例如：用一个 2 X 2 像素的黑白相间的纹理图片，作为某个大的、类似围棋盘一样的黑白纹理贴图，那么此时就需要将模式设置为 Nearest。&lt;/p>
&lt;blockquote>
&lt;p>提前预告：下一节我们将讲解 灯光，其中就会用到这个知识点。&lt;/p>
&lt;/blockquote>
&lt;h2 id="纹理的重复偏移旋转">纹理的重复、偏移、旋转&lt;/h2>
&lt;p>默认情况下，纹理是不会重复、偏移和旋转的。&lt;/p>
&lt;blockquote>
&lt;p>默认将纹理通过 伸缩 以适用于渲染面。&lt;/p>
&lt;/blockquote>
&lt;p>接下来讲一下如何设置纹理的重复、偏移、旋转。&lt;/p>
&lt;h3 id="设置重复方式">设置重复方式&lt;/h3>
&lt;p>纹理重复分为：水平重复(warpS)、垂直重复(warpT)&lt;/p>
&lt;p>&lt;strong>重复有 3 种形式：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Three.ClampToEdgeWrapping：每个边缘最后一个像素将永远重复&lt;/li>
&lt;li>Three.RepeatWrapping：重复整个纹理&lt;/li>
&lt;li>Three.MirroredRepeatWrapping：纹理被镜像(对称反转)并重复&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>设置重复代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>texture.wrapS= Three.RepeatWrapping
texture.wrapT= Three.RepeatWrapping
&lt;/code>&lt;/pre>&lt;h3 id="设置重复次数">设置重复次数&lt;/h3>
&lt;p>&lt;strong>设置重复次数代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>texture.repeat.set(2,3) //设置水平方向重复 2 次、垂直方向重复 3 次
&lt;/code>&lt;/pre>&lt;h3 id="设置偏移">设置偏移&lt;/h3>
&lt;p>&lt;strong>设置偏移的 1 单位 = 1 个纹理图片大小。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>设置偏移的代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>texture.offset.set(0.5,0.25) //设置纹理水平方向偏移 0.5 个纹理宽度、垂直方向偏移 0.25 个纹理高度
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>0.5 个纹理宽度也就相当于 一半的宽度偏移量&lt;/p>
&lt;p>0.25 个纹理高度也就相当于 1/4 的高度偏移量&lt;/p>
&lt;/blockquote>
&lt;h3 id="设置旋转">设置旋转&lt;/h3>
&lt;p>&lt;strong>通过修改 rotation 属性来设置旋转弧度。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>在 Three.js 中，有内置的可以将角度转变为弧度的方法&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>通过修改 center 属性来确认旋转中心点。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>纹理的中心点坐标体系，相当于传统的四象限坐标。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>中心点的 2 个原则：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>默认的旋转中心点为纹理图片的左下角，坐标为 (0,0)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>坐标的单位为 1 单位 = 1 个纹理图片对应大小&lt;/p>
&lt;blockquote>
&lt;p>例如 (0.5, 0.5) 坐标对应的是 纹理图片的中心位置&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>示例代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>texture.center.set(0.5,0.5) //将旋转中心点改为图片的正中心位置
texture.rotation = Three.MathUtils.degToRad(45) //设置纹理旋转弧度
//MathUtils.degToRad() 方法作用是将度数转化为弧度
&lt;/code>&lt;/pre>&lt;p>关于纹理，目前就先讲到这里。在以后的学习中，还会对纹理坐标以及其他几种类型的纹理进行学习。&lt;/p>
&lt;p>纹理是目前学习中遇到的内容量最大的一节。&lt;/p>
&lt;p>&lt;strong>好好加油，下一节讲解 灯光。&lt;/strong>&lt;/p></description></item><item><title>11.Three.js 基础之灯光</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/11.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/11.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/</guid><description>&lt;h1 id="11-threejs-基础之灯光">11 Three.js 基础之灯光&lt;/h1>
&lt;h2 id="灯光的种类">灯光的种类&lt;/h2>
&lt;p>在场景中添加灯光后，灯光照射在物体上产生明暗、光亮和阴影，从而让物体显得更加立体有光泽。&lt;/p>
&lt;blockquote>
&lt;p>在有些文档或教程中，会把 灯光 称呼为 光源，这只是对 light 这个单词的不同翻译而已&lt;br>
如果我在本系列文章中，有时候使用 “灯光”，有时候使用 “光源”，请勿见怪。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>向场景中添加灯光 这个行为，在传统 3D 软件制作中通常被称为 “打灯”&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>若场景中的物体由非反光材质构成，即使场景中没有任何光源，渲染后依然可以看见该物体。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>非反光材质为 MeshBasicMaterial&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>若场景中的物体由反光材质构成，假设场景中没有任何光源，渲染出的结果将是一片漆黑，什么物体都看不见。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>反光材质为 MeshPhongMaterial 等&lt;/p>
&lt;/blockquote>
&lt;h3 id="灯光的种类-1">灯光的种类&lt;/h3>
&lt;p>&lt;strong>在 Three.js 中，有 6 种基础类型的灯光，他们都继承于 Three.Light 。&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>灯光类型(都继承于 Light)&lt;/th>
&lt;th>灯光名称&lt;/th>
&lt;th>是否支持阴影&lt;/th>
&lt;th>是否作用于全局(无处不在)&lt;/th>
&lt;th>是否有照射目标&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>AmbientLight&lt;/td>
&lt;td>环境光、氛围光&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;td>无&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DirectionalLight&lt;/td>
&lt;td>平行光&lt;/td>
&lt;td>是&lt;/td>
&lt;td>否&lt;/td>
&lt;td>有&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HemisphereLight&lt;/td>
&lt;td>半球光源、户外光源&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;td>无&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PointLight&lt;/td>
&lt;td>点光源&lt;/td>
&lt;td>是&lt;/td>
&lt;td>否&lt;/td>
&lt;td>有&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RectAreaLight&lt;/td>
&lt;td>矩形面光源&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>无&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SpotLight&lt;/td>
&lt;td>聚光灯光源&lt;/td>
&lt;td>是&lt;/td>
&lt;td>否&lt;/td>
&lt;td>有&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>补充说明 1：环境光&lt;/strong>&lt;/p>
&lt;p>有个别文档或教程中，会把 HemisphereLight 也称呼为 “环境光”。&lt;br>
事实上 AmbientLight 和 HemisphereLight 的作用都是提供环境光，只是 HemisphereLight 的环境光更加真实，当然渲染所需性能也更多。&lt;/p>
&lt;p>&lt;strong>补充说明 2：是否支持阴影&lt;/strong>&lt;/p>
&lt;p>**所有的光照射到物体上后，都会产生阴影。**但 这里说的不是 &lt;strong>是否会产生阴影&lt;/strong>，而是说 &lt;strong>“是否支持阴影”&lt;/strong>。&lt;/p>
&lt;p>一共有 3 种光不支持阴影：AmbientLight、HemisphereLight、RectAreaLight&lt;/p>
&lt;p>其他种类的光，都支持阴影：DirectionalLight、PointLight、SpotLight&lt;/p>
&lt;p>关于 Three.js 中的 阴影 (LightShadown、DirectionalLightShadown、PointLightShadown、SpotLightShadown)，我们会在后面单独开辟一节来讲解。&lt;/p>
&lt;p>&lt;strong>关于“阴影”的进一步补充：&lt;/strong>&lt;/p>
&lt;p>在之前所有的示例中，当场景上有反光物体且有灯光时，物体会产生明暗，但是请注意：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>这个“物体显示出的明暗”并不是真正的“阴影”。&lt;/p>
&lt;blockquote>
&lt;p>在 Three.js 中 有真正的阴影对象，这个会在后面的 “Three.js 基础之阴影” 一文中有详细说明。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>这个“物体显示出的明暗”并不是完全符合我们日常的“光影明暗”。&lt;/p>
&lt;blockquote>
&lt;p>这是因为我们目前所有示例都使用的是“简单光照模型”，也就是说光照射在物体上后并不进行漫反射，所以渲染出的“明暗”并不完全自然合理。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>默认渲染器并不会渲染阴影、默认支持阴影的灯光也不会投射阴影，若想产生真正的阴影，还需开启阴影渲染和投射。&lt;/p>
&lt;blockquote>
&lt;p>具体如何开启，也会在后面的 “Three.js 基础之阴影” 一文中有详细说明。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>补充说明 3：是否作用域全局&lt;/strong>&lt;/p>
&lt;p>只有环境光(AmbientLight、HemisphereLight)作用于全局，其他光则照耀范围都是有限的。&lt;/p>
&lt;p>&lt;strong>补充说明 4：什么叫 “是否有照射目标？”&lt;/strong>&lt;/p>
&lt;p>答：就是这个光除了光源本身之外，还包含一个 target 属性，并且可以通过设置 target.position 的位置。对于有照射目标的灯光，在场景中不光要添加灯光本身，还可以添加 灯光照射目标。&lt;/p>
&lt;blockquote>
&lt;p>注意是 “可以添加” 灯光目标，而不是说 “必须也要添加” 灯光目标。&lt;/p>
&lt;/blockquote>
&lt;p>请注意上面表格中，关于 “是否产生阴影” 和 “是否有照射目标”，这 2 项 是完全相同的，也就是说，只有包含照射目标的光，才会产生阴影。&lt;/p>
&lt;p>&lt;strong>在 Three.js 中，有 3 种 光探针 类型的环境光。&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>灯光类型&lt;/th>
&lt;th>灯光名称&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>LightProbe&lt;/td>
&lt;td>光探针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AmbientLightProbe(继承于 LightProbe)&lt;/td>
&lt;td>环境光探针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HemisphereLightProbe(继承于 LightProbe)&lt;/td>
&lt;td>半球光探针&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>关于 光探针，是另外一套比较复杂的光的算法方式。&lt;/p>
&lt;p>根据我网上搜索到的一些信息，大概可以描述为：&lt;/p>
&lt;p>&lt;strong>传统的 环境光(AmbientLight、HemisphereLight) 渲染时需要的计算量比较大，对于渲染静止物体来说还可以，但是渲染 运动类型 的物体时所消耗的性能过高，而 光探针类型的环境光(AmbientLightProbe、HemisphereLightProbe) 则更加适合 运动类型 的物体。&lt;/strong>&lt;/p>
&lt;h3 id="光的辅助对象">光的辅助对象&lt;/h3>
&lt;p>场景中的光本身是不可见的，为了让我们方便观测光源，Three.js 提供了 光的辅助对象：DirectionalLightHelper、HemisphereLightHelper、PointLightHelper、RectAreaLightHelper、SpotLightHelper&lt;/p>
&lt;p>&lt;strong>所谓光的辅助对象，就是在渲染后出现的一些白色细线，这些白色细线指示出光源的位置、大小、以及光发射的方向。&lt;/strong>&lt;/p>
&lt;p>光的辅助对象用法非常简单，3 步骤：&lt;/p>
&lt;ol>
&lt;li>先创建 光 的实例&lt;/li>
&lt;li>将创建好的光实例作为 辅助对象构造函数的参数&lt;/li>
&lt;li>场景中添加 辅助对象即可&lt;/li>
&lt;/ol>
&lt;p>例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>//创建并设置平行光
const directionalLight = new Three.DirectionalLight(0xFFFFFF, 1)
directionalLight.position.set(0, 10, 0);
directionalLight.target.position.set(-5, 0, 0)
//将平行光添加到场景中
scene.add(directionalLight)
scene.add(directionalLight.target)
//根据平行光实例，创建对应的辅助对象，并将辅助对象添加到场景中
const directionalLightHelper = new Three.DirectionalLightHelper(directionalLight)
scene.add(directionalLightHelper)
&lt;/code>&lt;/pre>&lt;h3 id="灯光作用与特点">灯光作用与特点&lt;/h3>
&lt;p>&lt;strong>AmbientLight(环境光、氛围光)：&lt;/strong>&lt;/p>
&lt;p>通常仅作为基础光线，一般需要与其他灯光配合使用。不能产生阴影、也无需指定坐标位置，仅需设置颜色和强度。&lt;/p>
&lt;p>注意：不支持阴影&lt;/p>
&lt;p>&lt;strong>DirectionalLight(平行光)：&lt;/strong>&lt;/p>
&lt;p>最为经常使用的光源，光纤(光芒)都是平行向着一个方向发射。&lt;/p>
&lt;p>经常使用 DirectionalLight 来模拟太阳光照射到某个物体上的光照效果。&lt;/p>
&lt;p>&lt;strong>HemisphereLight(半球光源)：&lt;/strong>&lt;/p>
&lt;p>相对 ambientLight，hemisphereLight 更加真实的模拟自然光源，提供 天空 和 地面 漫反射光线。&lt;/p>
&lt;p>一共接收 3 个参数：&lt;/p>
&lt;ul>
&lt;li>第 1 个参数：天空光线颜色&lt;/li>
&lt;li>第 2 个参数：地面反射光颜色&lt;/li>
&lt;li>第 3 个参数：光的反射强度&lt;/li>
&lt;/ul>
&lt;p>注意：不支持阴影&lt;/p>
&lt;p>&lt;strong>PointLight(点光源)：&lt;/strong>&lt;/p>
&lt;p>类似生活中的灯泡，光纤(光芒)没有固定方向，朝着四周散射。&lt;/p>
&lt;p>注意：点光源对应的辅助对象 PointLightHelper 只有一个 菱形的光源形状，并没有 光 的发射线条。&lt;/p>
&lt;p>&lt;strong>RectAreaLight(矩形面光源)：&lt;/strong>&lt;/p>
&lt;p>与 DirectionalLight 模拟太阳光不同，RectAreaLight 光源形状为一个矩形，可以模拟出明亮的窗口或矩形照明光源。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>不支持阴影&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只有 MeshStandardMaterial 和 MeshPhysicalMaterial 材料才支持 RectAreaLight 光源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按照官方文档描述，场景中必须加入 RectAreaLightUniformsLib.init()&lt;/p>
&lt;blockquote>
&lt;p>目前我比较疑惑的是，经过试验发现，即使不添加 RectAreaLightUniformsLib.init()，场景依然正常渲染，似乎看不出有任何差别&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>特别说明：&lt;/strong>&lt;/p>
&lt;p>RectAreaLight 对应的 辅助对象 RectAreaLightArea 引入方式和其他 光辅助对象 引入方式不同。&lt;/p>
&lt;p>其他光辅助对象都是内置在 three 中的，使用之前无需引入，可以直接使用，例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>const directionalLightHelper = new Three.DirectionalLightHelper(directionalLight)
&lt;/code>&lt;/pre>&lt;p>但是 RectAreaLightHelper 在使用前需要引入才可以，引入代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { RectAreaLightHelper } from &amp;#39;three/examples/jsm/helpers/RectAreaLightHelper&amp;#39;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>SpotLight(聚光灯)：&lt;/strong>&lt;/p>
&lt;p>类似生活中的聚光灯效果。&lt;/p>
&lt;p>关于每个灯光的具体参数详情、属性用法，请参考官方文档：https://threejs.org/docs/index.html#api/zh/lights/Light&lt;/p>
&lt;p>接下来，我们将通过创建一个 HelloLight 的例子，直观的观察不同类型灯光的效果。&lt;/p>
&lt;blockquote>
&lt;p>这个示例中，会用到我们上节学习的 纹理 相关知识。&lt;/p>
&lt;/blockquote>
&lt;h2 id="前期准备orbitcontrols-讲解制作纹理图片">前期准备：OrbitControls 讲解、制作纹理图片&lt;/h2>
&lt;h3 id="orbitcontrols-的简介和用法">OrbitControls 的简介和用法&lt;/h3>
&lt;p>本示例中需要用到一个之前从未使用过的类：OrbitControls，先简单介绍一下这个类。&lt;/p>
&lt;ol>
&lt;li>orbit 单词的翻译为：轨道&lt;/li>
&lt;li>controls 单词的翻译为：控制权&lt;/li>
&lt;/ol>
&lt;p>OrbitControls 是鼠标镜头轨道控件，可以通过鼠标来配置镜头的运动轨道，例如 缩放、平移、旋转。也就是说在不修改场景的前提下，可以通过鼠标来改变镜头，以便查看不同角度下的场景。&lt;/p>
&lt;blockquote>
&lt;p>在手机端，不是鼠标，而是手指滑动&lt;/p>
&lt;/blockquote>
&lt;h4 id="orbitcontrols-的用法">OrbitControls 的用法&lt;/h4>
&lt;pre tabindex="0">&lt;code>const controls = new OrbitControls(camera, canvas) //创建一个实例
controls.target.set(0, 5, 0) //controls.target 为镜头的坐标系统
//controls.target.set(0, 5, 0) 的意思是：设置原点 Y 轴的坐标(以高出5米的轨道运行)
controls.update() //使控件使用新目标
&lt;/code>&lt;/pre>&lt;p>请注意，在上面代码中，OrbitControls 的构造函数中第 2 个参数为 DOM 中的 canvas 节点，实际上当添加过 OrbitControls 之后，鼠标在 canvas 上的 拖拽、鼠标滚轴滚动 等操作都会被捕捉到，并且做出相对应的镜头画面切换。&lt;/p>
&lt;p>说直白点，我们终于可以通过鼠标对 3D 场景进行不同角度，距离的切换操作了。&lt;/p>
&lt;p>&lt;strong>OrbitControls 的 change 事件：&lt;/strong>&lt;/p>
&lt;p>无论是通过 鼠标或键盘 来修改镜头轨道 都会触发 OrbitControls 的 change 事件。&lt;/p>
&lt;p>我们可以通过添加 事件监听 来捕获该事件：&lt;/p>
&lt;pre tabindex="0">&lt;code>const handleChange = () =&amp;gt; { ... }
const controls = new OrbitControls(camera, canvasRef.current)
controls.addEventListener(&amp;#39;change&amp;#39;,handleChange)
&lt;/code>&lt;/pre>&lt;p>对于目前的我们来说，是没有必要使用该事件的，在后续的 Three.js 技巧篇 中，我们才会运用到 change 事件。&lt;/p>
&lt;p>除此之外，我们还可以设置 禁止缩放、禁止旋转、禁止右键拖拽、设置可旋转角度范围等等一系列配置，具体的可查阅官方文档：https://threejs.org/docs/#examples/zh/controls/OrbitControls&lt;/p>
&lt;p>&lt;strong>特别注意：&lt;/strong>&lt;/p>
&lt;p>OrbitControls 并不是包含在 three 根目录下，而是位于 three/examples/jsm/controls/OrbitControls 中，因此引入代码为：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>提醒：在 OrbitControls.js 中，分别导出有 OrbitControls 和 MapControls，所以引入 OribitControls 是需要加 大括号 { }。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>严格意义上讲，OrbitControls 并不是 Three.js 核心包含的代码内容，OrbitControls 是将最常见的鼠标与 Three.js 场景交互内容的一个额外封装。&lt;/p>
&lt;p>由于 OrbitControls 实在是过于频繁使用，最终 Three.js 将 OrbitControls 也包含到了 Three.js 代码包中，只不过不在默认的目录中，而是在 Three.js 示例目录中。&lt;/p>
&lt;blockquote>
&lt;p>在 Three.js 早期的版本中，代码包中并未包含 OrbitControls，若想使用还需要 yarn 安装 three-orbitcontrols 这个包。只不过当后来 Three.js 包含了 OrbitControls 之后，才再也无需额外安装了。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>补充说明 2：&lt;/strong>&lt;/p>
&lt;p>原本 OrbitControl 除了鼠标拖拽可以改变场景视角，还支持键盘上的 4 个方向键来改变场景视角。&lt;/p>
&lt;p>只不过 React 对于原生 DOM 事件支持度并不高，React 更倾向于给组件添加 onKeydown 属性处理函数。&lt;/p>
&lt;blockquote>
&lt;p>本质上 组件的 onKeydown 相当于 React 的合成事件。&lt;/p>
&lt;/blockquote>
&lt;p>Three.js 的官方示例使用的是原生 html + js，是完全支持原生键盘事件的。所以 官网的示例 使用键盘方向键控制场景没有问题，但是在 React 项目中却不太容易实现。&lt;/p>
&lt;p>在 React 中如果想让 canvas 拥有键盘事件监听，需要做以下 2 处设置：&lt;/p>
&lt;ol>
&lt;li>在 useEffect 中，当第一次挂载完成，添加 canvasRef.current.fouce()，让 canvas 自动获得焦点&lt;/li>
&lt;li>在 &amp;lt;canvas /&amp;gt; 中添加 tabindex 属性，属性值为 -1、0、1 都无所谓，例如：&amp;lt;canvas tabindex={0} /&amp;gt;&lt;/li>
&lt;/ol>
&lt;p>只有满足以上 2 个条件后，canvas 才会监听到键盘事件，但是一旦 canvas 失去焦点，那么就又监听不到了。&lt;/p>
&lt;blockquote>
&lt;p>还是继续使用 鼠标拖拽 来修改查看场景视角吧&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>补充说明 3：&lt;/strong>&lt;/p>
&lt;p>事实上如果你真的需要监听 鼠标键盘方向键 ，其实最简单的办法就是把 OrbitControls 监听对象修改为 document.body 上。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const controls = new OrbitControls(camera, canvasRef.current)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ const controls = new OrbitControls(camera, document.body)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="纹理图片准备制作纹理图片-checkerpng">纹理图片准备：制作纹理图片 checker.png&lt;/h4>
&lt;p>本示例中需要用到一个类似 3D 场景地面黑白网格的纹理，因此我们需要提前准备好这个纹理图片。&lt;/p>
&lt;p>在 PhotoShop 中新建一个 宽高都为 2 像素的画布，然后：&lt;/p>
&lt;ol>
&lt;li>左上角和右下角 的那 1 像素中填充一个较黑的颜色&lt;/li>
&lt;li>右上角和左下角 的那 1 像素中填充一个较白的颜色&lt;/li>
&lt;li>将图片导出为 checker.png，并保存到 src/assets/imgs/ 目录中&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>虽然制作的纹理图片非常小，只有 2 像素 * 2 像素，但是我们可以通过设置纹理的重复，来实现渲染出比较大的 黑白网格底盘。&lt;/p>
&lt;ol>
&lt;li>设置纹理 magFilter 的属性值为 Three.NearestFilter&lt;/li>
&lt;li>设置纹理 wrapS、wrapT 属性值为 Three.RepeatWrapping&lt;/li>
&lt;li>根据 黑白网格的尺寸，计算并设置纹理 repeat 重复次数&lt;/li>
&lt;/ol>
&lt;p>以上 3 点刚好都是上一节我们讲解 纹理 时学习到的知识点。&lt;/p>
&lt;h2 id="灯光示例hellolight">灯光示例：HelloLight&lt;/h2>
&lt;p>先回顾一下 Three.js 中 10 个 光 的类型：&lt;/p>
&lt;p>光的原型(Light) + 6 种基础光(AmbientLight&amp;hellip;) + 光探针原型(LightProbe) + 2 种环境光探针(AmbientLightProbe、HemisphereLightProbe) = 1 + 6 + 1 + 2 = 10&lt;/p>
&lt;h3 id="示例目标">示例目标：&lt;/h3>
&lt;ol>
&lt;li>使用并体验 Three.js 中除 Light 和 LightProbe 之外的其他 8 种光类型&lt;/li>
&lt;li>使用并体验 光的辅助对象( XxxLightHelper)&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>环境光 AmbientLight 是没有 辅助对象的、其他光都有辅助对象&lt;/li>
&lt;li>矩形光 RectAreaLight 的辅助对象 RectAreaLightHelper 和其他光的辅助对象 引入方式不同&lt;/li>
&lt;/ol>
&lt;h3 id="代码拆分与梳理">代码拆分与梳理：&lt;/h3>
&lt;h4 id="1create-scenets创建基础场景">1、create-scene.ts：创建基础场景&lt;/h4>
&lt;p>创建 src/components/hello-light/create-scene.ts ，导出一个名为 createScene 的函数，用来专门负责创建基础的场景。&lt;/p>
&lt;p>&lt;strong>具体代码梳理：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>该场景中包含 1 个黑白网格的地面、1 个立方体、1 个球体，但是该场景不包含任何光。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>createScene 创建基础场景时接收一个参数 type，type 只能为以下 2 个值中的其中 1 种：MESH_PHONE_MATERIAL 或 MESH_STANDARD_MATERIAL&lt;/p>
&lt;/li>
&lt;li>
&lt;p>type 默认值为 MESH_PHONE_MATERIAL&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>进一步解释：&lt;/strong>&lt;/p>
&lt;p>由于 RectAreaLight 只作用在 MeshStandardMaterial 和 MeshPhysicalMaterial 材料物体上，所以我们才设置 type 这个参数。&lt;/p>
&lt;ol>
&lt;li>当使用 RectAreaLight 时，我们告知 createScene，使用 MeshStandardMaterial 材质创建 地面、立方体、球体&lt;/li>
&lt;li>当使用 其他 光时，我们告知 createScene，使用 MeshPhongMaterial 材质创建 地面、立方体、球体&lt;/li>
&lt;/ol>
&lt;h4 id="2indextsx创建渲染器镜头以及不同种类的光">2、index.tsx：创建渲染器、镜头、以及不同种类的光&lt;/h4>
&lt;p>&lt;strong>具体代码梳理：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>当 canvas DOM 初始化后，创建 渲染器、镜头、镜头交互(OrbitControls)&lt;/li>
&lt;li>创建 8 个按钮，每个按钮对应一种光&lt;/li>
&lt;li>使用 useState 创建一个变量 type，用来记录当前演示 光的类型&lt;/li>
&lt;li>点击不同按钮后，修改 当前光的类型 type 的值，从而引发 react 重新渲染&lt;/li>
&lt;li>在新一轮的渲染中，通过判断 type 类型，使用 createScene 创建一个新的场景 和 对应的 光&lt;/li>
&lt;/ol>
&lt;h4 id="3indexscss设置相关样式">3、index.scss：设置相关样式&lt;/h4>
&lt;p>&lt;strong>具体样式梳理：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>设置 canvas 对应的样式&lt;/li>
&lt;li>设置 8 个按钮对应的样式&lt;/li>
&lt;/ol>
&lt;h3 id="具体的代码">具体的代码：&lt;/h3>
&lt;h4 id="create-scenets">create-scene.ts：&lt;/h4>
&lt;pre tabindex="0">&lt;code>import * as Three from &amp;#39;three&amp;#39;
export enum MaterialType {
MESH_PHONE_MATERIAL = &amp;#39;MESH_PHONE_MATERIAL&amp;#39;,
MESH_STANDARD_MATERIAL = &amp;#39;MESH_STANDARD_MATERIAL&amp;#39;
}
const createScene: (type?: keyof typeof MaterialType) =&amp;gt; Three.Scene = (type = MaterialType.MESH_PHONE_MATERIAL) =&amp;gt; {
const scene = new Three.Scene()
const planeSize = 40
const loader = new Three.TextureLoader()
const texture = loader.load(require(&amp;#39;@/assets/imgs/checker.png&amp;#39;).default)
texture.wrapS = Three.RepeatWrapping
texture.wrapT = Three.RepeatWrapping
texture.magFilter = Three.NearestFilter
texture.repeat.set(planeSize / 2, planeSize / 2)
let planeMat: Three.Material
let cubeMat: Three.Material
let sphereMat: Three.Material
switch (type) {
case MaterialType.MESH_STANDARD_MATERIAL:
planeMat = new Three.MeshStandardMaterial({
map: texture,
side: Three.DoubleSide
})
cubeMat = new Three.MeshStandardMaterial({ color: &amp;#39;#8AC&amp;#39; })
sphereMat = new Three.MeshStandardMaterial({ color: &amp;#39;#CA8&amp;#39; })
break
default:
planeMat = new Three.MeshPhongMaterial({
map: texture,
side: Three.DoubleSide
})
cubeMat = new Three.MeshPhongMaterial({ color: &amp;#39;#8AC&amp;#39; })
sphereMat = new Three.MeshPhongMaterial({ color: &amp;#39;#8AC&amp;#39; })
}
const planeGeo = new Three.PlaneBufferGeometry(planeSize, planeSize)
const mesh = new Three.Mesh(planeGeo, planeMat)
mesh.rotation.x = Math.PI * -0.5
scene.add(mesh)
const cubeGeo = new Three.BoxBufferGeometry(4, 4, 4)
const cubeMesh = new Three.Mesh(cubeGeo, cubeMat)
cubeMesh.position.set(5, 2.5, 0)
scene.add(cubeMesh)
const sphereGeo = new Three.SphereBufferGeometry(3, 32, 16)
const sphereMesh = new Three.Mesh(sphereGeo, sphereMat)
sphereMesh.position.set(-4, 5, 0)
scene.add(sphereMesh)
return scene
}
export default createScene
&lt;/code>&lt;/pre>&lt;h4 id="indextsx">index.tsx：&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ts" data-lang="ts">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">useEffect&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">useState&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;react&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="kr">as&lt;/span> &lt;span class="nx">Three&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;three&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">OrbitControls&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;three/examples/jsm/controls/OrbitControls&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//import { RectAreaLightUniformsLib } from &amp;#39;three/examples/jsm/lights/RectAreaLightUniformsLib&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">RectAreaLightHelper&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;three/examples/jsm/helpers/RectAreaLightHelper&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="nx">createScene&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">MaterialType&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="kr">from&lt;/span> &lt;span class="s2">&amp;#34;./create-scene&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">import&lt;/span> &lt;span class="s2">&amp;#34;./index.scss&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">enum&lt;/span> &lt;span class="nx">LightType&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">AmbientLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;AmbientLight&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">AmbientLightProbe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;AmbientLightProbe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">DirectionalLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;DirectionalLight&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">HemisphereLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;HemisphereLight&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">HemisphereLightProbe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;HemisphereLightProbe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">PointLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;PointLight&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">RectAreaLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;RectAreaLight&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">SpotLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;SpotLight&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">buttonLables&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AmbientLight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AmbientLightProbe&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DirectionalLight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HemisphereLight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HemisphereLightProbe&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PointLight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RectAreaLight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SpotLight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">HelloLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">canvasRef&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">HTMLCanvasElement&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">sceneRef&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useRef&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">Three.Scene&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="na">null&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kr">type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">setType&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">useState&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">LightType&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AmbientLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">useEffect&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">renderer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WebGLRenderer&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">canvas&lt;/span>: &lt;span class="kt">canvasRef.current&lt;/span> &lt;span class="kr">as&lt;/span> &lt;span class="nx">HTMLCanvasElement&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">camera&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PerspectiveCamera&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">45&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">camera&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">controls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">OrbitControls&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">camera&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">controls&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">controls&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">update&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">scene&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createScene&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sceneRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">scene&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">render&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">sceneRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">renderer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sceneRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">camera&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requestAnimationFrame&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requestAnimationFrame&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">render&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">handleResize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">canvas&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">canvas&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">camera&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">aspect&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientWidth&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientHeight&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">camera&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">updateProjectionMatrix&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">renderer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientWidth&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">canvas&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">clientHeight&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">handleResize&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">addEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;resize&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">handleResize&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">removeEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;resize&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">handleResize&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">useEffect&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">sceneRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sceneRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">newScene&lt;/span>: &lt;span class="kt">Three.Scene&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kr">type&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RectAreaLight&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createScene&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">MaterialType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MESH_STANDARD_MATERIAL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">createScene&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">sceneRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kr">type&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType.AmbientLight&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">const&lt;/span> &lt;span class="nx">ambientLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AmbientLight&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ambientLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType.AmbientLightProbe&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">const&lt;/span> &lt;span class="nx">ambientLightProbe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AmbientLightProbe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ambientLightProbe&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType.DirectionalLight&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">const&lt;/span> &lt;span class="nx">directionalLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DirectionalLight&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">directionalLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">directionalLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">directionalLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">directionalLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">directionalLightHelper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DirectionalLightHelper&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">directionalLight&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">directionalLightHelper&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType.HemisphereLight&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">const&lt;/span> &lt;span class="nx">hemisphereLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HemisphereLight&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mh">0xb1e1ff&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mh">0xb97a20&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">hemisphereLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">hemisphereLightHelper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HemisphereLightHelper&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hemisphereLight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">hemisphereLightHelper&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType.HemisphereLightProbe&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">const&lt;/span> &lt;span class="nx">hemisphereLightProbe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">HemisphereLightProbe&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mh">0xb1e1ff&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mh">0xb97a20&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">hemisphereLightProbe&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType.PointLight&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">const&lt;/span> &lt;span class="nx">pointLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PointLight&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pointLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pointLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">pointLightHelper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PointLightHelper&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pointLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pointLightHelper&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RectAreaLight&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//RectAreaLightUniformsLib.init() //实际测试时发现即使不添加这行代码，场景似乎也依然正常渲染，没有看出差异
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">rectAreaLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RectAreaLight&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">rectAreaLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">rectAreaLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">rotation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MathUtils&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">degToRad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">90&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rectAreaLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">rectAreaLightHelper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">RectAreaLightHelper&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rectAreaLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rectAreaLightHelper&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nx">LightType.SpotLight&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">const&lt;/span> &lt;span class="nx">spotLight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SpotLight&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0xffffff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">spotLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">spotLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">position&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kr">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spotLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spotLight&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">spotLightHelper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Three&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SpotLightHelper&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spotLight&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">newScene&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">spotLightHelper&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;???&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kr">type&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">className&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;full-screen&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">className&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;buttons&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nx">buttonLables&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">map&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">label&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">index&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">button&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">className&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">label&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="kr">type&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="s2">&amp;#34;button-selected&amp;#34;&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">onClick&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{()&lt;/span> &lt;span class="o">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">setType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">label&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">key&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="sb">`button&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">index&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="nx">label&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">button&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">canvas&lt;/span> &lt;span class="na">ref&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">canvasRef&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="p">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="nx">HelloLight&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>create-scene.ts 和 index.tsx 的代码非常多，并且我也没有写注释。&lt;br>
但是如果之前章节中的示例你也都跟着 敲一遍，应该很容易看懂 这两个文件里的代码。&lt;/p>
&lt;/blockquote>
&lt;h4 id="indexscss">index.scss：&lt;/h4>
&lt;pre tabindex="0">&lt;code>.full-screen, canvas {
display: block;
height: inherit;
width: inherit;
}
.buttons {
display: flex;
justify-content: center;
width: 100%;
position: fixed;
top: 30px;
}
.buttons button {
width: 200px;
height: 30px;
margin-left: 20px;
font-size: 18px;
cursor: pointer;
}
.buttons button:first-child {
margin-left: 0;
}
.button-selected{
background-color:green;
color: white;
}
&lt;/code>&lt;/pre>&lt;p>若一切正常，实际运行后：&lt;/p>
&lt;ol>
&lt;li>点击网页中不同顶部的按钮，可以切换不同光对应的场景效果&lt;/li>
&lt;li>点击并拖动鼠标 或 滚动鼠标滚轴，可以切换场景视角&lt;/li>
&lt;/ol>
&lt;h3 id="遗留的疑惑">遗留的疑惑&lt;/h3>
&lt;h4 id="第-1-个疑惑rectarealightuniformslib">第 1 个疑惑：RectAreaLightUniformsLib&lt;/h4>
&lt;p>按照官方文档的说法，在使用 RectAreaLight 时，必须要执行 RectAreaLightUniformsLib.init() 的，但实际试验发现不执行这行代码也没有任何问题。&lt;/p>
&lt;p>&lt;strong>为什么会这样？&lt;/strong>&lt;/p>
&lt;h4 id="第-2-个疑惑rectarealighthelper">第 2 个疑惑：RectAreaLightHelper&lt;/h4>
&lt;p>实际运行发现，RectAreaLightHelper 所展示的光源的位置和方向与实际不符。&lt;/p>
&lt;p>矩形面灯光的代码为：&lt;/p>
&lt;pre tabindex="0">&lt;code>const rectAreaLight = new Three.RectAreaLight(0xFFFFFF, 5, 12, 4)
rectAreaLight.position.set(0, 10, 0)
rectAreaLight.rotation.x = Three.MathUtils.degToRad(-90)
newScene.add(rectAreaLight)
const rectAreaLightHelper = new RectAreaLightHelper(rectAreaLight)
newScene.add(rectAreaLightHelper)
&lt;/code>&lt;/pre>&lt;p>我们对 rectAreaLight 进行了 position(位置)、rotation(旋转) 设置，&lt;strong>难道 对应的辅助对象并不会跟随同步变化？&lt;/strong>&lt;/p>
&lt;h2 id="额外的一些唠叨话">额外的一些唠叨话&lt;/h2>
&lt;p>我是一边学习 Three.js 官方教程，一边写本系列文章。&lt;/p>
&lt;p>本片文章的源头，对应的原始教程是：https://threejsfundamentals.org/threejs/lessons/threejs-lights.html&lt;/p>
&lt;p>因为之前刚好学过 场景，按照当时编写的示例代码：&lt;/p>
&lt;ol>
&lt;li>月球围绕地球&lt;/li>
&lt;li>地球围绕太阳&lt;/li>
&lt;li>太阳自转&lt;/li>
&lt;/ol>
&lt;p>我当时得出了一个结论：每一个 scene 实例都是一个相对独立的 场景空间，&lt;strong>我想当然得认为这里面的独立也包含 场景中的 光&lt;/strong>。&lt;/p>
&lt;p>所以最初我想实现 光 示例时这样的：&lt;/p>
&lt;ol>
&lt;li>一个主场景&lt;/li>
&lt;li>主场景内，2 行 3 列 分布着 6 个子场景&lt;/li>
&lt;li>这 6 个子场景里，分别包含这 6 中基础光源&lt;/li>
&lt;/ol>
&lt;p>按照这个目标，我编写了代码，结果渲染后的场景画面，&lt;strong>完全不是我预期的，实际结果是：6 个子场景上的灯光，完全混合在一起，并不是相互独立的&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>当时我完全懵的状态。&lt;/strong>&lt;/p>
&lt;p>经过 1 天的迷惑，查资料、QQ 交流群里询问其他人，直至我最终查阅了 scene.add() 函数源码，才明白过来，我那个结论是错误的。&lt;/p>
&lt;pre tabindex="0">&lt;code>sceneB.add(lightB)
sceneA.add(sceneB)
&lt;/code>&lt;/pre>&lt;p>以上代码最终真正的执行，会将 lightB 添加到 sceneA 中。&lt;/p>
&lt;p>尤其假设 lightB 光的类型为 环境光，而环境光是无处不在的，那么 lightB 会影响到所有 sceneA 中的物体。&lt;/p>
&lt;p>这也就解释了为什么 “6 个子场景上的灯光，完全混合在一起，并不是相互独立的”。&lt;/p>
&lt;p>或许你会疑惑？你说的这些不都已经在 &lt;a href="https://github.com/puxiao/threejs-tutorial/blob/main/08%20Three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF.md" target="_blank" rel="noopener">Three.js 基础之场景.md&lt;/a> 一节中讲过了，怎么又说了一遍？&lt;/p>
&lt;p>事实是我在进一步理解 场景、光 之后，又重新修改编辑了 之前章节的错误观点，所以你看到的时候都才是正确的。&lt;/p>
&lt;p>我是一边学习，一边有新的知识领悟，然后再不断回头修改、补充之前文章中的相关知识点。&lt;/p>
&lt;p>&lt;strong>我唠叨的这些目的，其实想表达 2 个事情：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>学习 Three.js 的 类、函数、方法、属性时候，最好去看一下 three.js 的源码，绝对会加深你的 Three.js 理解和功力。&lt;/li>
&lt;li>学习 Three.js 真的挺难，需要不断打破已有认知，若有些地方暂时无法理解也没关系，只要继续加油，终会搞明白的。&lt;/li>
&lt;/ol>
&lt;p>唠叨结束。&lt;/p>
&lt;p>本文学习了 光(Light)，按道理接下来应该学习 阴影(LightShadown)，但是下节我们先学习 镜头(Camera)，学完之后再回过头学习 阴影。&lt;/p>
&lt;blockquote>
&lt;p>明天是 2020 年 12 月 19 日，阿里巴巴 前端 D2 技术分享大会开幕，19 号、20 号 为期 2 天的前端技术直播会议分享。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>花 98 元买的直播观看门票，不能浪费了，所以，换换脑子，未来 2 天暂停 Three.js 的学习。&lt;/p>
&lt;/blockquote></description></item><item><title>12.Three.js 基础之镜头</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/12.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%95%9C%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/12.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%95%9C%E5%A4%B4/</guid><description>&lt;h1 id="12-threejs-基础之镜头">12 Three.js 基础之镜头&lt;/h1>
&lt;p>在之前所有的示例中，关于镜头，我们使用的都是 PerspectiveCamera(透视镜头)。&lt;/p>
&lt;blockquote>
&lt;p>再次强调一下，我个人偏好是喜欢将 Camera 称为 “镜头”，但是 Three.js 官方或其他教程中称呼其为 “相机”&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>在 Three.js 中，一共有 5 种镜头：&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>镜头类型(都继承于 Three.Camera)&lt;/th>
&lt;th>镜头名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ArrayCamera&lt;/td>
&lt;td>镜头阵列&lt;/td>
&lt;td>一组已预定义的镜头&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CubeCamera&lt;/td>
&lt;td>立方镜头&lt;/td>
&lt;td>6 个面的镜头(前、后、左、右、顶、底)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OrthographicCamera&lt;/td>
&lt;td>正交镜头&lt;/td>
&lt;td>无论物体距离镜头远近，最终渲染出的大小不变&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PerspectiveCamera&lt;/td>
&lt;td>透视镜头&lt;/td>
&lt;td>像人眼睛一样的镜头，远大近小，最常用的镜头&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>StereoCamera&lt;/td>
&lt;td>立体镜头&lt;/td>
&lt;td>双透视镜头，常用于创建 3D 立体影像或 视差屏障&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>所有镜头的辅助对象都是：Three.CameraHelper&lt;/strong>&lt;/p>
&lt;p>由于 透视镜头(PerspectiveCamera) 是日常中使用最频繁的镜头类型，因此我们先从 透视镜头 开始讲解。&lt;/p>
&lt;h2 id="镜头的一些知识">镜头的一些知识&lt;/h2>
&lt;blockquote>
&lt;p>我们通过透视镜头，来讲解一些镜头的知识&lt;br>
透视镜头(PerspectiveCamera) 所呈现出的效果，和我们用有眼睛观察世界是一模一样的。&lt;/p>
&lt;/blockquote>
&lt;h4 id="平截面">平截面&lt;/h4>
&lt;p>无论所观察的物体是什么类型，例如球体、立方体、椎体等，在我们的视野中都会形成 2 个截面：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>远截面(far)：物体最远处的截面&lt;/strong>&lt;/li>
&lt;li>&lt;strong>近截面(near)：物体最近处的截面&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>若以某个特定角度，当镜头(眼睛)观察物体时，物体远截面和近截面完全相同，那么此时近截面就会遮挡远截面，我们只能看到近截面。&lt;/p>
&lt;p>例如我们在一个立方体的正前方，此时近截面完全遮挡住远截面，此时我们观察到的立方体更像是一个平面。&lt;/p>
&lt;blockquote>
&lt;p>但是由于可能存在阴影，我们依然能够感知到这是一个 “3D 立体物体”。&lt;/p>
&lt;/blockquote>
&lt;h4 id="视椎">视椎&lt;/h4>
&lt;p>想象一下，假设把我们的镜头(眼睛) 当做一个点，由这个点依次与物体的近截面、远截面的顶点进行连接，就会形成一个 椎体，而这个虚构出来的椎体，就是我们镜头(眼睛)与物体在空间上存在的视椎。&lt;/p>
&lt;p>如果我们眼睛不是与物体，而是与 &lt;strong>“场景(Three.Scene)的近截面、远截面”&lt;/strong> 形成的视椎，就是正常 Three.js 场景中可见空间。&lt;/p>
&lt;p>请注意，上面提到的 场景的远截面和近截面 是加了引号，事实上没有办法直接设置场景的远近截面，场景的近远视椎是由镜头的以下几个参数最终计算出的：&lt;/p>
&lt;ol>
&lt;li>镜头的观察角度(fov)&lt;/li>
&lt;li>镜头画面的宽高比(aspect)&lt;/li>
&lt;li>镜头的最近可见距离(far)&lt;/li>
&lt;li>镜头的最远可见距离(near)&lt;/li>
&lt;li>一个隐含因素：镜头本身的位置(camera.position)&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>近截面和远截面决定了物体是否在镜头内可见&lt;br>
物体与镜头的距离决定物体在视觉上的大小&lt;/p>
&lt;/blockquote>
&lt;p>当我们初始化一个透视镜头时，构造函数需要传递的 4 个参数，就是上面前 4 个元素。&lt;/p>
&lt;p>&lt;strong>透视镜头默认参数值：fov=50、aspect=1、near=0.1、far=2000&lt;/strong>&lt;/p>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>在 Three.js 官方文档中对以上 4 个参数的解释是：&lt;/p>
&lt;ol>
&lt;li>fov：摄像机视椎体垂直视野角度&lt;/li>
&lt;li>aspect：摄像机视椎体长宽比(宽高比)&lt;/li>
&lt;li>near：摄像机视椎体近端面&lt;/li>
&lt;li>far：摄像机视椎体远端面&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>虽然我的描述和官方描述文字上存在差异，但意思相同。我认为我的用词更加口语化，容易理解，所以在本系列文章中，我会继续使用我的描述语言。&lt;/p>
&lt;p>因为受到自己对 Three.js 的理解程度，或许偏个人化语言描述或许是不正确的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="关于镜头近截面与远截面的补充说明计算量与性能">关于镜头近截面与远截面的补充说明：计算量与性能&lt;/h2>
&lt;p>我们知道透视镜头默认参数值：fov=50、aspect=1、near=0.1、far=2000，而我们之前文章中的示例，通常镜头设置参数为：new Three.PerspectiveCamera(45,2,0.1,1000)&lt;/p>
&lt;blockquote>
&lt;p>也就是说，近截面(镜头最近可见距离)通常设置为 0.1、远截面(镜头最远可见距离)通常为 1000&lt;/p>
&lt;/blockquote>
&lt;p>若超出这个范围内的物体或物体局部则都将不可见。&lt;/p>
&lt;h4 id="思考一下">思考一下&lt;/h4>
&lt;p>假设我们直接将 near 由 0.1 修改为 0.0001、far 由 1000 修改为 1000000，那是不是场景最近可见度更加精细、可见范围变得更大，能够承载更多的物体呢？&lt;/p>
&lt;p>答案是肯定的，但场景越大，可见度越微观，渲染所需计算量也越大。&lt;/p>
&lt;p>&lt;strong>请记得：当计算量大到一定程度后，就会出现渲染异常，画面会出现一些意外的、不符合预期结果。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>通常表现为物体表面像素紊乱、破碎、闪烁、像素前后失调，这是因为 GPU 没有足够的精度来确认哪些像素应该在前，哪些在后。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>我十分确信此刻我是在讲解 Three.js，而不是 大姨妈。&lt;/p>
&lt;/blockquote>
&lt;h4 id="解决办法并不推荐将渲染器的-logarithmicdepthbuffer-设置为-true">解决办法(并不推荐)：将渲染器的 logarithmicDepthBuffer 设置为 true&lt;/h4>
&lt;p>&lt;strong>logarighmicDepthBuffer：对数深度缓存器&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const renderer = new Three.WebGLRenderer({
canvas:xxxx,
logarithmicDepthBuffer:true
})
&lt;/code>&lt;/pre>&lt;p>&lt;strong>注意事项：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>通常电脑浏览器都已支持 logarithmicDepthBuffer 属性，但很多手机目前还不支持。&lt;/li>
&lt;li>logarithmicDepthBuffer 为 true 只是在一定程度上能够缓解问题，但若 near 足够小、far 足够大时，依然会出现 GPU 计算精度不够，造成画面渲染紊乱。&lt;/li>
&lt;/ol>
&lt;h4 id="解决办法推荐做法不解决">解决办法(推荐做法)：不解决&lt;/h4>
&lt;p>&lt;strong>请记得：你本就不应该把 near 设置过小、far 设置过大！&lt;/strong>&lt;/p>
&lt;h4 id="near-和-far-正确的设定原则">near 和 far 正确的设定原则&lt;/h4>
&lt;p>尽可能让 near 和 far 更接近镜头不远的位置，当然前提是不让任何物体超出消失的范围内。&lt;/p>
&lt;p>注意，这里的 “更接近镜头不远的位置” 是指 “合适、适当的位置”，并不是指小数点后精确多少位。&lt;/p>
&lt;p>在保证精度的前提下，尽可能设置合适的 近截面和远截面，这样让 镜头与物体产生的视椎 “更小、更接近”，以节省渲染所需计算量和性能。&lt;/p>
&lt;p>&lt;strong>举一个例子：&lt;/strong>&lt;/p>
&lt;p>假设你需要渲染出一个 足球 的特写，那么把足球放置在一个 比较小的平台或地面即可，而不是创建一个城市一样大小的场景，却只渲染出一个 足球的近距离特写。&lt;/p>
&lt;blockquote>
&lt;p>但是假设你的场景确确实实需要非常大，此时就需要多参考网上其他人是如何处理类似场景的。&lt;br>
或许后续文章中也会有讲解，此时此刻你只需知道 near 和 far 设置合适即可，没必要过于精细或巨大。&lt;/p>
&lt;/blockquote>
&lt;h2 id="镜头示例-1使用-camerahelper-来观察镜头">镜头示例 1：使用 CameraHelper 来观察镜头&lt;/h2>
&lt;p>关于 透视镜头 PerspectiveCamera 我们之前示例中已经使用多次。&lt;/p>
&lt;p>本示例主要演示 通过 镜头辅助对象(CameraHelper) 来观察镜头。&lt;/p>
&lt;h4 id="思考一下-1">思考一下：&lt;/h4>
&lt;p>在正常情况下，一个镜头只能看到别的物体但无法看到自己。&lt;/p>
&lt;p>就好像我们的眼睛可以看到这个世界，但是眼睛本身自己没法看到自己(眼睛)。&lt;/p>
&lt;blockquote>
&lt;p>当然除非对着镜子，不过对着镜子的本质依然是眼睛去看别的物体。&lt;/p>
&lt;/blockquote>
&lt;p>更加直白一点：就算你眼睛长得再大，你也做不到左眼直接看到自己右眼。&lt;/p>
&lt;blockquote>
&lt;p>我们人虽然是 2 个眼球，但是在 Three.js 的相关举例中，是将 左右两个眼睛当成 是 1 个镜头来阐述的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="hellocamera-示例目标">HelloCamera 示例目标&lt;/h3>
&lt;ol>
&lt;li>创建一个包含物体的场景&lt;/li>
&lt;li>创建 2 个镜头，镜头 A 和镜头 B&lt;/li>
&lt;li>将网页画面一分为二&lt;/li>
&lt;li>左侧显示 镜头 A 所看到的场景&lt;/li>
&lt;li>右侧使用使用 镜头 B 来观察 镜头 A&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>事实上是 镜头 B 观察并显示 镜头 A 对应的辅助对象 (CameraHelper)&lt;/li>
&lt;li>为了省事，我们直接使用前文讲解灯光时编写的 create-scene.ts 来创建场景&lt;/li>
&lt;/ol>
&lt;h3 id="代码实现思路">代码实现思路&lt;/h3>
&lt;h4 id="关键点-1同一个场景渲染出-2-个不同的画面">关键点 1：同一个场景渲染出 2 个不同的画面&lt;/h4>
&lt;p>**实现 2 个画面：**添加左右 2 个镜头，每个镜头设置不同，最终呈现出的场景不同&lt;/p>
&lt;pre tabindex="0">&lt;code>const leftCamera = new Three.PerspectiveCamera(45, 2, 5, 100)
leftCamera.position.set(0, 10, 20)
const rightCamera = new Three.PerspectiveCamera(60, 2, 0.1, 200)
rightCamera.position.set(40, 10, 30)
rightCamera.lookAt(0, 5, 0)
&lt;/code>&lt;/pre>&lt;p>**实现 2 个交互：**添加 左右 2 个 div、2 个 OrbitControls，覆盖于 canvas 之上&lt;/p>
&lt;pre tabindex="0">&lt;code>const leftControls = new OrbitControls(leftCamera, leftViewRef.current)
leftControls.target.set(0, 5, 0)
leftControls.update()
const rightControls = new OrbitControls(rightCamera, rightViewRef.current)
rightControls.target.set(0, 5, 0)
rightControls.update()
...
&amp;lt;div className=&amp;#39;full-screen&amp;#39;&amp;gt;
&amp;lt;div className=&amp;#39;split&amp;#39;&amp;gt;
&amp;lt;div ref={leftViewRef}&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div ref={rightViewRef}&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;canvas ref={canvasRef} /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code>&lt;/pre>&lt;p>**渲染 2 个画面：**使用渲染器的 裁减 功能&lt;/p>
&lt;p>渲染器裁减功能，涉及到的方法有 setScissor()、setScissorTarget()、setViewport() 。&lt;/p>
&lt;blockquote>
&lt;p>我们之前示例中，为了适应浏览器窗口大小的改变，我们使用过 渲染器的 setSize()&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null&lt;/strong>
将剪裁区域设为(x, y)到(x + width, y + height) Sets the scissor area from&lt;/p>
&lt;p>&lt;strong>setScissorTest ( boolean : Boolean ) : null&lt;/strong>
启用或禁用剪裁检测. 若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。&lt;/p>
&lt;p>&lt;strong>setViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : null&lt;/strong>
将视口大小设置为(x, y)到 (x + width, y + height)&lt;/p>
&lt;p>&lt;strong>请额外留意在后面实际代码中，我们定义的 setScissorForElement() 函数。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>多敲几遍，记住 setScissorForElement() 函数中获得裁减区域的代码套路&lt;/p>
&lt;/blockquote>
&lt;h4 id="关键点-2镜头辅助对象">关键点 2：镜头辅助对象&lt;/h4>
&lt;p>镜头辅助对象为 Three.CameraHelper，他的用法很简单：&lt;/p>
&lt;pre tabindex="0">&lt;code>const helper = new THREE.CameraHelper( leftCamera )
scene.add( helper )
&lt;/code>&lt;/pre>&lt;h4 id="关键点-3如何渲染">关键点 3：如何渲染&lt;/h4>
&lt;p>在之前所有的示例代码中，渲染代码都为：&lt;/p>
&lt;pre tabindex="0">&lt;code>renderer.render(scene, camera)
&lt;/code>&lt;/pre>&lt;p>但本示例中，我们是同一个 scene，但是 2 个不同的 camera，因此与之对应的渲染代码也要发生变化。&lt;/p>
&lt;p>需要依次分别渲染出 左侧镜头视角 和 右侧镜头视角。&lt;/p>
&lt;pre tabindex="0">&lt;code>//leftCamera一些更新操作
...
renderer.render(sceneRef.current, leftCamera)
//rightCamera一些更新操作
...
renderer.render(sceneRef.current, rightCamera)
&lt;/code>&lt;/pre>&lt;h3 id="具体的代码">具体的代码&lt;/h3>
&lt;h4 id="create-scenets">create-scene.ts&lt;/h4>
&lt;p>我们直接使用之前 &lt;strong>“11 Three.js 基础之灯光.md”&lt;/strong> 中已写好的代码。&lt;/p>
&lt;h4 id="indexscss">index.scss&lt;/h4>
&lt;pre tabindex="0">&lt;code>.full-screen,canvas {
display: block;
height: inherit;
width: inherit;
}
.split {
position: fixed;
display: flex;
width: inherit;
height: inherit;
}
.split div {
width: inherit;
height: inherit;
}
&lt;/code>&lt;/pre>&lt;h4 id="indextsx">index.tsx&lt;/h4>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import createScene from &amp;#39;@/components/hello-light/create-scene&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const HelloCamera = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const sceneRef = useRef&amp;lt;Three.Scene | null&amp;gt;(null)
const leftViewRef = useRef&amp;lt;HTMLDivElement&amp;gt;(null)
const rightViewRef = useRef&amp;lt;HTMLDivElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null || leftViewRef.current === null || rightViewRef.current === null) {
return
}
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement })
renderer.setScissorTest(true)
const scene = createScene()
scene.background = new Three.Color(0x000000)
sceneRef.current = scene
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(0, 10, 0)
light.target.position.set(5, 0, 0)
scene.add(light)
scene.add(light.target)
const leftCamera = new Three.PerspectiveCamera(45, 2, 5, 100)
leftCamera.position.set(0, 10, 20)
const helper = new Three.CameraHelper(leftCamera)
scene.add(helper)
const leftControls = new OrbitControls(leftCamera, leftViewRef.current)
leftControls.target.set(0, 5, 0)
leftControls.update()
const rightCamera = new Three.PerspectiveCamera(60, 2, 0.1, 200)
rightCamera.position.set(40, 10, 30) //为了能够看清、看全镜头，所以将右侧镜头的位置设置稍远一些
rightCamera.lookAt(0, 5, 0)
const rightControls = new OrbitControls(rightCamera, rightViewRef.current)
rightControls.target.set(0, 5, 0)
rightControls.update()
const setScissorForElement = (div: HTMLDivElement) =&amp;gt; {
if (canvasRef.current === null) {
return
}
//获得 canvas 和 div 的矩形框尺寸和位置
const canvasRect = canvasRef.current.getBoundingClientRect()
const divRect = div.getBoundingClientRect()
//计算出裁切框的尺寸和位置
const right = Math.min(divRect.right, canvasRect.right) - canvasRect.left
const left = Math.max(0, divRect.left - canvasRect.left)
const bottom = Math.min(divRect.bottom, canvasRect.bottom) - canvasRect.top
const top = Math.max(0, divRect.top - canvasRect.top)
const width = Math.min(canvasRect.width, right - left)
const height = Math.min(canvasRect.height, bottom - top)
//将剪刀设置为仅渲染到画布的该部分
const positiveYUpBottom = canvasRect.height - bottom
renderer.setScissor(left, positiveYUpBottom, width, height)
renderer.setViewport(left, positiveYUpBottom, width, height)
//返回外观
return width / height
}
const render = () =&amp;gt; {
if (leftCamera === null || rightCamera === null || sceneRef.current === null) {
return
}
const sceneBackground = sceneRef.current.background as Three.Color
//渲染 左侧 镜头
const leftAspect = setScissorForElement(leftViewRef.current as HTMLDivElement)
leftCamera.aspect = leftAspect as number
leftCamera.updateProjectionMatrix()
helper.update()
helper.visible = false
sceneBackground.set(0x000000)
renderer.render(sceneRef.current, leftCamera)
//渲染 右侧 个镜头
const rightAspect = setScissorForElement(rightViewRef.current as HTMLDivElement)
rightCamera.aspect = rightAspect as number
rightCamera.updateProjectionMatrix()
helper.visible = true
sceneBackground.set(0x000040)
renderer.render(sceneRef.current, rightCamera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) {
return
}
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;div className=&amp;#39;full-screen&amp;#39;&amp;gt;
&amp;lt;div className=&amp;#39;split&amp;#39;&amp;gt;
&amp;lt;div ref={leftViewRef}&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div ref={rightViewRef}&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;canvas ref={canvasRef} /&amp;gt;
&amp;lt;/div&amp;gt;
)
}
export default HelloCamera
&lt;/code>&lt;/pre>&lt;p>执行以后，就会看到浏览器中左右 2 个可交互的画面。其中右侧画面中包含左侧灯光辅助对象。&lt;/p>
&lt;h2 id="镜头示例-2orthographiccamera">镜头示例 2：OrthographicCamera&lt;/h2>
&lt;p>第二个比较经常用的镜头是 OrthographicCamera(正交镜头)。&lt;/p>
&lt;p>正交镜头与透视镜头最大的区别点在于：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>正交镜头的视椎体不是 椎体，而是立方体&lt;/p>
&lt;/li>
&lt;li>
&lt;p>正交镜头看到的都是一个“面”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此，正交镜头没有 “透视(近大远小)”这个概念&lt;/p>
&lt;blockquote>
&lt;p>我对于以上 2 点理解并不深，先记住以后再慢慢研究&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h4 id="orthographiccamera-的用途">OrthographicCamera 的用途&lt;/h4>
&lt;ol>
&lt;li>用途 1：作为 2D 画布&lt;/li>
&lt;li>作为 3D 建模程序 的 上、下、左、右、前、后 视图。&lt;/li>
&lt;/ol>
&lt;h4 id="orthographiccamera-基本用法">OrthographicCamera 基本用法&lt;/h4>
&lt;pre tabindex="0">&lt;code>const camera = new Three.OrthographicCamera(-1, 1, 1, -1, 5, 50)
camera.zoom = 0.2
camera.position.set(0,10,20)
&lt;/code>&lt;/pre>&lt;p>初始化时，构造函数内的参数依次是：&lt;/p>
&lt;p>OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )&lt;/p>
&lt;ol>
&lt;li>left：视椎体左侧面&lt;/li>
&lt;li>right：视椎体右侧面&lt;/li>
&lt;li>top：视椎体顶面&lt;/li>
&lt;li>bottom：视椎体底面&lt;/li>
&lt;li>near：视椎体近端面&lt;/li>
&lt;li>far：视椎体远端面&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>从实际的角度来看，一定要注意以下几点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>left 的值不能大于 right，同理 bottom 的值不能大于 top。 如果没有按照这个约定，例如 bottom 大于 top 相当于颠倒了相机。&lt;/li>
&lt;li>near 设置越小，投影的映像越大&lt;/li>
&lt;li>left 与 right 之间的距离、top 与 bottom 之间的距离的比例一定要和 canvas 比例相同，否则会导致投影的物体形状变形&lt;/li>
&lt;/ol>
&lt;h4 id="正交镜头与透视镜头的几点不同地方">正交镜头与透视镜头的几点不同地方&lt;/h4>
&lt;p>&lt;strong>渲染时，对应的设置不同。&lt;/strong>&lt;/p>
&lt;p>透视镜头渲染时，需要修改的是 camera.aspect = newAspect&lt;/p>
&lt;p>正交镜头渲染时，需要修改的是 camera.left = - new Aspect、camera.right = new Aspect&lt;/p>
&lt;h3 id="假设我们在-hellocamera-示例中使用-orthographiccamera">假设我们在 HelloCamera 示例中使用 OrthographicCamera&lt;/h3>
&lt;p>&lt;strong>需要修改的地方为：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const leftCamera = new Three.PerspectiveCamera(45, 2, 5, 100)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- leftCamera.position.set(0, 10, 20)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ const leftCamera = new Three.OrthographicCamera(-1, 1, 1, -1, 5, 50)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ leftCamera.zoom = 0.2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> leftCamera.position.set(0,10,20)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const leftAspect = setScissorForElement(leftViewRef.current as HTMLDivElement)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- leftCamera.aspect = leftAspect as number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ leftCamera.left = -(leftAspect as number)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ leftCamera.right = leftAspect as number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> leftCamera.updateProjectionMatrix()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其他代码无需修改，发布调试，即可看到正交镜头辅助对象，此时的视椎不再是椎体，而是一个立方体。&lt;/p>
&lt;p>关于其他镜头：ArrayCamera、CubeCamera、StereoCamera 本文不再讲解，以后用到的时候再深入研究。&lt;/p>
&lt;p>具体的用法，可查阅：https://threejs.org/docs/index.html#api/zh/cameras/Camera&lt;/p>
&lt;p>至此，关于镜头的基础知识讲解完毕。&lt;/p>
&lt;blockquote>
&lt;p>虽然本文是在讲镜头，但本文的核心知识点却是在讲 渲染器的裁切 功能。&lt;/p>
&lt;p>一定要多多复习，熟练掌握 渲染器的 setScissor()、setScissorTest()、setViewport() 方法。&lt;/p>
&lt;/blockquote>
&lt;p>下一节，我们将讲解 Shardown(阴影)&lt;/p></description></item><item><title>13.Three.js 基础之阴影</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/13.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%B4%E5%BD%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/13.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%B4%E5%BD%B1/</guid><description>&lt;h1 id="13-threejs-基础之阴影">13 Three.js 基础之阴影&lt;/h1>
&lt;h2 id="阴影shadow概述">阴影(Shadow)概述&lt;/h2>
&lt;h4 id="lightshadow">LightShadow&lt;/h4>
&lt;p>在 Three.js 中，所有阴影的基类都是 Three.LightShadow。&lt;/p>
&lt;p>请注意：不能直接去实例化 LightShadow，平时真正去创建的阴影，都是该类的之类。&lt;/p>
&lt;h4 id="阴影类型">阴影类型&lt;/h4>
&lt;p>目前，一共有 3 种阴影，通过名字基本都可以猜出对应的灯光的类型。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>阴影类型(都继承于 LightShadow)&lt;/th>
&lt;th>阴影名称&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>PointLightShadow&lt;/td>
&lt;td>点光源阴影&lt;/td>
&lt;td>对应 PointLight 光源&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DirectionalLightShadow&lt;/td>
&lt;td>平行光阴影&lt;/td>
&lt;td>对应 DirectionalLight 光源&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SpotLightShadow&lt;/td>
&lt;td>聚光灯阴影&lt;/td>
&lt;td>对应 SpootLight 光源&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>注意：DirectionalLightShadow 只能使用 OrthographicCamera 镜头来计算阴影，无法在 PerspectiveCamera 镜头下使用。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这是因为 PerspectiveCamera 的光线是平行的。&lt;/p>
&lt;/blockquote>
&lt;h4 id="特别强调你无需创建阴影实例阴影实例是由-灯光-内部创建的">特别强调：你无需创建阴影实例，阴影实例是由 灯光 内部创建的。&lt;/h4>
&lt;h4 id="阴影贴图">阴影贴图&lt;/h4>
&lt;p>默认情况下 Three.js 使用阴影贴图来绘制阴影。&lt;/p>
&lt;p>&lt;strong>何为 “阴影贴图” ？&lt;/strong>&lt;/p>
&lt;p>答：所谓 ”贴图“，你可以想象成 ”一层层窗户纸“。&lt;/p>
&lt;p>假设现在有一个窗户，你可以一层一层的粘贴不同透明度的窗户纸，每一层窗户纸都会叠加到之前的那一层，最终窗户纸所呈现的效果是所有窗户纸最终合并后一块呈现的效果。&lt;/p>
&lt;p>当然，由于阴影都是黑灰色，不存在彩色，所以上面的举例中，窗户纸都是不同透明度(明暗度)的，不需要考虑窗户纸的颜色。&lt;/p>
&lt;p>&lt;strong>阴影的实际渲染过程：&lt;/strong>&lt;/p>
&lt;p>假设目前场景下，有 5 个可产生阴影的灯光、20 个阴影对象。&lt;/p>
&lt;p>那么最终渲染出的阴影，所经历的过程如下：&lt;/p>
&lt;ol>
&lt;li>使用 第 1 个灯光 渲染出一份 20 个阴影对象&lt;/li>
&lt;li>使用 第 2 个灯光 渲染出一份 20 个阴影对象&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>使用 第 5 个灯光 渲染出一份 20 个阴影对象&lt;/li>
&lt;li>最终将 5 次渲染的阴影结果进行合并，得出最终的阴影&lt;/li>
&lt;/ol>
&lt;p>从上述渲染过程可以看出，每多一个可产生阴影的光源、阴影对象，则需要多渲染一次场景。&lt;/p>
&lt;p>&lt;strong>由此可见，阴影的渲染需要大量的计算和性能。&lt;/strong>&lt;/p>
&lt;h4 id="降低阴影所需性能的解决办法">降低阴影所需性能的解决办法&lt;/h4>
&lt;p>&lt;strong>方案 1：可以有多个灯光，但只有一个平行光可产生阴影&lt;/strong>&lt;/p>
&lt;p>&lt;strong>方案 2：使用 光照贴图 或 环境光照遮挡贴图 来预先计算离线照明的效果&lt;/strong>&lt;/p>
&lt;p>&lt;strong>方案 3：使用 假阴影，添加一个平面放到物体下方的地面上，同时赋予一个看着像阴影的纹理图片材质&lt;/strong>&lt;/p>
&lt;p>方案 1、方案 2 我们会在以后再详细讲述学习，本文先实现一下方案 3。&lt;/p>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>对于绝大多数 游戏场景 来说，人物脚下的阴影都是采用 方案 3 的策略，一般人们是可以接受这种假阴影。&lt;/p>
&lt;p>这种假阴影对渲染性能的提升非常大。&lt;/p>
&lt;h2 id="假阴影示例hellofakeshadow">假阴影示例：HelloFakeShadow&lt;/h2>
&lt;h4 id="示例目标">示例目标：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>一个类似黑白棋盘一样的地面(之前示例已经使用多次)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在这个平台上面有 15 个跳动的小球&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个小球颜色均不同&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个小球在一定范围内循环、且有规律的跳动&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个小球都有自己的在地面上的阴影&lt;/p>
&lt;blockquote>
&lt;p>注意这个阴影是假的阴影，并不是光照产生的，而是我们模拟出来的&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>小球阴影随着小球跳动而做出对应的位置、浓度(明暗)变化&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="代码思路">代码思路：&lt;/h4>
&lt;p>&lt;strong>1、如何创建地面？&lt;/strong>&lt;/p>
&lt;p>答：我们之前示例已经演示过，继续使用 黑白纹理图片 产生地面，不再多言。&lt;/p>
&lt;p>&lt;strong>2、如何创建 15 个颜色不同的小球？&lt;/strong>&lt;/p>
&lt;p>答：可以通过 for 循环来创建 15 个小球，在每一次 for 循环中，设置不同的小球材质颜色。&lt;/p>
&lt;p>大体代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>const numSphere = 15
for(let i = 0; i&amp;lt;numSphere; i++){
const sphereMat = new Three.MeshPhongMaterial()
sphereMat.color.setHSL(i / numSphere, 1, 0.75)
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>3、如何创建假阴影？&lt;/strong>&lt;/p>
&lt;p>答：首先创建假阴影对应的 PNG 图片，像墨水滴在水上后的样子。图片中间颜色深，越往外扩颜色越淡直至透明。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://threejsfundamentals.org/threejs/resources/images/roundshadow.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>意外不意外，本文终于有一张配图了^_^&lt;/p>
&lt;/blockquote>
&lt;p>我们通过 纹理加载器，加载这张图片作为阴影的纹理，然后创建一个 Three.PlaneBufferGeometry 几何体，通过创建网格让几何体和材质最终变成阴影物体网格。&lt;/p>
&lt;p>特别提醒：&lt;/p>
&lt;ol>
&lt;li>在小球几何体的构造参数中，我们需要设定 &lt;code>transparent: true&lt;/code>，启用透明度，否则渲染出的阴影为一个整体的黑块。&lt;/li>
&lt;li>同时设定 &lt;code>depthWrite: false&lt;/code>，以降低阴影渲染的精确度，让阴影更加模糊平滑。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>4、如何让某个小球和它的阴影为一个整体？&lt;/strong>&lt;/p>
&lt;p>答：创建一个 Three.Object3D 的对象，将 小球 和 阴影 都添加进去，让他们形成一个整体。在内部设置阴影的 position.y = 0.001，让阴影看上去更加贴近地面，同时设置小球的 position 为 其他值，让小球和阴影在 y 轴上保持一定的距离。&lt;/p>
&lt;p>&lt;strong>5、如何让小球循环、且有规律的跳动？&lt;/strong>&lt;/p>
&lt;p>答：这个牵扯一些具体的数学算法，参见后面示例中贴出来的具体代码吧。&lt;/p>
&lt;p>&lt;strong>6、如何让阴影随着小球跳动高度而发生对应的变化？&lt;/strong>&lt;/p>
&lt;p>答：每次更新小球 y 轴的值时，根据一定比例，修改 阴影对应的透明度，以此来从视觉上感受到阴影的变化。&lt;/p>
&lt;p>请注意：并没有更改阴影的尺寸大小，而仅仅更改阴影的透明度来模拟阴影的明暗变化。&lt;/p>
&lt;p>&lt;strong>7、阴影和小球讲清楚了，那灯光呢？&lt;/strong>&lt;/p>
&lt;p>答：为了让整个场景能够有光，我们需要添加 1 个半球环境光源。&lt;/p>
&lt;p>为了个小球看上去有光泽感，我们需要添加 1 个平行光，负责照射在小球上。&lt;/p>
&lt;p>也就是说，场景中，我们一共要添加 2 个光源。&lt;/p>
&lt;p>&lt;strong>关键点补充：&lt;/strong>&lt;/p>
&lt;p>我们需要将渲染器 WebGLRenderer 的 physicallyCorrectLights 的值设置为 true，以按照物理校正正确光照的模式来渲染场景。&lt;/p>
&lt;blockquote>
&lt;p>该值默认为 false，如果不设置该值为 true，则渲染出的小球特别亮。&lt;/p>
&lt;/blockquote>
&lt;h4 id="示例代码">示例代码&lt;/h4>
&lt;p>我们创建 src/components/hello-fake-shadow/index.tsx 文件。&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
interface SphereShadowBase {
base: Three.Object3D,
sphereMesh: Three.Mesh,
shadowMesh: Three.Mesh,
y: number
}
const HelloFakeShadow = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) {
return
}
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
renderer.physicallyCorrectLights = true
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 1000)
camera.position.set(0, 10, 20)
const scene = new Three.Scene()
scene.background = new Three.Color(0xFFFFFF)
const hemisphereLight = new Three.HemisphereLight(0xB1E1FF, 0xB97A20, 2)
scene.add(hemisphereLight)
const directionalLight = new Three.DirectionalLight(0xFFFFFF, 1)
directionalLight.position.set(0, 10, 5)
directionalLight.target.position.set(-5, 0, 0)
scene.add(directionalLight)
scene.add(directionalLight.target)
const planeSize = 40
const loader = new Three.TextureLoader()
const texture = loader.load(require(&amp;#39;@/assets/imgs/checker.png&amp;#39;).default)
texture.wrapS = Three.RepeatWrapping
texture.wrapT = Three.RepeatWrapping
texture.magFilter = Three.NearestFilter
texture.repeat.set(planeSize / 2, planeSize / 2)
const planeMaterial = new Three.MeshBasicMaterial({
map: texture,
side: Three.DoubleSide
})
planeMaterial.color.setRGB(1.5, 1.5, 1.5) //在纹理图片颜色的RGB基础上，分别乘以 1.5，这样可以不修改纹理图片的前提下让纹理图片更加偏白一些
const planeGeo = new Three.PlaneBufferGeometry(planeSize, planeSize)
const mesh = new Three.Mesh(planeGeo, planeMaterial)
mesh.rotation.x = Math.PI * -0.5
scene.add(mesh)
const shadowTexture = loader.load(require(&amp;#39;@/assets/imgs/roundshadow.png&amp;#39;).default)
const basesArray: SphereShadowBase[] = [] //所有球体假阴影对应的数组
const sphereRadius = 1
const sphereGeo = new Three.SphereBufferGeometry(sphereRadius, 32, 16)
const shadowSize = 1 //假阴影的尺寸
const shadowGeo = new Three.PlaneBufferGeometry(shadowSize, shadowSize) //假阴影对应的平面几何体
const numSphere = 15 //将随机创建 15 个球体
for (let i = 0; i &amp;lt; numSphere; i++) {
const base = new Three.Object3D() //创建 球和阴影 的整体对象
scene.add(base)
const shadowMat = new Three.MeshBasicMaterial({
map: shadowTexture,
transparent: true,
depthWrite: false
})
const shadowSize = sphereRadius * 4
const shadowMesh = new Three.Mesh(shadowGeo, shadowMat)
shadowMesh.position.y = 0.001
shadowMesh.rotation.x = Math.PI * -0.5
shadowMesh.scale.set(shadowSize, shadowSize, shadowSize)
base.add(shadowMesh)
const sphereMat = new Three.MeshPhongMaterial()
sphereMat.color.setHSL(i / numSphere, 1, 0.75) //给 球 设置不同颜色
const sphereMesh = new Three.Mesh(sphereGeo, sphereMat)
sphereMesh.position.set(0, sphereRadius + 2, 0)
base.add(sphereMesh)
basesArray.push({
base,
sphereMesh,
shadowMesh,
y: sphereMesh.position.y
})
}
const controls = new OrbitControls(camera, canvasRef.current)
controls.target.set(0, 5, 0)
controls.update()
const render = (time: number) =&amp;gt; {
time *= 0.001
basesArray.forEach((item, index) =&amp;gt; {
const { base, sphereMesh, shadowMesh, y } = item
const u = index / basesArray.length
const speed = time * 0.2
const angle = speed + u * Math.PI * 2 * (index % 1 ? 1 : -1)
const radius = Math.sin(speed - index) * 10
base.position.set(Math.cos(angle)* radius,0,Math.sin(angle)* radius)
const yOff = Math.abs(Math.sin(time*2+index))
sphereMesh.position.y = y + Three.MathUtils.lerp(-2,2,yOff);
(shadowMesh.material as Three.Material).opacity = Three.MathUtils.lerp(1,0.25,yOff)
})
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) {
return
}
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloFakeShadow
&lt;/code>&lt;/pre>&lt;p>运行后，就会看到 15 个跳动且有阴影的小球。&lt;/p>
&lt;p>&lt;strong>补充一点：物体碰撞&lt;/strong>&lt;/p>
&lt;p>如果你把视角变为顶视图，你会发现这个现象：在跳动过程中若两个小球发生位置上的重叠，小球会直接融入到对方之中。&lt;/p>
&lt;p>这一点并不像我们现实中，小球会发生碰撞互相作用之类的物体现象。&lt;/p>
&lt;p>&lt;strong>Three.js 默认并不包含物体碰撞物理殷勤。&lt;/strong>&lt;/p>
&lt;p>若你真的需要在 Three.js 中需要物体之间的碰撞，那么你可以引入第三方编写的 物体碰撞模块，具体如何引入我们先略过。&lt;/p>
&lt;p>你只需知道 Three.js 这个特性就好。&lt;/p>
&lt;p>&lt;strong>Three.js 侧重点时场景渲染，而不是 3D 游戏。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>事实上这是 Three.js 的一个特点，也是缺点&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>若开发 3D 游戏类，通常并不会选择 Three.js，会选择其他 3D 游戏引擎，例如：Babylon.js、PlayCanvas.js&lt;/p>
&lt;/blockquote>
&lt;h2 id="平行光阴影directionallightshadow示例helloshadow">平行光阴影(DirectionalLightShadow)示例：HelloShadow&lt;/h2>
&lt;h4 id="示例目标-1">示例目标：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>一个黑白相间的地面上，放置有 一个立方体和一个球体&lt;/p>
&lt;/li>
&lt;li>
&lt;p>场景中有一个 平行光源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>地面上显示出 立方体和球体 真正的阴影&lt;/p>
&lt;blockquote>
&lt;p>这里说的阴影是真的阴影对象，而不是“物体显示出的明暗”或“像 HelloFakeShadow 那样假的阴影”&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>为了方便我们观察，场景中需要添加：灯光的辅助对象、镜头的辅助对象、“阴影的辅助对象”&lt;/p>
&lt;blockquote>
&lt;p>请注意 “阴影的辅助对象”其实是加上了双引号，事实上并不存在阴影的辅助对象，这里的辅助对象实际上指的是 “灯光中对应的阴影镜头的辅助对象”。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h4 id="代码思路-1">代码思路：&lt;/h4>
&lt;p>&lt;strong>1、基础场景的搭建&lt;/strong>&lt;/p>
&lt;p>这个场景在之前示例中已经反复出现了，不再过多讲述。&lt;/p>
&lt;p>&lt;strong>2、阴影的相关设置有哪些？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>渲染器(WebGLRenderer)开启渲染阴影&lt;/p>
&lt;pre tabindex="0">&lt;code>renderer.shadowMap.enable = true
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>平行灯光(DirectionalLight)开启投射阴影&lt;/p>
&lt;pre tabindex="0">&lt;code>light.castShadow = true
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>地面开启 接收投影&lt;/p>
&lt;pre tabindex="0">&lt;code>planeMesh.receiveShadow = true
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>立方体和球体都开启 接收和投射阴影&lt;/p>
&lt;pre tabindex="0">&lt;code>boxMesh.castShadow = true
boxMesh.receiveShadow = true
sphereMesh.castShadow = true
sphereMesh.receiveShadow = true
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>3、阴影的辅助对象？&lt;/strong>&lt;/p>
&lt;p>灯光、镜头 的辅助对象在之前章节中，已经使用过了，那么说一下 “阴影的辅助对象”。&lt;/p>
&lt;p>首先在 Three.js 中根本不存在阴影的辅助对象，“阴影的辅助对象”其实是我个人想出来的一个词。&lt;/p>
&lt;p>这个所谓的“阴影的辅助对象”其实是 灯光中阴影的镜头对应的辅助对象。&lt;/p>
&lt;blockquote>
&lt;p>目的是为了方便我们通过灯光的辅助对象来观察灯光所能投射的阴影可见区域。&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>const shadowCamera = light.shadow.camera
const shadowHelper = new Three.CameraHelper(shadowCamera)
scene.add(shadowHelper)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>4、修改灯光中阴影的镜头属性，覆盖住所有物体，好让阴影显示完整&lt;/strong>&lt;/p>
&lt;p>如果你在编写示例时发现物体在地面上的影子显示不完整(看着影子似乎被裁切掉了一部分)，那么这种情况多数原因就是 灯光中阴影的镜头照着范围不足以覆盖物体，所以才出现了影子被裁切掉的情况。&lt;/p>
&lt;p>在本示例中，我们就需要手工修改阴影镜头视椎的可见范围，让视椎刚好可以覆盖住物体。同时我们要尽量保证视椎又不是特别大，而是刚好比较合适的大小。&lt;/p>
&lt;p>特别强调：&lt;/p>
&lt;ol>
&lt;li>平行光中影子(DirectionalLightShadow)的镜头使用的是 OrthographicCamera，不是 PerspectiveCamera&lt;/li>
&lt;li>其他 2 种阴影 PointLightShadow、SpotLightShadow 镜头默认使用的是 PerspectiveCamera。&lt;/li>
&lt;li>因此在本示例中，当我们要修改 阴影的镜头覆盖区域时修改的是 OrthographicCamera 的 left、right、top、bottom 属性。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">const shadowCamera = light.shadow.camera
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.left = -10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.right = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.top = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.bottom = -10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.updateProjectionMatrix()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">const shadowHelper = new Three.CameraHelper(shadowCamera)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scene.add(shadowHelper)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>经过修改后的视椎，实际宽 20、高 20&lt;/p>
&lt;/blockquote>
&lt;p>在本示例中我们添加的 shadowHelper 事实上就是为了方便我们观察视椎是否完全覆盖住了物体。&lt;/p>
&lt;blockquote>
&lt;p>这里我们先提出一个问题：为了省事我们是否可以直接将阴影镜头视椎的范围设置成特别大，这样就不用担心万一物体不在视椎范围里了。可以这样做吗？&lt;/p>
&lt;p>答案是：不可以！&lt;/p>
&lt;p>至于为什么，会在后面详细讲述。&lt;/p>
&lt;/blockquote>
&lt;h4 id="注意事项">注意事项：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>在 假阴影示例(HelloFakeShadow)中，我们将 地面平台使用的是不反光材质 MeshBasicMaterial，但是在本示例中，需要将地面平台设置为可反光材质 MeshPhoneMaterial。&lt;/p>
&lt;blockquote>
&lt;p>如果地面平台材质继续使用 MeshBasicMaterial，则永远显示不出阴影。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>再次强调一遍，你无需要创建 DirectionalLightShadow 实例，阴影实例是由 灯光(DirectionalLight) 内部创建的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目前我们一直采用的是 简单光照模型，所以物体的阴影是正确的，但是物体的明暗与实际生活中的效果在某些地方略微不同，说直白点就是有些地方的明暗不符合自然现象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于场景中添加了 镜头交互对象 OrbitControls，所以在每次渲染时，也要将 各个辅助对象进行更新。&lt;/p>
&lt;pre tabindex="0">&lt;code>const render = () =&amp;gt; {
cameraHelper.update()
lightHelper.update()
shadowHelper.update()
...
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h4 id="示例代码-1">示例代码：&lt;/h4>
&lt;p>示例代码位于 src/components/hello-shadow/index.stx&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const HelloShadow = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) {
return
}
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
renderer.shadowMap.enabled = true
const scene = new Three.Scene()
scene.background = new Three.Color(0x333333)
const camera = new Three.PerspectiveCamera(45, 2, 5, 100)
camera.position.set(0, 10, 20)
scene.add(camera)
const helperCamera = new Three.PerspectiveCamera(45, 2, 5, 100)
helperCamera.position.set(20, 10, 20)
helperCamera.lookAt(0, 5, 0)
scene.add(helperCamera)
const cameraHelper = new Three.CameraHelper(helperCamera)
scene.add(cameraHelper)
const controls = new OrbitControls(camera, canvasRef.current)
controls.target.set(0, 5, 0)
controls.update()
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.castShadow = true
light.position.set(0, 10, 0)
light.target.position.set(-4, 0, -4)
scene.add(light)
scene.add(light.target)
const shadowCamera = light.shadow.camera
shadowCamera.left = -10
shadowCamera.right = 10
shadowCamera.top = 10
shadowCamera.bottom = -10
shadowCamera.updateProjectionMatrix()
const lightHelper = new Three.DirectionalLightHelper(light)
scene.add(lightHelper)
const shadowHelper = new Three.CameraHelper(shadowCamera)
scene.add(shadowHelper)
const planeSize = 40
const loader = new Three.TextureLoader()
const texture = loader.load(require(&amp;#39;@/assets/imgs/checker.png&amp;#39;).default)
texture.wrapS = Three.RepeatWrapping
texture.wrapT = Three.RepeatWrapping
texture.magFilter = Three.NearestFilter
texture.repeat.set(planeSize / 2, planeSize / 2)
const planGeo = new Three.PlaneBufferGeometry(planeSize, planeSize)
const planeMat = new Three.MeshPhongMaterial({
map: texture,
side: Three.DoubleSide
})
const planeMesh = new Three.Mesh(planGeo, planeMat)
planeMesh.receiveShadow = true
planeMesh.rotation.x = Math.PI * -0.5
scene.add(planeMesh)
const material = new Three.MeshPhongMaterial({
color: 0x88AACC
})
const boxMat = new Three.BoxBufferGeometry(4, 4, 4)
const boxMesh = new Three.Mesh(boxMat, material)
boxMesh.castShadow = true
boxMesh.receiveShadow = true
boxMesh.position.set(5, 3, 0)
scene.add(boxMesh)
const sphereMat = new Three.SphereBufferGeometry(3, 32, 16)
const sphereMesh = new Three.Mesh(sphereMat, material)
sphereMesh.castShadow = true
sphereMesh.receiveShadow = true
sphereMesh.position.set(-4, 5, 0)
scene.add(sphereMesh)
const render = () =&amp;gt; {
cameraHelper.update()
lightHelper.update()
shadowHelper.update()
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) {
return
}
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloShadow
&lt;/code>&lt;/pre>&lt;p>以上代码正常运行后，这会在地面上显示出比较清晰、比较黑的物体影子。&lt;/p>
&lt;h4 id="回顾之前提出的问题为什么阴影镜头的视椎既要覆盖物体又要范围合适不要过大">回顾之前提出的问题：为什么阴影镜头的视椎既要覆盖物体，又要范围合适，不要过大？&lt;/h4>
&lt;p>先不解释为什么，我们可以先尝试将阴影镜头的视椎修改得比较大，例如扩大 10 倍，然后看会发生什么？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.left = -10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.right = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.top = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.bottom = -10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.left = -100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.right = 100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.top = 100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ shadowCamera.bottom = -100
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当阴影视椎变得比较大，此时运行，实际渲染中会发现——物体在地面上的阴影变得不够平滑、有类似马赛克的块状效果，这是为什么？&lt;/p>
&lt;p>答：默认阴影贴图尺寸(shadow mapSize) 为 512 x 512，当灯光中阴影镜头视椎范围越大，所需要对应的阴影贴图尺寸也要越大。当视椎特别大而阴影贴图尺寸并不足够大时就会产生这种块状阴影。&lt;/p>
&lt;p>当然你可以通过修改 &lt;code>light.shadow.mapSize.widht&lt;/code> 和 &lt;code>light.shadow.mapSize.height&lt;/code> 的值，将属性值调大(默认是 512)。这样看似可以解决阴影块状问题，但是当阴影贴图尺寸越大，对应渲染所需的计算和性能也就越大，这并不是我们希望的效果。&lt;/p>
&lt;p>所以，&lt;strong>最简单的方式就是不要将视椎范围调整得过大&lt;/strong>，让视椎可覆盖物体但有不是特别大，这才是我们应该做的。&lt;/p>
&lt;blockquote>
&lt;p>事实上是视椎和阴影贴图尺寸 越合适、越贴近，阴影渲染的效果越好。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>补充说明：阴影贴图尺寸最大能设置为多少？&lt;/strong>&lt;/p>
&lt;p>答：渲染器中 &lt;code>renderer.capabilities.maxTextureSize&lt;/code> 的值就是渲染器可支持的贴图最大尺寸。&lt;/p>
&lt;h4 id="如何让影子不那么黑显示得比较淡一些">如何让影子不那么黑，显示得比较淡一些？&lt;/h4>
&lt;p>我们是无法直接修改影子的明暗度，但是可以通过给场景中添加一个半球环境光，让场景整体更加亮一些，从而影子也就变得淡了一些。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">renderer.shadowMap.enabled = true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ renderer.physicallyCorrectLights = true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//添加半球环境光
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const hemisphereLight = new Three.HemisphereLight(0xFFFFFF, 0x000000, 2)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ scene.add(hemisphereLight)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="聚光灯阴影spotlightshadow示例">聚光灯阴影(SpotLightShadow)示例&lt;/h2>
&lt;p>我们将在平行光阴影示例的基础上，修改成 聚光灯阴影示例。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>为了方便我们观察聚光灯阴影，我们将不添加 半球环境光。&lt;/li>
&lt;li>聚光灯阴影对应的镜头为 PerspectiveCamera，这种镜头上我们没有必要再去修改视椎范围&lt;/li>
&lt;/ol>
&lt;p>修改后的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">renderer.shadowMap.enabled = true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- renderer.physicallyCorrectLights = true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const hemisphereLight = new Three.HemisphereLight(0xFFFFFF, 0x000000, 2)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- scene.add(hemisphereLight)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const light = new Three.DirectionalLight(0xFFFFFF, 1)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ const light = new Three.SpotLight(0xFFFFFF, 1)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>light.castShadow = true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">const shadowCamera = light.shadow.camera
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.left = -10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.right = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.top = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- shadowCamera.bottom = -10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>shadowCamera.updateProjectionMatrix()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const lightHelper = new Three.DirectionalLightHelper(light)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ const lightHelper = new Three.SpotLightHelper(light)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>scene.add(lightHelper)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="点光源阴影pointlightshadow示例">点光源阴影(PointLightShadow)示例&lt;/h2>
&lt;h4 id="点光源pointlight的特殊之处">点光源(PointLight)的特殊之处：&lt;/h4>
&lt;p>点光源是朝着四面八方发射光的，也就是说相当于朝着 上、下、左、右、前、后 6 个面都发光，这就意味着它会在这 6 个面上都产生阴影。&lt;/p>
&lt;blockquote>
&lt;p>平行光、聚光灯 他们 都只会朝着一个方向发射光，且只产生一个面上的阴影。&lt;/p>
&lt;/blockquote>
&lt;p>也就是说 点光源阴影 渲染一次(实际是渲染 6 个面的阴影)要比别的阴影类型计算量更大、渲染所需时间多。&lt;/p>
&lt;h4 id="示例的特殊改动之处">示例的特殊改动之处：&lt;/h4>
&lt;p>由于之前示例中，我们只有一个 地面，而 点光源阴影会在 6 个面中都投射阴影，所以我们需要改造我们的场景。&lt;/p>
&lt;p>向场景中添加其他几个面，以便我们看到不同面上的阴影。&lt;/p>
&lt;p>&lt;strong>如何添加 6 个面？&lt;/strong>&lt;/p>
&lt;p>答：我们只需在场景中添加一个尺寸更大一点的一个立方体，为了方便和之前的立方体做区分，我们暂且将这个立方体称呼为 room。&lt;/p>
&lt;p>我们需要做的事情是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将 room 嵌套住原本的立方体和球体&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 room 的材质的 side 设置为 Three.BackSide，这样渲染器就会渲染该物体的内部，而不是外部。&lt;/p>
&lt;blockquote>
&lt;p>由于原本的立方体、球体、点光源 均被包裹 在 room 中，所以我们就会看到 他们 在 room 内部各个面上的投影。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这里所说的 “被包裹” 其实只不是 他们(立方体、球体)尺寸比较小，且位置(立方体、球体、点光源)坐标刚好位于 room 内部而已。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h4 id="补充说明">补充说明：&lt;/h4>
&lt;p>尽管 room 是 6 个面，但是实际渲染的结果，正对着你视觉的那些面是不会被渲染出来的。&lt;/p>
&lt;blockquote>
&lt;p>视觉正对着的面，有可能是 1 个，也有可能是 2 个、3 个，这完全取决于你观察的视觉角度。&lt;/p>
&lt;/blockquote>
&lt;p>因为如果这个面也被渲染，那你实际上是看不到 room 内部的，这不是我们希望的。&lt;/p>
&lt;blockquote>
&lt;p>因为我们 room 材质里设定的是 side:Three.BackSide&lt;/p>
&lt;/blockquote>
&lt;h4 id="具体的代码">具体的代码：&lt;/h4>
&lt;p>我们将代码放置于 scr/components/hello-shadow/hello-point-light-shadow.tsx&lt;/p>
&lt;p>这次我们以 聚光灯阴影(SpotLightShadow)示例 来做修改说明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- light = new Three.DirectionalLight(0xFFFFFF, 1)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ const light = new Three.PointLight(0xFFFFFF, 1)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>light.castShadow = true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">light.position.set(0, 10, 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- light.target.position.set(-4, 0, -4)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>scene.add(light)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- scene.add(light.target)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- const lightHelper = new Three.SpotLightHelper(light)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ const lightHelper = new Three.PointLightHelper(light)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//新增 room 立方体
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const roomMat = new Three.MeshPhongMaterial({
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ color:0xCCCCCC,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ side:Three.BackSide //注意此处的设置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ })
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const roomGeo = new Three.BoxBufferGeometry(30,30,30)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const roomMesh = new Three.Mesh(roomGeo,roomMat)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ roomMesh.receiveShadow = true //作为背景墙面，只需接收阴影，无需设置 投射阴影(castShadow)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ roomMesh.position.set(0,14.9,0) //这个 y 值 14.9 是有玄机的，稍后解释
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ scene.add(roomMesh)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译运行，就可以看到 球体 在地面和某个侧面上的阴影。&lt;/p>
&lt;h4 id="注意为什么物体下方显示的阴影-是在地面planemesh而不是-roommesh-的底面">注意：为什么物体下方显示的阴影 是在地面(planeMesh)而不是 roomMesh 的底面？&lt;/h4>
&lt;p>究竟显示 地面还是 room 的底面，这个完全取决于 地面(planeMesh)、roomMesh 的相对位置，谁位置更加靠上就显示谁。&lt;/p>
&lt;p>由于 room 的高度为 30，高度的一半为 15，为了避免 地面和 room 的底面 不分高低，所以我们故意将 roomMesh 的 position.y 的值设置为 14.9。&lt;/p>
&lt;p>这样可以十分明确 地面 高于 roomMesh 的底面，所以我们看到的就是地面。&lt;/p>
&lt;p>若将上面的代码，修改为：&lt;/p>
&lt;pre tabindex="0">&lt;code>roomMesh.position.set(0,15.1,0)
&lt;/code>&lt;/pre>&lt;p>此时 roomMesh 底面在 地面 之上，所以渲染后只会看到 roomMesh 的底面，看不见地面了。&lt;/p>
&lt;p>&lt;strong>在实际的场景中，确实避免 2 个面极度紧贴，是会选择将其中一个面的位置故意设置偏低一些，保证 Three.js 能够明确区分出 哪个面谁在上谁在下。&lt;/strong>&lt;/p>
&lt;p>至此，关于阴影我们就学习到此。&lt;/p>
&lt;p>下一节学习一个特殊场景——雾，充满雾气的场景。&lt;/p></description></item><item><title>14.Three.js 基础之雾</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/14.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/14.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%BE/</guid><description>&lt;h1 id="14-threejs-基础之雾">14 Three.js 基础之雾&lt;/h1>
&lt;h2 id="雾fog概述">雾(Fog)概述&lt;/h2>
&lt;p>这里的 雾(Fog) 就是指我们日常生活中的雾气。&lt;/p>
&lt;p>我们之前所有的示例的 scene 中，都是完全清晰、透明的空间，如果想创建出有雾气的场景，就需要 雾 了。&lt;/p>
&lt;h4 id="雾的特点">雾的特点：&lt;/h4>
&lt;ol>
&lt;li>越靠近镜头 雾气越小&lt;/li>
&lt;li>越远离镜头 雾气越大&lt;/li>
&lt;li>雾气本身只会影响物体的渲染效果，但雾气本身并不会流动&lt;/li>
&lt;li>默认所有材质都可以被雾影响，若某物体不想被雾影响，可以将该物体材质的 fog 属性设置为 false&lt;/li>
&lt;/ol>
&lt;h4 id="雾的-2-种类型">雾的 2 种类型&lt;/h4>
&lt;p>在 Three.js 中，一共有 2 种 雾的类型；&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>雾的类型&lt;/th>
&lt;th>名称&lt;/th>
&lt;th>解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Fog&lt;/td>
&lt;td>雾&lt;/td>
&lt;td>雾的密度随着距离 线性增大&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FogExp2&lt;/td>
&lt;td>指数雾&lt;/td>
&lt;td>雾的密度随着距离 指数增大&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="fog-构造参数">Fog 构造参数&lt;/h4>
&lt;pre tabindex="0">&lt;code>Fog( color : Integer, near : Float, far : Float )
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>color：雾的颜色&lt;/p>
&lt;/li>
&lt;li>
&lt;p>near：开始应用雾的最小距离，默认值为 1&lt;/p>
&lt;blockquote>
&lt;p>假设 雾的 near 数值 小于 镜头 near 的值，则该区域的物体不会被雾所影响。&lt;/p>
&lt;p>因为小于镜头 near 区域的物体根本就不可见，Three.js 也不会渲染该区域。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>far：应用雾的最大距离，默认值为 1000&lt;/p>
&lt;blockquote>
&lt;p>假设 雾的 far 数值 大于 镜头 far 的值，则该区域的物体不会被雾所影响。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h4 id="fogexp2-构造参数">FogExp2 构造参数&lt;/h4>
&lt;pre tabindex="0">&lt;code>FogExp2( color : Integer, density : Float )
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>color：雾的颜色&lt;/li>
&lt;li>density：定义雾的密度将会增加的有多快，默认值为 0.00025&lt;/li>
&lt;/ol>
&lt;h4 id="如何把雾添加到场景中">如何把雾添加到场景中？&lt;/h4>
&lt;p>添加的方式非常简单：&lt;/p>
&lt;pre tabindex="0">&lt;code>scene.fog = new Three.Fog(0xFFFFFF,10,100)
或
scene.fog = new Three.FogExp2(0xFFFFFF,0.001)
&lt;/code>&lt;/pre>&lt;h4 id="究竟该选择哪种雾">究竟该选择哪种雾？&lt;/h4>
&lt;p>从实际渲染效果 真实度 而言，FogExp2 更加逼真。&lt;/p>
&lt;p>但实际项目中，往往更多选择 Fog，因为 Fog 更加简单。&lt;/p>
&lt;blockquote>
&lt;p>Fog 还允许你调整 near 和 far 的值，而 FogExp2 只允许调整指数值，若想对雾气距离更加精准控制，Fog 是第一选择。&lt;/p>
&lt;/blockquote>
&lt;h4 id="关于雾的颜色的补充说明">关于雾的颜色的补充说明&lt;/h4>
&lt;p>为了让 雾和物体、场景融合比较好，通常情况下我们会将 雾的颜色和场景的背景色 设置成相同值。&lt;/p>
&lt;p>当然如果你希望 场景背景色 和 雾气颜色不相同，完全没有问题，根据实际需求来设定就好了。&lt;/p>
&lt;h2 id="雾的示例hellofog">雾的示例：HelloFog&lt;/h2>
&lt;h4 id="示例目标">示例目标&lt;/h4>
&lt;ol>
&lt;li>场景上有 3 个不断旋转、不同颜色的立方体&lt;/li>
&lt;li>场景中添加 雾，让 3 个立方体被雾气包围&lt;/li>
&lt;/ol>
&lt;h4 id="实现思路">实现思路&lt;/h4>
&lt;p>额~，这个场景除了 雾 之外其他的实现，和我们最初刚开始学 “03 编写 HelloThreejs.md” 那篇文章一样，具体就不多说了，直接上代码。&lt;/p>
&lt;h4 id="示例代码">示例代码&lt;/h4>
&lt;p>代码位于 scr/components/hello-fog/index.tsx&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const HelloFog = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) {
return
}
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
scene.background = new Three.Color(0xadd8e6)
scene.fog = new Three.Fog(0xadd8e6, 1, 2) //向场景中添加 雾
//scene.fog = new Three.FogExp2(0xadd8e6,0.8) //向场景中添加 指数雾
const camera = new Three.PerspectiveCamera(75, 2, 0.1, 5)
camera.position.z = 2
const controls = new OrbitControls(camera, canvasRef.current)
controls.update()
const light = new Three.DirectionalLight(0XFFFFFF, 1)
light.position.set(-1, 2, 4)
scene.add(light)
const colors = [&amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;]
const boxs: Three.Mesh[] = []
colors.forEach((color, index) =&amp;gt; {
const mat = new Three.MeshPhongMaterial({ color })
const geo = new Three.BoxBufferGeometry(1, 1, 1)
const mesh = new Three.Mesh(geo, mat)
mesh.position.set((index - 1) * 2, 0, 0)
scene.add(mesh)
boxs.push(mesh)
})
const render = (time: number) =&amp;gt; {
time *= 0.001
boxs.forEach((box) =&amp;gt; {
box.rotation.x = time
box.rotation.y = time
})
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) {
return
}
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloFog
&lt;/code>&lt;/pre>&lt;h2 id="如何让材质不受雾的影响">如何让材质不受雾的影响？&lt;/h2>
&lt;p>&lt;strong>所有材质默认都会受到雾的影响和作用。&lt;/strong>&lt;/p>
&lt;p>若希望物体不受雾的影响(即使物体处于雾气当中)，那么可以将物体材质的 fog 属性设置为 false 即可。&lt;/p>
&lt;h4 id="试想一下以下场景">试想一下以下场景：&lt;/h4>
&lt;ol>
&lt;li>我们有一个房子，房子四周被雾气包围&lt;/li>
&lt;li>此时我们打开窗户，我们希望的效果是：窗外的物体继续被雾气环绕，但屋内的物体并不受雾气影响。&lt;/li>
&lt;li>为了实现这个效果，我们只需将屋内的物体材质 fog 设置为 false 即可&lt;/li>
&lt;/ol>
&lt;h4 id="举例演示">举例演示&lt;/h4>
&lt;p>我们修改 HelloFog 中的代码，我们让中间的红色立方体不受雾气影响，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">colors.forEach((color, index) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const mat = new Three.MeshPhongMaterial({ color })
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const geo = new Three.BoxBufferGeometry(1, 1, 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const mesh = new Three.Mesh(geo, mat)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mesh.position.set((index - 1) * 2, 0, 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> scene.add(mesh)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boxs.push(mesh)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> })
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const redBox = boxs[1].material as Three.Material //找到中间 红色立方体
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ redBox.fog = false //让红色立方体的材质不受雾的影响
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后，左右两侧的立方体继续受到雾气影响，若隐若现，但中间红色立方体则不受雾气任何影响。&lt;/p>
&lt;blockquote>
&lt;p>滚动鼠标中轴，调整场景上的观察视角，拉远观察距离，左右两侧立方体可能会完全消失在雾气中，但中间红色立方体不会消失，会一直处于可见状态。&lt;/p>
&lt;/blockquote>
&lt;p>至此，关于 雾 讲解完毕。&lt;/p>
&lt;p>这一节可能是最近一系列文章中，最简单的一篇了。&lt;/p>
&lt;p>下一节，讲解 离屏渲染(render target)&lt;/p></description></item><item><title>15.Three.js 基础之离屏渲染</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/15.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/15.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</guid><description>&lt;h1 id="15-threejs-基础之离屏渲染">15 Three.js 基础之离屏渲染&lt;/h1>
&lt;h2 id="render-targets离屏渲染简介">Render Targets(离屏渲染)简介&lt;/h2>
&lt;h4 id="名词解释render-targets">名词解释：Render Targets&lt;/h4>
&lt;p>&lt;strong>从字面上直接翻译，“Render Targets” 应该翻译为 “渲染目标”。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>从实际作用上翻译，”Render Targets“ 应该翻译为 ”离屏渲染目标 或 离屏渲染对象“。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>国内绝大多数 Three.js 教程都把 Render Targets 翻译为 离屏渲染。&lt;/p>
&lt;p>我个人认为翻译成：离屏渲染目标 更为合适，但有时我会不自觉使用 离线渲染对象 这个词，所以你只需要明白 虽然称呼不同，但指向的都是同一个东西。&lt;/p>
&lt;/blockquote>
&lt;h4 id="离屏渲染概念解释">离屏渲染概念解释&lt;/h4>
&lt;p>首先，我们先说一下 普通的“渲染”。&lt;/p>
&lt;p>之前示例中我们使用的渲染器都是 WebGLRenderer。我们创建的渲染器实例 renderer 会根据 场景(含场景中的物体)、灯光 来将视觉结果渲染到网页中。&lt;/p>
&lt;p>此时的 渲染 就是普通的渲染，渲染结果直接出现在网页中。&lt;/p>
&lt;p>&lt;strong>那什么又是离屏渲染？&lt;/strong>&lt;/p>
&lt;p>答：渲染器会渲染场景，但是不会吧渲染结果直接呈现在网页中，而是把渲染结果保存到 GPU 内部中。&lt;/p>
&lt;p>此时 暂存到 GPU 中的渲染结果(图片)，可以被当做一种纹理(texture)，使用到其他物体中。&lt;/p>
&lt;p>离屏渲染 和 正常渲染 整个计算过程完全相同，不同的地方在于 离屏渲染 的结果是保存在 GPU 内存中，而非直接显示在网页中。&lt;/p>
&lt;h4 id="离屏渲染的种类">离屏渲染的种类&lt;/h4>
&lt;p>在 Three.js 中，一共有 3 种离屏渲染类型。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>离屏渲染类型&lt;/th>
&lt;th>名称及解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>WebGLMultisampleRenderTarget&lt;/td>
&lt;td>WebGL 2 对应的离屏渲染&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>WebGLRenderTarget&lt;/td>
&lt;td>WebGLRender 对应的离屏渲染&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>WebGLCubeRenderTarget&lt;/td>
&lt;td>CubeCamera 对应的离屏渲染&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="离屏渲染的用途">离屏渲染的用途&lt;/h4>
&lt;p>假设有这样一个场景：场景中有 3 个不同颜色、不停转动的立方体。&lt;/p>
&lt;p>我们之前示例中会使用 WebGLRenderer ，把这个场景画面内容渲染到网页中，这属于正常的渲染。&lt;/p>
&lt;p>若我们现在改变需求，我们希望修改成：&lt;/p>
&lt;ol>
&lt;li>场景中有一面镜子&lt;/li>
&lt;li>在镜子中显示出 3 个不同颜色、不同旋转的立方体&lt;/li>
&lt;li>场景本身当中，是看不见这 3 个立方体的&lt;/li>
&lt;/ol>
&lt;p>为了实现这个需求，我们此时就需要用到 离屏渲染。&lt;/p>
&lt;p>具体做法是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建一个子场景，该子场景中 有 3 个不同颜色、不停旋转的立方体&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个总场景、一个渲染器，一面镜子&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用总场景的渲染器，对子场景进行渲染，得到一个离屏渲染结果(图像纹理)&lt;/p>
&lt;blockquote>
&lt;p>注意：由于是离屏渲染，只是将 3 个立方体渲染出的视觉效果保存到 GPU 内存中，网页中并不会显示出离屏渲染结果&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>将离屏渲染结果作为一个纹理，作用在镜子面上&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用总场景的渲染器，将镜子渲染到网页中&lt;/p>
&lt;blockquote>
&lt;p>至此，完成我们的目标。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>再试想另外一个应用场景：&lt;/strong>&lt;/p>
&lt;p>一辆汽车，汽车的倒车镜中可以显示出汽车后面的场景，这也需要用到 离线渲染。&lt;/p>
&lt;h2 id="离屏渲染示例hellorendertarget">离屏渲染示例：HelloRenderTarget&lt;/h2>
&lt;h4 id="示例目标">示例目标：&lt;/h4>
&lt;ol>
&lt;li>创建一个 “子场景”，子场景中有 光、镜头、3 个不同颜色的立方体&lt;/li>
&lt;li>创建一个 “总场景”，总场景中有 光、镜头、1 个平面圆(镜子)、1 个立方体&lt;/li>
&lt;li>在 总场景中，控制子场景中的 3 个立方体，让他们不停旋转&lt;/li>
&lt;li>通过离屏渲染，将子场景中的 “景象” 作为图片纹理，作用在镜子和立方体的 6 个面上&lt;/li>
&lt;/ol>
&lt;h4 id="代码思路">代码思路：&lt;/h4>
&lt;p>&lt;strong>场景搭建：&lt;/strong>&lt;/p>
&lt;p>子场景和总场景的创建过程，比较简单，不再过多讲述。&lt;/p>
&lt;p>由于子场景和总场景中都有 镜头、光、立方体这些，为了方便我们区分，也为了让我们代码更加简单清晰，所以我们会单独创建一个 scr/components/hello-render-target/render-target-scene.ts 的文件，用来创建子场景。&lt;/p>
&lt;blockquote>
&lt;p>注意：子场景中不需要创建渲染器&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>我们说的 总场景，其实就是 HelloRenderTarget 组件本身&lt;/p>
&lt;/blockquote>
&lt;p>子场景需要对外暴露出 场景、立方体、镜头：&lt;/p>
&lt;pre tabindex="0">&lt;code>export default {
scene,
boxs,
camera
}
&lt;/code>&lt;/pre>&lt;p>总场景获取子场景中的关键元素：&lt;/p>
&lt;pre tabindex="0">&lt;code>import * as RTScene from &amp;#39;./render-target-scene&amp;#39;
...
const rtScene = RTScene.default.scene
const rtBoxs = RTScene.default.boxs
const rtCamera = RTScene.default.camera
&lt;/code>&lt;/pre>&lt;p>&lt;strong>创建离屏渲染对象&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const rendererTarget = new Three.WebGLRenderTarget(512, 512)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意，上面代码中设置 离屏渲染对象的尺寸为 宽 512 像素、高 512 像素&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>创建材质，并将材质纹理与离屏渲染对象的渲染结果纹理进行绑定&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const material = new Three.MeshPhongMaterial({
map: rendererTarget.texture
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>由于离屏渲染对象的渲染出的纹理尺寸为 512 X 512，这样意味着我们应该将子场景中的镜头宽高比(aspect) 设置为 1&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>同样，也意味着我们将来 总场景中的 物体(镜子和立方体) 渲染的面 宽高比 也应该是 1:1。&lt;/p>
&lt;p>若物体渲染的面 宽高比不是 1:1，那么最终渲染出的面上的图片会变形。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>修改渲染器的渲染目标，让渲染器去渲染离屏渲染对象，当渲染完成后再清除(恢复)渲染器的渲染目标&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>renderer.setRenderTarget(rendererTarget)
renderer.render(rtScene, rtCamera)
renderer.setRenderTarget(null)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>虽然渲染器的渲染目标最终又被设置为 null，但是 离屏渲染的画面我们已经获得并保存在 rendererTarget 中。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>最终，在使用渲染器把镜子和立方体进行渲染输出&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>renderer.render(scene, camera)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>至此，整个代码完成&lt;/p>
&lt;/blockquote>
&lt;h4 id="示例代码">示例代码：&lt;/h4>
&lt;p>&lt;strong>子场景：&lt;/strong>&lt;/p>
&lt;p>文件位于 scr/components/hello-render-target/render-target-scene.ts&lt;/p>
&lt;pre tabindex="0">&lt;code>import * as Three from &amp;#39;three&amp;#39;
const scene = new Three.Scene()
scene.background = new Three.Color(0x00FFFF)
const camera = new Three.PerspectiveCamera(45, 1, 0.1, 10)
camera.position.z = 10
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(0, 10, 10)
scene.add(light)
const colors = [&amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;]
const boxs: Three.Mesh[] = []
colors.forEach((color, index) =&amp;gt; {
const mat = new Three.MeshPhongMaterial({ color })
const geo = new Three.BoxBufferGeometry(2, 2, 2)
const mesh = new Three.Mesh(geo, mat)
mesh.position.x = (index - 1) * 3
scene.add(mesh)
boxs.push(mesh)
})
export default {
scene,
boxs,
camera
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>总场景(HelloRenderTarget)：&lt;/strong>&lt;/p>
&lt;p>文件位于 scr/components/hello-render-target/index.tsx&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import * as RTScene from &amp;#39;./render-target-scene&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const HelloRenderTarget = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) {
return
}
const rtScene = RTScene.default.scene
const rtBoxs = RTScene.default.boxs
const rtCamera = RTScene.default.camera
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const rendererTarget = new Three.WebGLRenderTarget(512, 512)
const scene = new Three.Scene()
scene.background = new Three.Color(0x333333)
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(0, 10, 10)
light.target.position.set(-2, 2, 2)
scene.add(light)
scene.add(light.target)
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.z = 15
const controls = new OrbitControls(camera, canvasRef.current)
controls.update()
const material = new Three.MeshPhongMaterial({
map: rendererTarget.texture
})
const cubeGeo = new Three.BoxBufferGeometry(4, 4, 4)
const cubeMesh = new Three.Mesh(cubeGeo, material)
cubeMesh.position.x = 4
scene.add(cubeMesh)
const circleGeo = new Three.CircleBufferGeometry(2.8, 36)
const circleMesh = new Three.Mesh(circleGeo, material)
circleMesh.position.x = -4
scene.add(circleMesh)
const render = (time: number) =&amp;gt; {
time *= 0.001
rtBoxs.forEach((item) =&amp;gt; {
item.rotation.set(time, time, 0)
})
renderer.setRenderTarget(rendererTarget)
renderer.render(rtScene, rtCamera)
renderer.setRenderTarget(null)
cubeMesh.rotation.set(time, time, 0)
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) {
return
}
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloRenderTarget
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>补充一下：上面代码中关于灯光的位置、灯光目标的位置、镜头的位置、立方体的位置 都是我随手 填上的，并没有特别的含义，你完全可以适当修改一下。&lt;/p>
&lt;/blockquote>
&lt;p>发布运行，就会在网页中看到 镜子的 1 个面、立方体的 6 个面 上 显示着 3 个不停旋转的立方体。&lt;/p>
&lt;h4 id="补充说明-1">补充说明 1：&lt;/h4>
&lt;p>在上述示例代码中，离线渲染目标的尺寸我设置的宽高均为 512，你完全可以设置成其他比例的值。&lt;/p>
&lt;p>但是为了画面不出现变形内容，所以要遵循以下原则：&lt;/p>
&lt;p>&lt;strong>离线渲染目标的宽高比、子场景中镜头的宽高比、总场景中物体被渲染的面的宽高比，这 3 者要保持一致，这样就不会变形。&lt;/strong>&lt;/p>
&lt;p>假设你想在运行的过程中，修改 离线渲染目标的宽高、以及子场景中镜头的宽高比，其操作方式和修改普通的渲染器或镜头没有什么区别。例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>renderTarget.setSize(newWidth,newHeight)
rtCamera.aspect = newWidth/newHeight
rtCamera.updateProjectionMatrix()
&lt;/code>&lt;/pre>&lt;h4 id="补充说明-23d-绘制中的-4-大数据缓冲">补充说明 2：3D 绘制中的 4 大数据缓冲&lt;/h4>
&lt;ol>
&lt;li>颜色缓冲：&lt;/li>
&lt;li>像素缓冲：&lt;/li>
&lt;li>深度缓冲：depth buffer&lt;/li>
&lt;li>模板缓冲：stencil buffer&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>stencilBuffer 又被称为 印模缓冲&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>模板(stencil)与模板(template)的差异之处：&lt;/strong>&lt;/p>
&lt;p>单词 stencil 和 template 都可以被翻译为 模板，但是他们 2 者含义是有区别的。&lt;/p>
&lt;p>首先这 2 个单词都是来源以 印刷。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>模板(template)：形模，例如通过修剪 木板或钢板 的外形，以此外形来进行印刷&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模板(stencil)：印模，另外一种印刷技术，例如通过蜡纸来印刷&lt;/p>
&lt;blockquote>
&lt;p>你把 印模 与 形模 理解成 2 种 不同的印刷方式即可&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h4 id="保存-渲染目标对应的-图片纹理之外还会额外创建-颜色纹理-和-深度模板纹理">保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理。&lt;/h4>
&lt;p>离屏渲染目标 除了得到并保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理。&lt;/p>
&lt;blockquote>
&lt;p>图片纹理中，就使用到了 像素缓冲&lt;/p>
&lt;/blockquote>
&lt;p>像我们上面示例中根本就用不到 深度缓冲，那么我们可以在 离屏渲染目标初始化的时候，直接设置 不需要创建 深度缓冲 和 模板缓冲，以节省性能。&lt;/p>
&lt;pre tabindex="0">&lt;code>const rendererTarget = new Three.WebGLRenderTarget(512, 512,{
depthBuffer:false,
stencilBuffer:false
})
&lt;/code>&lt;/pre>&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>depthBuffer：深度缓存、默认值为 true&lt;/li>
&lt;li>stencilBuffer：模板缓冲，默认值为 false&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>关于上述 补充说明 2 、补充说明 3 中的几个缓冲，我个人理解也不够深，不够透彻，观点仅供参考。&lt;/p>
&lt;/blockquote>
&lt;p>至此，离线渲染 讲解完毕。&lt;/p>
&lt;p>今天是 2020 年最后一天，大家元旦快乐。&lt;/p>
&lt;p>元旦过后，我们将开始学习 Three.js 基础中最后 2 个知识：自定义几何体(current Geometry)、自定义缓冲几何体(current buffer geometry)&lt;/p></description></item><item><title>16.Three.js 基础之自定义几何体</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/16.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%A0%E4%BD%95%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/16.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%A0%E4%BD%95%E4%BD%93/</guid><description>&lt;h1 id="16-threejs-基础之自定义几何体">16 Three.js 基础之自定义几何体&lt;/h1>
&lt;p>&lt;strong>重要说明：本文部分内容已经过时&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>.以下内容更新于 2021 年 4 月 15 日&lt;/p>
&lt;/blockquote>
&lt;p>本文写的时候还使用的是 0.124.0 版本，但是在 0.125.2 以后（目前最新的是 0.127.0 ），关于 几何体 官方做了重大调整：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>官方已经将 Geometry 从核心库中移除，新的位置改为：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { Geometry } from &amp;#39;three/examples/jsm/deprecated/Geometry&amp;#39;
&lt;/code>&lt;/pre>&lt;p>请注意 目录名为 deprecated，这个单词的意思就是：已弃用、不建议使用。&lt;/p>
&lt;p>也就是说官方已经不再建议你使用 Geometry 这个类了，那它的替代者是谁呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 r124 版本的时候，几何体(例如 BoxGeometry) 他们都继承的是 Geometry，但是在新版本中它们继承的是 BufferGeometry。&lt;/p>
&lt;p>也就是说如果你想自定义几何体，现在应该使用的是 BufferGeometry&lt;/p>
&lt;blockquote>
&lt;p>Three.BufferGeometry&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>换句话说，就是 BufferGeometry 替代了 Geometry&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Three.Mesh() 函数中的参数也发生了变化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>或许还有其他更多地方发生了变化&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>本文在编写的时候，还采用的是 Geometry，所以本文内容过时了。&lt;/p>
&lt;p>目前先暂且不做修改，等到以后有时间了再将本文中的代码 Geometry 修改为 BufferGeometry。&lt;/p>
&lt;br>
&lt;p>你可以先跳过本章，继续后面章节的学习。&lt;/p>
&lt;blockquote>
&lt;p>以下内容更新于 2021 年 4 月 15 日&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>接下来开始本文(已过时)的内容。&lt;/p>
&lt;hr>
&lt;br>
&lt;p>本文说的 几何体(geometry)，也就是之前 “05 Three.js 基础之图元.md” 中的 图元(primitives)。&lt;/p>
&lt;blockquote>
&lt;p>图元和几何体只是同一个对象(事物)的不同的叫法而已。&lt;/p>
&lt;/blockquote>
&lt;p>自定义几何体也就相当于自定义图元。&lt;/p>
&lt;blockquote>
&lt;p>自定义几何体的这个过程，在传统 3D 软件中被称为 建模&lt;/p>
&lt;/blockquote>
&lt;h2 id="自定义几何体custom-geometry概述">自定义几何体(custom geometry)概述&lt;/h2>
&lt;p>先来一个灵魂拷问。&lt;/p>
&lt;h3 id="有必要在-threejs-中自定义几何体吗">有必要在 Three.js 中自定义几何体吗？&lt;/h3>
&lt;p>&lt;strong>答：似乎没有必要，因为实际项目中，绝大多数情况下，我们都会通过专业的 3D 软件中来创建物体模型(建模)，而不是通过 Three.js 自定义建模。&lt;/strong>&lt;/p>
&lt;p>传统专业的 3D 转件包括：&lt;/p>
&lt;ol>
&lt;li>Blender：开源免费的 3D 软件&lt;/li>
&lt;li>Maya：侧重动画渲染的 3D 软件&lt;/li>
&lt;li>Cinema4D(C4D)：轻量级的 3D 软件&lt;/li>
&lt;li>3D Sudio Max&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>以上软件中，都有学习成本，相对而言 C4D 更加轻量、更加简单。&lt;/p>
&lt;/blockquote>
&lt;p>当 3D 模型创建好后，我们将模型导出为 gLTF 或 .obj 的文件，然后在 Three.js 中加载并使用它们。&lt;/p>
&lt;p>尽管如此，但 Three.js 依然提供了自定义几何体(自定义建模)的方法。&lt;/p>
&lt;blockquote>
&lt;p>可以让我们在不导入 建模文件 的前提下，通过 Three.js 来自定义几何体。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>所有的传统 3D 软件建模过程都是可视化的，也就是说你可以时时看到物体，并且进行细微调整。而 Three.js 则是通过代码来建模的，整个建模过程是不可见的。&lt;/p>
&lt;/blockquote>
&lt;p>尽管实际中我们可能会很少机会在 Three.js 中自定义几何体，但是学习这方面的知识还是非常有必要的。&lt;/p>
&lt;h3 id="threejs-中如何自定义几何体">Three.js 中如何自定义几何体？&lt;/h3>
&lt;p>答：在 Three.js 中，一共可以有 2 种方式自定义几何体。&lt;/p>
&lt;p>&lt;strong>第 1 种：继承于 Geometry&lt;/strong>&lt;/p>
&lt;p>优点：创建和使用的难度小&lt;/p>
&lt;p>缺点：渲染启动速度慢、占更多内存&lt;/p>
&lt;p>&lt;strong>第 2 种：继承于 BufferGeometry&lt;/strong>&lt;/p>
&lt;p>优点：渲染启动速度快、占更少内存&lt;/p>
&lt;p>缺点：创建和使用的难度大&lt;/p>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>上面说的 渲染启动速度 慢，是指当场景第一次被渲染、后续修改后重新渲染的速度慢。&lt;/p>
&lt;p>并不是说 绘制速度慢。&lt;/p>
&lt;blockquote>
&lt;p>无论选择 Geometry 还是 BufferGeometry，绘制过程速度是相同的，他们的 “快慢” 主要体现在 第一次渲染启动速度 这方面。&lt;/p>
&lt;/blockquote>
&lt;p>当然，你不需花太多精力去理解 慢 的细节，你只需知道 Geometry 相对而言 渲染速度更慢一些即可。&lt;/p>
&lt;p>&lt;strong>如何选择？&lt;/strong>&lt;/p>
&lt;p>答：对于要创建的自定义几何体各个面的三角形总和小于 1000，则优先选择继承于 Geometry。三角形数量超过这个范围的则推荐继承于 BufferGeometry。&lt;/p>
&lt;p>事实上以上的选择仅供参考，重点是你实际项目中 是否觉得渲染启动速度、修改响应速度慢，如果慢则可进行优化改进。&lt;/p>
&lt;blockquote>
&lt;p>如果由于客户端硬件配置比较高，感知不到慢或卡顿，那么可以而继续使用 Geometry。&lt;/p>
&lt;/blockquote>
&lt;h2 id="自定义几何体示例hellocustomgeometry">自定义几何体示例：HelloCustomGeometry&lt;/h2>
&lt;h4 id="示例目标">示例目标&lt;/h4>
&lt;ol>
&lt;li>通过自定义几何体，来实现一个 立方体&lt;/li>
&lt;li>自定义 立方体 6 个面的颜色&lt;/li>
&lt;li>自定义 立方体 8 个顶点的颜色&lt;/li>
&lt;li>给 立方体 添加 光照法线，让立方体可以反光&lt;/li>
&lt;/ol>
&lt;h4 id="代码思路">代码思路&lt;/h4>
&lt;p>&lt;strong>如何自定义一个立方体？&lt;/strong>&lt;/p>
&lt;p>答：主要分为 3 步&lt;/p>
&lt;ol>
&lt;li>
&lt;p>第 1 步：实例化一个 Three.Geometry&lt;/p>
&lt;pre tabindex="0">&lt;code>const geometry = new Three.Geometry()
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>第 2 步：按照立方体相应的坐标，添加 8 个顶点&lt;/p>
&lt;pre tabindex="0">&lt;code>geometry.vertices.push(
new Three.Vector3(-1, -1, 1), // 1
new Three.Vector3(1, -1, 1), // 2
new Three.Vector3(-1, 1, 1), // 3
new Three.Vector3(1, 1, 1), // 4
new Three.Vector3(-1, -1, -1), // 5
new Three.Vector3(1, -1, -1), // 6
new Three.Vector3(-1, 1, -1), // 7
new Three.Vector3(1, 1, -1) // 8
)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>第 3 步：将相邻的 3 个顶点，依次按照逆时针顺序，构建成一个个三角形。&lt;/p>
&lt;blockquote>
&lt;p>立方体一共有 6 个面，每个面由 2 个三角形构成，因此一共需要构建 12 个三角形&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>为什么必须是逆时针？这是 Three.js 规定的。&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>geometry.faces.push(
//前面
new Three.Face3(0, 3, 2),
new Three.Face3(0, 1, 3),
//右面
new Three.Face3(1, 7, 3),
new Three.Face3(1, 5, 7),
//后面
new Three.Face3(5, 6, 7),
new Three.Face3(5, 4, 6),
//左面
new Three.Face3(4, 2, 6),
new Three.Face3(4, 0, 2),
//顶面
new Three.Face3(2, 7, 6),
new Three.Face3(2, 3, 7),
//底面
new Three.Face3(4, 1, 0),
new Three.Face3(4, 5, 1)
)
&lt;/code>&lt;/pre>&lt;p>至此，就以成功构建出一个立方体的基本骨架。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>如何自定义 6 个面的颜色额？&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>geometry.faces[0].color = geometry.faces[1].color = new Three.Color(&amp;#39;red&amp;#39;)
geometry.faces[2].color = geometry.faces[3].color = new Three.Color(&amp;#39;yello&amp;#39;)
geometry.faces[4].color = geometry.faces[5].color = new Three.Color(&amp;#39;green&amp;#39;)
geometry.faces[6].color = geometry.faces[7].color = new Three.Color(&amp;#39;cyan&amp;#39;)
geometry.faces[8].color = geometry.faces[9].color = new Three.Color(&amp;#39;blue&amp;#39;)
geometry.faces[10].color = geometry.faces[11].color = new Three.Color(&amp;#39;magenta&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>如何自定义 8 个顶点的颜色？&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>geometry.faces.forEach((face, index) =&amp;gt; {
face.vertexColors = [
(new Three.Color()).setHSL(index / 12, 1, 0.5),
(new Three.Color()).setHSL(index / 12 + 0.1, 1, 0.5),
(new Three.Color()).setHSL(index / 12 + 0.2, 1, 0.5)
]
})
&lt;/code>&lt;/pre>&lt;p>&lt;strong>如何开启顶点着色？&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const material = new THREE.MeshBasicMaterial({vertexColors: true})
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>const material = new Three.MeshPhongMaterial({ vertexColors: true })
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>vertexColors 默认值为 false，即默认显示材质 color 的颜色。&lt;/p>
&lt;p>如果没有给材质设置 color 值，那么默认颜色值为 白色&lt;/p>
&lt;/blockquote>
&lt;p>特别说明，在 Three.js 之前的版本中，vertexColors 的值并不是 Boolean，而是进行以下设置：&lt;/p>
&lt;pre tabindex="0">&lt;code>//export enum Colors {}
//export const NoColors: Colors;
//export const FaceColors: Colors;
//export const VertexColors: Colors;
const material = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors});
&lt;/code>&lt;/pre>&lt;p>在目前比较新的版本中，vertexColors 的值改为 Boolean 类型。&lt;/p>
&lt;p>&lt;strong>如何添加光照法线？&lt;/strong>&lt;/p>
&lt;p>答：一共有 3 种方式&lt;/p>
&lt;ol>
&lt;li>
&lt;p>给每一个 face 设置 normal 属性值&lt;/p>
&lt;pre tabindex="0">&lt;code>face.normal = new Three.Vector3(...)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>通过 vertexNormals 属性来设置&lt;/p>
&lt;pre tabindex="0">&lt;code>face.vertexNormals = {
new Three.Vector3(...),
new Three.Vector3(...),
...
new Three.Vector3(...)
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>通过 computeFaceNormals() 和 computeVertexNormals() 这 2 个方法自动帮我们计算出光照法线。&lt;/p>
&lt;p>但是对于立方体而言，只执行 computeFaceNormals() 方法即可。&lt;/p>
&lt;pre tabindex="0">&lt;code>geometry.computeFaceNormals()
//geometry.computeVertexNormals() // 这个方法并不适用于立方体
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>第 3 种 方法最为简便，也比较常用。&lt;/p>
&lt;p>本示例就采用第 3 种方式。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>补充说明：computeVertexNormals() 为什么不适用于立方体？&lt;/strong>&lt;/p>
&lt;p>答：因为 computeVertexNormals() 会从每个顶点共享的所有面的法线中计算得出法线，这样的发现会让立方体的顶点看上去更像一个球体。&lt;/p>
&lt;blockquote>
&lt;p>如果你执行了 computeVertexNormals()，并不会报错，仅仅是立方体顶点处看似更加圆润，像球一样。&lt;/p>
&lt;/blockquote>
&lt;h4 id="代码示例">代码示例：&lt;/h4>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const HelloCustomGeometry = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) {
return
}
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.z = 8
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(2, 2, 4)
scene.add(light)
const helper = new Three.DirectionalLightHelper(light)
scene.add(helper)
const controls = new OrbitControls(camera, canvasRef.current)
controls.update()
//自定义一个立方体几何体
const geometry = new Three.Geometry()
geometry.vertices.push(
new Three.Vector3(-1, -1, 1), // 1
new Three.Vector3(1, -1, 1), // 2
new Three.Vector3(-1, 1, 1), // 3
new Three.Vector3(1, 1, 1), // 4
new Three.Vector3(-1, -1, -1), // 5
new Three.Vector3(1, -1, -1), // 6
new Three.Vector3(-1, 1, -1), // 7
new Three.Vector3(1, 1, -1) // 8
)
geometry.faces.push(
//前面
new Three.Face3(0, 3, 2),
new Three.Face3(0, 1, 3),
//右面
new Three.Face3(1, 7, 3),
new Three.Face3(1, 5, 7),
//后面
new Three.Face3(5, 6, 7),
new Three.Face3(5, 4, 6),
//左面
new Three.Face3(4, 2, 6),
new Three.Face3(4, 0, 2),
//顶面
new Three.Face3(2, 7, 6),
new Three.Face3(2, 3, 7),
//底面
new Three.Face3(4, 1, 0),
new Three.Face3(4, 5, 1)
)
geometry.faces[0].color = geometry.faces[1].color = new Three.Color(&amp;#39;red&amp;#39;)
geometry.faces[2].color = geometry.faces[3].color = new Three.Color(&amp;#39;yello&amp;#39;)
geometry.faces[4].color = geometry.faces[5].color = new Three.Color(&amp;#39;green&amp;#39;)
geometry.faces[6].color = geometry.faces[7].color = new Three.Color(&amp;#39;cyan&amp;#39;)
geometry.faces[8].color = geometry.faces[9].color = new Three.Color(&amp;#39;blue&amp;#39;)
geometry.faces[10].color = geometry.faces[11].color = new Three.Color(&amp;#39;magenta&amp;#39;)
geometry.faces.forEach((face, index) =&amp;gt; {
face.vertexColors = [
(new Three.Color()).setHSL(index / 12, 1, 0.5),
(new Three.Color()).setHSL(index / 12 + 0.1, 1, 0.5),
(new Three.Color()).setHSL(index / 12 + 0.2, 1, 0.5)
]
})
geometry.computeFaceNormals()
//geometry.computeVertexNormals() //对于立方体而言，无需执行此方法
//const material = new Three.MeshBasicMaterial({ color: &amp;#39;red&amp;#39; })
const material = new Three.MeshPhongMaterial({ vertexColors: true })
//const material = new Three.MeshPhongMaterial({ color: &amp;#39;red&amp;#39; })
const cube = new Three.Mesh(geometry, material)
scene.add(cube)
const render = (time: number) =&amp;gt; {
cube.rotation.x = cube.rotation.y = time * 0.001
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) {
return
}
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloCustomGeometry
&lt;/code>&lt;/pre>&lt;p>实际运行后，就会看到一个 炫彩的立方体。&lt;/p>
&lt;h4 id="本文小结">本文小结：&lt;/h4>
&lt;p>通过自定义一个立方体的示例，可以看出，尽管是一个很简单的立方体，可我们都需要非常复杂的空间坐标计算配置，因此还是本文开头那段话：&lt;/p>
&lt;ol>
&lt;li>如非必要，不要在 Three.js 中自定义几何体。&lt;/li>
&lt;li>使用传统的 3D 软件建模，更香。&lt;/li>
&lt;/ol>
&lt;h4 id="补充说明">补充说明：&lt;/h4>
&lt;p>本系列教程，实际上是我一边学习 &lt;a href="https://threejsfundamentals.org/threejs/lessons/" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/lessons/&lt;/a> ，一边使用 React + TypeScript + 自己的语言和理解 重写一遍的。&lt;/p>
&lt;p>本文对应的英文教程为：https://threejsfundamentals.org/threejs/lessons/threejs-custom-geometry.html&lt;/p>
&lt;p>在原版的英文教程中，还有另外一个 通过一张图片来获得 纹理坐标(UV)，进而生成一张地图的例子。&lt;/p>
&lt;p>我个人感觉没有必要去这么深入学习自定义几何体，所以本文略过这个示例。&lt;/p>
&lt;p>除此之外，官方还有单独一篇，使用 BufferGeometry 来自定义几何体的教程：&lt;/p>
&lt;p>&lt;a href="https://threejsfundamentals.org/threejs/lessons/threejs-custom-buffergeometry.html" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/lessons/threejs-custom-buffergeometry.html&lt;/a>&lt;/p>
&lt;p>我认为现阶段，没有必要如此这般的深入去学习自定义几何体，因为暂停这部分的学习。&lt;/p>
&lt;blockquote>
&lt;p>如果你还有精力，可以去学习一下。&lt;/p>
&lt;/blockquote>
&lt;h2 id="threejs-基础知识总结">Three.js 基础知识总结&lt;/h2>
&lt;p>通过前面一系列的学习，我们终于将 Three.js 基础知识学习完成。&lt;/p>
&lt;p>回顾一下我们都学习了哪些知识点：&lt;/p>
&lt;ol>
&lt;li>Three.js 简介、项目初始化、入门示例&lt;/li>
&lt;li>图元、3D 文字、场景、材质、纹理、灯光、镜头、阴影、雾、离屏渲染、自定义几何体&lt;/li>
&lt;li>辅助对象(灯光辅助对象 LightHelper 、镜头辅助对象 XxxxCameraHelper、坐标轴辅助对象 AxesHelper)、镜头轨道控制类(OrbitControls)&lt;/li>
&lt;/ol>
&lt;p>真心不容易，给自己一朵小红花！&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>我们本系列教程整体的规划是：&lt;/p>
&lt;ol>
&lt;li>基础篇 (✓)&lt;/li>
&lt;li>技巧篇 (x)&lt;/li>
&lt;li>优化篇 (x)&lt;/li>
&lt;li>解决方案 (x)&lt;/li>
&lt;li>WebVR (x)&lt;/li>
&lt;li>实例篇 (x)&lt;/li>
&lt;/ol>
&lt;p>目前我们已经学习了基础篇，对 Three.js 已经有了足够的基础知识掌握，后面的学习都是建立在这些基础知识之上的。&lt;/p>
&lt;p>&lt;strong>接下来，进入技巧篇——按需渲染。&lt;/strong>&lt;/p>
&lt;h4 id="稍等再啰嗦几句">稍等，再啰嗦几句：&lt;/h4>
&lt;p>我们后续的讲解文章中，将加快进度，不再像 基础篇 这样如此细致，甚至是啰嗦。&lt;/p>
&lt;p>因此，我希望你不看教程示例代码，而是自己独立敲出示例代码。如果做不到，那么你先不要着急进入下一篇，而是应该再回过头，反复阅读，反复敲几遍代码。&lt;/p>
&lt;blockquote>
&lt;p>在做(动手敲代码)的过程中学习，而不是只看不动手。&lt;/p>
&lt;/blockquote></description></item><item><title>17.Three.js 技巧之按需渲染</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/17.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8C%89%E9%9C%80%E6%B8%B2%E6%9F%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/17.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8C%89%E9%9C%80%E6%B8%B2%E6%9F%93/</guid><description>&lt;h1 id="17-threejs-技巧之按需渲染">17 Three.js 技巧之按需渲染&lt;/h1>
&lt;p>&lt;strong>灵魂拷问：什么叫按需渲染？按哪个需？&lt;/strong>&lt;/p>
&lt;p>答：就是字面意思——需要的时候才渲染，不需要的时候不渲染。&lt;/p>
&lt;p>在 基础篇 中，我们所有的示例中，都有以下代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>const render = () =&amp;gt;{
...
renderer.render(scene,camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
&lt;/code>&lt;/pre>&lt;p>也就是意味着，无论任何时候，我们都会在每一帧上进行场景渲染。&lt;/p>
&lt;p>假设场景本身就是静止的，没有任何物体变化，此时依然进行不间断的循环渲染，其实是对客户端设备性能、电量的一种浪费。&lt;/p>
&lt;h2 id="按需渲染示例renderingondemand">按需渲染示例：RenderingOnDemand&lt;/h2>
&lt;blockquote>
&lt;p>在基础篇中，所有示例都是以 HelloXxxx 来命名 React 组件的，但是以后我们不会继续使用这种命名方式，而是会根据实际讲解内容来定义 React 组件名。&lt;/p>
&lt;/blockquote>
&lt;h4 id="只渲染一次的一个示例">只渲染一次的一个示例：&lt;/h4>
&lt;p>scr/components/rendering-on-demand/index.tsx&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const RenderingOnDemand = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
const camera = new Three.PerspectiveCamera(45, 2, 1, 100)
camera.position.z = 20
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(5, 5, 10)
scene.add(light)
const colors = [&amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;]
const cubes: Three.Mesh[] = []
colors.forEach((color, index) =&amp;gt; {
const material = new Three.MeshPhongMaterial({ color })
const geometry = new Three.BoxBufferGeometry(4, 4, 4)
const mesh = new Three.Mesh(geometry, material)
mesh.position.x = (index - 1) * 6
scene.add(mesh)
cubes.push(mesh)
})
const render = () =&amp;gt; {
renderer.render(scene, camera)
}
window.requestAnimationFrame(render)
const controls = new OrbitControls(camera, canvasRef.current)
controls.update()
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default RenderingOnDemand
&lt;/code>&lt;/pre>&lt;p>&lt;strong>请注意上面代码中的这一段：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const render = () =&amp;gt; {
renderer.render(scene, camera)
}
&lt;/code>&lt;/pre>&lt;p>以往示例中，我们还会在 render 里添加：&lt;code>window.requestAnimationFrame(render)&lt;/code> 不停的循环渲染场景。&lt;/p>
&lt;p>当我们这次没有添加这行代码后，实际运行，会得到以下结果：&lt;/p>
&lt;ol>
&lt;li>场景只在初始化时，渲染一次&lt;/li>
&lt;li>尽管添加有 OrbitControls，但是任何鼠标操作，场景并不会进行更新渲染&lt;/li>
&lt;li>尽管添加有浏览器窗口尺寸变化监听，但是浏览器只会针对 canvas 进行变形拉伸，场景并不会进行更新渲染&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>我们肯定是需要当 OrbitControl 发生改变、浏览器窗口发生改变时，重新渲染场景。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>如何实现这 2 个需求呢？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>当 OrbitControls 发生变化时，我们添加对应事件处理函数，调用 render 函数即可。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl"> const controls = new OrbitControls(camera, canvasRef.current)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ controls.addEventListener(&amp;#39;change&amp;#39;,render) //添加事件处理函数，触发重新渲染
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> controls.update()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>当浏览器窗口尺寸发生变化时，我们在 handleResize 函数中调用 render 函数即可。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">const handleResize = () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (canvasRef.current === null) { return }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const width = canvasRef.current.clientWidth
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const height = canvasRef.current.clientHeight
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> camera.aspect = width / height
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> camera.updateProjectionMatrix()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> renderer.setSize(width, height, false)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ window.requestAnimationFrame(render) //触发重新渲染
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> //注意，这里并不建议直接调用 render()，而是选择执行 window.requestAnimationFrame(render)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>就这么简单，就这么 easy 。&lt;/p>
&lt;/blockquote>
&lt;p>实际修改后的代码，调试运行后，就做到了 按需渲染。&lt;/p>
&lt;p>&lt;strong>为什么不建议直接调用 render() ？&lt;/strong>&lt;/p>
&lt;p>答：因为直接 render() 是在当前帧中执行的代码，这样可能会让浏览器 卡顿一下，而选择执行 window.requestAnimationFrame(render) 则明确告知浏览器，在下一帧中执行，确保用户体验流畅一些。&lt;/p>
&lt;h4 id="完美">完美？&lt;/h4>
&lt;p>仔细观察你会发现，当我们拖拽鼠标会触发重新渲染，鼠标拖拽和重新渲染几乎是 同时发生又同时结束的。&lt;/p>
&lt;p>停止鼠标拖拽，场景变化(渲染)戛然而止。&lt;/p>
&lt;p>你想象一下这个场景：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>你手拉着一个绳子，绳子另外一头拴在一个比较重的铁球上面，此时你拉着绳子拽着铁球前进。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假如说你突然停止脚步，那么应该发生什么？&lt;/p>
&lt;p>A、铁球和你同时停止(分秒不差)&lt;/p>
&lt;p>B、尽管你停下了脚步，但是铁球由于惯性，依然会往前移动一点点&lt;/p>
&lt;blockquote>
&lt;p>哪怕铁球特别沉，多少总会表现出往前一点点的移动的迹象的&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>我们都相信，B 选项更加符合我们日常的感知预期。&lt;/p>
&lt;p>把话题拉回到 鼠标控制轨道 上面来，事实上当我们拖拽鼠标移动停止后，不应该立即停止场景渲染，而是应该让场景继续往后渲染一点点。&lt;/p>
&lt;h4 id="如何实现惯性">如何实现&amp;quot;惯性&amp;quot;？&lt;/h4>
&lt;p>答：开启 轨道控制器的 enableDamping 属性。&lt;/p>
&lt;blockquote>
&lt;p>damping 单词的意思是 阻尼，也就是 惯性&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>controls.enableDamping = true
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>enableDamping 默认值为 false&lt;/p>
&lt;/blockquote>
&lt;p>但是，设置 enableDamping 为 true 之后，会引发新的问题。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>enableDamping 设置为 true 之后，需要继续调用 OrbitControls 实例 的 update() 函数，以便相机能够 “靠着惯性继续往前移动轨道”。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但是虽然我们已停止了鼠标拖拽，但是由于惯性，controls 会继续触发 change 事件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而 change 事件又会调用 render 函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最终演变成了一个 无限循环 的状况&lt;/p>
&lt;blockquote>
&lt;p>尽管是无限循环渲染，但是请放心，并不会因此造成客户端崩溃，因为在之前的示例中，我们本身就是不断的无限循环调用 render 函数的。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>如何解决惯性引发的无限循环渲染？&lt;/strong>&lt;/p>
&lt;p>答：我们可以添加一个 Boolean 类型的参数，用来区分出究竟是 惯性引发的渲染，还是我们主动鼠标拖拽引发的渲染。&lt;/p>
&lt;p>请注意，不要用 useState 来创建 这个 Boolean 参数，因为 useState 是异步的，并且每次执行 useState 改变 boo 的值都会引发重新渲染。&lt;/p>
&lt;p>我们采用的是在 组件外部声明 的方式来定义 boo。&lt;/p>
&lt;p>具体的做法是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ let boo = false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>const RenderingOnDemand = () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> useEffect(() =&amp;gt;{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const render = () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ boo = false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ controls.update()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> renderer.render(scene, camera)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> window.requestAnimationFrame(render)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const handleChange = () =&amp;gt; {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ if (boo === false) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ boo = true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ window.requestAnimationFrame(render)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const controls = new OrbitControls(camera, canvasRef.current)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- controls.addEventListener(&amp;#39;change&amp;#39;, render)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ controls.addEventListener(&amp;#39;change&amp;#39;, handleChange)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ controls.enableDamping = true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> controls.update()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return () =&amp;gt;{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> },[canvasRef])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于存在 “惯性”，所以会在 惯性 期间继续不断调用 controls.update()，直至惯性消失，不再触发 change 时间，此时才会停止调用 controls.update()，从而中断了 无限循环渲染。&lt;/p>
&lt;p>&lt;strong>完整的示例代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
let boo = false
const RenderingOnDemand = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
const camera = new Three.PerspectiveCamera(45, 2, 1, 100)
camera.position.z = 20
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(5, 5, 10)
scene.add(light)
const colors = [&amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;]
const cubes: Three.Mesh[] = []
colors.forEach((color, index) =&amp;gt; {
const material = new Three.MeshPhongMaterial({ color })
const geometry = new Three.BoxBufferGeometry(4, 4, 4)
const mesh = new Three.Mesh(geometry, material)
mesh.position.x = (index - 1) * 6
scene.add(mesh)
cubes.push(mesh)
})
const render = () =&amp;gt; {
boo = false
controls.update()
renderer.render(scene, camera)
}
window.requestAnimationFrame(render)
const handleChange = () =&amp;gt; {
if (boo === false) {
boo = true
window.requestAnimationFrame(render)
}
}
const controls = new OrbitControls(camera, canvasRef.current)
controls.addEventListener(&amp;#39;change&amp;#39;, handleChange)
controls.enableDamping = true
controls.update()
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
window.requestAnimationFrame(render)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default RenderingOnDemand
&lt;/code>&lt;/pre>&lt;h2 id="补充一个-orbitcontrols-的知识">补充一个 OrbitControls 的知识&lt;/h2>
&lt;p>我也就是今天才知道，原来 OrbitControls 除了鼠标可改变轨迹之外，还可以通过键盘上的 4 个方向键(上下左右)来更改视图。&lt;/p>
&lt;p>但是我在 React 中试验，发现键盘事件并不触发。于是我自己新建一个 React 组件，进一步测试：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect } from &amp;#39;react&amp;#39;
const TestKeydown = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const handleKeydown = (eve: KeyboardEvent) =&amp;gt; {
console.log(eve)
}
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
canvasRef.current.addEventListener(&amp;#39;keydown&amp;#39;, handleKeydown, false)
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} style={{ display: &amp;#39;block&amp;#39;, width: &amp;#39;100%&amp;#39;, height: &amp;#39;100%&amp;#39; }} /&amp;gt;
)
}
export default TestKeydown
&lt;/code>&lt;/pre>&lt;p>实际运行发现，确实根本不会触发键盘事件。&lt;/p>
&lt;p>后经过查阅资料，才知道对于 React 来说，更加倾向于使用 React 合成事件，例如 &amp;lt;imput onKeydown={ xxx } /&amp;gt; 而不是 通过 addEventListener(&amp;lsquo;keydown&amp;rsquo;,xxx)。&lt;/p>
&lt;p>上面的代码若想触发键盘事件，需要修改成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">import { useRef, useEffect } from &amp;#39;react&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">const TestKeydown = () =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const handleKeydown = (eve: KeyboardEvent) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> console.log(eve)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> useEffect(() =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (canvasRef.current === null) { return }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ canvasRef.current.focus()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> canvasRef.current.addEventListener(&amp;#39;keydown&amp;#39;, handleKeydown, false)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }, [canvasRef])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ &amp;lt;canvas ref={canvasRef} tabIndex={0} style={{ display: &amp;#39;block&amp;#39;, width: &amp;#39;100%&amp;#39;, height: &amp;#39;100%&amp;#39; }} /&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span> )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">export default TestKeydown
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>添加 canvas 自动获取焦点&lt;/li>
&lt;li>给 canvas 添加 tabIndex 值，该值是 -1、0、1 都可以，但是必须添加&lt;/li>
&lt;/ol>
&lt;p>但是对于 OrbitControls 来说，若想在 React 中也使用键盘事件，则只能依此修改。&lt;/p>
&lt;p>不过当 canvas 失去焦点后，则键盘事件就会失效。&lt;/p>
&lt;p>&lt;strong>Three.js 官方示例使用的是原生的 html + js，是完全支持键盘事件的。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>React 则对原生键盘事件支持度不高。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>不过我们完全不必介意这件事情，我们继续使用鼠标来控制场景变换角度好了。&lt;/p>
&lt;/blockquote>
&lt;p>下一节，我们学习如何调试 Three.js。&lt;/p></description></item><item><title>18.Three.js 技巧之调试</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/18.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%B0%83%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/18.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%B0%83%E8%AF%95/</guid><description>&lt;h1 id="18-threejs-技巧之调试">18 Three.js 技巧之调试&lt;/h1>
&lt;p>本文讲解一些 Three.js 的调试技巧，是其他程序员在开发 Three.js 过程中积累的一些找错、调试经验。&lt;/p>
&lt;blockquote>
&lt;p>其中一些调试经验适用于所有的前端项目&lt;/p>
&lt;/blockquote>
&lt;h2 id="调试的几点经验">调试的几点经验&lt;/h2>
&lt;h4 id="1使用浏览器调试">1、使用浏览器调试&lt;/h4>
&lt;p>个人推荐使用 谷歌浏览器 或 最新版的微软 Edge 浏览器 调试工具。&lt;/p>
&lt;p>以谷歌浏览器 Chrome 为例，打开调试的快捷键为：Ctrl + Shift + I&lt;/p>
&lt;blockquote>
&lt;p>个别测试时候，鼠标放在画布上点击右键不显示菜单，或者不显示 “检查”，此时使用快捷键调出调试工具最为合适。&lt;/p>
&lt;/blockquote>
&lt;h4 id="2关闭缓存">2、关闭缓存&lt;/h4>
&lt;p>对于开发阶段，为了确保所加载的各种资源是最新的，而不是缓存的，所以推荐关闭缓存。&lt;/p>
&lt;p>关闭缓存的方法：打开调试面板(Toggle Tools) &amp;gt; 网络面板(Network) &amp;gt; 勾选 禁用缓存(Disable cache)&lt;/p>
&lt;h4 id="3善用信息打印-console">3、善用信息打印 Console&lt;/h4>
&lt;p>可以通过在代码中添加 console.log(xxx)，或者直接在 Console 面板中 添加打印代码，查看当前 JS 环境中的信息变量。&lt;/p>
&lt;h4 id="4添加-debugger">4、添加 debugger&lt;/h4>
&lt;p>我们可以在代码中，添加 debugger ，给代码执行过程中添加断点，好一步步确认整个执行过程。&lt;/p>
&lt;ol>
&lt;li>直接通过 VSCoder 在某行代码左侧，添加断点(小红点)&lt;/li>
&lt;li>在代码中添加 &lt;code>debugger&lt;/code>，当代码执行到此处时即进入调试状态&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>个人推荐使用第 1 种形式添加断点&lt;/p>
&lt;/blockquote>
&lt;h4 id="5通过-url-来获取参数">5、通过 URL 来获取参数&lt;/h4>
&lt;p>假如说我们现在需要在场景上创建一个立方体，URL 参数中包含立方体对应的尺寸。&lt;/p>
&lt;p>假设 URL 参数为：&lt;/p>
&lt;pre tabindex="0">&lt;code>https://xxx.com/threejs/xxx.index?width=3&amp;amp;height=2&amp;amp;depth=1
&lt;/code>&lt;/pre>&lt;p>&lt;code>width=3&amp;amp;height=2&amp;amp;depth=1&lt;/code> 即我们需要获取并配置给立方体的参数。&lt;/p>
&lt;blockquote>
&lt;p>为了避免参数缺失或错误而导致立方体创建失败，我们给立方体的 宽、高、厚 设置一个默认值 1&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>我们可以使用浏览器新增的 URLSearchParams 来解析 URL 参数：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>interface URLParams {
width: number,
height: number,
depth: number
}
const getURLParams = (): URLParams =&amp;gt; {
const params = new URLSearchParams(window.location.search.substring(1))
const widthStr = params.get(&amp;#39;width&amp;#39;)
const heightStr = params.get(&amp;#39;height&amp;#39;)
const depthStr = params.get(&amp;#39;depth&amp;#39;)
let [width, height, depth] = [0, 0, 0]
if (widthStr) { width = parseInt(widthStr, 10) || 1 }
if (heightStr) { height = parseInt(heightStr, 10) || 1 }
if (depthStr) { depth = parseInt(depthStr, 10) || 1 }
return { width, height, depth }
}
const TestDebugging = () =&amp;gt; {
const urlParams = getURLParams() //获取 URL 参数
...
const geometry = new Three.BoxBufferGeometry(urlParams.width, urlParams.height, urlParams.depth)
...
}
&lt;/code>&lt;/pre>&lt;h4 id="6把一些参数显示在屏幕上">6、把一些参数显示在屏幕上&lt;/h4>
&lt;p>我们还以 刚才的代码为例，在之前的示例中，我们是将组件直接 return 一个 &amp;lt;canvas /&amp;gt; 对象，&lt;/p>
&lt;pre tabindex="0">&lt;code>return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
&lt;/code>&lt;/pre>&lt;p>我们可以改造一下：&lt;/p>
&lt;pre tabindex="0">&lt;code>return (
&amp;lt;div className=&amp;#39;full-screen&amp;#39;&amp;gt;
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
&amp;lt;div className=&amp;#39;debug&amp;#39;&amp;gt;
&amp;lt;span&amp;gt;width:{urlParams.width}&amp;lt;/span&amp;gt;
&amp;lt;span&amp;gt;height:{urlParams.height}&amp;lt;/span&amp;gt;
&amp;lt;span&amp;gt;depth:{urlParams.depth}&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
）
&lt;/code>&lt;/pre>&lt;p>对应的样式：&lt;/p>
&lt;pre tabindex="0">&lt;code>.full-screen, canvas {
display: block;
height: inherit;
width: inherit;
}
.debug {
position: fixed;
top: 20px;
left: 20px;
width: 80px;
padding: 20px;
background-color: rgba($color: #FFFFFF, $alpha: 0.7);
}
.debug span {
display: block;
}
&lt;/code>&lt;/pre>&lt;p>这样当我们调试网页的时候，就可以直接在左上角，看到 立方体的尺寸具体的值。&lt;/p>
&lt;blockquote>
&lt;p>本示例演示的立方体尺寸是固定的，若通过 useState 来定义尺寸，且尺寸会发生修改，那么左上角的展示的参数也可以对应修改成动态可变动的。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>依次类推，可以延展成其他参数展示&lt;/p>
&lt;/blockquote>
&lt;h4 id="7把-windowrequestanimationframe-添加在靠后位置">7、把 window.requestAnimationFrame 添加在靠后位置&lt;/h4>
&lt;p>在之前的一些示例中，渲染场景的函数，可能如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>const render = () =&amp;gt; {
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
&lt;/code>&lt;/pre>&lt;p>你是否考虑过，假设我们修改成这样：&lt;/p>
&lt;pre tabindex="0">&lt;code>const render = () =&amp;gt; {
window.requestAnimationFrame(render) //代码顺序改变
renderer.render(scene, camera)
}
window.requestAnimationFrame(render)
&lt;/code>&lt;/pre>&lt;p>代码顺序调整后，会有什么问题吗？&lt;/p>
&lt;p>答：这里可能会产生一个隐患——由于 window.requestAnimationFrame 代码在前，renderer.render(scene, camera) 代码在后，那么意味着 即使 renderer.render() 执行发生错误，那么代码依然在下一帧中继续执行。&lt;/p>
&lt;p>而我们之前的顺序是 renderer.render() 在前，window.requestAnimationFrame 在后，那么万一 renderer.render() 执行时发生错误，此时 浏览器即报错，JS 停止运行，那么后面的 window.requestAnimationFrame 就不会再执行了。&lt;/p>
&lt;p>结论：应该尽量把 window.requestAnimationFrame 添加到靠后位置。&lt;/p>
&lt;h4 id="8检查-threejs-中的单位">8、检查 Three.js 中的单位&lt;/h4>
&lt;p>在 Three.js 中，单位并没有统一，具体表现在：&lt;/p>
&lt;ol>
&lt;li>镜头的角度使用的是度数、而其他地方涉及角度时单位使用的是 弧度。&lt;/li>
&lt;li>默认情况下，对于距离、尺寸的数值 1 表示 1 米，但是也可以通过配置让数值 1 表示为 1 厘米。&lt;/li>
&lt;/ol>
&lt;p>因此，在使用 Three.js 时，关于数值单位请格外留意。&lt;/p>
&lt;h4 id="9添加辅助对象添加镜头轨道控制器">9、添加辅助对象、添加镜头轨道控制器&lt;/h4>
&lt;p>在开发阶段，可以多添加一些辅助对象，例如：坐标辅助对象、灯光辅助对象、镜头辅助对象。&lt;/p>
&lt;p>辅助对象可以比较直观得帮助我们去观察，去调试。&lt;/p>
&lt;p>同时也要添加镜头轨道控制器，例如 OrbitControls，可以让我们比较方便操控、查看场景。&lt;/p>
&lt;h4 id="10必要时可以将物体材质设置为-meshbasicmaterial">10、必要时可以将物体材质设置为 MeshBasicMaterial&lt;/h4>
&lt;p>假设你设置的物体材质是可反光材料，但是渲染时发现并没有渲染出该物体。&lt;/p>
&lt;p>这个时候，你可以先将物体材质修改为不反光的 MeshBasicMaterial，这样可以快速排除一些问题。&lt;/p>
&lt;p>假设物体材质不反光，此时若依然渲染不出物体，那么就可以肯定问题没有出在灯光上。&lt;/p>
&lt;p>反之，则应该去检查灯光的问题。&lt;/p>
&lt;h4 id="11检查镜头的-near-和-far-配置">11、检查镜头的 near 和 far 配置&lt;/h4>
&lt;p>有些时候场景没有渲染出物体，那么你也要去检查一下镜头的 near 和 far 的值。&lt;/p>
&lt;p>比如我们可以暂时性的将镜头的 far 设置为 10000，或者将 near 设置为 0.001，在这种极端配置下，再去看场景是否渲染出物体。&lt;/p>
&lt;p>调试结束后，记得将 near 和 far 调整会合理的精度范围。&lt;/p>
&lt;h4 id="12遇到疑惑的地方查文档查源码">12、遇到疑惑的地方，查文档，查源码&lt;/h4>
&lt;p>遇到某些 Three.js 疑惑的地方，例如某属性，某方法，请记得一定先去查阅官方文档，如果没有解决就直接去看 Three.js 的源码。&lt;/p>
&lt;p>Three.js 的源码并不是特别复杂，要敢于查看源码来解决疑惑。&lt;/p>
&lt;h2 id="使用-gui-调试场景中的参数">使用 GUI 调试场景中的参数&lt;/h2>
&lt;p>&lt;strong>图形用户界面( Graphical User Interface ) 简称 GUI。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>主要目的是用来帮我们快速搭建可视化调试参数面板。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>针对 JS 的 GUI ——dat.gui&lt;/strong>&lt;/p>
&lt;p>官网地址：https://github.com/dataarts/dat.gui&lt;/p>
&lt;p>&lt;strong>针对 React 的 GUI——react-dat-gui&lt;/strong>&lt;/p>
&lt;p>官网地址：https://github.com/claus/react-dat-gui&lt;/p>
&lt;p>&lt;strong>react-dat-gui 的具体用法，请查看我的另外一篇文章：&lt;a href="https://github.com/puxiao/notes/blob/master/React%E4%B8%AD%E4%BD%BF%E7%94%A8GUI.md" target="_blank" rel="noopener">React 中使用 GUI.md&lt;/a>&lt;/strong>&lt;/p>
&lt;p>本教程所有示例都是基于 react + typescript 的，所以我们选择使用 react-dat-gui&lt;/p>
&lt;p>在我们后续的示例中，就会使用到 react-dat-gui。&lt;/p>
&lt;h2 id="调试-glsl">调试 GLSL&lt;/h2>
&lt;p>&lt;strong>图形库着色语言( Graphic Library Shader Language ) 简称 GLSL。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>学不动了，学不动了！&lt;/p>
&lt;/blockquote>
&lt;p>GLSL 的相关介绍，可查阅：&lt;/p>
&lt;p>WebGL 与 GLSL：https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html&lt;/p>
&lt;p>WebGL2 与 GLSL：https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html&lt;/p>
&lt;p>由于我个人没有学习过 WebGL 和 GLSL，所以暂时先不讨论如何调试 GLSL。&lt;/p>
&lt;blockquote>
&lt;p>谷歌浏览器还有一个专门用来调试着色器的插件：Shader Editor&lt;/p>
&lt;p>&lt;a href="https://chrome.google.com/webstore/detail/shader-editor/ggeaidddejpbakgafapihjbgdlbbbpob?hl=en" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/shader-editor/ggeaidddejpbakgafapihjbgdlbbbpob?hl=en&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>关于 Three.js 的调试技巧，就讲到这里。&lt;/p>
&lt;p>接下来讲解 Canvas 的一些常用小技巧。&lt;/p></description></item><item><title>19.Three.js 技巧之画布</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/</guid><description>&lt;h1 id="19-threejs-技巧之画布">19 Three.js 技巧之画布&lt;/h1>
&lt;p>本文讲解一下 画布 Canvas 的一些实用技巧。&lt;/p>
&lt;ul>
&lt;li>创建画布截屏(快照)，并保存图片到本地&lt;/li>
&lt;li>设置不清除画布内容&lt;/li>
&lt;li>获取键盘事件&lt;/li>
&lt;li>设置画布透明度&lt;/li>
&lt;li>设置画布为背景&lt;/li>
&lt;/ul>
&lt;h2 id="示例基本代码hellocanvas">示例基本代码：HelloCanvas&lt;/h2>
&lt;h4 id="先制作一个简单的带动画的-threejs-场景">先制作一个简单的、带动画的 Three.js 场景&lt;/h4>
&lt;p>为了演示各个功能，我们先创建一个基础的 Three.js 动画场景：场景上有 3 个不同颜色、不停旋转的立方体。&lt;/p>
&lt;p>这个场景在之前多个示例中已经创建过多次，但是这次和之前的略微不同。&lt;/p>
&lt;p>**不同点 1：**由于本文是讲解 canvas 的，本身和 Three.js 没太大的关联，所以这次我们会创建一个 useCreateScene 的自定义 hook，用来专门创建 3D 场景，这样我们的 index.tsx 代码可以更加简洁。&lt;/p>
&lt;blockquote>
&lt;p>所谓 &lt;code>自定义 react hook&lt;/code>，本质上就是包含有 hook 的普通函数&lt;/p>
&lt;/blockquote>
&lt;p>**不同点 2：**由于讲解过程中需要用到一些按钮，所以我们这次将引入 react-dat-gui 这个组件，来添加一些示例相关按钮。&lt;/p>
&lt;p>关于如何使用 react-dat-gui 这个，请参考我写的 &lt;a href="https://github.com/puxiao/notes/blob/master/React%E4%B8%AD%E4%BD%BF%E7%94%A8GUI.md" target="_blank" rel="noopener">React 中使用 GUI.md&lt;/a> 这篇教程。&lt;/p>
&lt;blockquote>
&lt;p>请务必学习一下 react-dat-gui 这个组件，在后续示例中我们会经常使用这个组件来作为调试面板。&lt;/p>
&lt;/blockquote>
&lt;h4 id="具体的代码">具体的代码&lt;/h4>
&lt;p>我们创建一个专门存放本示例的目录 src/components/hello-canvas/&lt;/p>
&lt;p>&lt;strong>use-create-scene.ts：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
const useCreateScene = (canvasRef: React.RefObject&amp;lt;HTMLCanvasElement&amp;gt;) =&amp;gt; {
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
scene.background = new Three.Color(0x222222)
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.set(0, 5, 10)
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(5, 10, 0)
scene.add(light)
const controls = new OrbitControls(camera, canvasRef.current)
controls.update()
const colors = [&amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;]
const cubes: Three.Mesh[] = []
colors.forEach((color, index) =&amp;gt; {
const mat = new Three.MeshPhongMaterial({ color })
const geo = new Three.BoxBufferGeometry(2, 2, 2)
const mesh = new Three.Mesh(geo, mat)
mesh.position.x = (index - 1) * 4
scene.add(mesh)
cubes.push(mesh)
})
const render = (time: number) =&amp;gt; {
time *= 0.001
cubes.forEach((cube) =&amp;gt; {
cube.rotation.x = cube.rotation.y = time
})
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
}
export default useCreateScene
&lt;/code>&lt;/pre>&lt;p>&lt;strong>index.scss：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>.full-screen,
canvas {
display: block;
height: inherit;
width: inherit;
}
.dat-gui {
top: 16px !important;
font-size: 18px !important;
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>index.tsx：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useState } from &amp;#39;react&amp;#39;
import DatGUI, { DatButton } from &amp;#39;react-dat-gui&amp;#39;
import useCreateScene from &amp;#39;./use-create-scene&amp;#39;
import &amp;#39;./index.scss&amp;#39;
import &amp;#39;react-dat-gui/dist/index.css&amp;#39;
const HelloCanvas = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const [date, setDate] = useState&amp;lt;any&amp;gt;({})
useCreateScene(canvasRef)
const handleGUIUpdate = (newDate: any) =&amp;gt; {
setDate(newDate)
}
const handleSaveClick = () =&amp;gt; {
//编写点击之后的代码
}
return (
&amp;lt;div className=&amp;#39;full-screen&amp;#39;&amp;gt;
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
&amp;lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&amp;#39;dat-gui&amp;#39; &amp;gt;
&amp;lt;DatButton label=&amp;#39;点击保存画布快照&amp;#39; onClick={handleSaveClick} /&amp;gt;
&amp;lt;/DatGUI&amp;gt;
&amp;lt;/div&amp;gt;
)
}
export default HelloCanvas
&lt;/code>&lt;/pre>&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>所有创建 3D 场景的代码都转移到了 use-create-scene.ts 中，index.tsx 的代码终于看上去非常简洁了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们使用了 &amp;lt;DatGUI &amp;gt; 标签，但是由于我们本身只使用 按钮(&amp;lt;DatButton &amp;gt;)，并未用到任何其他变量，所以&lt;/p>
&lt;p>&lt;code> &amp;lt;DatGUI data={date} onUpdate={handleGUIUpdate} &amp;gt;&lt;/code>这行属性配置只是为了不让 DatGUI 报缺省错误，并无其他作用。&lt;/p>
&lt;blockquote>
&lt;p>DatGUI 的 date、onUpdate 为必填属性&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>至此，本示例所用到的基础场景代码已搭建好，接下来开始讲解 canvas 的使用技巧。&lt;/p>
&lt;h2 id="创建画布截屏快照并保存图片到本地">创建画布截屏(快照)，并保存图片到本地&lt;/h2>
&lt;h3 id="先说一下如何创建画布截屏快照">先说一下如何创建画布截屏(快照)&lt;/h3>
&lt;p>对于 HTML5 中的 canvas 来说，创建画布截屏(快照)有 2 种方式：canvas.toDataURL()、canvas.toBolb()&lt;/p>
&lt;blockquote>
&lt;p>所谓截屏和快照，更加准确的说法应该是：获取画布当前图片的内容&lt;/p>
&lt;/blockquote>
&lt;h4 id="第-1-种canvastodataurl">第 1 种：canvas.toDataURL()&lt;/h4>
&lt;p>canvas.toDataURL() 可以创建一个临时的图片地址，该图片地址可以作为当前页面中的 &amp;lt;image &amp;gt;标签中的 src 属性值。或者可以创建一个下载链接，点击下载这个图片。&lt;/p>
&lt;p>&lt;strong>toDataURL()用法：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>canvas.toDataURL(type?: string, quality?: any): string;
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>type：图片格式类型，值只能是 &amp;ldquo;image/png&amp;rdquo; 或 &amp;ldquo;image/jpeg&amp;rdquo;&lt;/p>
&lt;blockquote>
&lt;p>除了上面 2 个固定值，若你填写其他值则不启作用也不报错，最终会使用 &amp;ldquo;image/png&amp;rdquo; 来作为默认值&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>对于 谷歌浏览器 Chrome ，还额外支持一个类型 “image/webp”&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>quality：jpeg 图片的压缩质量，取值范围 0 - 1，默认值为 0.92&lt;/p>
&lt;blockquote>
&lt;p>quality 的值越大，图片清晰度越高，文件体积越大&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>如果 quality 的值不在 0-1 范围内，则会使用默认值 0.92&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>创建 PNG 图片：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const imgurl = canvas.toDataURL(&amp;#39;image/png&amp;#39;)
console.log(imgurl)
//输出以下内容
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAEUCAYAAADK...
&lt;/code>&lt;/pre>&lt;p>&lt;strong>创建 JPEG 图片：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const imgurl = canvas.toDataURL(&amp;#39;image/jpeg&amp;#39;,quality)
console.log(imgurl)
//输出以下内容
data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQY...
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意上面输出内容中，均包含了 ”base64“，这种格式的图片，是可以自动下载的&lt;/p>
&lt;p>关于图片自动下载保存到本地我们会稍后讲解&lt;/p>
&lt;/blockquote>
&lt;h4 id="第-2-种canvastoblob">第 2 种：canvas.toBlob()&lt;/h4>
&lt;p>canvas.toBlob() 可以创建 Blob 对象，该对象包含图片的数据内容。&lt;/p>
&lt;blockquote>
&lt;p>注意：canvas.toDataURL() 是获得一个临时的图片地址，而 canvas.toBlob() 是获得图片数据内容。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>canvas.toBlob()用法：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>toBlob(callback: BlobCallback, type?: string, quality?: any): void;
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>callback：获得 Blob 对象的回调函数&lt;/p>
&lt;blockquote>
&lt;p>通常为：canvas.toBlob( (blob: Blob|null) =&amp;gt; {} )&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>type：图片的格式类型，默认值为 &amp;ldquo;image/png&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>quality：若图片格式类型为 &amp;ldquo;image/jpeg&amp;rdquo;，quality 表示 JPEG 的压缩质量&lt;/p>
&lt;blockquote>
&lt;p>type 的取值和默认值、quality 的取值范围和默认值 与 canvas.toDataURL() 完全相同&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>使用示例：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>canvas.toBlob((blob) =&amp;gt; {
console.log(blob)
})
或
canvas.toBlob((blob) =&amp;gt; {
console.log(blob)
}, &amp;#39;image/jpeg&amp;#39;, 0.8)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>注意：不同于 canvas.toDataURL()，canvas.toBlob() 这个函数是没有返回值的&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>另外，假设使用 jpeg 压缩质量为 0.8，文件体积有可能只有 png 格式的 1/3 。&lt;/p>
&lt;/blockquote>
&lt;h4 id="补充说明">补充说明：&lt;/h4>
&lt;p>&lt;strong>关于分辨率：&lt;/strong>&lt;/p>
&lt;p>按照 MDN 文档，无论哪种方式保存的图片分辨率都是 96，但是我在 PC 机上试验，将下载的图片保存到本地，并在 PhotoShop 软件中查看，发现图片分辨率依然是 72。&lt;/p>
&lt;p>我怀疑 保存图片的分辨率其实是和 当前系统一致的。假设在手机上，有可能图片分辨率就是 96 了。&lt;/p>
&lt;blockquote>
&lt;p>稍后我会在手机上验证一下 图片分辨率 这个问题。&lt;/p>
&lt;/blockquote>
&lt;p>最后，建议你去 MDN 上看 canvas 保存图片 的相关讲解作为本小节的补充。&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas&lt;/a>&lt;/p>
&lt;h3 id="再说一下如何自动将图片下载到本地">再说一下如何自动将图片下载到本地&lt;/h3>
&lt;p>&lt;strong>图片自动下载到本地的思路：在 JS 中创建一个 a 链接，并且模拟出 a 点击事件&lt;/strong>&lt;/p>
&lt;p>&lt;strong>使用 toDataURL()函数：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const canvas = canvasRef.current
const imgurl = canvas.toDataURL(&amp;#39;image/jpeg&amp;#39;, 0.8)
const a = document.createElement(&amp;#39;a&amp;#39;)
a.href = imgurl
a.download = &amp;#39;myimg.jpeg&amp;#39;
a.click()
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>注意：我原本以为还需要将 a 标签插入到网页 body 中才可以实现自动下载，但是经过试验发现根本不需要这样，以下为我原本写的代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>const a = document.createElement(&amp;#39;a&amp;#39;)
document.body.appendChild(a) //根本无需此行代码
a.style.display = &amp;#39;none&amp;#39; //由于不需要添加到 body 中，因此也无需此行代码
a.href = imgurl
a.download = &amp;#39;myimg.jpeg&amp;#39;
a.click()
document.body.removeChild(a) //根本无需此行代码
&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>&lt;strong>使用 toBlob()函数：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const canvas = canvasRef.current
canvas.toBlob((blob) =&amp;gt; {
const imgurl = window.URL.createObjectURL(blob)
const a = document.createElement(&amp;#39;a&amp;#39;)
a.href = imgurl
a.download = &amp;#39;myimg.jpeg&amp;#39;
a.click()
}, &amp;#39;image/jpeg&amp;#39;, 0.8)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>小总结：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>若使用 canvas.toDataURL()，则可以直接将得到的图片临时地址 赋值给 a.href&lt;/li>
&lt;li>若使用 canvas.toBlob()，则需要通过 window.URL.createObjectURL() 这个函数将 Blob 数据转化得到对应的地址，然后再赋值给 a.href&lt;/li>
&lt;/ol>
&lt;p>好了，关于如何获取画布图片数据、如何保持图片到本地讲解完毕，来实践吧。&lt;/p>
&lt;p>无论采用 canvas.toDataURL() 还是 canvas.toBlob() 都可以，本示例我们采用 toBlob() 。&lt;/p>
&lt;p>我们将 index.stx 的代码修改如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useState } from &amp;#39;react&amp;#39;
import DatGUI, { DatButton } from &amp;#39;react-dat-gui&amp;#39;
import useCreateScene from &amp;#39;./use-create-scene&amp;#39;
import &amp;#39;./index.scss&amp;#39;
import &amp;#39;react-dat-gui/dist/index.css&amp;#39;
const HelloCanvas = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const [date, setDate] = useState&amp;lt;any&amp;gt;({})
useCreateScene(canvasRef)
const handleGUIUpdate = (newDate: any) =&amp;gt; {
setDate(newDate)
}
const handleSaveClick = () =&amp;gt; {
if (canvasRef.current === null) { return }
const canvas = canvasRef.current
//采用 toDataURL() 方式
// const imgurl = canvas.toDataURL(&amp;#39;image/jpeg&amp;#39;, 0.8)
// const a = document.createElement(&amp;#39;a&amp;#39;)
// a.href = imgurl
// a.download = &amp;#39;myimg.jpeg&amp;#39; //我们定义下载图片的文件名
// a.click()
//采用 toBlob() 方式
canvas.toBlob((blob) =&amp;gt; {
const imgurl = window.URL.createObjectURL(blob)
const a = document.createElement(&amp;#39;a&amp;#39;)
a.href = imgurl
a.download = &amp;#39;myimg.jpeg&amp;#39;
a.click()
}, &amp;#39;image/jpeg&amp;#39;, 0.8)
}
return (
&amp;lt;div className=&amp;#39;full-screen&amp;#39;&amp;gt;
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
&amp;lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&amp;#39;dat-gui&amp;#39; &amp;gt;
&amp;lt;DatButton label=&amp;#39;点击保存画布快照&amp;#39; onClick={handleSaveClick} /&amp;gt;
&amp;lt;/DatGUI&amp;gt;
&amp;lt;/div&amp;gt;
)
}
export default HelloCanvas
&lt;/code>&lt;/pre>&lt;p>实际运行，点击右上角的 按钮，就会给画布创建图片快照，并且自动下载到本地。&lt;/p>
&lt;p>然后你可以查看刚刚下载到本地的 myimg.jpeg 这个文件，打开它——你会发现？？？&lt;/p>
&lt;p>&lt;strong>怎么图片啥内容都没有？纯色的？3 个立方体呢？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>what ？why ？&lt;/strong>&lt;/p>
&lt;p>呵，马上讲解为什么。&lt;/p>
&lt;p>&lt;strong>问题出在了哪里？&lt;/strong>&lt;/p>
&lt;p>首先我们容易想到，在 use-create-scene.ts 的 render() 函数中，不停的运行着每一帧都进行画布重新渲染的代码，莫非是我们截图那一瞬间刚好画布还未渲染完成？&lt;/p>
&lt;p>好，我们先把那行代码删除掉，看是否就可以截图显示有内容了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">const render = (time: number) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> time *= 0.001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cubes.forEach((cube) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cube.rotation.x = cube.rotation.y = time
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> })
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> renderer.render(scene, camera)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- window.requestAnimationFrame(render)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">window.requestAnimationFrame(render)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次运行，3 个立方体是静止状态，此时点击按钮保存截图。&lt;/p>
&lt;p>查看该图，竟然依然是空白，没有内容的。&lt;/p>
&lt;p>看来问题并不出在上面一行代码中，我们恢复刚才删除的 &lt;code>window.requestAnimationFrame(render)&lt;/code>，再去想其他原因。&lt;/p>
&lt;p>&lt;strong>真实的原因是：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>我们所谓的针对画布截屏 创建快照，实际上是获取 canvas 中的数据&lt;/li>
&lt;li>但这个数据并不是针对 DOM 中已显示的 canvas，而是针对 canvas 对象中缓冲区的数据&lt;/li>
&lt;li>关键在于当 canvas 渲染完成后(DOM 中已显示出内容)，默认会清空 缓冲区中的数据&lt;/li>
&lt;li>所以，这就是我们为什么去 “获取 canvas 图像数据时得到是空白内容” 的原因&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>canvas 从计算到显示的过程：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>canvas 根据相应的 JS 规则，开始创建、计算画布内容数据&lt;/li>
&lt;li>canvas 将计算得到的画布内容数据填充到 canvas 缓冲区&lt;/li>
&lt;li>当 canvas 画布内容计算完成，此时 canvas 缓冲区已有完整的画布内容数据后，将画布内容显示到 DOM 中&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>再说一遍：&lt;/strong>&lt;/p>
&lt;p>我们之前的示例中，渲染并显示 canvas 内容的函数 render 和 创建画布快照 的函数是相互独立的，这就造成了当我们去获取 canvas 缓冲区数据时，canvas 已经将画布内容显示到 DOM 中并且清空了缓冲区。&lt;/p>
&lt;p>&lt;strong>解决办法：&lt;/strong>&lt;/p>
&lt;p>解决办法就是当我们要创建画布快照，获取 canvas 缓冲区内容之前，在同一个函数体内，额外调用一次 render 函数，确保此时 canvas 缓冲区内是有内容的。&lt;/p>
&lt;p>&lt;strong>实际代码：&lt;/strong>&lt;/p>
&lt;p>第 1：由于我们示例代码中，render 函数本身位于 useCreateScene 函数内部，因此我们需要创造一个 renderRef 的钩子(hook)，将 renderRef 对外 return 出去，以便 index.stx 中可以获取 render 函数的引用。&lt;/p>
&lt;pre tabindex="0">&lt;code>type RenderType = () =&amp;gt; void
...
const renderRef = useRef&amp;lt;RenderType | null&amp;gt;(null)
...
renderRef.current = render
...
return renderRef
&lt;/code>&lt;/pre>&lt;p>第 2：这样做引申出另外一个问题，就是我们的 render 函数其实是有参数 time 的：&lt;/p>
&lt;pre tabindex="0">&lt;code>const render = (time: number) =&amp;gt; {
time *= 0.001
cubes.forEach((cube) =&amp;gt; {
cube.rotation.x = cube.rotation.y = time
})
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
&lt;/code>&lt;/pre>&lt;p>而我们希望 index.tsx 中调用 render() 是不传参数 time 的。因为 index.tsx 中根本不存在 time 这个变量，所以我们需要对 渲染 进行适当的改造。&lt;/p>
&lt;p>我们将原本的 渲染函数 render() 拆分成 2 个函数：&lt;/p>
&lt;ol>
&lt;li>单纯负责渲染的 render 函数&lt;/li>
&lt;li>负责修改物体属性从而产生动画的 animate 函数&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>const render = () =&amp;gt; {
renderer.render(scene, camera)
}
renderRef.current = render
const animate = (time: number) =&amp;gt; {
time *= 0.001
cubes.forEach((cube) =&amp;gt; {
cube.rotation.x = cube.rotation.y = time
})
render() //这样 render() 就是一个不需要参数的函数
window.requestAnimationFrame(animate)
}
window.requestAnimationFrame(animate)
&lt;/code>&lt;/pre>&lt;p>经过这样改造后，完整的 use-create-screen.ts 代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
type RenderType = () =&amp;gt; void
const useCreateScene = (canvasRef: React.RefObject&amp;lt;HTMLCanvasElement&amp;gt;) =&amp;gt; {
const renderRef = useRef&amp;lt;RenderType | null&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
scene.background = new Three.Color(0x222222)
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.set(0, 5, 10)
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(5, 10, 0)
scene.add(light)
const controls = new OrbitControls(camera, canvasRef.current)
controls.update()
const colors = [&amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;]
const cubes: Three.Mesh[] = []
colors.forEach((color, index) =&amp;gt; {
const mat = new Three.MeshPhongMaterial({ color })
const geo = new Three.BoxBufferGeometry(2, 2, 2)
const mesh = new Three.Mesh(geo, mat)
mesh.position.x = (index - 1) * 4
scene.add(mesh)
cubes.push(mesh)
})
const render = () =&amp;gt; {
renderer.render(scene, camera)
}
renderRef.current = render
const animate = (time: number) =&amp;gt; {
time *= 0.001
cubes.forEach((cube) =&amp;gt; {
cube.rotation.x = cube.rotation.y = time
})
render() //这样 render() 就是一个不需要参数的函数
window.requestAnimationFrame(animate)
}
window.requestAnimationFrame(animate)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return renderRef
}
export default useCreateScene
&lt;/code>&lt;/pre>&lt;p>index.tsx 完整代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useState } from &amp;#39;react&amp;#39;
import DatGUI, { DatButton } from &amp;#39;react-dat-gui&amp;#39;
import useCreateScene from &amp;#39;./use-create-scene&amp;#39;
import &amp;#39;./index.scss&amp;#39;
import &amp;#39;react-dat-gui/dist/index.css&amp;#39;
const HelloCanvas = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const [date, setDate] = useState&amp;lt;any&amp;gt;({})
const renderRef = useCreateScene(canvasRef) //获取自定义 hook 返回的 renderRef
const handleGUIUpdate = (newDate: any) =&amp;gt; {
setDate(newDate)
}
const handleSaveClick = () =&amp;gt; {
if (canvasRef.current === null || renderRef.current === null) { return }
const canvas = canvasRef.current
renderRef.current() //此时调用 render()，进行一次渲染，确保 canvas 缓冲区有数据
//采用 toDataURL() 方式
// const imgurl = canvas.toDataURL(&amp;#39;image/jpeg&amp;#39;, 0.8)
// const a = document.createElement(&amp;#39;a&amp;#39;)
// a.href = imgurl
// a.download = &amp;#39;myimg.jpeg&amp;#39; //我们定义下载图片的文件名
// a.click()
//采用 toBlob() 方式
canvas.toBlob((blob) =&amp;gt; {
const imgurl = window.URL.createObjectURL(blob)
const a = document.createElement(&amp;#39;a&amp;#39;)
a.href = imgurl
a.download = &amp;#39;myimg.jpeg&amp;#39;
a.click()
}, &amp;#39;image/jpeg&amp;#39;, 0.8)
}
return (
&amp;lt;div className=&amp;#39;full-screen&amp;#39;&amp;gt;
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
&amp;lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&amp;#39;dat-gui&amp;#39; &amp;gt;
&amp;lt;DatButton label=&amp;#39;点击保存画布快照&amp;#39; onClick={handleSaveClick} /&amp;gt;
&amp;lt;/DatGUI&amp;gt;
&amp;lt;/div&amp;gt;
)
}
export default HelloCanvas
&lt;/code>&lt;/pre>&lt;p>调试运行，这次保存的画布快照图片，就不会再是空白，而是有具体内容了。&lt;/p>
&lt;h2 id="设置不清除画布内容">设置不清除画布内容&lt;/h2>
&lt;p>上面刚讲到 HTML5 中的 Canvas 每次渲染都存在一个 数据缓冲区的概念，而 Three.js 的渲染器 WebGLRenderer 也同样存在 数据缓冲区 这个概念。&lt;/p>
&lt;p>WebGLRenderer 缓冲区内为每次渲染场景得到的画面数据，默认情况下每一次渲染都会清空(释放)上一次的渲染画面数据。&lt;/p>
&lt;p>Canvas 数据缓冲区每次清空 这个我们没有办法修改，只能调用渲染函数，重新渲染一次。&lt;/p>
&lt;p>但是 WebGLRenderer 的数据缓冲区却是可以通过设置让默认不清除的。&lt;/p>
&lt;blockquote>
&lt;p>所谓不清除上一次数据缓冲区的内容，本质上就是保留上一次渲染画面内容&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>所谓不清除画布内容，本质上是让渲染器不清除之前的渲染内容&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>设置 WebGLRenderer 保留数据缓冲区中的历史数据：&lt;/strong>&lt;/p>
&lt;p>我们只需要将 WebGLRender 的配置修改如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>const renderer = new Three.WebGLRenderer({
canvas: canvasRef.current,
preserveDrawingBuffer: true,
alpha: true
})
renderer.autoClearColor = false
&lt;/code>&lt;/pre>&lt;p>经过以上的修改之后，每次渲染都会继续保留之前渲染历史画面。&lt;/p>
&lt;p>调试运行代码，你就能感受到和之前渲染的不一样效果了。&lt;/p>
&lt;p>&lt;strong>但是，存在一个问题：当浏览器窗口尺寸改变后，由于执行了 renderer.setSize()，则此时 渲染器中过往的渲染内容将会被清空。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>渲染器中的渲染历史内容被清空后，画面就好像第一次刚开始那样，重新开始渲染。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>补充说明：当用户在手机上浏览时，手机从竖屏变为横屏时，也会触发重新绘制。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>真正的解决方案：离屏渲染&lt;/strong>&lt;/p>
&lt;p>例如使用 WebGLRenderTarget，具体请回顾我们之前讲解的内容：&lt;a href="https://github.com/puxiao/threejs-tutorial/blob/main/15%20Three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93.md" target="_blank" rel="noopener">15 Three.js 基础之离屏渲染.md&lt;/a>&lt;/p>
&lt;h3 id="补充一个示例preservedrawingbuffer">补充一个示例：PreserveDrawingBuffer&lt;/h3>
&lt;p>src/components/hello-canvas/preserve-drawing-buffer.tsx&lt;/p>
&lt;h4 id="示例目标">示例目标：&lt;/h4>
&lt;ol>
&lt;li>创建一个由 6 个立方体，做相互缠绕运动的一个物体&lt;/li>
&lt;li>创建一个正交镜头 OrthographicCamera&lt;/li>
&lt;li>给 canvas 添加鼠标滑动监听、以及 手指滑动监听&lt;/li>
&lt;li>当 鼠标或手指滑动画布时，更新 物体 在镜头中的位置&lt;/li>
&lt;li>设置渲染器不清除历史画面&lt;/li>
&lt;/ol>
&lt;p>最终呈现出的效果：类似一个 画笔在画板上 画画 的效果。&lt;/p>
&lt;p>&lt;strong>PreserveDrawingBuffer 代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const state = { x: 0, y: 0, z: 0 }
const PreserveDrawingBuffer = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({
canvas: canvasRef.current,
preserveDrawingBuffer: true,
alpha: true
})
renderer.autoClearColor = false
const camera = new Three.OrthographicCamera(-2, 2, 1, -1, -1, 1)
const scene = new Three.Scene()
scene.background = new Three.Color(0xFFFFFF)
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(-1, 2, 3)
scene.add(light)
const geometry = new Three.BoxBufferGeometry(1, 1, 1)
const base = new Three.Object3D()
scene.add(base)
base.scale.set(0.1, 0.1, 0.1)
const colors = [&amp;#39;#F00&amp;#39;, &amp;#39;#FF0&amp;#39;, &amp;#39;#0F0&amp;#39;, &amp;#39;#0FF&amp;#39;, &amp;#39;#00F&amp;#39;, &amp;#39;#F0F&amp;#39;]
const numArr = [-2, 2] //同一坐标轴上，对称 2 个立方体的坐标
colors.forEach((color, index) =&amp;gt; {
const material = new Three.MeshPhongMaterial({ color })
const cube = new Three.Mesh(geometry, material)
const col = Math.floor(index / numArr.length)
const row = index % numArr.length
let result = [0, 0, 0]
result[col] = numArr[row]
cube.position.set(result[0], result[1], result[2])
base.add(cube)
})
const temp = new Three.Vector3()
const updatePosition = (x: number, y: number) =&amp;gt; {
if (canvasRef.current === null) { return }
// const rect = canvasRef.current.getBoundingClientRect()
// const newX = (x - rect.left) * canvasRef.current.width / rect.width
// const newY = (y - rect.top) * canvasRef.current.height / rect.height
// const resX = newX / canvasRef.current.width * 2 - 1
// const resY = newY / canvasRef.current.height * -2 + 1
const resX = x / canvasRef.current.width * 2 - 1
const resY = y / canvasRef.current.height * -2 + 1
temp.set(resX, resY, 0).unproject(camera)
state.x = temp.x
state.y = temp.y
}
const handleMouseMove = (eve: MouseEvent) =&amp;gt; {
updatePosition(eve.clientX, eve.clientY)
}
const handleTouchMove = (eve: TouchEvent) =&amp;gt; {
eve.preventDefault()
const touche = eve.touches[0]
updatePosition(touche.clientX, touche.clientY)
}
canvasRef.current.addEventListener(&amp;#39;mousemove&amp;#39;, handleMouseMove)
canvasRef.current.addEventListener(&amp;#39;touchmove&amp;#39;, handleTouchMove, { passive: false })
const render = (time: number) =&amp;gt; {
time = time * 0.001
base.position.set(state.x, state.y, state.z)
base.rotation.x = time
base.rotation.y = time * 1.11
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.right = width / height
camera.left = - camera.right
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default PreserveDrawingBuffer
&lt;/code>&lt;/pre>&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>上面这段代码略微复杂、陌生。因为这段代码中有几个地方是我们之前示例中从来未接触过的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>使用的是正交镜头，而不是透视镜头&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当窗口尺寸发生变化时，更新正交镜头&lt;/p>
&lt;blockquote>
&lt;p>更新方式和我们之前习惯使用的 透视镜头(PerspectiveCamera) 大不同&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>监听鼠标滑动、手指滑动事件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新 物体 在正交镜头中的 “投影位置”&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>额外补充：&lt;/strong>&lt;/p>
&lt;p>上述代码中，6 个立方体 他们分别是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在 x 轴对称的 2 个立方体&lt;/p>
&lt;blockquote>
&lt;p>在示例中，对应的坐标分别为 (-2,0,0)、(2,0,0)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在 y 轴对称的 2 个立方体&lt;/p>
&lt;blockquote>
&lt;p>在示例中，对应的坐标分别为 (0,-2,0)、(0,2,0)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在 z 轴堆成的 2 个立方体&lt;/p>
&lt;blockquote>
&lt;p>在示例中，对应的坐标分别为 (0,0,-2)、(0,0,2)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>这 6 个立方体他们依次对应的坐标，没有提前写死，而是通过一段特殊的 forEach 循环来计算得出的。&lt;/p>
&lt;p>可以阅读下面这段通用的代码，帮助你理解 整个 forEach 循环是如何得到每个立方体坐标的。&lt;/p>
&lt;pre tabindex="0">&lt;code>//遍历出 目标长度为N，特殊值为 [xx, xx, ...] 的 多维数组
const numArr = [-2, 2] //定义特殊位置上出现的数字
const arrLength = 3 //定义目标数组长度
const total = arrLength * numArr.length //根据目标数组长度以及特殊数字的个数，计算得出目标数组的总个数
for (let i = 0; i &amp;lt; total; i++) {
const col = Math.floor(i / numArr.length) //计算出特殊位置的索引
const row = i % numArr.length //计算出特殊位置上数字值对应的索引
let result = new Array(arrLength) //得到一个 长度为 arrLenght 的数组
result.fill(0) //将数组每一项填充为 0
result[col] = numArr[row] //修改特殊位置上的值
console.log(result)
}
&lt;/code>&lt;/pre>&lt;p>如果你对 useCreateScene 这个示例不太理解也没有关系，因为毕竟这个示例中出现了一些我们之前示例中从未用到的一些类，你可以先跳过这个示例，继续后面的学习。&lt;/p>
&lt;blockquote>
&lt;p>随着日后对于 正交镜头 的多次使用，终归会熟练并理解的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="获取键盘事件">获取键盘事件&lt;/h2>
&lt;h4 id="让-canvas-获取键盘事件">让 Canvas 获取键盘事件&lt;/h4>
&lt;p>必须同时满足以下 2 个条件后，canvas 才可以获得键盘事件。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>canvas 当前获得焦点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>&amp;lt;canvas \&amp;gt;&lt;/code> 标签中必须添加 tabIndex 属性，&lt;/p>
&lt;blockquote>
&lt;p>属性值是 -1、0、1 都无所谓，建议设置为 0&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>补充说明：当 canvas 获得当前焦点后，会在四周出现一个蓝色边框，可以通过定义 css 样式来取消这个样式。&lt;/p>
&lt;pre tabindex="0">&lt;code>canvas:focus {
outline: none;
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>简单示例：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const CanvasKeyboard = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
canvasRef.current.focus() //自动获取焦点
const handleKeydown = (event: KeyboardEvent) =&amp;gt; {
console.log(event)
}
canvasRef.current.addEventListener(&amp;#39;keydown&amp;#39;, handleKeydown)
return () =&amp;gt; {
if (canvasRef.current === null) { return }
canvasRef.current.removeEventListener(&amp;#39;keydown&amp;#39;, handleKeydown)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; tabIndex={0} /&amp;gt;
)
}
export default CanvasKeyboard
&lt;/code>&lt;/pre>&lt;h4 id="让-orbitcontrol-获取键盘事件">让 OrbitControl 获取键盘事件&lt;/h4>
&lt;p>默认 OrbitControl 对象就包含键盘方向键侦听。&lt;/p>
&lt;p>键盘上的 上下左右 方向键 均可操控改变 镜头轨道视图。&lt;/p>
&lt;p>但是我们之前的代码中，经常是这样写的：&lt;/p>
&lt;pre tabindex="0">&lt;code>const controls = new OrbitControls(camera, canvasRef.current)
&lt;/code>&lt;/pre>&lt;p>这样存在的问题是，当 canvas 失去焦点后，就无法再获得键盘事件。&lt;/p>
&lt;p>最简单的解决办法就是将代码修改为：&lt;/p>
&lt;pre tabindex="0">&lt;code>const controls = new OrbitControls(camera, document.body)
&lt;/code>&lt;/pre>&lt;p>这样键盘事件就不容易丢失。&lt;/p>
&lt;h2 id="设置画布透明度">设置画布透明度&lt;/h2>
&lt;p>设置画布透明度，你可能会疑惑，这有什么好讲的，直接通过 css 给 canvas 添加透明度样式即可：&lt;/p>
&lt;pre tabindex="0">&lt;code>canvas {
opacity: 0.4;
}
&lt;/code>&lt;/pre>&lt;p>这样做肯定没有问题，但是这里说的 “设置画布透明度” 实际上是指 给不同物体设置透明度。&lt;/p>
&lt;p>例如我们之前示例中的立方体，那么所有的示例中立方体都不是半透明的。&lt;/p>
&lt;p>&lt;strong>给材质设置透明度：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>需要给材质设置透明度&lt;/p>
&lt;pre tabindex="0">&lt;code>const mat = new Three.MeshPhongMaterial({
color,
opacity: 0.4
})
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>渲染器需要开启透明度渲染&lt;/p>
&lt;pre tabindex="0">&lt;code>const renderer = new Three.WebGLRenderer({
canvas: canvasRef.current,
alpha:true,
premultipliedAlpha:false
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>alpha：canvas 是否包含透明度，默认为 false&lt;/p>
&lt;p>premultipliedAlpha：renderer 是否假设颜色有 premultiplied alpha (预乘 alpha)，默认为 true&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>针对 预乘 Alpha 的补充说明：&lt;/strong>&lt;/p>
&lt;p>premultiplied alpha：颜色值 预乘 alpha&lt;/p>
&lt;p>这是传统 3D 绘制中的一个重要概念，你可以简单理解成如下：&lt;/p>
&lt;p>假设我们要表示一个 透明度为 60% 的纯红色，采用 RGBA 的方式为 (255,0,0,0.6)，通过 预乘 alpha，我们可以得到透明度为 60% 的纯红色如果放置在纯白色底上，实际上最终呈现出来的颜色和 RGB ( 255,102,102) 是完全相同的。&lt;/p>
&lt;p>假设一个颜色使用 RGBA 来表示，透明度为 A、rgb 颜色为 C、纯白色(255,255,255)为 F，那么把 RGBA 转化为 RGB 的公式为：&lt;/p>
&lt;p>C*A + ( 1-A ) * F&lt;/p>
&lt;p>也就是说 rgba(255,0,0,0.6) 转化为对应的 rgb 过程为：&lt;/p>
&lt;p>(255,0,0)_0.6 + (1-0.6) _ (255,255,255) = (255, 255 x 0.4, 255 x 0.4) = (255,102,102)&lt;/p>
&lt;p>&lt;strong>暂时看不懂没有关系，只需记住若想让渲染器将物体渲染出半透明，除了物体本身材质配置透明度以外，还需要将渲染器中的 alpha 设置为 true 、premultipliedAlpha 设置为 false&lt;/strong>&lt;/p>
&lt;h2 id="设置画布为背景">设置画布为背景&lt;/h2>
&lt;p>将 canvas 设置为网页背景，事实上也很简单，对应的样式：&lt;/p>
&lt;pre tabindex="0">&lt;code>canvas {
position: fixed;
top: 0;
left: 0;
z-index: -1;
}
&lt;/code>&lt;/pre>&lt;p>上述 CSS 样式就让 canvas 位置固定，且层级最低，这样就成为当前网页背景了。&lt;/p>
&lt;p>但是实际项目中，更加建议将 canvas 包含在一个 iframe 中后，再作为 网页的背景。&lt;/p>
&lt;p>这样做有几个理由：&lt;/p>
&lt;ol>
&lt;li>使用 iframe 后，可以将 canvas、Three.js 的相关代码独立出来&lt;/li>
&lt;li>可以多个页面都引用这个 iframe&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>iframe 的相关示例：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;iframe id=&amp;#39;background&amp;#39; src=&amp;#39;xxx.html&amp;#39; &amp;gt;
&amp;lt;div&amp;gt;
Hello Three.js
&amp;lt;/div&amp;gt;
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>#background {
position: fixed;
width:100%;
height:100%;
left:0;
top:0;
z-index:-1;
border:none;
pointer-events:none;
}
&lt;/code>&lt;/pre>&lt;p>上述 css 样式中：&lt;/p>
&lt;ol>
&lt;li>position: fixed; 可以让 iframe 位置固定&lt;/li>
&lt;li>z-index: -1; 可以让 iframe 层级最低&lt;/li>
&lt;li>border: none; 可以让 iframe 不显示边框&lt;/li>
&lt;li>pointer-events: none; 让 iframe 永远不会成为鼠标事件的 target，意味着让 iframe 不接受鼠标交互事件&lt;/li>
&lt;/ol>
&lt;p>关于更多 canvas 的相关用法，建议阅读 MDN 上关于 canvas 的相关文档：&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API&lt;/a>&lt;/p>
&lt;p>至此，关于 Three.js 的一些常用技巧讲解完毕。&lt;/p>
&lt;p>接下来开始讲解 Three.js 的一些性能优化。&lt;/p></description></item><item><title>20.Three.js 优化之合并对象</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/</guid><description>&lt;h1 id="20-threejs-优化之合并对象">20 Three.js 优化之合并对象&lt;/h1>
&lt;p>前面学习了 Three.js 入门、基础、技巧，今天开始学习 Three.js 的性能优化。&lt;/p>
&lt;p>关于性能优化有很多方式，最基础也是最常见的方式就是——合并几何对象。&lt;/p>
&lt;blockquote>
&lt;p>在 “Three.js 基础之图元” 那篇文章中，我们将几何体称呼为 图元，现在我们修改一下这个称呼，本文以后，绝大多数情况下我们都使用 “几何体” 来代替 “图元”。&lt;/p>
&lt;/blockquote>
&lt;p>既然谈到性能优化，就不能使用简单的示例，要不然根本无法体现出 优化前和优化后 的区别。&lt;/p>
&lt;p>激动人心的时刻到了。&lt;/p>
&lt;h4 id="本文我们的目标制作并优化一个显示地球人口人数分布的可视化-3d-地球">本文我们的目标：制作并优化一个显示地球人口人数分布的可视化 3D 地球&lt;/h4>
&lt;p>你可以先访问以下网址，先感受一下我们本文要模仿的效果：&lt;/p>
&lt;p>&lt;a href="https://globe.chromeexperiments.com/" target="_blank" rel="noopener">https://globe.chromeexperiments.com/&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>补充说明：这个网站，是谷歌浏览器为了向大众演示 WebGL 技术而制作的一个演示网页。&lt;/p>
&lt;/blockquote>
&lt;p>我相信你第一次看到这种基于浏览器的 3D 地球数据展示，一定会被震撼到的。&lt;/p>
&lt;p>接下来我们就要逐步分析，找出实现方式。&lt;/p>
&lt;p>&lt;strong>我们先考虑怎么把这个场景实现出来，然后再考虑优化的事。&lt;/strong>&lt;/p>
&lt;h4 id="核心模块分析">核心模块分析&lt;/h4>
&lt;p>我们要先搞明白这个 3D 数字地球的核心模块。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>3D 地球&lt;/p>
&lt;blockquote>
&lt;p>就是一个球体，添加一个地球纹理图片&lt;/p>
&lt;blockquote>
&lt;p>图片为一个矩形地球展开图，本示例使用的地球纹理图片资源：&lt;br>
&lt;a href="https://threejsfundamentals.org/threejs/resources/images/world.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/world.jpg&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>表示人口多少的柱状物&lt;/p>
&lt;blockquote>
&lt;p>某个地区人口多则柱状物就比较高，反之人口少则柱状物比较低&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>鼠标可交互&lt;/p>
&lt;blockquote>
&lt;p>这个直接使用 OrbitControls 就可以
只不过本示例只允许左右、上下拖拽查看，但不允许修改镜头轨道的远近距离&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>上面的核心模块 1 、3 都很容易实现，重点我们进一步拆解一下 “表示人口多少的柱状物”。&lt;/p>
&lt;h4 id="如何实现表示人口多少的柱状物">如何实现“表示人口多少的柱状物”？&lt;/h4>
&lt;p>我们通过以下 3 个灵魂追问，来梳理思路。&lt;/p>
&lt;p>&lt;strong>第 1 问：人口数据从哪里来？&lt;/strong>&lt;/p>
&lt;p>原网页提供 3 个年份的人口数量统计，分别是 1990、1995、2000 年。&lt;/p>
&lt;p>美国国家航天局(NASA)提供的统计结果介绍页：
&lt;a href="https://sedac.ciesin.columbia.edu/data/set/gpw-v4-admin-unit-center-points-population-estimates-rev11/data-download" target="_blank" rel="noopener">https://sedac.ciesin.columbia.edu/data/set/gpw-v4-admin-unit-center-points-population-estimates-rev11/data-download&lt;/a>&lt;/p>
&lt;p>请注意，该页面还提供最近年份的统计结果，但是下载时候提示需要注册。&lt;/p>
&lt;p>我们选择不使用最新的 2020 年数据，而是使用 2010 年的结果。&lt;/p>
&lt;p>为了方便你获得到 2010 年男性人口统计结果，你可以直接点击下面这个地址，直接下载：&lt;/p>
&lt;p>&lt;a href="https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>反正我们本文的重点是模仿效果，至于数据时效性不必纠结&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>该人口统计数据文件格式为 .asc，至于如何解析该文件，我们会稍后讲解&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>为啥是男性人口统计？女性人口呢？为什么不是全部人口统计呢？&lt;br>
因为在下一篇文章中，就会有女性人口统计，然后做出同一个地区 男女人口数量比较 的动画&lt;br>
为了简化，本文下面文字中，将忽略 “男性人口数量” 这个概念，统一称呼为 “人口数据”&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>第 2 问：人口数据和地区的对应关系，如何表现在地球上？&lt;/strong>&lt;/p>
&lt;p>我们把刚才下载得到的人口统计数据文件，重命名为 gpw_v4_014mt_2010.asc，然后将该文件移动到：src/assets/data/ 目录中。&lt;/p>
&lt;p>点击该文件，用记事本查看该文件内容，你会发现里面大致为以下内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>ncols 360
nrows 145
xllcorner -180
yllcorner -60
cellsize 0.99999999999994
NODATA_value -9999
-9999 -9999 -9999 -9999 -9999 -999...
...
...
&lt;/code>&lt;/pre>&lt;p>这里面的数据内容为：&lt;strong>矩形地球地图上，不同点(经纬度)对应的数值(人口数量)&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>补充：这里面的人口数量值并不是具体人口数量(比如 45932551 个人)，而是具有一定比例单位的值(例如 458.6)&lt;/p>
&lt;p>具体单位值对应的人口我还不清楚，或许是 万，也或许是百万，不过不影响我们本示例，你只需把他当成数字即可&lt;/p>
&lt;/blockquote>
&lt;p>我们需要将数据与地图纹理图片进行点对点的位置匹配。&lt;/p>
&lt;blockquote>
&lt;p>.asc 后缀的文件有特别多种用途和场景，我们这里提到的 .asc 文件是指：以 &lt;code>PGP (Pretty Good Privacy) ASCII Armored File&lt;/code>形式存在的栅格化结构的数据文件。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;strong>.asc 栅格化结构的数据文件说明：&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>对应含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ncols(number colos)&lt;/td>
&lt;td>表示该数据内容有多少列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>nrows(number rows)&lt;/td>
&lt;td>表示该数据内容有多少行&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>xllcorner(x-low-left-corner)&lt;/td>
&lt;td>栅格的左下角坐标 x 的值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>yllcorner(y-low-left-corner)&lt;/td>
&lt;td>栅格的左下角坐标 y 的值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cellsize(cell size)&lt;/td>
&lt;td>每个单元格元的尺寸&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NODATA_value&lt;/td>
&lt;td>单元格内没有值时对应的值&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>你可以把 .asc 文件 想象成一个数据表格，每个单元格为一项，nrows 行 ncols 列 个单元格构建成了一个 数据网格。&lt;/p>
&lt;p>除了 .asc 开头的属性值键对外，后面的就是依次填入数据单元网格中的数据。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;p>&lt;strong>第 3 问：根据人口多少，如何创建对应的柱状物？&lt;/strong>&lt;/p>
&lt;p>当得到地球某个经纬度(地球纹理图片上的某个坐标)上对应的人口数据后，就可以根据人口数量按照一定比例，创建柱状物。&lt;/p>
&lt;p>原理讲过后，那接下来就是实际操作了。&lt;/p>
&lt;h2 id="基础示例helloearth">基础示例：HelloEarth&lt;/h2>
&lt;p>接下来，将通过以下几个步骤，逐步实现我们的目标示例。&lt;/p>
&lt;p>&lt;strong>特别说明：&lt;/strong>&lt;/p>
&lt;p>以下几个步骤中的代码，重点是向你讲解具体的功能和思路，并不是最终的代码。&lt;/p>
&lt;p>最终完整的示例代码中，会对这些每个步骤中的代码进行新的组织。&lt;/p>
&lt;h4 id="第-1-步加载人口数据文件gpw_v4_014mt_2010asc">第 1 步：加载人口数据文件(gpw_v4_014mt_2010.asc)&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>数据文件路径为 ./src/assets/data/gpw_v4_014mt_2010.asc&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>由于我们使用 alias 来得到 .asc 文件编译后的路径，所以请记得：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>tsconfig.pahts.json 的 paths 中添加 &lt;code>&amp;quot;@/assets/*&amp;quot;: [&amp;quot;./src/assets/*&amp;quot;]&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>global.d.ts 中添加 &lt;code>declare module '*.asc';&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以上 2 处均配置正确后，才可以让我们在代码中方便使用 &lt;code>require('@/assets/xx/xx.asc').default&lt;/code> 来获取 .asc 资源的路径&lt;/p>
&lt;blockquote>
&lt;p>假设你并不是使用 react + typescript + alias，那么你可以忽略我提到的配置，直接请求一个固定的网络资源(.asc 文件)就好了。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>通过 window.fetch() 这个函数来获取 .asc 文件内容&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>我们这里没有使用 xhr 或 axios 来请求获取文件资源，而是使用了 fetch 这个 Web API&lt;/p>
&lt;p>关于 fetch 的用法，请参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>具体的代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const loadDataFile = async (url: string) =&amp;gt; {
try {
const res = await window.fetch(url)
const text = await res.text() // text 就是 .asc 文件里的内容
} catch (error) {
console.log(&amp;#39;加载数据出错&amp;#39;)
}
}
const ascURL = require(&amp;#39;@/assets/data/gpw_v4_014mt_2010.asc&amp;#39;).default
loadDataFile(ascURL)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>额外说一个事情，本文对应的是 Three.js 官方教程 &lt;a href="https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects.html" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects.html&lt;/a>&lt;/p>
&lt;p>我在阅读英文原文时，当时他代码中使用的是：&lt;/p>
&lt;pre tabindex="0">&lt;code>async function loadFile(url) {
const req = await fetch(url);
return req.text();
}
&lt;/code>&lt;/pre>&lt;p>我认为不应该将返回值使用变量 req(request)，而应该是 res(response)，于是我就提交了一个合并请求(PR)，然后很快就得到 &lt;a href="https://github.com/greggman" target="_blank" rel="noopener">greggman&lt;/a> 的回应，我的 PR 已被合并到 master 中。&lt;/p>
&lt;p>呵，我也顺带成为了这个项目中的一名 贡献者(contributor)。&lt;/p>
&lt;/blockquote>
&lt;h4 id="第-2-步解析人口数据">第 2 步：解析人口数据&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>为了方便我们以后代码提示，我们先使用 TypeScript 定义解析 .asc 数据后的格式&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>type DataType = (number | undefined)[][]
type ASCData = {
data: DataType,
ncols: number,
nrows: number,
xllcorner: number,
yllcorner: number,
cellsize: number,
NODATA_value: number,
max: number,
min: number,
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>data 为栅格化的世界人口数据，一共 nrows 条，每一条是由 ncols 个数字构成&lt;/p>
&lt;p>假设某个点对应有人口数据则值为具体的数字，若没有人口则值为 undefined。&lt;/p>
&lt;p>请记得没有人口数据的值为 undefined，而不是 0。&lt;/p>
&lt;p>max、min 分别为我们添加的自定义属性，用来记录所有地区人口数据中最多和最少的人口数量，以此我们方便计算出 柱状高度比例&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>开始解析 .asc 文件内容，大体步骤如下：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先我们知道 .asc 中每一行对应一条数据，那么就可以使用换行符 &amp;lsquo;\n&amp;rsquo; 来分隔出每一条数据，然后针对每一条数据进行解析&lt;/p>
&lt;pre tabindex="0">&lt;code>text.split(&amp;#39;\n&amp;#39;).forEach((line) =&amp;gt; { ... })
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>被分隔出来的每一行数据，再进一步转化和分析：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>由于可能存在多个连续空格，因此我们对每一条数据，再通过正则表达式 &lt;code>/\s+/&lt;/code> 进一步分隔&lt;/p>
&lt;pre tabindex="0">&lt;code>// 在正则表达式 ‘/\s+/’ 中 s 表示为空格，+ 表示 1个或多个
const parts = line.trim().split(/\s+/)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>位于 .asc 文件开头，描述栅格化数据的一些属性，例如 ncols、nrows&amp;hellip;，这些数据的结构为：&lt;code>属性名 + 空格 + 值&lt;/code> 构成的&lt;/p>
&lt;pre tabindex="0">&lt;code>if (parts.length === 2) { ... }
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>位于 .asc 文件中间，一行行，一条条具体的数据值，这些数据的结构为：&lt;code>数字 + 空格 + 数字 + ...&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>if (parts.length &amp;gt; 2) { ... }
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>位于 .asc 文件尾部，可能存在的、无用的空白换行，这些空白换行是需要被我们通过条件判断来忽略掉的&lt;/p>
&lt;pre tabindex="0">&lt;code>由于前面已经进行了 length === 2 或 &amp;gt; 2 的判断，那么剩下的就肯定是空白无用的换行，我们什么也不做处理就好。
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>在解析所有人口数据的过程中，我们要不断记录、得出 人口最大数值和最小数值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最终将解析好的数据结果对象，通过 TS 的 as 断言，对外返回出结果&lt;/p>
&lt;/li>
&lt;li>
&lt;p>补充一点：由于我们从 text 中读取到的 “数字” 其实是 字符串，所以在解析过程中都需要使用 parseFloat() 这个函数将 string 转化为 number&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再补充一个细节，在初始化 max 和 min 时：&lt;/p>
&lt;ol>
&lt;li>让 max 初始化值为 0，因为我们知道有人口数据的值一定是大于 0 的&lt;/li>
&lt;li>让 min 初始化值为 99999，因为我们知道一定有人口数据的值一定是小于 99999 的，且人口数量一定不会是负数&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>具体的代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const parseData = (text: string) =&amp;gt; {
const data: (number|undefined)[][] = []
const settings: { [key: string]: any } = { data }
let max:number = 0
let min:number = 99999
text.split(&amp;#39;\n&amp;#39;).forEach((line) =&amp;gt; {
const parts = line.trim().split(/\s+/)
if (parts.length === 2) {
settings[parts[0]] = parseFloat(parts[1])
} else if(parts.length &amp;gt; 2) {
const values = parts.map((item) =&amp;gt; {
const value = parseFloat(item)
if (value === settings[&amp;#39;NODATA_value&amp;#39;]) {
return undefined
}
max = Math.max(max, value)
min = Math.min(min, value)
return value
})
data.push(values)
}
})
return { ...settings, ...{ max, min } } as ASCData
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h4 id="第-3-步加载地球纹理图片">第 3 步：加载地球纹理图片&lt;/h4>
&lt;pre tabindex="0">&lt;code>const loader = new Three.TextureLoader()
const texture = loader.load(require(&amp;#39;@/assets/imgs/world.jpg&amp;#39;).default,render)
const material = new Three.MeshPhongMaterial({
map: texture
})
const geometry = new Three.SphereBufferGeometry(2, 32, 32)
const earth = new Three.Mesh(geometry, material)
scene.add(earth)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意上述代码中，loader.load(xxx, render)，我们希望当纹理图片加载完成后，才执行 render 渲染&lt;/p>
&lt;/blockquote>
&lt;h4 id="第-4-步将人口数据与地球纹理图片进行位置上的匹配">第 4 步：将人口数据与地球纹理图片进行位置上的匹配&lt;/h4>
&lt;p>&lt;strong>先不考虑球体，假设我们仅仅想获得一张显示人口数量分布、平面的世界地图，该如何做呢？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>代码思路：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>我们通过 第 2 步骤已经拿到了栅格化后的世界人口分布数据&lt;/li>
&lt;li>并且我们知道栅格化的数据是由 nrow(145) 行、ncols(360) 列组成&lt;/li>
&lt;li>假设 1 个数据点 对应 1 像素，那么栅格化的数据实际上对应的是一个 高 145 像素、宽 360 像素的图形&lt;/li>
&lt;li>假设 数据点最小(人口最少)的地方，我们用黑色来填充，而数据点最大(人口最多)的地方用红色填充，处于中间数量的点按照比例依次进行颜色变化，那么就可以得到我们想要的图形了。
&lt;ol>
&lt;li>关于某个点填充的颜色，我们使用 HSL(色相、饱和度、亮度)，其中当 人口少时 L 的值越接近于 0 (黑色)、人口多时 L 的值越接近 1 (红色)&lt;/li>
&lt;li>向画布(canvas) 某个点填充颜色，需要用到 canvas 一些相关知识，请自行先学习了解一下 canvas 相关知识&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>对应的代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const hsl = (h: number, s: number, l: number) =&amp;gt; {
return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
}
const drawData = (ascData: ASCData) =&amp;gt; {
if (canvasRef.current === null) { return }
const ctx = canvasRef.current.getContext(&amp;#39;2d&amp;#39;)
if (ctx === null) { return }
const range = ascData.max - ascData.min
ctx.canvas.width = ascData.ncols
ctx.canvas.height = ascData.nrows
ctx.fillStyle = &amp;#39;#444&amp;#39;
ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
ascData.data.forEach((row, rowIndex) =&amp;gt; {
row.forEach((value, colIndex) =&amp;gt; {
if (value === undefined) { return }
const amount = (value - ascData.min) / range
const hue = 1
const saturation = 1
const lightness = amount
ctx.fillStyle = hsl(hue, saturation, lightness)
ctx.fillRect(colIndex,rowIndex,1,1)
})
})
}
&lt;/code>&lt;/pre>&lt;p>为了让你比较直观看清，这里贴出目前我们已经写出来的代码。&lt;/p>
&lt;blockquote>
&lt;p>请注意下面的代码并不是我们真正示例的代码，你可以实际运行以下，查看效果&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
const loadDataFile = async (url: string) =&amp;gt; {
const res = await window.fetch(url)
const text = await res.text()
return text
}
type DataType = (number | undefined)[][]
type ASCData = {
data: DataType,
ncols: number,
nrows: number,
xllcorner: number,
yllcorner: number,
cellsize: number,
NODATA_value: number,
max: number,
min: number,
}
const parseData = (text: string) =&amp;gt; {
const data: DataType = []
const settings: { [key: string]: any } = { data }
let max: number = 0
let min: number = 99999
text.split(&amp;#39;\n&amp;#39;).forEach((line) =&amp;gt; {
const parts = line.trim().split(/\s+/)
if (parts.length === 2) {
settings[parts[0]] = parseFloat(parts[1])
} else if (parts.length &amp;gt; 2) {
const values = parts.map((item) =&amp;gt; {
const value = parseFloat(item)
if (value === settings[&amp;#39;NODATA_value&amp;#39;]) {
return undefined
}
max = Math.max(max, value)
min = Math.min(min, value)
return value
})
data.push(values)
}
})
return { ...settings, ...{ max, min } } as ASCData
}
const hsl = (h: number, s: number, l: number) =&amp;gt; {
return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
}
const HelloEarth = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
const drawData = (ascData: ASCData) =&amp;gt; {
if (canvasRef.current === null) { return }
const ctx = canvasRef.current.getContext(&amp;#39;2d&amp;#39;)
if (ctx === null) { return }
const range = ascData.max - ascData.min
ctx.canvas.width = ascData.ncols
ctx.canvas.height = ascData.nrows
ctx.fillStyle = &amp;#39;#444&amp;#39;
ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
ascData.data.forEach((row, rowIndex) =&amp;gt; {
row.forEach((value, colIndex) =&amp;gt; {
if (value === undefined) { return }
const amount = (value - ascData.min) / range
const hue = 1
const saturation = 1
const lightness = amount
ctx.fillStyle = hsl(hue, saturation, lightness)
ctx.fillRect(colIndex,rowIndex,1,1)
})
})
}
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const ascURL = require(&amp;#39;@/assets/data/gpw_v4_014mt_2010.asc&amp;#39;).default
const doSomthing = async () =&amp;gt; {
try {
const text = await loadDataFile(ascURL)
const ascData = parseData(text)
drawData(ascData)
} catch (error) {
console.log(error)
}
}
doSomthing()
return () =&amp;gt; {
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} /&amp;gt;
)
}
export default HelloEarth
&lt;/code>&lt;/pre>&lt;p>实际运行后，就会看到一张 世界人口分布的地图&lt;/p>
&lt;blockquote>
&lt;p>请注意这个 “看似是世界地图”的图片并不是真正的世界地理位置地图，而是人口数量分布图。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>如果你已经看懂了上面的代码，那么接下来就可以真正去制作 3D 立体地球示例了。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>本示例是我们做过的最复杂的例子，尽管我们已经进行了详细的思路解读，你一定要多看，多敲几遍，否则接下来的代码你可能更加难以理解。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>我们需要将之前的 drawData() 修改 为 addBoxes()，并且不再是在 canvas 中绘制点，而是在球体上添加柱状物：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const addBoxes = (ascData: ASCData, scene: Three.Scene) =&amp;gt; {
const geometry = new Three.BoxBufferGeometry(1, 1, 1)
geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))
const lonHelper = new Three.Object3D()
scene.add(lonHelper)
const latHelper = new Three.Object3D()
lonHelper.add(latHelper)
const positionHelper = new Three.Object3D()
positionHelper.position.z = 1
latHelper.add(positionHelper)
const range = ascData.max - ascData.min
const lonFudge = Math.PI * 0.5
const latFudge = Math.PI * -0.135
ascData.data.forEach((row, latIndex) =&amp;gt; {
row.forEach((value, lonIndex) =&amp;gt; {
if (value === undefined) { return }
const amount = (value - ascData.min) / range
const material = new Three.MeshBasicMaterial()
const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
const saturation = 1
const lightness = Three.MathUtils.lerp(0.1, 1, amount)
material.color.setHSL(hue, saturation, lightness)
const mesh = new Three.Mesh(geometry, material)
scene.add(mesh)
lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge
positionHelper.updateWorldMatrix(true, false)
mesh.applyMatrix4(positionHelper.matrixWorld)
mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
})
})
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>上面代码中牵扯到了非常多新的、之前从未使用过的一些函数或属性。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>解释说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>栅格化数据 和 纹理图片 均可看作是 2D 矩形坐标，最终需要转化为 3D 球体坐标，转化过程中 lonFudge、latFudge 具体作用机理，暂时还没搞明白。&lt;/p>
&lt;blockquote>
&lt;p>先记住转化公式，以后再慢慢研究&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>栅格化数据 为 360 _ 145、纹理图片为 2048 _ 1024&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Three.Matrix4：WebGL 中的矩阵库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Three.MathUtils：Three.js 中内置的一些计算函数&lt;/p>
&lt;blockquote>
&lt;p>关于这些新的对象具体详细介绍，请查阅 Three.js 官方文档&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>lonHelper 用于赤道上的经度旋转、latHelper 用于维度旋转、positionHelper 用于 Z 轴(地球地面)上的偏移。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>lonFudge 的值为 Math.PI * 0.5，也就是相当于 1/4 个圆(地球 1/4 圈)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>latFudge 的值为 Math.PI * -0.135，这里的 -0.135 不太清楚是怎么得出来的，但是大概率推测它是用来将柱状物与纹理图片对齐的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>示例所需其他代码块：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>创建 3D 地球、以及加载纹理图片&lt;/li>
&lt;li>添加 OrbitControls 控制，并且开启 “弹性结束控制”&lt;/li>
&lt;li>添加场景渲染函数 render，并且添加 “按需渲染” 相关代码&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>最终完整的示例代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const loadDataFile = async (url: string) =&amp;gt; {
const res = await window.fetch(url)
const text = await res.text()
return text
}
type DataType = (number | undefined)[][]
type ASCData = {
data: DataType,
ncols: number,
nrows: number,
xllcorner: number,
yllcorner: number,
cellsize: number,
NODATA_value: number,
max: number,
min: number,
}
const parseData = (text: string) =&amp;gt; {
const data: DataType = []
const settings: { [key: string]: any } = { data }
let max: number = 0
let min: number = 99999
text.split(&amp;#39;\n&amp;#39;).forEach((line) =&amp;gt; {
const parts = line.trim().split(/\s+/)
if (parts.length === 2) {
settings[parts[0]] = parseFloat(parts[1])
} else if (parts.length &amp;gt; 2) {
const values = parts.map((item) =&amp;gt; {
const value = parseFloat(item)
if (value === settings[&amp;#39;NODATA_value&amp;#39;]) {
return undefined
}
max = Math.max(max, value)
min = Math.min(min, value)
return value
})
data.push(values)
}
})
return { ...settings, ...{ max, min } } as ASCData
}
// const hsl = (h: number, s: number, l: number) =&amp;gt; {
// return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
// }
let renderRequested = false
const HelloEarth = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement&amp;gt;(null)
// const drawData = (ascData: ASCData) =&amp;gt; {
// if (canvasRef.current === null) { return }
// const ctx = canvasRef.current.getContext(&amp;#39;2d&amp;#39;)
// if (ctx === null) { return }
// const range = ascData.max - ascData.min
// ctx.canvas.width = ascData.ncols
// ctx.canvas.height = ascData.nrows
// ctx.fillStyle = &amp;#39;#444&amp;#39;
// ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
// ascData.data.forEach((row, rowIndex) =&amp;gt; {
// row.forEach((value, colIndex) =&amp;gt; {
// if (value === undefined) { return }
// const amount = (value - ascData.min) / range
// const hue = 1
// const saturation = 1
// const lightness = amount
// ctx.fillStyle = hsl(hue, saturation, lightness)
// ctx.fillRect(colIndex, rowIndex, 1, 1)
// })
// })
// }
const addBoxes = (ascData: ASCData, scene: Three.Scene) =&amp;gt; {
const geometry = new Three.BoxBufferGeometry(1, 1, 1)
geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))
const lonHelper = new Three.Object3D()
scene.add(lonHelper)
const latHelper = new Three.Object3D()
lonHelper.add(latHelper)
const positionHelper = new Three.Object3D()
positionHelper.position.z = 1
latHelper.add(positionHelper)
const range = ascData.max - ascData.min
const lonFudge = Math.PI * 0.5
const latFudge = Math.PI * -0.135
ascData.data.forEach((row, latIndex) =&amp;gt; {
row.forEach((value, lonIndex) =&amp;gt; {
if (value === undefined) { return }
const amount = (value - ascData.min) / range
const material = new Three.MeshBasicMaterial()
const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
const saturation = 1
const lightness = Three.MathUtils.lerp(0.1, 1, amount)
material.color.setHSL(hue, saturation, lightness)
const mesh = new Three.Mesh(geometry, material)
scene.add(mesh)
lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge
positionHelper.updateWorldMatrix(true, false)
mesh.applyMatrix4(positionHelper.matrixWorld)
mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
})
})
}
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const canvas = canvasRef.current
const renderer = new Three.WebGLRenderer({ canvas })
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.z = 4
const scene = new Three.Scene()
scene.background= new Three.Color(0x000000)
const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true
controls.enablePan =false
controls.update()
const render = () =&amp;gt; {
renderRequested = false
controls.update()
renderer.render(scene, camera)
}
const handleChange =() =&amp;gt;{
if(renderRequested === false){
renderRequested = true
window.requestAnimationFrame(render)
}
}
controls.addEventListener(&amp;#39;change&amp;#39;,handleChange)
const loader = new Three.TextureLoader()
const texture = loader.load(require(&amp;#39;@/assets/imgs/world.jpg&amp;#39;).default, render)
const material = new Three.MeshBasicMaterial({
map: texture
})
const geometry = new Three.SphereBufferGeometry(1, 64, 32)
const earth = new Three.Mesh(geometry, material)
scene.add(earth)
const handleResize = () =&amp;gt; {
const width = canvas.clientWidth
const height = canvas.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
window.requestAnimationFrame(render)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
const ascURL = require(&amp;#39;@/assets/data/gpw_v4_014mt_2010.asc&amp;#39;).default
const doSomthing = async () =&amp;gt; {
try {
const text = await loadDataFile(ascURL)
const ascData = parseData(text)
//drawData(ascData)
addBoxes(ascData, scene)
render()
} catch (error) {
console.log(error)
}
}
doSomthing()
return () =&amp;gt; {
controls.removeEventListener(&amp;#39;change&amp;#39;,handleChange)
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloEarth
&lt;/code>&lt;/pre>&lt;p>调试运行，首先就会看到一个 3D 立体地球，等待 1 秒左右，待 .asc 数据加载并解析、添加地球上的柱状物后，就会看到本示例所想演示的最终效果。&lt;/p>
&lt;blockquote>
&lt;p>终于终于到这一步了&lt;/p>
&lt;/blockquote>
&lt;p>不过当你鼠标拖动地球时，会感受到略微卡顿，或者说不够流畅。&lt;/p>
&lt;p>那么接下来，就到了本文的核心内容：通过 合并对象 来达到优化场景的目的。&lt;/p>
&lt;h4 id="补充启用浏览器-调试工具-devtool-的-rendering-查看渲染性能">补充：启用浏览器 调试工具 DevTool 的 Rendering 查看渲染性能&lt;/h4>
&lt;p>除了浏览器本身的 性能(Performance) 面板外，还有另外一个重要的、方便我们查看页面渲染性能的工具——Rendering。&lt;/p>
&lt;p>&lt;strong>通过谷歌调试工具 Rendering，查看当前页面渲染性能情况：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>打开浏览器调试工具 DevTool&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击右侧 3 个小圆点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>鼠标移动到 More tools&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击 Rendering&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在新出现的 Rendering 面板中，勾选 Frame Rendering Stats&lt;/p>
&lt;blockquote>
&lt;p>备注：在旧的谷歌浏览器中，应该勾选的是 Show FPS meter&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>这样就可以在网页左上角，实时看到当前渲染性能状况。&lt;/p>
&lt;p>&lt;strong>性能数据解读：&lt;/strong>&lt;/p>
&lt;p>性能展示的数据，主要 2 个模块：Frames 和 GPU&lt;/p>
&lt;p>&lt;strong>GPU 相关：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>GPU raster ：on 表示 GPU 光栅化已开启&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GPU memory：GPU 已用大小、GPU 最大可用大小&lt;/p>
&lt;blockquote>
&lt;p>在本示例中，通常是当修改浏览器尺寸时，此时需要大量计算，会显示出 GPU memory&lt;/p>
&lt;p>在普通的 鼠标拖拽 改变地球视角时，不会显示 GPU memory&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Frames 相关：&lt;/strong>&lt;/p>
&lt;p>假设某一时刻，渲染性能结果为 Frames：63% 1082(0m) dropped of 2737&lt;/p>
&lt;p>对应的解读为：&lt;/p>
&lt;p>第 1 个数字 63% —— 63% 的帧按时渲染完成&lt;/p>
&lt;p>第 2 个数字 1082 —— 有 1082 个合成帧丢失(未渲染)&lt;/p>
&lt;p>第 3 个数字 0m —— 有 0 个帧丢失&lt;/p>
&lt;p>第 4 个数字 2737 —— 原本计划渲染 2737 个帧&lt;/p>
&lt;p>数字之间的计算关系为 63% ≈ 1 - (1082 + 0 )/ 2737&lt;/p>
&lt;p>也就是说 第 2 个数字(丢失的合成帧)越小，那么整体按时完成渲染帧的百分比(第 1 个数字)越大，意味着此刻网页越流畅。&lt;/p>
&lt;h2 id="优化代码合并对象">优化代码：合并对象&lt;/h2>
&lt;h4 id="核心代码分析">核心代码分析&lt;/h4>
&lt;p>在上面的示例代码中，lonHelper 用于赤道上的经度旋转、latHelper 用于维度旋转、positionHelper 用于 Z 轴(地球地面)上的偏移。&lt;/p>
&lt;blockquote>
&lt;p>默认 Three.js 中物体是有 1/2 位于 Z 轴之下的，通过 Z 轴的偏移让柱状物可以完全出现在地面上&lt;/p>
&lt;/blockquote>
&lt;p>每一个数据点(柱状物)都创建了一个 MeshBasicMaterial 和 Mesh。&lt;/p>
&lt;p>我们的数据点一共为 145 行、360 列，那么就意味着假设全部数据点都有数据，那么数据点总数量为：145 * 360 = 52200，但是考虑到有非常多的数据点的值为 -9999(NODATA_value)，也就是没有值，不需要绘制，那么减去这些没有数据点，&lt;strong>最终需要绘制的数据点(柱状物)大约为 19000 个&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>柱状物 19000 个，再加上对应的 3 个辅助对象(lonHelper、latHelper、positionHelper)，相当于总绘制数量为 19000 * 4 = 76000。&lt;/strong>&lt;/p>
&lt;p>也就是说每一次场景更新，大约需要绘制 7.6 万个对象，所以这才造成了卡顿现象。&lt;/p>
&lt;p>&lt;strong>如何解决卡顿？减少需要渲染对象的数量！&lt;/strong>&lt;/p>
&lt;p>还记得我们刚才统计的渲染对象数量吗？&lt;/p>
&lt;ol>
&lt;li>柱状体 约 19000 个&lt;/li>
&lt;li>每个柱状体对应 3 个辅助对象 19000 * 3&lt;/li>
&lt;/ol>
&lt;p>我们需要做的就是把所有的柱状体合并成一个物体，也就是说原本需要渲染 19000 个柱状体，合并之后只需渲染 1 个，让柱状体数量减少 18999 个。&lt;/p>
&lt;p>&lt;strong>修改 addBoxes 函数代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { BufferGeometryUtils } from &amp;#39;three/examples/jsm/utils/BufferGeometryUtils&amp;#39;
const addBoxes = (ascData: ASCData, scene: Three.Scene) =&amp;gt; {
//const geometry = new Three.BoxBufferGeometry(1, 1, 1)
//geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))
const lonHelper = new Three.Object3D()
scene.add(lonHelper)
const latHelper = new Three.Object3D()
lonHelper.add(latHelper)
const positionHelper = new Three.Object3D()
positionHelper.position.z = 1
latHelper.add(positionHelper)
const originHelper = new Three.Object3D()
originHelper.position.z = 0.5
positionHelper.add(originHelper)
const range = ascData.max - ascData.min
const lonFudge = Math.PI * 0.5
const latFudge = Math.PI * -0.135
const geometries: Three.BoxBufferGeometry[] = []
const color = new Three.Color()
ascData.data.forEach((row, latIndex) =&amp;gt; {
row.forEach((value, lonIndex) =&amp;gt; {
if (value === undefined) { return }
const amount = (value - ascData.min) / range
//const material = new Three.MeshBasicMaterial()
//const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
//const saturation = 1
//const lightness = Three.MathUtils.lerp(0.1, 1, amount)
//material.color.setHSL(hue, saturation, lightness)
//const mesh = new Three.Mesh(geometry, material)
//scene.add(mesh)
const geometry = new Three.BoxBufferGeometry(1, 1, 1)
lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge
//positionHelper.updateWorldMatrix(true, false)
//mesh.applyMatrix4(positionHelper.matrixWorld)
//mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
positionHelper.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.01, 0.5, amount))
originHelper.updateWorldMatrix(true, false)
geometry.applyMatrix4(originHelper.matrixWorld)
const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
const saturation = 1
const lightness = Three.MathUtils.lerp(0.1, 1, amount)
color.setHSL(hue, saturation, lightness)
const rgb = color.toArray().map((value) =&amp;gt; {
return value * 255
})
const numVerts = geometry.getAttribute(&amp;#39;position&amp;#39;).count
const itemSize = 3
const colors = new Uint8Array(itemSize * numVerts)
//这里有一个稍微奇葩点的写法，就是使用下划线 _ 来起到参数占位的作用
colors.forEach((_, index) =&amp;gt; {
colors[index] = rgb[index % 3]
})
const normalized = true
const colorAttrib = new Three.BufferAttribute(colors, itemSize, normalized)
geometry.setAttribute(&amp;#39;color&amp;#39;, colorAttrib)
geometries.push(geometry)
})
})
const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries)
//const material = new Three.MeshBasicMaterial({ color: &amp;#39;red&amp;#39; })
const material = new Three.MeshBasicMaterial({
vertexColors: true
})
const mesh = new Three.Mesh(mergedGeometry, material)
scene.add(mesh)
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>上述代码中，注释部分为之前 addBoxes() 函数的代码，除了 //const material = new Three.MeshBasicMaterial({ color: &amp;lsquo;red&amp;rsquo; }) 这一行&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>代码解析：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>合并所有的柱状物，使用到了一个新的函数 BufferGeometryUtils.mergeBufferGeometries()&lt;/p>
&lt;blockquote>
&lt;p>注意：BufferGeometryUtils 并非来自 Three，而是来自 &amp;rsquo;three/examples/jsm/utils/BufferGeometryUtils&amp;rsquo;&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>柱状物的颜色，不再使用 color 设定，而是启用了 “顶点着色”。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>关于这 2 个大的知识点，可以去阅读 Three.js 官方文档&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>需要恶补官方文档，如果只是看了本教程，那么还会有大量的知识点未曾接触。&lt;/p>
&lt;/blockquote>
&lt;p>经过合并优化后的场景，在浏览器中运行，比之前的流畅非常多，没有卡顿的现象了。&lt;/p>
&lt;blockquote>
&lt;p>我本机电脑硬件配置比较高，我分别记录了 Rendering 面板中 优化前后的 Frames 值。&lt;/p>
&lt;p>优化前：顺利渲染帧的百分比约为 60%&lt;/p>
&lt;p>优化后：顺利渲染帧的百分比约为 90%&lt;/p>
&lt;p>可见网页流畅度确实提高了很多&lt;/p>
&lt;/blockquote>
&lt;h4 id="本文小结">本文小结：&lt;/h4>
&lt;p>&lt;strong>在 Three.js 大型的场景中，绝大多数都需要采用合并对象的策略来优化渲染性能。&lt;/strong>&lt;/p>
&lt;p>合并对象可以减少需要渲染的对象数量，并且还可以将有一些根本不可见的面进行删除，减少渲染面，提高渲染性能。&lt;/p>
&lt;p>你以为就这样可以结束了？&lt;/p>
&lt;p>事实上还有优化空间，本文先到这里结束。&lt;/p>
&lt;p>下一篇将继续优化这个场景。&lt;/p></description></item><item><title>21.Three.js 优化之合并对象的动画</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/21.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E7%94%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/21.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E7%94%BB/</guid><description>&lt;h1 id="21-threejs-优化之合并对象的动画">21 Three.js 优化之合并对象的动画&lt;/h1>
&lt;p>在上一篇中，我们将 19000 个柱状对象合并为 1 个整体，这样优化过后渲染速度性能大幅提高。&lt;/p>
&lt;p>但是，我们所加载的是 2010 年 全球男性人口数量统计。&lt;/p>
&lt;p>&lt;strong>假设现在我们添加新的需求：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>加载并显示全球女性人口数量&lt;/li>
&lt;li>此时，我们程序中 男性与女性 各有 1 份数据&lt;/li>
&lt;li>我们需要做的动画就是：当切换 不同性别数据时，柱状物也会随着人口数量不同而发生 高低 变化的动画&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>不同性别的人口数据 .asc 文件下载：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>男性：https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc&lt;/li>
&lt;li>女性：https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014ft_2010_cntm_1_deg.asc&lt;/li>
&lt;/ol>
&lt;p>很显然，之前把所有柱状物都合并成 1 个整体之后，是没有办法单独操作某一个柱状物的。&lt;/p>
&lt;p>想实现每一个柱状物高低变化的动画，又该如何实现呢？&lt;/p>
&lt;h4 id="实现方式">实现方式：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>通过 设置物体材质的 morphtargets(变形目标) 属性为 true 来改变柱状物形状&lt;/p>
&lt;pre tabindex="0">&lt;code> const material = new THREE.MeshBasicMaterial({
vertexColors: true,
morphTargets: true,
})
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>通过 Tween.js 来创建改变过程中的动画&lt;/p>
&lt;pre tabindex="0">&lt;code>import { TWEEN } from &amp;#39;three/examples/jsm/libs/tween.module.min.js&amp;#39;
或者自己去安装 tween.js 的模块
yarn add @tweenjs/tween.js
//npm i @tweenjs/tween.js --save
import TWEEN from &amp;#39;@tweenjs/tween.js&amp;#39;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Tween.js 的用法，请参考官网：https://github.com/tweenjs/tween.js&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>通过材质的 Material.onBeforeCompile() 函数来产生改变过程中柱状物颜色的变化&lt;/p>
&lt;blockquote>
&lt;p>Material.onBeforeCompile() 的用法，请参考文档：https://threejs.org/docs/index.html#api/zh/materials/Material.onBeforeCompile&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h4 id="具体代码">具体代码&lt;/h4>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>上面仅仅是提供了解决思路，而实际具体的代码复杂程度，超出了我目前的认知。&lt;/p>
&lt;p>所以我们暂且搁置，所有能力的同学，可自行查看本文对应的原版教程：&lt;/p>
&lt;p>&lt;a href="https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects-animated.html" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects-animated.html&lt;/a>，&lt;/p>
&lt;p>将来有一天 Three.js 能力提高了，再来弥补上。&lt;/p>
&lt;p>下一节，我们学习另外一个可以提升计算性能的方式：使用 WebWorker。&lt;/p></description></item><item><title>22.Three.js 优化之OffscreenCanvas与WebWorker</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/22.three.js-%E4%BC%98%E5%8C%96%E4%B9%8Boffscreencanvas%E4%B8%8Ewebworker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/22.three.js-%E4%BC%98%E5%8C%96%E4%B9%8Boffscreencanvas%E4%B8%8Ewebworker/</guid><description>&lt;h1 id="22-threejs-优化之-offscreencanvas-与-webworker">22 Three.js 优化之 OffscreenCanvas 与 WebWorker&lt;/h1>
&lt;p>我们知道 JS 是单线程，可以通过 WebWorker 将一些复杂计算执行命令从主线程中分离出来。&lt;/p>
&lt;p>关于 WebWorker 的使用方法，请参考：&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/zh-cn/docs/web/api/web_workers_api/using_web_workers" target="_blank" rel="noopener">https://developer.mozilla.org/zh-cn/docs/web/api/web_workers_api/using_web_workers&lt;/a>&lt;/p>
&lt;p>或者查看我写的另外一篇文章：&lt;a href="https://github.com/puxiao/notes/blob/master/WebWorker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">WebWorker 学习笔记.md&lt;/a>&lt;/p>
&lt;br>
&lt;p>一些比较新的浏览器(例如谷歌浏览器) 还有另外一个和 WebWorker 搭配使用、针对画布的类：OffscreenCanvas。&lt;/p>
&lt;p>&lt;strong>OffscreenCanvas 的作用就是将 canvas 的控制权转让给 Web Worker。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>因此 OffscreenCanvas 必须搭配 Web Worker 一起使用。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>补充一个知识点：&lt;/p>
&lt;p>和 OffscreenCanvas 类似的还有 ArrayBuffer、 MessagePort、ImageBitmap，他们都可以与 WebWorker 搭配使用&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h2 id="offscreencanvas-的概念和用法">OffscreenCanvas 的概念和用法&lt;/h2>
&lt;h4 id="offscreencanvas-的基本概念">OffscreenCanvas 的基本概念&lt;/h4>
&lt;p>你可以把 WebWorker 做为各种复杂类型的后台运算线程，作用范围比较广泛。&lt;/p>
&lt;p>而 OffscreenCanvas 则专门针对 Canvas 做离屏渲染。&lt;/p>
&lt;blockquote>
&lt;p>注意，这里提到的 离屏渲染 和 我们使用 WebGLRendererTarget 来做的离屏渲染，从概念上是类似的&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>OffscreenCanvas 的 “离屏” 是指浏览器 DOM 而言&lt;/p>
&lt;p>WebGLRenderTarget 的 “离屏” 只指 Three.js 的主场景(Scene) 而言&lt;/p>
&lt;/blockquote>
&lt;p>你可以把 OffscreenCanvas 看作是针对 Canvas 的特殊 WebWorker 应用场景。&lt;/p>
&lt;p>但是请记得：目前绝大多数浏览器均已支持 WebWorker，但是对 OffscreenCanvas 的支持度并不高。&lt;/p>
&lt;br>
&lt;p>&lt;strong>如何创建 OffscreenCanvas ？&lt;/strong>&lt;/p>
&lt;p>不可以使用 new OffscreenWorker() 的方式来创建 OffscreenCanvas，而是使用 canvas.transferControlToOffscreen() 来获得 canvas 对应的 OffscreenCanvas。&lt;/p>
&lt;br>
&lt;p>&lt;strong>如何检测当前浏览器是否支持 OffscreenCanvas？&lt;/strong>&lt;/p>
&lt;p>我们只需检查 canvas 是否存在 transferControlToOffscreen 方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>if(canvas.transferControlToOffscreen !== null){
console.log(&amp;#39;当前浏览器支持 OffscreenCanvas&amp;#39;)
}else{
console.log(&amp;#39;当前浏览器不支持 OffscreenCanvas&amp;#39;)
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>我们是通过检查 canvas 对象上是否包含 .transferControlToOffscreen 方法来判断是否当前浏览器支持 OffscreenCanvas 的。&lt;/p>
&lt;p>这里补充一个 JS 知识，如何判断某个对象上是否有某个属性。&lt;/p>
&lt;p>假设有一个对象&lt;/p>
&lt;pre tabindex="0">&lt;code>const obj = {
a:undefined,
b:null
}
&lt;/code>&lt;/pre>&lt;p>此时我们使用 if(obj.a) 或 if(obj.b) 都是无法准确判断出到底 属性 a、b 是否存在。&lt;/p>
&lt;p>那么这个时候就可以使用以下 2 种方式来进行判断：&lt;/p>
&lt;pre tabindex="0">&lt;code>if(&amp;#39;a&amp;#39; in obj) { ... }
if(Reflect.has(obj,&amp;#39;b&amp;#39;)){ ... }
&lt;/code>&lt;/pre>&lt;p>使用 in 或者 Reflect.has() 就可以准确判断出对象上是否具有某属性或方法，即使该属性的值为 undefined&lt;/p>
&lt;blockquote>
&lt;p>注意：上面 2 种查询方式都需要属性名的字符串值，为了更好的语法提示，我们示例中并不这样用。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;br>
&lt;h4 id="offscreencanvas-的用法">OffscreenCanvas 的用法&lt;/h4>
&lt;blockquote>
&lt;p>再次强调：通常情况下 OffscreenCanvas 必须搭配 Web Worker 一起使用。&lt;/p>
&lt;/blockquote>
&lt;p>我们单独创建一个 JS 文件，将 canvas 绘制的一些 JS 代码写在这个文件中。&lt;/p>
&lt;p>&lt;strong>大体步骤：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建一个单独的 JS 文件，用来编写 Three.js 场景内容和渲染代码&lt;/p>
&lt;blockquote>
&lt;p>会以这个 JS 文件来作为 web worker 的调用文件对象&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在主场景中，获得 DOM 中的 canvas&lt;/p>
&lt;/li>
&lt;li>
&lt;p>获取 canvas 对应的 OffscreenCanvas&lt;/p>
&lt;pre tabindex="0">&lt;code>const offscreen = canvas.transferCountrolToOffscreen()
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>创建一个 worker 对象，并且设置一些消息参数&lt;/p>
&lt;pre tabindex="0">&lt;code>const worker = new Window.Worker(&amp;#39;xx/xxxx.js&amp;#39;,{type:&amp;#39;module&amp;#39;})
worker.postMessage({type:&amp;#39;main&amp;#39;,canvas:offscreen},[offscreen])
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>由于 web worker 不允许访问 DOM 事件，例如浏览器窗口尺寸改变事件、鼠标事件等，所以当这些事件发生后，我们需要通知 worker，将事件对应的一些参数和变动发送给 worker，以便 worker 中的 canvas 渲染逻辑作出对应的响应。&lt;/p>
&lt;blockquote>
&lt;p>窗口尺寸改变事件我们还比较容易解决，无非就是把新的尺寸发送给 worker，比较难的是像 鼠标事件、键盘事件等，需要稍微复杂的一些传递方式才可以解决。&lt;/p>
&lt;p>在本文后半部分会有详细讲解。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>实际差异：&lt;/strong>&lt;/p>
&lt;p>刚才将的是理论上大体步骤，但是由于我们本教程的示例代码，实际上是运行在 React + TypeScript 环境上的，也就是说我们需要编写的是 worker.ts 而不是 worker.js。&lt;/p>
&lt;blockquote>
&lt;p>当然你也可以采取在编写 worker 时使用 .js 而不是 .ts，只不过这样就失去了 TypeScript 的便利性。&lt;/p>
&lt;/blockquote>
&lt;p>我们推荐的解决方案是使用 webpack 的插件：worker-loader 来解决 react + typescript 环境中编写 worker。&lt;/p>
&lt;p>具体的配置步骤，请参考我写的另外一篇文章：&lt;a href="https://github.com/puxiao/notes/blob/master/WebWorker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#React%E5%86%85%E5%B5%8CWebWorker%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">React 内嵌 WebWorker 代码&lt;/a>&lt;/p>
&lt;p>接下来，我们将通过一个实际的例子，来演示一遍 OffscreenCanvas + Worker。&lt;/p>
&lt;br>
&lt;h2 id="离屏画布渲染示例hellooffscreencanvas">离屏画布渲染示例：HelloOffscreenCanvas&lt;/h2>
&lt;p>假设你已经配置好了 worker-loader，那么我们开始本示例。&lt;/p>
&lt;br>
&lt;h4 id="示例目标">示例目标：&lt;/h4>
&lt;ol>
&lt;li>场景上有 3 个不同颜色，不断旋转的立方体&lt;/li>
&lt;li>我们将场景中的渲染工作，从主程序中抽离出去，让 Web Worker 来负责场景的渲染工作，依次来减轻主程序的运算负担。&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>我们场景中动画渲染本身计算量并不是很大，即使我们不使用 web worker 浏览器也不会卡顿，但本示例只是为了演示如何使用 OffscreenCanvas + Worker。&lt;/li>
&lt;li>我们先假设你的浏览器是支持 OffscreenCanvas 的。&lt;/li>
&lt;/ol>
&lt;br>
&lt;h4 id="关键点说明">关键点说明：&lt;/h4>
&lt;p>默认 主程序(index.tsx 或 index.ts) 与 分线程(Worker.ts) 彼此通过 .postMessage() 互相发送数据。&lt;/p>
&lt;p>而 .postMessage() 默认发送的数据是深拷贝，而不是引用。&lt;/p>
&lt;blockquote>
&lt;p>因为本质上 index.tsx 和 worker.ts 就不在同一个线程中，无法共享数据&lt;/p>
&lt;p>支持共享数据的 SharedWorker 目前浏览器支持度还不够高。&lt;/p>
&lt;/blockquote>
&lt;p>假设我们是把场景渲染的计算工作转移到了 worker.ts 中，但是 worker.ts 每次计算好 canvas 画面内容后再发送给 index.tsx，每次都执行一次深拷贝，性能反而低下。&lt;/p>
&lt;blockquote>
&lt;p>Web Worker 本身是无法访问 DOM 元素的&lt;/p>
&lt;/blockquote>
&lt;p>幸好 .postMessage() 方法的第 2 个参数，允许我们将一些数据类型比较大的对象，直接将控制权转移给 worker.ts。&lt;/p>
&lt;p>&lt;strong>也就是说，OffscreenCanvas + Worker 不是走以下流程：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>worker.ts 负责创建 Three.js 场景和物体&lt;/li>
&lt;li>worket.ts 负责渲染得到 场景画面数据&lt;/li>
&lt;li>worket.ts 通过 .postMessage() 将离屏渲染得到的 画布画面内容数据 发送给 index.tsx&lt;/li>
&lt;li>index.tsx 接收 画布画面内容数据 并渲染到 canvas DOM 中&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>而是走以下流程：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>index.tsx 通过 canvas.transferToOffscreenCanvas() 得到 OffscreenCanvas&lt;/li>
&lt;li>index.tsx 通过 .postMessage() 第 2 个参数，将 [OffscreenCanavs] 传递给 worker.ts，也就是说将 canvas 的控制权完全交给 worker.ts&lt;/li>
&lt;li>接下来就是 worker.ts 负责创建 Three.js 场景和物体，并且渲染场景画面内容直接赋予给 OffscreenCanavas。&lt;/li>
&lt;/ol>
&lt;br>
&lt;h4 id="其他补充">其他补充：&lt;/h4>
&lt;p>由于 worker 本身无法获取 DOM ，以及无法获取浏览器某些事件，例如浏览器的窗口大小变动事件。&lt;/p>
&lt;p>所以当浏览器窗口尺寸发生变化后，我们要让 index.tsx 及时通知 worker.ts 新的浏览器窗口宽高，以便让 worker.ts 作出相应的调整。&lt;/p>
&lt;blockquote>
&lt;p>与窗口尺寸改变相似的还有鼠标移动事件，也可以通过传递当前鼠标坐标位置传递给 Worker 以便做出相应的处理。后期我们会学习如何做场景物体拾取效果，就是鼠标放到某个物体上时物体做出相应变化，这种场景就会需要用到鼠标坐标。&lt;/p>
&lt;/blockquote>
&lt;p>接下来，就开始具体编写代码吧。&lt;/p>
&lt;br>
&lt;h4 id="message-datats">message-data.ts&lt;/h4>
&lt;blockquote>
&lt;p>src/components/hello-offscreen-canvas/message-data.ts&lt;/p>
&lt;/blockquote>
&lt;p>message-data.ts 的作用是定义一些参数名、参数值的类型，以便我们获得好的 TS 语法提示。&lt;/p>
&lt;blockquote>
&lt;p>注意：message-data.ts 会同时被 index.tsx 和 worker.ts 引入，这样做的效果是：&lt;/p>
&lt;ol>
&lt;li>index.tsx 可以比较容易知道 worker.ts 内部定义的函数名叫什么&lt;/li>
&lt;li>worker.ts 可以比较容易知道 index.tsx 传递过来的参数类型是什么&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>//定义画布的尺寸类型数据结构
export type CanvasSize = {
width: number,
height: number
}
export enum WorkerFunName {
main = &amp;#39;main&amp;#39;,
updateSize = &amp;#39;updateSize&amp;#39;
}
//定义 MessageEvent data 的数据结构
export type MessageData =
{ type: WorkerFunName.main, params: OffscreenCanvas }
|
{ type: WorkerFunName.updateSize, params: CanvasSize }
&lt;/code>&lt;/pre>&lt;br>
&lt;h4 id="workerts">worker.ts&lt;/h4>
&lt;blockquote>
&lt;p>src/components/hello-offscreen-canvas/worker.ts&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>import * as Three from &amp;#39;three&amp;#39;
import { CanvasSize, MessageData, WorkerFunName } from &amp;#39;./message-data&amp;#39;
let renderer: Three.WebGLRenderer
let camera: Three.PerspectiveCamera
let scene: Three.Scene
//定义初始化的函数
const main = (canvas: OffscreenCanvas) =&amp;gt; {
//开始创建 3D 相关场景
renderer = new Three.WebGLRenderer({ canvas })
camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.z = 4
scene = new Three.Scene()
const colors = [&amp;#39;blue&amp;#39;, &amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;]
const cubes: Three.Mesh[] = []
colors.forEach((color, index) =&amp;gt; {
const material = new Three.MeshPhongMaterial({ color })
const geometry = new Three.BoxBufferGeometry(1, 1, 1)
const mesh = new Three.Mesh(geometry, material)
mesh.position.x = (index - 1) * 2
scene.add(mesh)
cubes.push(mesh)
})
const light = new Three.DirectionalLight(0xFFFFFF, 1)
light.position.set(-2, 2, 2)
scene.add(light)
const render = (time: number) =&amp;gt; {
time *= 0.001
cubes.forEach((item) =&amp;gt; {
item.rotation.set(time, time, 0)
})
renderer.render(scene, camera)
self.requestAnimationFrame(render)
}
self.requestAnimationFrame(render)
}
//定义用来接收画布尺寸更新的函数
const updateSize = (newSize: CanvasSize) =&amp;gt; {
camera.aspect = newSize.width / newSize.height
camera.updateProjectionMatrix()
renderer.setSize(newSize.width, newSize.height, false)
}
const handleMessage = ((eve: MessageEvent&amp;lt;MessageData&amp;gt;) =&amp;gt; {
switch (eve.data.type) {
case WorkerFunName.main:
main(eve.data.params)
break
case WorkerFunName.updateSize:
updateSize(eve.data.params)
break
default:
throw new Error(`no handle for the type`)
}
})
self.addEventListener(&amp;#39;message&amp;#39;, handleMessage)
const handleMessageError = () =&amp;gt; {
throw new Error(&amp;#39;Worker.ts: message error ...&amp;#39;)
}
self.addEventListener(&amp;#39;messageerror&amp;#39;, handleMessageError)
//导出 {} 是因为 .ts 类型的文件必须有导出对象才可以被 TS 编译成模块，而不是全局对象
export { }
&lt;/code>&lt;/pre>&lt;br>
&lt;h4 id="indextsx">index.tsx&lt;/h4>
&lt;blockquote>
&lt;p>src/components/hello-offscreen-canvas/index.tsx&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>import { useEffect, useRef } from &amp;#39;react&amp;#39;
import { WorkerFunName } from &amp;#39;./message-data&amp;#39;
import Worker from &amp;#39;worker-loader!./worker&amp;#39;
import &amp;#39;./index.scss&amp;#39;
const HelloOffscreenCanvas = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const canvas = canvasRef.current as HTMLCanvasElement
const offscreen = canvas.transferControlToOffscreen()
const worker = new Worker()
worker.postMessage({ type: WorkerFunName.main, params: offscreen}, [offscreen])
const handleMessageError = (error: MessageEvent&amp;lt;any&amp;gt;) =&amp;gt; {
console.log(error)
}
const handleError = (error: ErrorEvent) =&amp;gt; {
console.log(error)
}
worker.addEventListener(&amp;#39;messageerror&amp;#39;, handleMessageError)
worker.addEventListener(&amp;#39;error&amp;#39;, handleError)
const handleResize = () =&amp;gt; {
worker.postMessage({
type: WorkerFunName.updateSize,
params: { width: canvas.clientWidth, height: canvas.clientHeight }
})
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
worker.removeEventListener(&amp;#39;messageerror&amp;#39;, handleMessageError)
worker.removeEventListener(&amp;#39;error&amp;#39;, handleError)
}
}, [canvasRef])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloOffscreenCanvas
&lt;/code>&lt;/pre>&lt;p>我们可以看到 index.tsx 中已经没有任何 Three.js 相关的代码了。&lt;/p>
&lt;p>运行调试一切正常。&lt;/p>
&lt;br>
&lt;p>&lt;strong>接下来我们要解决 2 个问题：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>控制 3D 场景用到的 OrbitControls 类，在新建时需要传递 HTML DOM 元素，交互的过程中需要 DOM 元素的鼠标事件和键盘事件，但是 worker 内部又不能访问 DOM 元素，那该如何解决？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设浏览器不支持 OffscreenCanvas ，那又该如何拆分我们的代码可以做到兼容？&lt;/p>
&lt;blockquote>
&lt;p>在软件开发术语中，会使用 “鲁棒性或健壮性” 来指代码的兼容性和容错性。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;h2 id="模拟并添加-orbitcontrols">模拟并添加 OrbitControls&lt;/h2>
&lt;blockquote>
&lt;p>你需要先忘记我们上面刚才讲过的示例代码，本小节中所有的代码和上面示例代码没有任何关联。&lt;/p>
&lt;/blockquote>
&lt;h4 id="目前无法使用-orbitcontrols-的困境">目前无法使用 OrbitControls 的困境&lt;/h4>
&lt;p>在以前所有的例子中，我们添加镜头轨道控制器，都是使用以下代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>import { OrbitControls } from &amp;#39;three/examples/jsm/controls/OrbitControls&amp;#39;
const controls = new OrbitControls(camera,canvas)
或者
const controls = new OrbitControls(camera,window.body)
&lt;/code>&lt;/pre>&lt;p>OrbitControls 构造函数第 2 个参数无论是 canvas 还是 window.body，一定是一个 DOM 元素。&lt;/p>
&lt;p>我们已经将 Three.js 相关代码都转移到了 Worker 内部，但是 Web Worker 内部是无法获取 DOM 元素的，那么意味着 OrbitControls 根本就无法初始化。&lt;/p>
&lt;blockquote>
&lt;p>不要想着尝试将 DOM 元素作为 参数，使用 .postMessage() 函数传递给 Worker 内部，因为 .postMessage() 函数中的参数并不是传递引用，而是直接深度复制一份。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="那么究竟该怎么办呢">那么究竟该怎么办呢？&lt;/h4>
&lt;p>我们先研究一下 OrbitControls 的源码：&lt;/p>
&lt;p>&lt;a href="https://github.com/mrdoob/three.js/blob/dev/examples/jsm/controls/OrbitControls.js" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/blob/dev/examples/jsm/controls/OrbitControls.js&lt;/a>&lt;/p>
&lt;br>
&lt;p>我把源码中和 Dom 元素相关的一些关键代码摘录出来：&lt;/p>
&lt;pre tabindex="0">&lt;code>//设置 scope = this
var scope = this;
var OrbitControls = function ( object, domElement ) {
//下面这行代码相当于 scope.domElement = domElement
this.domElement = domElement;
}
//添加鼠标右键(上下文)菜单事件侦听
scope.domElement.addEventListener( &amp;#39;contextmenu&amp;#39;, onContextMenu);
//添加触控笔和鼠标摁下事件侦听
scope.domElement.addEventListener( &amp;#39;pointerdown&amp;#39;, onPointerDown);
//添加鼠标滚轴事件侦听
scope.domElement.addEventListener( &amp;#39;wheel&amp;#39;, onMouseWheel );
//添加触摸开始、结束、移动事件侦听
scope.domElement.addEventListener( &amp;#39;touchstart&amp;#39;, onTouchStart);
scope.domElement.addEventListener( &amp;#39;touchend&amp;#39;, onTouchEnd);
scope.domElement.addEventListener( &amp;#39;touchmove&amp;#39;, onTouchMove);
//添加键盘事件侦听
scope.domElement.addEventListener( &amp;#39;keydown&amp;#39;, onKeyDown);
if ( state !== STATE.NONE ) {
//添加触控笔和鼠标移动事件侦听
scope.domElement.ownerDocument.addEventListener( &amp;#39;pointermove&amp;#39;, onPointerMove, false );
//添加触控笔和鼠标松开事件侦听
scope.domElement.ownerDocument.addEventListener( &amp;#39;pointerup&amp;#39;, onPointerUp, false );
scope.dispatchEvent( startEvent );
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>补充说明：在最新的浏览器事件中 pointer 相关事件即包含触控笔，也包含鼠标。所以 pointerdown、pointermove、pointerup 这 3 个事件对应 触控笔或鼠标 对应的事件，相当于是 2 者的合体。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>从上面可以看出，我们初始化传递给 OrbitControls 的 DOM 元素主要是用来添加各种事件侦听。&lt;/p>
&lt;blockquote>
&lt;p>当然 OrbitControls 代码中也有对应的 removeEventListener 移除事件侦听。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>补充一点：contextmenu 事件虽然目前部分浏览器支持(主要是火狐浏览器)，但是在 MDN 的文档中已经明确该事件即将被废除。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>重点来了，请听好：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>既然 OrbitControls 需要 DOM 元素的目的是为了获取并添加各种事件侦听&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而 Worker 中无法获取 DOM 元素&lt;/p>
&lt;/li>
&lt;li>
&lt;p>那么有没有可能我们虚拟出来一个对象，让该对象拥有和 DOM 元素相同的事件 API&lt;/p>
&lt;blockquote>
&lt;p>换句话说，就是让这个虚拟出来的对象具备抛出事件的能力&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>补充一点，这里说的 DOM 事件其实有 2 种：&lt;/p>
&lt;ol>
&lt;li>DOM 元素上的各种用户交互 5 种事件：鼠标事件、滚轴事件、键盘事件、触摸事件、右键菜单事件&lt;/li>
&lt;li>浏览器窗口尺寸发生变化引发 DOM 元素尺寸发生变化的 window resize 事件&lt;/li>
&lt;li>我们需要做的就是分别模拟出以上 6 种事件&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>然后我们让 OrbitControls 去侦听这个虚拟对象所发出的各种事件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>也就是说让这个虚拟对象代替真实的 DOM 元素，以此来解决我们目前的困境&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>思路有了，那该具体怎么做呢？&lt;/strong>&lt;/p>
&lt;p>首先我们要明白一件事，原生 DOM 对应的属性、方法、事件、以及事件携带的属性 种类繁多且复杂。&lt;/p>
&lt;p>而 OrbitControls 并不是每一个属性、方法、事件、事件每一个属性 都使用到了，也就是说我们所谓的 “模拟”不需要 100% 一模一样，我们只需要提供 OrbitControls 需要的即可。&lt;/p>
&lt;p>究竟需要模拟出 DOM 元素哪些属性和方法，我们会在具体代码时讲解。&lt;/p>
&lt;p>此刻，我们只以事件携带的属性来举例说明：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对于鼠标滚轴滚动来说，OrbitControls 只需要使用到该事件的 deltaY 值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于键盘事件来说，OrbitControls 只需要使用到该事件的 ctrlKey、metaKey、shiftKey、keyCode 值&lt;/p>
&lt;blockquote>
&lt;p>meta 键？&lt;/p>
&lt;p>这个 meta 键在 Windows 键盘上相当于 windows 键、在苹果键盘上是一个四瓣的小花。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在 OrbitControls 内部并未使用到 altKey 值&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>注意：由于 OrbitControls 仅使用到键盘 上/下/左/右 4 个键，我们还可以主动过滤掉一些无用的摁键，换句话说也就是提前判断一下是否是以上 4 个方向键，如果不是，则直接跳过，不传递该事件&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>注意：对于目前版本 Three.js r126 版本而言，OrbitControls 键盘事件读取使用的是 keyCode，但是 event.keyCode 事实上已经不被推荐使用，建议使用 event.code 属性。&lt;/p>
&lt;p>所以我顺带向 Three.js 官方提交了 PR，将 keyCode 修改为 code，这个 PR 已经被官方审查通过了，会在 r127 版本中使用。因此，我也成为 Three.js 代码贡献者了。&lt;/p>
&lt;p>我提交的这个 PR：https://github.com/mrdoob/three.js/pull/21409&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>关于为什么不再推荐使用 event.keyCode 主要是因为 keyCode 不能够比较清晰正确返回键盘所摁键，例如 冒号和分号 都是同一个键，此时 keyCode 就无法精确区分。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>对于鼠标事件，OrbitControls 需要使用到该事件的 pointerType、button、clientX、clientY、ctrlKey、metaKey、shiftKey 值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于触摸(touch)事件，OrbitControls 需要使用每一个 触摸点的 pageX、pageY 属性值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>我们需要让 “虚拟对象” 抛出 “虚拟事件”，并且虚拟事件拥有上面那些属性值。&lt;/p>
&lt;blockquote>
&lt;p>补充说明：这里所说的 “抛出事件” 暗含 2 种事件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>用户交互事件：鼠标事件、滚轴事件、键盘事件&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浏览器窗口变化引发 “DOM 元素” 内部尺寸属性相关的修改事件&lt;/p>
&lt;blockquote>
&lt;p>除了 window 拥有 resize 事件之外，普通 DOM 元素是不具备 resize 事件的，我们可以将这个原本不存在的 DOM 元素 resize 追加到 我们的消息中，对于 用户交互事件 我们选择直接抛出、对于 window resize 引发的尺寸修改事件，我们选择内部直接处理。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>属性补充说明：&lt;/strong>&lt;/p>
&lt;p>在 OrbitControls 内部，还会对监听的 DOM 元素的根元素添加 2 个事件侦听。&lt;/p>
&lt;pre tabindex="0">&lt;code>// scope = this
scope.domElement.ownerDocument.addEventListener( &amp;#39;pointermove&amp;#39;, onPointerMove );
scope.domElement.ownerDocument.addEventListener( &amp;#39;pointerup&amp;#39;, onPointerUp );
&lt;/code>&lt;/pre>&lt;p>因此我们模拟的元素还要拥有 .ownerDocument 属性值。&lt;/p>
&lt;blockquote>
&lt;p>在后面的实际代码中你会看到，我们会让 模拟元素 .ownerDocument 指向自身。&lt;/p>
&lt;p>this.ownerDocument = this&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>document 补充说明：&lt;/strong>&lt;/p>
&lt;p>在 OrbitControls 类的构造函数中，有以下代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>if ( domElement === undefined ) console.warn( &amp;#39;THREE.OrbitControls: The second parameter &amp;#34;domElement&amp;#34; is now mandatory.&amp;#39; );
if ( domElement === document ) console.error( &amp;#39;THREE.OrbitControls: &amp;#34;document&amp;#34; should not be used as the target &amp;#34;domElement&amp;#34;. Please use &amp;#34;renderer.domElement&amp;#34; instead.&amp;#39; );
&lt;/code>&lt;/pre>&lt;p>也就是说在初始化 OrbitControls 时会对要侦听的 DOM 元素进行检查。在第 2 行代码中需要使用到 document 这个对象，但是在 web worker 中根本无法访问 document，所以我们需要给 worker 添加一个 document 对象。代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>//@ts-ignore
self.document = {}
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>添加 //@ts-ignore 这样注释，可以让 TypeScript 忽略下面一行代码的检查。&lt;/p>
&lt;blockquote>
&lt;p>因为 window.document 在 TS 版本里被定义为 只读对象，是无法修改的。&lt;/p>
&lt;p>如果我们不选择忽略 TS 检查，当去执行 self.document = {} 时 TS 就会报错。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>我们添加的 self.document = {} 纯粹是为了让 OrbitControls 构造函数可以去访问到 document 对象，避免报错。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>所谓的 “抛出事件” 实现的途径是由 我们虚构出的一个 事件派发器 来实现的。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>该事件派发器的 3 个功能责任：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>监听功能：监听真实 DOM 元素事件：用户交互事件、浏览器尺寸变化事件&lt;/li>
&lt;li>事件转化：将监听到的事件内容，转化为一条数据，该数据包含该事件中 OrbitControls 所需要的各种属性值&lt;/li>
&lt;li>消息传递：将事件转化后的数据，通过 web worker 的 postMessage() 传递给 web worker&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>所谓的“模拟的 DOM 元素”，也就是在 web worker 中工作的 DOM 元素。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>该“模拟的 DOM 元素”的 2 个功能责任：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>模拟 DOM 元素的属性和方法&lt;/li>
&lt;li>处理 DOM 元素需要处理的各种事件&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>该“模拟的 DOM 元素”的生命工作流程为：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>index.tsx 中添加对 真实 DOM 元素的监听，并且通知 worker 创建“模拟元素”的消息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>worker.ts 中接收消息，开始创建一个 “模拟元素”，并且把该元素传递给 OrbitControls&lt;/p>
&lt;/li>
&lt;li>
&lt;p>index.tsx 中监听到真实 DOM 元素触发的各种事件，将该事件分析处理，转化为一条约定好的消息 并发送给 worker&lt;/p>
&lt;/li>
&lt;li>
&lt;p>worker.ts 中接收到事件消息后，将该消息转发给 “模拟的 DOM 元素”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>“模拟的 DOM 元素” 接收该消息，然后将该消息(包含事件类型、事件属性)抛出，供 OrbitControls 使用&lt;/p>
&lt;blockquote>
&lt;p>我们抛出的事件，也是模拟出来的事件，并不是原始 DOM 事件，只不过我们模拟出来的事件中恰好包含 OrbitControls 需要的所有属性和方法。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在 web worker 中工作的 OrbitControls，从始至终都不知道自己操作的其实是一个假的 DOM 元素，以及监听的事件也是假的 DOM 事件。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>整个事件的流程为：&lt;/strong>&lt;/p>
&lt;p>&lt;strong>真实 DOM 事件 &amp;gt; 转化为消息 &amp;gt; 发送给 worker &amp;gt; 传递给“模拟的 DOM 元素” &amp;gt; 抛出该消息(相当于抛出该事件)&lt;/strong>&lt;/p>
&lt;p>通过 事件 &amp;gt; 消息 &amp;gt; 消息 &amp;gt; 事件 这样一波操作过后，可以让 OrbitControls 就像监控真实 DOM 元素一样监控运行在 web worker 中的那个 “模拟的 DOM 元素”。&lt;/p>
&lt;blockquote>
&lt;p>我故意一直使用 “模拟的 DOM 元素”这个词，而没有使用 “虚拟 DOM”，就是为了让我们避免和 react 中 虚拟 DOM 的一词弄混淆。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>关于 事件抛出 的补充说明：&lt;/strong>&lt;/p>
&lt;p>我们让 “虚构元素” 继承于 Three 已内置的 EventDispatcher，这样 “虚构元素” 就 具备 .dispatcheEvent() 方法。&lt;/p>
&lt;pre tabindex="0">&lt;code>import { EventDispatcher } from &amp;#39;three&amp;#39;
&lt;/code>&lt;/pre>&lt;br>
&lt;p>为什么不使用 原生 JS 提供的 EventTarget ？&lt;/p>
&lt;p>这是因为原生 JS 提供的 EventTarget 虽然也有 .dispatcheEvent()，但问题是它只可以抛出 JS 中的 Event 实例，而我们在 worker 中并不能使用 Event。&lt;/p>
&lt;br>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>无论 JS 原生的 EventTarget，还是 Three.js 内置的 EventDispatcher，他们内部本质上都是执行的是函数调用，所以他们的执行过程都是 同步的。&lt;/p>
&lt;blockquote>
&lt;p>浏览器中原生的各种事件处理函数 其实是异步的。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>整体解决思路回顾：为什么我们可以实现？&lt;/strong>&lt;/p>
&lt;p>回顾一下本小节开头的困境问题：web worker 本身不可以访问真实 DOM 元素，当然也包括 DOM 事件。&lt;/p>
&lt;br>
&lt;p>&lt;strong>那么我们究竟是怎么做到的？以及为什么我们可以做到？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>答：机缘巧合&lt;/strong>&lt;/p>
&lt;p>**第 1 种机缘巧合：**虽然 web worker 无法访问真实的 DOM 元素，但是 canvas 元素对应的 OffscreenCanvas 却是一个例外，通过主线程让出 canvas 绘制控制权，让 web worker 拥有了可以操作并绘制 canvas 元素的能力。&lt;/p>
&lt;blockquote>
&lt;p>目前火狐浏览器并不支持 OffscreenCanvas，所以本示例还要考虑在非 worker 情况下的场景创建。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>**第 2 种机缘巧合：**虽然 web worker 无法直接监听真实 DOM 元素事件，但是 web worker 内部却可以运行 抛出事件 这个操作。于是我们通过 事件 &amp;gt; 消息 &amp;gt; 消息 &amp;gt; 事件 的操作让 web worker 内部模拟出的 DOM 元素拥有了像真实 DOM 元素一样的各种事件抛出机制。&lt;/p>
&lt;blockquote>
&lt;p>再次提醒一下：在 web worker 中，不光 DOM 元素是我们模拟出来的，就连抛出的 DOM 元素事件也是我们模拟出来的。&lt;/p>
&lt;/blockquote>
&lt;p>最终我们让 web worker 中 OrbitControls 正常运行起来了。&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>如果你对我上面的讲述还不太理解，那么多读几遍，不要着急接着往下看。因为如果整体的思路你没有理解透，那么下面这些具体实现的代码，阅读起来也会一头雾水。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>实话实说，在学习本章内容，看英文原版教程，我花了将近一周的时间，才弄明白整个原理。&lt;/p>
&lt;p>本文讲的内容可能是整个 three.js 教程中最绕、最复杂的，但是为了性能优化，学习一下是非常值得的。&lt;/p>
&lt;/blockquote>
&lt;br/>
&lt;p>&lt;strong>补充一个和本文无关的知识点：&lt;/strong>&lt;/p>
&lt;p>除了 window 之外，其他 DOM 元素尺寸发生变化时，是不会触发任何事件的。&lt;/p>
&lt;ol>
&lt;li>通过 css 修改 DOM 元素尺寸&lt;/li>
&lt;li>因为 window resize 事件而修改 DOM 元素尺寸&lt;/li>
&lt;/ol>
&lt;p>如果你想监听某 DOM 元素尺寸的变化，在最新的 DOM3 标准中，可以通过 MutationObserver 来监控，具体用法请查阅 MDN 官方文档。&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&lt;/a>&lt;/p>
&lt;br/>
&lt;h3 id="整体思路示意图">整体思路示意图&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://puxiao.com/demo/using-orbitcontrols-in-worker/using-orbitcontrols-in-worker.jpg" alt="using-orbitcontrols-in-worker.jpg" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;br>
&lt;p>接下来开始讲解具体代码如何实现。&lt;/p>
&lt;blockquote>
&lt;p>由于我使用的是 React + TypeScript，加上我有一些自己代码理解和划分，所以我下面讲述的代码和原教程很多地方都不一样。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>过程有点复杂，希望我能讲清楚。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="代码模块规划">代码模块规划&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>定义一个类 FictionalElement 继承于 EventDispatcher，用这个类的实例来模拟 “DOM 元素本身”&lt;/p>
&lt;blockquote>
&lt;p>请注意：FictionalElement 只具备(模仿、模拟) “DOM 元素” 本身的一些属性和方法(例如 width、height、left、top、getBoundingClientRect() 等)，但并不具备可以直接和 web worker 通信的能力&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在模拟一些 “无用” 的方法时，例如 focus()、preventDefault()、stopPropagation()，将该方法代码体内不添加任何代码，只是保证有这个方法但无需有实际执行内容。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>定义一个类 FictionalElementManager 用来创建和管理所有 FictionalElement 实例&lt;/p>
&lt;blockquote>
&lt;p>事实上我认为这一步骤不是必须的，因为实际项目中，绝大多数情况下网页中都只会有一个 用户交互元素(通常为 canvas 或 document.body)，并不会有太多元素需要我们管理。但是本文对应的 &lt;a href="https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html" target="_blank" rel="noopener">原版教程&lt;/a> 中有这一环节(管理层)，那么我们也继续遵循。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>为了区别不同的管理对象，我们将在内部给每一个 ElementProxyReceiver 添加一个对应的 id&lt;/p>
&lt;p>原版教程中，id 是由 FictionalElementManager 提供的，但是我认为这样并不合理，我采用的是通过外部传递 id 为 string 类型的值。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>定义一个类 FictionalWindow 用来模拟 window&lt;/p>
&lt;blockquote>
&lt;p>请注意，目前来说 FictionalWindow 仅仅是继承了 EventDispatcher，并没有做其他设置，先这样做，也许未来有其他需求了，再根据需要扩展它。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>定义一个类 ControlsProxy 用来负责基础的 真实 DOM 元素与 Web Worker 之间通信。&lt;/p>
&lt;blockquote>
&lt;p>当浏览器窗口尺寸发生变化时，我们模拟的 &amp;ldquo;DOM 元素本身&amp;quot;也应该会发生尺寸变化，而这个变化的触发并不是由 FictionalElement 完成的，而是由 ControlsProxy 来完成的。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>定义一个类 OrbitControlsProxy 继承于 ControlsProxy，然后重写 configEventListener() 和 dispose()&lt;/p>
&lt;blockquote>
&lt;p>你可能疑惑为什么我没有直接把代码写在同一个类里，而是要拆分成 2 个。我这样做的原因是想将一些基础的、共性的属性和方法抽离出来，这样未来有一天我们要去实现其他轨道控制器，都可以继承于 ControlsProxy&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>定义一个类 WorkerMessageType，用来定义 发送消息 的类型&lt;/p>
&lt;blockquote>
&lt;p>每次都靠手写消息类型是不靠谱的，万一手抖拼写错字母了想检查出来都不容易。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>此外，虽然本教程一直都是用的是 TypeScript，但是在编写这些类的时候，考虑有些人并不使用 TS，所以我采用的是 .js + JSDoc 的方式，通过 JSDoc 代码注释的形式来定义不同消息的数据结构，没有使用 .ts。&lt;/p>
&lt;blockquote>
&lt;p>我也是因为这个示例而去学习了 JSDoc，感兴趣可查看我另外一篇学习笔记：&lt;a href="https://github.com/puxiao/notes/blob/master/JSDoc%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md" target="_blank" rel="noopener">JSDoc 的安装与使用.md&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>以上仅仅是 “虚构” 的核心代码，除此之外，我们还需要编写对应的 “应用” 层面的代码：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>index.tsx：JS 主场景 main 代码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>worker.ts：Worker 场景代码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>create-world.ts：负责创建 Three.js 3D 场景的核心代码&lt;/p>
&lt;blockquote>
&lt;p>create-world.ts 中的代码并不知道自己将来是运行在 Worker 中还是运行在 主场景中(Main)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>如果你能坚持看到这里没有被我绕晕，那恭喜你。&lt;/strong>&lt;/p>
&lt;p>是不是该展示具体代码了？&lt;/p>
&lt;br>
&lt;h3 id="项目实际代码">项目实际代码&lt;/h3>
&lt;p>原理都讲述完了，但是每个类的代码细节实在是太多，我也不想再细致讲述了，所以在 Github 单独创建了一个项目：&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://github.com/puxiao/using-orbitcontrols-in-worker" target="_blank" rel="noopener">https://github.com/puxiao/using-orbitcontrols-in-worker&lt;/a>&lt;/strong>&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>为了让全世界的人能看到我的这个代码，我竟然写了一个英文版 README.MD&lt;/p>
&lt;/blockquote>
&lt;p>你可以直接查看我写的简体中文介绍文档：&lt;/p>
&lt;p>&lt;a href="https://github.com/puxiao/using-orbitcontrols-in-worker/blob/main/README-zh_CN.md" target="_blank" rel="noopener">https://github.com/puxiao/using-orbitcontrols-in-worker/blob/main/README-zh_CN.md&lt;/a>&lt;/p>
&lt;br>
&lt;h3 id="说一下我的感受">说一下我的感受&lt;/h3>
&lt;p>本节后面的代码实现，花费了我有 1 个月的时间，整个过程即充实有痛苦。&lt;/p>
&lt;ol>
&lt;li>从阅读原版教程，完全看不懂 理解不了&lt;/li>
&lt;li>后来可以理解&lt;/li>
&lt;li>改为自己的实现方式&lt;/li>
&lt;li>不断得修改、优化代码&lt;/li>
&lt;li>上传到 Github 编写文档&lt;/li>
&lt;/ol>
&lt;p>尽管掌握了本章所写的示例代码，但是这些对实际 Three.js 的使用提升并不会有立竿见影的效果。&lt;/p>
&lt;br>
&lt;h4 id="但是">但是！&lt;/h4>
&lt;p>因为不断的深入去理解，学习，我也有很多收获：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我成功向 Three.js 贡献了自己的一点点代码，尤其是在提交自己的 PR 过程中，用蹩脚英语与 Three.js 代码审查人员的不断沟通，是一次很神奇的体验。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 OrbitControls，顺带我也看了其他 轨道控制器的 一些源码，事实上我原本的野心计划是编写出所有轨道控制器的 ControlsProxy 版，但是时间和精力，这个事情只能暂时放下，等待将来或者其他感兴趣的人来编写吧。&lt;/p>
&lt;blockquote>
&lt;p>目前我的项目中只编写了 OrbitControlsProxy.js，如果你感兴趣，也可以尝试编写出其他 轨道控制器对应的 XxxControlsProxy。&lt;/p>
&lt;p>提醒：如果你想编写其他轨道控制器的代理管理类，它需要继承于 ControlsProxy，然后重写 configEventListener() 和 dispose() 这 2 个方法。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>学习了 JSDoc 注释规范，也就是即使我们不使用 TypeScript，通过 JSDoc 注释依然可以进行类型定义。&lt;/p>
&lt;blockquote>
&lt;p>通过 JSDoc 的学习，让我对 TypeScript 有更加深一层的理解。&lt;/p>
&lt;p>无论 TypeScript 还是 JSDoc，还是 VSCode IDE 本身的代码提示和自动检查，本质上都仅仅在 开发阶段 对我们编写的代码进行约束，将来 JS 运行阶段就管不了那么多了。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>接触了 //@ts-ignore 这个特殊注释&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;h3 id="本小节结束">本小节结束&lt;/h3>
&lt;p>本小节至此结束，同时也意味着本系列教程的 “优化” 篇章讲解完成。&lt;/p>
&lt;p>接下来，我们要开始新的阶段学习，下一阶段才决定我们 Three.js 实际应用领域 “质的飞越”。&lt;/p>
&lt;br>
&lt;p>&lt;strong>下一阶段，我们要开始学习 Three.js 中常见的各种应用场景解决方案。&lt;/strong>&lt;/p>
&lt;p>加油，好玩有趣的事情终于要开始了。&lt;/p>
&lt;br></description></item><item><title>23.Three.js 解决方案之加载.obj模型</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/23.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/23.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="23-threejs-解决方案之加载obj-模型">23 Three.js 解决方案之加载.obj 模型&lt;/h1>
&lt;p>本文将开始 Three.js 新的篇章—— Three.js 各种应用场景的解决方案。&lt;/p>
&lt;p>有 2 点会与之前的篇章不同：&lt;/p>
&lt;ol>
&lt;li>讲解内容时尽量简要，不再像前面 01-22 篇章那样啰嗦&lt;/li>
&lt;li>和原版官方教程内容上略有不同，删除我认为没有必要的内容、增加上我自己补充的内容。&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>特别强调 1：从本文示例开始，我们将升级 React 和 Three.js 的版本&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>react 由原来的 17.0.2 升级为 17.0.3&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重点是 Three.js 由原来的 0.125.2 升级为 0.127.0&lt;/p>
&lt;blockquote>
&lt;p>由于 Three.js 版本迭代，对于某些类的引用路径、方法和属性的使用 难免会有一些变化。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>由于 Three.js 在 0.126.0 版本时已经默认不包含 .d.ts 文件，所以我们还需要额外单独安装 对应的 typescript 类型定义文件包&lt;/p>
&lt;pre tabindex="0">&lt;code>yarn add @types/three
//npm i @types/three
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>特别强调 2：尽管我们在前一章节花了非常多的时间研究出如果在 Web Worker 中渲染和控制 Threejs 3D 场景，但是本示例并不会选择使用 web worker，依然会选择直接在 JS 主场景中创建 3D 场景。&lt;/strong>&lt;/p>
&lt;br>
&lt;p>正文开始&amp;hellip;&lt;/p>
&lt;h2 id="加载obj模型文件">加载.obj(模型)文件&lt;/h2>
&lt;br>
&lt;p>&lt;strong>前言小絮&lt;/strong>&lt;/p>
&lt;p>在之前所有的示例中，场景中的 3D 物体元素都是直接在 Three.js 中创建的，但是 Three.js 毕竟不是专业的 3D 建模软件，所以实际工作中，我们更多的都是在传统 3D 建模软件中创建好模型，然后将模型导出成特定格式的文件，然后在 Three.js 中使用特定的加载器，将这些模型加载进来。&lt;/p>
&lt;br>
&lt;h4 id="让我们开始使用-blender">让我们开始使用 Blender&lt;/h4>
&lt;p>尽管我更喜欢 C4D 这个软件，但是由于 C4D 为收费软件，所以在本教程中，我们将更多的使用 Blender 这个免费的 3D 建模软件。&lt;/p>
&lt;p>国外人很注意版权，所以很多教程中也都使用的是 Bleander。&lt;/p>
&lt;p>假设你希望自己创建的模型或者项目要跟别人交流，而你使用破解版的 C4D ，多少有一些隐患。&lt;/p>
&lt;br>
&lt;h4 id="blender-软件下载安装">Blender 软件下载安装&lt;/h4>
&lt;p>Blender 不光免费，而且还支持简体中文。&lt;/p>
&lt;blockquote>
&lt;p>当前版本为 2.92.0&lt;/p>
&lt;/blockquote>
&lt;p>下载地址：https://www.blender.org/download/&lt;/p>
&lt;blockquote>
&lt;p>软件安装好之后，第一次启动 Blender 时会有一个弹窗，在弹窗中将界面语言由 English 修改为 简体中文，这样软件界面就变成 简体中文了。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>关于 Blender 的基础用法，请参考我另外一篇学习笔记：&lt;a href="https://github.com/puxiao/notes/blob/master/Blender%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.md" target="_blank" rel="noopener">Blender 基础教程&lt;/a>&lt;/strong>&lt;/p>
&lt;p>我也是刚开始学习 Blender，感兴趣一起学习吧。&lt;/p>
&lt;blockquote>
&lt;p>我本身就会一些基础的 C4D 软件操作，所以在学习 Blender 时并没有感觉特别吃力，只是觉得 Blender 各种操作的快捷键实在是太多了，有点难记。如果你是第一次接触 3D 建模软件，那&amp;hellip;只能说，加油！&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="使用-blender-创建并导出-3d-模型obj-文件">使用 Blender 创建并导出 3D 模型——.obj 文件&lt;/h4>
&lt;p>启动 Blender 之后，默认场景上有一个立方体，我们再添加几个其他元素，如 圆柱体、圆锥体、球体。&lt;/p>
&lt;p>&lt;strong>关于 Blender 中“球体”的特别说明&lt;/strong>&lt;/p>
&lt;p>我们添加球体的操作是：物体模式下，点击 “添加 &amp;gt; 表(曲)面 &amp;gt; 球体”&lt;/p>
&lt;p>千万不要误操作成：“添加 &amp;gt; 融球 &amp;gt; 球”&lt;/p>
&lt;p>因为 Blender 中 融球 和 球体 虽然看上去都像球体，但是 2 者有很大的差别。&lt;/p>
&lt;blockquote>
&lt;p>这句话是废话，要是没差别也不会是不同操作了。&lt;/p>
&lt;p>所谓 融球 就是当 2 个融球彼此靠近一定程度后，2 个融球边缘会自动融合在一起，就是因为这个特性所以才被称为融球。融球本质上是 Blender 一种即时计算的数据公式。&lt;/p>
&lt;p>而 球体 就是属于普通的网格，2 个球体就算彼此靠得再近也不会发生相融的场景。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>我们只是简单将这几个元素修改一下位置，不做任何属性的调整，然后就直接导出模型。&lt;/p>
&lt;blockquote>
&lt;p>为什么不做复杂的调整？&lt;br>
答：因为我也刚学 Blender，还不太会，就先这样吧。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>现在我们要导出刚才创建的 3D 场景元素，执行：&lt;/p>
&lt;p>&lt;strong>文件 &amp;gt; 导出 &amp;gt; Wavefront(obj)&lt;/strong>&lt;/p>
&lt;p>在弹出的导出选项弹出中，我们什么也不修改，直接点击 导出 OBJ，我们将文件名设置为 hello.obj。&lt;/p>
&lt;blockquote>
&lt;p>以下为默认的导出参数&lt;/p>
&lt;p>在 Objects as 选项中：&lt;/p>
&lt;ol>
&lt;li>OBJ 物体 (默认已勾选)&lt;/li>
&lt;li>OBJ 组 (默认未被勾选)&lt;/li>
&lt;li>材质组 (默认未被勾选)&lt;/li>
&lt;li>动画 (默认未被勾选)&lt;/li>
&lt;/ol>
&lt;p>在 变换 选项中：&lt;/p>
&lt;ol>
&lt;li>缩放：1.00 (默认值)&lt;/li>
&lt;li>路径模式：自动 (默认值)&lt;/li>
&lt;li>前进：-Z 前进 (默认值)&lt;/li>
&lt;li>向上：Y 向上 (默认值)&lt;/li>
&lt;/ol>
&lt;p>在 集合数据 选项中：&lt;/p>
&lt;ol>
&lt;li>应用修改器 (默认已勾选)&lt;/li>
&lt;li>平滑组 (默认未被勾选)&lt;/li>
&lt;li>Bitflag 平滑组 (默认未被勾选)&lt;/li>
&lt;li>写入法线 (默认已勾选)&lt;/li>
&lt;li>包括 UV (默认已勾选)&lt;/li>
&lt;li>写入材质 (默认已勾选)&lt;/li>
&lt;li>三角面 (默认未被勾选)&lt;/li>
&lt;li>Curves as NURBS (默认未被勾选)&lt;/li>
&lt;li>多边形组 (默认未被勾选)&lt;/li>
&lt;li>保持顶点顺序 (默认未被勾选)&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;br>
&lt;p>当导出完成后，我们会看到实际上产生了 2 个新文件：&lt;/p>
&lt;ol>
&lt;li>hello.obj&lt;/li>
&lt;li>hello.mtl&lt;/li>
&lt;/ol>
&lt;p>特别说明一下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>.obj 这个文件是用来储存 3D 模型 数据的&lt;/p>
&lt;blockquote>
&lt;p>请注意这里面只包含 3D 模型 的数据和模型位置信息，并不包含 Blender 场景中的镜头和灯光&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>.mtl 这个文件是用来储存 材质 数据的&lt;/p>
&lt;blockquote>
&lt;p>我们在 Blender 中创建的几个物体元素，&lt;strong>实际上 Blender 已经给他们添加了默认的一个可反光材质&lt;/strong>。&lt;/p>
&lt;p>由于是可反光材质，所以请记得一定要在 Three.js 场景中添加灯光，否则这些物体都会看不见的。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在 Blender 中材质包含有 纹理贴图，尽管此刻我们并未给材质设置任何纹理贴图。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>我们将得到的 hello.obj 文件拷贝到 React 项目中，路径为 src/assets/model/hello.obj&lt;/p>
&lt;p>接下来我们要开始编写 Three.js 相关代码了。&lt;/p>
&lt;br>
&lt;h4 id="加载-obj-模型文件对应的类加载器为-objloader">加载 .obj 模型文件对应的类(加载器)为 OBJLoader&lt;/h4>
&lt;p>OBJLoader 的用法也非常简单：&lt;/p>
&lt;blockquote>
&lt;p>最常用的方法为 .load()&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>import { OBJLoader } from &amp;#34;three/examples/jsm/loaders/OBJLoader&amp;#34;
...
const loader = new OBJLoader()
loader.load(require(&amp;#39;@/assets/model/hello.obj&amp;#39;).default, (group) =&amp;gt; {
console.log(group)
scene.add(group)
}, (event) =&amp;gt; {
console.log(Math.floor((event.loaded * 100) / event.total) + &amp;#39;% loaded&amp;#39;)
}, (error) =&amp;gt; {
console.log(error.type)
})
&lt;/code>&lt;/pre>&lt;br>
&lt;p>也可以使用异步的 loadAsync()，用法为：&lt;/p>
&lt;pre tabindex="0">&lt;code>const promise = loader.loadAsync(require(&amp;#39;@/assets/model/hello.obj&amp;#39;).default, (event) =&amp;gt; {
console.log(Math.floor((event.loaded * 100) / event.total) + &amp;#39;% loaded&amp;#39;)
})
promise.then((group) =&amp;gt; {
scene.add(group)
})
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;strong>关于 Three.js 官方文档的一个小说明：&lt;/strong>&lt;/p>
&lt;p>如果你查看 OBJLoader 的官方文档，你会发现只介绍了 load() 方法，没有提及 loadAsync() ，这是为什么？&lt;/p>
&lt;blockquote>
&lt;p>即使你查看 OBJLoader 的源码，也会发现根本没有 loadAsync() 方法，那&amp;hellip;&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>这其实是因为 OBJLoader 继承于 Loader，而 loadAsync() 是由 Loader 定义的，所以才未出现在 OBJLoader 的文档中。&lt;/p>
&lt;p>Three.js 仓库管理员非常严谨，每次提交 PR 涉及修改一定要求你去修改对应的文档，所以如果以后发现某个方法并未出现在 要使用的类的介绍中，那么就去他的父类里查找即可。&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>像别的编程语言文档，可能都会在某个类的介绍文章中，列出所继承父类的属性和方法，但是在 Three.js 中并未列出。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>我向官方提交了一个建议：https://github.com/mrdoob/three.js/issues/21640&lt;/p>
&lt;p>得到官方的回复内容为：&lt;/p>
&lt;pre tabindex="0">&lt;code>Indeed. And that&amp;#39;s the reasons why I not vote to do this. This approach would require a lot of manual effort and thus is error prone when things change.
The documentation pages contain references like:
See the base Material class for common properties.
Same for methods. Considering that the documentation is not generated, I think it&amp;#39;s better to stick with this approach.
&lt;/code>&lt;/pre>&lt;p>官方回复的意思是：由于现在 Three.js 文档并不是自动生成的，如果那样做当发生变更时，每次都会产生大量的工作内容，所以&amp;hellip;就先保持现状吧。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>完整的示例代码如下：&lt;/p>
&lt;p>src/components/hello-objloader/index.tsx&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect } from &amp;#34;react&amp;#34;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#34;three/examples/jsm/controls/OrbitControls&amp;#34;
import { OBJLoader } from &amp;#34;three/examples/jsm/loaders/OBJLoader&amp;#34;
import &amp;#39;./index.scss&amp;#39;
const HelloOBJLoader = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.set(10, 0, 10)
const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1)
scene.add(light)
const control = new OrbitControls(camera, canvasRef.current)
control.update()
const loader = new OBJLoader()
loader.load(require(&amp;#39;@/assets/model/hello.obj&amp;#39;).default, (group) =&amp;gt; {
console.log(group)
scene.add(group)
}, (event) =&amp;gt; {
console.log(Math.floor((event.loaded * 100) / event.total) + &amp;#39;% loaded&amp;#39;)
}, (error) =&amp;gt; {
console.log(error.type)
})
const render = () =&amp;gt; {
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloOBJLoader
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>切记一定要给场景添加灯光，否则即使加载模型成功了，场景漆黑一片，也啥也看不见。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>此刻，我们在 Blender 中创建的 3D 模型已经加载并显示出来了，但是模型并没有任何材质，接下来我们要完善一下示例，给物体添加上材质。&lt;/p>
&lt;br>
&lt;h2 id="加载mtl材质和纹理文件">加载.mtl(材质和纹理)文件&lt;/h2>
&lt;p>首先，我们需要在 Blender 中给物体的材质添加纹理贴图。&lt;/p>
&lt;br>
&lt;h4 id="在-blender-中给物体设置材质添加纹理">在 Blender 中给物体设置材质，添加纹理&lt;/h4>
&lt;p>具体步骤为：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>先准备一张 金属纹理贴图，将该图片文件命名为 metal_texture.jpg，暂且存放在 hello.blend 同级目录下。&lt;/p>
&lt;blockquote>
&lt;p>随着项目复杂，纹理图片资源变多，更加合理的是创建一个 texture 的目录，用来专门存放纹理图片资源&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在不选择任何物体的前提下，在 Blender 右侧选项面板中，找到 “材质属性” 面板，我们会看到 默认材质 Material，在 “表(曲)面 - 基础色” 设置中，找到 “基础色”，点击左侧的 小圆点，在弹出菜单中选择 “图像纹理”。&lt;/p>
&lt;blockquote>
&lt;p>如果你不小心点击的是 “基础色” 右侧的区域，则会出现 调色板&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>此时 基础色 已修改为 图像纹理 状态，我们点击 “打开”，在弹窗中找到 metal_texture.jpg 并点击 “打开图片&amp;quot;，这样该纹理图片已添加到 材质 Material 中了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来我们需要做的就是依次选中(或全选)立方体、圆柱体、椎体、球体，然后在材质属性面板中，找到 “材质图标”，鼠标放上去会显示提示文字：浏览要关联的材质，点击该图标，选择 Material&lt;/p>
&lt;blockquote>
&lt;p>请注意是一个图标，而不是什么按钮，更不要点击 “新建”&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>至此，我们已经将所有物体均设置一个相同材质纹理图片。&lt;/p>
&lt;blockquote>
&lt;p>如果感兴趣，你完全可以自己给不同物体设置不同的材质纹理图片&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>让我们先简单渲染一下，看看效果吧。&lt;/p>
&lt;p>首先我们调整好场景视角，然后执行 “视图 &amp;gt; 对齐视图 &amp;gt; 活动相机对齐当前视角”，这一步的快捷键为 &lt;code>Ctrl + Alt + Numpad0&lt;/code>。&lt;/p>
&lt;p>然后我们点击 Blender 顶部菜单 “渲染 &amp;gt; 渲染图像”，这一步的快捷键为 F12，接下来就渲染弹窗中就可以看到物体渲染后的样子。&lt;/p>
&lt;br>
&lt;blockquote>
&lt;p>假设你不会 Blender，也没有关系，可以忽略我上面这段关于如何在 Blender 中创建模型和添加材质、纹理的操作。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>导出模型&lt;/strong>&lt;/p>
&lt;p>&amp;ldquo;文件 &amp;gt; 导出 &amp;gt; Wavefront(.obj)&amp;rdquo;&lt;/p>
&lt;br>
&lt;p>&lt;strong>我们看一下 Three.js 官方文档中对 .mtl 文件的描述：&lt;/strong>&lt;/p>
&lt;p>材质模版库（MTL）或 .MTL 文件格式是 .OBJ 的配套文件格式， 用于描述一个或多个 .OBJ 文件中物体表面着色（材质）属性。&lt;/p>
&lt;br>
&lt;p>&lt;strong>实际看看 hello.mtl 文件具体是什么内容&lt;/strong>&lt;/p>
&lt;p>我们可以使用 记事本 或 vscode 打开 hello.mtl 文件，内容如下：&lt;/p>
&lt;pre tabindex="0">&lt;code># Blender MTL File: &amp;#39;hello.blend&amp;#39;
# Material Count: 1
newmtl Material
Ns 323.999994
Ka 1.000000 1.000000 1.000000
Kd 0.800000 0.800000 0.800000
Ks 0.500000 0.500000 0.500000
Ke 0.000000 0.000000 0.000000
Ni 1.450000
d 1.000000
illum 2
map_Kd metal_texture.jpg
&lt;/code>&lt;/pre>&lt;p>我们可以看到最后一行 &lt;code>map_Kd metal_texture.jpg&lt;/code>，大概也可以猜到这一行表明材质纹理图片的路径和文件名，并且路径是相对路径。&lt;/p>
&lt;blockquote>
&lt;p>由于我们将 metal_texture.jpg 存放在 hello.blend 同一目录下。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>关于.mtl 文件内容的补充说明：&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>下面我将针对上面的 .mtl 文件内容进行逐一解释&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>#：注释内容&lt;/li>
&lt;li>newtml：材质的名称&lt;/li>
&lt;li>Ns：反射指数，即反射高光度，值越高则高光越密集，一般取值范围 0 - 1000&lt;/li>
&lt;li>Ka：材质的环境光，一般取值范围 0 - 1&lt;/li>
&lt;li>Kd：散射光&lt;/li>
&lt;li>Ks：镜面光&lt;/li>
&lt;li>Ni：折射光，一般取值范围 0.01 - 10&lt;/li>
&lt;li>d：渐隐指数，取值范围为 0 - 1，当值为 1 时完全不透明，当值为 0 时完全透明&lt;/li>
&lt;li>illum：材质的光照模型，值为整数，取值范围为 0 - 10&lt;/li>
&lt;li>map_Kd：漫反射指定颜色纹理贴图文件路径&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>上面属性中 illum 实际上是 “illumination model”，即光照模型。&lt;/p>
&lt;p>illum 的取值分别对应的是：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>取值&lt;/th>
&lt;th>光照模型&lt;/th>
&lt;th>中文名&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>Color on and Ambient off&lt;/td>
&lt;td>色彩开，阴影色关&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>Color on and Ambient on&lt;/td>
&lt;td>色彩开，阴影色开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>Highlight on&lt;/td>
&lt;td>高光开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>Reflection on and Ray trace on&lt;/td>
&lt;td>反射开，光线追踪开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>Transparency: Glass on / Reflection: Ray trace on&lt;/td>
&lt;td>透明： 玻璃开 反射：光线追踪开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>Reflection: Fresnel on and Ray trace on&lt;/td>
&lt;td>反射：菲涅尔衍射开，光线追踪开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>Transparency: Refraction on / Reflection: Fresnel off and Ray trace on&lt;/td>
&lt;td>透明：折射开 反射：菲涅尔衍射关，光线追踪开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>Transparency: Refraction on / Reflection: Fresnel on and Ray trace on&lt;/td>
&lt;td>透明：折射开 反射：菲涅尔衍射开，光线追踪开&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>Reflection on and Ray trace off&lt;/td>
&lt;td>反射开，光线追踪关&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>Transparency: Glass on / Reflection: Ray trace off&lt;/td>
&lt;td>透明： 玻璃开 反射：光线追踪关&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>Casts shadows onto invisible surfaces&lt;/td>
&lt;td>投射阴影于不可见表面&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;p>&lt;strong>那么问题来了，由于 hello.mtl 中包含纹理图片的路径，如果我们将 图片资源(metal_texture.jpg) 拷贝到 src/assets/model 中，.jpg 图片会被 webpack 重新编译成别的文件名，这会造成我们加载不到 纹理图片 资源。&lt;/strong>&lt;/p>
&lt;br>
&lt;p>&lt;strong>最简单的解决办法，就是将 .obj/.mtl/.jpg 这 3 个文件资源存放在 public 目录中，而不是在 src 目录中。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>public 目录里的文件是不会被 webpack 编译重命名的。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>拷贝文件到 Three.js 项目中&lt;/strong>&lt;/p>
&lt;p>我们在 React 项目根目录的 public 目录下创建 model 目录，然后将新导出的 3 个文件：hello.obj、hello.mtl、metal_texture.jpg 拷贝到 public/model/ 中。&lt;/p>
&lt;br>
&lt;p>至此，前期准备工作完毕，接下来转到 Three.js 项目代码中。&lt;/p>
&lt;br>
&lt;h4 id="加载-mtl-表面着色器材质对应的类加载器为-mtlloader">加载 .mtl 表面着色器(材质)对应的类(加载器)为 MTLLoader&lt;/h4>
&lt;blockquote>
&lt;p>在 Three.js 中，各种加载器的用法几乎完全相同。&lt;/p>
&lt;/blockquote>
&lt;p>我们需要做的事情就是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>先使用 MTLLoader 实例 加载材质(纹理图片)资源&lt;/p>
&lt;blockquote>
&lt;p>特别强调一下，MTLLoader 实例 加载得到的对象类型并不是 Three.Metrial ，而是 MTLLoader.MaterialCreator&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>加载完成后，将得到的 MaterialCreator 实例 赋予给 OBJLoader 实例&lt;/p>
&lt;blockquote>
&lt;p>这样 OBJLoader 以后加载的任意模型都会自动应用该 MaterialCreator 材质&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>然后再让 OBJLoader 实例 去加载模型&lt;/p>
&lt;blockquote>
&lt;p>加载完成后，将模型添加到场景中&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>实际代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { MTLLoader } from &amp;#34;three/examples/jsm/loaders/MTLLoader&amp;#34;
import { OBJLoader } from &amp;#34;three/examples/jsm/loaders/OBJLoader&amp;#34;
...
const mtlLoader = new MTLLoader()
const objLoader = new OBJLoader()
mtlLoader.load(&amp;#39;./model/hello.mtl&amp;#39;, (materialCreator) =&amp;gt; {
objLoader.setMaterials(materialCreator)
objLoader.load(&amp;#39;./model/hello.obj&amp;#39;, (group) =&amp;gt; {
scene.add(group)
})
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意上述代码加载的资源地址为 “./model/hello.mtl” 和 “./model/hello.obj”，这里是相对路径，相对编译之后的 index.html 而言。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>完整的代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect } from &amp;#34;react&amp;#34;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#34;three/examples/jsm/controls/OrbitControls&amp;#34;
import { MTLLoader } from &amp;#34;three/examples/jsm/loaders/MTLLoader&amp;#34;
import { OBJLoader } from &amp;#34;three/examples/jsm/loaders/OBJLoader&amp;#34;
import &amp;#39;./index.scss&amp;#39;
const HelloOBJLoader = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.set(10, 0, 10)
const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1)
scene.add(light)
const mtlLoader = new MTLLoader()
const objLoader = new OBJLoader()
mtlLoader.load(&amp;#39;./model/hello.mtl&amp;#39;, (materialCreator) =&amp;gt; {
objLoader.setMaterials(materialCreator)
objLoader.load(&amp;#39;./model/hello.obj&amp;#39;, (group) =&amp;gt; {
scene.add(group)
})
})
const control = new OrbitControls(camera, canvasRef.current)
control.update()
const render = () =&amp;gt; {
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloOBJLoader
&lt;/code>&lt;/pre>&lt;br>
&lt;p>至此，我们已经讲解完如何加载 .mtl 和 .obj 文件。&lt;/p>
&lt;br>
&lt;h2 id="obj-文件类型的一些特别之处">.obj 文件类型的一些特别之处&lt;/h2>
&lt;p>本文讲解的是在 Blender 中导出 wavefront(.obj) 文件格式。&lt;/p>
&lt;p>这里要针对性的进行补充：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Blender 可以导出 N 多种文件格式&lt;/p>
&lt;blockquote>
&lt;p>.obj 仅仅是其中一种&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Three.js 支持多种 3D 文件模型格式&lt;/p>
&lt;blockquote>
&lt;p>本文讲解的是加载 .obj&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>.obj 格式的一些特点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>行业内比较广泛使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>.obj 是一种纯文本格式&lt;/p>
&lt;blockquote>
&lt;p>本文中我们使用记事本打开了 .mtl 文件，并未打开 .obj 文件，感兴趣的可以自己尝试看看具体都是什么内容。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>.obj 包含的内容有：Mesh(网格)、按组/物体分离、材质/纹理、NURBS 曲线和曲面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>.obj 不包含(不支持导出)的内容有：网格顶点颜色、骨架、动画、灯光、相机、空物体、父子关系或变换&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>以上特性中不难看出 .obj 有优点，也有缺点。&lt;/p>
&lt;p>&lt;strong>优点：只包含物体模型数据本身&lt;/strong>&lt;/p>
&lt;p>&lt;strong>缺点：不包含其他复杂元素(动画、相机、灯光等)&lt;/strong>&lt;/p>
&lt;br>
&lt;p>接下来，我们将在下一章节中，讲解另外一种 3D 模型格式文件：.gLTF&lt;/p>
&lt;p>gLTF 格式可以包含更多复杂的元素数据。&lt;/p>
&lt;br>
&lt;h2 id="为什么要自己学习-blender">为什么要自己学习 Blender？&lt;/h2>
&lt;p>我个人认为，如果你想深入学习 3D，学习 Three.js，那么你就需要掌握一门 3D 建模软件。&lt;/p>
&lt;p>你可以不精通，但是基础的操作你要掌握，这样非常利于你对于 Three.js 3D 概念的理解。&lt;/p>
&lt;br>
&lt;p>如果你不会 3D 建模软件，那么你只能直接在 Three.js 中去创建模型，这将是一件非常费力的事情，并且也无法做到精准建模，对模型的细腻雕刻。&lt;/p>
&lt;br>
&lt;p>你总不能完全依靠别人给你提供建好的模型，做到饭来张口的状态吧。&lt;/p>
&lt;p>自己能够掌握 3D 建模，越建越快乐。&lt;/p>
&lt;br>
&lt;p>这也是为什么本文花了大量篇幅在一步一步讲解 Blender 中的各种操作的原因。&lt;/p>
&lt;blockquote>
&lt;p>我也是 Blender 新手小白，希望我们一起学习，一起加油。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>如果本文中讲解的 Blender 你根本不会操作，也不感兴趣安装学习，那么你可以直接在网上搜索一些 .obj 和 .mtl 文件进行代替学习。&lt;/p>
&lt;p>这里提供 2 个文件资源，你可以直接下载使用：&lt;/p>
&lt;p>&lt;a href="https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill-fixed.mtl" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill-fixed.mtl&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill.obj" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill.obj&lt;/a>&lt;/p>
&lt;br>
&lt;p>我们下一章节见。&lt;/p></description></item><item><title>24.Three.js 解决方案之加载.gLTF模型</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/24.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/24.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="24-threejs-解决方案之加载gltf-模型">24 Three.js 解决方案之加载.gltf 模型&lt;/h1>
&lt;p>上一章节，我们讲解了加载 .obj 模型，本文将讲解加载 .gltf 模型。&lt;/p>
&lt;blockquote>
&lt;p>注：虽然我们标题写的是 “加载.gltf 模型”，但更加准确地说法应该是 &amp;ldquo;加载 gtTF 文件&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>首先我们先回顾一下 .obj 文件格式的模型一些特征：文件格式简单(纯文本)、除模型外无法提供其他场景元素(例如摄像机、灯光等)。&lt;/p>
&lt;p>本文要讲解的 .gltf 格式文件可以包含的数据内容和类型要比 .obj 多很多。&lt;/p>
&lt;br>
&lt;h2 id="常见-3d-文件格式-和-gltf-的区别">常见 3D 文件格式 和 gltf 的区别&lt;/h2>
&lt;p>&lt;strong>我们先将常见的 3D 文件格式进行划分&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第 1 类(原始文件)：&lt;/strong>&lt;/p>
&lt;p>3D 建模软件本身特有的、原始的文件格式，例如：&lt;/p>
&lt;ol>
&lt;li>Blender 对应的是 .blend&lt;/li>
&lt;li>3D Max 对应的是 .max&lt;/li>
&lt;li>Maya 对应的是 .ma&lt;/li>
&lt;li>C4D 对应的是 .c4d&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>第 2 类(中转文件)：&lt;/strong>&lt;/p>
&lt;p>多个 3D 建模软件彼此都可以打开，能够读取的文件格式，例如：&lt;/p>
&lt;ol>
&lt;li>.obj&lt;/li>
&lt;li>.dae&lt;/li>
&lt;li>.fbx&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>所谓“中转”，是指这些格式的作用实际上相当于将某个模型从 A 软件 导出 然后再 B 软件中可以打开并读取。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>第 3 类(特定格式)：&lt;/strong>&lt;/p>
&lt;p>某些 3D 应用独有的文件格式。&lt;/p>
&lt;p>例如王者荣耀这款游戏中 3D 模型就可能是自己独有的文件格式。&lt;/p>
&lt;br>
&lt;p>&lt;strong>第 4 类(传输格式)：&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这里的 “传输” 是英文单词 “Transmission” 的翻译&lt;/p>
&lt;/blockquote>
&lt;p>gltf 就属于传输格式类型的文件。gltf 格式可以做到其他格式都无法做到的事情。&lt;/p>
&lt;br>
&lt;h3 id="gltf-文件格式简介">GLTF 文件格式简介&lt;/h3>
&lt;p>&lt;strong>GLTF 是英文：Graphics Language Transmission Format 的缩写&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>WebGL、OpenGL 中的 “GL” 和 GLTF 中的 “GL” 是相同的单词。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>GLTF 中文全称为：图形语言传输格式&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>GLTF 本身就是由 OpenGL 和 Vulkan 背后的 3D 图形标准组织 Khronos 定义的。&lt;/p>
&lt;/blockquote>
&lt;p>所以你可以想象得到，gltf 本身就是为了网络传输、浏览器渲染 3D 而生的。&lt;/p>
&lt;p>关于更多 gltf 信息，可以查看其官网：https://www.khronos.org/gltf/&lt;/p>
&lt;br>
&lt;p>&lt;strong>GLTF 的支持度：几乎所有的 Web 3D 图形框架都支持 GLTF&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>除了 Three.js 框架外 ，其他 3D JS 引擎框架也都支持 GLTF&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>gltf 优点 1：体积小，便于传输&lt;/strong>&lt;/p>
&lt;p>gltf 文件中模型的数据都以二进制存储，当下载(使用) gltf 文件时可以将这些二进制数据直接在 GPU 中使用。&lt;/p>
&lt;p>反观 vrml、.obj 或 .dae 等格式，他们是将数据存储为文本(例如纯文本或 JSON 格式)，也就是说 GPU 在读取这些模型文件时还需要进行文本解析。&lt;/p>
&lt;p>在文件体积方面，通常相同的模型顶点数据如果用文本形式存储，要比二进制存储体积大 3 到 5 倍。&lt;/p>
&lt;br>
&lt;p>&lt;strong>gltf 优点 2：直接渲染&lt;/strong>&lt;/p>
&lt;p>gltf 文件中模型的数据是直接要渲染的，而不是要再次编辑的。&lt;/p>
&lt;blockquote>
&lt;p>换句话说 gltf 文件中的模型是不可以再次编辑的&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>而其他类型的文件，例如 .obj 中模型是可以在 Three.js 中加载完成后二次编辑的&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>你可以简单的把 gltf 想象成 jpg 图片，而其他格式的 3D 文件是 PSD 文件，当我们仅仅是为了看到图片，无需编辑该图片时，肯定是 .jpg 图片体积小，打开速度快。&lt;/p>
&lt;/blockquote>
&lt;p>正因为是不可编辑，所以一些对于渲染而言不重要的数据通常都已被删除，例如多边形都已转化为三角形。&lt;/p>
&lt;br>
&lt;p>&lt;strong>gltf 优点 3：内嵌材质信息&lt;/strong>&lt;/p>
&lt;p>gltf 文件中模型的材质信息是被内嵌进去。&lt;/p>
&lt;p>请注意我们这里说的是 “材质信息”，也就是相当于 .obj 对应的 .mtl 中的数据，但是对于纹理图片资源(xxx.jpg)本身来说，并不会内嵌进去。&lt;/p>
&lt;blockquote>
&lt;p>所以，这里隐含的一个事情就是，我们依然需要将 .gltf 文件对应的纹理图片资源 .jpg 放在 pulic 目录中。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>结论：gltf 格式非常有针对性，是专门为渲染而设计的，文件体积小，且 GPU 读取快速。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>因此，推荐使用 gltf 格式。&lt;/strong>&lt;/p>
&lt;br>
&lt;h3 id="在-blender-中导出-gltf-文件">在 Blender 中导出 gltf 文件&lt;/h3>
&lt;p>讲了这么多 gltf 文件的优点，那么我们打开之前创建的 hello.blend 文件，导出一下 gltf 文件看看。&lt;/p>
&lt;p>&lt;strong>导出步骤：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>打开 hello.blend&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文件 &amp;gt; 导出 &amp;gt; glTF 2.0(.glb/.gltf)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在弹窗对话框中，使用默认导出项，我们直接点 &lt;code>导出&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>尽管我们使用的是默认导出项，但是还请你留意一下这几项内容：&lt;/p>
&lt;p>&lt;code>包括&lt;/code>：选定的物体(未勾选)、自定义属性(未勾选)、相机(未勾选)、精确灯光(未勾选)&lt;/p>
&lt;p>&lt;code>变换&lt;/code>：Y 向上(已勾选)&lt;/p>
&lt;p>&lt;code>几何数据&lt;/code>: 应用修改器(未勾选)、UV(已勾选)、法向(已勾选)、切向(未勾选)、顶点色(已勾选)、材质(导出)、图像(自动)、压缩(未勾选)&lt;/p>
&lt;p>&lt;code>动画&lt;/code>：动画(已勾选)、形态键(已勾选)、蒙皮(已勾选)&lt;/p>
&lt;blockquote>
&lt;p>尽管我们创建的 hello.blend 中并未设置任何动画，你可以选择取消动画相关的勾选&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>此时去导出目录里，我们会发现多出来了一个 &lt;code>hello.glb&lt;/code> 的文件。&lt;/p>
&lt;blockquote>
&lt;p>特别强调：由于纹理图片资源 metal_texture.jpg 本身就在目录中，所以我们只是从直观上感觉多出了 1 个文件而已。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>.glb ？不是 .gltf ？&lt;/strong>&lt;/p>
&lt;p>额~，别着急，我们补充一下 GLTF 格式的知识。&lt;/p>
&lt;br>
&lt;h4 id="gltf-是一种-3d-文件格式规范但是却有-3-种表现形式">GLTF 是一种 3D 文件格式规范，但是却有 3 种表现形式&lt;/h4>
&lt;p>&lt;strong>3 种表现形式分别为：分离式、二进制、嵌入式&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第 1 种表现形式(分离式)：.gltf + .bin + 纹理贴图资源(.jpg、.png)&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>gltf：3D 场景的所有概要信息，包括灯光、纹理贴图等信息&lt;/p>
&lt;blockquote>
&lt;p>该文件的内容具体形式为 JSON&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>.bin：模型的二进制数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>纹理贴图资源：这个就不多说了，就是纹理图片 xxx.jpg 或 .png&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>第 2 种表现形式(二进制)：.glb&lt;/strong>&lt;/p>
&lt;p>.glb：包含场景所有的信息的二进制数据。&lt;/p>
&lt;blockquote>
&lt;p>.glb === .gltf + .bin + 纹理图片资源&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>第 3 种表现形式(嵌入式)：.gltf&lt;/strong>&lt;/p>
&lt;p>.gltf：以 JSON 形式保存所有场景信息数据，包括材质和纹理信息。&lt;/p>
&lt;blockquote>
&lt;p>这种形式由于文件内容是 json，因此是可以通过文本再次编辑的&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>Blender 默认导出 glTF 2.0 格式时，采用的是 .glb 后缀形式。&lt;/strong>&lt;/p>
&lt;p>想要更改成别的导出形式，我们可以在 Blender 导出项 &lt;code>格式&lt;/code>下拉框中更改为 “.gltf 分离(.gltf + .bin + 纹理)” 或 &amp;ldquo;glTF 嵌入式(.gltf)&amp;quot;。&lt;/p>
&lt;p>那么此时&lt;strong>导出的文件格式就是 .gltf 后缀形式。&lt;/strong>&lt;/p>
&lt;br>
&lt;p>&lt;strong>3 种形式的对比：&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>以下纯粹是我个人的观点，仅供参考&lt;/p>
&lt;/blockquote>
&lt;p>比较常见的是前 2 种：分离式(.gltf + .bin + 纹理)、二进制形式(.glb)&lt;/p>
&lt;p>如果你的项目中，模型数据不会发生变化，但是纹理贴图可能容易发生变化，那么可以选择 分离式的。&lt;/p>
&lt;blockquote>
&lt;p>分离式的贴图资源本身就是单独存在的，因此方便替换修改。&lt;/p>
&lt;/blockquote>
&lt;p>如果你是要发送给其他人使用、且不会发生材质变更的，则可以采用 .glb 形式的。&lt;/p>
&lt;blockquote>
&lt;p>由于所有数据都只在 .glb 文件中，就 1 个文件也利于文件发送。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>补充一点：有一个网站 &lt;a href="https://gltf-viewer.donmccurdy.com/" target="_blank" rel="noopener">https://gltf-viewer.donmccurdy.com/&lt;/a> ，他可以提供 .glb 文件在线预览。&lt;/p>
&lt;p>同时在 NPM 上面，有很多针对 .glb 和 .gltf 格式互转的工具包，例如：&lt;a href="https://www.npmjs.com/package/gltf-import-export" target="_blank" rel="noopener">gltf-import-export&lt;/a>&lt;/p>
&lt;br>
&lt;p>对于 Three.js 来说，加载 glTF 格式的文件，无论哪种形式，均支持。&lt;/p>
&lt;br>
&lt;h2 id="使用-gltfloader-加载-gltf-文件的示例">使用 GLTFLoader 加载 glTF 文件的示例&lt;/h2>
&lt;p>在 Three.js 中负责加载 glTF 格式文件的加载器为 GLTFLoader。&lt;/p>
&lt;p>用法和之前 OBJLoader 用法完全相同，废话不多说，直接看代码。&lt;/p>
&lt;br>
&lt;p>我们先加载 .glb 格式的文件，代码如下：&lt;/p>
&lt;p>src/components/hello-gltfloader&lt;/p>
&lt;blockquote>
&lt;p>由于 .glb 文件是单独 1 个存在，所以我们这次可以将 hello.glb 文件放在 src/assces/model/ 目录下了。&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>import { GLTFLoader } from &amp;#34;three/examples/jsm/loaders/GLTFLoader&amp;#34;
...
const loader = new GLTFLoader()
loader.load(require(&amp;#39;@/assets/model/hello.glb&amp;#39;).default, (gltf) =&amp;gt; {
scene.add(gltf.scene)
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意当加载完成后，执行的是 scene.add(gltf.scene)&lt;/p>
&lt;p>加载完成得到的 gltf 中包含的数据有：&lt;/p>
&lt;ol>
&lt;li>gltf.animations; // Array&amp;lt;THREE.AnimationClip&amp;gt;&lt;/li>
&lt;li>gltf.scene; // THREE.Group&lt;/li>
&lt;li>gltf.scenes; // Array&amp;lt;THREE.Group&amp;gt;&lt;/li>
&lt;li>gltf.cameras; // Array&amp;lt;THREE.Camera&amp;gt;&lt;/li>
&lt;li>gltf.asset; // Object&lt;/li>
&lt;/ol>
&lt;p>我们此刻只是将 gltf.scene 添加到了场景中而已，其他数据暂时并未使用到。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>和加载 .glb 类似，如果我们的 3D 数据文件为 分离式的 .gltf，则将上述代码修改为：&lt;/p>
&lt;pre tabindex="0">&lt;code>loader.load(&amp;#39;./model/hello.gltf&amp;#39;, (gltf) =&amp;gt; {
scene.add(gltf.scene)
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>注意：我们只需将 hello.gltf 传递给 loader 即可，loader 会读取 .gltf 中的数据，自动去加载对应的 hello.bin 和 纹理图片 hello.jpg。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>由于牵扯到不同的文件 webpack 编译，所以我们选择将 .gltf、.bin、.jpg 文件放在 src/public/ 目录中。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>至此，加载 .gltf 文件讲解完成。&lt;/p>
&lt;p>就这？明明就几行代码的事情，为什么还要花这样大的篇幅来讲解 .obj 和 .glb、gltf ？&lt;/p>
&lt;p>答：要想学得深入，就一定要知道原理，知道 obj 和 gltf 的差异，知其然也要知其所以然。&lt;/p>
&lt;br>
&lt;p>我这里提供几个上找到的 glTF 文件资源，方便自己练习使用。&lt;/p>
&lt;p>&lt;strong>一个黄色的小鸭子：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://vr.josh.earth/assets/models/duck/duck.gltf" target="_blank" rel="noopener">https://vr.josh.earth/assets/models/duck/duck.gltf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vr.josh.earth/assets/models/duck/duck.bin" target="_blank" rel="noopener">https://vr.josh.earth/assets/models/duck/duck.bin&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vr.josh.earth/assets/models/duck/duck.png" target="_blank" rel="noopener">https://vr.josh.earth/assets/models/duck/duck.png&lt;/a>&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>一个简易 3D 社区&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://threejsfundamentals.org/threejs/resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>这个小区模型比较大，你需要适当调整一下镜头参数，才可以看清楚全貌&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>一个酷酷的头盔&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://cdn.khronos.org/assets/api/gltf/DamagedHelmet.glb" target="_blank" rel="noopener">https://cdn.khronos.org/assets/api/gltf/DamagedHelmet.glb&lt;/a>&lt;/p>
&lt;br>
&lt;p>&lt;strong>一个宇航员&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://modelviewer.dev/shared-assets/models/Astronaut.glb" target="_blank" rel="noopener">https://modelviewer.dev/shared-assets/models/Astronaut.glb&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>真的好酷！&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h2 id="谷歌开源的一个-js-库model-viewer">谷歌开源的一个 JS 库：model-viewer&lt;/h2>
&lt;p>在搜索 glTF 相关文章时，我无意中发现另外谷歌公司开源的一个 JS 项目： model-viewer&lt;/p>
&lt;p>项目 Github 地址：https://github.com/google/model-viewer&lt;/p>
&lt;p>项目官网：https://modelviewer.dev/&lt;/p>
&lt;p>项目介绍：Easily display interactive 3D models on the web &amp;amp; in AR&lt;/p>
&lt;blockquote>
&lt;p>简单来说就是：在 Web 或 AR 中，一个简单的用来显示 3D 模型的 JS 库。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>具体用法：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;model-viewer src=&amp;#34;shared-assets/models/Astronaut.glb&amp;#34; alt=&amp;#34;A 3D model of an astronaut&amp;#34; auto-rotate camera-controls&amp;gt;&amp;lt;/model-viewer&amp;gt;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>确实够简单了，就是引入 viewer ，然后可以使用 &lt;model-viewer> 标签插入模型渲染显示标签。&lt;/p>
&lt;p>简直和插入图片标签 &lt;img> 没啥区别。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>交互效果：除了可以渲染出 3D 模型文件，还默认配备有类似 OrbitControls 相同的交互效果。&lt;/p>
&lt;br>
&lt;p>兼容性：目前 苹果浏览器 Safari、火狐 Firefox 并不支持。&lt;/p>
&lt;br>
&lt;p>至此，关于如何加载 glTF 文件已讲解完毕。&lt;/p>
&lt;p>&lt;strong>但是有一点我们没有提到，就是使用 glTF 中自带的灯光、镜头、动画等内容。&lt;/strong>&lt;/p>
&lt;p>由于目前我还不会在 Blender 创建动画，所以这一块我们暂且保留，等待以后有机会再继续学习。&lt;/p>
&lt;br>
&lt;p>在 Three.js 中，还有很多其他文件格式的加载器，我们就不逐个讲解了，具体的可以查阅官方文档。&lt;/p>
&lt;br>
&lt;p>你以为本文结束了？没有！&lt;/p>
&lt;p>在上面示例中，我们实际上漏掉了一个非常重要的知识点：加载被压缩过的 .glb 文件&lt;/p>
&lt;br>
&lt;h2 id="gltf-文件压缩和加载解压draco">glTF 文件压缩和加载(解压)——Draco&lt;/h2>
&lt;p>在本文的示例中，所演示加载的 .glb 文件是我自己在 Blender 中创建导出的。&lt;/p>
&lt;p>如同图片文件一样，也有专门针对 .glb 文件压缩的工具，最为著名的就是谷歌公司开源的：draco&lt;/p>
&lt;h3 id="draco-简介">Draco 简介&lt;/h3>
&lt;p>Draco 是一种库，用于压缩和解压缩 3D 几何网格(geometric mesh) 和 点云(point cloud)&lt;/p>
&lt;p>draco 官网：https://google.github.io/draco/&lt;/p>
&lt;p>draco 源码：https://github.com/google/draco&lt;/p>
&lt;br>
&lt;p>draco 底层是使用 c++ 编写的。&lt;/p>
&lt;p>draco 可以在不牺牲模型效果的前提下，将 .glb 文件压缩体积减小很多。&lt;/p>
&lt;blockquote>
&lt;p>就好像将普通文件压缩成 .zip 一样&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>至于文件减少多少，这个暂时没有查询到&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="draco-使用流程是">Draco 使用流程是：&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>使用 Draco 将模型压缩，最终压缩后的文件格式为 .drc 或 .glb&lt;/p>
&lt;blockquote>
&lt;p>Draco 可以压缩众多 3D 格式文件，.glb 仅仅是其中一种&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在 .glb 文件内部有一个特殊字段，用来表述本文件是否经过了 draco 压缩&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当客户端(JS) 使用 GLTFLoader 去加载某个 .glb 文件时会去读取该标识&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若判断该 .glb 文件未被压缩则直接进行加载和解析&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若判断该 .glb 文件是被 draco 压缩过的，则会尝试调用 draco 解压类，下载 .glb 文件的同时进行解压，最终将下载、解压后的 .glb 数据传递给 GLTFLoader 使用&lt;/p>
&lt;blockquote>
&lt;p>这就引申出来一个事情：我们需要提前将负责 draco 解压的类传递给 GLTFLoader，具体如何做请看后面的讲解。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;h4 id="如何使用-draco-压缩-glb-文件">如何使用 Draco 压缩 .glb 文件？&lt;/h4>
&lt;p>具体如何操作实现，暂时我也没有学习，先搁置一下。&lt;/p>
&lt;blockquote>
&lt;p>敬请期待以后的更新&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="如何在-threejs-中加载压缩过的-glb-文件">如何在 Three.js 中加载压缩过的 .glb 文件？&lt;/h4>
&lt;p>关于 Draco 的介绍，可以查看 Three.js 对于 Draco 的介绍描述：&lt;/p>
&lt;p>&lt;a href="https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco&lt;/a>&lt;/p>
&lt;p>Three.js 源码包中 draco 针对 gltf 文件的解压文件库：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>draco/ 目录下有 4 个文件：draco_decoder.js、draco_decoder.wasm、draco_encoder.js、draco_wasm_wrapper.js&lt;/p>
&lt;/li>
&lt;li>
&lt;p>draco/gltf/ 目录下面同样有 4 个文件&lt;/p>
&lt;blockquote>
&lt;p>请注意 draco/ 和 draco/gltf/ 目录下的 4 个文件虽然是名字一样，但是他们内容并不相同。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>分别解释一下这 4 个文件：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>draco_decoder.js&lt;/p>
&lt;blockquote>
&lt;p>draco 解压(解码) 相关 js&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>draco_decoder.wasm&lt;/p>
&lt;blockquote>
&lt;p>.wasm 文件是 WebAssembly 解码器&lt;/p>
&lt;p>关于 WebAssembly 更多知识，请执行查阅：https://www.wasm.com.cn/&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>draco_encoder.js&lt;/p>
&lt;blockquote>
&lt;p>draco 压缩(编码) 相关 js&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>draco_wasm_wrapper.js&lt;/p>
&lt;blockquote>
&lt;p>用于封装 .wasm 解码器的 js&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>重点来了&amp;hellip;&lt;/p>
&lt;br>
&lt;h4 id="第-1-步拷贝-draco-文件到项目-public-中">第 1 步：拷贝 draco 文件到项目 public 中&lt;/h4>
&lt;p>我们将 Three.js 中 examples/js/libs/draco 目录拷贝到 React 项目的 public 目录中。&lt;/p>
&lt;blockquote>
&lt;p>draco 属于第 3 方库，我们目前暂时采用拷贝到 public 目录中这种形式&lt;/p>
&lt;p>请记得一定拷贝的是 draco/，其中包含 draco/gltf/ 目录&lt;/p>
&lt;/blockquote>
&lt;h4 id="第-2-步实例化一个-dracoloader并传递给-gltfloader">第 2 步：实例化一个 DRACOLoader，并传递给 GLTFLoader&lt;/h4>
&lt;blockquote>
&lt;p>关于 DRACOLoader 的详细解释，请参考官方文档：&lt;/p>
&lt;p>&lt;a href="https://threejs.org/docs/#examples/zh/loaders/DRACOLoader" target="_blank" rel="noopener">https://threejs.org/docs/#examples/zh/loaders/DRACOLoader&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>我们将之前 GLTFLoader 的代码修改如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ import { DRACOLoader } from &amp;#39;three/examples/jsm/loaders/DRACOLoader&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> const gltfLoader = new GLTFLoader()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ const dracoLoader = new DRACOLoader()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ dracoLoader.setDecoderPath(&amp;#39;./examples/js/libs/draco/&amp;#39;)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ dracoLoader.setDecoderConfig({ type: &amp;#39;js&amp;#39; })
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">+ gltfLoader.setDRACOLoader(dracoLoader)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gi">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> gltfLoader.load(&amp;#39;./model/vivo.glb&amp;#39;, (gltf) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> scene.add(gltf.scene)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;p>下面就针对上面 4 行核心代码进行解释说明：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>const dracoLoader = new DRACOLoader()&lt;/code>&lt;/p>
&lt;p>实例化一个 DRACOLoader&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dracoLoader.setDecoderPath('./examples/js/libs/draco/')&lt;/code>&lt;/p>
&lt;p>设置 dracoLoader 应该去哪个目录里查找 解压(解码) 文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dracoLoader.setDecoderConfig({ type: 'js' })&lt;/code>&lt;/p>
&lt;p>设置 dracoLoader 的配置项&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>gltfLoader.setDRACOLoader(dracoLoader)&lt;/code>&lt;/p>
&lt;p>将 dracoLoader 传递给 gltfLoader，供 gltfLoader 使用&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>至此，结束！&lt;/p>
&lt;br>
&lt;p>虽然 draco 非常复杂，但是对于我们使用者而言却很简单，仅仅上面 4 行代码即可实现加载被 draco 压缩过的 .glb 文件。&lt;/p>
&lt;br>
&lt;h2 id="加载drc-模型文件">加载.drc 模型文件&lt;/h2>
&lt;p>在上面示例中，我们加载的是被 draco 压缩过的 .glb 文件。&lt;/p>
&lt;p>那如果是被 draco 压缩过的 .drc 文件呢？&lt;/p>
&lt;p>答：更加简单，直接使用 DRACOLoader 即可。&lt;/p>
&lt;br>
&lt;p>DRACOLoader 使用示例代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>const loader = new DRACOLoader();
loader.setDecoderPath( &amp;#39;/examples/js/libs/draco/&amp;#39; );
loader.preload();
loader.load(&amp;#39;./xxx/model.drc&amp;#39;,
function ( geometry ) {
const material = new THREE.MeshStandardMaterial( { color: 0x606060 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
}
}
&lt;/code>&lt;/pre>&lt;br>
&lt;h2 id="补充说明修改模型位置偏差">补充说明：修改模型位置偏差&lt;/h2>
&lt;p>无论加载 .obj 文件，还是本章讲解的加载 .gltf 文件，假设模型在建模软件中位置中心并不是原点，而是非常偏远的位置。&lt;/p>
&lt;p>那么文件加载完成后，将模型添加到场景中，模型的位置并不在场景视角的中心位置，如果位置过于偏远，甚至有可能根本看不见模型。&lt;/p>
&lt;p>我们可以通过以下方式，计算模型的位置偏差，并修正模型的位置，使其出现在视野中心位置。&lt;/p>
&lt;pre tabindex="0">&lt;code>const loader = new GLTFLoader()
loader.load(&amp;#39;./model/lddq.gltf&amp;#39;, (gltf) =&amp;gt; {
const group = gltf.scene
const box = new Three.Box3().setFromObject(group)
const center = box.getCenter(new Three.Vector3())
group.position.x += (group.position.x - center.x)
group.position.y += (group.position.y - center.y)
group.position.z += (group.position.z - center.z)
scene.add(group)
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Box3 的介绍请执行查阅官方文档。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>下一章节，我们要学习如何添加 场景背景，呵， VR 看房效果要来了！&lt;/p></description></item><item><title>25.Three.js 解决方案之添加背景和天空盒</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/25.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/25.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/</guid><description>&lt;h1 id="25-threejs-解决方案之添加背景和天空盒">25 Three.js 解决方案之添加背景和天空盒&lt;/h1>
&lt;p>在我们之前所有演示的案例中，场景中的背景往往使用默认的黑色，或者是其他纯颜色。&lt;/p>
&lt;p>下面我们讲解一下 Three.Screen 的背景设置方式。&lt;/p>
&lt;br>
&lt;h2 id="设置场景背景">设置场景背景&lt;/h2>
&lt;p>场景(Three.Screen)有一个属性 .background。我们可以通过设置这个属性来给场景添加背景。&lt;/p>
&lt;br>
&lt;p>&lt;strong>.background 属性值类型&lt;/strong>&lt;/p>
&lt;p>场景背景属性值一共有 3 种类型：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>默认为 null&lt;/p>
&lt;blockquote>
&lt;p>.background 属性值为 null，场景显示为黑色&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>某颜色 Three.Color&lt;/p>
&lt;blockquote>
&lt;p>Three.Color 可接受 字符串或数字类型的颜色值，例如:&lt;/p>
&lt;ol>
&lt;li>new Three.Color(&amp;rsquo;#333')&lt;/li>
&lt;li>new Three.Color(&amp;lsquo;green&amp;rsquo;)&lt;/li>
&lt;li>new Three.Color(0x333333)&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>某纹理 Three.Texture&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>设置背景色示例代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const scene = new Three.Scene()
scene.background = new Three.Color(0x333333)
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;strong>设置背景纹理图片示例代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const scene = new Three.Scene()
const textureLoader = new Three.TextureLoader()
scene.background = textureLoader.load(require(&amp;#39;@/assets/imgs/blue_sky.jpg&amp;#39;).default)
&lt;/code>&lt;/pre>&lt;p>或者是&lt;/p>
&lt;pre tabindex="0">&lt;code>const textureLoader = new Three.TextureLoader()
textureLoader.load(require(&amp;#39;@/assets/imgs/blue_sky.jpg&amp;#39;).default, (texture) =&amp;gt; {
scene.background = texture
})
&lt;/code>&lt;/pre>&lt;br>
&lt;p>上面设置场景纹理背景图，实际运行后你会发现虽然背景图显示了，但是背景图却有可能是变形着的。&lt;/p>
&lt;p>这是由于背景图片本身就一个宽高比，而画布(Canvas)本身也有一个宽高比。&lt;/p>
&lt;blockquote>
&lt;p>实际上是渲染器渲染尺寸的宽高，例如每次浏览器窗口尺寸发生变化时，我们都会重新设置 渲染尺寸&lt;/p>
&lt;pre tabindex="0">&lt;code>renderer.setSize(width, height, false)
&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>判断高宽比，不让背景图变形且可以铺满整个背景&lt;/strong>&lt;/p>
&lt;p>假设我们不能接受背景图变形，那么我们就需要计算一下 2 者的宽高比，然后找出合适的比例进行修改。&lt;/p>
&lt;p>这个不让背景图变形的计算过程是：&lt;/p>
&lt;ol>
&lt;li>计算出画布宽高比，例如 canvasAspect&lt;/li>
&lt;li>计算出背景图宽高比，例如 imgAspect&lt;/li>
&lt;li>然后计算 imgAspect/canvasAspect，得到 最终背景图在不变形的前提下的缩放比，例如 const resultAspect = imgAspect / canvasAspect&lt;/li>
&lt;li>然后依次设置背景图纹理的偏移(offset.x、offset.y)，以及判断是否需要重复平铺背景图(repeat.x、repeat.y)&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>示例代码如下：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const textureRef = useRef&amp;lt;Three.Texture | null&amp;gt;(null)
...
const textureLoader = new Three.TextureLoader()
textureLoader.load(require(&amp;#39;@/assets/imgs/blue_sky.jpg&amp;#39;).default, (texture) =&amp;gt; {
textureRef.current = texture
scene.background = textureRef.current
handleResize() //此处是当纹理图片加载完成后，需要调用执行一下 handleResize()
})
...
const handleResize = () =&amp;gt; {
const canvasAspect = width / height //第1步：计算出画布宽高比
if (textureRef.current !== null) {
const bgTexture = textureRef.current
const imgAspect = bgTexture.image.width / bgTexture.image.height //第2步：计算出背景图宽高比
const resultAspect = imgAspect / canvasAspect //第3步：计算出最终背景图宽缩放宽高比
//第4步：设置背景图纹理的偏移和重复
bgTexture.offset.x = resultAspect &amp;gt; 1 ? (1 - 1 / resultAspect) / 2 : 0
bgTexture.repeat.x = resultAspect &amp;gt; 1 ? 1 / resultAspect : 1
bgTexture.offset.y = resultAspect &amp;gt; 1 ? 0 : (1 - resultAspect) / 2
bgTexture.repeat.y = resultAspect &amp;gt; 1 ? 1 : resultAspect
}
}
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;strong>完整的示例代码如下：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>import { useRef, useEffect } from &amp;#34;react&amp;#34;
import * as Three from &amp;#39;three&amp;#39;
import { OrbitControls } from &amp;#34;three/examples/jsm/controls/OrbitControls&amp;#34;
import { GLTFLoader } from &amp;#34;three/examples/jsm/loaders/GLTFLoader&amp;#34;
import &amp;#39;./index.scss&amp;#39;
const HelloSkybox = () =&amp;gt; {
const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
const textureRef = useRef&amp;lt;Three.Texture | null&amp;gt;(null)
useEffect(() =&amp;gt; {
if (canvasRef.current === null) { return }
const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
const scene = new Three.Scene()
const textureLoader = new Three.TextureLoader()
textureLoader.load(require(&amp;#39;@/assets/imgs/blue_sky.jpg&amp;#39;).default, (texture) =&amp;gt; {
textureRef.current = texture
scene.background = textureRef.current
handleResize()
})
scene.background = textureRef.current
const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
camera.position.set(10, 0, 10)
const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1)
scene.add(light)
const loader = new GLTFLoader()
loader.load(require(&amp;#39;@/assets/model/hello.glb&amp;#39;).default, (gltf) =&amp;gt; {
scene.add(gltf.scene)
})
const control = new OrbitControls(camera, canvasRef.current)
control.update()
const render = () =&amp;gt; {
renderer.render(scene, camera)
window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
const handleResize = () =&amp;gt; {
if (canvasRef.current === null) { return }
const width = canvasRef.current.clientWidth
const height = canvasRef.current.clientHeight
const canvasAspect = width / height
if (textureRef.current !== null) {
const bgTexture = textureRef.current
const imgAspect = bgTexture.image.width / bgTexture.image.height
const resultAspect = imgAspect / canvasAspect
bgTexture.offset.x = resultAspect &amp;gt; 1 ? (1 - 1 / resultAspect) / 2 : 0
bgTexture.repeat.x = resultAspect &amp;gt; 1 ? 1 / resultAspect : 1
bgTexture.offset.y = resultAspect &amp;gt; 1 ? 0 : (1 - resultAspect) / 2
bgTexture.repeat.y = resultAspect &amp;gt; 1 ? 1 : resultAspect
}
camera.aspect = canvasAspect
camera.updateProjectionMatrix()
renderer.setSize(width, height, false)
}
handleResize()
window.addEventListener(&amp;#39;resize&amp;#39;, handleResize)
return () =&amp;gt; {
window.removeEventListener(&amp;#39;resize&amp;#39;, handleResize)
}
}, [])
return (
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; /&amp;gt;
)
}
export default HelloSkybox
&lt;/code>&lt;/pre>&lt;br>
&lt;p>请注意，上面讲述的是将背景图片加载进 Three.js 中，并当做纹理来使用。我们可以通过修改纹理各种属性来修改和控制背景图。&lt;/p>
&lt;blockquote>
&lt;p>上面示例代码中仅仅是对纹理的偏移和重复进行了设置&lt;/p>
&lt;/blockquote>
&lt;p>但是，假设就仅仅为了达到上述效果，实际上我们根本不用搞这么复杂，直接给网页中 &amp;lt;canvas&amp;gt; 标签设置一个背景图片即可。&lt;/p>
&lt;br>
&lt;p>&lt;strong>第 1 步：添加渲染器参数 alpha:true&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current, alpha: true })
&lt;/code>&lt;/pre>&lt;br>
**第2步：给画布标签(&lt;canvas\>)添加背景图**
&lt;p>第 1 种添加方式：通过 css 添加&lt;/p>
&lt;pre tabindex="0">&lt;code>.full-screen {
display: block;
width: inherit;
height: inherit;
background: url(./imgs/blue_sky.jpg) no-repeat center center;
background-size: cover;
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意：上面 .scss 中我们给背景设置的图片路径，其实指向项目的 public 目录&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>第 2 种添加方式：通过 JS 添加&lt;/p>
&lt;pre tabindex="0">&lt;code>const canvasStyle = {
background: `url(${require(&amp;#39;@/assets/imgs/blue_sky.jpg&amp;#39;).default}) center center no-repeat`,
backgroundSize: &amp;#39;cover&amp;#39;
}
&amp;lt;canvas ref={canvasRef} className=&amp;#39;full-screen&amp;#39; style={canvasStyle} /&amp;gt;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>React 在编译时，会自动将 &lt;code>style={canvasStyle}&lt;/code> 中的样式转化为 CSS 样式&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>至此，关于如何设置场景背景图片，讲解完毕。&lt;/p>
&lt;p>接下来要讲解一个常见的 Three.js 应用场景：SkyBox(天空盒)。&lt;/p>
&lt;br>
&lt;h2 id="天空盒skybox">天空盒(Skybox)&lt;/h2>
&lt;p>假设我们身处一个立方体内部，我们可以观察到立方体内部 6 个面的背景贴图。&lt;/p>
&lt;blockquote>
&lt;p>这不就是我们身处某个房间内吗？&lt;/p>
&lt;/blockquote>
&lt;p>这类应用场景，通常被称呼为 Skybox，也就是 天空盒。&lt;/p>
&lt;p>这也是我们日常听到对最多的 Web 3D 应用：VR 看房&lt;/p>
&lt;br>
&lt;p>上面对于天空盒的解释正确吗？&lt;/p>
&lt;p>答：正确但不严谨！&lt;/p>
&lt;br>
&lt;p>通常我们所说天空盒(Skybox) 一个非常重要的特性就是：像天空一样大的盒子&lt;/p>
&lt;p>进一步解释就是：这个盒子空间像天空一样无边无际，永远不到头。&lt;/p>
&lt;blockquote>
&lt;p>说直白点，天空盒就好像我们平时的场景(Three.Scene)，无论缩小到什么限度，还是放大到什么限度，永远走不出场景之外。&lt;/p>
&lt;/blockquote>
&lt;p>而本文下面所有的示例，其实都是针对场景背景添加纹理贴图，所以下面示例中的天空盒(skybox)空间等同于场景本身。&lt;/p>
&lt;br>
&lt;p>&lt;strong>天空盒一共有 2 种形式的贴图资源：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>全景图(hdri)，又名 天空图&lt;/li>
&lt;li>立方体贴图(cubemap)&lt;/li>
&lt;/ol>
&lt;br>
&lt;h4 id="第-1-种实现天空盒的方法全景图hdri">第 1 种实现天空盒的方法：全景图(hdri)&lt;/h4>
&lt;p>很明显，我们最容易想到的实现方式为：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我们把整个 Three.Screen 当做立方体，也就是将整个场景当做立方体&lt;/p>
&lt;blockquote>
&lt;p>再次重复一遍：我们并不是在场景中创建一个立方体，而是直接将整个场景当做立方体&lt;/p>
&lt;p>假设你要给场景中某个立方体设置类似的效果，那么你要做的事情是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建纹理，使用立方体纹理加载器(Three.CubeTextureLoader)加载图片资源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建材质，除了设置材质的纹理之外，还要设置 .side 属性，将值为 Three.BackSide，例如&lt;/p>
&lt;pre tabindex="0">&lt;code>new MeshPhongMaterial({ map:xxxx, side: Three.BackSide })
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>最终创建立方体网格(Three.Mesh)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;blockquote>
&lt;p>请注意：绝大多数 VR 看房，都是将场景当做立方体即可。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>按照指定顺序，获取(加载) 6 个面的纹理贴图，得到纹理&lt;/p>
&lt;blockquote>
&lt;p>请注意，这次加载我们并不使用 Three.TextureLoader，而是采用立方体专有的纹理加载器 Three.CubeTextureLoader&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>将得到的纹理作为场景背景&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置相机坐标 z 的值，确保我们可以看到物体，例如&lt;/p>
&lt;pre tabindex="0">&lt;code>camera.position.set(0, 0, 10)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>然后正常渲染，我们就会感觉此刻身在房间中&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>示例代码：&lt;/strong>&lt;/p>
&lt;p>房间图片素材：&lt;/p>
&lt;p>我们使用网上找到的某房间 6 个面的纹理贴图&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg&lt;/a>&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>实际代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>const cubeTextureLoader = new Three.CubeTextureLoader()
cubeTextureLoader.load([
&amp;#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg&amp;#39;,
&amp;#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg&amp;#39;,
&amp;#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg&amp;#39;,
&amp;#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg&amp;#39;,
&amp;#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg&amp;#39;,
&amp;#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg&amp;#39;
], (texture) =&amp;gt; {
scene.background = texture
})
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;strong>针对贴图资源顺序的补充说明：&lt;/strong>&lt;/p>
&lt;p>在上面示例代码中，我们可以看到加载立方体 6 面图片贴图资源的顺序是固定的，依次为：&lt;/p>
&lt;p>pos-x.jpg、neg-x.jpg、pos-y.jpg、neg-y.jpg、pos-z.jpg、neg-z.jpg&lt;/p>
&lt;br>
&lt;p>&lt;strong>&amp;ldquo;pos&amp;rdquo; 是单词 &amp;ldquo;positive&amp;rdquo; 的缩写，在 3D 坐标系中意思是 正&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>positive：积极的、正向的、乐观的&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>&amp;ldquo;neg&amp;rdquo; 是单词 &amp;ldquo;negative&amp;rdquo; 的缩写，在 3D 坐标系中意思是 负&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>negative：消极的、负面的&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h3 id="左手坐标系统-vs-右手坐标系统">左手坐标系统 VS 右手坐标系统&lt;/h3>
&lt;p>我们先介绍一下 右手坐标系统，你就自然明白什么是左手坐标系统了。&lt;/p>
&lt;p>我们看一下百度百科的介绍：&lt;/p>
&lt;p>右手系(right-hand system)是在空间中规定直角坐标系的方法之一。此坐标系中 x 轴，y 轴和 z 轴的正方向是如下规定的：把右手放在原点的位置，使大拇指，食指和中指互成直角，把大拇指指向 x 轴的正方向，食指指向 y 轴的正方向时，中指所指的方向就是 z 轴的正方向。&lt;/p>
&lt;br>
&lt;p>同样的操作你换做左手，那么就是左手坐标系统。&lt;/p>
&lt;p>&lt;strong>左手坐标系统和右手坐标系统在 Y 轴、Z 轴 方面没有区别，但是在 X 轴上是彼此相反的。&lt;/strong>&lt;/p>
&lt;br>
&lt;p>&lt;strong>对于立方体贴图，使用的是左手系统！&lt;/strong>&lt;/p>
&lt;p>因此上面图片名称的含义为：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>对应立方体内部的面来说&lt;/th>
&lt;th>对于站在立方体内部中间的人来说&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>pos-x&lt;/td>
&lt;td>X 轴正方向&lt;/td>
&lt;td>左面&lt;/td>
&lt;td>视觉左方&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>neg-x&lt;/td>
&lt;td>X 轴负方向&lt;/td>
&lt;td>右面&lt;/td>
&lt;td>视觉右方&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pos-y&lt;/td>
&lt;td>Y 轴正方向&lt;/td>
&lt;td>上面&lt;/td>
&lt;td>视觉上方&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>neg-y&lt;/td>
&lt;td>Y 轴负方向&lt;/td>
&lt;td>下面&lt;/td>
&lt;td>视觉下方&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pos-z&lt;/td>
&lt;td>Z 轴正方向&lt;/td>
&lt;td>后面&lt;/td>
&lt;td>视觉后方&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>neg-z&lt;/td>
&lt;td>Z 轴负方向&lt;/td>
&lt;td>前面&lt;/td>
&lt;td>视觉前方&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>请注意，立方体的前面或后面完全是由观察者所处的位置来决定的。&lt;/p>
&lt;p>如果你在立方体外面去看立方体，那么正面看到的是立方体的正面，看不到的是立方体的背面。&lt;/p>
&lt;p>但是我们现在做的是站在立方体内部去观察立方体，所以此刻 “立方体的正面” 实际上对于我们观察者而言是在我们身后，也就是我们的视觉后方。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>对于 Three.js 渲染使用的是 右手坐标系统！&lt;/strong>&lt;/p>
&lt;p>&lt;strong>不过你不用担心左右方向相反这个事情，因为在 Three.js 内部在渲染的时候会自动帮我们将左右对调。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>重复一遍：&lt;/p>
&lt;ol>
&lt;li>一般立方体模型贴图使用左手坐标系统&lt;/li>
&lt;li>Three.js 整体使用右手坐标系统&lt;/li>
&lt;li>但在渲染立方体内部贴图时，Three.js 会自动帮我们做好左右兑换&lt;/li>
&lt;li>因此我们在传递纹理贴图时，贴图顺序使用的是左手坐标系统&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;br>
&lt;blockquote>
&lt;p>糟糕，我也是今天学习到这里才彻底明白坐标系统，我可能在之前的文章中对于 上下左右前后 讲解错了，但是我暂时记不清是哪一章节。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="第-2-种实现天空盒的方法立方体贴图cubemap">第 2 种实现天空盒的方法：立方体贴图(cubemap)&lt;/h4>
&lt;p>我们第 1 种实现天空盒，实际上使用的是 6 个面的图片资源组合成了一个 3D 空间。&lt;/p>
&lt;p>接下来我们学习使用一张 360° 球形相机拍摄的照片，来实现 3D 空间立方体。&lt;/p>
&lt;br>
&lt;p>首先你从网上找到一张 360° 的场景图片资源：&lt;/p>
&lt;p>&lt;a href="https://threejsfundamentals.org/threejs/resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg" target="_blank" rel="noopener">https://threejsfundamentals.org/threejs/resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>请注意，这类图片尺寸宽高比例为 2:1，经常称呼这类图片为 “全景图”&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>实现思路：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>使用纹理加载器加载该图片资源&lt;/p>
&lt;blockquote>
&lt;p>这种 2:1 的图片，被称为 “等矩形图像”&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>实例化一个 Three.WebGLCubeRenderTarget，构造函数中的 size 属性为图片资源的高&lt;/p>
&lt;blockquote>
&lt;p>WebGLCubeRenderTarget 继承于 WebGLRenderTarget，属于离屏渲染的一种特例(专门针对立方体模型)&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在 WebGLRenderTarget 的源码中可以看到这句代码：super( size, size, options );&lt;/p>
&lt;p>WebGLRenderTarget 构造函数需要传递 width 和 height，但是 WebGLCubeRenderTarget 构造函数只需传入 1 个 size，因为正方体，所以宽高一样。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>调用该实例化对象的 fromEquirectangularTexture() 函数&lt;/p>
&lt;blockquote>
&lt;p>将等距图像 转化为 立方体模型贴图&lt;/p>
&lt;blockquote>
&lt;p>可以简单理解成：就是将 1 整张图片转化为 6 个面的立方体模型贴图，并进行渲染&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>将场景背景设置为该实例对象&lt;/p>
&lt;blockquote>
&lt;p>这样相当于将场景背景图的值设置为 WebGLCubeRenderTarget 的渲染结果&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>具体代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const textureLoader = new Three.TextureLoader()
textureLoader.load(require(&amp;#39;@/assets/imgs/tears_of_steel_bridge.jpg&amp;#39;).default,
(texture) =&amp;gt; {
const crt = new Three.WebGLCubeRenderTarget(texture.image.height)
crt.fromEquirectangularTexture(renderer,texture)
scene.background = crt.texture
}
)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>补充说明：scene.background 的类型为 WebGLBackground&lt;/p>
&lt;p>请留意上述代码中 &lt;code>scene.background = crt.texture&lt;/code>，事实上在以前的一些教程中可以写成 &lt;code>scene.background = crt&lt;/code>，WebGLBackground 会在内部进行判断，如果 background 类型为 WebGLRenderTarget，则使用该实例的 .texture 属性值。&lt;/p>
&lt;p>但是在最新版 r127 中已经删除了该判断代码，所以现在必须写成 &lt;code>scene.background = crt.texture&lt;/code>。&lt;/p>
&lt;p>就这个问题，我已向官网教程进行了修改提交：https://github.com/gfxfundamentals/threejsfundamentals/pull/205&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h3 id="补充说明全景图hdri-与-立方体贴图cubemap-互转">补充说明：全景图(hdri) 与 立方体贴图(cubemap) 互转&lt;/h3>
&lt;p>网上有人提供了 全景图与立方体模型图 之间的转化工具包：&lt;/p>
&lt;p>在线地址：https://matheowis.github.io/HDRI-to-CubeMap/&lt;/p>
&lt;p>项目源码：https://github.com/aunyks/hdri-to-cubemap&lt;/p>
&lt;br>
&lt;p>你以为本文结束了？没有！&lt;/p>
&lt;p>我们上面示例都是 天空盒(skybox)，那如果是真的一个立方体呢？&lt;/p>
&lt;blockquote>
&lt;p>天空盒 是没有尺寸，空间无限大的，而普通立方体则是有尺寸的。&lt;/p>
&lt;/blockquote>
&lt;p>下面示例我们将创建一个立方体，然后对立方体内部进行贴图，并渲染和观察立方体盒子内部。&lt;/p>
&lt;br>
&lt;h2 id="普通立方体内部贴图和渲染">普通立方体内部贴图和渲染&lt;/h2></description></item><item><title>26.Three.js 解决方案之透明度bug</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/26.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%8F%E6%98%8E%E5%BA%A6bug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/26.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%8F%E6%98%8E%E5%BA%A6bug/</guid><description>&lt;h1 id="26-threejs-解决方案之透明度-bug">26 Three.js 解决方案之透明度 bug&lt;/h1>
&lt;p>透明度(transparency) 在 Three.js 中很容易实现，但是透明度又存在一个 &amp;ldquo;Bug&amp;rdquo;，解决起来又比较难。&lt;/p>
&lt;blockquote>
&lt;p>请注意，这里说的 “Bug” 是加了引号的，具体原因我们稍后讲解。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>我们先从一个简单的示例开始。&lt;/p>
&lt;h3 id="示例-1渲染一个半透明的立方体">示例 1：渲染一个半透明的立方体&lt;/h3>
&lt;p>所有材质的基类 Three.Material 有 2 个属性和设置透明度有关：&lt;/p>
&lt;ol>
&lt;li>transparent：设置材质是否透明&lt;/li>
&lt;li>opacity：设置材质透明度，取值范围 0 - 1&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>由于 Material 是所有材质的基类，也就意味着所有材质都拥有上述 2 个属性&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>假设我们想创建一个半透明的立方体，代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>const geometry = new Three.BoxBufferGeometry(2, 2, 2)
const material = new Three.MeshBasicMaterial({
color: &amp;#39;red&amp;#39;,
transparent: true,
opacity: 0.5
})
const cube = new Three.Mesh(geometry, material)
scene.add(cube)
&lt;/code>&lt;/pre>&lt;br>
&lt;p>上面我们只是给材质设置了一个 红色，当我们运行程序的时候会发现：单独一个半透明立方体，似乎看不出任何半透明的意思。&lt;/p>
&lt;blockquote>
&lt;p>即使给材质添加 &lt;code>side: Three.DoubleSide&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>我们需要添加多个半透明立方体，才更容易看出来彼此半透明。&lt;/p>
&lt;p>我们继续修改示例。&lt;/p>
&lt;br>
&lt;h3 id="渲染-8-个小立方体">渲染 8 个小立方体&lt;/h3>
&lt;p>我们的渲染目标：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>渲染 8 个不同颜色，透明度都为 0.5 的立方体&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这 8 个立方体分布在一个 2 x 2 x 2 的空间中&lt;/p>
&lt;blockquote>
&lt;p>这种分布方式，在魔方玩具中被称为 “二阶魔方”&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>每个立方体 里外 2 个面都要进行渲染&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>具体实现代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>const colors = [&amp;#39;red&amp;#39;, &amp;#39;blue&amp;#39;, &amp;#39;darkorange&amp;#39;, &amp;#39;darkviolet&amp;#39;, &amp;#39;green&amp;#39;, &amp;#39;tomato&amp;#39;, &amp;#39;sienna&amp;#39;, &amp;#39;crimson&amp;#39;]
const cube_size = 1 //立方体尺寸
const cube_margin = 0.6 //立方体间距空隙
colors.forEach((color, index) =&amp;gt; {
const geometry = new Three.BoxBufferGeometry(cube_size, cube_size, cube_size)
const material = new Three.MeshPhongMaterial({
color,
transparent: true,
opacity: 0.5,
side: Three.DoubleSide
})
const cube = new Three.Mesh(geometry, material)
cube.position.x = (index % 2 ? 1 : -1) * cube_size * cube_margin
cube.position.y = (Math.floor(index / 4) ? -1 : 1) * cube_size * cube_margin
cube.position.z = ((index % 4) &amp;gt;= 2) ? 1 : -1 * cube_size * cube_margin / 2
scene.add(cube)
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>在目前最新的 Three.js r127 版本中，对于预置颜色的单词，只支持全小写，例如：&lt;/p>
&lt;ol>
&lt;li>红色 只可以写 &lt;code>red&lt;/code>，不可以写成 &lt;code>Red&lt;/code>&lt;/li>
&lt;li>再或者 暗桔色 只可以写 &lt;code>darkorange&lt;/code>，不可以写成&lt;code>DarkOrange&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>这是因为在 Color 源码中，记录内置颜色值的对象 key 都是小写，我已针对这个问题提交了自己的 pr：&lt;/p>
&lt;p>&lt;a href="https://github.com/mrdoob/three.js/pull/21687" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/pull/21687&lt;/a>&lt;/p>
&lt;p>我修改了一点代码，让取值时对颜色值的字符串执行 .toLowerCase()，这样即使颜色值字符串有大写可以最终实际被转化为小写。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>实际运行后，就会看到 8 个半透明的小立方体。通过 OrbitControls 旋转视角，看着感觉挺好的呀。&lt;/p>
&lt;br>
&lt;!-- 如果我不告诉你，可能你一直也发现不了这里面存在着一个 “bug” -->
&lt;p>当你尝试不断变换视角查看立方体时，在某些特殊的视角下，我们看不到立方体左侧后表面。&lt;/p>
&lt;blockquote>
&lt;p>也就是说，原本立方体左侧后表面应该也被渲染，但是实际上并未被渲染。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>如果你实在是没有看出来什么问题，暂时相信我一下，就好像你已真的发现了那样。&lt;/p>
&lt;p>下面听一下关于出现这个 &amp;ldquo;bug&amp;rdquo; 的解释。&lt;/p>
&lt;br>
&lt;h3 id="threejs-绘制-3d-对象的方式">Three.js 绘制 3D 对象的方式&lt;/h3>
&lt;p>上面提到的渲染 “Bug”，是由于 Three.js 绘制 3D 对象的方式造成的。&lt;/p>
&lt;br>
&lt;p>对于每一个几何图形，每个三角形一次只绘制一个。&lt;/p>
&lt;blockquote>
&lt;p>立方体的 1 个面是一个 正方形，而这个正方形是由 2 个三角形构成的。&lt;/p>
&lt;p>在绘制 1 个面(正方形)，Three.js 会先后绘制 2 个三角形，最终拼接成 1 个正方形。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>每次绘制一个三角形时，会记录 2 个事情：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>三角形的颜色&lt;/p>
&lt;/li>
&lt;li>
&lt;p>三角形的像素深度&lt;/p>
&lt;blockquote>
&lt;p>像素深度是指存储每个像素所用的位数，用来度量图像的分辨率。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>当绘制下一个三角形时，对于每一个像素，如果深度比之前记录的深度还要深，则不会绘制任何像素&lt;/p>
&lt;blockquote>
&lt;p>这其实是 Three.js 绘制物体时采取的一种节省性能的策略&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>这套策略对于不透明的物体来说非常有用，但是对于透明的物体却不起作用。&lt;/p>
&lt;br>
&lt;p>一个立方体有 6 个面，每个面 2 个三角形，也就意味着一个立方体需要绘制 12 个三角形。&lt;/p>
&lt;p>而这 12 个三角形究竟先绘制哪个，他们绘制的顺序是什么呢？&lt;/p>
&lt;p>答：绘制顺序取决于我们的视角，越接近相机的三角形越优先被绘制。&lt;/p>
&lt;blockquote>
&lt;p>这就是为什么我们上面提到的绘制 bug 只有在某些特定角度下才会出现的原因。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>越靠近相机的三角形越先被绘制，这也意味着在某些角度下，远离摄像机的某个面(立方体背面或侧背面)有可能不会被绘制。&lt;/p>
&lt;/blockquote>
&lt;p>这种情况不仅会出现在立方体身上，球体上也会出现。&lt;/p>
&lt;br>
&lt;p>&lt;strong>针对以上情况，有一种解决方案：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>将每个立方体添加 2 次到场景中&lt;/li>
&lt;li>第 1 次添加的立方体设置只让渲染 背面(Three.BackSide)&lt;/li>
&lt;li>第 2 次添加的立方体设置只让渲染 前面(Three.FrontSide)&lt;/li>
&lt;/ol>
&lt;p>这样一番操作过后，确保 Three.js 可以将每个立方体的前面、后面都会渲染，拼合一下 2 次的渲染结果，将 “正确的” 结果渲染出来。&lt;/p>
&lt;br>
&lt;p>&lt;strong>补充说明&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>上面的解决方案实际上需要绘制 2 次，这也许会造成性能上的浪费。&lt;/li>
&lt;li>如果你并不是特别在乎那一点点渲染 “Bug”，你完全可以忽视它。&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>接下来我们再通过另外一个示例，讲解另外一种有针对性的解决方案。&lt;/p>
&lt;br>
&lt;h3 id="绘制-2-个中心交叉的平面正方形">绘制 2 个中心交叉的平面正方形&lt;/h3>
&lt;p>我们的示例目标是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>绘制 2 个平面的正方形&lt;/p>
&lt;blockquote>
&lt;p>创建平面 在 Three.js 中使用的是 Three.PlaneBufferGeometry&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>给每个平面添加一个颜色和纹理贴图，两面都渲染，并设置正方形平面透明度为 0.5&lt;/p>
&lt;blockquote>
&lt;p>贴图我们直接使用网上的 2 张图片资源&lt;/p>
&lt;p>图片都是由背景色的，并非背景透明的 PNG&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>让这 2 个平面形成 十字交叉 的状态&lt;/p>
&lt;blockquote>
&lt;p>也就是说让其中一个平面的 y 轴旋转 180 度&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>实现的代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const planeDataArr = [
{
color: &amp;#39;red&amp;#39;,
ratation: 0,
imgsrc: &amp;#39;https://threejsfundamentals.org/threejs/resources/images/happyface.png&amp;#39;
},
{
color: &amp;#39;yellow&amp;#39;,
ratation: Math.PI * 0.5,
imgsrc: &amp;#39;https://threejsfundamentals.org/threejs/resources/images/hmmmface.png&amp;#39;
}
]
planeDataArr.forEach((value) =&amp;gt; {
const geometry = new Three.PlaneBufferGeometry(2, 2)
const textureLoader = new TextureLoader()
const material = new Three.MeshBasicMaterial({
color: value.color,
map: textureLoader.load(value.imgsrc),
opacity: 0.5,
transparent: true,
side:Three.DoubleSide
})
const plane = new Three.Mesh(geometry, material)
plane.rotation.y = value.ratation
scene.add(plane)
})
&lt;/code>&lt;/pre>&lt;br>
&lt;p>这次，我们将很容易看到，当红色平面一侧完全覆盖住黄色平面一侧时，会完全看不到黄色平面那一侧。&lt;/p>
&lt;blockquote>
&lt;p>实际运行效果我就不贴图了，你可以将上面代码实际运行一下。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>你就假装此刻你看到了。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>用我们上面讲过的理论可解释这个现象：即 红色平面一侧颜色深度大于黄色平面一侧，当完全覆盖住之后黄色平面那一侧就不会再进行渲染，所以我们就看不到了。&lt;/p>
&lt;br>
&lt;p>&lt;strong>解决方案：将上面 2 个平面拆分成 4 个平面，这样可以确保每个平面都会被渲染。&lt;/strong>&lt;/p>
&lt;p>由于我们这个场景 2 个平面十字交叉，所以我们就直接创建 4 个小的平面，然后将这 4 个小平面组合成 “2 个十字相交的平面”。&lt;/p>
&lt;p>具体实现的方式是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将原本 较大的 1 个平面拆分成 2 个小平面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置这 2 个小平面的纹理贴图偏移，各自占一半&lt;/p>
&lt;blockquote>
&lt;p>这样可以最终让 2 个小平面贴合成 1 个完整的平面(纹理)&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>为了方便我们计算旋转，好让他们形成十字交叉，所以我们可以将 每组小平面放置在同一个空间中&lt;/p>
&lt;blockquote>
&lt;p>这需要使用到 Three.Object3D&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>实际代码：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>const planeDataArr = [
{
color: &amp;#39;red&amp;#39;,
ratation: 0,
imgsrc: &amp;#39;https://threejsfundamentals.org/threejs/resources/images/happyface.png&amp;#39;
},
{
color: &amp;#39;yellow&amp;#39;,
ratation: Math.PI * 0.5,
imgsrc: &amp;#39;https://threejsfundamentals.org/threejs/resources/images/hmmmface.png&amp;#39;
}
]
planeDataArr.forEach((value) =&amp;gt; {
const base = new Three.Object3D()
base.rotation.y = value.ratation
scene.add(base)
const plane_size = 2
const half_size = plane_size / 2
const geometry = new Three.PlaneBufferGeometry(half_size, plane_size)
const arr = [-1, 1]
arr.forEach((x) =&amp;gt; {
const textureLoader = new TextureLoader()
const texture = textureLoader.load(value.imgsrc)
texture.offset.x = x &amp;lt; 1 ? 0 : 0.5
texture.repeat.x = 0.5
const material = new Three.MeshBasicMaterial({
color: value.color,
map: texture,
transparent: true,
opacity: 0.5,
side: Three.DoubleSide
})
const plane = new Three.Mesh(geometry, material)
plane.position.x = x * half_size / 2
base.add(plane)
});
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>假设我们目标平面宽高均为 2，那么：&lt;/p>
&lt;ol>
&lt;li>我们将该目标平面拆分成 2 个 宽 1、高 2 的平面&lt;/li>
&lt;li>获取并设置纹理贴图，并分别设置纹理的 offset.x 、repeat.x 各占 一半，也就是 0.5&lt;/li>
&lt;li>我们知道拆分出的 2 个小平面他们 x 轴相差 1 个小平面的宽度，由于我们设置的内部循环数组为 [-1,1]，所以 2 个小平面的 x 值应该是 正负宽度一半的一半。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;br>
&lt;p>这一次，我们再运行就会发现，无论任何视角下，红色平面不再会这该黄色平面了。&lt;/p>
&lt;br>
&lt;p>&lt;strong>这是第 2 种解决透明 &amp;ldquo;bug&amp;rdquo; 的方案：将对象进行拆分&lt;/strong>&lt;/p>
&lt;p>&lt;strong>但是请注意，该解决方式只适合那些简单，且位置相对固定的 3D 对象。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>若物体本身就比较复杂，面比较多，还要再拆分，那么就太消耗渲染性能&lt;/p>
&lt;p>并且位置必须相对固定，若不固定会增加我们拼接的难度&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>接下来讲解第 3 种解决方案。&lt;/p>
&lt;h3 id="启用-alphatest-来避免遮挡问题">启用 alphaTest 来避免遮挡问题&lt;/h3>
&lt;p>首先我们回顾一下上面的例子，当时示例中 2 个平面的纹理贴图背景是不透明的。&lt;/p>
&lt;p>那我们可以尝试另外 2 个图片贴图，他们是背景透明的 PNG 图片。&lt;/p>
&lt;p>我们要使用材质(Three.Material) 的一个属性 .alphaTest。&lt;/p>
&lt;br>
&lt;p>&lt;strong>.alphaTest 属性介绍&lt;/strong>&lt;/p>
&lt;p>.alphaTest 是一个透明度检测值，值得类型是 Number，取值范围为 0 - 1。&lt;/p>
&lt;p>若透明度低于该值，则不会进行渲染。&lt;/p>
&lt;blockquote>
&lt;p>反之，只有某个点透明度高于该值的才会进行渲染&lt;/p>
&lt;/blockquote>
&lt;p>.alphaTest 默认值为 0。&lt;/p>
&lt;blockquote>
&lt;p>也就是说默认情况下即使透明度为 0 也会进行渲染&lt;/p>
&lt;p>假设我们给材质设置有 color，那么肯定就会渲染出内容&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>我们在最初 2 个平面的代码基础上进行修改。&lt;/p>
&lt;ol>
&lt;li>修改纹理贴图资源，这次使用背景透明的 PNG 图片&lt;/li>
&lt;li>材质不再设置 .opacity 属性，改设置 .alphaTest 属性&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>修改后的代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>const planeDataArr = [
{
color: &amp;#39;red&amp;#39;,
ratation: 0,
imgsrc: &amp;#39;https://threejsfundamentals.org/threejs/resources/images/tree-01.png&amp;#39;
},
{
color: &amp;#39;yellow&amp;#39;,
ratation: Math.PI * 0.5,
imgsrc: &amp;#39;https://threejsfundamentals.org/threejs/resources/images/tree-02.png&amp;#39;
}
]
planeDataArr.forEach((value) =&amp;gt; {
const geometry = new Three.PlaneBufferGeometry(2, 2)
const textureLoader = new TextureLoader()
const material = new Three.MeshBasicMaterial({
color: value.color,
map: textureLoader.load(value.imgsrc),
alphaTest: 0.5,
transparent: true,
side:Three.DoubleSide
})
const plane = new Three.Mesh(geometry, material)
plane.rotation.y = value.ratation
scene.add(plane)
})
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>请注意，上面代码中我们取了一个透明度的中间值，将 .alphaTest 属性值设置为 0.5。&lt;/p>
&lt;p>你可以尝试将 .alphaTest 分别设置为 0.2 或 0.8 看看结果会有什么变化。&lt;/p>
&lt;blockquote>
&lt;p>最终边缘清晰度取决于贴图图片中抠图的精细程度。若边缘越不清晰(也就是越模糊)，最终呈现出的白边会越严重。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;br>
&lt;p>实际运行后就会发现，2 棵不同颜色的树木，彼此十字交叉，可以透过前面树的枝叶看到另外一颗树。&lt;/p>
&lt;h3 id="本文小节">本文小节&lt;/h3>
&lt;p>我们讲解了为什么会在某些视角下，某些半透明的物体个别地方三角面不会被渲染的原因。&lt;/p>
&lt;p>通过几个示例，讲解了 3 种解决方案：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将物体添加 2 份，1 份负责渲染前面，另外一份负责渲染后面&lt;/p>
&lt;blockquote>
&lt;p>缺点：增加渲染工作量&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>将物体(或平面)进行拆分，已确保每 1 份均会有机会被渲染&lt;/p>
&lt;blockquote>
&lt;p>缺点：只适合简单的物体，且位置固定容易拼凑&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>通过设置 .alphaTest，以实现透明渲染&lt;/p>
&lt;blockquote>
&lt;p>缺点：若贴图抠图不够精细，容易出现白边&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>就像上面我们提到的，每一种解决方案都有各自的使用场景和缺点。&lt;/p>
&lt;p>我们今后在实际的项目中，一定要根据实际情况来作出选择，看使用哪种方案。&lt;/p>
&lt;blockquote>
&lt;p>说白了，无非就是在性能、复杂度、精细化方面进行取舍，最终找出合适的方案。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;blockquote>
&lt;p>你可能会注意到本章节我并没有贴出完整的示例代码，而仅仅贴出了核心的代码。&lt;/p>
&lt;p>我是这样认为的，如果到了今天你依然无法自己写出完整的代码，还需要靠复制我完整的示例代码，那你干脆别学 Three.js 了，放弃吧。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>至此，本章结束。&lt;/p>
&lt;p>目前我们所有的示例都是基于 1 个 画布(canvas) 和 1 个 镜头(camera)，下一节我们讲解同一个网页中渲染多个 画布 和多个镜头。&lt;/p></description></item><item><title>27.Three.js 解决方案之多画布、多场景</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/27.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%A4%9A%E7%94%BB%E5%B8%83%E5%A4%9A%E5%9C%BA%E6%99%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/27.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%A4%9A%E7%94%BB%E5%B8%83%E5%A4%9A%E5%9C%BA%E6%99%AF/</guid><description>&lt;h1 id="27-threejs-解决方案之多画布多场景">27 Three.js 解决方案之多画布、多场景&lt;/h1>
&lt;p>在我们之前的示例中，通常都是 1 个网页中只有 1 个画布，1 个渲染器，1 个场景。&lt;/p>
&lt;p>1 个画布(Canvas) + 1 个渲染器 相当于在当前浏览器的 JS 中创建了 1 个 webgl。&lt;/p>
&lt;blockquote>
&lt;p>1 个 webgl 就会占用一定量的内存和性能，浏览器也是为了用户体验着想，所以才会限制 webgl 数量的。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>请注意：&lt;/p>
&lt;p>&lt;strong>浏览器并不限制 DOM 中 画布 &amp;lt;canvas &amp;gt; 标签的数量，浏览器只是限制 webgl 的数量。&lt;/strong>&lt;/p>
&lt;!-- 关于浏览器不限制画布标签数量这个观点，我并不十分确认是否正确 -->
&lt;br>
&lt;h3 id="网页中-webgl-数量限制">网页中 webgl 数量限制&lt;/h3>
&lt;p>不同浏览器都会对 webgl 创建的数量进行限制，通常情况下可以创建 8 个左右。&lt;/p>
&lt;p>如果超出浏览器对 webgl 数量，则新创建的会顶替较早之前创建的。&lt;/p>
&lt;blockquote>
&lt;p>此时较早之前创建的 webgl 会消失，变为不可用&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>如果我们一个网页中需要多个 webgl，那是不是我们多创建几个画布就可以了？&lt;/p>
&lt;h4 id="试想一下这个场景">试想一下这个场景&lt;/h4>
&lt;p>假设我们现在要制作一个产品列表页，该页面上需要展示 15 个产品，且每一个产品我们都希望搭配一个 3D 模型展示。&lt;/p>
&lt;p>那么我们现在就会遇到一些问题：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>问题一：如果每一个产品对应 1 个 webgl，因此我们就需要创建 15 个 webgl，这超出了浏览器对于一个页面上可创建 webgl 数量限制。&lt;/p>
&lt;blockquote>
&lt;p>我们假设浏览器最多只允许我们创建 8 个 webgl&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>特别强调：假设我们在一段 JS 代码中创建了 N 个渲染器 或 N 个场景，这并不会创建 N 个 webgl，他们仍然被视为仅仅是 1 个 webgl&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>你可以简单粗暴得去理解：webgl 的数量仅和画布(canvas)数量有关，和创建几个渲染器或场景无关。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>问题二：假设每个产品只是模型不同，但是所使用的材质相同，或者多个产品使用同一个纹理贴图，如果我们对每一个产品都创建一套 webgl，那同一个材质或贴图就可能需要被我们反复多次加载。换句话说每一个 Three.js 创建的产品 3D 展示都相互独立(孤立)，资源无法共享。&lt;/p>
&lt;blockquote>
&lt;p>上面我们说 “创建一套 webgl” 的意思是：创建一个 canvas，创建 一个渲染器，创建一个场景 等等&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>那&amp;hellip;解决方案是什么呢？&lt;/p>
&lt;h3 id="第-1-种解决方案用其他标签充当占位然后使用渲染器的剪裁渲染功能">第 1 种解决方案：用其他标签充当占位，然后使用渲染器的剪裁渲染功能&lt;/h3>
&lt;p>&lt;strong>用 1 个 画布来渲染全部，用一些其他元素标签来 “代替” “充当” N 个画布。&lt;/strong>&lt;/p>
&lt;br>
&lt;p>&lt;strong>具体的事实细节：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建一个 &amp;lt;canvas &amp;gt; 标签，并设置 z-index:-1，这样该画布就会显示在其他元素的下面&lt;/p>
&lt;blockquote>
&lt;p>事实上相当于将 画布 当成了 “大背景”&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在需要展示 “画布” 的位置，我们添加一些网页标签，用来启到 “占位” 的作用。&lt;/p>
&lt;blockquote>
&lt;p>该标签里并没有实际内容，但是我们通过 CSS 给该标签添加宽和高&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>在 JS 中使用 Three.js，添加不同的灯光和镜头。&lt;/p>
&lt;blockquote>
&lt;p>一组灯光和镜头 对应一个 需要渲染的对象内容&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>我们 “判断元素当前是否可见”，然后通过渲染器的以下 3 个方法，对渲染器进行 “裁剪”。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Renderer.setScissorTest()&lt;/p>
&lt;blockquote>
&lt;p>该方法接收 1 个参数：boolean，来决定是否启用或禁用裁剪检测。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Renderer.setViewport()&lt;/p>
&lt;blockquote>
&lt;p>该方法接收 4 个参数：x、y、width、height，这 4 个参数构成 1 个矩形的裁剪框。&lt;/p>
&lt;p>若此时已启用 剪裁检测，那么只有在该矩形框内的才会被渲染，不在该矩形框内的则不会被渲染。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Renderer.setScissor()&lt;/p>
&lt;blockquote>
&lt;p>该方法接收 4 个参数：x、y、width、height，这 4 个参数构成 1 个视窗(视框)。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>不断判断，不断清空画布内容，已实现实时更新裁剪可见区域。&lt;/p>
&lt;blockquote>
&lt;p>但是请注意：由于 Three.js 渲染需要一定时间，当网页快速滚动时可能会出现 “渲染不及时”，看上去似乎是一个 “bug”，具体我们会稍后讲解。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>最终，我们将那些 “占位”标签的位置和尺寸 传递给 Three.js，通过 裁剪，只在渲染出相应内容。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>下面我们将针对以上步骤中，一些关键的点进行详细讲解。&lt;/p>
&lt;br>
&lt;h3 id="第-1启到占位作用的网页标签">第 1：启到占位作用的网页标签&lt;/h3>
&lt;p>我们知道这些标签本身不需要显示任何内容，我们会通过 CSS 来给他们设定宽高。&lt;/p>
&lt;p>那究竟使用什么标签呢？&lt;/p>
&lt;p>我们会很容易想到 &amp;lt;div &amp;gt; 、&amp;lt;span &amp;gt; 这些标签都可以。无论使用哪个标签，我们只要确保这些标签统一即可。&lt;/p>
&lt;p>&lt;strong>我们推荐一种更加优雅、通用、明确的做法：给标签添加 html5 新增的 data-* 属性&lt;/strong>&lt;/p>
&lt;br>
&lt;p>&lt;strong>data-* 属性介绍：&lt;/strong>&lt;/p>
&lt;p>在传统的网页标签中，例如 &amp;lt;span &amp;gt; 标签，默认它只能有以下几种信息：&lt;/p>
&lt;ol>
&lt;li>该标签拥有的 属性和处理事件函数，例如 id、onclick 等&lt;/li>
&lt;li>该标签的样式，例如 class、style&lt;/li>
&lt;li>该标签和闭合标签之间的内容&lt;/li>
&lt;/ol>
&lt;p>除此之外，该标签无法承载其他信息。&lt;/p>
&lt;blockquote>
&lt;p>实际上若想还包含其他信息，通常变相的实现手段是将其他信息 包装成 样式名称(class name)&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>在 HTML5 出现之后，任何标签都可以新增以 &lt;code>data-*&lt;/code> 的自定义属性。&lt;/p>
&lt;blockquote>
&lt;p>请注意上面中的 * 是需要我们自己根据实际情况来自定义的&lt;/p>
&lt;/blockquote>
&lt;p>例如我们给 &amp;lt;span /&amp;gt; 添加一个额外的属性，也就是自定义信息 data-author：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;span id=&amp;#39;myspan&amp;#39; data-author=&amp;#39;ypx&amp;#39;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>上面代码中，我们给 span 增加了一个自定义属性 data-author，我们假设用这个属性来记录作者名字&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>我们可以通过以下 JS 获取该标签：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>document.querySelector(&amp;#39;#span&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>现在，我们还可以通过查找自定义属性的方式，来获取：&lt;/p>
&lt;pre tabindex="0">&lt;code>document.getAttribute(&amp;#39;data-author&amp;#39;)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>如果要获取多个拥有该属性的 DOM 元素，我们可以使用：getAttributes() 这个方法&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>&lt;strong>使用 CSS 统一获取并设置样式：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>span{
content:attr(data-author)
}
&lt;/code>&lt;/pre>&lt;p>或&lt;/p>
&lt;pre tabindex="0">&lt;code>span[data-author]{
...
}
&lt;/code>&lt;/pre>&lt;p>甚至直接给所有拥有 data-author 属性的标签统一设置样式&lt;/p>
&lt;pre tabindex="0">&lt;code>[data-author]{
...
}
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;p>上面讲解的都是我们在 JS 中获取标签的自定义属性，假设要通过 JS 给标签添加自定义属性，还是以 span 为例，具体操作方式为：&lt;/p>
&lt;p>第 1 种方式：使用 setAttribute()&lt;/p>
&lt;pre tabindex="0">&lt;code>span.setAttribute(&amp;#39;data-author&amp;#39;,&amp;#39;xxxx&amp;#39;)
&lt;/code>&lt;/pre>&lt;br>
&lt;p>第 2 种方式：使用 dataset&lt;/p>
&lt;pre tabindex="0">&lt;code>span.dataset.author = &amp;#39;xxxx&amp;#39;
&lt;/code>&lt;/pre>&lt;p>请注意：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>dataset 作为该标签的自定义属性统一对象，该标签的所有自定义属性都将挂载在该属性值下面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们在去设置自定义属性名时，是无需添加 &amp;ldquo;data-&amp;rdquo; 的，例如原本的 data-author 我们只需 dataset.author&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义属性名需遵循驼峰命名方式，在上面示例中我们自定义属性为 &lt;code>data-author&lt;/code>，去掉不用写的 data-，那剩下的就只有 author，我们可以直接这样写。但是假设我们自定义属性名为 &lt;code>data-author-name&lt;/code>，此时去掉不用写的 data- 后，还剩下 author-name，我们就需要遵循驼峰命名方式，实际代码应为：&lt;/p>
&lt;pre tabindex="0">&lt;code>span.dataset.authorName = &amp;#39;xxx&amp;#39;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>浏览器会自动将驼峰命名转化为 data-xxx-xxx 赋予给标签&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>回到我们本文要讲解的内容上面，我们可以将负责 &amp;ldquo;占位&amp;rdquo; 的标签都添加上统一的自定义属性，这样在 JS 中可根据该自定义字段来获取所有占位的标签。&lt;/p>
&lt;blockquote>
&lt;p>这样的做法对于我们来说有一个好处，就是不用再考虑标签究竟使用的是 &amp;lt;div &amp;gt; 还是 &amp;lt;span &amp;gt;&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h3 id="第-2判断网页中某标签当前是否在可见窗口内并告知渲染器进行如何裁切渲染">第 2：判断网页中某标签当前是否在可见窗口内，并告知渲染器进行如何裁切渲染&lt;/h3>
&lt;p>大体思路为：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在 JS 中获取该标签，假设该标签(DOM 元素)在 js 中的变量引用名为 elem&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 elem.getBoundingClientRect() 获取该标签相对于视窗的位置信息&lt;/p>
&lt;blockquote>
&lt;p>这些位置信息有：left、right、top、bottom、width、height&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>然后进行判断，如果出现以下情况，只要符合一条，那么我们就可以直接认为该标签当前不在可见窗口内。&lt;/p>
&lt;pre tabindex="0">&lt;code>bottom &amp;lt; 0
top &amp;gt; canvas.clientHeight
right &amp;lt; 0
left &amp;gt; canvas.clientWidth
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>假设我们经过判断元素在可见窗口内，那么我们就要告知渲染器可以根据该元素的位置和尺寸，来进行裁剪渲染。&lt;/p>
&lt;pre tabindex="0">&lt;code>//让画布的高 - 元素的底部，从而计算出超出的部分，这些部分不必再做渲染了
const positiveYUpBottom = canvas.clientHeight - bottom
renderer.setScissor(left,positiveYUpBottom,width,height)
renderer.setViewport(left,positiveYUpBottom,width,height)
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;br>
&lt;h3 id="第-3添加轨道控制器将光添加到镜头中而非场景中">第 3：添加轨道控制器、将光添加到镜头中，而非场景中&lt;/h3>
&lt;p>这里讲解一个新的知识点。&lt;/p>
&lt;p>在以前所有的示例中，假设我们希望物体有反射光，那么我们都会创建光，并将光添加到场景(Three.Scene)中。&lt;/p>
&lt;p>此时我们添加镜头轨道控制器，当移动鼠标修改镜头位置时，光的位置是不变的。&lt;/p>
&lt;blockquote>
&lt;p>因为我们是将 光 添加到了场景中，所以光的位置是和场景保持固定不变的。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>假设我们的场景中有多个物体，每个物体都有自己对应的镜头，我们希望对每个物体的镜头添加轨道控制器，且保证物体对应的光永远跟随着镜头移动，那么我就要将光添加到镜头里。&lt;/p>
&lt;br>
&lt;p>你没有听错，我再说一遍：&lt;strong>将光由原来添加到场景中，修改为添加到镜头中。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="line">&lt;span class="cl">&lt;span class="gd">- scene.add(light)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="gd">&lt;/span>&lt;span class="gi">+ camera.add(light)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如此操作之后，光就不再跟随场景，而是跟随着镜头移动而移动。&lt;/p>
&lt;p>这样可以保证我们每个物体的镜头中，始终有该物体的光&lt;/p>
&lt;br>
&lt;p>&lt;strong>对于本文示例讲解的场景，不推荐使用 OrbitControls，而是推荐使用 TrackballControls。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>TrackballControls 不提供滚动鼠标中轴缩放镜头这个功能，因为在这个示例场景中，滚动鼠标应该出现的是网页的滚动，而不是 Three.js 场景的视角缩放。&lt;/p>
&lt;/blockquote>
&lt;p>请一定记得在每次渲染函数中，要对轨道控制器进行更新：&lt;/p>
&lt;ol>
&lt;li>controls.handleResize()&lt;/li>
&lt;li>controls.update()&lt;/li>
&lt;/ol>
&lt;br>
&lt;h3 id="第-2-种解决方案通过-web-worker-来创建和渲染场景">第 2 种解决方案：通过 web worker 来创建和渲染场景&lt;/h3>
&lt;p>&lt;strong>该方案的优点很明确：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>本身就是对网页性能的一种提升&lt;/li>
&lt;li>由于是 web worker，不再受限于浏览器对 webgl 数量的限制&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>&lt;strong>不过缺点也很明确：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>需要浏览器支持 OffscreenCanvas 才可以&lt;/p>
&lt;blockquote>
&lt;p>目前火狐、苹果浏览器均不支持 OffscreenCanvas&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>默认 web worker 内部不支持对 DOM 元素交互事件的侦听，也就是说无法添加 轨道控制器&lt;/p>
&lt;blockquote>
&lt;p>不过可以通过变相的方式，请参考本系列教程 &lt;a href="https://github.com/puxiao/threejs-tutorial/blob/main/22%20Three.js%E4%BC%98%E5%8C%96%E4%B9%8BOffscreenCanvas%E4%B8%8EWebWorker.md" target="_blank" rel="noopener">22 Three.js 优化之 OffscreenCanvas 与 WebWorker.md&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;h3 id="第-3-种解决方案threejs-渲染的画布不直接显示让不同位置的标签画布去复制该画布的局部结果">第 3 种解决方案：Three.js 渲染的画布不直接显示，让不同位置的标签(画布)去复制该画布的局部结果&lt;/h3>
&lt;p>由于浏览器并不显示 画布 的数量，我们可以将不同位置的 占位标签 直接使用画布标签，然后让不同的画布去复制渲染出的画布结果内容。&lt;/p>
&lt;p>这样做的缺点是：性能不好，速度慢，每个区域都需要进行相应的复制操作。&lt;/p>
&lt;!-- 关于浏览器不限制画布标签数量这个观点，我并不十分确认是否正确 -->
&lt;br>
&lt;p>本文只是阐述了某些特殊场景，例如需要多画布、多场景的情况下的解决方案。&lt;/p>
&lt;p>并没有深入、完整编写示例代码。&lt;/p>
&lt;blockquote>
&lt;p>我个人认出现这种场景的几率并不大，所以就偷懒一下，不去写完整的示例了。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>本文此致结束。&lt;/p>
&lt;p>下一节，我们将讲解一个非常重要的内容，关乎绝大多数我们编写的 Three.js 程序。&lt;/p>
&lt;p>那就是：鼠标选中场景中的物体，并发生交互。&lt;/p></description></item><item><title>28.Three.js 解决方案之选中、拾取某物体</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/28.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%89%E4%B8%AD%E6%8B%BE%E5%8F%96%E6%9F%90%E7%89%A9%E4%BD%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/28.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%89%E4%B8%AD%E6%8B%BE%E5%8F%96%E6%9F%90%E7%89%A9%E4%BD%93/</guid><description>&lt;h1 id="28-threejs-解决方案之选中拾取某物体">28 Three.js 解决方案之选中、拾取某物体&lt;/h1>
&lt;p>在日常的 Three.js 应用中，我们除了要渲染出 3D 场景外，还需要大量用户鼠标或笔触(手指触摸)操作。&lt;/p>
&lt;p>在讲解本文正式内容之前，我们先讲解一下 Three.js 官方帮我们写好的控制器。&lt;/p>
&lt;blockquote>
&lt;p>在之前示例中我们经常使用的是 OrbitControls，除了这个以外还有其他几种控制器。&lt;/p>
&lt;/blockquote>
&lt;h3 id="镜头轨道控制器">镜头轨道控制器&lt;/h3>
&lt;blockquote>
&lt;p>再次重申，在本系列文章中 “镜头” 和 “摄像机” 是同一个意思，我个人更习惯使用 “镜头” 这个词。&lt;/p>
&lt;/blockquote>
&lt;p>在 Three.js 中，官方提供了以下几种控制器：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>控制器&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>补充说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>DeviceOrientationControls&lt;/td>
&lt;td>设备朝向控制器&lt;/td>
&lt;td>这个控制器只能应用在手机端，&lt;br />监听手机设备朝向变化，进而改变镜头朝向&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DragControls&lt;/td>
&lt;td>拖放控制器&lt;/td>
&lt;td>该控制器实例化时，需要传入可拖放的元素数组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FirstPersonControls&lt;/td>
&lt;td>第一人称控制器&lt;/td>
&lt;td>像游戏中人物行走一样，来切换场景视角&lt;br />该控制器是 FlyControls 的另一种实现&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>FlyControls&lt;/td>
&lt;td>飞行控制器&lt;/td>
&lt;td>像鸟飞行一样的视角，来切换场景&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OrbitControls&lt;/td>
&lt;td>轨道控制器&lt;/td>
&lt;td>我们日常使用最为频繁的一个控制器&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PointerLockControls&lt;/td>
&lt;td>指针锁定控制器&lt;/td>
&lt;td>Pointer，可以让我们脱离鼠标，无限移动使用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TrackballControls&lt;/td>
&lt;td>轨迹球控制器&lt;/td>
&lt;td>与 OrbitControls 类似，但又不相同，&lt;br />它不能恒定保持镜头的 up 向量&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;p>&lt;strong>补充说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>在使用 DeviceOrientationControls 时，需要在每次渲染函数中执行 .update()&lt;/li>
&lt;li>在使用 DragControls 时，需要给控制器实例添加 .addEventListener(&amp;lsquo;drag&amp;rsquo;, render)&lt;/li>
&lt;li>在使用 FirstPersonControls 时，当浏览器窗口尺寸发生变化时，需要执行 .handleResize()，已更新交互范围&lt;/li>
&lt;li>在使用 FlyControls 时，当浏览器窗口尺寸发生变化时，需要适当修改 .movementSpeed 和 执行 .update( delta:number)&lt;/li>
&lt;li>在使用 OrbitControls 时，若要获得阻尼惯性效果，要设置 .enableDamping = true&lt;/li>
&lt;li>在使用 PointerLockControls 时，锁定(隐藏)鼠标光标的是执行 .lock()，退出(显示)鼠标光标的是执行 .unlock&lt;/li>
&lt;li>在使用 TrackballControls 时，可以通过键盘 A/S/D 键来控制场景视角&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>以上这些控制器，都是用户与场景之间的交互操作。&lt;/p>
&lt;p>那么接下来，我们讲解一下在场景中，一些我们自定义的一些鼠标交互操作：拾取元素&lt;/p>
&lt;br>
&lt;h4 id="抱歉本系列教程暂停更新">抱歉，本系列教程暂停更新。&lt;/h4>
&lt;p>接下来一段时间，我打算去开发一个 3D 云点标注工具。&lt;/p>
&lt;p>还是从实战中去学习 Three.js 吧，或许有一天会重新继续更新本系列教程。&lt;/p></description></item><item><title>Three.js 实用知识点笔记</title><link>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/three.js-%E5%AE%9E%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/three.js-%E5%AE%9E%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="threejs-实用知识点笔记">Three.js 实用知识点笔记&lt;/h1>
&lt;p>从今天开始，在本文中记录实际 Three.js 开发过程中所遇到的知识点。&lt;/p>
&lt;br>
&lt;p>&lt;strong>关于示例代码的一般约定说明：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>举例的时候，很多都是伪代码&lt;/li>
&lt;li>为了保证代码简洁，所以在实用某些类时没有添加 &lt;code>Three.&lt;/code> 前缀&lt;/li>
&lt;li>绝大多数时候都使用箭头函数&lt;/li>
&lt;li>使用 Xxx 泛指同一类型，例如 XxxCamer 泛指各类相机&lt;/li>
&lt;li>由于我们讲解的是 Three.js，所以全部使用的是 右手坐标系&lt;/li>
&lt;/ol>
&lt;br>
&lt;h4 id="01每一个-object3d-对象都只能有一个父级">01、每一个 Object3D 对象都只能有一个父级&lt;/h4>
&lt;p>这里说的 Object3D 实际上包括所有继承于 Object3D 的子类，例如 Mesh、Camera、Group 等&lt;/p>
&lt;p>举例说明：&lt;/p>
&lt;pre tabindex="0">&lt;code>const mesh = new Mesh(geometry,material)
const sceneA = new Scene()
const sceneB = new Scene()
sceneA.add(mesh)
sceneB.add(mesh)
&lt;/code>&lt;/pre>&lt;p>由于 mesh 只能有一个父类，所以当 sceneB 也执行 .add(mesh) 后，sceneA.children 中会自动删除掉 mesh。&lt;/p>
&lt;br>
&lt;h4 id="02克隆或复制-mesh-不会在内存中真正复制出一份-顶点geometry和材质material它们使用的是引用而不是复制">02、克隆或复制 Mesh 不会在内存中真正复制出一份 顶点(geometry)和材质(material)，它们使用的是引用，而不是复制&lt;/h4>
&lt;p>Object3D 拥有 .clone() 和 .copy() 两个方法，Mesh 继承于 Object3D，所以也拥有这两个方法。&lt;/p>
&lt;p>在 Mesh 类中扩展了 .copy() 方法，但是针对 Mesh 内部的属性 顶点和材质，实用的是引用而不是真正内存中的复制。&lt;/p>
&lt;pre tabindex="0">&lt;code>const meshB = meshA.clone()
&lt;/code>&lt;/pre>&lt;p>上述代码中新复制得到的 meshB 仅仅复制了 meshA 的一些变换相关的属性，例如 matrix 等，但是对于占内存大头的 顶点和材质 这两项实用的是引用。&lt;/p>
&lt;p>也就是说此时 meshA 和 meshB 它们共用了一份 geometry 和 material。&lt;/p>
&lt;blockquote>
&lt;p>不用担心因为多复制了几份 mesh 而增加很多内存。&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="03添加场景scene或其他-object3d-渲染之前和渲染之后的回调函数">03、添加场景(scene)或其他 Object3D 渲染之前和渲染之后的回调函数&lt;/h4>
&lt;p>场景 scene 继承于 Object3D，而 Object3D 可以配置 2 个渲染之前或之后的回调函数：&lt;/p>
&lt;pre tabindex="0">&lt;code>scene.onBeforeRender = () =&amp;gt; { ...}
scnet.onAfterRende = () =&amp;gt; { ... }
&lt;/code>&lt;/pre>&lt;p>使用场景举例：假设我们希望不渲染场景上的某一类元素，那么我们可以在 renderer.render() 之前通过上面 2 个回调函数进行设置&lt;/p>
&lt;pre tabindex="0">&lt;code>scene.onBeforeRender = () =&amp;gt; {
scene.children.forEach(item =&amp;gt; {
if(item.type === &amp;#39;Points&amp;#39;){
item.visible = false
}
})
}
scene.onAfterRender = () =&amp;gt; {
scene.children.forEach(item =&amp;gt; item.visible = true)
}
renderer.render(scene,camera)
&lt;/code>&lt;/pre>&lt;br>
&lt;h4 id="04通过-layers-控制物体是否被渲染">04、通过 .layers 控制物体是否被渲染&lt;/h4>
&lt;p>在 Three.js 中 .layers 对应的是 Layers 这个类，Three.js 规定 Layers 级别的值取值范围为 0 - 32。&lt;/p>
&lt;blockquote>
&lt;p>你可以把 layers 翻译成 “级别”，也可以称呼为 “层级”&lt;/p>
&lt;/blockquote>
&lt;p>任何继承于 Object3D 的类，例如 相机、物体 等都具有 .layers 属性。&lt;/p>
&lt;p>它们的 .layers 默认级别都为 0。&lt;/p>
&lt;p>不能通过直接给 .layers 赋值的方式修改级别，而是应该通过 .set(value) 这种形式。&lt;/p>
&lt;pre tabindex="0">&lt;code>mymesh.layers.set(1)
camera.layers.set(1)
&lt;/code>&lt;/pre>&lt;br>
&lt;p>对于相机而言，它只能渲染出同一级别的物体元素。&lt;/p>
&lt;pre tabindex="0">&lt;code>const meshA = new Mesh(...)
//meshA.layers.set(0) //默认就是 0
const meshB = new Mesh(...)
meshB.layers.set(1)
const scene = new Scene()
scene.add(meshA)
scene.add(meshB)
const cameraA = new XxxCamera()
//cameraA.layers.set(0) //默认就是 0
const cameraB = new XxxCamera()
cameraB.layers.set(1)
&lt;/code>&lt;/pre>&lt;p>在上面代码中：&lt;/p>
&lt;ol>
&lt;li>我们按照默认的形式添加了 meshA、cameraA，它们默认层级为 0&lt;/li>
&lt;li>手动修改了 meshB、cameraB 的 .layers 层级为 1&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>那么当执行下面的代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>renderer.render(scene, cameraA)
renderer.render(scene. cameraB)
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>cameraA 只会渲染出场景中同一级别的 meshA&lt;/li>
&lt;li>cameraB 只会渲染出场景中同一级别的 meshB&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>也可以选择随时修改 meshA 的 .layers 值，这样 cameraB 就可以渲染到它了。&lt;/p>
&lt;pre tabindex="0">&lt;code>meshA.layers.set(1)
renderer.render(secen, cameraB)
&lt;/code>&lt;/pre>&lt;br>
&lt;p>换句话说，假设我们希望控制是否渲染场景中某些元素，那么有 2 种途径：&lt;/p>
&lt;ol>
&lt;li>设置其 .visible 的值来决定是否渲染&lt;/li>
&lt;li>设置其 .layers 的值来决定只被同一层级的相机渲染&lt;/li>
&lt;/ol>
&lt;br>
&lt;h4 id="05手工修改-object3d-实例的matrix-时切记要设置-matrixautoupdatefalse">05、手工修改 Object3D 实例的.matrix 时切记要设置 .matrixAutoUpdate=false&lt;/h4>
&lt;p>默认情况下 Object3D 实例的 .matrixAutoUpdate 的值为 true，也就是说当通过 .applyMatrix4()、.applyQuaternion() 等修改实例的变换时，默认会自动更新其他所有相关属性值，例如 position、quaternion、scale、rotation。&lt;/p>
&lt;p>但是，如果直接通过修改 Object3D 实例的 .matrix 值时，生效的前提是：&lt;/p>
&lt;ol>
&lt;li>先把 .matrixAutoUpdate 设置为 false&lt;/li>
&lt;li>不去调用 .updateMatrix()&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>const mesh = new Mesh(...)
mesh.matrixAutoUpdate = false
mesh.matrix.copy(otherMatrix)
&lt;/code>&lt;/pre>&lt;br>
&lt;p>但是上面的代码存在另外一个问题：尽管 .matrix 值更新了，可是 mesh 的其他属性值 例如 .position，.quaternion，scale，rotation 却没有自动更新。&lt;/p>
&lt;p>解决方式很简单，可以通过 Matrix 的 .decompose() 方法优雅更新它们。&lt;/p>
&lt;p>举例说明：假设现在有 meshA、meshB 两个对象，需要将 meshB 的各种变换属性值设置成和 meshA 完全相同&lt;/p>
&lt;pre tabindex="0">&lt;code>meshB.matrixAutoUpdate = false
meshB.matrix.copy(meshA.matrix)
meshB.matrix.decompose(meshB.position, meshB.quaternion, meshB.scale)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>当修改 meshB.quaternion 值后会自动修改 meshB.rotation 的值&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;h4 id="06绘制三角形的顶点顺序决定了该三角形是正面顺时针还是反面逆时针">06、绘制三角形的顶点顺序决定了该三角形是正面(顺时针)还是反面(逆时针)&lt;/h4>
&lt;p>一个三角形有 3 个顶点，假定为 a、b、c，那么：&lt;/p>
&lt;ol>
&lt;li>假定 a b c 连接顺序为 逆时针，那么最终形成的三角形为 正面&lt;/li>
&lt;li>假定 a b c 连接顺序为 顺时针，那么最终形成的三角形为 反面(背面)&lt;/li>
&lt;/ol>
&lt;p>另外一种判定形式是：右手握住沿着两个顶点添加顺序的连接线，此时大拇指指示方向即为正面&lt;/p>
&lt;br>
&lt;h4 id="07保持外观和位置的前提下将立方体的顶点坐标-归一化">07、保持外观和位置的前提下，将立方体的顶点坐标 &amp;ldquo;归一化&amp;rdquo;&lt;/h4>
&lt;p>这里说的立方体是指基于 BoxGeometry 而创建的立方体。&lt;/p>
&lt;p>这里说的 顶点坐标 “归一化” 是指将立方体顶点坐标修改成 1x1x1 规格的立方体顶点坐标。&lt;/p>
&lt;p>这里说的 保持外观和位置 是指通过修改其 变换矩阵 .matrix 来实现。&lt;/p>
&lt;p>实现思路：&lt;/p>
&lt;ol>
&lt;li>凡是基于 BoxGeometry 的立方体，其顶点坐标信息都是统一规范的，尽管其值可能不同&lt;/li>
&lt;li>所以我们就根据其值来确定这个立方体与 1x1x1 立方体的 宽、高、深 比例&lt;/li>
&lt;li>将这个缩放比例应用到立方体本身的矩阵中即可&lt;/li>
&lt;li>同时将这个立方体的顶点信息修改成 1x1x1 立方体的顶点信息&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>const boxGeometryNormalize = (box) =&amp;gt; {
const originX = box.geometry.attributes.position.array[0]
const originY = box.geometry.attributes.position.array[1]
const originZ = box.geometry.attributes.position.array[2]
const scaleX = originX / 0.5
const scaleY = originY / 0.5
const scaleZ = originZ / 0.5
box.geometry = new BoxGeometry()
box.matrixAutoUpdate = false
box.matrix.makeScale(scaleX, scaleY, scaleZ)
box.matrix.decompose(box.position, box.quaternion, box.scale)
}
&lt;/code>&lt;/pre>&lt;br></description></item></channel></rss>