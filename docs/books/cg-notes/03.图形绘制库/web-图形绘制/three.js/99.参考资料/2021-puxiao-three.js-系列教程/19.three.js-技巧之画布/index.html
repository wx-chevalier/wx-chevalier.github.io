<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="19 Three.js 技巧之画布 本文讲解一下 画布 Canvas 的一些实用技巧。 创建画布截屏(快照)，并保存图片到本地 设置不清除画布内容 获取键盘事件 设置画布透明度 设置画布为背景 示例基本代码：HelloCanvas 先制作一个简单的、带"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/"><meta property="og:title" content="19.Three.js 技巧之画布 | Next-gen Tech Edu"><meta property="og:description" content="19 Three.js 技巧之画布 本文讲解一下 画布 Canvas 的一些实用技巧。 创建画布截屏(快照)，并保存图片到本地 设置不清除画布内容 获取键盘事件 设置画布透明度 设置画布为背景 示例基本代码：HelloCanvas 先制作一个简单的、带"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>19.Three.js 技巧之画布 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=d2a662a20009227f1aed4586f84072c2><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">2021-puxiao-《Three.js 系列教程》</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idbb95a2d75baa1d08a35c84b8efe5ad00")' href=#idbb95a2d75baa1d08a35c84b8efe5ad00 aria-expanded=false aria-controls=idbb95a2d75baa1d08a35c84b8efe5ad00 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>99.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idbb95a2d75baa1d08a35c84b8efe5ad00 aria-expanded=false aria-controls=idbb95a2d75baa1d08a35c84b8efe5ad00><i class="fa-solid fa-angle-down" id=caret-idbb95a2d75baa1d08a35c84b8efe5ad00></i></a></div><ul class="nav docs-sidenav collapse show" id=idbb95a2d75baa1d08a35c84b8efe5ad00><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2017-%E5%9B%BE%E8%A7%A3-webgl-%E5%8F%8A-three.js-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/>2017-图解 WebGL 及 Three.js 工作原理</a></li><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ide04f28caa67ef746c1e042a66bd26df7")' href=#ide04f28caa67ef746c1e042a66bd26df7 aria-expanded=false aria-controls=ide04f28caa67ef746c1e042a66bd26df7 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/>2021-puxiao-《Three.js 系列教程》</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ide04f28caa67ef746c1e042a66bd26df7 aria-expanded=false aria-controls=ide04f28caa67ef746c1e042a66bd26df7><i class="fa-solid fa-angle-down" id=caret-ide04f28caa67ef746c1e042a66bd26df7></i></a></div><ul class="nav docs-sidenav collapse show" id=ide04f28caa67ef746c1e042a66bd26df7><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/01.three.js-%E7%AE%80%E4%BB%8B/>01.Three.js 简介</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/02.%E5%88%9D%E5%A7%8B%E5%8C%96three.js-%E9%A1%B9%E7%9B%AE/>02.初始化Three.js 项目</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/03.%E7%BC%96%E5%86%99hellothreejs/>03.编写HelloThreejs</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/04.%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/>04.添加一些自适应</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/05.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%85%83/>05.Three.js 基础之图元</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/06.%E5%9B%BE%E5%85%83%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B/>06.图元练习示例</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/07.%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/>07.图元之3D文字</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/08.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/>08.Three.js 基础之场景</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/09.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/>09.Three.js 基础之材质</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/10.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%B9%E7%90%86/>10.Three.js 基础之纹理</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/11.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/>11.Three.js 基础之灯光</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/12.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%95%9C%E5%A4%B4/>12.Three.js 基础之镜头</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/13.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%B4%E5%BD%B1/>13.Three.js 基础之阴影</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/14.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%BE/>14.Three.js 基础之雾</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/15.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/>15.Three.js 基础之离屏渲染</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/16.three.js-%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%A0%E4%BD%95%E4%BD%93/>16.Three.js 基础之自定义几何体</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/17.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8C%89%E9%9C%80%E6%B8%B2%E6%9F%93/>17.Three.js 技巧之按需渲染</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/18.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%B0%83%E8%AF%95/>18.Three.js 技巧之调试</a></li><li class="child level active"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/19.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/>19.Three.js 技巧之画布</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/>20.Three.js 优化之合并对象</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/21.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E7%94%BB/>21.Three.js 优化之合并对象的动画</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/22.three.js-%E4%BC%98%E5%8C%96%E4%B9%8Boffscreencanvas%E4%B8%8Ewebworker/>22.Three.js 优化之OffscreenCanvas与WebWorker</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/23.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/>23.Three.js 解决方案之加载.obj模型</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/24.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/>24.Three.js 解决方案之加载.gLTF模型</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/25.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/>25.Three.js 解决方案之添加背景和天空盒</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/26.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%8F%E6%98%8E%E5%BA%A6bug/>26.Three.js 解决方案之透明度bug</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/27.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%A4%9A%E7%94%BB%E5%B8%83%E5%A4%9A%E5%9C%BA%E6%99%AF/>27.Three.js 解决方案之多画布、多场景</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/28.three.js-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%89%E4%B8%AD%E6%8B%BE%E5%8F%96%E6%9F%90%E7%89%A9%E4%BD%93/>28.Three.js 解决方案之选中、拾取某物体</a></li><li class="child level"><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/three.js-%E5%AE%9E%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/>Three.js 实用知识点笔记</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#示例基本代码hellocanvas>示例基本代码：HelloCanvas</a><ul><li></li></ul></li><li><a href=#创建画布截屏快照并保存图片到本地>创建画布截屏(快照)，并保存图片到本地</a><ul><li><a href=#先说一下如何创建画布截屏快照>先说一下如何创建画布截屏(快照)</a></li><li><a href=#再说一下如何自动将图片下载到本地>再说一下如何自动将图片下载到本地</a></li></ul></li><li><a href=#设置不清除画布内容>设置不清除画布内容</a><ul><li><a href=#补充一个示例preservedrawingbuffer>补充一个示例：PreserveDrawingBuffer</a></li></ul></li><li><a href=#获取键盘事件>获取键盘事件</a><ul><li></li></ul></li><li><a href=#设置画布透明度>设置画布透明度</a></li><li><a href=#设置画布为背景>设置画布为背景</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>19.Three.js 技巧之画布</h1><div class=article-style><h1 id=19-threejs-技巧之画布>19 Three.js 技巧之画布</h1><p>本文讲解一下 画布 Canvas 的一些实用技巧。</p><ul><li>创建画布截屏(快照)，并保存图片到本地</li><li>设置不清除画布内容</li><li>获取键盘事件</li><li>设置画布透明度</li><li>设置画布为背景</li></ul><h2 id=示例基本代码hellocanvas>示例基本代码：HelloCanvas</h2><h4 id=先制作一个简单的带动画的-threejs-场景>先制作一个简单的、带动画的 Three.js 场景</h4><p>为了演示各个功能，我们先创建一个基础的 Three.js 动画场景：场景上有 3 个不同颜色、不停旋转的立方体。</p><p>这个场景在之前多个示例中已经创建过多次，但是这次和之前的略微不同。</p><p>**不同点 1：**由于本文是讲解 canvas 的，本身和 Three.js 没太大的关联，所以这次我们会创建一个 useCreateScene 的自定义 hook，用来专门创建 3D 场景，这样我们的 index.tsx 代码可以更加简洁。</p><blockquote><p>所谓 <code>自定义 react hook</code>，本质上就是包含有 hook 的普通函数</p></blockquote><p>**不同点 2：**由于讲解过程中需要用到一些按钮，所以我们这次将引入 react-dat-gui 这个组件，来添加一些示例相关按钮。</p><p>关于如何使用 react-dat-gui 这个，请参考我写的 <a href=https://github.com/puxiao/notes/blob/master/React%E4%B8%AD%E4%BD%BF%E7%94%A8GUI.md target=_blank rel=noopener>React 中使用 GUI.md</a> 这篇教程。</p><blockquote><p>请务必学习一下 react-dat-gui 这个组件，在后续示例中我们会经常使用这个组件来作为调试面板。</p></blockquote><h4 id=具体的代码>具体的代码</h4><p>我们创建一个专门存放本示例的目录 src/components/hello-canvas/</p><p><strong>use-create-scene.ts：</strong></p><pre tabindex=0><code>import { useEffect } from &#39;react&#39;
import * as Three from &#39;three&#39;
import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;

const useCreateScene = (canvasRef: React.RefObject&lt;HTMLCanvasElement&gt;) =&gt; {
    useEffect(() =&gt; {
        if (canvasRef.current === null) { return }

        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
        const scene = new Three.Scene()
        scene.background = new Three.Color(0x222222)
        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
        camera.position.set(0, 5, 10)

        const light = new Three.DirectionalLight(0xFFFFFF, 1)
        light.position.set(5, 10, 0)
        scene.add(light)

        const controls = new OrbitControls(camera, canvasRef.current)
        controls.update()

        const colors = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;]
        const cubes: Three.Mesh[] = []
        colors.forEach((color, index) =&gt; {
            const mat = new Three.MeshPhongMaterial({ color })
            const geo = new Three.BoxBufferGeometry(2, 2, 2)
            const mesh = new Three.Mesh(geo, mat)
            mesh.position.x = (index - 1) * 4
            scene.add(mesh)
            cubes.push(mesh)
        })

        const render = (time: number) =&gt; {
            time *= 0.001
            cubes.forEach((cube) =&gt; {
                cube.rotation.x = cube.rotation.y = time
            })
            renderer.render(scene, camera)
            window.requestAnimationFrame(render)
        }
        window.requestAnimationFrame(render)

        const handleResize = () =&gt; {
            if (canvasRef.current === null) { return }
            const width = canvasRef.current.clientWidth
            const height = canvasRef.current.clientHeight
            camera.aspect = width / height
            camera.updateProjectionMatrix()
            renderer.setSize(width, height, false)
        }
        handleResize()
        window.addEventListener(&#39;resize&#39;, handleResize)

        return () =&gt; {
            window.removeEventListener(&#39;resize&#39;, handleResize)
        }
    }, [canvasRef])
}

export default useCreateScene
</code></pre><p><strong>index.scss：</strong></p><pre tabindex=0><code>.full-screen,
canvas {
    display: block;
    height: inherit;
    width: inherit;
}

.dat-gui {
    top: 16px !important;
    font-size: 18px !important;
}
</code></pre><p><strong>index.tsx：</strong></p><pre tabindex=0><code>import { useRef, useState } from &#39;react&#39;
import DatGUI, { DatButton } from &#39;react-dat-gui&#39;
import useCreateScene from &#39;./use-create-scene&#39;

import &#39;./index.scss&#39;
import &#39;react-dat-gui/dist/index.css&#39;

const HelloCanvas = () =&gt; {
    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
    const [date, setDate] = useState&lt;any&gt;({})

    useCreateScene(canvasRef)

    const handleGUIUpdate = (newDate: any) =&gt; {
        setDate(newDate)
    }

    const handleSaveClick = () =&gt; {
        //编写点击之后的代码
    }

    return (
        &lt;div className=&#39;full-screen&#39;&gt;
            &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
            &lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&#39;dat-gui&#39; &gt;
                &lt;DatButton label=&#39;点击保存画布快照&#39; onClick={handleSaveClick} /&gt;
            &lt;/DatGUI&gt;
        &lt;/div&gt;
    )
}

export default HelloCanvas
</code></pre><p><strong>补充说明：</strong></p><ol><li><p>所有创建 3D 场景的代码都转移到了 use-create-scene.ts 中，index.tsx 的代码终于看上去非常简洁了。</p></li><li><p>我们使用了 &lt;DatGUI > 标签，但是由于我们本身只使用 按钮(&lt;DatButton >)，并未用到任何其他变量，所以</p><p><code>&lt;DatGUI data={date} onUpdate={handleGUIUpdate} ></code>这行属性配置只是为了不让 DatGUI 报缺省错误，并无其他作用。</p><blockquote><p>DatGUI 的 date、onUpdate 为必填属性</p></blockquote></li></ol><p>至此，本示例所用到的基础场景代码已搭建好，接下来开始讲解 canvas 的使用技巧。</p><h2 id=创建画布截屏快照并保存图片到本地>创建画布截屏(快照)，并保存图片到本地</h2><h3 id=先说一下如何创建画布截屏快照>先说一下如何创建画布截屏(快照)</h3><p>对于 HTML5 中的 canvas 来说，创建画布截屏(快照)有 2 种方式：canvas.toDataURL()、canvas.toBolb()</p><blockquote><p>所谓截屏和快照，更加准确的说法应该是：获取画布当前图片的内容</p></blockquote><h4 id=第-1-种canvastodataurl>第 1 种：canvas.toDataURL()</h4><p>canvas.toDataURL() 可以创建一个临时的图片地址，该图片地址可以作为当前页面中的 &lt;image >标签中的 src 属性值。或者可以创建一个下载链接，点击下载这个图片。</p><p><strong>toDataURL()用法：</strong></p><pre tabindex=0><code>canvas.toDataURL(type?: string, quality?: any): string;
</code></pre><ol><li><p>type：图片格式类型，值只能是 &ldquo;image/png&rdquo; 或 &ldquo;image/jpeg&rdquo;</p><blockquote><p>除了上面 2 个固定值，若你填写其他值则不启作用也不报错，最终会使用 &ldquo;image/png&rdquo; 来作为默认值</p></blockquote><blockquote><p>对于 谷歌浏览器 Chrome ，还额外支持一个类型 “image/webp”</p></blockquote></li><li><p>quality：jpeg 图片的压缩质量，取值范围 0 - 1，默认值为 0.92</p><blockquote><p>quality 的值越大，图片清晰度越高，文件体积越大</p></blockquote><blockquote><p>如果 quality 的值不在 0-1 范围内，则会使用默认值 0.92</p></blockquote></li></ol><p><strong>创建 PNG 图片：</strong></p><pre tabindex=0><code>const imgurl = canvas.toDataURL(&#39;image/png&#39;)
console.log(imgurl)

//输出以下内容
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAEUCAYAAADK...
</code></pre><p><strong>创建 JPEG 图片：</strong></p><pre tabindex=0><code>const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;,quality)
console.log(imgurl)

//输出以下内容
data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQY...
</code></pre><blockquote><p>请注意上面输出内容中，均包含了 ”base64“，这种格式的图片，是可以自动下载的</p><p>关于图片自动下载保存到本地我们会稍后讲解</p></blockquote><h4 id=第-2-种canvastoblob>第 2 种：canvas.toBlob()</h4><p>canvas.toBlob() 可以创建 Blob 对象，该对象包含图片的数据内容。</p><blockquote><p>注意：canvas.toDataURL() 是获得一个临时的图片地址，而 canvas.toBlob() 是获得图片数据内容。</p></blockquote><p><strong>canvas.toBlob()用法：</strong></p><pre tabindex=0><code>toBlob(callback: BlobCallback, type?: string, quality?: any): void;
</code></pre><ol><li><p>callback：获得 Blob 对象的回调函数</p><blockquote><p>通常为：canvas.toBlob( (blob: Blob|null) => {} )</p></blockquote></li><li><p>type：图片的格式类型，默认值为 &ldquo;image/png&rdquo;</p></li><li><p>quality：若图片格式类型为 &ldquo;image/jpeg&rdquo;，quality 表示 JPEG 的压缩质量</p><blockquote><p>type 的取值和默认值、quality 的取值范围和默认值 与 canvas.toDataURL() 完全相同</p></blockquote></li></ol><p><strong>使用示例：</strong></p><pre tabindex=0><code>canvas.toBlob((blob) =&gt; {
    console.log(blob)
})

或

canvas.toBlob((blob) =&gt; {
    console.log(blob)
}, &#39;image/jpeg&#39;, 0.8)
</code></pre><blockquote><p>注意：不同于 canvas.toDataURL()，canvas.toBlob() 这个函数是没有返回值的</p></blockquote><blockquote><p>另外，假设使用 jpeg 压缩质量为 0.8，文件体积有可能只有 png 格式的 1/3 。</p></blockquote><h4 id=补充说明>补充说明：</h4><p><strong>关于分辨率：</strong></p><p>按照 MDN 文档，无论哪种方式保存的图片分辨率都是 96，但是我在 PC 机上试验，将下载的图片保存到本地，并在 PhotoShop 软件中查看，发现图片分辨率依然是 72。</p><p>我怀疑 保存图片的分辨率其实是和 当前系统一致的。假设在手机上，有可能图片分辨率就是 96 了。</p><blockquote><p>稍后我会在手机上验证一下 图片分辨率 这个问题。</p></blockquote><p>最后，建议你去 MDN 上看 canvas 保存图片 的相关讲解作为本小节的补充。</p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas target=_blank rel=noopener>https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas</a></p><h3 id=再说一下如何自动将图片下载到本地>再说一下如何自动将图片下载到本地</h3><p><strong>图片自动下载到本地的思路：在 JS 中创建一个 a 链接，并且模拟出 a 点击事件</strong></p><p><strong>使用 toDataURL()函数：</strong></p><pre tabindex=0><code>const canvas = canvasRef.current
const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;, 0.8)

const a = document.createElement(&#39;a&#39;)
a.href = imgurl
a.download = &#39;myimg.jpeg&#39;
a.click()
</code></pre><blockquote><p>注意：我原本以为还需要将 a 标签插入到网页 body 中才可以实现自动下载，但是经过试验发现根本不需要这样，以下为我原本写的代码：</p><pre tabindex=0><code>const a = document.createElement(&#39;a&#39;)
document.body.appendChild(a) //根本无需此行代码
a.style.display = &#39;none&#39; //由于不需要添加到 body 中，因此也无需此行代码
a.href = imgurl
a.download = &#39;myimg.jpeg&#39;
a.click()
document.body.removeChild(a) //根本无需此行代码
</code></pre></blockquote><p><strong>使用 toBlob()函数：</strong></p><pre tabindex=0><code>const canvas = canvasRef.current
canvas.toBlob((blob) =&gt; {
    const imgurl = window.URL.createObjectURL(blob)
    const a = document.createElement(&#39;a&#39;)
    a.href = imgurl
    a.download = &#39;myimg.jpeg&#39;
    a.click()
}, &#39;image/jpeg&#39;, 0.8)
</code></pre><p><strong>小总结：</strong></p><ol><li>若使用 canvas.toDataURL()，则可以直接将得到的图片临时地址 赋值给 a.href</li><li>若使用 canvas.toBlob()，则需要通过 window.URL.createObjectURL() 这个函数将 Blob 数据转化得到对应的地址，然后再赋值给 a.href</li></ol><p>好了，关于如何获取画布图片数据、如何保持图片到本地讲解完毕，来实践吧。</p><p>无论采用 canvas.toDataURL() 还是 canvas.toBlob() 都可以，本示例我们采用 toBlob() 。</p><p>我们将 index.stx 的代码修改如下：</p><pre tabindex=0><code>import { useRef, useState } from &#39;react&#39;
import DatGUI, { DatButton } from &#39;react-dat-gui&#39;
import useCreateScene from &#39;./use-create-scene&#39;

import &#39;./index.scss&#39;
import &#39;react-dat-gui/dist/index.css&#39;

const HelloCanvas = () =&gt; {
    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
    const [date, setDate] = useState&lt;any&gt;({})

    useCreateScene(canvasRef)

    const handleGUIUpdate = (newDate: any) =&gt; {
        setDate(newDate)
    }

    const handleSaveClick = () =&gt; {
        if (canvasRef.current === null) { return }
        const canvas = canvasRef.current

        //采用 toDataURL() 方式
        // const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;, 0.8)
        // const a = document.createElement(&#39;a&#39;)
        // a.href = imgurl
        // a.download = &#39;myimg.jpeg&#39; //我们定义下载图片的文件名
        // a.click()

        //采用 toBlob() 方式
        canvas.toBlob((blob) =&gt; {
            const imgurl = window.URL.createObjectURL(blob)
            const a = document.createElement(&#39;a&#39;)
            a.href = imgurl
            a.download = &#39;myimg.jpeg&#39;
            a.click()
        }, &#39;image/jpeg&#39;, 0.8)
    }

    return (
        &lt;div className=&#39;full-screen&#39;&gt;
            &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
            &lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&#39;dat-gui&#39; &gt;
                &lt;DatButton label=&#39;点击保存画布快照&#39; onClick={handleSaveClick} /&gt;
            &lt;/DatGUI&gt;
        &lt;/div&gt;
    )
}

export default HelloCanvas
</code></pre><p>实际运行，点击右上角的 按钮，就会给画布创建图片快照，并且自动下载到本地。</p><p>然后你可以查看刚刚下载到本地的 myimg.jpeg 这个文件，打开它——你会发现？？？</p><p><strong>怎么图片啥内容都没有？纯色的？3 个立方体呢？</strong></p><p><strong>what ？why ？</strong></p><p>呵，马上讲解为什么。</p><p><strong>问题出在了哪里？</strong></p><p>首先我们容易想到，在 use-create-scene.ts 的 render() 函数中，不停的运行着每一帧都进行画布重新渲染的代码，莫非是我们截图那一瞬间刚好画布还未渲染完成？</p><p>好，我们先把那行代码删除掉，看是否就可以截图显示有内容了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl>const render = (time: number) =&gt; {
</span></span><span class=line><span class=cl>    time *= 0.001
</span></span><span class=line><span class=cl>    cubes.forEach((cube) =&gt; {
</span></span><span class=line><span class=cl>        cube.rotation.x = cube.rotation.y = time
</span></span><span class=line><span class=cl>    })
</span></span><span class=line><span class=cl>    renderer.render(scene, camera)
</span></span><span class=line><span class=cl><span class=gd>-   window.requestAnimationFrame(render)
</span></span></span><span class=line><span class=cl><span class=gd></span>}
</span></span><span class=line><span class=cl>window.requestAnimationFrame(render)
</span></span></code></pre></div><p>再次运行，3 个立方体是静止状态，此时点击按钮保存截图。</p><p>查看该图，竟然依然是空白，没有内容的。</p><p>看来问题并不出在上面一行代码中，我们恢复刚才删除的 <code>window.requestAnimationFrame(render)</code>，再去想其他原因。</p><p><strong>真实的原因是：</strong></p><ol><li>我们所谓的针对画布截屏 创建快照，实际上是获取 canvas 中的数据</li><li>但这个数据并不是针对 DOM 中已显示的 canvas，而是针对 canvas 对象中缓冲区的数据</li><li>关键在于当 canvas 渲染完成后(DOM 中已显示出内容)，默认会清空 缓冲区中的数据</li><li>所以，这就是我们为什么去 “获取 canvas 图像数据时得到是空白内容” 的原因</li></ol><p><strong>canvas 从计算到显示的过程：</strong></p><ol><li>canvas 根据相应的 JS 规则，开始创建、计算画布内容数据</li><li>canvas 将计算得到的画布内容数据填充到 canvas 缓冲区</li><li>当 canvas 画布内容计算完成，此时 canvas 缓冲区已有完整的画布内容数据后，将画布内容显示到 DOM 中</li></ol><p><strong>再说一遍：</strong></p><p>我们之前的示例中，渲染并显示 canvas 内容的函数 render 和 创建画布快照 的函数是相互独立的，这就造成了当我们去获取 canvas 缓冲区数据时，canvas 已经将画布内容显示到 DOM 中并且清空了缓冲区。</p><p><strong>解决办法：</strong></p><p>解决办法就是当我们要创建画布快照，获取 canvas 缓冲区内容之前，在同一个函数体内，额外调用一次 render 函数，确保此时 canvas 缓冲区内是有内容的。</p><p><strong>实际代码：</strong></p><p>第 1：由于我们示例代码中，render 函数本身位于 useCreateScene 函数内部，因此我们需要创造一个 renderRef 的钩子(hook)，将 renderRef 对外 return 出去，以便 index.stx 中可以获取 render 函数的引用。</p><pre tabindex=0><code>type RenderType = () =&gt; void
...

const renderRef = useRef&lt;RenderType | null&gt;(null)
...

renderRef.current = render
...

return renderRef
</code></pre><p>第 2：这样做引申出另外一个问题，就是我们的 render 函数其实是有参数 time 的：</p><pre tabindex=0><code>const render = (time: number) =&gt; {
    time *= 0.001
    cubes.forEach((cube) =&gt; {
        cube.rotation.x = cube.rotation.y = time
    })
    renderer.render(scene, camera)
    window.requestAnimationFrame(render)
}
window.requestAnimationFrame(render)
</code></pre><p>而我们希望 index.tsx 中调用 render() 是不传参数 time 的。因为 index.tsx 中根本不存在 time 这个变量，所以我们需要对 渲染 进行适当的改造。</p><p>我们将原本的 渲染函数 render() 拆分成 2 个函数：</p><ol><li>单纯负责渲染的 render 函数</li><li>负责修改物体属性从而产生动画的 animate 函数</li></ol><pre tabindex=0><code>const render = () =&gt; {
    renderer.render(scene, camera)
}
renderRef.current = render

const animate = (time: number) =&gt; {
    time *= 0.001
    cubes.forEach((cube) =&gt; {
        cube.rotation.x = cube.rotation.y = time
    })
    render() //这样 render() 就是一个不需要参数的函数
    window.requestAnimationFrame(animate)
}
window.requestAnimationFrame(animate)
</code></pre><p>经过这样改造后，完整的 use-create-screen.ts 代码如下：</p><pre tabindex=0><code>import { useEffect, useRef } from &#39;react&#39;
import * as Three from &#39;three&#39;
import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;

type RenderType = () =&gt; void

const useCreateScene = (canvasRef: React.RefObject&lt;HTMLCanvasElement&gt;) =&gt; {
    const renderRef = useRef&lt;RenderType | null&gt;(null)

    useEffect(() =&gt; {
        if (canvasRef.current === null) { return }

        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
        const scene = new Three.Scene()
        scene.background = new Three.Color(0x222222)
        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
        camera.position.set(0, 5, 10)

        const light = new Three.DirectionalLight(0xFFFFFF, 1)
        light.position.set(5, 10, 0)
        scene.add(light)

        const controls = new OrbitControls(camera, canvasRef.current)
        controls.update()

        const colors = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;]
        const cubes: Three.Mesh[] = []
        colors.forEach((color, index) =&gt; {
            const mat = new Three.MeshPhongMaterial({ color })
            const geo = new Three.BoxBufferGeometry(2, 2, 2)
            const mesh = new Three.Mesh(geo, mat)
            mesh.position.x = (index - 1) * 4
            scene.add(mesh)
            cubes.push(mesh)
        })

        const render = () =&gt; {
            renderer.render(scene, camera)
        }
        renderRef.current = render

        const animate = (time: number) =&gt; {
            time *= 0.001
            cubes.forEach((cube) =&gt; {
                cube.rotation.x = cube.rotation.y = time
            })
            render() //这样 render() 就是一个不需要参数的函数
            window.requestAnimationFrame(animate)
        }
        window.requestAnimationFrame(animate)

        const handleResize = () =&gt; {
            if (canvasRef.current === null) { return }
            const width = canvasRef.current.clientWidth
            const height = canvasRef.current.clientHeight
            camera.aspect = width / height
            camera.updateProjectionMatrix()
            renderer.setSize(width, height, false)
        }
        handleResize()
        window.addEventListener(&#39;resize&#39;, handleResize)

        return () =&gt; {
            window.removeEventListener(&#39;resize&#39;, handleResize)
        }
    }, [canvasRef])

    return renderRef
}

export default useCreateScene
</code></pre><p>index.tsx 完整代码如下：</p><pre tabindex=0><code>import { useRef, useState } from &#39;react&#39;
import DatGUI, { DatButton } from &#39;react-dat-gui&#39;
import useCreateScene from &#39;./use-create-scene&#39;

import &#39;./index.scss&#39;
import &#39;react-dat-gui/dist/index.css&#39;

const HelloCanvas = () =&gt; {
    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
    const [date, setDate] = useState&lt;any&gt;({})

    const renderRef =  useCreateScene(canvasRef) //获取自定义 hook 返回的 renderRef

    const handleGUIUpdate = (newDate: any) =&gt; {
        setDate(newDate)
    }

    const handleSaveClick = () =&gt; {
        if (canvasRef.current === null || renderRef.current === null) { return }
        const canvas = canvasRef.current

        renderRef.current() //此时调用 render()，进行一次渲染，确保 canvas 缓冲区有数据

        //采用 toDataURL() 方式
        // const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;, 0.8)
        // const a = document.createElement(&#39;a&#39;)
        // a.href = imgurl
        // a.download = &#39;myimg.jpeg&#39; //我们定义下载图片的文件名
        // a.click()

        //采用 toBlob() 方式
        canvas.toBlob((blob) =&gt; {
            const imgurl = window.URL.createObjectURL(blob)
            const a = document.createElement(&#39;a&#39;)
            a.href = imgurl
            a.download = &#39;myimg.jpeg&#39;
            a.click()
        }, &#39;image/jpeg&#39;, 0.8)
    }

    return (
        &lt;div className=&#39;full-screen&#39;&gt;
            &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
            &lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&#39;dat-gui&#39; &gt;
                &lt;DatButton label=&#39;点击保存画布快照&#39; onClick={handleSaveClick} /&gt;
            &lt;/DatGUI&gt;
        &lt;/div&gt;
    )
}

export default HelloCanvas
</code></pre><p>调试运行，这次保存的画布快照图片，就不会再是空白，而是有具体内容了。</p><h2 id=设置不清除画布内容>设置不清除画布内容</h2><p>上面刚讲到 HTML5 中的 Canvas 每次渲染都存在一个 数据缓冲区的概念，而 Three.js 的渲染器 WebGLRenderer 也同样存在 数据缓冲区 这个概念。</p><p>WebGLRenderer 缓冲区内为每次渲染场景得到的画面数据，默认情况下每一次渲染都会清空(释放)上一次的渲染画面数据。</p><p>Canvas 数据缓冲区每次清空 这个我们没有办法修改，只能调用渲染函数，重新渲染一次。</p><p>但是 WebGLRenderer 的数据缓冲区却是可以通过设置让默认不清除的。</p><blockquote><p>所谓不清除上一次数据缓冲区的内容，本质上就是保留上一次渲染画面内容</p></blockquote><blockquote><p>所谓不清除画布内容，本质上是让渲染器不清除之前的渲染内容</p></blockquote><p><strong>设置 WebGLRenderer 保留数据缓冲区中的历史数据：</strong></p><p>我们只需要将 WebGLRender 的配置修改如下：</p><pre tabindex=0><code>const renderer = new Three.WebGLRenderer({
    canvas: canvasRef.current,
    preserveDrawingBuffer: true,
    alpha: true
})
renderer.autoClearColor = false
</code></pre><p>经过以上的修改之后，每次渲染都会继续保留之前渲染历史画面。</p><p>调试运行代码，你就能感受到和之前渲染的不一样效果了。</p><p><strong>但是，存在一个问题：当浏览器窗口尺寸改变后，由于执行了 renderer.setSize()，则此时 渲染器中过往的渲染内容将会被清空。</strong></p><blockquote><p>渲染器中的渲染历史内容被清空后，画面就好像第一次刚开始那样，重新开始渲染。</p></blockquote><blockquote><p>补充说明：当用户在手机上浏览时，手机从竖屏变为横屏时，也会触发重新绘制。</p></blockquote><p><strong>真正的解决方案：离屏渲染</strong></p><p>例如使用 WebGLRenderTarget，具体请回顾我们之前讲解的内容：<a href=https://github.com/puxiao/threejs-tutorial/blob/main/15%20Three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93.md target=_blank rel=noopener>15 Three.js 基础之离屏渲染.md</a></p><h3 id=补充一个示例preservedrawingbuffer>补充一个示例：PreserveDrawingBuffer</h3><p>src/components/hello-canvas/preserve-drawing-buffer.tsx</p><h4 id=示例目标>示例目标：</h4><ol><li>创建一个由 6 个立方体，做相互缠绕运动的一个物体</li><li>创建一个正交镜头 OrthographicCamera</li><li>给 canvas 添加鼠标滑动监听、以及 手指滑动监听</li><li>当 鼠标或手指滑动画布时，更新 物体 在镜头中的位置</li><li>设置渲染器不清除历史画面</li></ol><p>最终呈现出的效果：类似一个 画笔在画板上 画画 的效果。</p><p><strong>PreserveDrawingBuffer 代码：</strong></p><pre tabindex=0><code>import { useEffect, useRef } from &#39;react&#39;
import * as Three from &#39;three&#39;

import &#39;./index.scss&#39;

const state = { x: 0, y: 0, z: 0 }

const PreserveDrawingBuffer = () =&gt; {
    const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)

    useEffect(() =&gt; {
        if (canvasRef.current === null) { return }

        const renderer = new Three.WebGLRenderer({
            canvas: canvasRef.current,
            preserveDrawingBuffer: true,
            alpha: true
        })
        renderer.autoClearColor = false

        const camera = new Three.OrthographicCamera(-2, 2, 1, -1, -1, 1)

        const scene = new Three.Scene()
        scene.background = new Three.Color(0xFFFFFF)

        const light = new Three.DirectionalLight(0xFFFFFF, 1)
        light.position.set(-1, 2, 3)
        scene.add(light)

        const geometry = new Three.BoxBufferGeometry(1, 1, 1)
        const base = new Three.Object3D()
        scene.add(base)
        base.scale.set(0.1, 0.1, 0.1)

        const colors = [&#39;#F00&#39;, &#39;#FF0&#39;, &#39;#0F0&#39;, &#39;#0FF&#39;, &#39;#00F&#39;, &#39;#F0F&#39;]
        const numArr = [-2, 2] //同一坐标轴上，对称 2 个立方体的坐标
        colors.forEach((color, index) =&gt; {
            const material = new Three.MeshPhongMaterial({ color })
            const cube = new Three.Mesh(geometry, material)

            const col = Math.floor(index / numArr.length)
            const row = index % numArr.length
            let result = [0, 0, 0]
            result[col] = numArr[row]

            cube.position.set(result[0], result[1], result[2])

            base.add(cube)
        })

        const temp = new Three.Vector3()
        const updatePosition = (x: number, y: number) =&gt; {
            if (canvasRef.current === null) { return }

            // const rect = canvasRef.current.getBoundingClientRect()
            // const newX = (x - rect.left) * canvasRef.current.width / rect.width
            // const newY = (y - rect.top) * canvasRef.current.height / rect.height

            // const resX = newX / canvasRef.current.width * 2 - 1
            // const resY = newY / canvasRef.current.height * -2 + 1

            const resX = x / canvasRef.current.width * 2 - 1
            const resY = y / canvasRef.current.height * -2 + 1

            temp.set(resX, resY, 0).unproject(camera)
            state.x = temp.x
            state.y = temp.y
        }

        const handleMouseMove = (eve: MouseEvent) =&gt; {
            updatePosition(eve.clientX, eve.clientY)
        }
        const handleTouchMove = (eve: TouchEvent) =&gt; {
            eve.preventDefault()
            const touche = eve.touches[0]
            updatePosition(touche.clientX, touche.clientY)
        }

        canvasRef.current.addEventListener(&#39;mousemove&#39;, handleMouseMove)
        canvasRef.current.addEventListener(&#39;touchmove&#39;, handleTouchMove, { passive: false })

        const render = (time: number) =&gt; {
            time = time * 0.001
            base.position.set(state.x, state.y, state.z)
            base.rotation.x = time
            base.rotation.y = time * 1.11
            renderer.render(scene, camera)
            window.requestAnimationFrame(render)
        }
        window.requestAnimationFrame(render)

        const handleResize = () =&gt; {
            if (canvasRef.current === null) { return }
            const width = canvasRef.current.clientWidth
            const height = canvasRef.current.clientHeight
            camera.right = width / height
            camera.left = - camera.right
            camera.updateProjectionMatrix()
            renderer.setSize(width, height, false)
        }
        handleResize()
        window.addEventListener(&#39;resize&#39;, handleResize)

        return () =&gt; {
            window.removeEventListener(&#39;resize&#39;, handleResize)
        }
    }, [canvasRef])

    return (
        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
    )
}

export default PreserveDrawingBuffer
</code></pre><p><strong>补充说明：</strong></p><p>上面这段代码略微复杂、陌生。因为这段代码中有几个地方是我们之前示例中从来未接触过的：</p><ol><li><p>使用的是正交镜头，而不是透视镜头</p></li><li><p>当窗口尺寸发生变化时，更新正交镜头</p><blockquote><p>更新方式和我们之前习惯使用的 透视镜头(PerspectiveCamera) 大不同</p></blockquote></li><li><p>监听鼠标滑动、手指滑动事件</p></li><li><p>更新 物体 在正交镜头中的 “投影位置”</p></li></ol><p><strong>额外补充：</strong></p><p>上述代码中，6 个立方体 他们分别是：</p><ol><li><p>在 x 轴对称的 2 个立方体</p><blockquote><p>在示例中，对应的坐标分别为 (-2,0,0)、(2,0,0)</p></blockquote></li><li><p>在 y 轴对称的 2 个立方体</p><blockquote><p>在示例中，对应的坐标分别为 (0,-2,0)、(0,2,0)</p></blockquote></li><li><p>在 z 轴堆成的 2 个立方体</p><blockquote><p>在示例中，对应的坐标分别为 (0,0,-2)、(0,0,2)</p></blockquote></li></ol><p>这 6 个立方体他们依次对应的坐标，没有提前写死，而是通过一段特殊的 forEach 循环来计算得出的。</p><p>可以阅读下面这段通用的代码，帮助你理解 整个 forEach 循环是如何得到每个立方体坐标的。</p><pre tabindex=0><code>//遍历出 目标长度为N，特殊值为 [xx, xx, ...] 的 多维数组
const numArr = [-2, 2] //定义特殊位置上出现的数字
const arrLength = 3 //定义目标数组长度
const total = arrLength * numArr.length //根据目标数组长度以及特殊数字的个数，计算得出目标数组的总个数
for (let i = 0; i &lt; total; i++) {
    const col = Math.floor(i / numArr.length) //计算出特殊位置的索引
    const row = i % numArr.length //计算出特殊位置上数字值对应的索引
    let result = new Array(arrLength) //得到一个 长度为 arrLenght 的数组
    result.fill(0) //将数组每一项填充为 0
    result[col] = numArr[row] //修改特殊位置上的值
    console.log(result)
}
</code></pre><p>如果你对 useCreateScene 这个示例不太理解也没有关系，因为毕竟这个示例中出现了一些我们之前示例中从未用到的一些类，你可以先跳过这个示例，继续后面的学习。</p><blockquote><p>随着日后对于 正交镜头 的多次使用，终归会熟练并理解的。</p></blockquote><h2 id=获取键盘事件>获取键盘事件</h2><h4 id=让-canvas-获取键盘事件>让 Canvas 获取键盘事件</h4><p>必须同时满足以下 2 个条件后，canvas 才可以获得键盘事件。</p><ol><li><p>canvas 当前获得焦点</p></li><li><p><code>&lt;canvas \></code> 标签中必须添加 tabIndex 属性，</p><blockquote><p>属性值是 -1、0、1 都无所谓，建议设置为 0</p></blockquote></li></ol><p>补充说明：当 canvas 获得当前焦点后，会在四周出现一个蓝色边框，可以通过定义 css 样式来取消这个样式。</p><pre tabindex=0><code>canvas:focus {
    outline: none;
}
</code></pre><p><strong>简单示例：</strong></p><pre tabindex=0><code>import { useEffect, useRef } from &#39;react&#39;

import &#39;./index.scss&#39;

const CanvasKeyboard = () =&gt; {
    const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)
    useEffect(() =&gt; {
        if (canvasRef.current === null) { return }

        canvasRef.current.focus() //自动获取焦点

        const handleKeydown = (event: KeyboardEvent) =&gt; {
            console.log(event)
        }

        canvasRef.current.addEventListener(&#39;keydown&#39;, handleKeydown)

        return () =&gt; {
            if (canvasRef.current === null) { return }
            canvasRef.current.removeEventListener(&#39;keydown&#39;, handleKeydown)
        }
    }, [canvasRef])
    return (
        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; tabIndex={0} /&gt;
    )
}

export default CanvasKeyboard
</code></pre><h4 id=让-orbitcontrol-获取键盘事件>让 OrbitControl 获取键盘事件</h4><p>默认 OrbitControl 对象就包含键盘方向键侦听。</p><p>键盘上的 上下左右 方向键 均可操控改变 镜头轨道视图。</p><p>但是我们之前的代码中，经常是这样写的：</p><pre tabindex=0><code>const controls = new OrbitControls(camera, canvasRef.current)
</code></pre><p>这样存在的问题是，当 canvas 失去焦点后，就无法再获得键盘事件。</p><p>最简单的解决办法就是将代码修改为：</p><pre tabindex=0><code>const controls = new OrbitControls(camera, document.body)
</code></pre><p>这样键盘事件就不容易丢失。</p><h2 id=设置画布透明度>设置画布透明度</h2><p>设置画布透明度，你可能会疑惑，这有什么好讲的，直接通过 css 给 canvas 添加透明度样式即可：</p><pre tabindex=0><code>canvas {
    opacity: 0.4;
}
</code></pre><p>这样做肯定没有问题，但是这里说的 “设置画布透明度” 实际上是指 给不同物体设置透明度。</p><p>例如我们之前示例中的立方体，那么所有的示例中立方体都不是半透明的。</p><p><strong>给材质设置透明度：</strong></p><ol><li><p>需要给材质设置透明度</p><pre tabindex=0><code>const mat = new Three.MeshPhongMaterial({
    color,
    opacity: 0.4
})
</code></pre></li><li><p>渲染器需要开启透明度渲染</p><pre tabindex=0><code>const renderer = new Three.WebGLRenderer({
    canvas: canvasRef.current,
    alpha:true,
    premultipliedAlpha:false
})
</code></pre><blockquote><p>alpha：canvas 是否包含透明度，默认为 false</p><p>premultipliedAlpha：renderer 是否假设颜色有 premultiplied alpha (预乘 alpha)，默认为 true</p></blockquote></li></ol><p><strong>针对 预乘 Alpha 的补充说明：</strong></p><p>premultiplied alpha：颜色值 预乘 alpha</p><p>这是传统 3D 绘制中的一个重要概念，你可以简单理解成如下：</p><p>假设我们要表示一个 透明度为 60% 的纯红色，采用 RGBA 的方式为 (255,0,0,0.6)，通过 预乘 alpha，我们可以得到透明度为 60% 的纯红色如果放置在纯白色底上，实际上最终呈现出来的颜色和 RGB ( 255,102,102) 是完全相同的。</p><p>假设一个颜色使用 RGBA 来表示，透明度为 A、rgb 颜色为 C、纯白色(255,255,255)为 F，那么把 RGBA 转化为 RGB 的公式为：</p><p>C*A + ( 1-A ) * F</p><p>也就是说 rgba(255,0,0,0.6) 转化为对应的 rgb 过程为：</p><p>(255,0,0)_0.6 + (1-0.6) _ (255,255,255) = (255, 255 x 0.4, 255 x 0.4) = (255,102,102)</p><p><strong>暂时看不懂没有关系，只需记住若想让渲染器将物体渲染出半透明，除了物体本身材质配置透明度以外，还需要将渲染器中的 alpha 设置为 true 、premultipliedAlpha 设置为 false</strong></p><h2 id=设置画布为背景>设置画布为背景</h2><p>将 canvas 设置为网页背景，事实上也很简单，对应的样式：</p><pre tabindex=0><code>canvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: -1;
}
</code></pre><p>上述 CSS 样式就让 canvas 位置固定，且层级最低，这样就成为当前网页背景了。</p><p>但是实际项目中，更加建议将 canvas 包含在一个 iframe 中后，再作为 网页的背景。</p><p>这样做有几个理由：</p><ol><li>使用 iframe 后，可以将 canvas、Three.js 的相关代码独立出来</li><li>可以多个页面都引用这个 iframe</li></ol><p><strong>iframe 的相关示例：</strong></p><pre tabindex=0><code>&lt;iframe id=&#39;background&#39; src=&#39;xxx.html&#39; &gt;
&lt;div&gt;
    Hello Three.js
&lt;/div&gt;
</code></pre><pre tabindex=0><code>#background {
    position: fixed;
    width:100%;
    height:100%;
    left:0;
    top:0;
    z-index:-1;
    border:none;
    pointer-events:none;
}
</code></pre><p>上述 css 样式中：</p><ol><li>position: fixed; 可以让 iframe 位置固定</li><li>z-index: -1; 可以让 iframe 层级最低</li><li>border: none; 可以让 iframe 不显示边框</li><li>pointer-events: none; 让 iframe 永远不会成为鼠标事件的 target，意味着让 iframe 不接受鼠标交互事件</li></ol><p>关于更多 canvas 的相关用法，建议阅读 MDN 上关于 canvas 的相关文档：</p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API target=_blank rel=noopener>https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p><p>至此，关于 Three.js 的一些常用技巧讲解完毕。</p><p>接下来开始讲解 Three.js 的一些性能优化。</p></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>上一页</div><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/18.three.js-%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%B0%83%E8%AF%95/ rel=next>18.Three.js 技巧之调试</a></div><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/cg-notes/03.%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%BA%93/web-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/three.js/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-puxiao-three.js-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/20.three.js-%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/ rel=prev>20.Three.js 优化之合并对象</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div><script type=text/javascript id=clstr_globe async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>