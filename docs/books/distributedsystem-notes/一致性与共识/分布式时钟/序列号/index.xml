<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>序列号 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F/%E5%BA%8F%E5%88%97%E5%8F%B7/</link>
      <atom:link href="https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F/%E5%BA%8F%E5%88%97%E5%8F%B7/index.xml" rel="self" type="application/rss+xml" />
    <description>序列号</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>序列号</title>
      <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F/%E5%BA%8F%E5%88%97%E5%8F%B7/</link>
    </image>
    
    <item>
      <title>全序广播</title>
      <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F/%E5%BA%8F%E5%88%97%E5%8F%B7/%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F/%E5%BA%8F%E5%88%97%E5%8F%B7/%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD/</guid>
      <description>&lt;h1 id=&#34;全序广播&#34;&gt;全序广播&lt;/h1&gt;
&lt;p&gt;如果你的程序只运行在单个 CPU 核上，那么定义一个操作全序是很容易的：可以简单地就是 CPU 执行这些操作的顺序。但是在分布式系统中，让所有节点对同一个全局操作顺序达成一致可能相当棘手。我们讨论过按时间戳或序列号进行排序，但发现它还不如单主复制给力（如果你使用时间戳排序来实现唯一性约束，而且不能容忍任何错误）。&lt;/p&gt;
&lt;p&gt;单主复制通过选择一个节点作为主库来确定操作的全序，并在主库的单个 CPU 核上对所有操作进行排序。接下来的挑战是，如果吞吐量超出单个主库的处理能力，这种情况下如何扩展系统；以及，如果主库失效，如何处理故障切换。在分布式系统文献中，这个问题被称为全序广播（total order broadcast）或原子广播（atomic broadcast）、&lt;/p&gt;
&lt;p&gt;全序广播通常被描述为在节点间交换消息的协议。非正式地讲，它要满足两个安全属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可靠交付（reliable delivery）：没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全序交付（totally ordered delivery）：消息以相同的顺序传递给每个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确的全序广播算法必须始终保证可靠性和有序性，即使节点或网络出现故障。当然在网络中断的时候，消息是传不出去的，但是算法可以不断重试，以便在网络最终修复时，消息能及时通过并送达（当然它们必须仍然按照正确的顺序传递）。&lt;/p&gt;
&lt;h1 id=&#34;使用全序广播&#34;&gt;使用全序广播&lt;/h1&gt;
&lt;p&gt;像 ZooKeeper 和 etcd 这样的共识服务实际上实现了全序广播，这一事实暗示了全序广播与共识之间有着紧密联系。全序广播正是数据库复制所需的：如果每个消息都代表一次数据库的写入，且每个副本都按相同的顺序处理相同的写入，那么副本间将相互保持一致（除了临时的复制延迟）。这个原理被称为状态机复制（state machine replication）。与之类似，可以使用全序广播来实现可序列化的事务，如果每个消息都表示一个确定性事务，以存储过程的形式来执行，且每个节点都以相同的顺序处理这些消息，那么数据库的分区和副本就可以相互保持一致。&lt;/p&gt;
&lt;p&gt;全序广播的一个重要表现是，顺序在消息送达时被固化：如果后续的消息已经送达，节点就不允许追溯地将（先前）消息插入顺序中的较早位置。这个事实使得全序广播比时间戳命令更强。考量全序广播的另一种方式是，这是一种创建日志的方式（如在复制日志，事务日志或预写式日志中）：传递消息就像附加写入日志。由于所有节点必须以相同的顺序传递相同的消息，因此所有节点都可以读取日志，并看到相同的消息序列。&lt;/p&gt;
&lt;p&gt;全序广播对于实现提供防护令牌的锁服务也很有用。每个获取锁的请求都作为一条消息追加到日志末尾，并且所有的消息都按它们在日志中出现的顺序依次编号。序列号可以当成防护令牌用，因为它是单调递增的。在 ZooKeeper 中，这个序列号被称为 zxid。&lt;/p&gt;
&lt;h1 id=&#34;使用全序广播实现线性一致的存储&#34;&gt;使用全序广播实现线性一致的存储&lt;/h1&gt;
&lt;p&gt;在线性一致的系统中，存在操作的全序。这是否意味着线性一致与全序广播一样？不尽然，但两者之间有者密切的联系。从形式上讲，线性一致读写寄存器是一个“更容易”的问题。全序广播等价于共识，而共识问题在异步的崩溃-停止模型中没有确定性的解决方案，而线性一致的读写寄存器可以在这种模型中实现。然而，支持诸如比较并设置（CAS, compare-and-set），或自增并返回（increment-and-get）的原子操作使它等价于共识问题。因此，共识问题与线性一致寄存器问题密切相关。&lt;/p&gt;
&lt;p&gt;全序广播是异步的：消息被保证以固定的顺序可靠地传送，但是不能保证消息何时被送达（所以一个接收者可能落后于其他接收者）。相比之下，线性一致性是新鲜性的保证：读取一定能看见最新的写入值。但如果有了全序广播，你就可以在此基础上构建线性一致的存储。例如，你可以确保用户名能唯一标识用户帐户。&lt;/p&gt;
&lt;p&gt;设想对于每一个可能的用户名，你都可以有一个带有 CAS 原子操作的线性一致寄存器。每个寄存器最初的值为空值（表示不使用用户名）。当用户想要创建一个用户名时，对该用户名的寄存器执行 CAS 操作，在先前寄存器值为空的条件，将其值设置为用户的账号 ID。如果多个用户试图同时获取相同的用户名，则只有一个 CAS 操作会成功，因为其他用户会看到非空的值（由于线性一致性）。你可以通过将全序广播当成仅追加日志的方式来实现这种线性一致的 CAS 操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在日志中追加一条消息，试探性地指明你要声明的用户名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读日志，并等待你所附加的信息被回送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否有任何消息声称目标用户名的所有权。如果这些消息中的第一条就你自己的消息，那么你就成功了：你可以提交声称的用户名（也许是通过向日志追加另一条消息）并向客户端确认。如果所需用户名的第一条消息来自其他用户，则中止操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于日志项是以相同顺序送达至所有节点，因此如果有多个并发写入，则所有节点会对最先到达者达成一致。选择冲突写入中的第一个作为胜利者，并中止后来者，以此确定所有节点对某个写入是提交还是中止达成一致。类似的方法可以在一个日志的基础上实现可序列化的多对象事务。尽管这一过程保证写入是线性一致的，但它并不保证读取也是线性一致的，如果你从与日志异步更新的存储中读取数据，结果可能是陈旧的。（精确地说，这里描述的过程提供了顺序一致性（sequential consistency），有时也称为时间线一致性（timeline consistency），比线性一致性稍微弱一些的保证）。为了使读取也线性一致，有几个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你可以通过追加一条消息，当消息回送时读取日志，执行实际的读取。消息在日志中的位置因此定义了读取发生的时间点。（etcd 的法定人数读取有些类似这种情况。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果日志允许以线性一致的方式获取最新日志消息的位置，则可以查询该位置，等待直到该位置前的所有消息都传达到你，然后执行读取。（这是 Zookeeper sync() 操作背后的思想）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你可以从同步更新的副本中进行读取，因此可以确保结果是最新的。（这种技术用于链式复制；参阅“复制研究”。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;使用线性一致性存储实现全序广播&#34;&gt;使用线性一致性存储实现全序广播&lt;/h1&gt;
&lt;p&gt;上一节介绍了如何从全序广播构建一个线性一致的 CAS 操作。我们也可以把它反过来，假设我们有线性一致的存储，接下来会展示如何在此基础上构建全序广播。最简单的方法是假设你有一个线性一致的寄存器来存储一个整数，并且有一个原子自增并返回操作。或者原子 CAS 操作也可以完成这项工作。该算法很简单：每个要通过全序广播发送的消息首先对线性一致寄存器执行自增并返回操作。然后将从寄存器获得的值作为序列号附加到消息中。然后你可以将消息发送到所有节点（重新发送任何丢失的消息），而收件人将按序列号连续发送消息。&lt;/p&gt;
&lt;p&gt;请注意，与兰伯特时间戳不同，通过自增线性一致性寄存器获得的数字形式上是一个没有间隙的序列。因此，如果一个节点已经发送了消息 4 并且接收到序列号为 6 的传入消息，则它知道它在传递消息 6 之前必须等待消息 5 。兰伯特时间戳则与之不同，事实上，这是全序广播和时间戳排序间的关键区别。实现一个带有原子性自增并返回操作的线性一致寄存器有多困难？像往常一样，如果事情从来不出差错，那很容易：你可以简单地把它保存在单个节点内的变量中。问题在于处理当该节点的网络连接中断时的情况，并在该节点失效时能恢复这个值。一般来说，如果你对线性一致性的序列号生成器进行深入过足够深入的思考，你不可避免地会得出一个共识算法。&lt;/p&gt;
&lt;p&gt;这并非巧合：可以证明，线性一致的 CAS（或自增并返回）寄存器与全序广播都都等价于共识问题。也就是说，如果你能解决其中的一个问题，你可以把它转化成为其他问题的解决方案。这是相当深刻和令人惊讶的洞察！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>序列号顺序</title>
      <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F/%E5%BA%8F%E5%88%97%E5%8F%B7/%E5%BA%8F%E5%88%97%E5%8F%B7%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F/%E5%BA%8F%E5%88%97%E5%8F%B7/%E5%BA%8F%E5%88%97%E5%8F%B7%E9%A1%BA%E5%BA%8F/</guid>
      <description>&lt;h1 id=&#34;序列号顺序与全序广播&#34;&gt;序列号顺序与全序广播&lt;/h1&gt;
&lt;h1 id=&#34;序列号顺序&#34;&gt;序列号顺序&lt;/h1&gt;
&lt;p&gt;虽然因果是一个重要的理论概念，但实际上跟踪所有的因果关系是不切实际的。在许多应用中，客户端在写入内容之前会先读取大量数据，我们无法弄清写入因果依赖于先前全部的读取内容，还是仅包括其中一部分。显式跟踪所有已读数据意味着巨大的额外开销。但还有一个更好的方法：我们可以使用序列号（sequence nunber）或时间戳（timestamp）来排序事件。时间戳不一定来自时钟（或物理时钟，存在许多问题）。它可以来自一个逻辑时钟（logical clock），这是一个用来生成标识操作的数字序列的算法，典型实现是使用一个每次操作自增的计数器。&lt;/p&gt;
&lt;p&gt;这样的序列号或时间戳是紧凑的（只有几个字节大小），它提供了一个全序关系：也就是说每操作都有一个唯一的序列号，而且总是可以比较两个序列号，确定哪一个更大（即哪些操作后发生）。特别是，我们可以使用与因果一致（consistent with causality）的全序来生成序列号：我们保证，如果操作 A 因果后继于操作 B，那么在这个全序中 A 在 B 前（A 具有比 B 更小的序列号）。并行操作之间可以任意排序。这样一个全序关系捕获了所有关于因果的信息，但也施加了一个比因果性要求更为严格的顺序。&lt;/p&gt;
&lt;p&gt;在单主复制的数据库中，复制日志定义了与因果一致的写操作。主库可以简单地为每个操作自增一个计数器，从而为复制日志中的每个操作分配一个单调递增的序列号。如果一个从库按照它们在复制日志中出现的顺序来应用写操作，那么从库的状态始终是因果一致的（即使它落后于领导者）。&lt;/p&gt;
&lt;h2 id=&#34;非因果序列号生成器&#34;&gt;非因果序列号生成器&lt;/h2&gt;
&lt;p&gt;如果主库不存在（可能因为使用了多主数据库或无主数据库，或者因为使用了分区的数据库），如何为操作生成序列号就没有那么明显了。在实践中有各种各样的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个节点都可以生成自己独立的一组序列号。例如有两个节点，一个节点只能生成奇数，而另一个节点只能生成偶数。通常，可以在序列号的二进制表示中预留一些位，用于唯一的节点标识符，这样可以确保两个不同的节点永远不会生成相同的序列号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以将时钟（物理时钟）时间戳附加到每个操作上。这种时间戳并不连续，但是如果它具有足够高的分辨率，那也许足以提供一个操作的全序关系。这一事实应用于 最后写入为准 的冲突解决方法中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以预先分配序列号区块。例如，节点 A 可能要求从序列号 1 到 1,000 区块的所有权，而节点 B 可能要求序列号 1,001 到 2,000 区块的所有权。然后每个节点可以独立分配所属区块中的序列号，并在序列号告急时请求分配一个新的区块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个选项都比单一主库的自增计数器表现要好，并且更具可扩展性。它们为每个操作生成一个唯一的，近似自增的序列号。然而它们都有同一个问题：生成的序列号与因果不一致。因为这些序列号生成器不能正确地捕获跨节点的操作顺序，所以会出现因果关系的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个节点每秒可以处理不同数量的操作。因此，如果一个节点产生偶数序列号而另一个产生奇数序列号，则偶数计数器可能落后于奇数计数器，反之亦然。如果你有一个奇数编号的操作和一个偶数编号的操作，你无法准确地说出哪一个操作在因果上先发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;来自物理时钟的时间戳会受到时钟偏移的影响，这可能会使其与因果不一致。例如下图这个例子中，其中因果上晚发生的操作，却被分配了一个更早的时间戳。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/17/3C4Cdg.md.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在分配区块的情况下，某个操作可能会被赋予一个范围在 1,001 到 2,000 内的序列号，然而一个因果上更晚的操作可能被赋予一个范围在 1 到 1,000 之间的数字。这里序列号与因果关系也是不一致的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;兰伯特时间戳&#34;&gt;兰伯特时间戳&lt;/h2&gt;
&lt;p&gt;尽管刚才描述的三个序列号生成器与因果不一致，但实际上有一个简单的方法来产生与因果关系一致的序列号。它被称为兰伯特时间戳，莱斯利·兰伯特（Leslie Lamport）于 1978 年提出，现在是分布式系统领域中被引用最多的论文之一。下图说明了兰伯特时间戳的应用。每个节点都有一个唯一标识符，和一个保存自己执行操作数量的计数器。兰伯特时间戳就是两者的简单组合：（计数器，节点 ID）$(counter, node ID)$。两个节点有时可能具有相同的计数器值，但通过在时间戳中包含节点 ID，每个时间戳都是唯一的。兰伯特时间戳与物理时间时钟没有任何关系，但是它提供了一个全序：如果你有两个时间戳，则计数器值大者是更大的时间戳。如果计数器值相同，则节点 ID 越大的，时间戳越大。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/17/3C596x.md.png&#34; alt=&#34;Lamport 时间戳提供了与因果关系一致的总排序&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;迄今，这个描述与上节所述的奇偶计数器基本类似。使兰伯特时间戳因果一致的关键思想如下所示：每个节点和每个客户端跟踪迄今为止所见到的最大计数器值，并在每个请求中包含这个最大计数器值。当一个节点收到最大计数器值大于自身计数器值的请求或响应时，它立即将自己的计数器设置为这个最大值。还是如上图所示，其中客户端 A 从节点 2 接收计数器值 5，然后将最大值 5 发送到节点 1 。此时，节点 1 的计数器仅为 1，但是它立即前移至 5，所以下一个操作的计数器的值为 6 。只要每一个操作都携带着最大计数器值，这个方案确保兰伯特时间戳的排序与因果一致，因为每个因果依赖都会导致时间戳增长。&lt;/p&gt;
&lt;p&gt;兰伯特时间戳与版本向量有所相似，但它们有着不同的目的：版本向量可以区分两个操作是并发的，还是一个因果依赖另一个；而兰伯特时间戳总是施行一个全序。从兰伯特时间戳的全序中，你无法分辨两个操作是并发的还是因果依赖的。兰伯特时间戳优于版本向量的地方是，它更加紧凑。&lt;/p&gt;
&lt;h2 id=&#34;光有时间戳排序还不够&#34;&gt;光有时间戳排序还不够&lt;/h2&gt;
&lt;p&gt;虽然兰伯特时间戳定义了一个与因果一致的全序，但它还不足以解决分布式系统中的许多常见问题。例如，考虑一个需要确保用户名能唯一标识用户帐户的系统。如果两个用户同时尝试使用相同的用户名创建帐户，则其中一个应该成功，另一个应该失败。乍看之下，似乎操作的全序关系足以解决这一问题（例如使用兰伯特时间戳）：如果创建了两个具有相同用户名的帐户，选择时间戳较小的那个作为胜者（第一个抓到用户名的人），并让带有更大时间戳者失败。由于时间戳上有全序关系，所以这个比较总是可行的。&lt;/p&gt;
&lt;p&gt;这种方法适用于事后确定胜利者：一旦你收集了系统中的所有用户名创建操作，就可以比较它们的时间戳。然而当某个节点需要实时处理用户创建用户名的请求时，这样的方法就无法满足了。节点需要马上（right now）决定这个请求是成功还是失败。在那个时刻，节点并不知道是否存其他节点正在并发执行创建同样用户名的操作，罔论其它节点可能分配给那个操作的时间戳。&lt;/p&gt;
&lt;p&gt;为了确保没有其他节点正在使用相同的用户名和较小的时间戳并发创建同名账户，你必须检查其它每个节点，看看它在做什么。如果其中一个节点由于网络问题出现故障或不可达，则整个系统可能被拖至停机。这不是我们需要的那种容错系统。这里的问题是，只有在所有的操作都被收集之后，操作的全序才会出现。如果另一个节点已经产生了一些操作，但你还不知道那些操作是什么，那就无法构造所有操作最终的全序关系：来自另一个节点的未知操作可能需要被插入到全序中的不同位置。&lt;/p&gt;
&lt;p&gt;总之：为了实诸如如用户名上的唯一约束这种东西，仅有操作的全序是不够的，你还需要知道这个全序何时会尘埃落定。如果你有一个创建用户名的操作，并且确定在全序中，没有任何其他节点可以在你的操作之前插入对同一用户名的声称，那么你就可以安全地宣告操作执行成功。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
