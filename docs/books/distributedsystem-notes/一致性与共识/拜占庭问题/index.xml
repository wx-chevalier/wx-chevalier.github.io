<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜占庭问题 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/</link>
      <atom:link href="https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <description>拜占庭问题</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>拜占庭问题</title>
      <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/</link>
    </image>
    
    <item>
      <title>拜占庭故障</title>
      <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E6%95%85%E9%9A%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E6%95%85%E9%9A%9C/</guid>
      <description>&lt;h1 id=&#34;拜占庭故障&#34;&gt;拜占庭故障&lt;/h1&gt;
&lt;p&gt;在&lt;a href=&#34;https://github.com/wx-chevalier/DistributedSystem-Notes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《分布式锁&lt;/a&gt;》中我们讨论过利用屏蔽令牌来解决节点暂停的问题，屏蔽令牌可以检测和阻止无意中发生错误的节点（例如，因为它尚未发现其租约已过期）。但是，如果节点有意破坏系统的保证，则可以通过使用假屏蔽令牌发送消息来轻松完成此操作。大部分情况下，我们假设节点是不可靠但诚实的：它们可能很慢或者从不响应（由于故障），并且它们的状态可能已经过时（由于 GC 暂停或网络延迟），但是我们假设如果节点它做出了回应，它正在说出“真相”：尽其所知，它正在按照协议的规则扮演其角色。&lt;/p&gt;
&lt;p&gt;如果存在节点可能“撒谎”（发送任意错误或损坏的响应）的风险，则分布式系统的问题变得更困难了——例如，如果节点可能声称其实际上没有收到特定的消息。这种行为被称为拜占庭故障（Byzantine fault），在不信任的环境中达成共识的问题被称为拜占庭将军问题。&lt;/p&gt;
&lt;h1 id=&#34;拜占庭将军问题&#34;&gt;拜占庭将军问题&lt;/h1&gt;
&lt;p&gt;拜占庭将军问题是所谓“两将军问题”的概括，它想象两个将军需要就战斗计划达成一致的情况。由于他们在两个不同的地点建立了营地，他们只能通过信使进行沟通，信使有时会被延迟或丢失（就像网络中的信息包一样）。在这个拜占庭式的问题中，有 n 位将军需要同意，他们的努力因为有一些叛徒在他们中间而受到阻碍。大多数的将军都是忠诚的，因而发出了真实的信息，但是叛徒可能会试图通过发送虚假或不真实的信息来欺骗和混淆他人（在试图保持未被发现的同时）。事先并不知道叛徒是谁。&lt;/p&gt;
&lt;p&gt;拜占庭是后来成为君士坦丁堡的古希腊城市，现在在土耳其的伊斯坦布尔。没有任何历史证据表明拜占庭将军比其他地方更容易出现阴谋和阴谋。相反，这个名字来源于拜占庭式的过度复杂，官僚，迂回等意义，早在计算机之前就已经在政治中被使用了。Lamport 想要选一个不会冒犯任何读者的国家，他被告知将其称为阿尔巴尼亚将军问题并不是一个好主意。&lt;/p&gt;
&lt;h1 id=&#34;拜占庭容错&#34;&gt;拜占庭容错&lt;/h1&gt;
&lt;p&gt;当一个系统在部分节点发生故障、不遵守协议、甚至恶意攻击、扰乱网络时仍然能继续正确工作，称之为拜占庭容错（Byzantine fault-tolerant）的，在特定场景下，这种担忧在是有意义的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在航空航天环境中，计算机内存或 CPU 寄存器中的数据可能被辐射破坏，导致其以任意不可预知的方式响应其他节点。由于系统故障将非常昂贵（例如，飞机撞毁和炸死船上所有人员，或火箭与国际空间站相撞），飞行控制系统必须容忍拜占庭故障。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在多个参与组织的系统中，一些参与者可能会试图欺骗或欺骗他人。在这种情况下，节点仅仅信任另一个节点的消息是不安全的，因为它们可能是出于恶意的目的而被发送的。例如，像比特币和其他区块链一样的对等网络可以被认为是让互不信任的各方同意交易是否发生的一种方式，而不依赖于中央当局。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我们常说的服务端基础架构中，我们通常可以安全地假设没有拜占庭式的错误。在你的数据中心里，所有的节点都是由你的组织控制的（所以他们可以信任），辐射水平足够低，内存损坏不是一个大问题。制作拜占庭容错系统的协议相当复杂，而容错嵌入式系统依赖于硬件层面的支持。在大多数服务器端数据系统中，部署拜占庭容错解决方案的成本使其变得不切实际。&lt;/p&gt;
&lt;p&gt;Web 应用程序确实需要预期受终端用户控制的客户端（如 Web 浏览器）的任意和恶意行为。这就是为什么输入验证，清理和输出转义如此重要：例如，防止 SQL 注入和跨站点脚本。但是，我们通常不使用拜占庭容错协议，而只是让服务器决定什么是客户端行为，而不是允许的。在没有这种中心授权的对等网络中，拜占庭容错更为重要。&lt;/p&gt;
&lt;p&gt;软件中的一个错误可能被认为是拜占庭式的错误，但是如果您将相同的软件部署到所有节点上，那么拜占庭式的容错算法不能为您节省。大多数拜占庭式容错算法要求超过三分之二的节点能够正常工作（即，如果有四个节点，最多只能有一个故障）。要使用这种方法对付 bug，你必须有四个独立的相同软件的实现，并希望一个 bug 只出现在四个实现之一中。&lt;/p&gt;
&lt;p&gt;同样，如果一个协议可以保护我们免受漏洞，安全妥协和恶意攻击，那么这将是有吸引力的。不幸的是，这也是不现实的：在大多数系统中，如果攻击者可以渗透一个节点，那他们可能会渗透所有这些节点，因为它们可能运行相同的软件。因此传统机制（认证，访问控制，加密，防火墙等）仍然是攻击者的主要保护措施。&lt;/p&gt;
&lt;h1 id=&#34;弱谎言形式&#34;&gt;弱谎言形式&lt;/h1&gt;
&lt;p&gt;尽管我们假设节点通常是诚实的，但值得向软件中添加防止“撒谎”弱形式的机制——例如，由硬件问题导致的无效消息，软件错误和错误配置。这种保护机制并不是完全的拜占庭容错，因为它们不能抵挡决心坚定的对手，但它们仍然是简单而实用的步骤，以提高可靠性。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于硬件问题或操作系统，驱动程序，路由器等中的错误，网络数据包有时会受到损坏。通常，内建于 TCP 和 UDP 中的校验和会俘获损坏的数据包，但有时它们会逃避检测。简单的措施通常是采用充分的保护来防止这种破坏，例如应用程序级协议中的校验和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可公开访问的应用程序必须仔细清理来自用户的任何输入，例如检查值是否在合理的范围内，并限制字符串的大小以防止通过大内存分配拒绝服务。防火墙后面的内部服务可能能够在对输入进行较不严格的检查的情况下逃脱，但是一些基本的理智检查（例如，在协议解析中）是一个好主意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NTP 客户端可以配置多个服务器地址。同步时，客户端联系所有的服务器，估计它们的误差，并检查大多数服务器是否在对某个时间范围内达成一致。只要大多数的服务器没问题，一个配置错误的 NTP 服务器报告的时间会被当成特异值从同步中排除。使用多个服务器使 NTP 更健壮（比起只用单个服务器来）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统模型</title>
      <link>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-notes/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h1 id=&#34;系统模型&#34;&gt;系统模型&lt;/h1&gt;
&lt;h1 id=&#34;系统模型-1&#34;&gt;系统模型&lt;/h1&gt;
&lt;p&gt;算法的编写方式并不过分依赖于运行的硬件和软件配置的细节。这又要求我们以某种方式将我们期望在系统中发生的错误形式化。我们通过定义一个系统模型来做到这一点，这个模型是一个抽象，描述一个算法可能承担的事情。关于定时假设，三种系统模型是常用的：&lt;/p&gt;
&lt;h2 id=&#34;定时假设模型&#34;&gt;定时假设模型&lt;/h2&gt;
&lt;h3 id=&#34;同步模型&#34;&gt;同步模型&lt;/h3&gt;
&lt;p&gt;同步模型（synchronous model）假设网络延迟，进程暂停和和时钟误差都是有界限的。这并不意味着完全同步的时钟或零网络延迟；这只意味着你知道网络延迟，暂停和时钟漂移将永远不会超过某个固定的上限。同步模型并不是大多数实际系统的现实模型，因为（如本章所讨论的）无限延迟和暂停确实会发生。&lt;/p&gt;
&lt;h3 id=&#34;部分同步模型&#34;&gt;部分同步模型&lt;/h3&gt;
&lt;p&gt;部分同步（partial synchronous）意味着一个系统在大多数情况下像一个同步系统一样运行，但有时候会超出网络延迟，进程暂停和时钟漂移的界限。这是很多系统的现实模型：大多数情况下，网络和进程表现良好，否则我们永远无法完成任何事情，但是我们必须承认，在任何时刻假设都存在偶然被破坏的事实。发生这种情况时，网络延迟，暂停和时钟错误可能会变得相当大。&lt;/p&gt;
&lt;h3 id=&#34;异步模型&#34;&gt;异步模型&lt;/h3&gt;
&lt;p&gt;在这个模型中，一个算法不允许对时机做任何假设——事实上它甚至没有时钟（所以它不能使用超时）。一些算法被设计为可用于异步模型，但非常受限。&lt;/p&gt;
&lt;h2 id=&#34;节点失效系统模型&#34;&gt;节点失效系统模型&lt;/h2&gt;
&lt;p&gt;除了时间问题，我们还要考虑节点失效。三种最常见的节点系统模型是。&lt;/p&gt;
&lt;h3 id=&#34;崩溃-停止故障&#34;&gt;崩溃-停止故障&lt;/h3&gt;
&lt;p&gt;在崩溃停止（crash-stop）模型中，算法可能会假设一个节点只能以一种方式失效，即通过崩溃。这意味着节点可能在任意时刻突然停止响应，此后该节点永远消失——它永远不会回来。&lt;/p&gt;
&lt;h3 id=&#34;崩溃-恢复故障&#34;&gt;崩溃-恢复故障&lt;/h3&gt;
&lt;p&gt;我们假设节点可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应。在崩溃-恢复（crash-recovery）模型中，假设节点具有稳定的存储（即，非易失性磁盘存储）且会在崩溃中保留，而内存中的状态会丢失。&lt;/p&gt;
&lt;h3 id=&#34;拜占庭任意故障&#34;&gt;拜占庭（任意）故障&lt;/h3&gt;
&lt;p&gt;节点可以做（绝对意义上的）任何事情，包括试图戏弄和欺骗其他节点。&lt;/p&gt;
&lt;h1 id=&#34;算法的正确性&#34;&gt;算法的正确性&lt;/h1&gt;
&lt;p&gt;为了定义算法是正确的，我们可以描述它的属性。例如，排序算法的输出具有如下特性：对于输出列表中的任何两个不同的元素，左边的元素比右边的元素小。这只是定义对列表进行排序含义的一种形式方式。同样，我们可以写下我们想要的分布式算法的属性来定义它的正确含义。例如，如果我们正在为一个锁生成屏蔽令牌，我们可能要求算法具有以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;唯一性：没有两个屏蔽令牌请求返回相同的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单调序列：如果请求 $x$ 返回了令牌 $t_x$，并且请求$y$返回了令牌$t_y$，并且 $x$ 在 $y$ 开始之前已经完成，那么$t_x &amp;lt;t_y$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可用性：请求防护令牌并且不会崩溃的节点，最终会收到响应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个系统模型中的算法总是满足它在我们假设可能发生的所有情况下的性质，那么这个算法是正确的。但这如何有意义？如果所有的节点崩溃，或者所有的网络延迟突然变得无限长，那么没有任何算法能够完成任何事情。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
