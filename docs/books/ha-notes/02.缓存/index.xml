<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>02.缓存 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/</link><atom:link href="https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/index.xml" rel="self" type="application/rss+xml"/><description>02.缓存</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>02.缓存</title><link>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/</link></image><item><title>缓存策略</title><link>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</guid><description>&lt;h1 id="缓存策略">缓存策略&lt;/h1>
&lt;h1 id="缓存一致性">缓存一致性&lt;/h1>
&lt;h1 id="缓存预热">缓存预热&lt;/h1>
&lt;p>大促对于商品来说就是一年中最高峰的访问量，提前做好数据预热时保证双 11 等大促最关键的提前预案，如何确保提前预热的数据是&amp;quot;有效&amp;quot;的是预热质量的标志。对于商品中心来说，数据未命中主要会出现以下几种情况：
  *商品数据不全，比如上述 spu、多语言信息、关联关系等
  *tair 容量不足导致数据逐出
  *各单元数据不一致，DRC 同步延迟
  *数据不存在，导致请求直接打穿到 DB&lt;/p>
&lt;p>所以，数据预热除了要保证数据数据本身的质量外，还需要提前预估、检查基础设施的稳定性。但对于数据本身来说：
第一步是收集数据: 1.获取大促前购物车、收藏夹 top5000w 数据；2.获取含有大促商品标的商品；3.其他预热商品，服务商品、零售通商品等业务方要求预热数据
第二步是校验数据：
  大致的逻辑比较简单，通过预热平台引擎发起预热请求到 server 端，put 数据到 tair 中，然后模拟一次客户端调用，看是否能从 tair 中查询出数据，如果 tair 命中失败，检查是什么原因导致，同时统计模拟调用的命中率来呈现预热质量：&lt;/p>
&lt;h1 id="缓存设计">缓存设计&lt;/h1>
&lt;h2 id="查询">查询&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RAfYKRMKDBqZYPpwLjSbUkcRXUxLTHpK4CBc2RPnlusmOeNMCHHgJKBPhnESdujkNcRFoWkJSibY2A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="更新--删除">更新 / 删除&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RAfYKRMKDBqZYPpwLjSbUkcia4GzH8UH09octde8VpkS5nrcJ4FOYguAL5HRaYSbodbDSoK1qnbpgw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RAfYKRMKDBqZYPpwLjSbUkcOchXO2vU7bMgWM8zG6qrzMVI5ZtxjSj099xIIoG4NcocMUAKq3DIKg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="db-和缓存一致性">DB 和缓存一致性&lt;/h3>
&lt;p>答：当修改了数据库后，有没有及时修改缓存。这种问题，以前有过实践，修改数据库成功，而修改缓存失败的情况，最主要就是缓存服务器挂了。而因为网络问题引起的没有及时更新，可以通过重试机制来解决。而缓存服务器挂了，请求首先自然也就无法到达，从而直接访问到数据库。那么我们在修改数据库后，无法修改缓存，这时候可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。&lt;/p>
&lt;h1 id="缓存问题">缓存问题&lt;/h1>
&lt;h2 id="缓存穿透">缓存穿透&lt;/h2>
&lt;p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查 询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询 DB，这样缓存就失去了意义，在流量大时，可能 DB 就挂掉了。要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。&lt;/p>
&lt;p>有一个比较巧妙的作法是，可以将这个不存在的 key 预先设定一个值。&lt;/p>
&lt;p>比如，&amp;ldquo;key&amp;rdquo;, “&amp;amp;&amp;amp;”。&lt;/p>
&lt;p>在返回这个 &amp;amp;&amp;amp; 值的时候，我们的应用就可以认为这是不存在的 key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个 key，如果取到的值不再是 &amp;amp;&amp;amp;，则可以认为这时候 key 有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。&lt;/p>
&lt;h2 id="缓存并发">缓存并发&lt;/h2>
&lt;p>有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询 DB，同时设置缓存的情况，如果并发确实很大，这也可能造成 DB 压力过大，还有缓存频繁更新的问题。&lt;/p>
&lt;p>我现在的想法是对缓存查询加锁，如果 KEY 不存在，就加锁，然后查 DB 入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入 DB 查询。&lt;/p>
&lt;p>这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。&lt;/p>
&lt;h2 id="缓存失效">缓存失效&lt;/h2>
&lt;p>引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置 1 分钟啊，5 分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到 DB，DB 可能会压力过重。&lt;/p>
&lt;p>那如何解决这些问题呢？&lt;/p>
&lt;p>其中的一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。&lt;/p></description></item><item><title>缓存淘汰算法</title><link>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</guid><description>&lt;h1 id="缓存淘汰算法">缓存淘汰算法&lt;/h1>
&lt;h1 id="lru">LRU&lt;/h1>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/youanyyou/article/details/78989956" target="_blank" rel="noopener">https://blog.csdn.net/youanyyou/article/details/78989956&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>缓存一致性</title><link>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/ha-notes/02.%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>&lt;h1 id="缓存一致性">缓存一致性&lt;/h1>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://cubox.pro/c/4kL5m3" target="_blank" rel="noopener">https://cubox.pro/c/4kL5m3&lt;/a> 分布式缓存与DB秒级一致设计实践&lt;/li>
&lt;/ul></description></item></channel></rss>