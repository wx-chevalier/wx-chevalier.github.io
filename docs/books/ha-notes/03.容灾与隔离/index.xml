<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>03.容灾与隔离 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/</link><atom:link href="https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/index.xml" rel="self" type="application/rss+xml"/><description>03.容灾与隔离</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>03.容灾与隔离</title><link>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/</link></image><item><title>容灾系统</title><link>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/%E5%AE%B9%E7%81%BE%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/%E5%AE%B9%E7%81%BE%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="容灾系统">容灾系统&lt;/h1>
&lt;p>容灾按时间发展维度来看，截止到今天，容灾主要经历了如下了的几个阶段：&lt;/p>
&lt;ul>
&lt;li>第一阶段（1980-2000 年）：IT 作为业务支撑系统，容灾以数据为中心，恢复以人工为主，容灾系统作为备用系统&lt;/li>
&lt;li>第二阶段（2000-2013 年）：IT 作为业务的使能，容灾以业务为中心，双活、AQ 模式使得容灾系统支撑部分业务&lt;/li>
&lt;li>第三阶段（2013 年-至今）：年容灾即业务，容灾以客户为中心，智能流量分配，多中心部署，容灾系统即业务系统。异地多活目前就是处在第三阶段。&lt;/li>
&lt;/ul>
&lt;h1 id="容灾系统的评价指标">容灾系统的评价指标&lt;/h1>
&lt;p>容灾系统主要为了在灾难发生时业务不发生中断，那么当灾难发生时，用户最关心的是什么呢？以下是国际通用的容灾系统的评审标准 Share 78，可以作为广大用户衡量和选择容灾解决方案的指标。以下是备份/恢复的范围：&lt;/p>
&lt;ul>
&lt;li>灾难恢复计划的状态&lt;/li>
&lt;li>在应用中心与备份中心之间的距离&lt;/li>
&lt;li>应用中心与备份中心之间是如何相互连接的&lt;/li>
&lt;li>数据是怎样在两个中心之间传送的&lt;/li>
&lt;li>有多少数据被丢失&lt;/li>
&lt;li>怎样保证更新的数据在备份中心被更新&lt;/li>
&lt;li>备份中心可以开始备份工作的能力&lt;/li>
&lt;/ul>
&lt;p>因此，容灾系统的设计，主要也是围绕这几个用户需求。当然，容灾也不会无限制地投入，我们设计出的系统也只能是在现有的条件下尽量减少故障历时，尽量多的恢复数据，这也是衡量我们所设计出来的容灾系统质量的指标。实际的容灾系统设计过程中，我们重点关注的是 RTO 和 RPO 两个指标。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>RPO（Recovery Point Objective）：即数据恢复点目标，以时间为单位，即在灾难发生时，系统和数据必须恢复的时间点要求。RPO 标志系统能够容忍的最大数据丢失量。系统容忍丢失的数据量越小，RPO 的值越小。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RTO（Recovery Time Objective）：即恢复时间目标，以时间为单位，即在灾难发生后，信息系统或业务功能从停止到必须恢复的时间要求。RTO 标志系统能够容忍的服务停止的最长时间。系统服务的紧迫性要求越高，RTO 的值越小。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>RPO 针对的是数据丢失，而 RTO 针对的是服务丢失，RTO 和 RPO 的确定必须在进行风险分析和业务影响分析后根据不同的业务需求确定。好的容灾系统需要尽量满足用户的需求，但是容灾系统的设计往往受多种条件的制约，如可用的技术、现网状况、用户意志、用户业务等，但到目前为止，起决定性的因素，是容灾建设的成本。以下是容灾中心建设等级示意图。&lt;/p>
&lt;h1 id="系统构建">系统构建&lt;/h1>
&lt;p>根据对容灾系统建设模型，容灾系统建设过程分为分析、设计和实施三个阶段。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230416205810.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>下面分别对各个阶段作出说明：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>分析阶段：在取得管理层的正式同意后，获得人员和资源的保证。首先收集业务过程的信息、技术基础架构的支撑环境、灾难类型等方面的内容，然后进行业务影响分析和风险分析，确定由于中断和预期灾难可能造成的影响。分析的结果用以确定业务关键级别、业务恢复时间和可承受的数据损失程度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设计阶段：在本阶段，结合以上的分析成果，以及企业对容灾的投入规划，制订企业短期、长期范围内的容灾策略和目标，先定义初步的方案。再进一步结合各种因素进行分析，在候选的方案中剔除不合适的方案，将剩余的可用的方案提交给评估组，评估组经过充分详细的评审，选择最合适的容灾方案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实施阶段：根据选择的容灾方案，整合企业相关资源，确定容灾的体系架构和灾难恢复计划，通过技术手段和服务以达到所要求的容灾目标。任何制订的计划，都必须经过不断的测试和修正，才能满足企业不断发展的需求。同时，通过培训、测试过程，也能够使企业内部人员熟悉自己在容灾流程中所扮演的角色，保证在灾难真正发生的时刻能够有条不紊地执行恢复流程。测试的过程可以分为局部验证和演习两种方式。随着商业需求、新技术的不断升级以及新的内部和外部规则的变化，IT 系统也会随之改变。要确保灾难恢复计划的有效性，必须定期检查和修改计划。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>冗余设计</title><link>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/%E5%86%97%E4%BD%99%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/%E5%86%97%E4%BD%99%E8%AE%BE%E8%AE%A1/</guid><description>&lt;h1 id="冗余设计">冗余设计&lt;/h1>
&lt;p>工程学中的冗余是指系统为了提升其可靠度，刻意配置重复的零件或是机能。冗余一般是为了备用，或是失效安全的考量，也有可能是了提升系统性能，像是卫星导航系统接收器，或是多线程电脑处理。&lt;/p>
&lt;p>在计算机科学中，主要有以下几种不同的冗余，分别是：&lt;/p>
&lt;ul>
&lt;li>硬件冗余，例如双重模块冗余及三重模块冗余&lt;/li>
&lt;li>信息冗余，例如错误检测与纠正方法&lt;/li>
&lt;li>时间冗余，进行同一个任务数次，例如执行同一个程式数次，或是传输同一笔资料数次等&lt;/li>
&lt;li>软件冗余，例如 N 版本编程（N2Version Programming, NVP）,是由 Elmendor 提出并经 Avinienis 等人完善与实现的一种静态容错技术，它使用多个不同的软件版本利用决策机制和前向恢复实现容错。另一种由软件冗余衍生，但应用在硬件上的冗余是不同功能冗余，像是车辆中同时有机械刹车及油压刹车。此作法是用软件中的例子，二个独立由不同人写作，有相同功能的模组，针对同一信号产生相同的输出。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230417213615.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个网站，从基础的硬件层，到操作系统层，到数据库层，到应用程序层，再到网络层，都有可能产生单点故障。如果要有效地消除单点故障，最重要的一点是设计的时候要尽量避免引入单点，随着架构的变化，定期审查系统潜在的单点也是有必要的。如下面一些常见的审查：&lt;/p>
&lt;p>IDC 机房的单点，至少要两个 IDC 共存
机房的电力双线冗余，UPS、柴发随时准备
增加硬盘，做镜像，让出错的概率降低；
网卡与网线的单点问题，绑定多块网卡；
数据库至少要做好一主一备
负载均衡、反向代理至少一个集群有两个节点
靠谱的 DNS 解析
&amp;hellip;&lt;/p>
&lt;p>在应用程序层，一般来说是增加应用的部署节点，然后用一定的策略进行流量的分配。但实际上，我们需要根据应用的场景来做细分，针对不同的应用场景，解决单点问题需要思考和关注的点是不同的。毕竟应用里面有复杂的业务逻辑，是直接面向用户产生业务价值的。&lt;/p>
&lt;h1 id="有状态应用">有状态应用&lt;/h1>
&lt;p>一般而言我们把应用层分成无状态应用和有状态应用，针对这两种类型的应用，我们做冗余的方法是完全不一样的。针对无状态的应用，处理上相对比较简单。我可以增加应用的部署节点，然后把流量随机分配到这些应用结点上即可。典型的就是 Nginx 集群、简单的业务系统，这些系统没有状态，水平扩展集群即可提升集群的整体冗余能力。&lt;/p>
&lt;p>有状态的应用处理起来就相对比较复杂了。&lt;/p>
&lt;h2 id="状态同步">状态同步&lt;/h2>
&lt;p>有状态的应用，即应用内存中会记录运算过程中的状态数据，而整个功能的完成要依赖这些状态数据，但由于这些状态数据只存在某个应用结点上，那么如果前端流量随机打入后端应用结点，会造成处理结果的不准确。针对这种情况，我们通常有两种解决方法，&lt;/p>
&lt;p>调整流量分配规则，即采用一定的 hash 算法，根据请求标识把请求打入特定的后端应用，但这种方案需要注意的点就是采用 requestId%应用机器数 的 hash 方法时，当后端应用结点变化时（机器上下线），会造成所有请求流入的应用结点改变，这时可以考虑采用一致性 hash 算法来解决；
共享存储系统，将运算过程中产生的状态数据存入共享存储系统，所有应用结点通过共享存储系统读取状态信息达到同步的效果，共享存储系统可以是 DB，分布式缓存等等，根据应用场景而定；&lt;/p>
&lt;h2 id="操作互斥">操作互斥&lt;/h2>
&lt;p>在解决状态同步的问题之后，还会涉及到的操作互斥的问题，即某些操作按照业务上的要求是不能并发进行的。这就涉及到了多个后端应用结点之间如何进行协同的问题。这个问题通常有下面几种解决思路：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>分布式锁，通过抢锁的机制，由拿到锁的应用结点来执行操作。分布式锁可以利用 db 的行级锁，zookeeper 或 etcd 等分布式协调系统，或者 tair 一类的分布式缓存来实现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分区模式，就是对整体任务进行分割，某个后端应用结点或某几个后端应用结点只负责处理一个分区的任务，这样应用结点之间的处理任务的操作就不会产生突出。这里面需要注意的两点就是, 如何分区的划分规则和应用结点所属分区变化引起的服务抖动；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="主控结点的冗余">主控结点的冗余&lt;/h2>
&lt;p>如果应用集群存在一些运行集群管理任务的主控结点，那么针对主控结点的单点问题，我们根据应用结点的部署类型可分别做如下冗余设计方案。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>独立部署模式，主控结点逻辑与任务处理逻辑不在同一应用结点内，是独立进行服务部署的，可以采用一主一备的模式进行冗余，备份服务监控主服务工作状态，在主服务出现故障时，可切换到备份服务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对等部署模式，应用集群中所有应用结点都是对等的，可以在应用集群中根据某种规则选出一台主服务器，只由主服务器来完成管理任务，如果主服务挂掉，可以采用同样的规则重新进行选主。选主的具体实现可参考 paxos 或 raft 的分布式共识机制；&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>租户隔离</title><link>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/%E7%A7%9F%E6%88%B7%E9%9A%94%E7%A6%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/ha-notes/03.%E5%AE%B9%E7%81%BE%E4%B8%8E%E9%9A%94%E7%A6%BB/%E7%A7%9F%E6%88%B7%E9%9A%94%E7%A6%BB/</guid><description>&lt;h1 id="租户隔离">租户隔离&lt;/h1>
&lt;p>租户的概念不止局限于集群的用户，它可以包含为一组计算，网络，存储等资源组成的工作负载集合。而在多租户集群中，需要在一个集群范围内（未来可能会是多集群）对不同的租户提供尽可能的安全隔离，以最大程度的避免恶意租户对其他租户的攻击，同时需要保证租户之间公平地分配共享集群资源。&lt;/p>
&lt;p>在隔离的安全程度上，我们可以将其分为软隔离(Soft Multi-tenancy)和硬隔离（Hard Multi-tenancy）两种。其中软隔离更多的是面向企业内部的多租需求，该形态下默认不存在恶意租户，隔离的目的是为了内部团队间的业务保护和对可能的安全攻击进行防护；而硬隔离面向的更多是对外提供服务的服务供应商，由于该业务形态下无法保证不同租户中业务使用者的安全背景，我们默认认为租户之间以及租户与 K8s 系统之间是存在互相攻击的可能，因此这里也需要更严格的隔离作为安全保障。&lt;/p></description></item></channel></rss>