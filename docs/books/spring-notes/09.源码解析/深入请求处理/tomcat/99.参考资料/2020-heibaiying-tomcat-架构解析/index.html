<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="Tomcat 架构解析 一、Tomcat 简介 Tomcat 是目前主流的基于 Java 语言的轻量级应用服务器，它是对是 Java Servlet，JavaServer Pages（JSP），Java Expression Language（EL 表达式）和 Java WebSocket 技术的开源实"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"><meta property="og:title" content="2020-heibaiying-Tomcat 架构解析 | Next-gen Tech Edu"><meta property="og:description" content="Tomcat 架构解析 一、Tomcat 简介 Tomcat 是目前主流的基于 Java 语言的轻量级应用服务器，它是对是 Java Servlet，JavaServer Pages（JSP），Java Expression Language（EL 表达式）和 Java WebSocket 技术的开源实"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>2020-heibaiying-Tomcat 架构解析 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=ce58bcd143603834755c88a5c2102ec3><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">99.参考资料</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id43c5bae508b099cdb5106d9160bf37b2")' href=#id43c5bae508b099cdb5106d9160bf37b2 aria-expanded=false aria-controls=id43c5bae508b099cdb5106d9160bf37b2 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/>Tomcat</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id43c5bae508b099cdb5106d9160bf37b2 aria-expanded=false aria-controls=id43c5bae508b099cdb5106d9160bf37b2><i class="fa-solid fa-angle-down" id=caret-id43c5bae508b099cdb5106d9160bf37b2></i></a></div><ul class="nav docs-sidenav collapse show" id=id43c5bae508b099cdb5106d9160bf37b2><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id527269c0e1cdae73e1722c56d9a7bc12")' href=#id527269c0e1cdae73e1722c56d9a7bc12 aria-expanded=false aria-controls=id527269c0e1cdae73e1722c56d9a7bc12 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>99.参考资料</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id527269c0e1cdae73e1722c56d9a7bc12 aria-expanded=false aria-controls=id527269c0e1cdae73e1722c56d9a7bc12><i class="fa-solid fa-angle-down" id=caret-id527269c0e1cdae73e1722c56d9a7bc12></i></a></div><ul class="nav docs-sidenav collapse show" id=id527269c0e1cdae73e1722c56d9a7bc12><li class="child level active"><a href=/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/>2020-heibaiying-Tomcat 架构解析</a></li></ul></div><li class="child level"><a href=/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/springboot-tomcat/>SpringBoot Tomcat</a></li></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#一tomcat-简介>一、Tomcat 简介</a></li><li><a href=#二tomcat-架构>二、Tomcat 架构</a></li><li><a href=#三连接器>三、连接器</a><ul><li><a href=#31-protocolhandler>3.1 ProtocolHandler</a></li><li><a href=#32-adapter>3.2 Adapter</a></li><li><a href=#33-mapper-和-mapperlistener>3.3 Mapper 和 MapperListener</a></li></ul></li><li><a href=#四容器>四、容器</a><ul><li><a href=#41-container-和-lifecycle>4.1 Container 和 Lifecycle</a></li><li><a href=#42-分层结构>4.2 分层结构</a></li><li><a href=#43-pipeline-和-valve>4.3 Pipeline 和 Valve</a></li><li><a href=#44-filterchain>4.4 FilterChain</a></li></ul></li><li><a href=#五请求流程>五、请求流程</a></li><li><a href=#六启动流程>六、启动流程</a><ul><li></li></ul></li><li><a href=#七类加载器>七、类加载器</a><ul><li></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>2020-heibaiying-Tomcat 架构解析</h1><div class=article-style><h1 id=tomcat-架构解析>Tomcat 架构解析</h1><h2 id=一tomcat-简介>一、Tomcat 简介</h2><p>Tomcat 是目前主流的基于 Java 语言的轻量级应用服务器，它是对是 Java Servlet，JavaServer Pages（JSP），Java Expression Language（EL 表达式）和 Java WebSocket 技术的开源实现。当前 Tomcat 共有四个版本：</p><ul><li><strong>Tomcat 7</strong>：支持 Servlet 3.0，JSP 2.2，EL 2.2 和 WebSocket 1.1 规范。</li><li><strong>Tomcat 8.5</strong>：支持 Servlet 3.1，JSP 2.3，EL 3.0 和 WebSocket 1.1 规范，并可以通过安装 Tomcat 原生库来支持 HTTP/2 。当前 Tomcat 8.5 已经完全取代了 Tomcat 8，Tomcat 8 已停止维护，并不再提供下载。</li><li><strong>Tomcat 9</strong>：是当前主要的发行版；它建立在 Tomcat 8.0.x 和 8.5.x 之上，并实现了 Servlet 4.0，JSP 2.3，EL 3.0，WebSocket 1.1 和 JASPIC 1.1 规范。</li><li><strong>Tomcat 10 (alpha)</strong> ：是当前主要的开发版；它实现了 Servlet 5.0，JSP 3.0，EL 4.0 和 WebSocket 2.0 规范。</li></ul><h2 id=二tomcat-架构>二、Tomcat 架构</h2><p>Tomcat 的整体架构如下：</p><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_架构.png></div><ul><li><strong>Server</strong>：表示整个 Servlet 容器，在整个 Tomcat 运行环境中只有唯一一个 Server 实例。一个 Server 包含多个 Service，每个 Service 互相独立，但共享一个 JVM 以及系统类库。</li><li><strong>Service</strong>：一个 Service 负责维护多个 Connector 和一个 Engine。其中 Connector 负责开启 Socket 并监听客户端请求，返回响应数据；Engine 负责具体的请求处理。</li><li><strong>Connector</strong>：连接器，用于监听并转换来自客户端 Socket 请求，然后将 Socket 请求交由 Container 处理，支持不同协议以及不同的 I/O 方式。</li><li><strong>Engine</strong>：表示整个 Servlet 引擎，在 Tomcat 中，Engine 为最高层级的容器对象。</li><li><strong>Host</strong>：表示 Engine 中的虚拟机，通常与一个服务器的网络名有关，如域名等。</li><li><strong>Context</strong>：表示 ServletContext ，在 Servlet 规范中，一个 ServletContext 即表示一个独立的 Web 应用。</li><li><strong>Wrapper</strong>：是对标准 Servlet 的封装。</li></ul><p>以上各组件的详细介绍如下：</p><h2 id=三连接器>三、连接器</h2><p>连接器的主要功能是将 Socket 的输入转换为 Request 对象，并交由容器进行处理；之后再将容器处理完成的 Response 对象写到输出流。连接器的内部组件如下：</p><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat连接器组件.png></div><h3 id=31-protocolhandler>3.1 ProtocolHandler</h3><p><strong>1. Endpoint</strong></p><p>EndPoint 会启动线程来监听服务器端口，并负责处理来自客户端的 Socket 请求，是对传输层的抽象。它支持以下 IO 方式：</p><ul><li><strong>BIO</strong>：即最传统的 I/O 方式；</li><li><strong>NIO</strong>：采用 Java NIO 类库进行实现，Tomcat 8 之后默认该 I/O 方式，以替换原来的 BIO；</li><li><strong>NIO2</strong>：采用 JDK 7 最新的 NIO2 类库进行实现；</li><li><strong>APR</strong>：采用 APR (Apache 可移植运行库) 实现，APR 是使用 C/C++ 编写的本地库，需要单独进行安装。</li></ul><p><strong>2. Processor</strong></p><p>负责构造 Request 和 Response 对象，并通过 Adapter 提交到容器进行处理，是对应用层的抽象。它支持以下应用层协议：</p><ul><li><strong>HTTP / 1.1 协议</strong>；</li><li><strong>HTTP / 2.0 协议</strong>：自 Tomcat 8.5 以及 9.0 版本后开始支持；</li><li><strong>AJP 协议</strong>：即定向包协议。</li></ul><p><strong>3. ProtocolHandler</strong></p><p>ProtocolHandler 通过组合不同类型的 Endpoint 和 Processor 来实现针对具体协议的处理功能。按照不同的协议（HTTP 和 AJP）和不同的 I/O 方式（NIO，NIO2，AJP）进行组合，其有以下六个具体的实现类：</p><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_AbstractProtocol.png></div><p><strong>4. 协议升级</strong></p><p>可以看到上面的 ProtocolHandler 只有对 HTTP 1.1 协议进行处理的实现类，并没有对 HTTP 2.0 进行处理的实现类，想要对 HTTP 2.0 进行处理，需要使用到协议升级：当 ProtocolHandler 收到的是一个 HTTP 2.0 请求时，它会根据请求创建一个用于升级处理的令牌 UpgradeToken，该令牌中包含了升级处理器 HttpUpgradeHandler（接口），对于 HTTP 2.0 而言，其实现类是 Http2UpgradeHandler。</p><h3 id=32-adapter>3.2 Adapter</h3><p>Tomcat 设计者希望连接器是一个单独的组件，能够脱离 Servlet 规范而独立存在，以便增加其使用场景，因此 Process 对输入流封装后得到的 Request 不是一个 Servlet Request，该 Request 的全限定命名为：org.apache.coyote.Request 。因此在这里需要使用适配器模式（具体实现类是 CoyoteAdapter）将其转换为 org.apache.catalina.connector.Request，它才是标准的 ServletRequest 的实现：</p><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_request.png></div><h3 id=33-mapper-和-mapperlistener>3.3 Mapper 和 MapperListener</h3><p>由 Socket 输入流构建好标准的 ServletRequest 后，连接器还需要知道将 Request 发往哪一个容器，这需要通过 Mapper 来实现。Mapper 维护了请求路径与容器之间的映射信息。在 Tomcat 7 及之前的版本中 Mapper 由连接器自身维护，在 Tomcat 8 之后的版本中，Mapper 由 Service 进行维护。</p><p>MapperListener 实现了 ContainerListener 和 LifecycleListener 接口，用于在容器组件状态发生变更时，注册或取消对应容器的映射关系，这么做主要是为了支持 Tomcat 的热部署功能。</p><h2 id=四容器>四、容器</h2><h3 id=41-container-和-lifecycle>4.1 Container 和 Lifecycle</h3><p>Tomcat 中的所有容器都实现了 Container 接口，它定义了容器共同的属性与方法，而 Container 接口则继承自 Lifecycle 接口。Tomcat 中的大多数组件都实现了 Lifecycle 接口，它定义了与组件生命周期相关的公共方法，如 <code>init()</code>，<code>start()</code>，<code>stop()</code>，<code>destroy()</code> :</p><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_container.png></div><h3 id=42-分层结构>4.2 分层结构</h3><p>Tomcat 之所以采用分层的结构，主要是为了更好的灵活性和可扩展性：</p><ul><li><strong>Engine</strong>：最顶层的容器，一个 Service 中只有一个 Engine；</li><li><strong>Host</strong>：代表一个虚拟主机，一个 Engine 可以包含多个虚拟主机；</li><li><strong>Context</strong>：表示一个具体的 Web 应用程序，一个虚拟主机可以包含多个 Context；</li><li><strong>Wrapper</strong>：是 Tomcat 对 Servlet 的包装，一个 Context 中可以有多个 Wrapper。</li></ul><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_分层结构.png></div><p>Tomcat 容器的分层结构在其 conf 目录下的 <code>server.xml</code> 配置文件中也有体现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;Server</span> <span class=na>port=</span><span class=s>&#34;8005&#34;</span> <span class=na>shutdown=</span><span class=s>&#34;SHUTDOWN&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;Service</span> <span class=na>name=</span><span class=s>&#34;Catalina&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Connector</span> <span class=na>port=</span><span class=s>&#34;8080&#34;</span> <span class=na>protocol=</span><span class=s>&#34;HTTP/1.1&#34;</span><span class=na>connectionTimeout=</span><span class=s>&#34;20000&#34;</span><span class=na>redirectPort=</span><span class=s>&#34;8443&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Engine</span> <span class=na>name=</span><span class=s>&#34;Catalina&#34;</span> <span class=na>defaultHost=</span><span class=s>&#34;localhost&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;Host</span> <span class=na>name=</span><span class=s>&#34;localhost&#34;</span>  <span class=na>appBase=</span><span class=s>&#34;webapps&#34;</span> <span class=na>unpackWARs=</span><span class=s>&#34;true&#34;</span> <span class=na>autoDeploy=</span><span class=s>&#34;true&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/Engine&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/Service&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/Server&gt;</span>
</span></span></code></pre></div><p>这里的 appBase 代表我们应用程序所在父目录，我们部署的每一个应用程序就是一个独立的 Context 。</p><h3 id=43-pipeline-和-valve>4.3 Pipeline 和 Valve</h3><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_多层容器.jpg></div><p>由连接器发过来的请求会最先发送到 Engine，最终逐层传递，直至我们编写的 Servlet，这种传递主要通过 Pipeline 和 Valve 来实现。每层容器都有自己的 Pipeline，Pipeline 相当于处理管道；每个 Pipeline 中有一个 Valve 链，每个 Valve 可以看做一个独立的处理单元，用于对请求进行处理。最基础的 Valve 叫做 Basic Valve，新增的 Valve 会位于已有的 Valve 之前。Pipeline 和 Valve 的接口定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Pipeline</span> <span class=kd>extends</span> <span class=n>Contained</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Valve</span> <span class=nf>getBasic</span><span class=o>();</span>           <span class=c1>// 获得Basic Valve
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setBasic</span><span class=o>(</span><span class=n>Valve</span> <span class=n>valve</span><span class=o>);</span> <span class=c1>// 设置Basic Valve
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>addValve</span><span class=o>(</span><span class=n>Valve</span> <span class=n>valve</span><span class=o>);</span> <span class=c1>// 新增Valve
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=n>Valve</span><span class=o>[]</span> <span class=nf>getValves</span><span class=o>();</span>        <span class=c1>// 获取所有Valve
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>removeValve</span><span class=o>(</span><span class=n>Valve</span> <span class=n>valve</span><span class=o>);</span><span class=c1>// 移除Valve
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=n>Valve</span> <span class=nf>getFirst</span><span class=o>();</span> <span class=c1>//获取第一个 Valve
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isAsyncSupported</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>findNonAsyncValves</span><span class=o>(</span><span class=n>Set</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>result</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Valve</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Valve</span> <span class=nf>getNext</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 每一个Valve都持有其下一个Valve,这是标准的责任链模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>setNext</span><span class=o>(</span><span class=n>Valve</span> <span class=n>valve</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 对请求进行检查、处理或增强
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>invoke</span><span class=o>(</span><span class=n>Request</span> <span class=n>request</span><span class=o>,</span> <span class=n>Response</span> <span class=n>response</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>IOException</span><span class=o>,</span> <span class=n>ServletException</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>backgroundProcess</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isAsyncSupported</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>通过 Pipeline 的 Valve 责任链模式，每一层容器都可以很方便地进行功能的扩展，来对请求进行检查、处理或增强。每一层处理完成后，就会传递到下一层的 First Valve，由下一层进行处理。以 Engine 容器为例，其实现类为 StandardEngine：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>StandardEngine</span> <span class=kd>extends</span> <span class=n>ContainerBase</span> <span class=kd>implements</span> <span class=n>Engine</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>StandardEngine</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>pipeline</span><span class=o>.</span><span class=na>setBasic</span><span class=o>(</span><span class=k>new</span> <span class=n>StandardEngineValve</span><span class=o>());</span>
</span></span><span class=line><span class=cl>         <span class=o>....</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>在 StandardEngine 创建时就会为其 Pipeline 设置上一个名为 StandardEngineValve 的 Basic Valve，StandardEngineValve 的实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=kd>class</span> <span class=nc>StandardEngineValve</span> <span class=kd>extends</span> <span class=n>ValveBase</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>StandardEngineValve</span><span class=o>()</span> <span class=o>{</span><span class=kd>super</span><span class=o>(</span><span class=kc>true</span><span class=o>);}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>final</span> <span class=kt>void</span> <span class=nf>invoke</span><span class=o>(</span><span class=n>Request</span> <span class=n>request</span><span class=o>,</span> <span class=n>Response</span> <span class=n>response</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>IOException</span><span class=o>,</span> <span class=n>ServletException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取当前请求的Host
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Host</span> <span class=n>host</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=na>getHost</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>host</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>request</span><span class=o>.</span><span class=na>isAsyncSupported</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>request</span><span class=o>.</span><span class=na>setAsyncSupported</span><span class=o>(</span><span class=n>host</span><span class=o>.</span><span class=na>getPipeline</span><span class=o>().</span><span class=na>isAsyncSupported</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 将请求传递给host的Pipeline的第一个Valve
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>host</span><span class=o>.</span><span class=na>getPipeline</span><span class=o>().</span><span class=na>getFirst</span><span class=o>().</span><span class=na>invoke</span><span class=o>(</span><span class=n>request</span><span class=o>,</span> <span class=n>response</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Engine 的 Basic Valve（即最后一个 Valve）在 <code>invoke</code> 方法中会获取到下一级容器（Host）的第一个 Valve，从而完成首尾相接。</p><h3 id=44-filterchain>4.4 FilterChain</h3><p>通过 Pipeline 和 Valve 的传递，请求最终会传递到最内层容器 Wrapper 的 Basic Valve，其实现类为 StandardWrapperValve 。StandardWrapperValve 会在 <code>invoke</code> 方法中为该请求创建 FilterChain，依次执行请求对应的过滤器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 为该请求创建Filter Chain
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ApplicationFilterChain</span> <span class=n>filterChain</span> <span class=o>=</span> <span class=n>ApplicationFilterFactory</span><span class=o>.</span><span class=na>createFilterChain</span><span class=o>(</span><span class=n>request</span><span class=o>,</span> <span class=n>wrapper</span><span class=o>,</span> <span class=n>servlet</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>.....</span>
</span></span><span class=line><span class=cl><span class=c1>// 调用Filter Chain的doFilter方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>filterChain</span><span class=o>.</span><span class=na>doFilter</span><span class=o>(</span><span class=n>request</span><span class=o>.</span><span class=na>getRequest</span><span class=o>(),</span> <span class=n>response</span><span class=o>.</span><span class=na>getResponse</span><span class=o>());</span>
</span></span></code></pre></div><p>当到达执行链的末端后，会执行 servlet 的 service 方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>servlet</span><span class=o>.</span><span class=na>service</span><span class=o>(</span><span class=n>request</span><span class=o>,</span> <span class=n>response</span><span class=o>);</span>
</span></span></code></pre></div><p>以我们最常使用的 HttpServlet 为例，其最终的 service 方法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>protected void service<span class=o>(</span>HttpServletRequest req, HttpServletResponse resp<span class=o>)</span> throws ServletException, IOException <span class=o>{</span>
</span></span><span class=line><span class=cl>        String <span class=nv>method</span> <span class=o>=</span> req.getMethod<span class=o>()</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span>method.equals<span class=o>(</span>METHOD_GET<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            long <span class=nv>lastModified</span> <span class=o>=</span> getLastModified<span class=o>(</span>req<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=nv>lastModified</span> <span class=o>==</span> -1<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                .....
</span></span><span class=line><span class=cl>                doGet<span class=o>(</span>req, resp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>               ......
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span>method.equals<span class=o>(</span>METHOD_HEAD<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            long <span class=nv>lastModified</span> <span class=o>=</span> getLastModified<span class=o>(</span>req<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            maybeSetLastModified<span class=o>(</span>resp, lastModified<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            doHead<span class=o>(</span>req, resp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span>method.equals<span class=o>(</span>METHOD_POST<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            doPost<span class=o>(</span>req, resp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span>method.equals<span class=o>(</span>METHOD_PUT<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            doPut<span class=o>(</span>req, resp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span>method.equals<span class=o>(</span>METHOD_DELETE<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            doDelete<span class=o>(</span>req, resp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span>method.equals<span class=o>(</span>METHOD_OPTIONS<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            doOptions<span class=o>(</span>req,resp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span>method.equals<span class=o>(</span>METHOD_TRACE<span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            doTrace<span class=o>(</span>req,resp<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>}</span> ......
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>至此，来自客户端的请求就逐步传递到我们编写的 doGet 或者 doPost 方法中。</p><h2 id=五请求流程>五、请求流程</h2><p>这里对前面的连接器和容器章节进行总结，Tomcat 对客户端请求的完整处理流程如下：</p><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat启动请求处理流程.jpg></div><h2 id=六启动流程>六、启动流程</h2><p>Tomcat 整体的启动流程如下图所示：</p><div align=center><img src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat启动流程.png></div><h4 id=1-startupsh--catalinash>1. startup.sh & catalina.sh</h4><p><code>startup.sh</code> 是对 <code>catalina.sh</code> 的一层薄封装，主要用于检查 <code>catalina.sh</code> 是否存在以及调用它。 <code>catalina.sh</code> 负责启动一个 JVM 来运行 Tomcat 的启动类 Bootstrap 。</p><h4 id=2-bootstrap>2. Bootstrap</h4><p>Bootstrap 独立于 Tomcat 结构之外，它以 JAR 包的形式存在于 <code>bin</code> 目录下，主要负责初始化 Tomcat 的类加载器，并通过反射来创建 Catalina。</p><h4 id=3-catalina>3. Catalina</h4><p>Catalina 通过 Digester 解析 server.xml 来创建所有的服务组件。Digester 是一款能将 XML 转换为 Java 对象的事件驱动型工具，简而言之，它通过流读取 XML 文件，当识别出特定 XML 节点后，就会创建对应的组件。</p><h2 id=七类加载器>七、类加载器</h2><p>Tomcat 并没有完全沿用 JVM 默认的类加载机制，为了保证 Web 应用之间的隔离性和加载的灵活性，其采用了下图所示的类加载机制：</p><div align=center><img width=600px src=https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_类加载器.jpg></div><h4 id=1-web-app-class-loader>1. Web App Class Loader</h4><p>负责加载 <code>/WEB-INF/classes</code> 目录下的未压缩的 Class 和资源文件，以及 <code>/WEB-INF/lib</code> 目录下的 Jar 包。它只对当前的 Web 应用可见，对其它 Web 应用均不可见，因此它可以保证 Web 应用之间的彼此隔离。</p><h4 id=2-shared-class-loader>2. Shared Class Loader</h4><p>是所有 Web 应用的父类加载器，它负责加载 Web 应用之间共享的类，从而避免资源的重复加载。</p><h4 id=3-catalina-class-loader>3. Catalina Class Loader</h4><p>用于加载 Tomcat 应用服务器的类加载器，从而保证 Tomcat 与 Web 应用程序之间的隔离。</p><h4 id=4-common-class-loader>4. Common Class Loader</h4><p>其作用和 Shared Class Loader 类似，当 Tomcat 与 Web 应用程序之间存在共同依赖时，可以使用其进行加载。再往上，流程就与 JVM 类加载的流程一致了。</p><h2 id=参考资料>参考资料</h2><ul><li>刘光瑞 . Tomcat 架构解析 . 人民邮电出版社 . 2017-05</li></ul></div><div class=article-widget><div class="container-xl row post-nav"></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div><script type=text/javascript id=clstr_globe async src="//clustrmaps.com/globe.js?d=kgpJG5sWZQpKujBmD-uW1B54-WBPol-DuDtrB2KFjKs"></script></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>