<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>99.参考资料 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link><atom:link href="https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml"/><description>99.参考资料</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>99.参考资料</title><link>https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link></image><item><title>2020-heibaiying-Tomcat 架构解析</title><link>https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/spring-notes/09.%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/tomcat/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-heibaiying-tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</guid><description>&lt;h1 id="tomcat-架构解析">Tomcat 架构解析&lt;/h1>
&lt;h2 id="一tomcat-简介">一、Tomcat 简介&lt;/h2>
&lt;p>Tomcat 是目前主流的基于 Java 语言的轻量级应用服务器，它是对是 Java Servlet，JavaServer Pages（JSP），Java Expression Language（EL 表达式）和 Java WebSocket 技术的开源实现。当前 Tomcat 共有四个版本：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Tomcat 7&lt;/strong>：支持 Servlet 3.0，JSP 2.2，EL 2.2 和 WebSocket 1.1 规范。&lt;/li>
&lt;li>&lt;strong>Tomcat 8.5&lt;/strong>：支持 Servlet 3.1，JSP 2.3，EL 3.0 和 WebSocket 1.1 规范，并可以通过安装 Tomcat 原生库来支持 HTTP/2 。当前 Tomcat 8.5 已经完全取代了 Tomcat 8，Tomcat 8 已停止维护，并不再提供下载。&lt;/li>
&lt;li>&lt;strong>Tomcat 9&lt;/strong>：是当前主要的发行版；它建立在 Tomcat 8.0.x 和 8.5.x 之上，并实现了 Servlet 4.0，JSP 2.3，EL 3.0，WebSocket 1.1 和 JASPIC 1.1 规范。&lt;/li>
&lt;li>&lt;strong>Tomcat 10 (alpha)&lt;/strong> ：是当前主要的开发版；它实现了 Servlet 5.0，JSP 3.0，EL 4.0 和 WebSocket 2.0 规范。&lt;/li>
&lt;/ul>
&lt;h2 id="二tomcat-架构">二、Tomcat 架构&lt;/h2>
&lt;p>Tomcat 的整体架构如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_架构.png"/> &lt;/div>
&lt;ul>
&lt;li>&lt;strong>Server&lt;/strong>：表示整个 Servlet 容器，在整个 Tomcat 运行环境中只有唯一一个 Server 实例。一个 Server 包含多个 Service，每个 Service 互相独立，但共享一个 JVM 以及系统类库。&lt;/li>
&lt;li>&lt;strong>Service&lt;/strong>：一个 Service 负责维护多个 Connector 和一个 Engine。其中 Connector 负责开启 Socket 并监听客户端请求，返回响应数据；Engine 负责具体的请求处理。&lt;/li>
&lt;li>&lt;strong>Connector&lt;/strong>：连接器，用于监听并转换来自客户端 Socket 请求，然后将 Socket 请求交由 Container 处理，支持不同协议以及不同的 I/O 方式。&lt;/li>
&lt;li>&lt;strong>Engine&lt;/strong>：表示整个 Servlet 引擎，在 Tomcat 中，Engine 为最高层级的容器对象。&lt;/li>
&lt;li>&lt;strong>Host&lt;/strong>：表示 Engine 中的虚拟机，通常与一个服务器的网络名有关，如域名等。&lt;/li>
&lt;li>&lt;strong>Context&lt;/strong>：表示 ServletContext ，在 Servlet 规范中，一个 ServletContext 即表示一个独立的 Web 应用。&lt;/li>
&lt;li>&lt;strong>Wrapper&lt;/strong>：是对标准 Servlet 的封装。&lt;/li>
&lt;/ul>
&lt;p>以上各组件的详细介绍如下：&lt;/p>
&lt;h2 id="三连接器">三、连接器&lt;/h2>
&lt;p>连接器的主要功能是将 Socket 的输入转换为 Request 对象，并交由容器进行处理；之后再将容器处理完成的 Response 对象写到输出流。连接器的内部组件如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat连接器组件.png"/> &lt;/div>
&lt;h3 id="31-protocolhandler">3.1 ProtocolHandler&lt;/h3>
&lt;p>&lt;strong>1. Endpoint&lt;/strong>&lt;/p>
&lt;p>EndPoint 会启动线程来监听服务器端口，并负责处理来自客户端的 Socket 请求，是对传输层的抽象。它支持以下 IO 方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>BIO&lt;/strong>：即最传统的 I/O 方式；&lt;/li>
&lt;li>&lt;strong>NIO&lt;/strong>：采用 Java NIO 类库进行实现，Tomcat 8 之后默认该 I/O 方式，以替换原来的 BIO；&lt;/li>
&lt;li>&lt;strong>NIO2&lt;/strong>：采用 JDK 7 最新的 NIO2 类库进行实现；&lt;/li>
&lt;li>&lt;strong>APR&lt;/strong>：采用 APR (Apache 可移植运行库) 实现，APR 是使用 C/C++ 编写的本地库，需要单独进行安装。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. Processor&lt;/strong>&lt;/p>
&lt;p>负责构造 Request 和 Response 对象，并通过 Adapter 提交到容器进行处理，是对应用层的抽象。它支持以下应用层协议：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HTTP / 1.1 协议&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>HTTP / 2.0 协议&lt;/strong>：自 Tomcat 8.5 以及 9.0 版本后开始支持；&lt;/li>
&lt;li>&lt;strong>AJP 协议&lt;/strong>：即定向包协议。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>3. ProtocolHandler&lt;/strong>&lt;/p>
&lt;p>ProtocolHandler 通过组合不同类型的 Endpoint 和 Processor 来实现针对具体协议的处理功能。按照不同的协议（HTTP 和 AJP）和不同的 I/O 方式（NIO，NIO2，AJP）进行组合，其有以下六个具体的实现类：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_AbstractProtocol.png"/> &lt;/div>
&lt;p>&lt;strong>4. 协议升级&lt;/strong>&lt;/p>
&lt;p>可以看到上面的 ProtocolHandler 只有对 HTTP 1.1 协议进行处理的实现类，并没有对 HTTP 2.0 进行处理的实现类，想要对 HTTP 2.0 进行处理，需要使用到协议升级：当 ProtocolHandler 收到的是一个 HTTP 2.0 请求时，它会根据请求创建一个用于升级处理的令牌 UpgradeToken，该令牌中包含了升级处理器 HttpUpgradeHandler（接口），对于 HTTP 2.0 而言，其实现类是 Http2UpgradeHandler。&lt;/p>
&lt;h3 id="32-adapter">3.2 Adapter&lt;/h3>
&lt;p>Tomcat 设计者希望连接器是一个单独的组件，能够脱离 Servlet 规范而独立存在，以便增加其使用场景，因此 Process 对输入流封装后得到的 Request 不是一个 Servlet Request，该 Request 的全限定命名为：org.apache.coyote.Request 。因此在这里需要使用适配器模式（具体实现类是 CoyoteAdapter）将其转换为 org.apache.catalina.connector.Request，它才是标准的 ServletRequest 的实现：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_request.png"/> &lt;/div>
&lt;h3 id="33-mapper-和-mapperlistener">3.3 Mapper 和 MapperListener&lt;/h3>
&lt;p>由 Socket 输入流构建好标准的 ServletRequest 后，连接器还需要知道将 Request 发往哪一个容器，这需要通过 Mapper 来实现。Mapper 维护了请求路径与容器之间的映射信息。在 Tomcat 7 及之前的版本中 Mapper 由连接器自身维护，在 Tomcat 8 之后的版本中，Mapper 由 Service 进行维护。&lt;/p>
&lt;p>MapperListener 实现了 ContainerListener 和 LifecycleListener 接口，用于在容器组件状态发生变更时，注册或取消对应容器的映射关系，这么做主要是为了支持 Tomcat 的热部署功能。&lt;/p>
&lt;h2 id="四容器">四、容器&lt;/h2>
&lt;h3 id="41-container-和-lifecycle">4.1 Container 和 Lifecycle&lt;/h3>
&lt;p>Tomcat 中的所有容器都实现了 Container 接口，它定义了容器共同的属性与方法，而 Container 接口则继承自 Lifecycle 接口。Tomcat 中的大多数组件都实现了 Lifecycle 接口，它定义了与组件生命周期相关的公共方法，如 &lt;code>init()&lt;/code>，&lt;code>start()&lt;/code>，&lt;code>stop()&lt;/code>，&lt;code>destroy()&lt;/code> :&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_container.png"/> &lt;/div>
&lt;h3 id="42-分层结构">4.2 分层结构&lt;/h3>
&lt;p>Tomcat 之所以采用分层的结构，主要是为了更好的灵活性和可扩展性：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Engine&lt;/strong>：最顶层的容器，一个 Service 中只有一个 Engine；&lt;/li>
&lt;li>&lt;strong>Host&lt;/strong>：代表一个虚拟主机，一个 Engine 可以包含多个虚拟主机；&lt;/li>
&lt;li>&lt;strong>Context&lt;/strong>：表示一个具体的 Web 应用程序，一个虚拟主机可以包含多个 Context；&lt;/li>
&lt;li>&lt;strong>Wrapper&lt;/strong>：是 Tomcat 对 Servlet 的包装，一个 Context 中可以有多个 Wrapper。&lt;/li>
&lt;/ul>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_分层结构.png"/> &lt;/div>
&lt;p>Tomcat 容器的分层结构在其 conf 目录下的 &lt;code>server.xml&lt;/code> 配置文件中也有体现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;Server&lt;/span> &lt;span class="na">port=&lt;/span>&lt;span class="s">&amp;#34;8005&amp;#34;&lt;/span> &lt;span class="na">shutdown=&lt;/span>&lt;span class="s">&amp;#34;SHUTDOWN&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Service&lt;/span> &lt;span class="na">name=&lt;/span>&lt;span class="s">&amp;#34;Catalina&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Connector&lt;/span> &lt;span class="na">port=&lt;/span>&lt;span class="s">&amp;#34;8080&amp;#34;&lt;/span> &lt;span class="na">protocol=&lt;/span>&lt;span class="s">&amp;#34;HTTP/1.1&amp;#34;&lt;/span>&lt;span class="na">connectionTimeout=&lt;/span>&lt;span class="s">&amp;#34;20000&amp;#34;&lt;/span>&lt;span class="na">redirectPort=&lt;/span>&lt;span class="s">&amp;#34;8443&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Engine&lt;/span> &lt;span class="na">name=&lt;/span>&lt;span class="s">&amp;#34;Catalina&amp;#34;&lt;/span> &lt;span class="na">defaultHost=&lt;/span>&lt;span class="s">&amp;#34;localhost&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Host&lt;/span> &lt;span class="na">name=&lt;/span>&lt;span class="s">&amp;#34;localhost&amp;#34;&lt;/span> &lt;span class="na">appBase=&lt;/span>&lt;span class="s">&amp;#34;webapps&amp;#34;&lt;/span> &lt;span class="na">unpackWARs=&lt;/span>&lt;span class="s">&amp;#34;true&amp;#34;&lt;/span> &lt;span class="na">autoDeploy=&lt;/span>&lt;span class="s">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Engine&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Service&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/Server&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 appBase 代表我们应用程序所在父目录，我们部署的每一个应用程序就是一个独立的 Context 。&lt;/p>
&lt;h3 id="43-pipeline-和-valve">4.3 Pipeline 和 Valve&lt;/h3>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_多层容器.jpg"/> &lt;/div>
&lt;p>由连接器发过来的请求会最先发送到 Engine，最终逐层传递，直至我们编写的 Servlet，这种传递主要通过 Pipeline 和 Valve 来实现。每层容器都有自己的 Pipeline，Pipeline 相当于处理管道；每个 Pipeline 中有一个 Valve 链，每个 Valve 可以看做一个独立的处理单元，用于对请求进行处理。最基础的 Valve 叫做 Basic Valve，新增的 Valve 会位于已有的 Valve 之前。Pipeline 和 Valve 的接口定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">Pipeline&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Contained&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">Valve&lt;/span> &lt;span class="nf">getBasic&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">// 获得Basic Valve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setBasic&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Valve&lt;/span> &lt;span class="n">valve&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 设置Basic Valve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">addValve&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Valve&lt;/span> &lt;span class="n">valve&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 新增Valve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">Valve&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="nf">getValves&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">// 获取所有Valve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">removeValve&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Valve&lt;/span> &lt;span class="n">valve&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">// 移除Valve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">Valve&lt;/span> &lt;span class="nf">getFirst&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="c1">//获取第一个 Valve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isAsyncSupported&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">findNonAsyncValves&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Set&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">Valve&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">Valve&lt;/span> &lt;span class="nf">getNext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每一个Valve都持有其下一个Valve,这是标准的责任链模式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Valve&lt;/span> &lt;span class="n">valve&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 对请求进行检查、处理或增强
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">invoke&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Request&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ServletException&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">backgroundProcess&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isAsyncSupported&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 Pipeline 的 Valve 责任链模式，每一层容器都可以很方便地进行功能的扩展，来对请求进行检查、处理或增强。每一层处理完成后，就会传递到下一层的 First Valve，由下一层进行处理。以 Engine 容器为例，其实现类为 StandardEngine：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">StandardEngine&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">ContainerBase&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Engine&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">StandardEngine&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">super&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pipeline&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setBasic&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">StandardEngineValve&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 StandardEngine 创建时就会为其 Pipeline 设置上一个名为 StandardEngineValve 的 Basic Valve，StandardEngineValve 的实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">final&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">StandardEngineValve&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">ValveBase&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">StandardEngineValve&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">invoke&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Request&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Response&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ServletException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 获取当前请求的Host
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Host&lt;/span> &lt;span class="n">host&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getHost&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">host&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isAsyncSupported&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setAsyncSupported&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">host&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPipeline&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">isAsyncSupported&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将请求传递给host的Pipeline的第一个Valve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">host&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getPipeline&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getFirst&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Engine 的 Basic Valve（即最后一个 Valve）在 &lt;code>invoke&lt;/code> 方法中会获取到下一级容器（Host）的第一个 Valve，从而完成首尾相接。&lt;/p>
&lt;h3 id="44-filterchain">4.4 FilterChain&lt;/h3>
&lt;p>通过 Pipeline 和 Valve 的传递，请求最终会传递到最内层容器 Wrapper 的 Basic Valve，其实现类为 StandardWrapperValve 。StandardWrapperValve 会在 &lt;code>invoke&lt;/code> 方法中为该请求创建 FilterChain，依次执行请求对应的过滤器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 为该请求创建Filter Chain
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">ApplicationFilterChain&lt;/span> &lt;span class="n">filterChain&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ApplicationFilterFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">createFilterChain&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">wrapper&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">servlet&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">.....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 调用Filter Chain的doFilter方法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">filterChain&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">doFilter&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRequest&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getResponse&lt;/span>&lt;span class="o">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当到达执行链的末端后，会执行 servlet 的 service 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">servlet&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">service&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">response&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以我们最常使用的 HttpServlet 为例，其最终的 service 方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">protected void service&lt;span class="o">(&lt;/span>HttpServletRequest req, HttpServletResponse resp&lt;span class="o">)&lt;/span> throws ServletException, IOException &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> String &lt;span class="nv">method&lt;/span> &lt;span class="o">=&lt;/span> req.getMethod&lt;span class="o">()&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>method.equals&lt;span class="o">(&lt;/span>METHOD_GET&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> long &lt;span class="nv">lastModified&lt;/span> &lt;span class="o">=&lt;/span> getLastModified&lt;span class="o">(&lt;/span>req&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nv">lastModified&lt;/span> &lt;span class="o">==&lt;/span> -1&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> .....
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doGet&lt;span class="o">(&lt;/span>req, resp&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ......
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>method.equals&lt;span class="o">(&lt;/span>METHOD_HEAD&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> long &lt;span class="nv">lastModified&lt;/span> &lt;span class="o">=&lt;/span> getLastModified&lt;span class="o">(&lt;/span>req&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> maybeSetLastModified&lt;span class="o">(&lt;/span>resp, lastModified&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doHead&lt;span class="o">(&lt;/span>req, resp&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>method.equals&lt;span class="o">(&lt;/span>METHOD_POST&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doPost&lt;span class="o">(&lt;/span>req, resp&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>method.equals&lt;span class="o">(&lt;/span>METHOD_PUT&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doPut&lt;span class="o">(&lt;/span>req, resp&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>method.equals&lt;span class="o">(&lt;/span>METHOD_DELETE&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doDelete&lt;span class="o">(&lt;/span>req, resp&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>method.equals&lt;span class="o">(&lt;/span>METHOD_OPTIONS&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doOptions&lt;span class="o">(&lt;/span>req,resp&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>method.equals&lt;span class="o">(&lt;/span>METHOD_TRACE&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doTrace&lt;span class="o">(&lt;/span>req,resp&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span> ......
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此，来自客户端的请求就逐步传递到我们编写的 doGet 或者 doPost 方法中。&lt;/p>
&lt;h2 id="五请求流程">五、请求流程&lt;/h2>
&lt;p>这里对前面的连接器和容器章节进行总结，Tomcat 对客户端请求的完整处理流程如下：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat启动请求处理流程.jpg"/> &lt;/div>
&lt;h2 id="六启动流程">六、启动流程&lt;/h2>
&lt;p>Tomcat 整体的启动流程如下图所示：&lt;/p>
&lt;div align="center"> &lt;img src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat启动流程.png"/> &lt;/div>
&lt;h4 id="1-startupsh--catalinash">1. startup.sh &amp;amp; catalina.sh&lt;/h4>
&lt;p>&lt;code>startup.sh&lt;/code> 是对 &lt;code>catalina.sh&lt;/code> 的一层薄封装，主要用于检查 &lt;code>catalina.sh&lt;/code> 是否存在以及调用它。 &lt;code>catalina.sh&lt;/code> 负责启动一个 JVM 来运行 Tomcat 的启动类 Bootstrap 。&lt;/p>
&lt;h4 id="2-bootstrap">2. Bootstrap&lt;/h4>
&lt;p>Bootstrap 独立于 Tomcat 结构之外，它以 JAR 包的形式存在于 &lt;code>bin&lt;/code> 目录下，主要负责初始化 Tomcat 的类加载器，并通过反射来创建 Catalina。&lt;/p>
&lt;h4 id="3-catalina">3. Catalina&lt;/h4>
&lt;p>Catalina 通过 Digester 解析 server.xml 来创建所有的服务组件。Digester 是一款能将 XML 转换为 Java 对象的事件驱动型工具，简而言之，它通过流读取 XML 文件，当识别出特定 XML 节点后，就会创建对应的组件。&lt;/p>
&lt;h2 id="七类加载器">七、类加载器&lt;/h2>
&lt;p>Tomcat 并没有完全沿用 JVM 默认的类加载机制，为了保证 Web 应用之间的隔离性和加载的灵活性，其采用了下图所示的类加载机制：&lt;/p>
&lt;div align="center"> &lt;img width="600px" src="https://gitee.com/heibaiying/Full-Stack-Notes/raw/master/pictures/tomcat_类加载器.jpg"/> &lt;/div>
&lt;h4 id="1-web-app-class-loader">1. Web App Class Loader&lt;/h4>
&lt;p>负责加载 &lt;code>/WEB-INF/classes&lt;/code> 目录下的未压缩的 Class 和资源文件，以及 &lt;code>/WEB-INF/lib&lt;/code> 目录下的 Jar 包。它只对当前的 Web 应用可见，对其它 Web 应用均不可见，因此它可以保证 Web 应用之间的彼此隔离。&lt;/p>
&lt;h4 id="2-shared-class-loader">2. Shared Class Loader&lt;/h4>
&lt;p>是所有 Web 应用的父类加载器，它负责加载 Web 应用之间共享的类，从而避免资源的重复加载。&lt;/p>
&lt;h4 id="3-catalina-class-loader">3. Catalina Class Loader&lt;/h4>
&lt;p>用于加载 Tomcat 应用服务器的类加载器，从而保证 Tomcat 与 Web 应用程序之间的隔离。&lt;/p>
&lt;h4 id="4-common-class-loader">4. Common Class Loader&lt;/h4>
&lt;p>其作用和 Shared Class Loader 类似，当 Tomcat 与 Web 应用程序之间存在共同依赖时，可以使用其进行加载。再往上，流程就与 JVM 类加载的流程一致了。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>刘光瑞 . Tomcat 架构解析 . 人民邮电出版社 . 2017-05&lt;/li>
&lt;/ul></description></item></channel></rss>