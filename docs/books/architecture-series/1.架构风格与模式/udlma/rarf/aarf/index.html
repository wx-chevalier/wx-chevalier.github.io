<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="Introduction AARF 的全称为 Asynchronous Abstract Resource Flow，是属于对于 REST 架构风格的扩充与完善；AARF 是适用于现代复杂多变的业务模型，同时支持异步编程与分布式扩展的架构风格，Inspired By REST,Flux And Functional Reactive Programming。。AAR"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/aarf/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/aarf/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/aarf/"><meta property="og:title" content="AARF | Next-gen Tech Edu"><meta property="og:description" content="Introduction AARF 的全称为 Asynchronous Abstract Resource Flow，是属于对于 REST 架构风格的扩充与完善；AARF 是适用于现代复杂多变的业务模型，同时支持异步编程与分布式扩展的架构风格，Inspired By REST,Flux And Functional Reactive Programming。。AAR"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>AARF | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=8c0e6118961089a97dd3effe04318c0d><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">RARF</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id3d63a85b28f6a2de420e80b840487b5d")' href=#id3d63a85b28f6a2de420e80b840487b5d aria-expanded=false aria-controls=id3d63a85b28f6a2de420e80b840487b5d aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/>UDLMA</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id3d63a85b28f6a2de420e80b840487b5d aria-expanded=false aria-controls=id3d63a85b28f6a2de420e80b840487b5d><i class="fa-solid fa-angle-down" id=caret-id3d63a85b28f6a2de420e80b840487b5d></i></a></div><ul class="nav docs-sidenav collapse show" id=id3d63a85b28f6a2de420e80b840487b5d><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id067e560cb9269ce7298fea72a66ee7a7")' href=#id067e560cb9269ce7298fea72a66ee7a7 aria-expanded=false aria-controls=id067e560cb9269ce7298fea72a66ee7a7 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/>RARF</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id067e560cb9269ce7298fea72a66ee7a7 aria-expanded=false aria-controls=id067e560cb9269ce7298fea72a66ee7a7><i class="fa-solid fa-angle-down" id=caret-id067e560cb9269ce7298fea72a66ee7a7></i></a></div><ul class="nav docs-sidenav collapse show" id=id067e560cb9269ce7298fea72a66ee7a7><li class="child level active"><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/aarf/>AARF</a></li><li class="child level"><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/aarf.en/>AARF.en</a></li><li class="child level"><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/rarf/>RARF</a></li><li class="child level"><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/rarf.en/>RARF.en</a></li><li class="child level"><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/%E7%B1%BB-redux-%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87/>类 Redux 的代码组织</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id93be66192e00927b90e5f2f511e9fb08")' href=#id93be66192e00927b90e5f2f511e9fb08 aria-expanded=false aria-controls=id93be66192e00927b90e5f2f511e9fb08 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/%E6%89%A9%E5%B1%95/>扩展</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id93be66192e00927b90e5f2f511e9fb08 aria-expanded=false aria-controls=id93be66192e00927b90e5f2f511e9fb08><i class="fa-solid fa-angle-right" id=caret-id93be66192e00927b90e5f2f511e9fb08></i></a></div><ul class="nav docs-sidenav collapse" id=id93be66192e00927b90e5f2f511e9fb08><li class="child level"><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/%E6%89%A9%E5%B1%95/%E5%8F%8D%E5%BA%94%E5%BC%8F/>反应式</a></li><li class="child level"><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/%E6%89%A9%E5%B1%95/%E6%89%A9%E5%B1%95%E7%82%B9/>扩展点</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#why-aarf为什么是-aarf>Why AARF?(为什么是 AARF)</a><ul><li><a href=#microservices微服务>MicroServices(微服务)</a></li></ul></li><li><a href=#rest--software-architecture-style>REST & Software Architecture Style</a></li><li><a href=#flux--redux>Flux & Redux</a></li><li><a href=#reactive-programming--actor>Reactive Programming & Actor</a></li><li><a href=#whats-aarf什么是-aarf>What&rsquo;s AARF?(什么是 AARF)</a><ul><li><a href=#twelve-factors--cloud-native-principles>Twelve-Factors & Cloud Native Principles</a></li><li><a href=#aarf-principles>AARF Principles</a></li><li><a href=#modifiabilityundefined><a href=undefined>Modifiability</a></a></li><li><a href=#visibilityundefined><a href=undefined>Visibility</a></a></li></ul></li><li><a href=#case-model案例模型>Case Model(案例模型)</a></li></ul><ul><li><a href=#abstract-resource>Abstract Resource</a></li><li><a href=#attribute资源属性>Attribute(资源属性)</a></li><li><a href=#entity>Entity</a></li><li><a href=#model>Model</a><ul><li></li></ul></li></ul><ul><li><a href=#uniform-resource-flow-path统一资源流动路径>Uniform Resource Flow Path(统一资源流动路径)</a><ul><li><a href=#resource-quantifier资源量词>Resource Quantifier(资源量词)</a></li></ul></li><li><a href=#resourcebag资源包>ResourceBag(资源包)</a><ul><li><a href=#immutable-object不可变对象>Immutable Object(不可变对象)</a></li></ul></li><li><a href=#advanced-request>Advanced Request</a><ul><li><a href=#resource-filter>Resource Filter</a></li><li><a href=#resource-integration资源注入>Resource Integration(资源注入)</a></li><li><a href=#mapreduce-for-multiple-request-once单次多请求处理>MapReduce For Multiple Request Once(单次多请求处理)</a></li></ul></li><li><a href=#non-resourceful-response非资源化响应>Non-Resourceful Response(非资源化响应)</a><ul><li><a href=#code-and-http-status响应码与-http-状态>Code And HTTP Status(响应码与 HTTP 状态)</a></li><li><a href=#empty-resource-is-error空资源即为错误>Empty Resource Is Error(空资源即为错误)</a></li></ul></li></ul><ul><li><a href=#dispatcher>Dispatcher</a></li><li><a href=#get>Get</a><ul><li><a href=#setresult>SetResult</a></li></ul></li><li><a href=#post>Post</a></li><li><a href=#update>Update</a></li><li><a href=#delete>Delete</a></li></ul><ul><li><a href=#authority-control权限控制>Authority Control(权限控制)</a><ul><li><a href=#jwt-based-user-authentic用户认证>JWT Based User Authentic(用户认证)</a></li><li><a href=#基于-sql-级别的控制>基于 SQL 级别的控制</a></li></ul></li><li><a href=#data-verification数据验证>Data Verification(数据验证)</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>AARF</h1><div class=article-style><h1 id=introduction>Introduction</h1><p>AARF 的全称为 Asynchronous Abstract Resource Flow，是属于对于 REST 架构风格的扩充与完善；AARF 是适用于现代复杂多变的业务模型，同时支持异步编程与分布式扩展的架构风格，Inspired By REST,Flux And Functional Reactive Programming。。AARF 提出了完全面向资源的请求处理、逻辑分层(Layer System)以及全局统一的命名规范。AARF 的核心理念来源于笔者多年的前后端综合实践，不过笔者也不能确定这一套想法是否具有真的实践意义与价值，还是仅仅只是沉渣泛起抑或是简单的脑残。</p><p>AARF 不仅仅是一套具体实现方式，更重要的是一种架构风格的设计理念，它可以灵活的运用于包括 Java、PHP、NodeJS、Go 乃至于 Swift、Rust 这样的新兴服务端编程语言上。笔者也会不断地完善更新，也欢迎大家提出自己的宝贵意见。AARF 在设计理念上很类似于现在流行的微服务模式(MicroService Pattern)，笔者会在一个单独的章节进行对比。不过概而论之，微服务是从功能的角度，以原子服务组合的方式构建大型复杂长期运行的应用程序。而 AARF 是从业务逻辑的角度，以抽象资源的原子处理进行组合的方式构建灵活可变稳定的应用程序。</p><p>MVC 是。笔者没有经历过大量的大型项目，大部分经历的是中小型需要快速迭代乃至于整个需求全部推翻重来的项目。在实战过程中，深刻感受到目前 MVC 粗粒度下。很多的看上去很傻逼的错误，我们可能寄希望于程序员开发时候的标准的规范。简单来说，我们可能在 MySQL 中存放一条 JSON 字符串，在返回给前端时需要先进行 JSON 解码转化为 JSONArray 再和其他属性统一编码。这个问题看上去只需要规定程序猿在每个需要返回该属性的接口处进行编码即可，不过事实证明很多莫名奇妙的错误就是来自于这里。当然，通过数据模型或者统一的返回校验，譬如 JSON Schema 校验，我们肯定可以避免这个问题。上文提及的两个小例子，说明我们需要一个灵活但是有一定规范约束，这个规范约束应该像 REST 一样简单易懂并且容易实行。</p><p>MVC 架构的 Layer System 是在 Controller、Model、Service 这样进行分层，而 AARF 是纵向切分。在 Controller 层，或者是请求映射层，AARF 并不是将每个请求映射到一个专门的处理函数。而在 Model 层，AARF 也不建议按照每一个具体的业务逻辑编写 SQL 语句并向上提供，这样确实可以提供查询的效率，但是一旦业务需求发生变化之后，会出现大量的冗余的 SQL 语句以及对应的冗余代码。你会觉得自己的代码一团糟，就好像埋着无数的地雷。</p><p>为了方便理解，我们也可以借用函数柯里化与反柯里化的概念。我们提供一系列适用范围广，但是适用性较低的接口来代替原先适用性较高，但是适用范围极低的接口。而柯里化的这一步即交由前端来完成，也就是下文中会提及的 URFP 的概念。</p><h2 id=why-aarf为什么是-aarf>Why AARF?(为什么是 AARF)</h2><blockquote><p>AARF 代表着在后端开发中从面向逻辑到面向资源，从以业务/页面为驱动到以状态/数据为驱动的设计理念的变化。</p></blockquote><p>目前流行的复合 REST 分层的系统的原则的架构即是 MVC，在传统的 J2EE 中一般分为 Controller-Service-Model，也是典型的面向逻辑的编程。首先一个逻辑会映射到一个 Controller，再由 Controller 中根据 URI 来组合搭配不同的 Service，而某个 Service 往往也是为了完成某个业务逻辑而特别存在的。不过 MVC 完全是一套非常粗粒度的规范，在实际的编程中，后台就是一个庞杂的数据提供方，连接前端与数据库。而后台的具体代码分割风格在 Controller 层次受业务请求约束，在 Model 层则受到 SQL 语句的约束。确实，特别是在 GET 类型请求的处理中，如果需要返回多个资源的综合结果，用连接查询或者子查询毫无疑问会比多次查询节省很多消耗。但是这种混杂的 SQL 又会将我们希望达到的资源分割的目的给毁掉，因此，AARF 中希望能够立足于规范的不同资源间的 SQL 的自动智能组合来解决这个问题。</p><p>在 AARF 中，不同的资源处理器之间的逻辑代码重合度会在 80%以上，换言之，为了不同业务逻辑而产生的硬编码的需求被尽可能地缩小，从而尽可能地避免需求变更带来的代码变化。毕竟在大型系统中一行代码的改变可能形成的多米诺骨牌效应是不可想象的。</p><p>另一方面，以 Spring 为代表的框架强调的是以 DI，也就是 IOC 的方式来解决这种依赖的可变性问题。但是它们在一个宏观的视角上还是面向逻辑编程。AARF 提供了不仅仅是一套类似于 Spring 的编程 Library，也提供了一套从前后到后的基于约定的命名规划与代码风格。需要注意的是，因为业务逻辑的复杂多变性，AARF 只是尽可能地在抽象与具体之间寻求一种平衡，具体的业务逻辑设计与代码架构还是需要根据实际的应用场景而言。而这种抽象毫无疑问在设计初期会影响到性能，譬如可能需要冗余的数据库操作等，这种性能的补偿会在后面提及。</p><p>在对大量复杂的业务后台的分析之后，发现如果我们深入到某个具体的业务流设计中，会发现不同的 API 之间具有相当复杂的且唯一的关系。而如果我们提取这些业务逻辑之间的共性，即会发现对于一些抽象资源的组合和处理方式是如此的类似。</p><p>AARF 继承并个性化的解释了 REST 的六大原则，同时自身的原则为：</p><blockquote><p>这些所谓的原则还处于修订中，不建议用于生产环境</p><p>PS：上面这句话只是单纯的为了装逼</p></blockquote><ul><li>约定优于配置，配置优于硬编码，这一条算是 AARF 的核心理念，一方面表现在前端可见的资源组合搭配上，另一方面表现在对于隐性</li></ul><ul><li>请求与响应的一致性。就好像 Redux 宣称的 Predictable State 一样，之前客户端是在请求之后对于返回数据进行</li><li>尽可能地资源隔离。不强求资源的完全隔离，也不支持把对于资源的处理混杂在一起。至少在 ResourceHandler 这一层，不建议有对于其他资源的操作。在 Model 层，可以对于确定性的关联操作。在 Relation 层，可以随便混杂资源的操作。</li></ul><p>举个具体的例子，在我们的电商模型中，我们最常用的接口是返回商品(goods)信息，譬如：</p><pre tabindex=0><code>api.com/goods
</code></pre><p>这会根据我们的需要自动地返回一些商品列表，如果我们需要根据不同品类、属性等进行查询，则只需要加一个查询参数等，譬如：</p><pre tabindex=0><code>api.com/goods?requestData={category:1}&amp;sort=rating
</code></pre><p>随着业务需求的进一步完善，我们现在需要返回用户的订单商品信息，这里我们假设有一个专门的订单表(goods_order)，如果是按照传统的朴素的方式，可以为：</p><pre tabindex=0><code>api.com/getGoodsInOrderByUserId?user_id=123
</code></pre><p>而如果按照 rest 的风格，可以定义为：</p><pre tabindex=0><code>api.com/goods_order?requestData={user_id:123}
</code></pre><p>注意，无论是哪种 URL 定义方式都会映射到某个处理函数，但是很明显的 REST 风格的接口(URI)可读性会更好。但是虽然我们请求的是订单，但实际上返回的却是一个商品列表(如果你认为商品列表与商品是属于同一种资源，那么请忽略这一部分)。请求者最终想要的是一个包含商品详情的列表，而不是单纯的订单列表。因此，在对应的处理函数中，我们需要根据 user_id 查询到商品订单列表，然后根据商品订单列表查询到商品详情。这三者之间是一对多(用户-商品订单)以及一对一的关系(商品订单-商品)。</p><p>当然，我们可以在该处理函数中用一个简单的 SQL 连接查询即可获得想要的数据，一切看上去是如此的简单。接下来我们的业务逻辑更加复杂，添加了购物车、收藏夹等等功能，同样的，我们需要获得购物车中的商品列表、收藏夹中的商品列表。我们会选择定义不同的 URI，譬如：</p><pre tabindex=0><code>api.com/getGoodsInCartByUserId?user_id=123
api.com/getGoodsInFavoriteByUserId?user_id=123
</code></pre><p>当然，也可以用等效的 REST 风格的接口，不过它们都是同样映射到某个处理函数，然后很简单的用一个 SQL 语句解决。一切还是很简单很正常，但是墨菲定理就来了。有一天如果整个系统需要重构，商品表发生了翻天覆地的变化，或者某个原有的需求发生了些许的改变。好一点的情况是还是当时那个开发人员，他清晰的知道每一条代码，并且能精准的进行每一行的改动，最终通过回归测试。</p><p>不过真实情况却是，即使是自己也不乐意去看那一大堆好久不碰的代码，或者换了个新人，压根不愿意去看前辈的代码(这在小公司里非常常见，毕竟大家的代码风格都不一样)。可能一个函数的命名方式都会让你纠结半天，毕竟命名时是如此的随意。最终，导致整个系统中充满了冗余代码，就好像炸弹一样，谁也不知道这段代码是干啥的，但是也不敢删除。整个依赖变得非常混乱。直到有一天受不了了，花费大量的时间进行业务逻辑重构。当然，老板肯定会在你重构完成之前告诉你，需求又改了。你还能咬他咋的？</p><p>以上的方式就是面向业务逻辑的接口，我们有一个固定的 URL 或者 URI 代指某个业务逻辑的处理方式，并在该处理函数中调用所需的 Service 层或者 Model 层函数，完成整个业务逻辑处理过程。同时作为一个前端开发者，我们往往需要的是面向页面的接口。具体而言，前端开发者希望的最理想的情况是每个页面只需要发起一次请求即可以获得所需要的数据。譬如我们在电商系统中添加了所谓的主题活动，一个活动可能关联到多个商品。那么对于如下的这个界面，我们可能有两种构造方式：</p><pre tabindex=0><code>api.com/getGoodsThemeAndGoodsList?goods_theme_id=1
</code></pre><p>当前端请求该接口时，就会返回如下格式的数据：</p><pre tabindex=0><code>{
  &#34;goods_theme&#34;:{goods_theme_detail}
  &#34;goodss&#34;:[{goods_detail}]
}
</code></pre><p>绝大部分人都会把主题活动和商品当做两个存在一定关联的不同资源吧，不会认为这两货是同一个东西的吧？如果按照第一种方式，一旦设计同学修正了前端页面，譬如不展示商品列表详情了，或者后台的商品表发生变化，那么整个接口就要改或者添加新的接口。与接口相关联的 Service 或者 Model 层也会变动。就像上面所讲的，一大堆地雷正在靠近。</p><p>如果我们按照纯粹的资源的方式考虑呢，即完全的 REST 方式，首先我们获取主题活动的详情：</p><pre tabindex=0><code>api.com/goods_theme/1
</code></pre><p>获得一系列的商品列表 ID，然后通过商品列表去获取详情，譬如：</p><pre tabindex=0><code>api.com/goods/[1,2,3,4,5]
</code></pre><p>这种划分方式，可以达成逻辑上的明晰，不过前端估计会疯掉。并且用户体验会非常不好，同时也会耗费大量无谓的资源。</p><p>综上所述，我们需要是是一种抽象的，即独立于具体业务逻辑的资源划分与处理方式，这种方式能够灵活组合并且适应快速变化的前端界面与业务需求，最终在前端的请求次数与逻辑的划分之间达成较好的平衡。</p><p>MVC 架构功能之间分层比较明晰，但是逻辑间分层比较混乱，并且不同的功能点之间是所谓的双向数据流，如下图所示：</p><p>而 AARF 中明确划分了资源的边界，并且能够根据业务需求动态映射到不同的数据流现。</p><p>AARF 的适用领域是那种需要快速迭代的具有一定逻辑复杂度的服务后台搭建。对于大型项目，如果在项目起草时期就能够将需要的业务逻辑以及操作全部规划完善，那么也没必要使用 AARF 这种自找麻烦的架构风格。</p><p>个人感觉，AARF 会在代码自动生成领域有一定的领先优势。</p><h3 id=microservices微服务>MicroServices(微服务)</h3><p>近年来微服务概念的兴起也是为了进行这样的解耦合，只是微服务和 AARF 的类比可以有以下几点：</p><ul><li>微服务和 AARF 在某种意义上都是推崇 SRP 原则，不过微服务是从传统的 SOA 架构衍变而来，而 AARF 是借鉴了以状态/数据为驱动的这样一种开发方式。</li><li>微服务更多的是在功能上的，面向于整体后台架构的解耦合。而 AARF 关注的是偏向于业务逻辑的组织方式。</li><li>微服务往往强调的是不同功能间的物理隔离，这是其与传统的巨石(Monolith)应用程序的一个很大的区别。而 AARF 依赖的是逻辑间的隔离，相对于功能领域会是一个更加抽象的概念。</li><li>微服务是去除了 ESB 的 SOA，即一种去中心化的分布式软件架构。而 AARF 面向每个具体业务而言的去 Controller 化的基于抽象资源流的架构风格。</li></ul><p>AARF 与 MicroServices 的最终目标都是为了避免巨石应用程序的出现，最终形成一种分布式地灵活可拆卸的应用程序。某些方面来说，AARF 是实现 MicroServices 的一个手段。</p><p>实际上，现在也有很多微服务的设计模式上，在保证隔离性的基础上，以 Event-Driven 的方式来组合不同的服务并且管理这些分布式数据。</p><ul><li><a href=https://www.nginx.com/blog/event-driven-data-management-microservices/ target=_blank rel=noopener>event-driven-data-management-microservices</a></li></ul><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://www.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-separate-tables-e1449727641793.png alt="Each service in a microservice architecture maintains a private database table" loading=lazy data-zoomable></div></div></figure></p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://www.nginx.com/wp-content/uploads/2015/12/Richardson-microservices-part5-credit-check-1-e1449727610972.png alt loading=lazy data-zoomable></div></div></figure></p><h2 id=rest--software-architecture-style>REST & Software Architecture Style</h2><p>在理想的情况下，每个开发者都能具有高度一致的编码风格与能力，并且对整个项目了如指掌，这样才能够快速地无冗余地根据业务需求来修改代码。并且辅助以大量的回归测试来保证代码的可用性，毕竟</p><p>Request per thread is an old beast and should be avoided as much as possible. It not only affects an application&rsquo;s scalability but can also lead to cascading failures.</p><ul><li><a href=https://dzone.com/articles/non-blocking-rest-services-with-spring target=_blank rel=noopener>Non-Blocking REST Services With Spring</a></li></ul><h2 id=flux--redux>Flux & Redux</h2><h2 id=reactive-programming--actor>Reactive Programming & Actor</h2><p>在笔者的基于 Spring 框架的 AARF 的实践中，选用了 RxJava 作为 FRP 的实现库。不过实际上每个 ResourceHandler 非常类似于 Actor</p><p>Reactive programming is an emerging discipline which combines concurrency and event-based and asynchronous systems.Reactive programming can be seen as a natural extension of higher-order functional programming to concurrent systems that deal with distributed state by coordinating and orchestrating asynchronous data streams exchanged by actors.</p><p>Reactive Programming Principles (via manifesto)</p><ul><li>Responsive: The application should be quick to reacts to users, even under load and in the presence of failures</li><li>Resilient and Scalable: The application should be resilient, in order to stay responsive under various conditions. They also should react to changes in the input rate by increasing or decreasing the resources allocated to service these inputs. Today’s applications have more integration complexity, as they are composed of multiple applications.</li><li>Message Driven: A <em>message-driven</em>architecture is the foundation of scalable, resilient, and ultimately responsive systems.</li></ul><p><strong>参考文献</strong></p><ul><li><a href=https://www.linkedin.com/pulse/20141208023559-947775-reactive-programming-using-rxjava-and-akka target=_blank rel=noopener>reactive-programming-using-rxjava-and-akka</a></li></ul><h2 id=whats-aarf什么是-aarf>What&rsquo;s AARF?(什么是 AARF)</h2><blockquote><p>AARF is an architectural style, it&rsquo;s not only specific set of technologies, but a design concept throughout the develop stack.</p><p>笔者将 AARF 称为一种架构风格，它不仅仅是一系列具体的技术的集合，更重要的是一种贯穿开发全栈的设计理念。AARF 继承并个性化地实现了 REST 的基本思想，借鉴了 Flux 以及 Redux 的单向数据流的思想，最终使用 Reactive Programming 作为实现手段。</p></blockquote><p>最直观的感受上，传统的 MVC 模型是厨师点菜，不同的业务逻辑就是不同的菜，根据前端的需求做出不同的菜。而 AARF 是自助餐，即使在业务逻辑不明确的情况下，也能提供基本的食材或者半成品，前端可以自由的将这些食材组合搭配，最终形成自己所需要的美食。</p><blockquote><p>后端开发不应该再根据前端的某个需求编写相应的 URI 与处理函数，而应该从自身资源分割的视角，为前端提供一系列原子操作，并且在保证权限控制与数据验证的基础上允许前端自由组合</p></blockquote><p>对于 Model 层而言，。实际上，为了强调资源之间的隔离性与操作的原子性，直接的表现就是将原先复杂的 SQL 语句拆分成不同的小块然后交由不同的资源处理器或者 Model 进行处理。这样势必会增加 SQL 查询的次数，不过笔者在下文中会提及如何在保证 AARF 的资源独立的前提的基础上通过 Deferred SQL 的方式来减少无谓的 SQL 查询次数。另一方面，随着 NoSQL 数据库的发展，笔者也是建议可以通过缓存等多种存储方式来减少直接查询的 SQL 的次数。</p><h3 id=twelve-factors--cloud-native-principles>Twelve-Factors & Cloud Native Principles</h3><h3 id=aarf-principles>AARF Principles</h3><ul><li><p>Front-end Friendly</p><ul><li>flexibility</li><li>readability</li><li>Consistency<ul><li>Response comply with request</li></ul></li></ul></li><li><p>High Availability</p><ul><li>Responsive & Fault-Tolerant</li></ul></li><li><p>Develop Simplicity</p><h3 id=modifiabilityundefined><a href=undefined>Modifiability</a></h3><h4 id=reusabilityundefined><a href=undefined>Reusability</a></h4><p>Reusability is a property of an application architecture if its components, connectors, or data elements can be reused, without modification, in other applications. The primary mechanisms for inducing reusability within architectural styles is reduction of coupling (knowledge of identity) between components and constraining the generality of component interfaces. The uniform pipe-and-filter style exemplifies these types of constraints.</p></li></ul><ul><li><h4 id=configurabilityundefined><a href=undefined>Configurability</a></h4><p>Configurability is related to both extensibility and reusability in that it refers to post-deployment modification of components, or configurations of components, such that they are capable of using a new service or data element type. The pipe-and-filter and code-on-demand styles are two examples that induce configurability of configurations and components, respectively.</p></li><li><h3 id=visibilityundefined><a href=undefined>Visibility</a></h3><p>Styles can also influence the visibility of interactions within a network-based application by restricting interfaces via generality or providing access to monitoring. Visibility in this case refers to the ability of a component to monitor or mediate the interaction between two other components. Visibility can enable improved performance via shared caching of interactions, scalability through layered services, reliability through reflective monitoring, and security by allowing the interactions to be inspected by mediators (e.g., network firewalls). The mobile agent style is an example where the lack of visibility may lead to security concerns.</p></li><li><p>Scalability:架构的可扩展性</p><p>Scalability refers to the ability of the architecture to support large numbers of components, or interactions among components, within an active configuration. Scalability can be improved by simplifying components, by distributing services across many components (decentralizing the interactions), and by controlling interactions and configurations as a result of monitoring. Styles influence these factors by determining the location of application state, the extent of distribution, and the coupling between components.</p><p>Scalability is also impacted by the frequency of interactions, whether the load on a component is distributed evenly over time or occurs in peaks, whether an interaction requires guaranteed delivery or a best-effort, whether a request involves synchronous or asynchronous handling, and whether the environment is controlled or anarchic (i.e., can you trust the other components?).</p></li></ul><h2 id=case-model案例模型>Case Model(案例模型)</h2><ul><li>User</li><li>Book</li><li>Comment</li></ul><p>Relation</p><p>FriendShip</p><h1 id=resource资源>Resource(资源)</h1><p>在传统的 RESTful 风格的 MVC 框架中，将某个请求按照其请求路径映射到控制器中，并在该控制器中完成了</p><p>任何一個 ResourceHandler，可以以相同方式处理来自于外部或者内部的请求。</p><p>譬如 DELETE book_comment 可以即直接来自于 URLMapping</p><p>也可以来自于内部的 DELETE book。</p><p>资源的规范性，包括分割以及命名的规范性是整个 AARF 体系的基石。</p><h2 id=abstract-resource>Abstract Resource</h2><blockquote><p><strong>Everything is Abstract Resource</strong></p></blockquote><p>AARF 主要是以数据流的方式解决复杂逻辑后来的构建问题，其中对于资源的定义与传统的 REST 约定中的资源有交集也有差异，REST 中强调的是 URI 的概念，即唯一资源定位，往往将超媒体、文档或者某个逻辑对象当做资源。而 AARF 中主要面向的是逻辑对象以及对于逻辑对象的操作。</p><blockquote><p><strong>具有独立的属性或者属性组合的逻辑对象即为抽象资源</strong></p></blockquote><p>最常见的，我们可以将商品的所有属性组合为商品资源。</p><p>而对于发邮件这个动作而言，它的属性可能有收件人、邮件正文等等，那么这些属性的组合也就可以构成邮件资源。</p><p>实际上，对于资源的定义与划分具有很大的随机性，并且不同的划分方案会极大的影响后期的组合操作。对于如何合理划分资源来保证整个系统的最优性，还需要在后面详细讨论。</p><h2 id=attribute资源属性>Attribute(资源属性)</h2><ul><li>资源唯一标识，譬如对于用户资源的唯一标识就是 user_id。</li><li>外键依赖，外键依赖是表征资源之间显性关系的特征。注意，任何一个资源的标识名具有全局唯一性，譬如 use_id，那么所有的资源中都应该叫 user_id，而不应该使用 uid、id 等等缩写或者别名。另一方面，可能某个资源中的两个外键依赖都指向 user_id，但是表示两个不同的含义。譬如如果我们需要表征用户之间的互相关注的行为，一个表中可能有两个 user_id，第一个表示关注者，第二个表示被关注者。那么在命名时务必保证前缀不变，即皆为 user_id，可以通过 by 关键字添加后缀的方式，即 user_id_by_following、user_id_by_followed。</li><li>值属性</li></ul><h2 id=entity>Entity</h2><p>不是很建议资源的嵌套，即将某整个其他的资源打包成某个资源的一个属性。</p><p>建议以使用基本类型加上 JSONObject、JSONArray 为主，笔者常使用的类型有：</p><p>String</p><p>Integer</p><p>JSONObject</p><p>JSONArray</p><p>Instant(映射 TimeStamp 类型)</p><p>LocalDateTime(映射时间类型)</p><h2 id=model>Model</h2><p>在 Model 层的设计时，要注意做到逻辑无关性，而属性相关性。</p><h4 id=select>Select</h4><ul><li>利用 foreach 构造多查询的 in 条件查询语句时候，注意容错</li></ul><h1 id=request--response>Request & Response</h1><blockquote></blockquote><h2 id=uniform-resource-flow-path统一资源流动路径>Uniform Resource Flow Path(统一资源流动路径)</h2><h3 id=resource-quantifier资源量词>Resource Quantifier(资源量词)</h3><p>量词分为 单个值、多个值(JSONArray)、空值以及全部值(all)。</p><p>preHandle 根据上一个资源，获取到本次所需要处理的资源编号列表。</p><p>all，不一定就代表着全部。譬如</p><p>/user/{user_id}/book/all/comment</p><p>这边的 book 的 all，就应该被替换为多个值，即为隐性的多值。</p><p>换言之，所有与当前业务逻辑相关的处理，都放在 preHandle 的起始完成。这种多量词的一般出现在 GET 请求中，也是最复杂的请求之一。</p><h2 id=resourcebag资源包>ResourceBag(资源包)</h2><blockquote><p>资源包是唯一可以跨资源流动的对象</p></blockquote><h3 id=immutable-object不可变对象>Immutable Object(不可变对象)</h3><p>笔者觉得，没必要为每个 ResourceHandler 创建一个新的 ResourceBag，目前是暂时规定某个 ResourceHandler 尽可以操作 ResourceBag 中包含其对应的资源，而不可以操作其他资源。</p><h2 id=advanced-request>Advanced Request</h2><h3 id=resource-filter>Resource Filter</h3><p>包括条件查找、聚合操作、筛选操作</p><p>如果是聚合操作：aggreation</p><h3 id=resource-integration资源注入>Resource Integration(资源注入)</h3><h3 id=mapreduce-for-multiple-request-once单次多请求处理>MapReduce For Multiple Request Once(单次多请求处理)</h3><h2 id=non-resourceful-response非资源化响应>Non-Resourceful Response(非资源化响应)</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;code&#34;</span><span class=p>:</span> <span class=mi>404</span><span class=p>,</span> <span class=c1>//Required
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nt>&#34;desc&#34;</span><span class=p>:</span> <span class=s2>&#34;Description Message&#34;</span><span class=p>,</span> <span class=c1>//Optional
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nt>&#34;subCode&#34;</span><span class=p>:</span> <span class=s2>&#34;Sub Code to specific error&#34;</span> <span class=c1>//Optional
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=code-and-http-status响应码与-http-状态>Code And HTTP Status(响应码与 HTTP 状态)</h3><p>虽然 HTTP 协议为我们提供了大量的状态码，但是在实际的 API 开发中不建议用很多，毕竟前后端看着都很崩溃。一般来说，我们会建议使用以下五种状态码来表述不同的问题：</p><h3 id=empty-resource-is-error空资源即为错误>Empty Resource Is Error(空资源即为错误)</h3><h1 id=resourcehandler资源处理>ResourceHandler(资源处理)</h1><h2 id=dispatcher>Dispatcher</h2><p>为了保证多线程下的安全性，要保证每个 ResourceHandler 的无状态性。</p><p>为了避免因为复杂的异步数据流而导致逻辑的混乱，做以下约定：</p><p>(1)在 route 函数中的主逻辑步骤只允许同步执行，譬如常常要进行推送。如果推送会影响到本次资源流的结果，则同步执行。否则异步执行。</p><p>(2)在 route 方法中，不可以调用 onNext、onError 以及 onComplete 方法</p><h2 id=get>Get</h2><h3 id=setresult>SetResult</h3><p>本步骤主要在根据 deferredResult 进行返回，注意，所有的资源，为了保证解析的一致性与有效性，全部以列表方式返回。</p><h2 id=post>Post</h2><h2 id=update>Update</h2><h2 id=delete>Delete</h2><p>获取用户评价过的书</p><p>/user/{user_id}/comment/all/book</p><p>获取用户好友评价过的书</p><p>/user/[{user_id}]/comment/all/book</p><p>/user/{user_id}/comment/all/book</p><p>/user/{user_id}/book</p><p>/user/{user_id}/comment/[&ldquo;1&rdquo;,&ldquo;2&rdquo;]/book</p><p>get getAll getSingle getMultiple</p><p>post postSingle postMultiple</p><p>update updateSingle updateMultiple</p><p>delete deleteSingle deleteMultiple deleteAll</p><h1 id=relation混合关联层>Relation(混合关联层)</h1><p>资源之间的关联一般分为两种，显性关联与隐性关联。譬如主键依赖这样的，往往称为是显性关联，一般也都会在 URFP 中明晰的表现出来。而另一种关联就是所谓的隐性关联，譬如在我们的电商模型中，用户在购买某件商品，即下了某个订单之后</p><p>对于隐性关联，一般也会分为必然关联与可变关联。譬如我们往往有一个推送模块，而用户在执行某个操作之后是否发送通知，或者发送什么样的通知，这个在业务初期是不可预知的。因此在 AARF 中的建议中，Model 层中可以写这样的必然关联。而可选关联应该放在单独的 Relation 中进行处理。</p><p>对于某个资源的某个操作不可避免地会引起其他资源的操作，而在定义 AARF 的基本规则的时候也提及，某个资源的域中应当只处理与该资源相关联的事务，这样来尽可能地将所有的逻辑操作划分为原子操作，从而能够更灵活地组合封装。譬如在我们的电商模型中，用户在订购某个商品之后会由系统发邮件通知该用户。那么发送邮件这个动作与对订单资源的操作就是产生了一种隐性的依赖关系，这种依赖关系式可变的，譬如可能由发邮件切换到了发短信。在实际的应用中，我们并不可能预知未来的切换方式，如果依靠 DI 的概念，同样会造成一定的硬编码问题。</p><p>特别是在协同项目或者后期的迭代开发中，如果以面向逻辑的方式，那么往往会选择根据新的逻辑需求添加新的功能函数，而尽可能地避免修改之前的函数。但是这种盲目地堆叠方式只会导致代码的可维护性更差，最终积重难返。这样一个问题，看起来可以通过严格的</p><p>一方面，我们希望能保证代码的简洁性，另一方面，我们又希望能保证代码的灵活性与可变性。笔者一再强调的资源的单一职责问题，并不排斥在资源的 Model 中会有相关其他的操作，只不过建议将存在较大不确定性的操作放置于专门的 Relation 模块。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>insertSingleGoodsOrder</span><span class=o>(</span><span class=n>GoodsOrderResource</span><span class=o>.</span><span class=na>Entity</span> <span class=n>goodsOrderEntity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>transactionWrapper</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>//首先插入订单
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>goodsOrderMapper</span><span class=o>.</span><span class=na>insertSingleGoodsOrder</span><span class=o>(</span><span class=n>goodsOrderEntity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>//将资源封装到ResourceBag中
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>final</span> <span class=n>ResourceBag</span> <span class=n>resourceBag</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ResourceBag</span><span class=o>.</span><span class=na>Builder</span><span class=o>(</span><span class=n>ResourceBag</span><span class=o>.</span><span class=na>Action</span><span class=o>.</span><span class=na>GET</span><span class=o>,</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>()).</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>GoodsOrderResource</span> <span class=n>goodsOrderResource</span> <span class=o>=</span> <span class=k>new</span> <span class=n>GoodsOrderResource</span><span class=o>(</span><span class=n>goodsOrderEntity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>resourceBag</span><span class=o>.</span><span class=na>getResources</span><span class=o>().</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;goods_order&#34;</span><span class=o>,</span> <span class=n>goodsOrderResource</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(!</span><span class=k>this</span><span class=o>.</span><span class=na>relationProxy</span><span class=o>.</span><span class=na>proxy</span><span class=o>(</span><span class=s>&#34;goods_order&#34;</span><span class=o>,</span> <span class=s>&#34;insertSingleGoodsOrder&#34;</span><span class=o>,</span> <span class=n>resourceBag</span><span class=o>).</span><span class=na>toBlocking</span><span class=o>().</span><span class=na>first</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//如果操作失败，则回滚
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>throw</span> <span class=k>new</span> <span class=n>Exception</span><span class=o>(</span><span class=s>&#34;附加操作失败&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>笔者的建议是，对于必然的操作，直接放置在该功能函数中，对于可选操作，放置在 Relation 中进行。</p><h1 id=filterinterceptor>Filter/Interceptor</h1><h2 id=authority-control权限控制>Authority Control(权限控制)</h2><h3 id=jwt-based-user-authentic用户认证>JWT Based User Authentic(用户认证)</h3><p>笔者在最初设计 AARF 的风格时犯了一个很大的错误，也是为了兼容旧的系统。将请求认证，即发起该请求的用户认证与用户资源的获取混为一谈。譬如对于以下的请求：</p><pre tabindex=0><code>/user/{user_token}
</code></pre><p>这样一种直接把用户令牌与用户资源的唯一标识混为一谈的方式就是典型的错误。笔者比较推出基于 JWT 的用户认证。</p><h3 id=基于-sql-级别的控制>基于 SQL 级别的控制</h3><p>错误还是空？譬如用户请求一个不存在的商品，这是一个错误吗？请求一个不存在的资源，特别是在发生资源串联时，因此，在 Get 中，如果请求到的资源为空，则报错。</p><h2 id=data-verification数据验证>Data Verification(数据验证)</h2><p>数据验证一个是数据格式的验证，包括</p><p>请求数据格式的验证，放在 Model 中</p><p>返回数据格式的 Json 化</p><h1 id=deferred-sql>Deferred SQL</h1><p>笔者在文章开头就提及 AARF 可能面临的为了保证资源之间的隔离性而导致的 SQL 的冗余查询问题。Deferred SQL 的理念来自于异步编程中的 Promise 或者 Java 中的 Future 的概念。</p><h1 id=optimization性能优化>Optimization(性能优化)</h1></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/architecture-series/1.%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/udlma/rarf/aarf.en/ rel=prev>AARF.en</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte.disqus.com/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>