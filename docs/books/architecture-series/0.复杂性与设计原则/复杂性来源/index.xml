<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>复杂性来源 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/</link>
      <atom:link href="https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/index.xml" rel="self" type="application/rss+xml" />
    <description>复杂性来源</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>复杂性来源</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/</link>
    </image>
    
    <item>
      <title>1.复杂性定义</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/1.%E5%A4%8D%E6%9D%82%E6%80%A7%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/1.%E5%A4%8D%E6%9D%82%E6%80%A7%E5%AE%9A%E4%B9%89/</guid>
      <description>&lt;h1 id=&#34;复杂性定义&#34;&gt;复杂性定义&lt;/h1&gt;
&lt;p&gt;复杂性与软件系统的结构有关，这使它很难理解和修改系统。复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的。可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进；如果不引入其他错误，可能很难修复。如果一个软件系统难以理解和修改，那就很复杂；如果很容易理解和修改，那就很简单。在复杂的系统中，要实施甚至很小的改进都需要大量的工作；在一个简单的系统中，可以用更少的精力实现更大的改进。&lt;/p&gt;
&lt;p&gt;值得注意的是，复杂性不一定与系统的整体大小或功能有关；当然，实际上几乎所有大型复杂的软件系统都很难使用，因此它们也符合我对复杂性的定义，但这不一定是事实。小型而不复杂的系统也可能非常复杂。复杂性取决于代码库中最常打交道的那一部分，如果系统中有一些非常复杂的部分，但是几乎不需要触摸这些部分，那么它们对系统的整体复杂性不会有太大影响。可以用粗略的数学方法来表征：&lt;/p&gt;
&lt;p&gt;$$
C=\sum_{p} c_{p} t_{p}
$$&lt;/p&gt;
&lt;p&gt;系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。在一个永远不会被看到的地方隔离复杂性几乎和完全消除复杂性一样好。&lt;/p&gt;
&lt;h1 id=&#34;业务复杂度与技术复杂度&#34;&gt;业务复杂度与技术复杂度&lt;/h1&gt;
&lt;p&gt;业务复杂度对应了客户的业务需求，因而这种复杂度往往会随着需求规模的增大而增加，这也是本部分讨论复杂性的核心。技术复杂度来自需求的质量属性，诸如安全、高性能、高并发、高可用性等需求，为软件设计带来了极大的挑战，让人痛苦的是这些因素彼此之间可能又互相矛盾、互相影响。技术复杂度与业务复杂度并非完全独立，二者混合在一起产生的化合作用更让系统的复杂度变得不可预期，难以掌控&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s3.ax1x.com/2021/02/02/yn7XWV.png&#34; alt=&#34;技术复杂度与业务复杂度融合&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;技术复杂度则来自于对软件系统运行的质量需求，包括安全、高性能、高并发、高可用和高扩展性。系统安全性要求对访问进行控制，无论是加密还是认证和授权，都需要为整个系统架构添加额外的间接层。不仅对访问的低延迟产生影响，还极大提升了系统代码复杂度；为了让后端系统能具备高扩展性和弹性，要求所有系统的设计必须是无状态的；为了提升用户端访问体验，后端需要增添离线任务对数据加工、异构、预热、预缓存，以实现用空间换时间，降低实时接口的逻辑复杂度来降低请求的延迟。然而最让开发者更抓狂的是这些技术需求彼此又是相互影响甚至相互矛盾，在一些复杂流程并要求高响应的业务场景，如下单、秒杀等，会将一个同步的访问请求拆分为多级步骤的异步请求，再通过引入消息中间件对这些请求进行整合和分散处理，这种分离一方面增加了系统架构的复杂性，另一方面也因为引入了更多的资源，使得系统的高可用面临挑战，并增加了维护数据一致性的难度。而且技术复杂度与业务复杂度并非孤立，二者复杂度因子混合在一起产生的负作用更让系统的复杂度变得不可预期，难以掌控，就好比氢气和氯气混合在一起遇到光亮发生爆炸一样。&lt;/p&gt;
&lt;h1 id=&#34;complexity-symptoms--复杂性的症状&#34;&gt;Complexity Symptoms | 复杂性的症状&lt;/h1&gt;
&lt;p&gt;复杂性通过以下三种段落中描述的三种一般方式体现出来。这些表现形式中的每一个都使执行开发任务变得更加困难。&lt;/p&gt;
&lt;h2 id=&#34;变更放大change-amplification&#34;&gt;变更放大（Change amplification）&lt;/h2&gt;
&lt;p&gt;复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。例如，考虑一个包含几个页面的网站，每个页面显示带有背景色的横幅。在许多早期的网站中，颜色是在每个页面上明确指定的，如下图（a）所示。为了更改此类网站的背景，开发人员可能必须手动修改每个现有页面；对于拥有数千个页面的大型网站而言，这几乎是不可能的。幸运的是，现代网站使用的方法类似于下图（b），其中横幅颜色一次在中心位置指定，并且所有各个页面均引用该共享值。使用这种方法，可以通过一次修改来更改整个网站的标题颜色。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s3.ax1x.com/2020/11/28/DyAx00.png&#34; alt=&#34;网站更改示意&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上图中网站中的每个页面都显示一个彩色横幅。在（a）中，横幅的背景色在每页中都明确指定。在（b）中，共享变量保留背景色，并且每个页面都引用该变量。在（c）中，某些页面会显示其他用于强调的颜色，即横幅背景颜色的暗色；如果背景颜色改变，则强调颜色也必须改变。&lt;/p&gt;
&lt;h2 id=&#34;认知负荷cognitive-load&#34;&gt;认知负荷（Cognitive load）&lt;/h2&gt;
&lt;p&gt;复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。如果可以对系统进行重组，以使调用者不必担心释放内存（分配内存的同一模块也负责释放内存），它将减少认知负担。&lt;/p&gt;
&lt;p&gt;系统设计人员有时会假设可以通过代码行来衡量复杂性。他们认为，如果一个实现比另一个实现短，那么它必须更简单；如果只需要几行代码就可以进行更改，那么更改必须很容易。但是，这种观点忽略了与认知负荷相关的成本。我已经看到了仅允许使用几行代码编写应用程序的框架，但是要弄清楚这些行是什么极其困难。有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担。&lt;/p&gt;
&lt;h2 id=&#34;未知的未知unknown-unknowns&#34;&gt;未知的未知（Unknown unknowns）&lt;/h2&gt;
&lt;p&gt;复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。上图(c)说明了这个问题。网站使用一个中心变量来确定横幅的背景颜色，所以它看起来很容易改变。但是，一些 Web 页面使用较暗的背景色来强调，并且在各个页面中明确指定了较暗的颜色。如果背景颜色改变，那么强调的颜色必须改变以匹配。不幸的是，开发人员不太可能意识到这一点，所以他们可能会更改中央 bannerBg 变量而不更新强调颜色。即使开发人员意识到这个问题，也不清楚哪些页面使用了强调色，因此开发人员可能必须搜索 Web 站点中的每个页面。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在复杂性的三种表现形式中，未知的未知是最糟糕的。一个未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至是否有一个问题。你不会发现它，直到错误出现后，你做了一个改变。更改放大是令人恼火的，但是只要清楚哪些代码需要修改，一旦更改完成，系统就会工作。同样，高的认知负荷会增加改变的成本，但如果明确要阅读哪些信息，改变仍然可能是正确的。对于未知的未知，不清楚该做什么，或者提出的解决方案是否有效。唯一确定的方法是读取系统中的每一行代码，这对于任何大小的系统都是不可能的。甚至这可能还不够，因为更改可能依赖于一个从未记录的细微设计决策。&lt;/p&gt;
&lt;p&gt;良好设计的最重要目标之一就是使系统显而易见。这与高认知负荷和未知未知数相反。在一个显而易见的系统中，开发人员可以快速了解现有代码的工作方式以及进行更改所需的内容。一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.不确定的未来</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/2.%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%AA%E6%9D%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/2.%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%AA%E6%9D%A5/</guid>
      <description>&lt;h1 id=&#34;不确定性原则&#34;&gt;不确定性原则&lt;/h1&gt;
&lt;p&gt;频繁、不符预期的需求变更几乎是每个开发人员职业生涯中都会经历的，初期我们可能会觉得这种变更是偶然现象，但是随着用户量的增长、业务功能的变化，不确定性才是恒久存在的事实。因此，当我们在进行架构设计时，要能够从现有的需求，以及未来潜在的需求中寻找到确定性内核，并由内向外设计弹性可扩展的系统。不确定性原则能够帮我们更好地面对技术负债，其在项目管理上的体现类似于敏捷开发，其在技术架构上的落地类似于&lt;a href=&#34;https://ng-tech.icu/books/Backend-Series/#/?q=%e6%b5%8b%e8%af%95%e4%b8%8e%e9%ab%98%e5%8f%af%e7%94%a8%e4%bf%9d%e9%9a%9c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;测试与高可用保障&lt;/a&gt;中讨论的面向失败的设计原则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本节的很多思想参考了&lt;a href=&#34;http://www.10tiao.com/html/639/201812/2247488951/1.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阿里玄难：面向不确定性的软件设计几点思考&lt;/a&gt;这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;传统面向确定性的设计&#34;&gt;传统面向确定性的设计&lt;/h1&gt;
&lt;p&gt;在软件系统发展的早期，更多是提供各式各样的软件工具，帮助使用者进行信息化改造。其典型代表即 Excel，Word，以及典型的企业内部管理的信息系统，例如：企业流程审批、进销存管理系统等等。他们本质上是把原来的人工工作，用计算机软件来模拟，实现电子化，因此有个典型的特征：业务领域、软件职责和功能边界都相对清晰。因此最经典软件工程理论是瀑布模型：收集需求、画 UserCase、确定功能集合、模型抽象、概要设计、详细设计、编码、单元测试、集成测试、用户测试、上线运行。然后投入下一个版本的迭代。传统的软件开发大多数都是这种模式。这种模式特别强调文档质量和变更的全流程一致。&lt;/p&gt;
&lt;p&gt;在互联网服务时代，用计算机软件实现了靠人肉无法完成的能力，为人类社会提供了很多全新的服务能力。我们继承了传统的软件工程理论，也做了适度的改良。为了缩短版本迭代的时间，更快地验证产品想法获取用户，大多数团队采用敏捷模型。本质上是把需求批发模式变成了零售模式。这种模式最大的好处就是对产品需求的快速响应，但致命的是每次敏捷大多数情况下是在不断地打补丁，软件架构快速腐化。&lt;/p&gt;
&lt;p&gt;在前面这两个阶段的软件设计理论都有一个基本假设：软件边界是确定的，我们通过归纳总结和适度的预测（避免过度设计）来进行模型抽象。通过模型抽象，我们设计了各种可配置性来快速接入需求，提升效率，也就是我们常说的产品化。通过接口设计和模块化设计来进行组织分工协作。通过系统架构的开放性来应对不能配置的变化。&lt;/p&gt;
&lt;h1 id=&#34;确定性的内卷&#34;&gt;确定性的内卷&lt;/h1&gt;
&lt;p&gt;随着移动互联网，IOT，人工智能的发展，软件变成了社会的基础设施，也带来了更加剧烈的变化。我们所谓的变化往往来源于两个方面：用户量的爆发与业务功能的变更。用户量的爆发带来系统容量、可用性的挑战，通常是用分布式来解决，分布式数据库，分布式缓存、分布式服务，多机房多单元，CDN 等等。业务功能的变化，也即是通常说的系统可扩展性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过传统数据库的大字段或者 NoSQL，用元数据结合 K-V 存储的方式来应对数据信息的不确定性；&lt;/li&gt;
&lt;li&gt;通过流程引擎来满足工作流程的快速响应；&lt;/li&gt;
&lt;li&gt;通过规则引擎来代替程序中的大量 If-Else，实现界面配置来实现规则的变化。&lt;/li&gt;
&lt;li&gt;通过 UI 组件化，配合 UI 的编辑器来快速调整用户界面的变化。&lt;/li&gt;
&lt;li&gt;通过插件技术来将容易变化，且相对复杂的逻辑从主流程中剥离出来进行扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这样的背景下，业务是没有确定性边界的，是在不断在生长和变异。这样就没有确定性的软件外延。如果没有确定性的外延，而软件的运行又是需要确定性的，我们就只能去寻找确定性的内核。&lt;/p&gt;
&lt;p&gt;从逻辑推理的角度来说，传统软件工程是以归纳法为主，局部使用演绎法，而要面对外延不确定性的领域来看，需要找到稳定的内核基础，然后以演绎法为主，局部使用归纳法。我们先去寻找内核，内核向外生长和变异，原来的确定性是寻找外沿的确定，现在我们要寻找内核的确定。原来是归纳法，现在我们要演绎，找到不变的是什么，也可以说这是一种跨业务领域的更高阶的抽象。&lt;/p&gt;
&lt;h1 id=&#34;面向业务的对象化设计&#34;&gt;面向业务的对象化设计&lt;/h1&gt;
&lt;p&gt;在不确定性的背景下，我们需要从面向功能的组件化设计到面向业务的对象化设计。我们的世界可以按熵变化的方向，分为熵增的无机体和熵减的生命体。无机体是靠设计、图纸，自顶而下的层层分解细化设计，然后组件化拼装出来的。典型特征是标准组件化设计和批量生产来进行协同和提效。生命体，是由内而外的生长和变异的。虽然看上去是组件化的，但因为基因不同，事实上不同生命体是不可替换，会产生排异反应的。所有组成部分是在基因的控制下同步生长的。生命体的生长和变异是连续的。因此按抽象归纳，组件化设计的软件系统，随着业务发展，补丁越来越多，运行几年就会被推倒重来是它的宿命。&lt;/p&gt;
&lt;p&gt;典型的电商系统中，业务系统都是由组件化系统，例如购物车、店铺、详情、库存、交易、营销、资金、支付、结算、财务体系构成。所有的业务实现，其实是数据在这些组件系统中流动来实现的。在这个运行系统中，我们看不到天猫、淘宝、盒马、天猫超市、担保交易、预售、团购这些业务对象，反而是沉淀在了都体现在一个个分散的数据字段和 IfElse 中。&lt;/p&gt;
&lt;p&gt;我们的设计思路是，回归到业务本质，用对象化设计来让业务可生长、继承和变异。最基本的思路：整个系统的根基是业务。通过对象来去除兄弟之间的相互影响。核心控制性基因是不可变的，但新能力的创造就脱离父亲的影响能独立发展，也可以创造出新的子业务。&lt;/p&gt;
&lt;p&gt;同样地，在快速变化的背景下，我们很难用额外的文档去描述系统的设计、各层接口的实现。特别是对于软件开发人员，我们愈发地需要去遵循代码即文档的原则。在项目研发过程中所做的需求分析，概要设计，详细设计到最后的 Java 代码，其实就是业务逻辑到计算机世界的一次编译过程。这其中最大的问题就是人肉编译，而不是机器无差别编译，这个编译过程因人而异。因为这种不确定性，导致所有的设计文档随着时间的推移，与实际运行的代码之间产生不可弥合的鸿沟。一个业务系统的文档越来越没有用处，也就越来越没人写了。如果不能实现文档即代码，我们就不能留下真实可用的文档。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.吸积与持续迭代</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/3.%E5%90%B8%E7%A7%AF%E4%B8%8E%E6%8C%81%E7%BB%AD%E8%BF%AD%E4%BB%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/3.%E5%90%B8%E7%A7%AF%E4%B8%8E%E6%8C%81%E7%BB%AD%E8%BF%AD%E4%BB%A3/</guid>
      <description>&lt;h1 id=&#34;吸积与持续迭代&#34;&gt;吸积与持续迭代&lt;/h1&gt;
&lt;p&gt;复杂度是递增的，并不是某些特定事物让系统复杂，而是数十或数百个小事物的积累。&lt;/p&gt;
&lt;p&gt;吸积效应，即一个事物的生成过程，就是从一个核心开始，逐步吸附新的资源，渐渐积累而形成的。这本来是天文学上的一个词，用来解释星体的形成。比如太阳是从一个核心，逐渐吸收周围的宇宙物质逐渐形成的。&lt;/p&gt;
&lt;p&gt;从字面上我们可以理解为吸附和积累。每次加一点，每次加一点，最后就有了一大堆。这句话来描述吸积效应最好不过，出自 1975 年出版的《人月神话》。无论一次代码迭代和升级看上去是多么独立，客观上导致的结果就是代码量从一点点变成一大堆，遗留代码和遗留系统就是这样形成的。遗留代码到底有什么问题？吸积效应导致代码十分庞大，没有人可以完全了解这个系统。当系统出现问题时，最了解这部分代码的人可能已经离职而杳无音讯。&lt;/p&gt;
&lt;p&gt;软件本身如此易变（Malleable），因此软件设计是持续的过程，贯穿软件系统的整个生命周期。软件设计的这个特点，使它和现实世界中实体系统(例如建筑，船舶，桥梁)的设计差异很大。然而，人们并不是从一开始就认可软件设计设计的持续性特点。在软件开发历史上很大一部分时间里，设计被认为和其他的工程一样：设计过程集中在项目的开始阶段.这种方式的一个极端就是瀑布式开发模型。在这个模型中，项目被划分为分离（Discrete）的各个阶段:需求分析，设计，编码，测试和维护，前一个阶段在下一个阶段开始前结束，并且很多场景下，不同人负责不同的阶段。整个系统的设计工作在设计阶段一次性完成，这个阶段结束后，设计就冻结了。后面的各个阶段就是逐步实现设计的过程.&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/YSt6fs1h/image.png&#34; alt=&#34;软件复杂性随着时间增加的衍化&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不幸的是，瀑布流开发模型很少在软件开发中有效。软件系统比其他实体系统内在（Intrinsically）复杂性更高.大型软件系统，很难在开发前设想清楚系统设计个各个方面和准确理解各个设计决策的影响。结果是，初始的设计会有很多问题，这些问题一开始并不明显，在实现的过程中才变得更加清晰。瀑布开发模型没有组织上的保障来适应这种设计变化(例如:软件设计人员可能已经调整到其他项目上). 因此，开发人员尝试在不修改整体设计的前提下，通过补丁（Patch）的方式来修复问题.这导致复杂性的爆炸性增长.&lt;/p&gt;
&lt;p&gt;因为有这些问题，今天大部分软件开发项目采用了增量式开发模式(例如敏捷开发模式)。在这种模式下，初始的设计聚焦在整体功能的一小部分上进行设计，实现和评估。初始设计的问题逐步被发现，并被纠正。随后更多的功能点被设计，实现和评估。每个迭代都暴露已有设计的问题，这些问题在下一个功能集的设计前得到解决。通过将设计的分散（Spread Out），初始设计的问题能够在系统还很小的阶段得到修复。得益于初始阶段获得的经验，后续功能设计问题会更少.&lt;/p&gt;
&lt;p&gt;这种增量式开发模型之所以有效，是因为软件系统具有足够的可塑性（Malleable），使得在软件开发的中途进行重大的设计变更是可行的。做为对比来看，在实现过程中对实体系统的重大设计进行变更往往更有挑战。例如，在建筑过程中，增加/减少支撑桥梁的支柱的数量是不可行的。&lt;/p&gt;
&lt;p&gt;增量式设计意味着软件设计永不结束。设计在系统的生命周期中持续发生:程序员要时刻考虑设计问题。增量开发也意味着持续重构。一个系统的初始设计几乎从来都不是最好的方案。随着经验的增加，必然会发现更好的设计方案。作为程序员，你需要时刻寻找机会来改进当前系统的设计，并且你也需要设计改进做计划，预留时间。遵从 John Ousterhout 老爷子的指导，作为程序员对设计和代码保留着必要的&amp;quot;洁癖&amp;quot;,不断追求更好的设计，在面临&amp;quot;将就&amp;quot;和&amp;quot;重构&amp;quot;的时候会做出更好的选择。&lt;/p&gt;
&lt;h1 id=&#34;腐败的软件系统&#34;&gt;腐败的软件系统&lt;/h1&gt;
&lt;p&gt;大项目的陷阱是，随着时间的推移，它们会变得非常复杂，以至于重写比培养新人来理解代码然后修改要容易得多。软件是纯粹脑力劳动的结果，极度依赖软件工程师本人。因此，软件的交接就不简单是生产工具的交接，更是知识的传递。而只要有知识的传递就必然有丢失，有变形。因此一个离职频繁的团队，知识的反复交接，必然会丢失大量的细节，以致于到最后，接手的程序员对系统的理解是面目全非。&lt;/p&gt;
&lt;p&gt;而且最严重的不仅是知识的丢失，更有责任心的丢失。如果一个模块是由某个软件工程师一手开发并维护。在感情上，他自然的倾向于爱惜羽毛，认真对待。在责任上，他也无可推卸，因为这一切都源于他。但是，在一个离职率高的团队，一个软件反复转手，后来者除了感情不深外。出了问题，也自然的会把所有的缺陷归罪于前人，包括设计和开发。一个反复转手的软件，必定会出现经典的“破窗效应”：“反正系统已经这么烂了，而且也不是我的责任，我既没有能力，也没有必要去矫正它。”于是，有了 bug，接手者自不会去认真研究问题的根源，而是倾向于用快速且肮脏的“打补丁”方式来解决。反正是先把问题摁住，至于整个系统是否会越来越腐败，管它呢？因此，整个软件系统最终呈现的就是补丁摞补丁的“垃圾场”。&lt;/p&gt;
&lt;h1 id=&#34;瀑布与增量&#34;&gt;瀑布与增量&lt;/h1&gt;
&lt;p&gt;由于软件具有很好的延展性，因此软件设计是一个贯穿软件系统整个生命周期的连续过程。这使得软件设计与诸如建筑物，船舶或桥梁的物理系统的设计不同。但是，并非总是以这种方式查看软件设计。在编程的大部分历史中，设计都集中在项目的开始，就像其他工程学科一样。这种方法的极端称为瀑布模型，该模型将项目划分为离散的阶段，例如需求定义，设计，编码，测试和维护。在瀑布模型中，每个阶段都在下一阶段开始之前完成；在许多情况下，每个阶段都由不同的人负责。在设计阶段，立即设计整个系统。&lt;/p&gt;
&lt;p&gt;不幸的是，瀑布模型很少适用于软件。软件系统本质上比物理系统复杂。在构建任何东西之前，不可能充分具象化出大型软件系统的设计，以了解其所有含义。结果，初始设计将有许多问题。在实施良好之前，问题不会变得明显。但是，瀑布模型的结构此时无法适应主要的设计更改（例如，设计师可能已转移到其他项目）。因此，开发人员尝试在不改变整体设计的情况下解决问题。这导致复杂性的爆炸式增长。&lt;/p&gt;
&lt;p&gt;由于这些问题，当今大多数软件开发项目都使用诸如敏捷开发之类的增量方法，其中初始设计着重于整体功能的一小部分。设计，实施和评估此子集。发现和纠正原始设计的问题，然后设计，实施和评估更多功能。每次迭代都会暴露现有设计的问题，这些问题在设计下一组功能之前就已得到解决。通过以这种方式扩展设计，可以在系统仍然很小的情况下解决初始设计的问题。较新的功能受益于较早功能的实施过程中获得的经验，因此问题较少。&lt;/p&gt;
&lt;p&gt;增量方法适用于软件，因为软件具有足够的延展性，可以在实施过程中进行重大的设计更改。相比之下，对物理系统而言，主要的设计更改更具挑战性：例如，在建筑过程中更改支撑桥梁的塔架数量不切实际。增量开发意味着永远不会完成软件设计。设计在系统的整个生命周期中不断发生：开发人员应始终在思考设计问题。增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的。经验不可避免地显示出更好的做事方式。作为软件开发人员，您应该始终在寻找机会来改进正在开发的系统的设计，并且应该计划将部分时间花费在设计改进上。&lt;/p&gt;
&lt;p&gt;如果软件开发人员应始终考虑设计问题，而降低复杂性是软件设计中最重要的要素，则软件开发人员应始终考虑复杂性。这本书是关于如何使用复杂性来指导软件设计的整个生命周期。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4.懒惰与隔阂</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/4.%E6%87%92%E6%83%B0%E4%B8%8E%E9%9A%94%E9%98%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/4.%E6%87%92%E6%83%B0%E4%B8%8E%E9%9A%94%E9%98%82/</guid>
      <description>&lt;h1 id=&#34;复杂性的来源&#34;&gt;复杂性的来源&lt;/h1&gt;
&lt;p&gt;复杂性不是凭空而来，很多时候也不是刻意为之，这也就意味着复杂性的增加往往不会以我们的主观意志为转移。就像房间里的大象，我们无法逃避，也不能视而不见，本节即来讨论复杂性的主要来源点可能有哪些。&lt;/p&gt;
&lt;h1 id=&#34;交互且无扩展性设计&#34;&gt;交互且无扩展性设计&lt;/h1&gt;
&lt;p&gt;当吸积效应导致的大规模系统，结合了交互这个特性，会使技术系统更加复杂。一个技术系统除了作用于自身，还会与其它大量系统产生交互。比如下单购买一件商品，那么订单系统，商品系统，支付系统，物流系统，卡券系统就会交互协作。这样吸积的复杂性，由于交互特性的出现，会呈现几何级数上升。交互带来两种特性：第一是互操作性。在搜索引擎上查询去某地怎么走，搜索引擎会告诉你打车需要多长时间，并提供一个打车按钮。第二是相互依赖性。比如下订单时需要使用优惠券，那么当卡券系统出现问题时就会影响订单系统。&lt;/p&gt;
&lt;p&gt;对于只有一个业务的简单场景，并不需要扩展，问题也不突出，这也是为什么这个点经常被忽略的原因，因为我们大部分的系统都是从单一业务开始的。但是随着支持的业务越来越多，代码里面开始出现大量的 if-else 逻辑，这个时候代码开始有坏味道，没闻到的同学就这么继续往上堆，闻到的同学会重构一下，但因为系统没有统一的可扩展架构，重构的技法也各不相同，这种代码的不一致性也是一种理解上的复杂度。久而久之，系统就变得复杂难维护。像典型的 CRM 应用，有 N 个业务方，每个业务方又有 N 个租户，如果都要用 if-else 判断业务差异，那简直就是惨绝人寰。其实这种扩展点（Extension Point），或者叫插件（Plug-in）的设计在架构设计中是非常普遍的。比较成功的案例有 eclipse 的 plug-in 机制，星环系统等。还有一个扩展性需求就是字段扩展，这一点对 SaaS 应用尤为重要，因为有很多客户定制化需求，但是我们很多系统也没有统一的字段扩展方案。&lt;/p&gt;
&lt;h1 id=&#34;不合理的业务封装&#34;&gt;不合理的业务封装&lt;/h1&gt;
&lt;p&gt;不合理的业务封装是一个相对宽泛的概念，其具体的表现譬如面向过程而不是对象、分层不合理等。面向对象不仅是一个语言，更是一种思维方式，但是很多时候我们更会用事务脚本的方式，面向过程地来编写代码。譬如 DDD 最大的好处是将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）将领域概念清晰的显性化表达出来。&lt;/p&gt;
&lt;p&gt;另一个不合理的业务封装，就是不合理的分层；俗话说，计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。分层最大的好处就是分离关注点，让每一层只解决该层关注的问题，从而将复杂的问题简化，起到分而治之的作用。但是，并非分层越多越好，过多的层次不仅不能带来好处，反而会增加系统的复杂性和降低系统性能。分层太多和没有分层都会导致系统复杂度的上升，因此我们的原则是不可以没有分层，但是只分有必要的层。&lt;/p&gt;
&lt;h1 id=&#34;缺乏统一语言&#34;&gt;缺乏统一语言&lt;/h1&gt;
&lt;p&gt;典型的敏捷开发的结构，流水线上的各个角色往往会专注于自己负责的环节，精细化的分工也限制了每个角色的全局视角；虽然我们经常提倡所谓的主人翁意识，但是在落地时又很难去推进。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/QNKPFZmf/image.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Model‐Driven Design is the process of binding an analysis model to a code implementation model, ensuring that both stay in sync and are useful during evolution.Model‐Driven Design differs from DDD in that it is focused on implementation and any constraints that may require changes to an initial model, whereas DDD focuses on language, collaboration, and domain knowledge.&lt;/p&gt;
&lt;p&gt;Historically, the capturing of requirements for software systems was seen as an activity that could occur long before coding was due to start. Business experts would talk to business analysts, who in turn would talk to architects, who would produce an analysis model based on all the information from the problem domain. This analysis model would then be handed over to the developers, along with wireframes and work flow diagrams, so they could build the system.&lt;/p&gt;
&lt;p&gt;As developers start to implement the analysis model in code, they often find a mismatch between the high‐level artifacts produced by architects and the reality of building the system. However, at this stage there is often no feedback loop for developers to talk to the business and architects, so the analysis model can be updated and their input enacted. Instead, the developers diverge from the analysis model, and their implementation often overlooks important and descriptive domain terms and concepts that would have provided deeper insight and understanding of the domain.&lt;/p&gt;
&lt;p&gt;As the development team further evolves away from the analysis model, it becomes less and less useful. Crucial insight into the model is lost as the development team focuses on abstracting technical concerns instead of business concepts. In the end the job gets done, but the code bears no reflection to the original analysis model. The business still believes the original analysis models are correct and is unaware of the alterations within the code model.&lt;/p&gt;
&lt;p&gt;事先设计（Upfront Design）的弊端在于，随着业务的变化，因为领域专家与技术人员有不同的模型理解，代码库会变得失去控制：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/pr4nn0Bc/image.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;缺乏约束与规范&#34;&gt;缺乏约束与规范&lt;/h1&gt;
&lt;p&gt;在团队协作开发的背景下，缺少规范和约束会严重损害架构的一致性（Consistency），代码的可维护性将急剧下降。可能规范在实现层面就是命名、分包等不影响代码运行的小问题，但是千里之堤，溃于蚁穴，正是这些微末的不注意导致了整体复杂性的雪崩。&lt;/p&gt;
&lt;p&gt;最好的约束就是在架构层面，通过 Lint 或者运行时检测的方式针对不符合规范的代码报错或者抛出异常。在架构的约束之外，我们还需要靠 Code Review 来随时发现不合适或者 Bad Smell 的代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>不确定的未来</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%AA%E6%9D%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%AA%E6%9D%A5/</guid>
      <description>&lt;h1 id=&#34;不确定性原则&#34;&gt;不确定性原则&lt;/h1&gt;
&lt;p&gt;频繁、不符预期的需求变更几乎是每个开发人员职业生涯中都会经历的，初期我们可能会觉得这种变更是偶然现象，但是随着用户量的增长、业务功能的变化，不确定性才是恒久存在的事实。因此，当我们在进行架构设计时，要能够从现有的需求，以及未来潜在的需求中寻找到确定性内核，并由内向外设计弹性可扩展的系统。不确定性原则能够帮我们更好地面对技术负债，其在项目管理上的体现类似于敏捷开发，其在技术架构上的落地类似于&lt;a href=&#34;https://ng-tech.icu/books/Backend-Series/#/?q=%e6%b5%8b%e8%af%95%e4%b8%8e%e9%ab%98%e5%8f%af%e7%94%a8%e4%bf%9d%e9%9a%9c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;测试与高可用保障&lt;/a&gt;中讨论的面向失败的设计原则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本节的很多思想参考了&lt;a href=&#34;http://www.10tiao.com/html/639/201812/2247488951/1.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阿里玄难：面向不确定性的软件设计几点思考&lt;/a&gt;这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;传统面向确定性的设计&#34;&gt;传统面向确定性的设计&lt;/h1&gt;
&lt;p&gt;在软件系统发展的早期，更多是提供各式各样的软件工具，帮助使用者进行信息化改造。其典型代表即 Excel，Word，以及典型的企业内部管理的信息系统，例如：企业流程审批、进销存管理系统等等。他们本质上是把原来的人工工作，用计算机软件来模拟，实现电子化，因此有个典型的特征：业务领域、软件职责和功能边界都相对清晰。因此最经典软件工程理论是瀑布模型：收集需求、画 UserCase、确定功能集合、模型抽象、概要设计、详细设计、编码、单元测试、集成测试、用户测试、上线运行。然后投入下一个版本的迭代。传统的软件开发大多数都是这种模式。这种模式特别强调文档质量和变更的全流程一致。&lt;/p&gt;
&lt;p&gt;在互联网服务时代，用计算机软件实现了靠人肉无法完成的能力，为人类社会提供了很多全新的服务能力。我们继承了传统的软件工程理论，也做了适度的改良。为了缩短版本迭代的时间，更快地验证产品想法获取用户，大多数团队采用敏捷模型。本质上是把需求批发模式变成了零售模式。这种模式最大的好处就是对产品需求的快速响应，但致命的是每次敏捷大多数情况下是在不断地打补丁，软件架构快速腐化。&lt;/p&gt;
&lt;p&gt;在前面这两个阶段的软件设计理论都有一个基本假设：软件边界是确定的，我们通过归纳总结和适度的预测（避免过度设计）来进行模型抽象。通过模型抽象，我们设计了各种可配置性来快速接入需求，提升效率，也就是我们常说的产品化。通过接口设计和模块化设计来进行组织分工协作。通过系统架构的开放性来应对不能配置的变化。&lt;/p&gt;
&lt;h1 id=&#34;确定性的内卷&#34;&gt;确定性的内卷&lt;/h1&gt;
&lt;p&gt;随着移动互联网，IOT，人工智能的发展，软件变成了社会的基础设施，也带来了更加剧烈的变化。我们所谓的变化往往来源于两个方面：用户量的爆发与业务功能的变更。用户量的爆发带来系统容量、可用性的挑战，通常是用分布式来解决，分布式数据库，分布式缓存、分布式服务，多机房多单元，CDN 等等。业务功能的变化，也即是通常说的系统可扩展性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过传统数据库的大字段或者 NoSQL，用元数据结合 K-V 存储的方式来应对数据信息的不确定性；&lt;/li&gt;
&lt;li&gt;通过流程引擎来满足工作流程的快速响应；&lt;/li&gt;
&lt;li&gt;通过规则引擎来代替程序中的大量 If-Else，实现界面配置来实现规则的变化。&lt;/li&gt;
&lt;li&gt;通过 UI 组件化，配合 UI 的编辑器来快速调整用户界面的变化。&lt;/li&gt;
&lt;li&gt;通过插件技术来将容易变化，且相对复杂的逻辑从主流程中剥离出来进行扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这样的背景下，业务是没有确定性边界的，是在不断在生长和变异。这样就没有确定性的软件外延。如果没有确定性的外延，而软件的运行又是需要确定性的，我们就只能去寻找确定性的内核。&lt;/p&gt;
&lt;p&gt;从逻辑推理的角度来说，传统软件工程是以归纳法为主，局部使用演绎法，而要面对外延不确定性的领域来看，需要找到稳定的内核基础，然后以演绎法为主，局部使用归纳法。我们先去寻找内核，内核向外生长和变异，原来的确定性是寻找外沿的确定，现在我们要寻找内核的确定。原来是归纳法，现在我们要演绎，找到不变的是什么，也可以说这是一种跨业务领域的更高阶的抽象。&lt;/p&gt;
&lt;h1 id=&#34;面向业务的对象化设计&#34;&gt;面向业务的对象化设计&lt;/h1&gt;
&lt;p&gt;在不确定性的背景下，我们需要从面向功能的组件化设计到面向业务的对象化设计。我们的世界可以按熵变化的方向，分为熵增的无机体和熵减的生命体。无机体是靠设计、图纸，自顶而下的层层分解细化设计，然后组件化拼装出来的。典型特征是标准组件化设计和批量生产来进行协同和提效。生命体，是由内而外的生长和变异的。虽然看上去是组件化的，但因为基因不同，事实上不同生命体是不可替换，会产生排异反应的。所有组成部分是在基因的控制下同步生长的。生命体的生长和变异是连续的。因此按抽象归纳，组件化设计的软件系统，随着业务发展，补丁越来越多，运行几年就会被推倒重来是它的宿命。&lt;/p&gt;
&lt;p&gt;典型的电商系统中，业务系统都是由组件化系统，例如购物车、店铺、详情、库存、交易、营销、资金、支付、结算、财务体系构成。所有的业务实现，其实是数据在这些组件系统中流动来实现的。在这个运行系统中，我们看不到天猫、淘宝、盒马、天猫超市、担保交易、预售、团购这些业务对象，反而是沉淀在了都体现在一个个分散的数据字段和 IfElse 中。&lt;/p&gt;
&lt;p&gt;我们的设计思路是，回归到业务本质，用对象化设计来让业务可生长、继承和变异。最基本的思路：整个系统的根基是业务。通过对象来去除兄弟之间的相互影响。核心控制性基因是不可变的，但新能力的创造就脱离父亲的影响能独立发展，也可以创造出新的子业务。&lt;/p&gt;
&lt;p&gt;同样地，在快速变化的背景下，我们很难用额外的文档去描述系统的设计、各层接口的实现。特别是对于软件开发人员，我们愈发地需要去遵循代码即文档的原则。在项目研发过程中所做的需求分析，概要设计，详细设计到最后的 Java 代码，其实就是业务逻辑到计算机世界的一次编译过程。这其中最大的问题就是人肉编译，而不是机器无差别编译，这个编译过程因人而异。因为这种不确定性，导致所有的设计文档随着时间的推移，与实际运行的代码之间产生不可弥合的鸿沟。一个业务系统的文档越来越没有用处，也就越来越没人写了。如果不能实现文档即代码，我们就不能留下真实可用的文档。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>复杂性定义</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E5%A4%8D%E6%9D%82%E6%80%A7%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E5%A4%8D%E6%9D%82%E6%80%A7%E5%AE%9A%E4%B9%89/</guid>
      <description>&lt;h1 id=&#34;复杂性定义&#34;&gt;复杂性定义&lt;/h1&gt;
&lt;p&gt;复杂性与软件系统的结构有关，这使它很难理解和修改系统。复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的。可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进；如果不引入其他错误，可能很难修复。如果一个软件系统难以理解和修改，那就很复杂；如果很容易理解和修改，那就很简单。在复杂的系统中，要实施甚至很小的改进都需要大量的工作；在一个简单的系统中，可以用更少的精力实现更大的改进。&lt;/p&gt;
&lt;p&gt;值得注意的是，复杂性不一定与系统的整体大小或功能有关；当然，实际上几乎所有大型复杂的软件系统都很难使用，因此它们也符合我对复杂性的定义，但这不一定是事实。小型而不复杂的系统也可能非常复杂。复杂性取决于代码库中最常打交道的那一部分，如果系统中有一些非常复杂的部分，但是几乎不需要触摸这些部分，那么它们对系统的整体复杂性不会有太大影响。可以用粗略的数学方法来表征：&lt;/p&gt;
&lt;p&gt;$$
C=\sum_{p} c_{p} t_{p}
$$&lt;/p&gt;
&lt;p&gt;系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。在一个永远不会被看到的地方隔离复杂性几乎和完全消除复杂性一样好。&lt;/p&gt;
&lt;h1 id=&#34;业务复杂度与技术复杂度&#34;&gt;业务复杂度与技术复杂度&lt;/h1&gt;
&lt;p&gt;业务复杂度对应了客户的业务需求，因而这种复杂度往往会随着需求规模的增大而增加，这也是本部分讨论复杂性的核心。技术复杂度来自需求的质量属性，诸如安全、高性能、高并发、高可用性等需求，为软件设计带来了极大的挑战，让人痛苦的是这些因素彼此之间可能又互相矛盾、互相影响。技术复杂度与业务复杂度并非完全独立，二者混合在一起产生的化合作用更让系统的复杂度变得不可预期，难以掌控&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s3.ax1x.com/2021/02/02/yn7XWV.png&#34; alt=&#34;技术复杂度与业务复杂度融合&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;技术复杂度则来自于对软件系统运行的质量需求，包括安全、高性能、高并发、高可用和高扩展性。系统安全性要求对访问进行控制，无论是加密还是认证和授权，都需要为整个系统架构添加额外的间接层。不仅对访问的低延迟产生影响，还极大提升了系统代码复杂度；为了让后端系统能具备高扩展性和弹性，要求所有系统的设计必须是无状态的；为了提升用户端访问体验，后端需要增添离线任务对数据加工、异构、预热、预缓存，以实现用空间换时间，降低实时接口的逻辑复杂度来降低请求的延迟。然而最让开发者更抓狂的是这些技术需求彼此又是相互影响甚至相互矛盾，在一些复杂流程并要求高响应的业务场景，如下单、秒杀等，会将一个同步的访问请求拆分为多级步骤的异步请求，再通过引入消息中间件对这些请求进行整合和分散处理，这种分离一方面增加了系统架构的复杂性，另一方面也因为引入了更多的资源，使得系统的高可用面临挑战，并增加了维护数据一致性的难度。而且技术复杂度与业务复杂度并非孤立，二者复杂度因子混合在一起产生的负作用更让系统的复杂度变得不可预期，难以掌控，就好比氢气和氯气混合在一起遇到光亮发生爆炸一样。&lt;/p&gt;
&lt;h1 id=&#34;complexity-symptoms--复杂性的症状&#34;&gt;Complexity Symptoms | 复杂性的症状&lt;/h1&gt;
&lt;p&gt;复杂性通过以下三种段落中描述的三种一般方式体现出来。这些表现形式中的每一个都使执行开发任务变得更加困难。&lt;/p&gt;
&lt;h2 id=&#34;变更放大change-amplification&#34;&gt;变更放大（Change amplification）&lt;/h2&gt;
&lt;p&gt;复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。例如，考虑一个包含几个页面的网站，每个页面显示带有背景色的横幅。在许多早期的网站中，颜色是在每个页面上明确指定的，如下图（a）所示。为了更改此类网站的背景，开发人员可能必须手动修改每个现有页面；对于拥有数千个页面的大型网站而言，这几乎是不可能的。幸运的是，现代网站使用的方法类似于下图（b），其中横幅颜色一次在中心位置指定，并且所有各个页面均引用该共享值。使用这种方法，可以通过一次修改来更改整个网站的标题颜色。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s3.ax1x.com/2020/11/28/DyAx00.png&#34; alt=&#34;网站更改示意&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上图中网站中的每个页面都显示一个彩色横幅。在（a）中，横幅的背景色在每页中都明确指定。在（b）中，共享变量保留背景色，并且每个页面都引用该变量。在（c）中，某些页面会显示其他用于强调的颜色，即横幅背景颜色的暗色；如果背景颜色改变，则强调颜色也必须改变。&lt;/p&gt;
&lt;h2 id=&#34;认知负荷cognitive-load&#34;&gt;认知负荷（Cognitive load）&lt;/h2&gt;
&lt;p&gt;复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。如果可以对系统进行重组，以使调用者不必担心释放内存（分配内存的同一模块也负责释放内存），它将减少认知负担。&lt;/p&gt;
&lt;p&gt;系统设计人员有时会假设可以通过代码行来衡量复杂性。他们认为，如果一个实现比另一个实现短，那么它必须更简单；如果只需要几行代码就可以进行更改，那么更改必须很容易。但是，这种观点忽略了与认知负荷相关的成本。我已经看到了仅允许使用几行代码编写应用程序的框架，但是要弄清楚这些行是什么极其困难。有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担。&lt;/p&gt;
&lt;h2 id=&#34;未知的未知unknown-unknowns&#34;&gt;未知的未知（Unknown unknowns）&lt;/h2&gt;
&lt;p&gt;复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。上图(c)说明了这个问题。网站使用一个中心变量来确定横幅的背景颜色，所以它看起来很容易改变。但是，一些 Web 页面使用较暗的背景色来强调，并且在各个页面中明确指定了较暗的颜色。如果背景颜色改变，那么强调的颜色必须改变以匹配。不幸的是，开发人员不太可能意识到这一点，所以他们可能会更改中央 bannerBg 变量而不更新强调颜色。即使开发人员意识到这个问题，也不清楚哪些页面使用了强调色，因此开发人员可能必须搜索 Web 站点中的每个页面。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在复杂性的三种表现形式中，未知的未知是最糟糕的。一个未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至是否有一个问题。你不会发现它，直到错误出现后，你做了一个改变。更改放大是令人恼火的，但是只要清楚哪些代码需要修改，一旦更改完成，系统就会工作。同样，高的认知负荷会增加改变的成本，但如果明确要阅读哪些信息，改变仍然可能是正确的。对于未知的未知，不清楚该做什么，或者提出的解决方案是否有效。唯一确定的方法是读取系统中的每一行代码，这对于任何大小的系统都是不可能的。甚至这可能还不够，因为更改可能依赖于一个从未记录的细微设计决策。&lt;/p&gt;
&lt;p&gt;良好设计的最重要目标之一就是使系统显而易见。这与高认知负荷和未知未知数相反。在一个显而易见的系统中，开发人员可以快速了解现有代码的工作方式以及进行更改所需的内容。一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>懒惰与隔阂</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E6%87%92%E6%83%B0%E4%B8%8E%E9%9A%94%E9%98%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E6%87%92%E6%83%B0%E4%B8%8E%E9%9A%94%E9%98%82/</guid>
      <description>&lt;h1 id=&#34;复杂性的来源&#34;&gt;复杂性的来源&lt;/h1&gt;
&lt;p&gt;复杂性不是凭空而来，很多时候也不是刻意为之，这也就意味着复杂性的增加往往不会以我们的主观意志为转移。就像房间里的大象，我们无法逃避，也不能视而不见，本节即来讨论复杂性的主要来源点可能有哪些。&lt;/p&gt;
&lt;h1 id=&#34;交互且无扩展性设计&#34;&gt;交互且无扩展性设计&lt;/h1&gt;
&lt;p&gt;当吸积效应导致的大规模系统，结合了交互这个特性，会使技术系统更加复杂。一个技术系统除了作用于自身，还会与其它大量系统产生交互。比如下单购买一件商品，那么订单系统，商品系统，支付系统，物流系统，卡券系统就会交互协作。这样吸积的复杂性，由于交互特性的出现，会呈现几何级数上升。交互带来两种特性：第一是互操作性。在搜索引擎上查询去某地怎么走，搜索引擎会告诉你打车需要多长时间，并提供一个打车按钮。第二是相互依赖性。比如下订单时需要使用优惠券，那么当卡券系统出现问题时就会影响订单系统。&lt;/p&gt;
&lt;p&gt;对于只有一个业务的简单场景，并不需要扩展，问题也不突出，这也是为什么这个点经常被忽略的原因，因为我们大部分的系统都是从单一业务开始的。但是随着支持的业务越来越多，代码里面开始出现大量的 if-else 逻辑，这个时候代码开始有坏味道，没闻到的同学就这么继续往上堆，闻到的同学会重构一下，但因为系统没有统一的可扩展架构，重构的技法也各不相同，这种代码的不一致性也是一种理解上的复杂度。久而久之，系统就变得复杂难维护。像典型的 CRM 应用，有 N 个业务方，每个业务方又有 N 个租户，如果都要用 if-else 判断业务差异，那简直就是惨绝人寰。其实这种扩展点（Extension Point），或者叫插件（Plug-in）的设计在架构设计中是非常普遍的。比较成功的案例有 eclipse 的 plug-in 机制，星环系统等。还有一个扩展性需求就是字段扩展，这一点对 SaaS 应用尤为重要，因为有很多客户定制化需求，但是我们很多系统也没有统一的字段扩展方案。&lt;/p&gt;
&lt;h1 id=&#34;不合理的业务封装&#34;&gt;不合理的业务封装&lt;/h1&gt;
&lt;p&gt;不合理的业务封装是一个相对宽泛的概念，其具体的表现譬如面向过程而不是对象、分层不合理等。面向对象不仅是一个语言，更是一种思维方式，但是很多时候我们更会用事务脚本的方式，面向过程地来编写代码。譬如 DDD 最大的好处是将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）将领域概念清晰的显性化表达出来。&lt;/p&gt;
&lt;p&gt;另一个不合理的业务封装，就是不合理的分层；俗话说，计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。分层最大的好处就是分离关注点，让每一层只解决该层关注的问题，从而将复杂的问题简化，起到分而治之的作用。但是，并非分层越多越好，过多的层次不仅不能带来好处，反而会增加系统的复杂性和降低系统性能。分层太多和没有分层都会导致系统复杂度的上升，因此我们的原则是不可以没有分层，但是只分有必要的层。&lt;/p&gt;
&lt;h1 id=&#34;缺乏统一语言&#34;&gt;缺乏统一语言&lt;/h1&gt;
&lt;p&gt;典型的敏捷开发的结构，流水线上的各个角色往往会专注于自己负责的环节，精细化的分工也限制了每个角色的全局视角；虽然我们经常提倡所谓的主人翁意识，但是在落地时又很难去推进。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/QNKPFZmf/image.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Model‐Driven Design is the process of binding an analysis model to a code implementation model, ensuring that both stay in sync and are useful during evolution.Model‐Driven Design differs from DDD in that it is focused on implementation and any constraints that may require changes to an initial model, whereas DDD focuses on language, collaboration, and domain knowledge.&lt;/p&gt;
&lt;p&gt;Historically, the capturing of requirements for software systems was seen as an activity that could occur long before coding was due to start. Business experts would talk to business analysts, who in turn would talk to architects, who would produce an analysis model based on all the information from the problem domain. This analysis model would then be handed over to the developers, along with wireframes and work flow diagrams, so they could build the system.&lt;/p&gt;
&lt;p&gt;As developers start to implement the analysis model in code, they often find a mismatch between the high‐level artifacts produced by architects and the reality of building the system. However, at this stage there is often no feedback loop for developers to talk to the business and architects, so the analysis model can be updated and their input enacted. Instead, the developers diverge from the analysis model, and their implementation often overlooks important and descriptive domain terms and concepts that would have provided deeper insight and understanding of the domain.&lt;/p&gt;
&lt;p&gt;As the development team further evolves away from the analysis model, it becomes less and less useful. Crucial insight into the model is lost as the development team focuses on abstracting technical concerns instead of business concepts. In the end the job gets done, but the code bears no reflection to the original analysis model. The business still believes the original analysis models are correct and is unaware of the alterations within the code model.&lt;/p&gt;
&lt;p&gt;事先设计（Upfront Design）的弊端在于，随着业务的变化，因为领域专家与技术人员有不同的模型理解，代码库会变得失去控制：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/pr4nn0Bc/image.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;缺乏约束与规范&#34;&gt;缺乏约束与规范&lt;/h1&gt;
&lt;p&gt;在团队协作开发的背景下，缺少规范和约束会严重损害架构的一致性（Consistency），代码的可维护性将急剧下降。可能规范在实现层面就是命名、分包等不影响代码运行的小问题，但是千里之堤，溃于蚁穴，正是这些微末的不注意导致了整体复杂性的雪崩。&lt;/p&gt;
&lt;p&gt;最好的约束就是在架构层面，通过 Lint 或者运行时检测的方式针对不符合规范的代码报错或者抛出异常。在架构的约束之外，我们还需要靠 Code Review 来随时发现不合适或者 Bad Smell 的代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>吸积与持续迭代</title>
      <link>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E5%90%B8%E7%A7%AF%E4%B8%8E%E6%8C%81%E7%BB%AD%E8%BF%AD%E4%BB%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/architecture-series/0.%E5%A4%8D%E6%9D%82%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90/%E5%90%B8%E7%A7%AF%E4%B8%8E%E6%8C%81%E7%BB%AD%E8%BF%AD%E4%BB%A3/</guid>
      <description>&lt;h1 id=&#34;吸积与持续迭代&#34;&gt;吸积与持续迭代&lt;/h1&gt;
&lt;p&gt;复杂度是递增的，并不是某些特定事物让系统复杂，而是数十或数百个小事物的积累。&lt;/p&gt;
&lt;p&gt;吸积效应，即一个事物的生成过程，就是从一个核心开始，逐步吸附新的资源，渐渐积累而形成的。这本来是天文学上的一个词，用来解释星体的形成。比如太阳是从一个核心，逐渐吸收周围的宇宙物质逐渐形成的。&lt;/p&gt;
&lt;p&gt;从字面上我们可以理解为吸附和积累。每次加一点，每次加一点，最后就有了一大堆。这句话来描述吸积效应最好不过，出自 1975 年出版的《人月神话》。无论一次代码迭代和升级看上去是多么独立，客观上导致的结果就是代码量从一点点变成一大堆，遗留代码和遗留系统就是这样形成的。遗留代码到底有什么问题？吸积效应导致代码十分庞大，没有人可以完全了解这个系统。当系统出现问题时，最了解这部分代码的人可能已经离职而杳无音讯。&lt;/p&gt;
&lt;p&gt;软件本身如此易变（Malleable），因此软件设计是持续的过程，贯穿软件系统的整个生命周期。软件设计的这个特点，使它和现实世界中实体系统(例如建筑，船舶，桥梁)的设计差异很大。然而，人们并不是从一开始就认可软件设计设计的持续性特点。在软件开发历史上很大一部分时间里，设计被认为和其他的工程一样：设计过程集中在项目的开始阶段.这种方式的一个极端就是瀑布式开发模型。在这个模型中，项目被划分为分离（Discrete）的各个阶段:需求分析，设计，编码，测试和维护，前一个阶段在下一个阶段开始前结束，并且很多场景下，不同人负责不同的阶段。整个系统的设计工作在设计阶段一次性完成，这个阶段结束后，设计就冻结了。后面的各个阶段就是逐步实现设计的过程.&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/YSt6fs1h/image.png&#34; alt=&#34;软件复杂性随着时间增加的衍化&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不幸的是，瀑布流开发模型很少在软件开发中有效。软件系统比其他实体系统内在（Intrinsically）复杂性更高.大型软件系统，很难在开发前设想清楚系统设计个各个方面和准确理解各个设计决策的影响。结果是，初始的设计会有很多问题，这些问题一开始并不明显，在实现的过程中才变得更加清晰。瀑布开发模型没有组织上的保障来适应这种设计变化(例如:软件设计人员可能已经调整到其他项目上). 因此，开发人员尝试在不修改整体设计的前提下，通过补丁（Patch）的方式来修复问题.这导致复杂性的爆炸性增长.&lt;/p&gt;
&lt;p&gt;因为有这些问题，今天大部分软件开发项目采用了增量式开发模式(例如敏捷开发模式)。在这种模式下，初始的设计聚焦在整体功能的一小部分上进行设计，实现和评估。初始设计的问题逐步被发现，并被纠正。随后更多的功能点被设计，实现和评估。每个迭代都暴露已有设计的问题，这些问题在下一个功能集的设计前得到解决。通过将设计的分散（Spread Out），初始设计的问题能够在系统还很小的阶段得到修复。得益于初始阶段获得的经验，后续功能设计问题会更少.&lt;/p&gt;
&lt;p&gt;这种增量式开发模型之所以有效，是因为软件系统具有足够的可塑性（Malleable），使得在软件开发的中途进行重大的设计变更是可行的。做为对比来看，在实现过程中对实体系统的重大设计进行变更往往更有挑战。例如，在建筑过程中，增加/减少支撑桥梁的支柱的数量是不可行的。&lt;/p&gt;
&lt;p&gt;增量式设计意味着软件设计永不结束。设计在系统的生命周期中持续发生:程序员要时刻考虑设计问题。增量开发也意味着持续重构。一个系统的初始设计几乎从来都不是最好的方案。随着经验的增加，必然会发现更好的设计方案。作为程序员，你需要时刻寻找机会来改进当前系统的设计，并且你也需要设计改进做计划，预留时间。遵从 John Ousterhout 老爷子的指导，作为程序员对设计和代码保留着必要的&amp;quot;洁癖&amp;quot;,不断追求更好的设计，在面临&amp;quot;将就&amp;quot;和&amp;quot;重构&amp;quot;的时候会做出更好的选择。&lt;/p&gt;
&lt;h1 id=&#34;腐败的软件系统&#34;&gt;腐败的软件系统&lt;/h1&gt;
&lt;p&gt;大项目的陷阱是，随着时间的推移，它们会变得非常复杂，以至于重写比培养新人来理解代码然后修改要容易得多。软件是纯粹脑力劳动的结果，极度依赖软件工程师本人。因此，软件的交接就不简单是生产工具的交接，更是知识的传递。而只要有知识的传递就必然有丢失，有变形。因此一个离职频繁的团队，知识的反复交接，必然会丢失大量的细节，以致于到最后，接手的程序员对系统的理解是面目全非。&lt;/p&gt;
&lt;p&gt;而且最严重的不仅是知识的丢失，更有责任心的丢失。如果一个模块是由某个软件工程师一手开发并维护。在感情上，他自然的倾向于爱惜羽毛，认真对待。在责任上，他也无可推卸，因为这一切都源于他。但是，在一个离职率高的团队，一个软件反复转手，后来者除了感情不深外。出了问题，也自然的会把所有的缺陷归罪于前人，包括设计和开发。一个反复转手的软件，必定会出现经典的“破窗效应”：“反正系统已经这么烂了，而且也不是我的责任，我既没有能力，也没有必要去矫正它。”于是，有了 bug，接手者自不会去认真研究问题的根源，而是倾向于用快速且肮脏的“打补丁”方式来解决。反正是先把问题摁住，至于整个系统是否会越来越腐败，管它呢？因此，整个软件系统最终呈现的就是补丁摞补丁的“垃圾场”。&lt;/p&gt;
&lt;h1 id=&#34;瀑布与增量&#34;&gt;瀑布与增量&lt;/h1&gt;
&lt;p&gt;由于软件具有很好的延展性，因此软件设计是一个贯穿软件系统整个生命周期的连续过程。这使得软件设计与诸如建筑物，船舶或桥梁的物理系统的设计不同。但是，并非总是以这种方式查看软件设计。在编程的大部分历史中，设计都集中在项目的开始，就像其他工程学科一样。这种方法的极端称为瀑布模型，该模型将项目划分为离散的阶段，例如需求定义，设计，编码，测试和维护。在瀑布模型中，每个阶段都在下一阶段开始之前完成；在许多情况下，每个阶段都由不同的人负责。在设计阶段，立即设计整个系统。&lt;/p&gt;
&lt;p&gt;不幸的是，瀑布模型很少适用于软件。软件系统本质上比物理系统复杂。在构建任何东西之前，不可能充分具象化出大型软件系统的设计，以了解其所有含义。结果，初始设计将有许多问题。在实施良好之前，问题不会变得明显。但是，瀑布模型的结构此时无法适应主要的设计更改（例如，设计师可能已转移到其他项目）。因此，开发人员尝试在不改变整体设计的情况下解决问题。这导致复杂性的爆炸式增长。&lt;/p&gt;
&lt;p&gt;由于这些问题，当今大多数软件开发项目都使用诸如敏捷开发之类的增量方法，其中初始设计着重于整体功能的一小部分。设计，实施和评估此子集。发现和纠正原始设计的问题，然后设计，实施和评估更多功能。每次迭代都会暴露现有设计的问题，这些问题在设计下一组功能之前就已得到解决。通过以这种方式扩展设计，可以在系统仍然很小的情况下解决初始设计的问题。较新的功能受益于较早功能的实施过程中获得的经验，因此问题较少。&lt;/p&gt;
&lt;p&gt;增量方法适用于软件，因为软件具有足够的延展性，可以在实施过程中进行重大的设计更改。相比之下，对物理系统而言，主要的设计更改更具挑战性：例如，在建筑过程中更改支撑桥梁的塔架数量不切实际。增量开发意味着永远不会完成软件设计。设计在系统的整个生命周期中不断发生：开发人员应始终在思考设计问题。增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的。经验不可避免地显示出更好的做事方式。作为软件开发人员，您应该始终在寻找机会来改进正在开发的系统的设计，并且应该计划将部分时间花费在设计改进上。&lt;/p&gt;
&lt;p&gt;如果软件开发人员应始终考虑设计问题，而降低复杂性是软件设计中最重要的要素，则软件开发人员应始终考虑复杂性。这本书是关于如何使用复杂性来指导软件设计的整个生命周期。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
