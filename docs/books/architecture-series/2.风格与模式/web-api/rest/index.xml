<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>REST | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/</link><atom:link href="https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/index.xml" rel="self" type="application/rss+xml"/><description>REST</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>REST</title><link>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/</link></image><item><title>Microsoft API 设计标准</title><link>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/microsoft-api-%E8%AE%BE%E8%AE%A1%E6%A0%87%E5%87%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/microsoft-api-%E8%AE%BE%E8%AE%A1%E6%A0%87%E5%87%86/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#63-silent-fail-rule" target="_blank" rel="noopener">原文地址 :Microsoft API Guidelines&lt;/a> &amp;gt;&lt;a href="https://github.com/wx-chevalier/just-coder-handbook/#restful" target="_blank" rel="noopener">笔者有关于 REST 系列文章&lt;/a> 笔者之前翻译过一篇&lt;a href="https://segmentfault.com/a/1190000005924733" target="_blank" rel="noopener">来自于 PayPal 的 RESTful API 标准&lt;/a>，其是 PayPal 内部遵循的 RESTful 的接口规范，本文则是微软提出的 API 风格指南，笔者认为二者各有优劣。微软的准则相对更加详细严谨，但是对于复杂资源请求，却没有 PayPal 提及的多。本文目前仅包含第一部分的翻译，笔者日后为添加上第二部分。&lt;/p>
&lt;/blockquote>
&lt;p>微软云平台为开发者提供了基于 HTTP 的 REST 风格的 API 接口，虽然不同的服务都是基于特定语言的一些请求框架的实现，但是基于 HTTP 的 REST 的操作却是遵循一致的规则。本指南的目的即是提供可以使得任何的 HTTP 客户端能够以相同的行为模式与规范来使用的接口。而保障开发者的一致性体验的关键，即是保证 REST API 遵循统一的设计指南，从而简单易用，符合人们的直觉反应。本指南的目标在于&lt;/p>
&lt;ul>
&lt;li>为 Microsoft 提供的所有 REST 风格的 Endpoints 都遵循一直的实践模式&lt;/li>
&lt;li>尽可能与目前产业界中大规模使用的 REST/HTTP 的最佳实践相符合&lt;/li>
&lt;li>保证所有使用 Microsoft 服务的应用开发者能够方便快捷地基于 REST 接口进行访问&lt;/li>
&lt;li>允许服务开发者能够基于之前的工作快速搭建新的接口&lt;/li>
&lt;li>允许所有的非 Microsoft 合作者也能使用这些规范&lt;/li>
&lt;/ul>
&lt;p>在正式介绍本指南之前，推荐阅读如下一些参考资料&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">RFC 2616&lt;/a> &amp;ndash; HTTP/1.1 的细节定义&lt;/li>
&lt;li>&lt;a href="http://www.amazon.com/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829/" target="_blank" rel="noopener">REST in Practice&lt;/a> &amp;ndash; 基于 REST 的实践指南&lt;/li>
&lt;li>&lt;a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">REST on Wikipedia&lt;/a> &amp;ndash; 维基百科上关于 REST 的核心概念与思想的介绍&lt;/li>
&lt;/ul>
&lt;h1 id="taxonomy">Taxonomy&lt;/h1>
&lt;p>作为 Microsoft REST API 指南的一部分，服务需要遵从如下的分类。&lt;/p>
&lt;h2 id="errors-错误">Errors: 错误&lt;/h2>
&lt;p>Errors，或者更准确地说，Service Errors，被定义为因为客户端将错误的数据传递给了服务端而导致服务端拒绝该请求。典型的譬如无效的认证状态、错误的参数、未知的版本 ID 等等。一般来说，服务端会以&lt;code>4xx&lt;/code>系列的 HTTP 错误码来进行响应，注意，Errors 并不会影响整体的 API 可用性。&lt;/p>
&lt;h2 id="faults-故障">Faults: 故障&lt;/h2>
&lt;p>Faults，或者说是 Service Faults，被定义为因为服务端内部错误而导致的无法准确对客户端进行响应，一般来说，服务端会以&lt;code>5xx&lt;/code>系列的 HTTP 错误码进行响应。不同于 Errors，Faults 一定会影响整体的 API 可用性。需要注意的是，因为限流导致的拒绝服务不可以被归类到 Faults。&lt;/p>
&lt;h2 id="latency-延迟">Latency: 延迟&lt;/h2>
&lt;p>延迟，即是指某个 API 从请求到响应完成所需要的时间，一般来说我们会在客户端测试该值。对于同步请求与异步请求的测试方法应该保持一致，对于异步响应的请求应该计算从初始请求发出的时间点到最终响应完成的时间点。&lt;/p>
&lt;h2 id="time-to-complete">Time To Complete&lt;/h2>
&lt;p>提供慢操作的服务必须要追踪&lt;code>Time To Complete&lt;/code>这个测量标准。&lt;/p>
&lt;h2 id="long-running-api-faults">Long Running API Faults&lt;/h2>
&lt;p>对于长期运行的 API( 这里的 Long Running API 即指那些异步响应的 API)，极有可能在初始化请求与获取结果的请求时都收到 200 的状态码，但是实际上内部的操作却触发了错误。这些错误需要被纳入对于整体可用性的测量。&lt;/p>
&lt;h1 id="client-guidence-客户端指南">Client Guidence: 客户端指南&lt;/h1>
&lt;p>为了保证客户端能够较好地接入 REST 服务，同样我们建议客户端也需要遵循一些最佳实践。&lt;/p>
&lt;h2 id="ignore-rule-忽略原则">Ignore Rule: 忽略原则&lt;/h2>
&lt;p>对于松耦合的客户单而言，在真实地获取到数据之前是不知道数据的确切结构的，如果服务端返回了一些并不是客户端所需要的数据，那么客户端应该安全地忽略这些意外的数据。另外在服务端迭代的过程中，可能有部分服务端会添加些额外的域，对于老的客户端而言可能并不需要这些域，从客户端的角度应该选择性地忽略这些域，而服务端必须要在文档中进行注明。&lt;/p>
&lt;h2 id="variable-order-rule-变量排序原则">Variable Order Rule: 变量排序原则&lt;/h2>
&lt;p>客户端在处理服务端的返回数据时，一定不能依赖于返回的 JSON 数据中的键的顺序，换言之，即使服务端以随机顺序发送回了 JSON 对象，客户端也要能够成功处理。而对于一些特殊的服务端支持的以&lt;code>$orderBy&lt;/code>关键字来对返回的 JSON 数组中的元素进行排序的时候，服务端必须在接口文档中显式地说明规范。&lt;/p>
&lt;h2 id="slient-fail-rule">Slient Fail Rule&lt;/h2>
&lt;p>如果客户端是使用服务端提供的一些可选功能，譬如可能发送一些自定义的头部请求项，那么客户端必须要能够在服务器可能无法提供这些可选功能的情况下依然正常工作。&lt;/p>
&lt;h1 id="rest-consistency-fundamentals">REST Consistency Fundamentals&lt;/h1>
&lt;h2 id="url-structure">URL Structure&lt;/h2>
&lt;p>URL 必须保证友好的可读性与可构造性，这有助于对于那些尚未较好支持地客户端提供探索与尽快采用的便捷性。一个典型的较好的 URL 结构如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>https://api.contoso.com/v1.0/people/jdoe@contoso.com/inbox
&lt;/code>&lt;/pre>&lt;p>而与之相反的，一个可读性较差的 URL 为&lt;/p>
&lt;pre tabindex="0">&lt;code>https://api.contoso.com/EWS/OData/Users(&amp;#39;jdoe@microsoft.com&amp;#39;)/Folders(&amp;#39;AAMkADdiYzI1MjUzLTk4MjQtNDQ1Yy05YjJkLWNlMzMzYmIzNTY0MwAuAAAAAACzMsPHYH6HQoSwfdpDx-2bAQCXhUk6PC1dS7AERFluCgBfAAABo58UAAA=&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>另一个常用的模式就是将某个 URL 作为参数值传递过去，譬如&lt;/p>
&lt;pre tabindex="0">&lt;code>https://api.contoso.com/v1.0/items?url=https://resources.contoso.com/shoes/fancy
&lt;/code>&lt;/pre>&lt;h2 id="url-长度">URL 长度&lt;/h2>
&lt;p>HTTP 1.1 协议，在 RFC 2616 的&lt;a href="http://tools.ietf.org/html/rfc2616#section-3.2.1" target="_blank" rel="noopener">3.2.1&lt;/a>章节中规定了 URL 长度的限制&lt;/p>
&lt;blockquote>
&lt;p>HTTP 协议本身不会对 URL 长度有任何限制，服务端必须要能够处理任何有效的 URL，并且对于基于 GET 的过长请求也要能够有效处理。当 URL 过长导致服务端无法处理时，服务端应该返回 414 号错误码。&lt;/p>
&lt;/blockquote>
&lt;p>注意，Internet Explorer 浏览器对于生成的 URL 长度会有限制，请服务端注意。&lt;/p>
&lt;h2 id="canonical-identifier-标准的标识符">Canonical Identifier: 标准的标识符&lt;/h2>
&lt;p>除了需要提供友好的 URL 之外，能够被移动或者重命名的资源必须要包含唯一且稳定的标识符。注意，系统中并不会强制要求以 GUID 作为标识符，典型的包含统一标识符的 URL 如下&lt;/p>
&lt;pre tabindex="0">&lt;code>https://api.contoso.com/v1.0/people/7011042402/inbox
&lt;/code>&lt;/pre>&lt;h2 id="supported-verbs-支持的动词">Supported Verbs: 支持的动词&lt;/h2>
&lt;p>客户端必须要以合适的 HTTP 动词来执行某些操作，并且必须要考虑是否支持动词的幂等性。下表是在 Microsoft REST 服务中支持的动词，并不一定是所有的资源都支持全部的动词，不过任何动词都需要满足以下约定 : | Verb | 描述 | 是否幂等 | | &amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | | GET | 返回某个对象的当前值 | True | | PUT | 用于替换某个对象或者创建某个命名对象 | True | | DELETE | 删除某个对象 | True | | POST | 基于提供的数据创建对象，或者提交某个命令操作 | False | | HEAD | 返回某个对象的元信息 l | True | | PATCH | 更新对象的部分属性值 | False | | OPTIONS | 获取某个请求的部分信息 | False |&lt;/p>
&lt;h3 id="post">POST&lt;/h3>
&lt;p>POST 操作必须返回创建好的对象的访问链接，譬如我们有个服务是允许用户创建自建的云服务器，请求方式可能如下&lt;/p>
&lt;pre tabindex="0">&lt;code>POST http://api.contoso.com/account1/servers
&lt;/code>&lt;/pre>&lt;p>响应值应该是如下这样&lt;/p>
&lt;pre tabindex="0">&lt;code>201 Created
Location: http://api.contoso.com/account1/servers/server321
&lt;/code>&lt;/pre>&lt;h3 id="利用-patcg-创建资源">利用 PATCG 创建资源&lt;/h3>
&lt;p>允许客户端在创建资源的时候只指定部分键值数据的必须支持 UPSET 语法，并且必须支持以 PATCH 动词来创建资源。鉴于 PUT 一般用于对于整个资源的内容的替换，直接允许客户端使用 PUT 进行更新会非常危险。一旦客户端不小心忽略了某些值，那么可能在更新资源时这些原值会被丢失。因此，所有支持 PUT 动词的操作都必须使用用户提交的属性来替换原有属性，而对于用户在请求中未提交的属性则要直接置空，即保证对服务端保留的原有属性务必全部删除。在 UPSET 语法下，对于不存在的资源的 PATCH 操作会被视作创建，而对于已存在资源的操作会被视作更新。为了避免服务端误解客户端的真实意图，客户端必须要在请求头中以一些额外参数注明。如果请求头中包含了 If-Match，那么该 PATCH 操作绝不会当做创建操作。如果请求头中包含了 If-None-Match，那么 PATCH 操作绝不能视作更新操作。如果某个服务端不支持 UPSET，那么对于不存在资源的 PATCH 操作应该返回&lt;code>409 Conflict&lt;/code>.&lt;/p>
&lt;h3 id="options-and-link-headers">OPTIONS and Link Headers&lt;/h3>
&lt;p>OPTIONS 操作允许客户端查询某个对象的元信息，至少需要返回该资源支持的动词类别。除以之外，建议是在返回时也包含上一个辅助文档的地址，譬如&lt;/p>
&lt;pre tabindex="0">&lt;code>Link: {help}; rel=&amp;#34;help&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="standard-request-headers-标准请求头">Standard Request Headers: 标准请求头&lt;/h2>
&lt;p>所有遵循 Microsoft REST API 指南的服务都需要支持如下的请求头 : | Header | Type | Description | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | | Authorization | String | 请求的认证头 | | Date | Date | &lt;a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339&lt;/a> 格式的时间戳 | | Accept | Content type | 请求的资源类型 : application/xml text/xml application/json text/javascript (for JSONP) | | Accept-Encoding | Gzip, deflate | REST 端必须支持 GZIP 与 DEFLATE 编码，对于大型资源的请求，服务端可以忽略未压缩的请求。| | Accept-Language | &amp;ldquo;en&amp;rdquo;, &amp;ldquo;es&amp;rdquo;, etc. | 指定响应的偏好语言，对于那些支持国际化的服务端必须要处理该请求头。| | Accept-Charset | Charset type like &amp;ldquo;UTF-8&amp;rdquo; | 默认是 UTF-8, 但是服务端也要能处理 ISO-8859-1。| | Content-Type | Content type | 请求体的 MIME 类型 (PUT/POST/PATCH) | | Prefer | return=minimal, return=representation | 如果指定了 return=minimal，服务端对于插入或者修改操作应该返回一个空的响应体。如果指定了 return=representation，服务端应该在响应时返回创建好的或者更新后的资源。当部分客户端希望能够较好的带宽利用与响应时间时，服务端应该支持该请求头。| | If-Match, If-None-Match, If-Range | String | 支持对于资源的优化的并发更新控制的必须要支持该请求头，也可以使用 ETags 等其他的头信息来进行缓存操作。|&lt;/p>
&lt;h2 id="standard-response-headers">Standard Response Headers&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Response Header&lt;/th>
&lt;th>Required&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Date&lt;/td>
&lt;td>All responses&lt;/td>
&lt;td>请求的处理完成的时间，以 &lt;a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339&lt;/a> 格式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Content-Type&lt;/td>
&lt;td>All responses&lt;/td>
&lt;td>The content type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Content-Encoding&lt;/td>
&lt;td>All responses&lt;/td>
&lt;td>GZIP 或者 DEFLATE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Preference-Applied&lt;/td>
&lt;td>When specified in request&lt;/td>
&lt;td>Whether a preference indicated in the Prefer request header was applied&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ETag&lt;/td>
&lt;td>当请求的资源包含资源体时&lt;/td>
&lt;td>包含当前资源的版本信息，与 If-Match 等协同进行并发控制&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="custom-headers-自定义请求头">Custom Headers: 自定义请求头&lt;/h2>
&lt;p>对于某些给定 API 的基本操作不应该支持自定义的请求头。对于一些需要额外数据的服务应该支持自定义的请求头。不过自定义的非标准的请求头应该遵循如下的规范&lt;/p>
&lt;ul>
&lt;li>RFC 3864 中暂定为临时的请求头格式&lt;/li>
&lt;li>请求头应该尽可能地符合使用场景&lt;/li>
&lt;/ul>
&lt;h2 id="specifying-headers-as-query-parameters-以查询参数方式提交自定义请求头">Specifying Headers as Query Parameters: 以查询参数方式提交自定义请求头&lt;/h2>
&lt;p>很多时候在进行 Ajax 请求，特别是跨域请求时部分自定义的请求头可能无法被支持。在这种情况下，我们应该允许将部分请求头作为查询参数传递给服务端，并且要保证查询参数中的名称与请求头中的名称保持一致。不过该规则有个特例就是 Accept 字段，一般在请求参数中会使用缩写的方式来表明请求的是 XML 还是 JSON 或者其他类型。&lt;/p>
&lt;h2 id="pii-parameters-个人认证信息">PII Parameters: 个人认证信息&lt;/h2>
&lt;p>鉴于通行的安全与隐私性保护原则，所有关于个人认证的信息不应该放置在 URL 中，即以路径或者查询参数的方式进行传递。因为该信息非常容易在客户端或者网络乃至于服务器的日志文件中被窃取。我们推荐的是所有 PII 类型的信息都应该放在请求头中进行传递，不过，在实践中我们也发现很多时候这些参数无法被放置在请求头中，因此服务端也应该保证能够在查询参数中去获取这些 PII 信息。而对于服务端获取到的 PII 信息，开发者应该严格遵循公司的隐私保护原则，并且建议客户端以加密的方式等等来避免信息泄露。&lt;/p>
&lt;h2 id="response-formats-响应格式">Response Formats: 响应格式&lt;/h2>
&lt;p>成功的平台总是相似的，它们往往会提供可读性较好并且一致的响应结果，从而使开发者能够尽可能地复用代码来进行响应处理。一般在基于 Web 的通信环境下，特别是移动端或者其他低带宽的环境下，我们推荐使用 JSON 作为传输格式，这一点也特别适用于那些基于 JavaScript 的客户端。注意，JSON 中的属性名应该是 camelCased，并且服务端应该默认使用 JSON 作为编码格式。&lt;/p>
&lt;h3 id="client-specified-response-format">Client Specified Response Format&lt;/h3>
&lt;p>在 HTTP 中，响应的请求格式应该由客户端使用 Accept 属性来决定。如果客户单发送了多种格式请求，那么服务端应当选择其中的一个作为标准。默认的响应格式应该是&lt;code>application/json&lt;/code>，并且所有的服务端都应该支持&lt;code>application/json&lt;/code>: | Accept Header | Response type | Notes | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | | application/json | Payload SHOULD be returned as JSON | Also accept text/javascript for JSONP cases |&lt;/p>
&lt;pre tabindex="0">&lt;code>GET https://api.contoso.com/v1.0/products/user
Accept: application/json
&lt;/code>&lt;/pre>&lt;h3 id="error-condition-response">Error Condition Response&lt;/h3>
&lt;p>对于非成功的场景，开发者应该能够以相同的代码库来处理不同的 REST API 返回的错误信息。这样有助于在正常的处理流程之外构建独立的稳定的架构来处理错误情形，下面这个例子基于 OData v4 JSON 标准。我们推荐任何服务端都应该遵循该标准。错误响应必须是单个 JSON 对象，该对象含有唯一的键名&lt;code>error&lt;/code>，而值也是一个 JSON 对象。该对象应该包含键值对，包含&lt;code>code&lt;/code>、&lt;code>message&lt;/code>，并且建议包含譬如&lt;code>target&lt;/code>、&lt;code>details&lt;/code>、&lt;code>innererror&lt;/code>这些信息。code 属性应该是一个与语言无关的字符串，是一个由服务端定义的可读的说明信息。与 HTTP 状态码相比，code 应该指向的更加具体。服务端应该保持有较少的这种&lt;code>code&lt;/code>定义，推荐不要超过 20 种。并且客户端要保证能够有效处理这些错误信息。&lt;code>message&lt;/code>中的值应该是可读的错误的具体描述，主要是为了辅助开发者进行理解，注意，不可以将 error 信息直接展示给终端用户。展示给用户的信息应该使用&lt;a href="http://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html#_Instance_Annotations" target="_blank" rel="noopener">annotation&lt;/a>或者一些自定义的友好的描述。服务端不会负责为&lt;code>message&lt;/code>提供本地化服务，因为这样对于开发者变得非常不友好并且难以处理。&lt;code>target&lt;/code>中的值应该指向错误的具体的目标，譬如错误中的属性名。&lt;code>details&lt;/code>中的值必须是一个包含多个 JSON 对象的 JSON 数组，每个 JSON 对象会包含一个&lt;code>code&lt;/code>与&lt;code>message&lt;/code>信息，并且可能包含&lt;code>target&lt;/code>属性。&lt;code>details&lt;/code>中的信息会用于描述请求过程中发生的一些其他错误。&lt;code>innererror&lt;/code>键值对必须包含一个 JSON 对象，该对象的内容则是由服务端指定。每个嵌套的新的错误描述应该是比父层级更加精确具体的描述，这种方式有助于在迭代的过程中随着业务逻辑的编号逐步地添加新的错误码。&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;error&amp;#34;: {
&amp;#34;code&amp;#34;: &amp;#34;BadArgument&amp;#34;,
&amp;#34;message&amp;#34;: &amp;#34;Previous passwords may not be reused&amp;#34;,
&amp;#34;target&amp;#34;: &amp;#34;password&amp;#34;,
&amp;#34;innererror&amp;#34;: {
&amp;#34;code&amp;#34;: &amp;#34;PasswordError&amp;#34;,
&amp;#34;innererror&amp;#34;: {
&amp;#34;code&amp;#34;: &amp;#34;PasswordDoesNotMeetPolicy&amp;#34;,
&amp;#34;minLength&amp;#34;: &amp;#34;6&amp;#34;,
&amp;#34;maxLength&amp;#34;: &amp;#34;64&amp;#34;,
&amp;#34;characterTypes&amp;#34;: [&amp;#34;lowerCase&amp;#34;,&amp;#34;upperCase&amp;#34;,&amp;#34;number&amp;#34;,&amp;#34;symbol&amp;#34;],
&amp;#34;minDistinctCharacterTypes&amp;#34;: &amp;#34;2&amp;#34;,
&amp;#34;innererror&amp;#34;: {
&amp;#34;code&amp;#34;: &amp;#34;PasswordReuseNotAllowed&amp;#34;
}
}
}
}
}
&lt;/code>&lt;/pre>&lt;p>上面例子中，基本的错误码为 &amp;ldquo;BadArgument,&amp;quot;，但是服务端在&lt;code>innererror&lt;/code>中提供了更多详细的说明。&amp;ldquo;PasswordReuseNotAllowed&amp;rdquo; 错误码可能是在迭代过程中被添加进去以给客户端更好地提示，这种增量型的添加方式并不会破坏老的客户端的处理过程，而又可以给开发者一些更详细的信息。&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;error&amp;#34;: {
&amp;#34;code&amp;#34;: &amp;#34;BadArgument&amp;#34;,
&amp;#34;message&amp;#34;: &amp;#34;Multiple errors in ContactInfo data&amp;#34;,
&amp;#34;target&amp;#34;: &amp;#34;ContactInfo&amp;#34;,
&amp;#34;details&amp;#34;: [
{
&amp;#34;code&amp;#34;: &amp;#34;NullValue&amp;#34;,
&amp;#34;target&amp;#34;: &amp;#34;PhoneNumber&amp;#34;,
&amp;#34;message&amp;#34;: &amp;#34;Phone number must not be null&amp;#34;
},
{
&amp;#34;code&amp;#34;: &amp;#34;NullValue&amp;#34;,
&amp;#34;target&amp;#34;: &amp;#34;LastName&amp;#34;,
&amp;#34;message&amp;#34;: &amp;#34;Last name must not be null&amp;#34;
},
{
&amp;#34;code&amp;#34;: &amp;#34;MalformedValue&amp;#34;,
&amp;#34;target&amp;#34;: &amp;#34;Address&amp;#34;,
&amp;#34;message&amp;#34;: &amp;#34;Address is not valid&amp;#34;
}
]
}
}
&lt;/code>&lt;/pre>&lt;p>上例中一次请求里发生了多个错误，这些错误以及信息都包含在了 &amp;ldquo;details.&amp;rdquo; 中。我们还推荐服务端在发生错误时添加一个 Retry-After HTTP 响应头，这样可以让客户端知道在合适的时间之后进行重试请求。&lt;/p>
&lt;h2 id="http-status-codeshttp-状态码">HTTP Status Codes:HTTP 状态码&lt;/h2>
&lt;p>我们应当使用标准的 HTTP 状态码作为响应的状态码。&lt;/p>
&lt;h2 id="client-library-optional">Client Library Optional&lt;/h2>
&lt;p>开发者应该能够使用多种语言或者平台来进行客户端开发，譬如 Windows、MacOS、Linux、C#、Python、Node.js 以及 Ruby。服务应该允许利用 curl 等工具进行快速访问。&lt;/p></description></item><item><title>Paypal API 设计标准</title><link>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/paypal-api-%E8%AE%BE%E8%AE%A1%E6%A0%87%E5%87%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/paypal-api-%E8%AE%BE%E8%AE%A1%E6%A0%87%E5%87%86/</guid><description>&lt;h1 id="paypal-api-设计标准">PayPal API 设计标准&lt;/h1>
&lt;p>在构建 API 时，我们不可避免的会采用现有的跨平台的 HTTP 的交互方式与资源模型，因此如果你发现你目前的模式与我们的标准南辕北辙，那么请咨询你们专业的 API 设计师以获得进一步的建议。&lt;/p>
&lt;h1 id="uri-components">URI Components&lt;/h1>
&lt;h2 id="version-版本控制">Version: 版本控制&lt;/h2>
&lt;p>URI 应当包含&lt;code>vN&lt;/code>，其中&lt;code>N&lt;/code>指明版本号。基于 URL 的版本控制相较于其他复杂的请求头的方法会显得简单易用很多。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>/v{version}/
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>/v1/
&lt;/code>&lt;/pre>&lt;h2 id="namespaces-命名空间">Namespaces: 命名空间&lt;/h2>
&lt;p>如果在 URI 中你需要考虑命名空间这个概念，那么应当选择紧邻在&lt;code>version&lt;/code>之后的第一个字段。命名空间折射出消费者对于 API 功能的观点，而不一定是公司本身业务逻辑层级的划分。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>/{version}/{namespace}/
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>/v1/vault/
&lt;/code>&lt;/pre>&lt;h2 id="resource-references-资源关联">Resource References: 资源关联&lt;/h2>
&lt;p>URI 与资源之间的关联应当保证一致性，避免出现容易引起混淆的子命名空间或者子目录的命名，这样有助于使用者能够很明晰地构造这些请求的 URI。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>/{version}/{namespace}/{resource}/{resource-id}/{sub-resource}/{sub-resource-id}
&lt;/code>&lt;/pre>&lt;h1 id="collection-resources">Collection Resources&lt;/h1>
&lt;p>支持 CRUD 操作的资源被称为是 Collection Resources，往往这些资源会与 POST/GET/PUT/PATCH/DELETE 这些 HTTP 动词紧密关联。Collection Resources 命名时应当使用复数名词，譬如&lt;code>/users&lt;/code>，这样可以和下面提及的 Singletons 进行区分。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>Usage&lt;/th>
&lt;th>Idempotent: 幂等性&lt;/th>
&lt;th>Notes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET&lt;/td>
&lt;td>Read&lt;/td>
&lt;td>X&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST&lt;/td>
&lt;td>Create&lt;/td>
&lt;td>&lt;/td>
&lt;td>仅当使用 &lt;a href="https://developer.paypal.com/webapps/developer/docs/api/#authentication--headers" target="_blank" rel="noopener">PayPal-Request-Id&lt;/a> 请求头时具有幂等性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT&lt;/td>
&lt;td>Create&lt;/td>
&lt;td>&lt;/td>
&lt;td>仅当在客户端提供了资源标识符时具有创建功能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT&lt;/td>
&lt;td>Update&lt;/td>
&lt;td>X&lt;/td>
&lt;td>仅用于某个资源的全部属性的更新，不可用于局部&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PATCH&lt;/td>
&lt;td>Update&lt;/td>
&lt;td>&lt;/td>
&lt;td>使用&lt;a href="https://tools.ietf.org/html/rfc6902" target="_blank" rel="noopener">JSON Patch&lt;/a> 消息格式&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE&lt;/td>
&lt;td>Delete&lt;/td>
&lt;td>&lt;/td>
&lt;td>应当在多次请求下具有相同的响应&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="collection-resource-获取资源集合--列表">Collection Resource: 获取资源集合 / 列表&lt;/h2>
&lt;p>包含任何相关联的元信息的给定资源的列表，所有的资源应当包含在&lt;code>items&lt;/code>域中，而类似于&lt;code>total_items&lt;/code> 以及 &lt;code>total_pages&lt;/code>的域指明整个关于数据整体的信息。这种命名的一致性有助于客户端开发者构建面向不同的资源集合的通用的处理函数。如果使用&lt;code>GET&lt;/code>动作进行访问，那么注意不应该影响到整个系统，并且保证除非数据发送变化否则响应消息也应该保持一致性。另外还需要注意的是，譬如日志输出这种动作不会被认为是对系统的修改。在 API 客户端权限合规的情况下允许对于资源列表进行过滤操作，即并不是本次都要把全部资源进行返回。另外，我们需要提供一个简短的摘要性质的资源表述来减少带宽的消耗，一般来说单个资源都包含较多的属性。&lt;/p>
&lt;h3 id="filtering-过滤">Filtering: 过滤&lt;/h3>
&lt;h4 id="paging-分页">Paging: 分页&lt;/h4>
&lt;p>关于分页的操作应该来源于请求时的&lt;code>page&lt;/code>与&lt;code>page_size&lt;/code>参数，其中&lt;code>page_size&lt;/code>指明了每次请求的结果数目，&lt;code>page&lt;/code>指明了请求的是第几页。另外，响应时应当保证包含&lt;code>total_items&lt;/code>与&lt;code>total_pages&lt;/code>这两个参数，其中&lt;code>total_items&lt;/code>指示请求的集合中总的数目，&lt;code>total_pages&lt;/code>指向总的页数 (&lt;code>total_items&lt;/code>/&lt;code>page_size&lt;/code>)。&lt;/p>
&lt;h5 id="hypermedia-links-超链接">Hypermedia links: 超链接&lt;/h5>
&lt;p>Hypermedia links 用于在分页的集合资源中指明请求其他页资源的便捷地址，一般来说会包含在&lt;code>next&lt;/code>, &lt;code>previous&lt;/code>, &lt;code>first&lt;/code>, &lt;code>last&lt;/code>等等类似的命名下。&lt;/p>
&lt;h4 id="time-selection">Time selection&lt;/h4>
&lt;p>如果需要根据时间进行选择，那么需要添加&lt;code>start_time&lt;/code> 或者&lt;code>{property_name}_after&lt;/code>, &lt;code>end_time&lt;/code> 或者 &lt;code>{property_name}_before&lt;/code> 这些查询参数。&lt;/p>
&lt;h4 id="sorting-排序">Sorting: 排序&lt;/h4>
&lt;p>&lt;code>sort_by&lt;/code> 以及 &lt;code>sort_order&lt;/code> 参数可以用来指明需要被排序的资源集合。一般来说&lt;code>sort_by&lt;/code>需要包含某个独立资源名，而&lt;code>sort_order&lt;/code>应该是&lt;code>asc&lt;/code>或者&lt;code>desc&lt;/code>值。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /{version}/{namespace}/{resource}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /v1/vault/credit-cards
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Resopnse&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
{
&amp;#34;total_items&amp;#34;: 1,
&amp;#34;total_pages&amp;#34;: 1,
&amp;#34;items&amp;#34;: [
{
&amp;#34;id&amp;#34;: &amp;#34;CARD-1SV265177X389440GKLJZIYY&amp;#34;,
&amp;#34;state&amp;#34;: &amp;#34;ok&amp;#34;,
&amp;#34;payer_id&amp;#34;: &amp;#34;user12345&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;visa&amp;#34;,
&amp;#34;number&amp;#34;: &amp;#34;xxxxxxxxxxxx0331&amp;#34;,
&amp;#34;expire_month&amp;#34;: &amp;#34;11&amp;#34;,
&amp;#34;expire_year&amp;#34;: &amp;#34;2018&amp;#34;,
&amp;#34;first_name&amp;#34;: &amp;#34;Joe&amp;#34;,
&amp;#34;last_name&amp;#34;: &amp;#34;Shopper&amp;#34;,
&amp;#34;valid_until&amp;#34;: &amp;#34;2017-01-12T00:00:00Z&amp;#34;,
&amp;#34;create_time&amp;#34;: &amp;#34;2014-01-13T07:23:15Z&amp;#34;,
&amp;#34;update_time&amp;#34;: &amp;#34;2014-01-13T07:23:15Z&amp;#34;,
&amp;#34;links&amp;#34;: [
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/vault/credit-cards/CARD-1SV265177X389440GKLJZIYY&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;self&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;
},
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/vault/credit-cards/CARD-1SV265177X389440GKLJZIYY&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;delete&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;DELETE&amp;#34;
},
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/vault/credit-cards/CARD-1SV265177X389440GKLJZIYY&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;patch&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;PATCH&amp;#34;
}
]
}
],
&amp;#34;links&amp;#34;: [
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/vault/credit-cards/?page_size=10&amp;amp;sort_by=create_time&amp;amp;sort_order=asc&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;first&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;
}
]
}
~~~
&lt;/code>&lt;/pre>&lt;h2 id="http-status">HTTP Status&lt;/h2>
&lt;p>如果返回的资源集合为空，即没有任何的资源项，此时也不应该返回&lt;code>404 Not Found&lt;/code>，而应该将&lt;code>items&lt;/code>项设置为空，并且提供一些集合的元信息，譬如&lt;code>total_count&lt;/code>设置为 0。而如果是错误的请求参数应当返回&lt;code>404 Bad Request&lt;/code>。否则应该返回&lt;code>200 OK&lt;/code>来表示成功的返回值。&lt;/p>
&lt;h2 id="read-single-resource">Read Single Resource&lt;/h2>
&lt;p>单个资源一般比资源集合中的对应项更详细，同时需要注意 GET 请求不应该影响到系统。对于敏感数据的资源标识不应该是连续的或者数值类型的，另外，如果待读取的数据是其他数据的子类，那么应该使用不可变的字符串标识符，这样可读性与可调试性都会更好。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /{version}/{namespace}/{resource}/{resource-id}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;merchant_customer_id&amp;#34;: &amp;#34;merchant-1&amp;#34;,
&amp;#34;merchant_id&amp;#34;: &amp;#34;target&amp;#34;,
&amp;#34;create_time&amp;#34;: &amp;#34;2014-10-10T16:10:55Z&amp;#34;,
&amp;#34;update_time&amp;#34;: &amp;#34;2014-10-10T16:10:55Z&amp;#34;,
&amp;#34;first_name&amp;#34;: &amp;#34;Kartik&amp;#34;,
&amp;#34;last_name&amp;#34;: &amp;#34;Hattangadi&amp;#34;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>HTTP Status&lt;/li>
&lt;/ul>
&lt;p>如果指定的资源并不存在，那么应该返回&lt;code>404 Not Found&lt;/code>状态，否则应该返回&lt;code>200 OK&lt;/code>状态码&lt;/p>
&lt;h2 id="update-single-resource">Update Single Resource&lt;/h2>
&lt;p>注意，使用 PUT 动作更新单个资源的时候需要除了需要修正的值否则保证 PUT 请求的值与 GET 响应的值保持一致性，另外对于像&lt;code>create_time&lt;/code>这样系统自动计算的值也可以忽略。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>PUT /{version}/{namespace}/{resource}/{resource-id}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>PUT /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY
{
&amp;#34;merchant_customer_id&amp;#34;: &amp;#34;merchant-1&amp;#34;,
&amp;#34;merchant_id&amp;#34;: &amp;#34;target&amp;#34;,
&amp;#34;create_time&amp;#34;: &amp;#34;2014-10-10T16:10:55Z&amp;#34;,
&amp;#34;update_time&amp;#34;: &amp;#34;2014-10-10T16:10:55Z&amp;#34;,
&amp;#34;first_name&amp;#34;: &amp;#34;Kartik&amp;#34;,
&amp;#34;last_name&amp;#34;: &amp;#34;Hattangadi&amp;#34;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>HTTP Status 任何处理失败的请求都应该返回&lt;code>400 Bad Request&lt;/code>, 特别是如果客户端想要更改某个只读的字段，也应该返回&lt;code>400 Bad Request&lt;/code>。如果具体的业务逻辑上存在校验规则，譬如对于数据的类型、长度等等，那么应该提供具体的操作码说明。如果部分场景下需要客户单与其他 API 进行交互或者在本次请求之外发出额外的请求，那么应该返回&lt;code>422&lt;/code>状态码，详情可以参考&lt;a href="http://ppaas/news/2014/05/01/added-standards-for-422-http-status/" target="_blank" rel="noopener">PPaaS Blog on this topic&lt;/a>这篇文章。对于其他成功的更新请求，应该返回&lt;code>204 No Content&lt;/code>状态码，即没有任何的返回体。&lt;/li>
&lt;/ul>
&lt;h2 id="update-partial-single-resoure">Update Partial Single Resoure&lt;/h2>
&lt;p>不同于每次 PUT 请求中都需要更新资源的全部属性，PACTH 可以根据指定的域更新对应的属性值，并且不会影响到其他属性。&lt;a href="https://tools.ietf.org/html/rfc6902" target="_blank" rel="noopener">JSON Patch&lt;/a> 是一个推荐的信息格式，在 PayPal 的几乎所有关于 PATCH 的操作中都有所应用。除非客户端的特别需要，否则每次 PATCH 操作的返回状态都应该是&lt;code>204 No Content&lt;/code>, 这样从带宽的角度，特别是在移动设备中能够更好地节约流量。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>PATCH /{version}/{namespace}/{resource}/{resource-id}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>PATCH /v1/notifications/webhooks/52Y53119KP6130839
[
{
&amp;#34;op&amp;#34;: &amp;#34;replace&amp;#34;,
&amp;#34;path&amp;#34;: &amp;#34;/url&amp;#34;,
&amp;#34;value&amp;#34;: &amp;#34;https://www.yeowza.com/paypal_webhook_new_url&amp;#34;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>204 No Content
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>HTTP Status 和 PUT 请求一致。&lt;/li>
&lt;/ul>
&lt;h2 id="delete-single-resource">Delete Single Resource&lt;/h2>
&lt;p>在删除一个资源的时候，为了保证客户端的可重试性，应当将 DELETE 操作当做幂等操作对待。因此每次删除操作都应该返回&lt;code>204 No Content&lt;/code>状态码，否则如果你返回的是&lt;code>404 Not Found&lt;/code>可能会让客户端误认为该资源是并不存在，而不是被删除了。应该使用 GET 请求来验证某个资源是否被成功删除，而不应该通过 DELETE 请求进行验证。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>DELETE /{version}/{namespace}/{resource}/{resource-id}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>DELETE /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY
204 No Content
&lt;/code>&lt;/pre>&lt;h2 id="create-new-resource">Create New Resource&lt;/h2>
&lt;p>一般来说，创建某个资源的请求体与 GET/PUT 不太一致，大部分情况下 API Server 都会为该资源创建一个全局的资源描述符，即使用&lt;a href="">Create New Resource - Consumer ID&lt;/a>。一旦 POST 请求被成功执行，也就意味着资源创建成功，那么该资源的描述符也会被添加到资源集合的 URI 中。Hypermedia links 提供了一种较为便捷的方式访问新近创建的资源，可以使用&lt;code>rel&lt;/code>: &lt;code>self&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /{version}/{namespace}/{resource}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
POST /v1/vault/credit-cards
{
&amp;#34;payer_id&amp;#34;: &amp;#34;user12345&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;visa&amp;#34;,
&amp;#34;number&amp;#34;: &amp;#34;4417119669820331&amp;#34;,
&amp;#34;expire_month&amp;#34;: &amp;#34;11&amp;#34;,
&amp;#34;expire_year&amp;#34;: &amp;#34;2018&amp;#34;,
&amp;#34;first_name&amp;#34;: &amp;#34;Betsy&amp;#34;,
&amp;#34;last_name&amp;#34;: &amp;#34;Buyer&amp;#34;,
&amp;#34;billing_address&amp;#34;: {
&amp;#34;line1&amp;#34;: &amp;#34;111 First Street&amp;#34;,
&amp;#34;city&amp;#34;: &amp;#34;Saratoga&amp;#34;,
&amp;#34;country_code&amp;#34;: &amp;#34;US&amp;#34;,
&amp;#34;state&amp;#34;: &amp;#34;CA&amp;#34;,
&amp;#34;postal_code&amp;#34;: &amp;#34;95070&amp;#34;
}
}
~~~
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
201 Created
{
&amp;#34;id&amp;#34;: &amp;#34;CARD-1MD19612EW4364010KGFNJQI&amp;#34;,
&amp;#34;valid_until&amp;#34;: &amp;#34;2016-05-07T00:00:00Z&amp;#34;,
&amp;#34;state&amp;#34;: &amp;#34;ok&amp;#34;,
&amp;#34;payer_id&amp;#34;: &amp;#34;user12345&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;visa&amp;#34;,
&amp;#34;number&amp;#34;: &amp;#34;xxxxxxxxxxxx0331&amp;#34;,
&amp;#34;expire_month&amp;#34;: &amp;#34;11&amp;#34;,
&amp;#34;expire_year&amp;#34;: &amp;#34;2018&amp;#34;,
&amp;#34;first_name&amp;#34;: &amp;#34;Betsy&amp;#34;,
&amp;#34;last_name&amp;#34;: &amp;#34;Buyer&amp;#34;,
&amp;#34;links&amp;#34;: [
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/vault/credit-cards/CARD-1MD19612EW4364010KGFNJQI&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;self&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;
},
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/vault/credit-cards/CARD-1MD19612EW4364010KGFNJQI&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;delete&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;DELETE&amp;#34;
}
]
}
~~~
&lt;/code>&lt;/pre>&lt;h2 id="create-new-resource---consumer-supplied-identifier">Create New Resource - Consumer Supplied Identifier&lt;/h2>
&lt;p>当某个 API Consumer 自定义了 Resource Identifier，那么应该使用 PUT 动作来创建资源，这样也能保证幂等性。&lt;/p>
&lt;h1 id="sub-resource-collection">Sub-Resource Collection&lt;/h1>
&lt;p>在某些情况下，我们可能需要多个标识符来定位到某个资源，这一类资源往往是其他资源的子类。&lt;/p>
&lt;h2 id="cautions">Cautions&lt;/h2>
&lt;ul>
&lt;li>多层的资源标识符本身对于 Consumer 而言也是一种负担。
&lt;ul>
&lt;li>尽可能地将具有唯一标识符的资源或者没必要指明父资源的资源作为 First-Level Resource。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要注意使用多个资源标识符的时候务必不能产生歧义，譬如&lt;code>/{version}/{namespace}/{resource}/{resource-id}/{sub-resource-id}&lt;/code>这种直接将子资源标识符放在父资源标识符之后的做法就是不合适的，会让 Consumer 迷糊。&lt;/li>
&lt;li>实践中这种资源的层叠嵌套不要超过两层。
&lt;ul>
&lt;li>要保证 API 客户端的可用性，如果在某个 URI 中维持大量的层级资源标识符会大大增加复杂度。&lt;/li>
&lt;li>服务端开发者需要校验每一层级的标识符来判断是否具有访问权限，如果层级过深极易导致复杂度的陡升。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>URI Templates&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /{version}/{namespace}/{resource}/{resource-id}/{sub-resource}
GET /{version}/{namespace}/{resource}/{resource-id}/{sub-resource}
GET /{version}/{namespace}/{resource}/{resource-id}/{sub-resource}/{sub-resource-id}
PUT /{version}/{namespace}/{resource}/{resource-id}/{sub-resource}/{sub-resource-id}
DELETE /{version}/{namespace}/{resource}/{resource-id}/{sub-resource}/{sub-resource-id}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Examples&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /v1/notifications/webhooks/{webhook-id}/event-types
POST /v1/factory/widgets/PART-4312/sub-assemblies
GET /v1/factory/widgets/PART-4312/sub-assemblies/INNER_COG
PUT /v1/factory/widgets/PART-4312/sub-assemblies/INNER_COG
DELETE /v1/factory/widgets/PART-4312/sub-assemblies/INNER_COG
&lt;/code>&lt;/pre>&lt;h1 id="sub-resource-singleton">Sub-Resource Singleton&lt;/h1>
&lt;p>当父子资源之间实际上是一一映射的关系时，可以使用单数形式的资源名来表明多个资源标识符的作用。这种情况下子资源往往也是父资源的一部分，即所谓的被父资源所有。否则子资源应当被放置于独立的资源集合中，并且以其他方式表明父子资源的关联。如果需要创建这种所谓的 Singleton 子资源，应该使用 PUT 动作，因为 PUT 是幂等性的。可以使用 PATCH 来进行部分更新，不过千万要注意不能使用 PATCH 进行创建操作。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET/PUT /{version}/{namespace}/{resource}/{resource-id}/{sub-resource}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Examples&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /v1/customers/devices/DEV-FDU233FDSE213f)/vendor-information
&lt;/code>&lt;/pre>&lt;h1 id="complex-operation">Complex Operation&lt;/h1>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
POST /{namespace}/{action-resource}
~~~
&lt;/code>&lt;/pre>&lt;p>所谓复杂的操作有时候也被称为&lt;code>controller&lt;/code>或者&lt;code>actions&lt;/code>，务必要审慎地使用，只有在仔细考虑过上文提及的&lt;a href="#resource-collection">Resource Collection&lt;/a>设计并不能满足需要的时候再进行使用。可以参考&lt;a href="http://www.amazon.com/RESTful-Web-Services-Cookbook-Scalability/dp/0596801688" target="_blank" rel="noopener">section 2.6 of the RESTful Web Services Cookbook&lt;/a>这一章节来了解更多的关于&lt;code>controller&lt;/code>的概念。复杂操作往往是与 POST 协同使用，并且大部分需要在 URI 中显式地指明动作，譬如 &amp;lsquo;activate&amp;rsquo;, &amp;lsquo;cancel&amp;rsquo;, &amp;lsquo;validate&amp;rsquo;, &amp;lsquo;accept&amp;rsquo;, 以及 &amp;lsquo;deny&amp;rsquo; 都是常见的操作。实际上，这种所谓 Action-Oriented 架构如果直接作用在跟 URI 中，即直接跟在命名空间之后，就是典型的反模式，通常这种模式较为适用于跟随在子资源之后。当某个场景是专注于动作，而不是资源的时候，应该建议适用 Action-Oriented 模式，并且此时应该适用 POST 动作，然后用某个单一的动词指明 action。&lt;/p>
&lt;h2 id="risks">Risks&lt;/h2>
&lt;ul>
&lt;li>架构设计的可扩展性 _ 一旦这种模式被滥用了，URI 的数量会急剧增长，特别是根级别的 Action 可以随着时间疯狂增长。同样的这也会导致路由或者对外提供服务的配置复杂度急速增长。_ URI 无法再被扩展，即不能再使用子资源。&lt;/li>
&lt;li>可测试性 : 因为缺乏丰富的 GET 等读取类操作而使得与 &lt;a href="#resource-collection">Resource Collection&lt;/a>-oriented 模式相比有较大缺陷&lt;/li>
&lt;li>历史 : 所有对于 Action 的调用应该存在某种资源中，譬如&lt;code>/action-resource-history&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="benefits">Benefits&lt;/h2>
&lt;ul>
&lt;li>避免因为短暂性数据而导致资源集合模型的损害。&lt;/li>
&lt;li>可用性的提升：这种 Action-Oriented 模式能够大大简化客户端交互内容，不过客户端并不能获益于资源本身的可读性&lt;/li>
&lt;/ul>
&lt;h2 id="resource-oriented-alternative">Resource-Oriented Alternative&lt;/h2>
&lt;p>与上文提及的这种单纯的 Action-Oriented RFC 风格 URL 相比，更好地方法就是与&lt;a href="#resource-collection">Resource Collection&lt;/a>相结合，并且使用&lt;code>GET /{actions}&lt;/code>来获取历史记录。这也允许未来基于资源模型的扩展。除此之外，这种模式也能较好地与&lt;a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="noopener">event sourcing&lt;/a>概念相结合。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /{version}/{namespace}/{action}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
POST /v1/risk/payment-decisions
{
&amp;#34;code&amp;#34;: &amp;#34;h43j5k6iop&amp;#34;
}
~~~
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
201 Created
{
&amp;#34;code&amp;#34;: &amp;#34;h43j5k6iop&amp;#34;,
&amp;#34;status&amp;#34;: &amp;#34;APPROVED&amp;#34;,
&amp;#34;links&amp;#34;: [
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/risk/payment-decisions/ID-FEF8EWR8E9FW)&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;self&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;
}
]
}
~~~
&lt;/code>&lt;/pre>&lt;h2 id="complex-operation---sub-resource">Complex Operation - Sub-Resource&lt;/h2>
&lt;p>很多时候我们需要对于资源进行些特定的操作或者状态修正，而这些操作是无法准确的用 PUT 或者 PATCH 进行表示。这些 URI 看上去有点像其他的 Sub-Resources 不过隐含着操作名。这个模式典型的使用场景就是当改变了某个资源的状态之后会添加些额外的副作用。另外，往往需要将资源标识符包含在 URL 中。而且并不是每个 Action 都会修改资源的状态。&lt;/p>
&lt;p>一般来说，Action 的响应状态都是&lt;code>200 OK&lt;/code>以及资源本身，如果没有任何的资源状态的修正，那么应该返回&lt;code>204 No Content&lt;/code>，并且不应该附上任何的响应体。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /{version}/{namespace}/{resource}/{resource-id}/{complex-operation}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
POST /v1/payments/billing-agreements/I-0LN988D3JACS/suspend
{
&amp;#34;note&amp;#34;: &amp;#34;Suspending the agreement.&amp;#34;
}
~~~
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
204 No Content
~~~
&lt;/code>&lt;/pre>&lt;p>不过需要注意的是，虽然这种模式可以改变状态，也并不意味着所有的关于资源的状态改变都要使用所谓的复杂操作模式。简单的状态的改变仍然可以使用 PUT/PATCH，也就是意味着混合使用&lt;a href="#resource-collection">Resource Collection&lt;/a>与 Complex Operation 从而减少操作的数目。&lt;/p>
&lt;ul>
&lt;li>Example Request (for mixed use of PUT)&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
PATCH /v1/payments/billing-agreements/I-0LN988D3JACS
[
{
&amp;#34;op&amp;#34;: &amp;#34;replace&amp;#34;,
&amp;#34;path&amp;#34;: &amp;#34;/&amp;#34;,
&amp;#34;value&amp;#34;: {
&amp;#34;description&amp;#34;: &amp;#34;New Description&amp;#34;,
&amp;#34;shipping_address&amp;#34;: {
&amp;#34;line1&amp;#34;: &amp;#34;2065 Hamilton Ave&amp;#34;,
&amp;#34;city&amp;#34;: &amp;#34;San Jose&amp;#34;,
&amp;#34;state&amp;#34;: &amp;#34;CA&amp;#34;,
&amp;#34;postal_code&amp;#34;: &amp;#34;95125&amp;#34;,
&amp;#34;country_code&amp;#34;: &amp;#34;US&amp;#34;
}
}
}
]
~~~
&lt;/code>&lt;/pre>&lt;h2 id="complex-operation---composite">Complex Operation - Composite&lt;/h2>
&lt;p>该系列的操作往往可以在一次请求中处理多个 creates/updates/deletes 操作。这一点往往从性能与可用性方面综合考虑，这也会在影响多个资源的请求中更好地维持原子性。参考下面这个例子，capture 和 payment 都会同时被 refund 操作影响。对于 capture 资源的 PUT 或者 PATCH 操作会隐性地影响 payment 资源。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /{version}/{namespace}/{action}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
POST /v1/payments/captures/{capture-id}/refund
~~~
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>~~~
{
&amp;#34;id&amp;#34;: &amp;#34;0P209507D6694645N&amp;#34;,
&amp;#34;create_time&amp;#34;: &amp;#34;2013-05-06T22:11:51Z&amp;#34;,
&amp;#34;update_time&amp;#34;: &amp;#34;2013-05-06T22:11:51Z&amp;#34;,
&amp;#34;state&amp;#34;: &amp;#34;completed&amp;#34;,
&amp;#34;amount&amp;#34;: {
&amp;#34;total&amp;#34;: &amp;#34;110.54&amp;#34;,
&amp;#34;currency&amp;#34;: &amp;#34;USD&amp;#34;
},
&amp;#34;capture_id&amp;#34;: &amp;#34;8F148933LY9388354&amp;#34;,
&amp;#34;parent_payment&amp;#34;: &amp;#34;PAY-8PT597110X687430LKGECATA&amp;#34;,
&amp;#34;links&amp;#34;: [
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/payments/refund/0P209507D6694645N&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;self&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;
},
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/payments/payment/PAY-8PT597110X687430LKGECATA&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;parent_payment&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;
},
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.paypal.com/v1/payments/capture/8F148933LY9388354&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;capture&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;
}
]
}
~~~
&lt;/code>&lt;/pre>&lt;h2 id="complex-operation---transient">Complex Operation - Transient&lt;/h2>
&lt;p>这一个类型的复杂操作并不会保留客户端的状态或者创建新的资源。往往就是一个简单的 RPC 调用，然后直接获取返回值。该操作一般不会用在子资源中，因为子资源操作一般会影响父资源的状态。此时返回是建议使用&lt;code>200 OK&lt;/code>这个状态码。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /{version}/{namespace}/{action}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /v1/risk/evaluate-payment
{
&amp;#34;code&amp;#34;: &amp;#34;h43j5k6iop&amp;#34;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>200 OK
{
&amp;#34;status&amp;#34;: &amp;#34;VALID&amp;#34;
}
&lt;/code>&lt;/pre>&lt;h2 id="complex-operation---search">Complex Operation - Search&lt;/h2>
&lt;p>在使用&lt;a href="#resource-collection">Resource Collections&lt;/a>的时候，最好是使用查询参数来进行集合内容的过滤。不过有时候我们会需要一些更为复杂的查询语法，单纯的查询参数的方式会导致使用的问题或者受限于查询参数的长度。这时候，应该选择使用 POST 请求来指定查询参数。&lt;/p>
&lt;h3 id="paging">Paging&lt;/h3>
&lt;p>如果响应体比较大的情况下应当使用分页方式，需要注意的是，Consumer 应该在每次子请求的时候都使用 POST 方式。这样也就意味着，在 POST 请求体中需要维护一些查询参数。分页查询参数同样可以参考&lt;a href="#paging">Resource Collections&lt;/a>这一部分。同样可以适用于提供 &lt;code>next&lt;/code>, &lt;code>previous&lt;/code>, &lt;code>first&lt;/code>, &lt;code>last&lt;/code> 来进行其他页的快速读取。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>POST /{version}/{namespace}/{search-resource}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code> POST /v1/factory/widgets-search
{
&amp;#34;created_before&amp;#34;:&amp;#34;1975-05-13&amp;#34;,
&amp;#34;status&amp;#34;: &amp;#34;ACTIVE&amp;#34;,
&amp;#34;vendor&amp;#34;: &amp;#34;Parts Inc.&amp;#34;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Response&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code> 200 OK
{
&amp;#34;items&amp;#34;: [
&amp;lt;&amp;lt;lots of part objects here&amp;gt;&amp;gt;
]
&amp;#34;links&amp;#34;: [
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.factory.io/v1/factory/widgets-search?page=2&amp;amp;page_size=10&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;next&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;POST&amp;#34;
},
{
&amp;#34;href&amp;#34;: &amp;#34;https://api.sandbox.factory.io/v1/factory/widgets-search?page=124&amp;amp;page_size=10&amp;#34;,
&amp;#34;rel&amp;#34;: &amp;#34;last&amp;#34;,
&amp;#34;method&amp;#34;: &amp;#34;POST&amp;#34;
},
]
}
&lt;/code>&lt;/pre>&lt;h1 id="read-only-resources">Read-only resources&lt;/h1>
&lt;p>在部分需要进行计算或者静态引用的场景下，GET 会比 POST 请求更为合适，因为 POST 在 HTTP 层面是不会有缓存的。GET 请求本身是幂等的，即不会改变资源的状态，而 POST 请求可以用于&lt;a href="#complex-operation">Complex Operations&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>URI Template&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /{version}/{namespace}/{read-only-resource}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Example Request&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>GET /v1/location/geocode?address=77+N.+Washington+Street%2C+Boston%2C+MA%2C+02114
&lt;/code>&lt;/pre></description></item><item><title>RESTful 接口</title><link>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/restful-%E6%8E%A5%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/architecture-series/2.%E9%A3%8E%E6%A0%BC%E4%B8%8E%E6%A8%A1%E5%BC%8F/web-api/rest/restful-%E6%8E%A5%E5%8F%A3/</guid><description>&lt;h1 id="restful-接口">RESTful 接口&lt;/h1>
&lt;h1 id="http-methods">HTTP Methods&lt;/h1>
&lt;h2 id="幂等性">幂等性&lt;/h2>
&lt;h1 id="state-management--状态管理">State Management | 状态管理&lt;/h1>
&lt;p>状态管理即维持一个页面状态或者控制的状态。HTTP 协议本身是一个无状态的协议，因此状态管理就是用来维持一系列的来自客户端的请求状态的机制。REST 服务本身提供了两个基础的状态类型：&lt;/p>
&lt;ul>
&lt;li>Active : 当服务被调用或者执行的时候即进入 Active 状态&lt;/li>
&lt;li>Passive : 当服务没有被使用是即进入 Passive 状态&lt;/li>
&lt;/ul>
&lt;h2 id="active">Active&lt;/h2>
&lt;h2 id="stateful">Stateful&lt;/h2>
&lt;p>这种状态下，服务处于激活状态，并且能够处理连续的任务。如果服务处于 Stateful 状态下，它可以处理三个类型的数据：Session、Context 与 Business。&lt;/p>
&lt;h3 id="session">Session&lt;/h3>
&lt;p>Session data represents information associated with retaining a connection made between a program and its client program.Sessions are identified by a unique identifier that can be read by using the SessionID property.A session is considered active as long as requests continue to be made with the same SessionID value. If the time between requests for a particular session exceeds the specified time-out value in minutes, the session is considered expired. Requests made with an expired SessionID value result in a new session.&lt;/p>
&lt;h3 id="context">Context&lt;/h3>
&lt;p>When the service is active,stateful and executing the main task of the service.If the logic is tied with workflow, then it is further divided to context data and context rules. Context rules are the rules for executing workflow.&lt;/p>
&lt;h3 id="business">Business&lt;/h3>
&lt;p>When the service is active and stateful,the service can execute a business task by executing multiple services.&lt;/p>
&lt;h2 id="stateless">Stateless&lt;/h2>
&lt;p>这种状态下，服务处于激活状态，但是没有在处理一个连贯的任务。&lt;/p></description></item></channel></rss>