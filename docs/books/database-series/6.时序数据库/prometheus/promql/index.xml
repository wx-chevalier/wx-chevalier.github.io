<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PromQL | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/</link><atom:link href="https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/index.xml" rel="self" type="application/rss+xml"/><description>PromQL</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>PromQL</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/</link></image><item><title>HTTP API</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/http-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/http-api/</guid><description>&lt;h1 id="在-http-api-中使用-promql">在 HTTP API 中使用 PromQL&lt;/h1>
&lt;p>我们不仅仅可以在 Prometheus 的 Graph 页面查询 PromQL，Prometheus 还提供了一种 HTTP API 的方式，可以更灵活的将 PromQL 整合到其他系统中使用，譬如下面要介绍的 Grafana，就是通过 Prometheus 的 HTTP API 来查询指标数据的。实际上，我们在 Prometheus 的 Graph 页面查询也是使用了 HTTP API。&lt;/p>
&lt;p>我们看下 &lt;a href="https://prometheus.io/docs/prometheus/latest/querying/api/" target="_blank" rel="noopener">Prometheus 的 HTTP API 官方文档&lt;/a>，它提供了下面这些接口：&lt;/p>
&lt;ul>
&lt;li>GET /api/v1/query&lt;/li>
&lt;li>GET /api/v1/query_range&lt;/li>
&lt;li>GET /api/v1/series&lt;/li>
&lt;li>GET /api/v1/label/&amp;lt;label_name&amp;gt;/values&lt;/li>
&lt;li>GET /api/v1/targets&lt;/li>
&lt;li>GET /api/v1/rules&lt;/li>
&lt;li>GET /api/v1/alerts&lt;/li>
&lt;li>GET /api/v1/targets/metadata&lt;/li>
&lt;li>GET /api/v1/alertmanagers&lt;/li>
&lt;li>GET /api/v1/status/config&lt;/li>
&lt;li>GET /api/v1/status/flags&lt;/li>
&lt;/ul>
&lt;p>从 Prometheus v2.1 开始，又新增了几个用于管理 TSDB 的接口：&lt;/p>
&lt;ul>
&lt;li>POST /api/v1/admin/tsdb/snapshot&lt;/li>
&lt;li>POST /api/v1/admin/tsdb/delete_series&lt;/li>
&lt;li>POST /api/v1/admin/tsdb/clean_tombstones&lt;/li>
&lt;/ul>
&lt;h2 id="api-响应格式">API 响应格式&lt;/h2>
&lt;p>Prometheus API 使用了 JSON 格式的响应内容。当 API 调用成功后将会返回 2xx 的 HTTP 状态码。&lt;/p>
&lt;p>反之，当 API 调用失败时可能返回以下几种不同的 HTTP 状态码：&lt;/p>
&lt;ul>
&lt;li>404 Bad Request：当参数错误或者缺失时。&lt;/li>
&lt;li>422 Unprocessable Entity 当表达式无法执行时。&lt;/li>
&lt;li>503 Service Unavailiable 当请求超时或者被中断时。&lt;/li>
&lt;/ul>
&lt;p>所有的 API 请求均使用以下的 JSON 格式：&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;status&amp;#34;: &amp;#34;success&amp;#34; | &amp;#34;error&amp;#34;,
&amp;#34;data&amp;#34;: &amp;lt;data&amp;gt;,
// Only set if status is &amp;#34;error&amp;#34;. The data field may still hold
// additional data.
&amp;#34;errorType&amp;#34;: &amp;#34;&amp;lt;string&amp;gt;&amp;#34;,
&amp;#34;error&amp;#34;: &amp;#34;&amp;lt;string&amp;gt;&amp;#34;
}
&lt;/code>&lt;/pre>&lt;h2 id="在-http-api-中使用-promql-1">在 HTTP API 中使用 PromQL&lt;/h2>
&lt;p>通过 HTTP API 我们可以分别通过/api/v1/query 和/api/v1/query_range 查询 PromQL 表达式当前或者一定时间范围内的计算结果。&lt;/p>
&lt;h3 id="瞬时数据查询">瞬时数据查询&lt;/h3>
&lt;p>通过使用 QUERY API 我们可以查询 PromQL 在特定时间点下的计算结果。&lt;/p>
&lt;pre tabindex="0">&lt;code>GET /api/v1/query
&lt;/code>&lt;/pre>&lt;p>URL 请求参数：&lt;/p>
&lt;ul>
&lt;li>query=&lt;string>：PromQL 表达式。&lt;/li>
&lt;li>time=&amp;lt;rfc3339 | unix_timestamp&amp;gt;：用于指定用于计算 PromQL 的时间戳。可选参数，默认情况下使用当前系统时间。&lt;/li>
&lt;li>timeout=&lt;duration>：超时设置。可选参数，默认情况下使用-query,timeout 的全局设置。&lt;/li>
&lt;/ul>
&lt;p>例如使用以下表达式查询表达式 up 在时间点 2015-07-01T20:10:51.781Z 的计算结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="err">$&lt;/span> &lt;span class="err">curl&lt;/span> &lt;span class="err">&amp;#39;http:&lt;/span>&lt;span class="c1">//localhost:9090/api/v1/query?query=up&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;status&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;success&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;data&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;resultType&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;vector&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;result&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;metric&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;__name__&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;up&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;job&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;prometheus&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;instance&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;localhost:9090&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;value&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781451.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;metric&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;__name__&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;up&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;job&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;instance&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;value&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781451.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="响应数据类型">响应数据类型&lt;/h3>
&lt;p>当 API 调用成功后，Prometheus 会返回 JSON 格式的响应内容，格式如上小节所示。并且在 data 节点中返回查询结果。data 节点格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;resultType&amp;#34;: &amp;#34;matrix&amp;#34; | &amp;#34;vector&amp;#34; | &amp;#34;scalar&amp;#34; | &amp;#34;string&amp;#34;,
&amp;#34;result&amp;#34;: &amp;lt;value&amp;gt;
}
&lt;/code>&lt;/pre>&lt;p>PromQL 表达式可能返回多种数据类型，在响应内容中使用 resultType 表示当前返回的数据类型，包括：&lt;/p>
&lt;ul>
&lt;li>瞬时向量：vector&lt;/li>
&lt;/ul>
&lt;p>当返回数据类型 resultType 为 vector 时，result 响应格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>[
{
&amp;#34;metric&amp;#34;: { &amp;#34;&amp;lt;label_name&amp;gt;&amp;#34;: &amp;#34;&amp;lt;label_value&amp;gt;&amp;#34;, ... },
&amp;#34;value&amp;#34;: [ &amp;lt;unix_time&amp;gt;, &amp;#34;&amp;lt;sample_value&amp;gt;&amp;#34; ]
},
...
]
&lt;/code>&lt;/pre>&lt;p>其中 metrics 表示当前时间序列的特征维度，value 只包含一个唯一的样本。&lt;/p>
&lt;ul>
&lt;li>区间向量：matrix&lt;/li>
&lt;/ul>
&lt;p>当返回数据类型 resultType 为 matrix 时，result 响应格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>[
{
&amp;#34;metric&amp;#34;: { &amp;#34;&amp;lt;label_name&amp;gt;&amp;#34;: &amp;#34;&amp;lt;label_value&amp;gt;&amp;#34;, ... },
&amp;#34;values&amp;#34;: [ [ &amp;lt;unix_time&amp;gt;, &amp;#34;&amp;lt;sample_value&amp;gt;&amp;#34; ], ... ]
},
...
]
&lt;/code>&lt;/pre>&lt;p>其中 metrics 表示当前时间序列的特征维度，values 包含当前事件序列的一组样本。&lt;/p>
&lt;ul>
&lt;li>标量：scalar&lt;/li>
&lt;/ul>
&lt;p>当返回数据类型 resultType 为 scalar 时，result 响应格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>[ &amp;lt;unix_time&amp;gt;, &amp;#34;&amp;lt;scalar_value&amp;gt;&amp;#34; ]
&lt;/code>&lt;/pre>&lt;p>由于标量不存在时间序列一说，因此 result 表示为当前系统时间一个标量的值。&lt;/p>
&lt;ul>
&lt;li>字符串：string&lt;/li>
&lt;/ul>
&lt;p>当返回数据类型 resultType 为 string 时，result 响应格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>[ &amp;lt;unix_time&amp;gt;, &amp;#34;&amp;lt;string_value&amp;gt;&amp;#34; ]
&lt;/code>&lt;/pre>&lt;p>字符串类型的响应内容格式和标量相同。&lt;/p>
&lt;h3 id="区间数据查询">区间数据查询&lt;/h3>
&lt;p>使用 QUERY_RANGE API 我们则可以直接查询 PromQL 表达式在一段时间返回内的计算结果。&lt;/p>
&lt;pre tabindex="0">&lt;code>GET /api/v1/query_range
&lt;/code>&lt;/pre>&lt;p>URL 请求参数：&lt;/p>
&lt;ul>
&lt;li>query=&lt;string>: PromQL 表达式。&lt;/li>
&lt;li>start=&amp;lt;rfc3339 | unix_timestamp&amp;gt;: 起始时间。&lt;/li>
&lt;li>end=&amp;lt;rfc3339 | unix_timestamp&amp;gt;: 结束时间。&lt;/li>
&lt;li>step=&lt;duration>: 查询步长。&lt;/li>
&lt;li>timeout=&lt;duration>: 超时设置。可选参数，默认情况下使用-query,timeout 的全局设置。&lt;/li>
&lt;/ul>
&lt;p>当使用 QUERY_RANGE API 查询 PromQL 表达式时，返回结果一定是一个区间向量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;resultType&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;matrix&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;result&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="err">&amp;lt;value&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>需要注意的是，在 QUERY_RANGE API 中 PromQL 只能使用瞬时向量选择器类型的表达式。&lt;/p>
&lt;/blockquote>
&lt;p>例如使用以下表达式查询表达式 up 在 30 秒范围内以 15 秒为间隔计算 PromQL 表达式的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="err">$&lt;/span> &lt;span class="err">curl&lt;/span> &lt;span class="err">&amp;#39;http:&lt;/span>&lt;span class="c1">//localhost:9090/api/v1/query_range?query=up&amp;amp;start=2015-07-01T20:10:30.781Z&amp;amp;end=2015-07-01T20:11:00.781Z&amp;amp;step=15s&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;status&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;success&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;data&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;resultType&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;matrix&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;result&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;metric&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;__name__&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;up&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;job&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;prometheus&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;instance&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;localhost:9090&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;values&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781430.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781445.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781460.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;metric&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;__name__&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;up&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;job&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;instance&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;localhost:9091&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;values&amp;#34;&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781430.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781445.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span> &lt;span class="mf">1435781460.781&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Recording Rules</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/recording-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/recording-rules/</guid><description>&lt;h1 id="recording-rules">Recording rules&lt;/h1>
&lt;p>有一些监控的数据查询时很耗时的，还有一些数据查询所使用的查询语句很繁琐。Recording rules 可以把一些很耗时的查询或者很繁琐的查询进行提前查询好，然后在需要数据的时候就可以很快拉出数据。譬如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 规则分组 rule_group，不论是 recording rules 还是 alerting rules 都要在组里面&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">groups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># groups的名称&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">example&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c">#该组下的规则&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">&amp;lt;rule&amp;gt; ... ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 案例&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">groups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">example&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job:http_inprogress_requests:sum&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sum(http_inprogress_requests) by (job)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">groups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">example&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job:process_cpu_seconds:rate5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">sum without(instance)(rate(process_cpu_seconds_total[5m]))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job:process_open_fds:max&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">max without(instance)(process_open_fds)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="语法校验">语法校验&lt;/h2>
&lt;p>完整的规则语法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">groups:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">[&lt;/span> - &amp;lt;rule_group&amp;gt; &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;rule_group&amp;gt;的语法
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 规则组名 必须是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name: &amp;lt;string&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 规则评估间隔时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> interval: &amp;lt;duration&amp;gt; &lt;span class="p">|&lt;/span> &lt;span class="nv">default&lt;/span> &lt;span class="o">=&lt;/span> global.evaluation_interval &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rules:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">[&lt;/span> - &amp;lt;rule&amp;gt; ... &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;rule&amp;gt;的语法
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 收集的指标名称&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">record: &amp;lt;string&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 评估时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># evaluated at the current time, and the result recorded as a new set of&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># time series with the metric name as given by &amp;#39;record&amp;#39;.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">expr: &amp;lt;string&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Labels to add or overwrite before storing the result.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">labels:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">[&lt;/span> &amp;lt;labelname&amp;gt;: &amp;lt;labelvalue&amp;gt; &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要在不启动 Prometheus 进程的情况下快速检查规则文件是否在语法上正确，可以通过安装并运行 Prometheus 的 promtool 命令行工具来校验：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ go get github.com/prometheus/prometheus/cmd/promtool
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="案例">案例&lt;/h1>
&lt;h2 id="减少基数">减少基数&lt;/h2>
&lt;p>如果我们有如下的表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ sum without&lt;span class="o">(&lt;/span>instance&lt;span class="o">)(&lt;/span>rate&lt;span class="o">(&lt;/span>process_cpu_seconds_total&lt;span class="o">{&lt;/span>&lt;span class="nv">job&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>&lt;span class="o">}[&lt;/span>5m&lt;span class="o">]))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果直接在 Dashboard 中输入如上的 PromQL，在数据量较大的情况下，极有可能会导致过长的计算时间。我们可以使用如下的记录规则来构建新的指标：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">groups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job:process_cpu_seconds:rate5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="sd">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sum without(instance)(
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> rate(process_cpu_seconds_total{job=&amp;#34;node&amp;#34;}[5m])
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> )&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，您只需要在渲染仪表板时获取一个时间序列即可，即使正在播放检测标签，也能快速地返回结果，因为您将要处理的时间序列数减少了多少个实例。实际上，您正在以持续资源成本进行交易，而查询的延迟和资源成本却大大降低。由于这种折衷，使用长向量范围的规则通常是不明智的，因为这样的查询往往很昂贵，并且定期运行它们会导致性能问题。您应该尝试将一项工作的所有规则归为一组。这样，它们将具有相同的时间戳，并在您对它们进行进一步的数学运算时避免出现失真。一组中的所有记录规则对于执行都具有相同的查询评估时间，并且所有输出样本也将具有该时间戳。您通常会有基于相同度量标准但具有不同标签集的聚合规则。通过让一个规则使用另一个规则的输出，您可以提高效率，而不是单独计算每个聚合。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">groups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job_device:node_disk_read_bytes:rate5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="sd">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sum without(instance)(
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> rate(node_disk_read_bytes_total{job=&amp;#34;node&amp;#34;}[5m])
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> )&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job:node_disk_read_bytes:rate5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="sd">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sum without(device)(
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> job_device:node_disk_read_bytes:rate5m{job=&amp;#34;node&amp;#34;}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> )&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="组合-range-vector-函数">组合 Range Vector 函数&lt;/h2>
&lt;p>如前所述，不能在产生即时矢量的函数的输出上使用范围矢量函数，譬如 &lt;code>max_over_time(sum without(instance)(rate(x_total[5m]))[1h])&lt;/code> 这样的操作就是不可行的。我们可以利用 Recording Rules 实现这样的功能：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">groups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">j_job_rules&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job:x:rate5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="sd">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sum without(instance)(
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> rate(x_total{job=&amp;#34;j&amp;#34;}[5m])
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> )&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">record&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">job:x:max_over_time1h_rate5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">expr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">max_over_time(job:x:rate5m{job=&amp;#34;j&amp;#34;}[1h])&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此方法可与任何范围向量函数一起使用，不仅包括 &lt;code>_over_time&lt;/code> 函数，而且包括 &lt;code>predict_linear&lt;/code>，deriv 和 holt_winters。但是，此技术不应与 rate, irate, 或者 increase 一起使用，因为有效的速率表达 &lt;code>(sum（x_total）[5m])&lt;/code> 每次其组成计数器之一重置或消失时都会产生大量尖峰。&lt;/p></description></item><item><title>操作符</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E6%93%8D%E4%BD%9C%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid><description>&lt;h1 id="操作符">操作符&lt;/h1>
&lt;p>使用 PromQL 除了能够方便的按照查询和过滤时间序列以外，PromQL 还支持丰富的操作符，用户可以使用这些操作符对进一步的对事件序列进行二次加工。这些操作符包括：数学运算符，逻辑运算符，布尔运算符等等。&lt;/p>
&lt;h1 id="数学运算">数学运算&lt;/h1>
&lt;p>我们可以通过指标 node_memory_free_bytes_total 获取当前主机可用的内存空间大小，其样本单位为 Bytes。这是如果客户端要求使用 MB 作为单位响应数据，那只需要将查询到的时间序列的样本值进行单位换算即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">node_memory_free_bytes_total / &lt;span class="o">(&lt;/span>&lt;span class="m">1024&lt;/span> * 1024&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>node_memory_free_bytes_total 表达式会查询出所有满足表达式条件的时间序列，当瞬时向量与标量之间进行数学运算时，数学运算符会依次作用域瞬时向量中的每一个样本值，从而得到一组新的时间序列。而如果是瞬时向量与瞬时向量之间进行数学运算时，过程会相对复杂一点。例如，如果我们想根据 node_disk_bytes_written 和 node_disk_bytes_read 获取主机磁盘 IO 的总量，可以使用如下表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">node_disk_bytes_written + node_disk_bytes_read
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。同时新的时间序列将不会包含指标名称。该表达式返回结果的示例如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>&lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;sda&amp;#34;&lt;/span>,instance&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node_exporter&amp;#34;&lt;/span>&lt;span class="o">}=&lt;/span>&amp;gt;1634967552@1518146427.807 + 864551424@1518146427.807
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>&lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;sdb&amp;#34;&lt;/span>,instance&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node_exporter&amp;#34;&lt;/span>&lt;span class="o">}=&lt;/span>&amp;gt;0@1518146427.807 + 1744384@1518146427.807
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>PromQL 支持的所有数学运算符如下所示：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>+&lt;/code> (加法)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-&lt;/code> (减法)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>*&lt;/code> (乘法)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/&lt;/code> (除法)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>%&lt;/code> (求余)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>^&lt;/code> (幂运算)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="使用布尔运算过滤时间序列">使用布尔运算过滤时间序列&lt;/h1>
&lt;p>在 PromQL 通过标签匹配模式，用户可以根据时间序列的特征维度对其进行查询。而布尔运算则支持用户根据时间序列中样本的值，对时间序列进行过滤。
例如，通过数学运算符我们可以很方便的计算出，当前所有主机节点的内存使用率：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而系统管理员在排查问题的时候可能只想知道当前内存使用率超过 95%的主机，通过使用布尔运算符可以方便的获取到该结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total &amp;gt; 0.95&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>瞬时向量与标量进行布尔运算时，PromQL 依次比较向量中的所有时间序列样本的值，如果比较结果为 true 则保留，反之丢弃。瞬时向量与瞬时向量直接进行布尔运算时，同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的 右边向量元素进行相应的操作，如果没找到匹配元素，则直接丢弃。目前，Prometheus 支持以下布尔运算符如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>==&lt;/code> (相等)&lt;/li>
&lt;li>&lt;code>!=&lt;/code> (不相等)&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code> (大于)&lt;/li>
&lt;li>&lt;code>&amp;lt;&lt;/code> (小于)&lt;/li>
&lt;li>&lt;code>&amp;gt;=&lt;/code> (大于等于)&lt;/li>
&lt;li>&lt;code>&amp;lt;=&lt;/code> (小于等于)&lt;/li>
&lt;/ul>
&lt;h2 id="使用-bool-修饰符改变布尔运算符的行为">使用 bool 修饰符改变布尔运算符的行为&lt;/h2>
&lt;p>布尔运算符的默认行为是对时序数据进行过滤。而在其它的情况下我们可能需要的是真正的布尔结果。例如，只需要知道当前模块的 HTTP 请求量是否&amp;gt;=1000，如果大于等于 1000 则返回 1（true）否则返回 0（false）。这时可以使用 bool 修饰符改变布尔运算的默认行为。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">http_requests_total &amp;gt; bool 1000&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 bool 修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果 0 或者 1。从而形成一条新的时间序列。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">http_requests_total{code=&amp;#34;200&amp;#34;,handler=&amp;#34;query&amp;#34;,instance=&amp;#34;localhost:9090&amp;#34;,job=&amp;#34;prometheus&amp;#34;,method=&amp;#34;get&amp;#34;} 1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">http_requests_total{code=&amp;#34;200&amp;#34;,handler=&amp;#34;query_range&amp;#34;,instance=&amp;#34;localhost:9090&amp;#34;,job=&amp;#34;prometheus&amp;#34;,method=&amp;#34;get&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时需要注意的是，如果是在两个标量之间使用布尔运算，则必须使用 bool 修饰符：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">== bool 2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 结果为1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="集合运算符">集合运算符&lt;/h1>
&lt;p>使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，我们称为瞬时向量。通过集合运算，可以在两个瞬时向量与瞬时向量之间进行相应的集合操作。目前，Prometheus 支持以下集合运算符：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>and&lt;/code> (并且)：&lt;code>vector1 and vector2&lt;/code> 会产生一个由 vector1 的元素组成的新的向量。该向量包含 vector1 中完全匹配 vector2 中的元素组成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>or&lt;/code> (或者)：&lt;code>vector1 or vector2&lt;/code> 会产生一个新的向量，该向量包含 vector1 中所有的样本数据，以及 vector2 中没有与 vector1 匹配到的样本数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>unless&lt;/code> (排除)：&lt;code>vector1 unless vector2&lt;/code> 会产生一个新的向量，新向量中的元素由 vector1 中没有与 vector2 匹配的元素组成。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="匹配模式">匹配模式&lt;/h1>
&lt;p>向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。&lt;/p>
&lt;h2 id="一对一匹配">一对一匹配&lt;/h2>
&lt;p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">vector1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">operator&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">vector2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在操作符两边表达式标签不一致的情况下，可以使用 on(label list)或者 ignoring(label list）来修改便签的匹配行为。使用 ignoreing 可以在匹配时忽略某些便签。而 on 则用于将匹配行为限定在某些便签之内。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">ignoring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如当存在样本：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">method_code&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_errors&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">24&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">method_code&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_errors&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;404&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">30&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">method_code&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_errors&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;put&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;501&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">method_code&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_errors&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">6&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">method_code&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_errors&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;404&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">21&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">method&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_requests&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">600&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">method&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_requests&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;del&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">34&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">method&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_requests&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">120&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 PromQL 表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">method_code&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_errors&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nf">ignoring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">method&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_requests&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该表达式会返回在过去 5 分钟内，HTTP 请求状态码为 500 的在所有请求中的比例。如果没有使用 ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。因此结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">0.04&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="m">24&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="m">600&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">0.05&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="m">120&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时由于 method 为 put 和 del 的 样本 找不到匹配项，因此不会出现在结果当中。&lt;/p>
&lt;h2 id="多对一和一对多">多对一和一对多&lt;/h2>
&lt;p>多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与&amp;quot;多&amp;quot;侧的多个元素匹配的情况。在这种情况下，必须使用 group 修饰符：group_left 或者 group_right 来确定哪一个向量具有更高的基数（充当“多”的角色）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">ignoring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">group_left&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">ignoring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">group_right&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">group_left&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">group_right&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expr&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用 ignoring 和 on 修饰符来排除或者限定匹配的标签列表。&lt;/p>
&lt;p>例如,使用表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">method_code&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_errors&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nf">ignoring&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">group_left&lt;/span> &lt;span class="n">method&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">http_requests&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="n">rate5m&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该表达式中，左向量&lt;code>method_code:http_errors:rate5m&lt;/code>包含两个标签 method 和 code。而右向量&lt;code>method:http_requests:rate5m&lt;/code>中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为 code。在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 group 修饰符 group_left 指定左向量具有更好的基数。&lt;/p>
&lt;p>最终的运算结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">0.04&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="m">24&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="m">600&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;404&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">0.05&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="m">30&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="m">600&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">0.05&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="m">6&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="m">120&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;404&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">0.175&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="m">21&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="m">120&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提醒：group 修饰符只能在比较和数学运算符中使用。在逻辑运算 and,unless 和 or 才注意操作中默认与右向量中的所有元素进行匹配。&lt;/p></description></item><item><title>聚合操作</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C/</guid><description>&lt;h1 id="聚合操作">聚合操作&lt;/h1>
&lt;p>Prometheus 还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。&lt;/p>
&lt;ul>
&lt;li>&lt;code>sum&lt;/code> (求和)&lt;/li>
&lt;li>&lt;code>min&lt;/code> (最小值)&lt;/li>
&lt;li>&lt;code>max&lt;/code> (最大值)&lt;/li>
&lt;li>&lt;code>avg&lt;/code> (平均值)&lt;/li>
&lt;li>&lt;code>stddev&lt;/code> (标准差)&lt;/li>
&lt;li>&lt;code>stdvar&lt;/code> (标准差异)&lt;/li>
&lt;li>&lt;code>count&lt;/code> (计数)&lt;/li>
&lt;li>&lt;code>count_values&lt;/code> (对 value 进行计数)&lt;/li>
&lt;li>&lt;code>bottomk&lt;/code> (后 n 条时序)&lt;/li>
&lt;li>&lt;code>topk&lt;/code> (前 n 条时序)&lt;/li>
&lt;li>&lt;code>quantile&lt;/code> (分布统计)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">aggr&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">[parameter&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">vector&lt;/span> &lt;span class="n">expression&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">[without&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="nf">by &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">label&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中只有 &lt;code>count_values&lt;/code>, &lt;code>quantile&lt;/code>, &lt;code>topk&lt;/code>, &lt;code>bottomk&lt;/code> 支持参数(parameter)。&lt;/p>
&lt;h1 id="without--by">without &amp;amp; by&lt;/h1>
&lt;p>without 用于从计算结果中移除列举的标签，而保留其它标签。by 则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过 without 和 by 可以按照样本的问题对数据进行聚合。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">http_requests_total&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">without &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">instance&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 等价于&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">http_requests_total&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">by &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">handler&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">job&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="count_values">count_values&lt;/h1>
&lt;p>count_values 用于时间序列中每一个样本值出现的次数。count_values 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">count_values&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;count&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">http_requests_total&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="topk--bottomk">topk &amp;amp; bottomk&lt;/h1>
&lt;p>topk 和 bottomk 则用于对样本值进行排序，返回当前样本值前 n 位，或者后 n 位的时间序列。获取 HTTP 请求数前 5 位的时序样本数据，可以使用表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">topk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">http_requests_total&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="quantile">quantile&lt;/h1>
&lt;p>quantile 用于计算当前样本数据值的分布情况 quantile(φ, express)其中 0 ≤ φ ≤ 1。例如，当 φ 为 0.5 时，即表示找到当前样本数据中的中位数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">quantile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">0.5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">http_requests_total&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>内置函数</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</guid><description>&lt;h1 id="内置函数">内置函数&lt;/h1>
&lt;h1 id="counter-指标增长率">Counter 指标增长率&lt;/h1>
&lt;p>Counter 类型的监控指标其特点是只增不减，在没有发生重置（如服务器重启，应用重启）的情况下其样本值应该是不断增大的。为了能够更直观的表示样本数据的变化剧烈情况，需要计算样本的增长速率。&lt;/p>
&lt;h2 id="increase">increase&lt;/h2>
&lt;p>increase(v range-vector)函数是 PromQL 中提供的众多内置函数之一。其中参数 v 是一个区间向量，increase 函数获取区间向量中的第一个后最后一个样本并返回其增长量。因此，可以通过以下表达式 Counter 类型指标的增长率：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">increase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_cpu[2m]&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="m">120&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里通过 node_cpu[2m] 获取时间序列最近两分钟的所有样本，increase 计算出最近两分钟的增长量，最后除以时间 120 秒得到 node_cpu 样本在最近两分钟的平均增长率。并且这个值也近似于主机节点最近两分钟内的平均 CPU 使用率。&lt;/p>
&lt;h2 id="rate">rate&lt;/h2>
&lt;p>rate（v range-vector）可以直接计算区间向量 v 在时间窗口内平均增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。该函数的返回结果不带有度量指标，只有标签列表。以下示例表达式返回区间向量中每个时间系列在过去 5 分钟内测量的每秒 HTTP 请求率：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">rate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">http_requests_total&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">job&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;api-server&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="n">[5m]&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rate 应仅用于 Counter，在长期趋势分析或者告警中推荐使用这个函数。
注意，当将 rate() 与聚合运算符（例如 sum()）或随时间聚合的函数（任何以&lt;code>_over_time&lt;/code> 结尾的函数）组合时，始终首先采用 rate()，然后聚合。否则，当目标重新启动时，rate() 无法检测计数器重置。&lt;/p>
&lt;h2 id="irate">irate&lt;/h2>
&lt;p>rate 或者 increase 函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。例如，对于主机而言在 2 分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致 CPU 占用 100% 的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。&lt;/p>
&lt;p>irate(v range-vector)函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过 irate 函数绘制的图标能够更好的反应样本数据的瞬时变化状态。&lt;/p>
&lt;p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">irate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">http_requests_total&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">job&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;api-server&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="n">[5m]&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>irate 函数相比于 rate 函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate 的这种灵敏度反而容易造成干扰。因此在长期趋势分析或者告警中更推荐使用 rate 函数。当将 irate() 函数与聚合运算符（例如 sum()）或随时间聚合的函数（任何以 &lt;code>_over_time&lt;/code> 结尾的函数）一起使用时，必须先执行 irate 函数，然后再进行聚合操作，否则当采样目标重新启动时 irate() 无法检测到计数器是否被重置。&lt;/p>
&lt;h1 id="预测-gauge-指标变化趋势">预测 Gauge 指标变化趋势&lt;/h1>
&lt;p>在一般情况下，系统管理员为了确保业务的持续可用运行，会针对服务器的资源设置相应的告警阈值。例如，当磁盘空间只剩 512MB 时向相关人员发送告警通知。这种基于阈值的告警模式对于当资源用量是平滑增长的情况下是能够有效的工作的。但是如果资源不是平滑变化的呢？比如有些某些业务增长，存储空间的增长速率提升了高几倍。这时，如果基于原有阈值去触发告警，当系统管理员接收到告警以后可能还没来得及去处理问题，系统就已经不可用了。因此阈值通常来说不是固定的，需要定期进行调整才能保证该告警阈值能够发挥去作用。那么还有没有更好的方法吗？&lt;/p>
&lt;p>PromQL 中内置的 predict_linear(v range-vector, t scalar) 函数可以帮助系统管理员更好的处理此类情况，predict_linear 函数可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用如下表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">predict_linear&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_filesystem_free&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">job&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;node&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="n">[2h]&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="m">3600&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="统计-histogram-指标的分位数">统计 Histogram 指标的分位数&lt;/h1>
&lt;p>Histogram 和 Summary 都可以同于统计和分析数据的分布情况。区别在于 Summary 是直接在客户端计算了数据分布的分位数情况。而 Histogram 的分位数计算需要通过 histogram_quantile(φ float, b instant-vector)函数进行计算。其中 φ（0&amp;lt;φ&amp;lt;1）表示需要计算的分位数，如果需要计算中位数 φ 取值为 0.5，以此类推即可。&lt;/p>
&lt;p>以指标 http_request_duration_seconds_bucket 为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># HELP http_request_duration_seconds request duration histogram&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># TYPE http_request_duration_seconds histogram&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_bucket&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">le&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;0.5&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_bucket&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">le&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_bucket&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">le&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;2&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_bucket&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">le&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;3&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_bucket&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">le&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;5&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_bucket&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">le&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;+Inf&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_sum&lt;/span> &lt;span class="m">6&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">http_request_duration_seconds_count&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当计算 9 分位数时，使用如下表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">histogram_quantile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">0.5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">http_request_duration_seconds_bucket&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过对 Histogram 类型的监控指标，用户可以轻松获取样本数据的分布情况。同时分位数的计算，也可以非常方便的用于评判当前监控指标的服务水平。需要注意的是通过 histogram_quantile 计算的分位数，并非为精确值，而是通过 http_request_duration_seconds_bucket 和 http_request_duration_seconds_sum 近似计算的结果。&lt;/p>
&lt;h1 id="动态标签替换">动态标签替换&lt;/h1>
&lt;p>一般来说来说，使用 PromQL 查询到时间序列后，可视化工具会根据时间序列的标签来渲染图表。例如通过 up 指标可以获取到当前所有运行的 Exporter 实例以及其状态：&lt;/p>
&lt;pre tabindex="0">&lt;code>up{instance=&amp;#34;localhost:8080&amp;#34;,job=&amp;#34;cadvisor&amp;#34;} 1
up{instance=&amp;#34;localhost:9090&amp;#34;,job=&amp;#34;prometheus&amp;#34;} 1
up{instance=&amp;#34;localhost:9100&amp;#34;,job=&amp;#34;node&amp;#34;} 1
&lt;/code>&lt;/pre>&lt;p>这是可视化工具渲染图标时可能根据，instance 和 job 的值进行渲染，为了能够让客户端的图标更具有可读性，可以通过 label_replace 标签为时间序列添加额外的标签。label_replace 的具体参数如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)
&lt;/code>&lt;/pre>&lt;p>该函数会依次对 v 中的每一条时间序列进行处理，通过 regex 匹配 src_label 的值，并将匹配部分 relacement 写入到 dst_label 标签中。如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>label_replace(up, &amp;#34;host&amp;#34;, &amp;#34;$1&amp;#34;, &amp;#34;instance&amp;#34;, &amp;#34;(.*):.*&amp;#34;)
&lt;/code>&lt;/pre>&lt;p>函数处理后，时间序列将包含一个 host 标签，host 标签的值为 Exporter 实例的 IP 地址：&lt;/p>
&lt;pre tabindex="0">&lt;code>up{host=&amp;#34;localhost&amp;#34;,instance=&amp;#34;localhost:8080&amp;#34;,job=&amp;#34;cadvisor&amp;#34;} 1
up{host=&amp;#34;localhost&amp;#34;,instance=&amp;#34;localhost:9090&amp;#34;,job=&amp;#34;prometheus&amp;#34;} 1
up{host=&amp;#34;localhost&amp;#34;,instance=&amp;#34;localhost:9100&amp;#34;,job=&amp;#34;node&amp;#34;} 1
&lt;/code>&lt;/pre>&lt;p>除了 label_replace 以外，Prometheus 还提供了 label_join 函数，该函数可以将时间序列中 v 多个标签 src_label 的值，通过 separator 作为连接符写入到一个新的标签 dst_label 中:&lt;/p>
&lt;pre tabindex="0">&lt;code>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)
&lt;/code>&lt;/pre>&lt;p>label_replace 和 label_join 函数提供了对时间序列标签的自定义能力，从而能够更好的于客户端或者可视化工具配合。&lt;/p></description></item><item><title>数据查询</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</guid><description>&lt;h1 id="数据查询">数据查询&lt;/h1>
&lt;h1 id="查询时间序列">查询时间序列&lt;/h1>
&lt;p>当 Prometheus 通过 Exporter 采集到相应的监控指标样本数据后，我们就可以通过 PromQL 对监控样本数据进行查询。当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">http_requests_total&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">http_requests_total{}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">http_requests_total{code=&amp;#34;200&amp;#34;,handler=&amp;#34;alerts&amp;#34;,instance=&amp;#34;localhost:9090&amp;#34;,job=&amp;#34;prometheus&amp;#34;,method=&amp;#34;get&amp;#34;}=(20889@1518096812.326)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">http_requests_total{code=&amp;#34;200&amp;#34;,handler=&amp;#34;graph&amp;#34;,instance=&amp;#34;localhost:9090&amp;#34;,job=&amp;#34;prometheus&amp;#34;,method=&amp;#34;get&amp;#34;}=(21287@1518096812.326)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="匹配模式">匹配模式&lt;/h2>
&lt;p>PromQL 还支持用户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。PromQL 支持使用 = 和 != 两种完全匹配模式：&lt;/p>
&lt;ul>
&lt;li>通过使用 label=value 可以选择那些标签满足表达式定义的时间序列；&lt;/li>
&lt;li>反之使用 label!=value 则可以根据标签匹配排除时间序列；&lt;/li>
&lt;/ul>
&lt;p>例如，如果我们只需要查询所有 http_requests_total 时间序列中满足标签 instance 为 localhost:9090 的时间序列，则可以使用如下表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">http_requests_total{instance=&amp;#34;localhost:9090&amp;#34;}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 排除掉这些时间序列&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">http_requests_total{instance!=&amp;#34;localhost:9090&amp;#34;}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了使用完全匹配的方式对时间序列进行过滤以外，PromQL 还可以支持使用正则表达式作为匹配条件，多个表达式之间使用 &lt;code>|&lt;/code> 进行分离：使用 label=~regx 表示选择那些标签符合正则表达式定义的时间序列；反之使用 label!~regx 进行排除。例如，如果想查询多个环节下的时间序列序列可以使用如下表达式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">http_requests_total{environment=~&amp;#34;staging|testing|development&amp;#34;,method!=&amp;#34;GET&amp;#34;}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="范围查询">范围查询&lt;/h1>
&lt;p>直接通过类似于 PromQL 表达式 http_requests_total 查询时间序列时，返回值中只会包含该时间序列中的最新的一个样本值，这样的返回结果我们称之为瞬时向量；而相应的这样的表达式称之为瞬时向量表达式。范围向量选择器像瞬时向量选择器一样工作，不同的是它们从时间序列中选择一定时间范围内的数据。在语法上，范围持续时间附加在向量选择器末尾的方括号（[]）中。&lt;/p>
&lt;p>时间持续的值以数字表示，其后跟以下时间单位：&lt;/p>
&lt;ul>
&lt;li>s - 秒&lt;/li>
&lt;li>m - 分钟&lt;/li>
&lt;li>h - 小时&lt;/li>
&lt;li>d - 天&lt;/li>
&lt;li>w - 周&lt;/li>
&lt;li>y - 年&lt;/li>
&lt;/ul>
&lt;p>在此示例中，我们选择在过去 1 分钟内为 metric 为 prometheus_http_requests_total 且 job 标签设置为 prometheus 的所有时间序列记录的元素值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">prometheus_http_requests_total{job=&amp;#34;prometheus&amp;#34;}[1m]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2020/01/04/ldvlNT.png" alt="范围查询示意图" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="偏移修改器">偏移修改器&lt;/h1>
&lt;p>偏移修改器允许更改查询中各个瞬时和范围向量的时间偏移。例如，以下表达式返回相对于当前查询时间 5 分钟前 metric 为 http_requests_total 的元素值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">http_requests_total offset 5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 偏移修改器始终需要跟随在选择器之后&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">sum(http_requests_total{method=&amp;#34;GET&amp;#34;} offset 5m) // GOOD.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">sum(http_requests_total{method=&amp;#34;GET&amp;#34;}) offset 5m // INVALID.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 也适用于范围向量&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">rate(http_requests_total[5m] offset 1w)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="聚合操作">聚合操作&lt;/h1>
&lt;p>一般来说，如果描述样本特征的标签(label)在并非唯一的情况下，通过 PromQL 查询数据，会返回多条满足这些特征维度的时间序列。而 PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 查询系统所有http请求的总量&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">sum(http_request_total)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 按照mode计算主机 CPU 的平均使用时间&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">avg(node_cpu_seconds_total) by (mode)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 按照主机查询各个主机的 CPU 使用率&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">sum(sum(irate(node_cpu_seconds_total{mode!=&amp;#39;idle&amp;#39;}[5m])) / sum(irate(node_cpu_seconds_total[5m]))) by (instance)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="标量和字符串">标量和字符串&lt;/h1>
&lt;p>除了使用瞬时向量表达式和区间向量表达式以外，PromQL 还直接支持用户使用标量(Scalar)和字符串(String)。&lt;/p>
&lt;h2 id="标量">标量&lt;/h2>
&lt;p>标量只有一个数字，没有时序。例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>10
&lt;/code>&lt;/pre>&lt;p>需要注意的是，当使用表达式 count(http_requests_total)，返回的数据类型，依然是瞬时向量。用户可以通过内置函数 scalar() 将单个瞬时向量转换为标量。&lt;/p>
&lt;h2 id="字符串">字符串&lt;/h2>
&lt;p>直接使用字符串，作为 PromQL 表达式，则会直接返回字符串。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;this is a string&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">&amp;#39;these are unescaped&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">\n \\ \t&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">`these are not unescaped&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">\n &amp;#39; &amp;#34; \t`&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="子查询">子查询&lt;/h1>
&lt;p>子查询允许您在给定范围和分辨率内运行瞬时查询。子查询的结果是范围向量。&lt;/p>
&lt;p>语法:&lt;code>&amp;lt;instant_query&amp;gt; '[' &amp;lt;range&amp;gt; ':' [&amp;lt;resolution&amp;gt;] ']' [ offset &amp;lt;duration&amp;gt; ]&lt;/code>，&lt;code>&amp;lt;resolution&amp;gt;&lt;/code> 可缺省。&lt;/p>
&lt;h1 id="查询优化">查询优化&lt;/h1>
&lt;h2 id="陈旧性">陈旧性&lt;/h2>
&lt;p>运行查询时，选择采样数据（独立于实际当前时间序列）的时间戳。这主要是为了支持聚合（总和，平均等）这样的情况，其中多个聚合时间序列在时间上不完全对齐。由于它们的独立性，Prometheus 需要在每个相关时间序列的时间戳上分配值。它只需在此时间戳之前采用最新的样本即可。&lt;/p>
&lt;p>如果目标抓取或规则评估不再返回先前存在的时间序列的样本，则该时间序列将被标记为陈旧。如果目标被移除，之前很快就会将其先前返回的时间序列标记为陈旧。如果在时间序列标记为过时后在采样时间戳处计算查询，则不会为该时间系列返回任何值。如果随后在该时间序列中摄取新样本，它们将照常返回。&lt;/p>
&lt;p>如果在采样时间戳前 5 分钟未找到任何样本（默认情况下），则此时间点不返回该时间序列的值。这实际上意味着时间序列在其最新收集的样本超过 5 分钟或者标记为陈旧之后从图表“消失”。对于在其刮擦中包含时间戳的时间序列，不会标记陈旧性。在这种情况下，仅应用 5 分钟的阈值。&lt;/p>
&lt;h2 id="避免慢查询和重载">避免慢查询和重载&lt;/h2>
&lt;p>如果查询需要对大量数据进行操作，则绘制图表可能会超时或使服务器或浏览器过载。因此，在构建对未知数据的查询时，始终在 Prometheus 表达式浏览器的表格视图中开始构建查询，直到结果集看起来合理（最多数百个，而不是数千个时间序列）。只有在您充分过滤或汇总数据后，才能切换到图表模式。如果表达式仍然需要很长时间来绘制图形，请通过记录规则 预先记录它。&lt;/p>
&lt;p>这与 Prometheus 的查询语言尤其相关，其中像 api_http_requests_total 这样的简单 metric 选择器可以扩展到具有不同标签的数千个时间序列。还要注意，即使输出只是少量的时间序列，聚合在许多时间序列上的表达式也会在服务器上产生负载。这类似于在关系数据库中对列的所有值求和的速度很慢，即使输出值只是一个数字。&lt;/p></description></item><item><title>数据模型</title><link>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/6.%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/prometheus/promql/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="数据模型">数据模型&lt;/h1>
&lt;p>Prometheus 从根本上存储的所有数据都是时间序列: 具有时间戳的数据流只属于单个度量指标和该度量指标下的多个标签维度。Prometheus 采用了单值模型，数据模型的核心概念是 metric,labels 和 samples；其格式为：&lt;code>&amp;lt;metric name&amp;gt;{&amp;lt;label name&amp;gt;=&amp;lt;label value&amp;gt;, …}&lt;/code>。一条 Prometheus 数据由一个指标名称（metric）和 N 个标签（label，N &amp;gt;= 0）组成的，比如下面这个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">promhttp_metric_handler_requests_total&lt;span class="o">{&lt;/span>&lt;span class="nv">code&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;200&amp;#34;&lt;/span>,instance&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;192.168.0.107:9090&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;prometheus&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">106&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>metric 的命名具有业务含义，比如 http_request_total，指标的类型分为：Counter，Gauge，Historgram，Summary。labels 用于表示维度，samples 由时间戳和数值组成。Prometheus 会自动生成 target 和 instances 作为标签。这种数据模型和 OpenTSDB 的数据模型是比较类似的，详细的信息可以参考官网文档 &lt;a href="https://prometheus.io/docs/concepts/data_model/" target="_blank" rel="noopener">Data model&lt;/a>。另外，关于指标和标签的命名，官网有一些指导性的建议，可以参考 &lt;a href="https://prometheus.io/docs/practices/naming/" target="_blank" rel="noopener">Metric and label naming&lt;/a>。&lt;/p>
&lt;p>除了存储时间序列数据外，Prometheus 也可以利用查询表达式存储 5 分钟的返回结果中的时间序列数据。&lt;/p>
&lt;h1 id="metrics-name--label">Metrics Name &amp;amp; Label&lt;/h1>
&lt;p>每条时间序列是由唯一的指标名称和一组标签 (key=value)的形式组成。指标名称 一般是给监测对像起一名字，例如 &lt;code>http_requests_total&lt;/code> 这样，它有一些命名规则，可以包字母数字之类的的。通常是以 &lt;code>应用名称开头_监测对像_数值类型_单位&lt;/code> 这样。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>push_total&lt;/p>
&lt;/li>
&lt;li>
&lt;p>userlogin_mysql_duration_seconds&lt;/p>
&lt;/li>
&lt;li>
&lt;p>app_memory_usage_bytes&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>标签 就是对一条时间序列不同维度的识别了，例如 一个 http 请求用的是 POST 还是 GET，它的 endpoint 是什么，这时候就要用标签去标记了。最终形成的标识便是这样了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">http_requests_total{method=&amp;#34;POST&amp;#34;,endpoint=&amp;#34;/api/tracks&amp;#34;}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>针对 http_requests_total 这个 metrics name 无论是增加标签还是删除标签都会形成一条新的时间序列。查询语句就可以跟据上面标签的组合来查询聚合结果了。如果以传统数据库的理解来看这条语句，则可以考虑 http_requests_total 是表名，标签是字段，而 timestamp 是主键，还有一个 float64 字段是值了。&lt;/p>
&lt;h1 id="counter只增不减的计数器">Counter：只增不减的计数器&lt;/h1>
&lt;p>Counter 类型代表一种样本数据单调递增的指标，即只增不减，并且您的应用程序在其 metrics 上公开的值是自启动以来的总和。可以使用 counter 类型的指标来表示服务的请求数、已完成的任务数、错误发生的次数等。譬如，如果我们要去计算每秒吞吐的网络流量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">rate(node_network_receive_bytes_total[5m])&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>[5m]&lt;/code> 意为使用过去五分钟的数据进行计算，即会得到过去五分钟的平均值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">{&lt;span class="l">device=&amp;#34;lo&amp;#34;,instance=&amp;#34;localhost:9100&amp;#34;,job=&amp;#34;node&amp;#34;} 1859.389655172414&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>{&lt;span class="l">device=&amp;#34;wlan0&amp;#34;,instance=&amp;#34;localhost:9100&amp;#34;,job=&amp;#34;node&amp;#34;} 1314.5034482758622&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rate 函数的输出值即为 Gauge，我们也就可以应用 Gauge 的聚合函数。如上的用法，我们也可以忽略网卡详情而获得总的容量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">sum without(device)(rate(node_network_receive_bytes_total[5m]))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># {instance=&amp;#34;localhost:9100&amp;#34;,job=&amp;#34;node&amp;#34;} 3173.8931034482762&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者我们也可以指定获取某个网卡的数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">sum without(instance)(rate(node_network_receive_bytes_total{device=&amp;#34;eth0&amp;#34;}[5m]))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># {device=&amp;#34;eth0&amp;#34;,job=&amp;#34;node&amp;#34;} 3173.8931034482762&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="gauge可增可减的仪表盘">Gauge：可增可减的仪表盘&lt;/h1>
&lt;p>Gauge 是对于状态的快照，通常被用于那些需要求和、求平均以及最小值、最大值的场景。Gauge 类型代表一种样本数据可以任意变化的指标，即可增可减。Gauge 通常用于像温度或者内存使用率这种指标数据，也可以表示能随时增加或减少的“总数”。常见指标如：node_memory_MemFree（主机当前空闲的内容大小）、node_memory_MemAvailable（可用内存大小）都是 Gauge 类型的监控指标。&lt;/p>
&lt;p>譬如 Node Exporter 导出了 node_filesystem_size_bytes 这个度量，其反映了挂载的文件系统的体积，并且包含了 device, fstype, 以及 mountpoint 标签。我们能够通过如下的方式计算总的文件大小：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sum without&lt;span class="o">(&lt;/span>device, fstype, mountpoint&lt;span class="o">)(&lt;/span>node_filesystem_size_bytes&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 without 函数会高速 sum 聚合器将有相同 label 的度量值相加，但是忽略 device, fstype, 以及 mountpoint 标签。我们可能会得到如下的结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">node_filesystem_free_bytes&lt;span class="o">{&lt;/span>&lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/dev/sda1&amp;#34;&lt;/span>,fstype&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;vfat&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">instance&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>,mountpoint&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/boot/efi&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">70300672&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">node_filesystem_free_bytes&lt;span class="o">{&lt;/span>&lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/dev/sda5&amp;#34;&lt;/span>,fstype&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ext4&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">instance&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>,mountpoint&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">30791843840&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">node_filesystem_free_bytes&lt;span class="o">{&lt;/span>&lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;tmpfs&amp;#34;&lt;/span>,fstype&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;tmpfs&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">instance&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>,mountpoint&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/run&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">817094656&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">node_filesystem_free_bytes&lt;span class="o">{&lt;/span>&lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;tmpfs&amp;#34;&lt;/span>,fstype&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;tmpfs&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">instance&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>,mountpoint&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/run/lock&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">5238784&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">node_filesystem_free_bytes&lt;span class="o">{&lt;/span>&lt;span class="nv">device&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;tmpfs&amp;#34;&lt;/span>,fstype&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;tmpfs&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">instance&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>,mountpoint&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/run/user/1000&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">826912768&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 聚合的结果如下&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>&lt;span class="nv">instance&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;localhost:9100&amp;#34;&lt;/span>,job&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">32511390720&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样地，我们也可以忽略 instance 标签，即获得总的文件系统的大小：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">sum without(device, fstype, mountpoint, instance)(node_filesystem_size_bytes)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>{&lt;span class="l">job=&amp;#34;node&amp;#34;} 32511390720&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>您可以对其他聚合使用相同的方法。max 会告诉您每台计算机上最大的已挂载文件系统的大小：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">max without(device, fstype, mountpoint)(node_filesystem_size_bytes)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># {instance=&amp;#34;localhost:9100&amp;#34;,job=&amp;#34;node&amp;#34;} 30792601600&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">avg without(instance, job)(process_open_fds)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 Gauge 类型的监控指标，通过 PromQL 内置函数 delta()可以获取样本在一段时间返回内的变化情况。例如，计算 CPU 温度在两个小时内的差异：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">delta(cpu_temp_celsius{host=&amp;#34;zeus&amp;#34;}[2h])&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以使用 deriv()计算样本的线性回归模型，甚至是直接使用 predict_linear()对数据的变化趋势进行预测。例如，预测系统磁盘空间在 4 个小时之后的剩余情况：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">predict_linear(node_filesystem_free{job=&amp;#34;node&amp;#34;}[1h], 4 * 3600)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="使用-histogram-和-summary-分析数据分布情况">使用 Histogram 和 Summary 分析数据分布情况&lt;/h1>
&lt;p>除了 Counter 和 Gauge 类型的监控指标以外，Prometheus 还定义了 Histogram 和 Summary 的指标类型。Histogram 和 Summary 主用用于统计和分析样本的分布情况。&lt;/p>
&lt;p>在大多数情况下人们都倾向于使用某些量化指标的平均值，例如 CPU 的平均使用率、页面的平均响应时间。这种方式的问题很明显，以系统 API 调用的平均响应时间为例：如果大多数 API 请求都维持在 100ms 的响应时间范围内，而个别请求的响应时间需要 5s，那么就会导致某些 WEB 页面的响应时间落到中位数的情况，而这种现象被称为长尾问题。&lt;/p>
&lt;p>为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如，统计延迟在 0~10ms 之间的请求数有多少而 10~20ms 之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。Histogram 和 Summary 都是为了能够解决这样问题的存在，通过 Histogram 和 Summary 类型的监控指标，我们可以快速了解监控样本的分布情况。&lt;/p>
&lt;p>例如，指标 prometheus_tsdb_wal_fsync_duration_seconds 的指标类型为 Summary。它记录了 Prometheus Server 中 wal_fsync 处理的处理时间，通过访问 Prometheus Server 的/metrics 地址，可以获取到以下监控样本数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># TYPE prometheus_tsdb_wal_fsync_duration_seconds summary&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&amp;#34;0.5&amp;#34;} 0.012352463&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&amp;#34;0.9&amp;#34;} 0.014458005&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&amp;#34;0.99&amp;#34;} 0.017316173&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_wal_fsync_duration_seconds_count 216&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的样本中可以得知当前 Prometheus Server 进行 wal_fsync 操作的总次数为 216 次，耗时 2.888716127000002s。其中中位数（quantile=0.5）的耗时为 0.012352463，9 分位数（quantile=0.9）的耗时为 0.014458005s。在 Prometheus Server 自身返回的样本数据中，我们还能找到类型为 Histogram 的监控指标 prometheus_tsdb_compaction_chunk_range_bucket。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># HELP prometheus_tsdb_compaction_chunk_range Final time range of chunks on their first compaction&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># TYPE prometheus_tsdb_compaction_chunk_range histogram&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;100&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;400&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;1600&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;6400&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;25600&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;102400&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;409600&amp;#34;} 0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;1.6384e+06&amp;#34;} 260&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;6.5536e+06&amp;#34;} 780&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;2.62144e+07&amp;#34;} 780&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_bucket{le=&amp;#34;+Inf&amp;#34;} 780&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">prometheus_tsdb_compaction_chunk_range_count 780&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与 Summary 类型的指标相似之处在于 Histogram 类型的样本同样会反应当前指标的记录的总数(以 &lt;code>_count&lt;/code> 作为后缀)以及其值的总量（以 &lt;code>_sum&lt;/code> 作为后缀）。不同在于 Histogram 指标直接反应了在不同区间内样本的个数，区间通过标签 len 进行定义。&lt;/p>
&lt;p>同时对于 Histogram 的指标，我们还可以通过 histogram_quantile()函数计算出其值的分位数。不同在于 Histogram 通过 histogram_quantile 函数是在服务器端计算的分位数。而 Sumamry 的分位数则是直接在客户端计算完成。因此对于分位数的计算而言，Summary 在通过 PromQL 进行查询时有更好的性能表现，而 Histogram 则会消耗更多的资源。反之对于客户端而言 Histogram 消耗的资源更少。在选择这两种方式时用户应该按照自己的实际场景进行选择。&lt;/p>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/beusaP2f3mOMIlEETBhtjg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/beusaP2f3mOMIlEETBhtjg&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>