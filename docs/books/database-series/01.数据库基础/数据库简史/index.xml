<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据库简史 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/</link><atom:link href="https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/index.xml" rel="self" type="application/rss+xml"/><description>数据库简史</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>数据库简史</title><link>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/</link></image><item><title>01.编年史</title><link>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/01.%E7%BC%96%E5%B9%B4%E5%8F%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/01.%E7%BC%96%E5%B9%B4%E5%8F%B2/</guid><description>&lt;h1 id="数据库编年史">数据库编年史&lt;/h1>
&lt;p>数据库领域图灵奖获得者 Jim Gray 说过：所有的存储系统最终都会演变成数据库系统。(All storage systems will eventually evolve to be database systems.)。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/superbed/2021/08/07/610e9c1a5132923bf8f83d9d.jpg" alt="数据库编年史" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="1960-年代第一个数据库">1960 年代：第一个数据库&lt;/h1>
&lt;p>1961 年，Charles Bachman 等人设计了第一个计算机数据库管理系统(DBMS)，这个网状模型(Network model)的数据库被称为 IDS（Integrated Data Store）。随后不久，IBM 在 1968 年开发了层次模型(hierarchical model)的数据库 IMS（Information Management System）。这两个数据库都是实验性的先行者。&lt;/p>
&lt;p>无论是网状模型还是层次模型，最开始的数据库都非常难用，没有很多我们如今习惯的东西：&lt;/p>
&lt;ul>
&lt;li>没有表，更没有 SQL；&lt;/li>
&lt;li>数据粗暴存储，不得不通过指针遍历整个数据结构来进行查询；&lt;/li>
&lt;li>逻辑层和物理层并不分离，没有独立的模式(schema)，要增加属性，必须重新加载全部的数据然后转存；&lt;/li>
&lt;/ul>
&lt;p>最初的数据库没有独立存储数据，没有任何抽象，这导致开发者需要耗费大量精力来使用。&lt;/p>
&lt;h1 id="1970-年代关系型数据库">1970 年代：关系型数据库&lt;/h1>
&lt;p>到了 20 世纪 70 年代，IBM 的研究员 Edgar Frank Codd 看到他周围的程序员每天花费大量时间处理查询、改变模式和思考如何存储数据，于是他创造了今天众所周知的关系模型。关系模型建立之后，IBM 开启了著名的 System R 进行专项研究，该项目是第一个实现 SQL 和事务的 DBMS。System R 的设计对后来各类数据库产生了积极的影响。&lt;/p>
&lt;p>关系模型摆脱了查询和数据存储之间的紧密耦合，查询独立于存储，数据库可以自由地在幕后进行优化，程序员无需知道背后的存储方式，只需要通过 SQL 与数据库进行交互，这对于开发者非常友好。1978 年 Oracle 发布，点燃了商业数据库的导火线。&lt;/p>
&lt;h1 id="20-世纪末走向成熟">20 世纪末：走向成熟&lt;/h1>
&lt;p>接下来的几十年里，数据库进入成长期，一步步走向成熟。早期的层次模型和网状模型消失了，关系型数据库成为主流。SQL 成为数据库标准查询语言，直到今天我们仍然在使用。&lt;/p>
&lt;p>数据库商业化也越来越完善，同时开始出现如 PostgreSQL 和 MySQL 等开源数据库。由于大型商业数据库非常昂贵，一些互联网企业开始使用 MySQL 等开源数据库作为替代方案。&lt;/p>
&lt;h1 id="2000-年代nosql">2000 年代：NoSQL&lt;/h1>
&lt;p>21 世纪伊始，互联网走向繁荣，突然间许多公司需要支持越来越多的用户，并且必须 &lt;code>24*7&lt;/code> 不间断运行服务，为此互联网公司不得不在多台计算机上复制(replication)和分片(shard)存储他们的数据。&lt;/p>
&lt;p>分片存储即将表按照某个关键字拆分成多个分片，例如按照年进行拆分，2000 年的数据存储在第一台机器上，2001 年的数据存储在第二台机器上，以此类推。这通常由数据库管理员来完成。同时为了让应用程序不修改代码、无感知地读写分片数据，必须要将一个中间件放到这些分片前面，将应用程序原本的 SQL 转换为支持分片的 SQL。如下图所示。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/superbed/2021/08/07/610e9cf15132923bf8f95ee6.jpg" alt="数据库分片方案" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>当然，这类方案也有一些缺点，例如：&lt;/p>
&lt;ul>
&lt;li>不支持跨分片事务；&lt;/li>
&lt;li>重新分片是困难的，会成为数据库管理员的噩梦；&lt;/li>
&lt;/ul>
&lt;p>Google 等公司如此分片存储数据库，目的是不惜一切代价来获得可扩展性，因为他们需要构建越来越大的应用，服务越来越多的用户。这些事情都是为了追求可扩展性。为此，这些公司还开发了 NoSQL，不惜放弃了关系模型，放弃了事务，放弃了数据一致性保证（有的 NoSQL 只保证最终一致性）。&lt;/p>
&lt;p>前文提到，20 世纪 70 年代 Edgar Frank Codd 为了减轻开发人员心智负担而设计了关系型数据库，而 NoSQL 解决了应用程序所需的可扩展性，但又好似退回到了以前，程序员又要面临 NoSQL 功能不足的问题——也就是 Jim Gray 所说的：“所有的存储系统最终都会演变成数据库系统。”&lt;/p>
&lt;h1 id="2010-年代分布式数据库">2010 年代：分布式数据库&lt;/h1>
&lt;p>为什么要构建分布式数据库呢？通过历史发展分析应该相当清楚了，现有的数据库解决方案给开发者和管理员带来了过重的负担。当你开始一个新的大项目，选择一个单点数据库会牺牲掉未来的可扩展性，选择一个 NoSQL 又会让开发者承受额外的负担来解决问题，并且可能不支持事务等优秀的功能。&lt;/p>
&lt;p>分布式数据库试图结合两者优点，构建成为两全其美的系统：既能支持完整的关系模型，又能提供高可扩展性和可用性。分布式数据库常被称为 NewSQL 或 Distributed SQL：无论怎么称呼，都指那些在多台机器运行的数据库。这不是说 NoSQL 是完全没用的，事实上人们在 NoSQL 上构建了许多成功的系统，但这要困难得多。Google 的分布式数据库 Spanner 论文中有一句话：&lt;/p>
&lt;blockquote>
&lt;p>We believe it is better to have application programmers deal with performance problems due to overuse of transactions as bottlenecks arise, rather than always coding around the lack of transactions. 我们认为最好让应用程序开发者来解决因过度使用事务而导致的性能问题，而不是让开发者总是围绕着缺少事务编写代码。&lt;/p>
&lt;/blockquote>
&lt;p>也就是说，事务是否会造成性能影响的应该由业务开发者来考虑，而作为一个数据库必须提供事务机制，来满足各种应用常见的需求。Spanner 论文发表后，开始涌现出许多优秀的开源分布式数据库，其中具有代表性的有：CockroachDB、TiDB、YugabyteDB 和最近开源的 OceanBase 等等。&lt;/p></description></item><item><title>2.DBMS</title><link>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/2.dbms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/2.dbms/</guid><description>&lt;h1 id="dbms">DBMS&lt;/h1>
&lt;p>后来到了 20 世纪 50 年代后期，随着磁盘、操作系统、磁芯存储器等数据存储设备的出现，新的数据处理系统迅猛发展起来。其中在操作系统中，也诞生了一种专门管理数据的软件，而它被称之为文件系统。彼时的文件系统对于企业而言，通常被视为一种存储着无数离散的对象的文件柜，不过这也实现了记录内的结构化。&lt;/p>
&lt;p>20 世纪 60 年代，当计算机开始广泛应用于数据管理，以及大量信息的涌入时，业界发现传统的文件系统已经远远无法满足对于查询、存储、管理数据的需求，恰逢此时能够统一管理和共享数据的数据库管理系统（DBMS）应运而生，最终基于 DBMS，用户可以更加方便快捷地编组大量数据。1964 年前后，来自军事信息系统的工作人员创下了（Data Base）数据库一词，用以表示由分时共享计算机系统终端用户共享的数据集合，可以视作数据库概念的真正诞生。&lt;/p>
&lt;p>数据库系统的萌芽出现于 60 年代。当时计算机开始广泛地应用于数据管理，对数据的共享提出了越来越高的要求。传统的文件系统已经不能满足人们的需要。能够统一管理和共享数据的数据库管理系统（DBMS）应运而生。1961 年通用电气公司（General ElectricCo.）的 Charles Bachman 成功地开发出世界上第一个网状 DBMS 也是第一个数据库管理系统&amp;mdash;- 集成数据存储（Integrated DataStore IDS），奠定了网状数据库的基础。&lt;/p>
&lt;p>1970 年，IBM 的研究员 E.F.Codd 博士在刊物 Communication of the ACM 上发表了一篇名为&amp;quot;A Relational Modelof Data for Large Shared Data Banks&amp;quot;的论文，提出了关系模型的概念，奠定了关系模型的理论基础。1974 年，IBM 的 Ray Boyce 和 DonChamberlin 将 Codd 关系数据库的 12 条准则的数学定义以简单的关键字语法表现出来，里程碑式地提出了 SQL（Structured Query Language）语言。在很长的时间内，关系数据库（如 MySQL 和 Oracle）对于开发任何类型的应用程序都是首选，巨石型架构也是应用程序开发的标准架构。&lt;/p></description></item><item><title>3.NoSQL</title><link>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/3.nosql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/3.nosql/</guid><description>&lt;h1 id="nosql">NoSQL&lt;/h1>
&lt;p>NoSQL 的爆发与 Web 2.0 时代互联网数据的爆炸式增长密切相关，传统的关系数据库无法处理如此大量的数据，基于传统的关系数据模型实现高可用性和可扩展的分布式数据库非常具有挑战性，因此需要具有高可伸缩性的分布式数据库。并且互联网上大多数数据的数据模型很简单，不需要关系模型进行建模，因此可以削弱事务和约束，并以高可用性和可伸缩性为目标，从而更好地满足业务需求。NoSQL 提出初期有人称为 No SQL，即完全去 SQL 化；而随着实践的深入，更多的人将其称为 Not only SQL，也有很多的 NoSQL 数据库同样支持 ACID 事务。&lt;/p>
&lt;p>采用 NoSQL 数据库的背后有几个驱动因素，其中包括：&lt;/p>
&lt;ul>
&lt;li>需要比关系数据库更好的可扩展性，包括非常大的数据集或非常高的写入吞吐量&lt;/li>
&lt;li>相比商业数据库产品，免费和开源软件更受偏爱。&lt;/li>
&lt;li>关系模型不能很好地支持一些特殊的查询操作。&lt;/li>
&lt;li>受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型。&lt;/li>
&lt;/ul>
&lt;p>NoSQL 家族主要分为键值(Key-Value)存储数据库、列存储数据库、文档型数据库和图数据库四大类，其产生就是为了解决大规模数据集合多重数据种类带来的挑战，故场景化也格外明显。键值存储数据库适用于内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等；列存储数据库适用于分布式的文件系统；文档型数据库适用于 Web 应用中的非结构化存储；图数据库适用于社交网络、推荐系统等，专注于构建关系图谱。&lt;/p>
&lt;h1 id="schema-less">schema-less&lt;/h1>
&lt;p>文档数据库有时称为无模式（schema-less）这是不正确的，因为存在隐式架构更好的方式是写模式（schema-on-write，数据库在存储值时强制执行模式）和读模式（schema-on-read，模式是隐式的，仅在读取数据时才解释）这类似于编程语言中的静态类型和动态类型。&lt;/p>
&lt;h1 id="nosql-1">NoSQL&lt;/h1>
&lt;p>近年来随着互联网的迅猛发展，产生了庞大的数据，也催生了 NoSQL、NewSQL 等新一代数据库的出现。2009 年 MongoDB 开源，掀开了 NoSQL 的序幕，一时之间 NoSQL 的概念受人追捧，MongoDB 也因为其易用性迅速在社区普及。NoSQL 抛弃了传统关系数据库中的事务和数据一致性，从而在性能上取得了极大提升，并且天然支持分布式集群。&lt;/p>
&lt;p>然而，不支持事务始终是 NoSQL 的痛点，让它无法在关键系统中使用。2012 年，Google 发布了 Spanner 论文，从此既支持分布式又支持事务的数据库逐渐诞生，。以 TiDB、蟑螂数据库等为代表的 NewSQL 身兼传统关系数据库和 NoSQL 的优点，开始崭露头角。2014 年亚马逊推出了基于新型 NVME SSD 虚拟存储层的 Aurora，它实现了完全兼容 MySQL 的超大单机数据库，于单点写多点读的主从架构做了进一步的发展，使得事务和存储引擎分离，为数据库架构的发展提供了具有实战意义的已实践用例。另外，各种不同用途的数据库也纷纷诞生并取得了较大的发展，比如用于 LBS 的地理信息数据库，用于监控和物联网的时序数据库，用于知识图谱的图数据库等。&lt;/p>
&lt;p>与数据库技术的历史发展类似，数据库的托管方式在过去几十年中也发生了很大变化。在网络发展的早期，每个人都必须在自己的物理服务器上运行数据库，EC2 和 Digital Ocean 使这变得更容易，但仍需要深入的技术理解来手动操作数据库。诸如 Heroku 的 Postgres 服务，AWS RDS 和 Mongo Atlas 等托管服务抽象出了许多复杂的细节，数据库管理变得更加简单，但底层模型仍然相同，需要开发人员提前配置计算容量。最新开发的无服务器数据库使开发人员无需担心基础架构，因为他们的数据库只需根据实际使用情况进行扩展和缩小以匹配当前负载，其中 Aurora Serverless 和 CosmosDB 就是一个突出的例子。&lt;/p></description></item><item><title>4.数据库选择</title><link>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/4.%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/4.%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E6%8B%A9/</guid><description>&lt;h1 id="数据库选择">数据库选择&lt;/h1>
&lt;p>您选择的数据库系统可能会产生长期影响如果数据库可能由于性能问题，一致性问题或操作难题而不太适合，则最好在开发周期中早些找到它，因为迁移到其他系统可能并不容易在某些情况下，可能需要对应用程序代码进行实质性更改。每个数据库系统都有优点和缺点为了降低进行昂贵迁移的风险，您可以花一些时间再决定使用哪个数据库来建立对数据库满足应用程序需求的信心。&lt;/p>
&lt;p>尝试根据数据库的组件（例如，数据库使用的存储引擎，如何共享，复制和分发数据等），数据库的等级（由 ThoughtWorks 等咨询机构或数据库比较网站分配的任意受欢迎度值）进行比较 例如 DB-Engines 或数据库数据库）或实现语言（C++，Java 或 Go 等）可能导致无效和过早的结论这些方法只能用于高级比较，并且可以像在 HBase 和 SQLite 之间进行选择一样粗略，因此即使对每个数据库的工作方式及其内部内容有一个肤浅的了解也可以帮助您得出更加权的结论。&lt;/p>
&lt;p>每次比较都应从明确定义目标开始，因为即使是最微小的偏差也可能完全使整个调查无效如果您要搜索的数据库非常适合您拥有的（或正计划减轻）工作负载，那么您最好的办法就是针对不同的数据库系统模拟这些工作负载，衡量重要的性能指标 为您，并比较结果一些问题，尤其是在性能和 可伸缩性方面，仅在一段时间或容量增长后才开始显示为了检测潜在的问题，最好在尽可能接近实际生产环境的环境中进行长时间运行的测试。&lt;/p>
&lt;p>模拟现实世界的工作负载不仅可以帮助您了解数据库的性能，还可以帮助您学习如何操作，调试和发现数据库社区的友好程度和帮助程度选择数据库总是将这些因素结合在一起，而性能通常并不是最重要的方面：通常使用缓慢保存数据的数据库要比快速丢失数据的数据库好得多。&lt;/p>
&lt;h2 id="比较项">比较项&lt;/h2>
&lt;p>要比较数据库，可以非常详细地了解用例并定义当前和预期的变量，例如：&lt;/p>
&lt;ul>
&lt;li>架构和记录大小&lt;/li>
&lt;li>客户数量&lt;/li>
&lt;li>查询类型和访问模式&lt;/li>
&lt;li>读写查询率&lt;/li>
&lt;li>这些变量的预期变化&lt;/li>
&lt;/ul>
&lt;p>了解这些变量可以帮助回答以下问题：&lt;/p>
&lt;ul>
&lt;li>数据库是否支持必需的查询？&lt;/li>
&lt;li>该数据库是否能够处理我们计划存储的数据量？&lt;/li>
&lt;li>一个节点可以处理多少个读写操作？&lt;/li>
&lt;li>系统应具有多少个节点？&lt;/li>
&lt;li>给定预期增长率，我们如何扩展集群？&lt;/li>
&lt;li>什么是保养程序？&lt;/li>
&lt;/ul>
&lt;p>回答完这些问题后，您可以构建测试集群并模拟您的工作负载大多数数据库已经具有压力工具，可用于重建特定的用例如果没有标准的压力工具可以在数据库生态系统中生成现实的随机工作负载，则可能是一个危险信号如果某些情况使您无法使用默认工具，则可以尝试使用现有的通用工具之一，也可以从头开始实施。&lt;/p>
&lt;h2 id="源码探究">源码探究&lt;/h2>
&lt;p>如果测试显示出积极的结果，熟悉数据库代码可能会有所帮助查看代码，通常首先了解数据库的各个部分，如何找到不同组件的代码，然后进行导航，这通常很有用甚至对数据库代码库有一个大概的想法，都可以帮助您更好地了解它产生的日志记录，其配置参数，并帮助您在使用它的应用程序中甚至在数据库代码本身中发现问题。如果我们可以将数据库用作黑匣子，而不必不必查看它们，那就太好了，但是实践表明，迟早会出现错误，中断，性能下降或其他一些问题，并且 最好为此做好准备如果您了解并了解数据库内部知识，则可以降低业务风险并提高快速恢复的机会。&lt;/p>
&lt;p>选择数据库是一项长期的决定，最好跟踪新发布的版本，了解确切的更改以及更改的原因，并制定升级策略新版本通常包含对错误和安全性问题的改进和修复，但可能会引入新的错误，性能下降或意外行为，因此在推出新版本之前对其进行测试也至关重要以前检查数据库实施者的处理方式可能会给您一个关于将来的期望的好主意过去的平滑升级不能保证将来的平滑升级，但是过去的复杂升级可能表明未来的升级也不容易。&lt;/p></description></item><item><title>5.性能评测</title><link>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/5.%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/database-series/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8F%B2/5.%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B/</guid><description>&lt;h1 id="数据库性能评测">数据库性能评测&lt;/h1>
&lt;p>Yahoo!是用于基准测试，性能评估和比较的流行工具之一云服务基准（YCSB）YCSB 提供了可以应用于不同数据存储的框架和一组通用的工作负载就像其他通用工具一样，应谨慎使用此工具，因为这样很容易得出错误的结论为了进行公平的比较并做出有根据的决定，有必要投入足够的时间来了解数据库必须执行的实际条件，并相应地调整基准。&lt;/p>
&lt;h1 id="tpc-c-benchmark">TPC-C BENCHMARK&lt;/h1>
&lt;p>The Transaction Processing Performance Council（TPC）具有一组基准，数据库供应商使用这些基准来比较和宣传其产品的性能 TPC-C 是一个在线事务处理（OLTP）基准，它是模拟常规应用程序工作负载的只读和更新事务的组合。&lt;/p>
&lt;p>此基准与执行的并发事务的性能和正确性有关主要性能指标是吞吐量：数据库系统每分钟能够处理的事务数需要执行事务以保留 ACID 属性并符合基准自身定义的属性集。&lt;/p>
&lt;p>该基准测试不专注于任何特定的业务部门，而是提供了一组抽象的操作，这些操作对于 OLTP 数据库适合的大多数应用程序很重要它包括多个表和实体，例如仓库，库存（库存），客户和订单，指定表布局，可针对这些表执行的交易明细，每个表的最小行数以及数据持久性约束。&lt;/p></description></item></channel></rss>