<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RocketMQ | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/messagequeue-series/rocketmq/</link><atom:link href="https://ng-tech.icu/books/messagequeue-series/rocketmq/index.xml" rel="self" type="application/rss+xml"/><description>RocketMQ</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>RocketMQ</title><link>https://ng-tech.icu/books/messagequeue-series/rocketmq/</link></image><item><title>集群与高可用</title><link>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/</guid><description>&lt;h1 id="集群与高可用">集群与高可用&lt;/h1>
&lt;h1 id="负载均衡">负载均衡&lt;/h1>
&lt;p>Producer 端的负载均衡实际是对于 Broker 的选择，目前包含以下两种：&lt;/p>
&lt;ul>
&lt;li>Round Robin 容错：即按照队列列表轮询，当上一次请求的 Broker 出现异常时，本次请求会通过简单容错机制进行跳过，这是默认的策略。&lt;/li>
&lt;li>RT 排序与延时容错：维护一个 Map，统计发送消息的每个 broker 的 RT，优先从 RT 较低的几个 broker 中选择，当某个 broker 出现异常时，通过延时容错机制，使其在一定时间内更难被选中。&lt;/li>
&lt;/ul></description></item><item><title>消息操作</title><link>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E6%B6%88%E6%81%AF%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E6%B6%88%E6%81%AF%E6%93%8D%E4%BD%9C/</guid><description>&lt;h1 id="消息发送">消息发送&lt;/h1></description></item><item><title>消息类型</title><link>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B/</guid><description>&lt;h1 id="消息发送与路由">消息发送与路由&lt;/h1>
&lt;p>值得一提的是，虽然 Producer 和 Broker 都可以设置消息体大小，消息体大小会对整体性能起到重要影响，阿里云的默认消息体大小阈值是 256K，部分最大可达 4M。&lt;/p></description></item><item><title>消息消费</title><link>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/messagequeue-series/rocketmq/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</guid><description>&lt;h1 id="消息消费">消息消费&lt;/h1>
&lt;h1 id="超时时间">超时时间&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Producer 级别配置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">DefaultMQProducer&lt;/span> &lt;span class="n">producer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">DefaultMQProducer&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">producer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setSendMsgTimeout&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 请求级别配置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 同步发送
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">defaultMQProducer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 异步发送
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">defaultMQProducer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">send&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">sendCallback&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要注意的是，async 和 oneway 两种发送方式的超时时间和同步发送有比较大的区别，这两种方式下，每个消息发送者都有一个资源信号量来控制发送的并发度，获取资源锁可能存在等待耗时。&lt;/p>
&lt;h1 id="失败重试">失败重试&lt;/h1>
&lt;p>发送失败在不同的场景和需求下的定义都不相同，于是我们需要具体问题具体分析，以同步发送为例：&lt;/p>
&lt;ul>
&lt;li>如果我们希望保证消息不丢，那么 Broker.Master 就必须同步刷盘成功；&lt;/li>
&lt;li>如果我们希望消息不丢的同时，如果 Master 故障，消费者也能立马消费到消息，那么 Broker.Slave 也必须同步刷盘成功；&lt;/li>
&lt;li>如果我们能容忍掉电级别导致的消息丢失，那么 Broker.Master 只需要写入 PageCache 即可。&lt;/li>
&lt;/ul>
&lt;p>对高可靠的要求不同，Broker 的刷盘策略及 HA 策略也各不相同，Producer 的处理逻辑自然也就不同，失败又可以分为以下几类：&lt;/p>
&lt;ul>
&lt;li>系统失败：客户端异常：Producer 无法获取 broker 的地址；通讯层面的异常：连接不可用、请求超时等；Broker 异常：磁盘满了、创建文件失败、写入 PageCache 超时等。可能抛出 MQClientException、RemotingException、MQBrokerException。&lt;/li>
&lt;li>业务失败：消息 Topic 长度超过上限；消息体大小超过上限；消息的 properties 长度超过上限等。可能抛出 MQClientException、MQBrokerException。&lt;/li>
&lt;li>节点失败：Broker.Master 刷盘失败，Broker.Slave 不可用或刷盘超时；无异常，根据发送返回值 SendResult.sendStatus 来判断。&lt;/li>
&lt;/ul>
&lt;p>针对系统失败和业务失败，我们可以通过 DefaultMQProducer.retryTimesWhenSendFailed 来配置重试次数，对于高可用失败，可以通过 DefaultMQProducer.retryAnotherBrokerWhenNotStoreOK 来配置切换 broker 的重试。&lt;/p>
&lt;p>如果为了保证消息不丢，只要消息在 Master 同步落盘即可：&lt;/p>
&lt;ul>
&lt;li>Broker 的刷盘策略需要配置为同步刷盘，即 &lt;code>FlushDiskType==SYNC_FLUSH&lt;/code>。&lt;/li>
&lt;li>Producer 在发送消息时，properties 中的“WAIT”属性设置为“true”，表示客户端同步等待刷盘完成。&lt;/li>
&lt;li>客户端需要手动检查发送状态，保证 &lt;code>SendResult.sendStatus=SEND_OK&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>为了性能，我们都是采用同步写 PageCache 与异步刷盘的策略，甚至是同步写预分配内存与异步写、PageCache 与异步刷盘。&lt;/p></description></item></channel></rss>