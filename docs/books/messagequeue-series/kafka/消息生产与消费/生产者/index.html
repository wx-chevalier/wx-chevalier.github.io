<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=google-site-verification content="google69a5cccb61297807"><meta name=baidu-site-verification content="cqmZHEleVh"><meta name=description content="Kafka Producer 在 Kafka 中，我们把产生消息的那一方称为生产者，比如登录电商网站的时候，你的登陆信息，登陆次数都会作为消息传输到 Kafka 后台，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递"><link rel=alternate hreflang=zh href=https://ng-tech.icu/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/%E7%94%9F%E4%BA%A7%E8%80%85/><meta name=theme-color content="#0a55a7"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css integrity="sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=" crossorigin=anonymous><link rel=stylesheet href=/css/wowchemy.63df6ae9fc2b4cc71b83f1774d780209.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-40NYXJ8823"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-40NYXJ8823")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?56df1177bce405601b0ecdd7208f75c6",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0f7d075e895d6f5f1f5fdbc1e33dc138_10087_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://ng-tech.icu/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/%E7%94%9F%E4%BA%A7%E8%80%85/><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="@wx-chevalier"><meta property="twitter:creator" content="@wx-chevalier"><meta property="og:site_name" content="Next-gen Tech Edu"><meta property="og:url" content="https://ng-tech.icu/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/%E7%94%9F%E4%BA%A7%E8%80%85/"><meta property="og:title" content="生产者 | Next-gen Tech Edu"><meta property="og:description" content="Kafka Producer 在 Kafka 中，我们把产生消息的那一方称为生产者，比如登录电商网站的时候，你的登陆信息，登陆次数都会作为消息传输到 Kafka 后台，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递"><meta property="og:image" content="https://ng-tech.icu/media/sharing.png"><meta property="twitter:image" content="https://ng-tech.icu/media/sharing.png"><meta property="og:locale" content="zh"><title>生产者 | Next-gen Tech Edu</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=7e36e67fff8b5ea784c1524f208cf7b0><button onclick=topFunction() id=backTopBtn title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden=true></i></button>
<script src=/js/wowchemy-init.min.14a0ed61c6dbd594b9c75193b25be179.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class="col-6 search-title"><p>搜索</p></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=关闭><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box></div></section><section class=section-search-results><div id=search-hits></div><div id=search-common-queries></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label=切换导航>
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Next-gen Tech Edu</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/books-gallery><span>笔记（万篇）</span></a></li><li class=nav-item><a class=nav-link href=/#knowledge-map><span>知识图谱</span></a></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>实验室</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/galaxy-home/gh-craft><span>Craft 方块世界</span></a>
<a class=dropdown-item href=/galaxy-home/glossary-cards><span>3D 知识卡牌</span></a></div></li><style>.dropdown-item{display:inline-flex}</style><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>其他阅读渠道</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230218234451.png></img><span>知乎</span></a>
<a class=dropdown-item href=https://segmentfault.com/blog/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113556.png></img><span>SegmentFault</span></a>
<a class=dropdown-item href=https://zhuanlan.zhihu.com/wxyyxc1992><img style=width:16px;height:16px;display:inline-block;margin-right:8px src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230219113519.png></img><span>掘金</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=搜索><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/wx-chevalier aria-label=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a></li><div></div><style>@media only screen and (max-width:600px){.jimmysong-template{display:none!important}}</style><li class=jimmysong-template style=color:#fff;font-size:12px><a href=https://jimmysong.io style=color:#fff>By Jimmy Song's Template</a></li></ul></div></nav></header></div><div class=page-body><link rel=stylesheet href=//unpkg.com/heti/umd/heti.min.css><div class="container-xl docs"><div class="row flex-xl-nowrap"><div class=docs-sidebar><form class="docs-search d-flex align-items-center"><button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type=button data-toggle=collapse data-target=#docs-nav aria-controls=docs-nav aria-expanded=false aria-label="Toggle section navigation"><div class=d-flex><span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">消息生产与消费</span>
<span><i class="fas fa-chevron-down"></i></span></div></button>
<button class="form-control sidebar-search js-search d-none d-md-flex">
<i class="fas fa-search pr-2"></i>
<span class=sidebar-search-text>搜索...</span>
<span class=sidebar-search-shortcut>/</span></button></form><nav class="collapse docs-links" id=docs-nav><ul class="nav docs-sidenav"><li style=display:inline-flex><a style=cursor:pointer onclick=window.history.back()><i class="fas fa-arrow-left pr-1"></i>
Back</a>
<span>|</span>
<a href=/books/><i class="fa-solid fa-house" style=margin-right:4px></i>
Books</a></li></ul><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id43564b4bbb95fcc7dd82302858823c86")' href=#id43564b4bbb95fcc7dd82302858823c86 aria-expanded=false aria-controls=id43564b4bbb95fcc7dd82302858823c86 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/messagequeue-series/kafka/>Kafka</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id43564b4bbb95fcc7dd82302858823c86 aria-expanded=false aria-controls=id43564b4bbb95fcc7dd82302858823c86><i class="fa-solid fa-angle-down" id=caret-id43564b4bbb95fcc7dd82302858823c86></i></a></div><ul class="nav docs-sidenav collapse show" id=id43564b4bbb95fcc7dd82302858823c86><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id0ed6a90e17c235497363d1250f9accf2")' href=#id0ed6a90e17c235497363d1250f9accf2 aria-expanded=false aria-controls=id0ed6a90e17c235497363d1250f9accf2 aria-hidden=false data-toggle=collapse></div></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-idc5a5b049ed2adbf5160a5a491a0875ca")' href=#idc5a5b049ed2adbf5160a5a491a0875ca aria-expanded=false aria-controls=idc5a5b049ed2adbf5160a5a491a0875ca aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/messagequeue-series/kafka/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/>集群部署</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#idc5a5b049ed2adbf5160a5a491a0875ca aria-expanded=false aria-controls=idc5a5b049ed2adbf5160a5a491a0875ca><i class="fa-solid fa-angle-right" id=caret-idc5a5b049ed2adbf5160a5a491a0875ca></i></a></div><ul class="nav docs-sidenav collapse" id=idc5a5b049ed2adbf5160a5a491a0875ca><li class="child level"><a href=/books/messagequeue-series/kafka/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE/>部署配置</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/>参数配置</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/>集群与高可用</a></li></ul></div><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/>架构概念</a></li><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-id667b960394f8e43cdb2c7bfef7d3852e")' href=#id667b960394f8e43cdb2c7bfef7d3852e aria-expanded=false aria-controls=id667b960394f8e43cdb2c7bfef7d3852e aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86/>消息代理</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#id667b960394f8e43cdb2c7bfef7d3852e aria-expanded=false aria-controls=id667b960394f8e43cdb2c7bfef7d3852e><i class="fa-solid fa-angle-right" id=caret-id667b960394f8e43cdb2c7bfef7d3852e></i></a></div><ul class="nav docs-sidenav collapse" id=id667b960394f8e43cdb2c7bfef7d3852e><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86/zookeeper/>ZooKeeper</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86/%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BC%98%E5%8C%96/>磁盘读写优化</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86/%E5%89%AF%E6%9C%AC/>副本</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/>日志文件</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/>网络模型</a></li></ul></div><div class="docs-toc-item has-child"><div class="parent-node d-flex justify-content-between" onclick='Collapse("caret-ida180bcd7ea5e27bf8c114f8c98d35239")' href=#ida180bcd7ea5e27bf8c114f8c98d35239 aria-expanded=false aria-controls=ida180bcd7ea5e27bf8c114f8c98d35239 aria-hidden=false data-toggle=collapse><a class="d-inline docs-toc-link" href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/>消息生产与消费</a>
<a class="nav-toogle d-inline level" aria-hidden=false data-toggle=collapse href=#ida180bcd7ea5e27bf8c114f8c98d35239 aria-expanded=false aria-controls=ida180bcd7ea5e27bf8c114f8c98d35239><i class="fa-solid fa-angle-down" id=caret-ida180bcd7ea5e27bf8c114f8c98d35239></i></a></div><ul class="nav docs-sidenav collapse show" id=ida180bcd7ea5e27bf8c114f8c98d35239><li class="child level active"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/%E7%94%9F%E4%BA%A7%E8%80%85/>生产者</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/>事务消息</a></li><li class="child level"><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/%E6%B6%88%E8%B4%B9%E8%80%85/>消费者</a></li></ul></div></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 docs-toc"><ul class="nav toc-top"><li><a href=# id=back_to_top class=docs-toc-title>目录</a></li></ul><nav id=TableOfContents><ul><li><a href=#简单消息发送>简单消息发送</a></li><li><a href=#同步发送消息>同步发送消息</a></li><li><a href=#异步发送消息>异步发送消息</a></li></ul><ul><li><a href=#分区策略>分区策略</a></li><li><a href=#顺序轮询>顺序轮询</a></li><li><a href=#随机轮询>随机轮询</a></li><li><a href=#按照-key-进行消息保存>按照 key 进行消息保存</a></li></ul></nav><div class="subscribe-module col-24 mt-1"><img src=https://ngte-superbed.oss-cn-beijing.aliyuncs.com/item/20230220172727.png alt=image title=王下邀月熊的微信公众号></div></div><main class="py-md-3 pl-md-3 docs-content col-xl-8" role=main><article class=article><h1>生产者</h1><div class=article-style><h1 id=kafka-producer>Kafka Producer</h1><p>在 Kafka 中，我们把产生消息的那一方称为生产者，比如登录电商网站的时候，你的登陆信息，登陆次数都会作为消息传输到 Kafka 后台，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递给 Kafka 后台，然后系统会根据你的爱好做智能推荐。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://pic.imgdb.cn/item/6077eb408322e6675c92ad73.jpg alt=生产者设计 loading=lazy data-zoomable></div></div></figure></p><p>Kafka 中的生产者设计主要考虑了以下方面：</p><ul><li><p>负载均衡：由于消息 topic 由多个 partition 组成，且 partition 会均衡分布到不同 broker 上，因此，为了有效利用 broker 集群的性能，提高消息的吞吐量，producer 可以通过随机或者 hash 等方式，将消息平均发送到多个 partition 上，以实现负载均衡。</p></li><li><p>批量发送：是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，以一次请求的方式发送了批量的消息给 broker，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性，相当于以时延代价，换取更好的吞吐量。</p></li></ul><h1 id=创建-kafka-生产者>创建 Kafka 生产者</h1><p>要向 Kafka 写入消息，首先需要创建一个生产者对象，并设置一些属性。Kafka 生产者有 3 个必选的属性：</p><ul><li><p>bootstrap.servers：该属性指定 broker 的地址清单，地址的格式为 host:port。清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找到其他的 broker 信息。不过建议至少要提供两个 broker 信息，一旦其中一个宕机，生产者仍然能够连接到集群上。</p></li><li><p>key.serializer：broker 需要接收到序列化之后的 key/value 值，所以生产者发送的消息需要经过序列化之后才传递给 Kafka Broker。生产者需要知道采用何种方式把 Java 对象转换为字节数组。key.serializer 必须被设置为一个实现了 org.apache.kafka.common.serialization.Serializer 接口的类，生产者会使用这个类把键对象序列化为字节数组。这里拓展一下 Serializer 类，Serializer 是一个接口，它表示类将会采用何种方式序列化，它的作用是把对象转换为字节，实现了 Serializer 接口的类主要有 ByteArraySerializer、StringSerializer、IntegerSerializer ，其中 ByteArraySerialize 是 Kafka 默认使用的序列化器，其他的序列化器还有很多，你可以通过 这里 查看其他序列化器。要注意的一点：key.serializer 是必须要设置的，即使你打算只发送值的内容。</p></li><li><p>value.serializer：与 key.serializer 一样，value.serializer 指定的类会将值序列化。</p></li></ul><p>下面代码演示了如何创建一个 Kafka 生产者，这里只指定了必要的属性，其他使用默认的配置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=n>Properties</span> <span class=n>properties</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Properties</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>properties</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;bootstrap.servers&#34;</span><span class=o>,</span><span class=s>&#34;broker1:9092,broker2:9092&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>properties</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;key.serializer&#34;</span><span class=o>,</span><span class=s>&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>properties</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;value.serializer&#34;</span><span class=o>,</span><span class=s>&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>properties</span> <span class=o>=</span> <span class=k>new</span> <span class=n>KafkaProducer</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;(</span><span class=n>properties</span><span class=o>);</span>
</span></span></code></pre></div><h1 id=kafka-消息发送>Kafka 消息发送</h1><p>实例化生产者对象后，接下来就可以开始发送消息了，我们从创建一个 ProducerRecord 对象开始，ProducerRecord 是 Kafka 中的一个核心类，它代表了一组 Kafka 需要发送的 key/value 键值对，它由记录要发送到的主题名称（Topic Name），可选的分区号（Partition Number）以及可选的键值对构成。在发送 ProducerRecord 时，我们需要将键值对对象由序列化器转换为字节数组，这样它们才能够在网络上传输。然后消息到达了分区器。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://pic.imgdb.cn/item/6076ebe28322e6675cf42160.jpg alt="Producer 发送流程" loading=lazy data-zoomable></div></div></figure></p><p>如果发送过程中指定了有效的分区号，那么在发送记录时将使用该分区。如果发送过程中未指定分区，则将使用 key 的 hash 函数映射指定一个分区。如果发送的过程中既没有分区号也没有，则将以循环的方式分配一个分区。选好分区后，生产者就知道向哪个主题和分区发送数据了。ProducerRecord 还有关联的时间戳，如果用户没有提供时间戳，那么生产者将会在记录中使用当前的时间作为时间戳。Kafka 最终使用的时间戳取决于 topic 主题配置的时间戳类型。</p><ul><li>如果将主题配置为使用 CreateTime，则生产者记录中的时间戳将由 broker 使用。</li><li>如果将主题配置为使用 LogAppendTime，则生产者记录中的时间戳在将消息添加到其日志中时，将由 broker 重写。</li></ul><p>然后，这条消息被存放在一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。由一个独立的线程负责把它们发到 Kafka Broker 上。Kafka Broker 在收到消息时会返回一个响应，如果写入成功，会返回一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量，上面两种的时间戳类型也会返回给用户。如果写入失败，会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败的话，就返回错误消息。</p><h2 id=简单消息发送>简单消息发送</h2><p>Kafka 最简单的消息发送如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ProducerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>record</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ProducerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;(</span><span class=s>&#34;CustomerCountry&#34;</span><span class=o>,</span><span class=s>&#34;West&#34;</span><span class=o>,</span><span class=s>&#34;France&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>producer</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>record</span><span class=o>);</span>
</span></span></code></pre></div><p>代码中生产者(producer)的 send() 方法需要把 ProducerRecord 的对象作为参数进行发送，ProducerRecord 有很多构造函数，这个我们下面讨论，这里调用的是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ProducerRecord</span><span class=o>(</span><span class=n>String</span> <span class=n>topic</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>)</span> <span class=o>{}</span>
</span></span></code></pre></div><p>这个构造函数，需要传递的是 topic 主题，key 和 value。把对应的参数传递完成后，生产者调用 send() 方法发送消息（ProducerRecord 对象）。我们可以从生产者的架构图中看出，消息是先被写入分区中的缓冲区中，然后分批次发送给 Kafka Broker。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://pic.imgdb.cn/item/6076f9438322e6675c12a5d0.jpg alt=不同的主题与批次 loading=lazy data-zoomable></div></div></figure></p><p>发送成功后，send() 方法会返回一个 Future(java.util.concurrent) 对象，Future 对象的类型是 RecordMetadata 类型，我们上面这段代码没有考虑返回值，所以没有生成对应的 Future 对象，所以没有办法知道消息是否发送成功。如果不是很重要的信息或者对结果不会产生影响的信息，可以使用这种方式进行发送。我们可以忽略发送消息时可能发生的错误或者在服务器端可能发生的错误，但在消息发送之前，生产者还可能发生其他的异常。这些异常有可能是 SerializationException(序列化失败)，BufferedExhaustedException 或 TimeoutException(说明缓冲区已满)，又或是 InterruptedException(说明发送线程被中断)。</p><h2 id=同步发送消息>同步发送消息</h2><p>第二种消息发送机制如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ProducerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>record</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ProducerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;(</span><span class=s>&#34;CustomerCountry&#34;</span><span class=o>,</span><span class=s>&#34;West&#34;</span><span class=o>,</span><span class=s>&#34;France&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RecordMetadata</span> <span class=n>recordMetadata</span> <span class=o>=</span> <span class=n>producer</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>record</span><span class=o>).</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span><span class=k>catch</span><span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>){</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>()</span><span class=err>；</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>这种发送消息的方式较上面的发送方式有了改进，首先调用 send() 方法，然后再调用 get() 方法等待 Kafka 响应。如果服务器返回错误，get() 方法会抛出异常，如果没有发生错误，我们会得到 RecordMetadata 对象，可以用它来查看消息记录。</p><p>生产者（KafkaProducer）在发送的过程中会出现两类错误：其中一类是重试错误，这类错误可以通过重发消息来解决。比如连接的错误，可以通过再次建立连接来解决；无主错误则可以通过重新为分区选举首领来解决。KafkaProducer 被配置为自动重试，如果多次重试后仍无法解决问题，则会抛出重试异常。另一类错误是无法通过重试来解决的，比如消息过大对于这类错误，KafkaProducer 不会进行重试，直接抛出异常。</p><h2 id=异步发送消息>异步发送消息</h2><p>同步发送消息都有个问题，那就是同一时间只能有一个消息在发送，这会造成许多消息无法直接发送，造成消息滞后，无法发挥效益最大化。比如消息在应用程序和 Kafka 集群之间一个来回需要 10ms。如果发送完每个消息后都等待响应的话，那么发送 100 个消息需要 1 秒，但是如果是异步方式的话，发送 100 条消息所需要的时间就会少很多很多。大多数时候，虽然 Kafka 会返回 RecordMetadata 消息，但是我们并不需要等待响应。</p><p>为了在异步发送消息的同时能够对异常情况进行处理，生产者提供了回掉支持。下面是回调的一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ProducerRecord</span> <span class=o>&lt;</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span> <span class=o>&gt;</span> <span class=n>producerRecord</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ProducerRecord</span> <span class=o>&lt;</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span> <span class=o>&gt;</span> <span class=o>(</span><span class=s>&#34;CustomerCountry&#34;</span><span class=o>,</span> <span class=s>&#34;Huston&#34;</span><span class=o>,</span> <span class=s>&#34;America&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>producer</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>producerRecord</span><span class=o>,</span> <span class=k>new</span> <span class=n>DemoProducerCallBack</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>DemoProducerCallBack</span> <span class=kd>implements</span> <span class=n>Callback</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onCompletion</span><span class=o>(</span><span class=n>RecordMetadata</span> <span class=n>metadata</span><span class=o>,</span> <span class=n>Exception</span> <span class=n>exception</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>exception</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>exception</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>首先实现回调需要定义一个实现了 org.apache.kafka.clients.producer.Callback 的类，这个接口只有一个 onCompletion 方法。如果 kafka 返回一个错误，onCompletion 方法会抛出一个非空(non null)异常，这里我们只是简单的把它打印出来，如果是生产环境需要更详细的处理，然后在 send() 方法发送的时候传递一个 Callback 回调的对象。</p><h1 id=生产者分区机制>生产者分区机制</h1><p>Kafka 对于数据的读写是以分区为粒度的，分区可以分布在多个主机（Broker）中，这样每个节点能够实现独立的数据写入和读取，并且能够通过增加新的节点来增加 Kafka 集群的吞吐量，通过分区部署在多个 Broker 来实现负载均衡的效果。上面我们介绍了生产者的发送方式有三种：不管结果如何直接发送、发送并返回结果、发送并回调。由于消息是存在主题（topic）的分区（partition）中的，所以当 Producer 生产者发送产生一条消息发给 topic 的时候，你如何判断这条消息会存在哪个分区中呢？</p><p>这其实就设计到 Kafka 的分区机制了。</p><h2 id=分区策略>分区策略</h2><p>Kafka 的分区策略指的就是将生产者发送到哪个分区的算法。Kafka 为我们提供了默认的分区策略，同时它也支持你自定义分区策略。如果要自定义分区策略的话，你需要显示配置生产者端的参数 Partitioner.class，我们可以看一下这个类它位于 org.apache.kafka.clients.producer 包下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Partitioner</span> <span class=kd>extends</span> <span class=n>Configurable</span><span class=o>,</span> <span class=n>Closeable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>partition</span><span class=o>(</span><span class=n>String</span> <span class=n>topic</span><span class=o>,</span> <span class=n>Object</span> <span class=n>key</span><span class=o>,</span> <span class=kt>byte</span><span class=o>[]</span> <span class=n>keyBytes</span><span class=o>,</span> <span class=n>Object</span> <span class=n>value</span><span class=o>,</span> <span class=kt>byte</span><span class=o>[]</span> <span class=n>valueBytes</span><span class=o>,</span> <span class=n>Cluster</span> <span class=n>cluster</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>close</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span> <span class=kd>public</span> <span class=kt>void</span> <span class=nf>onNewBatch</span><span class=o>(</span><span class=n>String</span> <span class=n>topic</span><span class=o>,</span> <span class=n>Cluster</span> <span class=n>cluster</span><span class=o>,</span> <span class=kt>int</span> <span class=n>prevPartition</span><span class=o>)</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Partitioner 类有三个方法，分别来解释一下</p><ul><li>partition(): 这个类有几个参数: topic，表示需要传递的主题；key 表示消息中的键值；keyBytes 表示分区中序列化过后的 key，byte 数组的形式传递；value 表示消息的 value 值；valueBytes 表示分区中序列化后的值数组；cluster 表示当前集群的原数据。Kafka 给你这么多信息，就是希望让你能够充分地利用这些信息对消息进行分区，计算出它要被发送到哪个分区中。</li><li>close() : 继承了 Closeable 接口能够实现 close() 方法，在分区关闭时调用。</li><li>onNewBatch(): 表示通知分区程序用来创建新的批次</li></ul><p>其中与分区策略息息相关的就是 partition() 方法了。</p><h2 id=顺序轮询>顺序轮询</h2><p>顺序分配，消息是均匀的分配给每个 partition，即每个分区存储一次消息。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://pic.imgdb.cn/item/6076faa18322e6675c15d490.jpg alt=分区顺序分配 loading=lazy data-zoomable></div></div></figure></p><p>上图表示的就是轮询策略，轮训策略是 Kafka Producer 提供的默认策略，如果你不使用指定的轮训策略的话，Kafka 默认会使用顺序轮训策略的方式。</p><h2 id=随机轮询>随机轮询</h2><p>随机轮询简而言之就是随机的向 partition 中保存消息，如下图所示。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://pic.imgdb.cn/item/6076fafc8322e6675c169361.jpg alt=随机分配示意图 loading=lazy data-zoomable></div></div></figure></p><p>实现随机分配的代码只需要两行，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span> <span class=o>&lt;</span> <span class=n>PartitionInfo</span> <span class=o>&gt;</span> <span class=n>partitions</span> <span class=o>=</span> <span class=n>cluster</span><span class=o>.</span><span class=na>partitionsForTopic</span><span class=o>(</span><span class=n>topic</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>ThreadLocalRandom</span><span class=o>.</span><span class=na>current</span><span class=o>().</span><span class=na>nextInt</span><span class=o>(</span><span class=n>partitions</span><span class=o>.</span><span class=na>size</span><span class=o>());</span>
</span></span></code></pre></div><p>先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以如果追求数据的均匀分布，还是使用轮询策略比较好。事实上，随机策略是老版本生产者使用的分区策略，在新版本中已经改为轮询了。</p><h2 id=按照-key-进行消息保存>按照 key 进行消息保存</h2><p>这个策略也叫做 key-ordering 策略，Kafka 中每条消息都会有自己的 key，一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略，如下图所示。</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=https://pic.imgdb.cn/item/6076fb448322e6675c17362b.jpg alt="key-ordering 分配示意图" loading=lazy data-zoomable></div></div></figure></p><p>实现这个策略的 partition 方法同样简单，只需要下面两行代码即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span> <span class=o>&lt;</span> <span class=n>PartitionInfo</span> <span class=o>&gt;</span> <span class=n>partitions</span> <span class=o>=</span> <span class=n>cluster</span><span class=o>.</span><span class=na>partitionsForTopic</span><span class=o>(</span><span class=n>topic</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>abs</span><span class=o>(</span><span class=n>key</span><span class=o>.</span><span class=na>hashCode</span><span class=o>())</span> <span class=o>%</span> <span class=n>partitions</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span></code></pre></div><p>上面这几种分区策略都是比较基础的策略，除此之外，你还可以自定义分区策略。</p><h1 id=生产者压缩机制>生产者压缩机制</h1><p>压缩一词简单来讲就是一种互换思想，它是一种经典的用 CPU 时间去换磁盘空间或者 I/O 传输量的思想，希望以较小的 CPU 开销带来更少的磁盘占用或更少的网络 I/O 传输。Kafka 的消息分为两层：消息集合 和 消息。一个消息集合中包含若干条日志项，而日志项才是真正封装消息的地方。Kafka 底层的消息日志由一系列消息集合日志项组成。Kafka 通常不会直接操作具体的一条条消息，它总是在消息集合这个层面上进行写入操作。</p><p>在 Kafka 中，压缩会发生在两个地方：Kafka Producer 和 Kafka Consumer，为什么启用压缩？说白了就是消息太大，需要变小一点 来使消息发的更快一些。Kafka Producer 中使用 compression.type 来开启压缩</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=n>Properties</span> <span class=n>properties</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Properties</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>properties</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;bootstrap.servers&#34;</span><span class=o>,</span> <span class=s>&#34;192.168.1.9:9092&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>properties</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;key.serializer&#34;</span><span class=o>,</span> <span class=s>&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>properties</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;value.serializer&#34;</span><span class=o>,</span> <span class=s>&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>properties</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;compression.type&#34;</span><span class=o>,</span> <span class=s>&#34;gzip&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>Producer</span> <span class=o>&lt;</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span> <span class=o>&gt;</span> <span class=n>producer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>KafkaProducer</span> <span class=o>&lt;</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span> <span class=o>&gt;</span> <span class=o>(</span><span class=n>properties</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>ProducerRecord</span> <span class=o>&lt;</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span> <span class=o>&gt;</span> <span class=n>record</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ProducerRecord</span> <span class=o>&lt;</span> <span class=n>String</span><span class=o>,</span> <span class=n>String</span> <span class=o>&gt;</span> <span class=o>(</span><span class=s>&#34;CustomerCountry&#34;</span><span class=o>,</span> <span class=s>&#34;Precision Products&#34;</span><span class=o>,</span> <span class=s>&#34;France&#34;</span><span class=o>);</span>
</span></span></code></pre></div><p>上面代码表明该 Producer 的压缩算法使用的是 GZIP</p></div><div class=article-widget><div class="container-xl row post-nav"><div class="col-6 post-nav-item"><div class=meta-nav>下一页</div><a href=/books/messagequeue-series/kafka/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/ rel=prev>事务消息</a></div></div></div><div class=body-footer><p>最近更新于 0001-01-01</p><section id=comments class="mb-3 pt-0"><div id=disqus_thread></div><script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://ngte-website.oss-accelerate.aliyuncs.com/disqus/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><footer class=site-footer><div class="copyright py-4 bg-footer"><div class="row justify-content-center"><div class="text-center footer-color"><p class=mb-0>© 2017-2022 NGTE all rights reserved</p></div></div></div></footer></main></div></div><script src=//unpkg.com/heti/umd/heti-addon.min.js></script>
<script>const heti=new Heti(".article");heti.autoSpacing()</script><script type=text/javascript>window.$crisp=[],window.CRISP_WEBSITE_ID="12adcc35-9621-4313-8262-62dc654b29d8",function(){setTimeout(function(){d=document,s=d.createElement("script"),s.src="https://client.crisp.chat/l.js",s.async=1,d.getElementsByTagName("head")[0].appendChild(s)},2500)}()</script></div><div class=page-footer></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script id=search-hit-algolia-template type=text/html><div class=search-hit><div class=search-hit-content><div class=search-hit-name><a href={{relpermalink}}>{{#helpers.highlight}}{ "attribute": "title" }{{/helpers.highlight}}</a></div><div class="article-metadata search-hit-type">{{type}}</div><p class=search-hit-description>{{#helpers.highlight}}{ "attribute": "summary" }{{/helpers.highlight}}</p></div></div></script><script src=https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js crossorigin=anonymous></script>
<script id=dsq-count-scr src=https://ngte-website.oss-accelerate.aliyuncs.com/disqus/count.js async></script>
<script src=/zh/js/algolia-search-built.min.4387d694ca1258194aaf562b8cd1c400.js type=module></script>
<script id=page-data type=application/json>{"use_headroom":false}</script><script src=/zh/js/wowchemy.min.d1673c7a11d1238516cbe12a1e84257f.js></script>
<script>var mybutton=document.getElementById("backTopBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin=anonymous></script>
<script>anchors.add()</script><script>(function(){"use strict";if(!document.queryCommandSupported("copy"))return;function e(e,t){e.className="highlight-copy-btn",e.textContent=t,setTimeout(function(){e.textContent="",e.className="highlight-copy-btn fa fa-copy"},1e3)}function t(e){var t=window.getSelection(),n=document.createRange();return n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n),t}function n(n){var o,s=document.createElement("button");s.className="highlight-copy-btn fa fa-copy",s.textContent="",o=n.firstElementChild,s.addEventListener("click",function(){try{var n=t(o);document.execCommand("copy"),n.removeAllRanges(),e(s,"已复制")}catch(t){console&&console.log(t),e(s,"Failed :'(")}}),n.appendChild(s)}var s=document.getElementsByClassName("highlight");Array.prototype.forEach.call(s,n)})()</script></body></html>