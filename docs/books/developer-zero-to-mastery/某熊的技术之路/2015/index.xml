<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2015 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/</link><atom:link href="https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/index.xml" rel="self" type="application/rss+xml"/><description>2015</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>2015</title><link>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/</link></image><item><title>2015-我的技术之路与知识体系</title><link>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/2015-%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF%E4%B8%8E%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/2015-%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF%E4%B8%8E%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</guid><description>&lt;h1 id="2015-我的技术之路与知识体系">2015-我的技术之路与知识体系&lt;/h1>
&lt;p>六年前笔者开始接触到 C 语言，写了第一行 HelloWorld。三年前开始进入工作岗位进行实践，前前后后参与了公司里、学校里也有十来个项目，自己也有多次自主创业的经历。在不懂事的时候，笔者自诩“全栈架构师”，从前端的 Android、iOS、Web，到中间件的 Apache、Nginx，再到后端的 Laravel、Spring、Rails、NodeJs，还有 MySQL、Redis、Mongodb，有时候还要做些 CI，用用 Hadoop、Docker、Spark 做做云计算环境，再实践实践机器学习的算法。呵呵，每当想起这些，笔者脑中就闪过了孔乙己一字排开八个大钱的画面，只懂些名词，真是连民科都不如。作为一个有底线的程序猿，知之为知之，不知为不知，虽然笔者在不长的实践生涯中“被迫”着了解了计算机软件行业的许多方面，但是笔者在这里描述这个背景并不是自夸或者装逼，只是想陈述一个事实：如果你还没有感到知识管理、知识归档的痛苦，那说明你还了解的不够多。如果你还只是停留在一字排开数个名词的阶段，那说明你了解的还不够深。&lt;/p>
&lt;p>技术分为术与道两者，术即是具体的做事的方法，而道则是做事的逻辑抽象的原则与原理。一味地追求术的人往往都是希望走捷径，不求甚解的。而道之所求也是符合一万小时原理，需要大量的付出与总结。借用数学之美中的例子，如果你想要去建立一个搜索引擎，直接拿来主义，用上 Solr、ElasticSearch 之类的，是术。而根据下载、索引与排序这三个抽象步骤来进行提炼与升华，这就是道。计算机科学有两类根本问题。一类是理论：算法，数据结构，复杂度，机器学习，模式识别，等等等。一类是系统：操作系统，网络系统，分布式系统，存储系统，游戏引擎，等等等等。粗浅的说，学界会偏向前者，产界偏向后者，笔者作为一只一直读书的从本科到硕士，见多了二者相互嫌弃。但是这二者相辅相成，笔者自己数学一直不好，对于那些公式啊推导畏如猛虎，但是用心看了之后，甚多乐趣啊。所谓举一反三，见微知著，这都是需要在一个广博的知识的基础上才行，所以对于知识，还是应该拿来主义，来者不拒。&lt;/p>
&lt;p>笔者回顾自己这几年的风雨历程，老实说，谈到绝望或者无奈的场景往往不是某个具体的问题，&lt;strong>能解决的问题是一定可以解决的&lt;/strong>，而是在知识海洋面前，感受到了宇宙的浩瀚与人类的渺小。庄子有云：吾生也有涯，而知也无涯。以有涯随无涯，殆已！笔者最常感觉痛苦的事情有二：&lt;/p>
&lt;p>(1)学过的知识都忘了。笔者算来开始用 Java 也有五年了吧，但是你现在要笔者立马说出 JVM 的架构组成，笔者也是心有戚戚，呐呐不能言。我能够记得的就是我系统的学习过五次，但是都忘了。再举个例子，笔者之前学习语言的时候，因为工作关系同时在用 Python、Java、Ruby、JavaScript，不谈学的多深，当时感觉最痛苦的就是老把每个语言怎么求取数组长度给忘了或者搞混了，是不是觉得很傻比？或者每次写 Java 的时候，笔者都会觉得读取文件好难好难，但是至少也写过上万行各种各样的读取文件的代码了吧。&lt;strong>我们构建一个完备的知识体系，不是为了让我们不会去忘记，而是让我们忘了之后能以最快的速度学会&lt;/strong>。我们宝贵的时间不应该浪费在对于知识的重复学习，Learn Once，Know Forever。&lt;/p>
&lt;p>(2)写过的代码都没了。举两个例子吧，还是以 Java 为例，我们很多项目都会用到一些字符串辅助的方法，譬如加密或者编码，然后笔者就发现每次做项目的时候都要把这些重写一遍。另一个呢，笔者学习 Spark 的时候，80%的时间都用来重复搭建虚拟机环境了，啪啪的。后来使用 Docker 之后才好一点。&lt;/p>
&lt;p>授人以鱼不如授人以渔，笔者一直觉得我这几年磕磕碰碰精华所在就是这完整的知识体系架构，它给了我莫大的信心与勇气去遨游在璀璨的知识长河中。不积跬步无以至千里，编程之路亦如一场游戏，随时学点知识拿个 EXP，或者打个大魔王爆个装备啥的，一个完备的知识体系或者知识图谱，就是你的背囊，也是你行走在知识海洋里的一叶扁舟。当然，本文所讲也只是一家之言，做不得准，大家见仁见智。顺便说一句，笔者很感谢为知笔记为我提供了非常好用的工具，这里友情推广一波。&lt;/p>
&lt;p>&lt;strong>知识应该放在它应该在的地方。&lt;/strong>&lt;/p>
&lt;h2 id="当我要学习一门编程语言cjavaphpswiftrustgo">当我要学习一门编程语言：C++/Java/PHP/Swift/Rust/Go…&lt;/h2>
&lt;blockquote>
&lt;p>关于本部分的详细文档和全部的知识结构图可以查看&lt;a href="https://github.com/wx-chevalier/Coder-Knowledge-Graph/blob/master/zh/programminglanguage.md" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>笔者从学习第一门语言开始，就被教导一个概念，学习一门语言的基础，也就是语法本身，不代表你掌握了这门语言。学习一门语言应该是学习它所代表的完整的生态环境和在各个应用场景下最合适的组合。同样的，笔者大大小小算是用过七八门语言，当然，你为了学习而去学习，用语言的数量标榜自己是毫无意义的。但是，每个语言都有其特性，就像才接触 Python 时候它的弱类型、快速开发的便捷以及后面应用到大型程序开发时候的代码混乱都给我留下了深刻的印象。往往说一门语言不好是因为你没学到家，但是就所处的技能水准和应用场景而言各个语言还是各有其优势的。笔者看现有的很多教程，以 Java 为例，它的讲解方式以及应用示例都是基于 JDK 本身和 Java 语言本身的特点的。那么笔者自己总结的这份所谓的编程语言的知识结构图或者拓扑图，是会抽象了各个语言的特性而形成。唔，譬如笔者最早是在 JavaScript 中，在用 jQuery 的时候接触到了 Promise 的概念，后来在 Java、在 Swift 中都发现了类似的，但不一定叫这个名字的用法或者第三方类库，那么我们在做笔记时，首先要知道，你现在所学的，是应该放在哪一部分。&lt;/p>
&lt;h3 id="语法基础">语法基础&lt;/h3>
&lt;p>学习一门语言呢，肯定首先要去学习它的语法基础，那学习语法基础的时候，我们要掌握哪几个方面呢，笔者大概归类到入门概述、Quick Start、数据结构、流程控制与异常处理、函数、模块与组件、类与对象以及 IO 这几个部分。详细的目录式列表可以参考&lt;a href="https://github.com/wx-chevalier/Coder-Knowledge-Graph/blob/master/zh/programminglanguage.md" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;h4 id="入门概述">入门概述&lt;/h4>
&lt;p>在这里你要了解这门语言的由来，它的特点，它的基本面貌。譬如你要了解下它各个版本迭代的特点。就像 Java 8 提出之后，你需要专门的对于 Java8 的语法特性进行一些了解，但是对于某个具体的语法知识点还是应该放到对应的语法讲解的位置。譬如 Java8 里面提出了函数式接口，那这部分具体的讲解还是应该放置到接口那一部分。&lt;/p>
&lt;p>其次呢，你还要在这边了解基本的注释与代码分割的规范，就好像笔者初学 Python 的时候，这货没有大括号，用的是缩进分割的方法，让才从 C++/Java 走过来的笔者一顿酸爽。&lt;/p>
&lt;p>接下来，在入门概述这边，你还要放外部资料的链接。你不可能把全部的你看到的资料转化为自己的笔记，那么你需要把所有的你看到的有价值的参考资料地址存放在这里。笔者大概分为了：&lt;/p>
&lt;ul>
&lt;li>Tutorial &amp;amp; Docs：入门教程和指导相关&lt;/li>
&lt;li>Practice&amp;amp;Tips：实践、小贴士相关，就好像 Github 上流行的 awesome-系列，就要把链接放这&lt;/li>
&lt;li>Forum&amp;amp;Lessons：一些论坛和在线的视频教程地址&lt;/li>
&lt;li>Blog&amp;amp;News：博客和资讯&lt;/li>
&lt;li>Book&amp;amp;Resources：参考的书籍啊、资源啊放这里&lt;/li>
&lt;/ul>
&lt;h4 id="quick-start">Quick Start&lt;/h4>
&lt;p>学习一门语言的时候，你肯定会写 HelloWorld，笔者在上面强调过，做笔记的一个目的就是在未来某天你可能全部忘记的时候能够以最快的速度学会，那么你再次学习的时候肯定会去继续写 HelloWorld。在这一部门，你需要知道怎么搭建开发环境，特别推荐是也要学下怎么使用 Docker 去搭建开发环境。接下来呢，你要学下构建工具和依赖管理工具。在早年，笔者才学 Java，还不知道用 Maven 的时候，那个时候根本分不清什么构建啊、依赖管理的概念，每次要用 jar 包了只能手动拖拽，真心呵呵哒。当然，一门优秀的编程语言一定要有其对应的构建与依赖管理工具，这样才能促进整个社区的活跃与交流。然后你要看看怎么进行代码部署，就好像 Python 的 Notebook、Swift 的 PlayGround 这些个神奇的东西，还是非常好用的。&lt;/p>
&lt;p>最后呢，还要看看常用的 IDE，不过笔者目前基本上就用的是 Atom 加上 Jetbrains(感恩)这一个系列。唔，之前看到很多大牛喜欢用 Sublime 啊 Vim 来写代码，我表示，这个逼还是不要装的好。&lt;/p>
&lt;h4 id="数据结构">数据结构&lt;/h4>
&lt;p>学完了 HelloWorld，我们就要来看看数据结构了，这是一个编程语言的基石所在。那么不论哪一种语言，它会提供给我们哪些知识呢。&lt;/p>
&lt;p>(1)首先是知道怎么去定义变量与常量。就好像 JavaScript 里面的 var、let，以及未来 Java 里面会加入的 val，变量定义的方式也是有很多种的。还有就是要了解下系统的内置的常量，这个在使用 PHP 进行开发的时候比较用得上。接下来，要看看这个变量是怎么赋值的，是必须单个赋值还是能够链式赋值，或者是像 JavaScript 这样还能支持解构赋值。最后呢，这一部分还要看看你怎么进行类型、格式判断的，好比&lt;code>instanceof&lt;/code>啊&lt;code>typeof&lt;/code>这些操作符，都是在这里介绍的。&lt;/p>
&lt;p>(2)然后呢要看看一些基本的数据类型。首先是数值类型，是分为了整型、浮点型还是像 OJC 这样的全是 NSNumber，还要看看原始类型和非原始类型的区别。如果是数值的话，还要看看怎么获取随机数、怎么进行科学计算、怎么进行类型转换。接下来，还要看看空类型、布尔类型、可选类型和枚举类型是怎么定义的。&lt;/p>
&lt;p>(3)接下来呢，看看字符串类型是怎么用的。字符串也是每个语言必备的，说难不难，说简单吧，那么多用法呢。基本上就要看看它是怎么创建增删、怎么索引遍历、怎么进行类型编码还有些像反向啊之类的基本操作。这里面也会有很多小的知识点，譬如 Java 里面字符串是不可变类型，譬如 PHP 里面你连接字符串不能用加号。&lt;/p>
&lt;p>(4)然后呢，就要看看结构体是怎么定义的了，这个在 Swift 里面还是挺重要的，不过在有些语言里就没有。&lt;/p>
&lt;p>(5)下面就要看看基本的时间日期类型，这里还会涉及到时区转换啊、日历啊等等方面。基本上各个语言的时间日期，要么是原生提供的不错，要么就会有第三方类库支持，譬如 JavaScript 中的 Moment.js，还是很不错的。&lt;/p>
&lt;p>(6)上面讲的几个数据类型都还好，现在开始就要了解高级复杂数据类型，也就是所谓的集合了。笔者把集合分为了序列类型与键值索引两大部分，譬如分别对应 Java 中的 List 和 Map。这边也是要了解集合的创建增删、索引遍历、类型转换还有排序啊、查找啊等等高级用法。&lt;/p>
&lt;p>(7)最后在这里还要学学不可变数据，这一点在函数式编程里面很流行，就好像 Facebook 提供的 Immutable.js 这个类库，还是很不错的。&lt;/p>
&lt;h4 id="流程控制与异常处理">流程控制与异常处理&lt;/h4>
&lt;p>接下来就要看看流程控制与异常处理方面的知识了，首先要知道运算符相关，像逻辑运算符啊、加减运算符啊还有运算符重载(运算符重载是能用于数据分析计算的语言的一个重要优势)。然后要看看怎么进行分支选择的，也就是常见的 if、switch 语句，在 Swift 中还有 guarantee 这样好用的语句。接下来就要看看怎么进行常见的循环了，最经典的肯定就是 for 循环，之后各个语言也都各有扩充，像什么 for-in、for-of、forEach 循环，它们都是属于循环遍历。还有就是 while 以及 do-while 这种变种。&lt;/p>
&lt;p>看完了循环下面继续看看流程控制，就像 break、continue 这种，还有 goto 这样可以随便乱跳的语句。下面要继续了解些作用域相关的知识，像 JavaScript 里面，一不小心就全局作用域了。然后还有关于迭代器的知识，在很多语言里迭代器和生成器是密不可分的，而在 Java 里面迭代器是一个接口。迭代器放在流程控制里也是因为一般来说迭代器也是用于循环的。&lt;/p>
&lt;p>最后，我们要来看看异常处理，包括怎么定义异常、怎么抛出异常，还有怎么用 try-catch-finally 这种形式来捕获和处理异常。Swift 里面提供了 try?的用法，也是非常 Sweet。&lt;/p>
&lt;h4 id="函数">函数&lt;/h4>
&lt;p>接下来我们继续学习函数的概念，唔，像 Java 这种完全的 OO 的语言，是没有函数的，里面只有方法，这也是它经常被诟病的地方，老说别的语言 HelloWorld 就一行，但是 Java 里面要写好多行。在这里笔者是把包括方法啊、函数都放在这边介绍。&lt;/p>
&lt;p>(1)函数定义首先呢要来看看函数是怎么定义的，不同的语言里定义方式有区别有交集。像有什么 func、function、define 等等 N 多不同的关键字。要注意下这个函数是不是需要返回值的，像 Java 里面没有返回值就是 void，而 Swift 里面可以写可以不写，还有很多弱类型语言里没有返回值。另外还要看看怎么定义函数变量，这个和闭包经常放在一起使用。&lt;/p>
&lt;p>(2)参数调用看完了定义再看看参数定义和调用方式。参数的话需要了解下有没有默认参数和外部参数。笔者刚接触 OJC 的时候，它的外部参数确实大大提高了可读性，后来 Swift 继承并且发扬光大了。下面就要看看不定参数，譬如怎么在 Java 里面定义不定参数。最后，要看看引用传值和复制传值的区别，在有些语言里还存在有 in-out 这样的关键字。&lt;/p>
&lt;p>(3)匿名函数/Lambda/闭包
Java8 里面引入了 Lambda 的用法，Lambda 本身也是函数式编程的一枚标杆，是一种设计模式吧。这里要看看 Lambda 怎么用，像有的语言里是-&amp;gt;，有的是=&amp;gt;，这个要区分下。还有就是看看闭包怎么定义，Swift 里面提供了一个尾随闭包的调用方式，非常方便。&lt;/p>
&lt;p>(4)生成器生成器、yield，最早笔者是在 Python 中接触到的，现在看 ES 里面也引入了这个概念。生成器一般和迭代器搭配在一起使用，不过也可以用来编写异步代码。&lt;/p>
&lt;p>(5)装饰器装饰器感觉有点像 AOP 的概念，笔者也是在 Python 和 Angular2 中接触到的。&lt;/p>
&lt;p>(6)函数柯里化和反柯里化在计算机科学中，柯里化(英语：Currying)，又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函 数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家哈斯凯尔·加里命名的，尽管它是 Moses Schönfinkel 和 Gottlob Frege 发明的。这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用 性，但同时也降低了函数的适用范围。笔者在 JavaScript 与 Scala 会比较常用这个特性，这里以 JavaScript 为例说明柯里化的核心思想。&lt;/p>
&lt;h4 id="模块与组件">模块与组件&lt;/h4>
&lt;p>这里主要学习下模块化的概念，譬如 Java、C#里面都会存在有命名空间，而 Swift 里是全局命名空间。还有像 ES6 里，这个 export、import 关键字到底是咋用的。&lt;/p>
&lt;h4 id="类与对象">类与对象&lt;/h4>
&lt;p>笔者还真没接触过 Lisp、Haskell 这样纯函数式语言，基本上都是 OO 的吧。那么类与对象也就是非常重要的一个部分。&lt;/p>
&lt;p>(1)类的定义怎么定义类、怎么用 public、private、protected 或者类似的方法来划分可见域、怎么来划分属性。像 Swift 里面还有延迟加载啊、属性监控啊等等。怎么来定义方法(和上面的函数一起看)。&lt;/p>
&lt;p>(2)对象怎么初始化对象，有的语言里有 new，有的没有。怎么实践单例模式。还有就是 this 或者 self 这样类似的用法到底干啥的，像 JavaScript 里面，因为最早的时候没有 OO 的概念，各种自定义的对象，这时候 this 的用法也就非常的杂乱。还有就是对象属于哪个类型进行的判断，这一点和变量章节有所重复。&lt;/p>
&lt;p>(3)继承怎么继承一个对象，还有就是继承之后的方法对于访问的父类中的属性啊、重载啊咋搞的，这个在 Java 面试题里面经常碰到。&lt;/p>
&lt;p>(4)抽象类、接口/协议与委托怎么定义抽象类或者接口，在 Swift 和 OJC 中是协议的概念，还有就是譬如 Java 中的怎么定义一个注解。&lt;/p>
&lt;p>(5)内部类这个在 Java 中用的比较多，又分为静态内部类、成员内部类、局部内部类以及匿名内部类。&lt;/p>
&lt;p>(6)反射与类装载&lt;/p>
&lt;h4 id="io">IO&lt;/h4>
&lt;p>这里介绍基本的输入输出的方法，包括控制台的输入输出、参数的处理、文件基本的读写，还有像 Java 里面繁多的什么字节流、字符流啊进行介绍。&lt;/p>
&lt;h3 id="语法应用">语法应用&lt;/h3>
&lt;p>学完了语法基础，那我们的笔记就要进入其他的具体的应用了，这里又分为 Advanced、Storage、TestRelease、SysProc 这几个部分。&lt;/p>
&lt;h4 id="advanced">Advanced&lt;/h4>
&lt;p>在这里就要进行泛型编程、内存管理、序列化和反序列化、编程规范和代码风格以及由该语言实现的算法的学习。&lt;/p>
&lt;h4 id="network">Network&lt;/h4>
&lt;p>本部分主要介绍网络访问、网络调用相关。包括了 NetworkManagement(网络管理)、Socket、HttpClient(网络客户端)、RPC/RMI(远程调用)&lt;/p>
&lt;h4 id="storage">Storage&lt;/h4>
&lt;p>在这里存放文件系统、数据库存储等等相关的内容。包括了缓存，像 Java 里缓存又会分为 on-heap 和 off-heap 两种。然后就要看看常见的数据库，数据库包括了 KeyValue 数据库，最常见的就是 Redis。还有文档型数据库，最常见的就是 Mongodb，还有关系型数据库。关系型数据库的使用中又要注意 ORM 和数据库分区分表等等插件。&lt;/p>
&lt;h4 id="testrelease">TestRelease&lt;/h4>
&lt;p>这里主要是测试啊、发布啊相关的内容。包括了单元测试，像 JUnit、Debug，像在 PHP 里面用 XDebug 实现单步调试，还有 Log 日志，像著名的 log4j，还有就是运行状态监控。&lt;/p>
&lt;h4 id="sysproc">SysProc&lt;/h4>
&lt;p>这里主要存放系统进程相关的内容，包括了切面编程和最重要的并发、同步相关的知识。&lt;/p>
&lt;p>(1)并发并发这部分要了解多线程的基本概念、线程通信的基本概念。基本的异步模式，像 Promise、Callback 啊等等，还有就是异步的数据流，也就是消息总线，还有就是响应式开发。&lt;/p>
&lt;p>(2)同步与线程安全这边要了解锁的基本概念，譬如 Java 中的 synchronized 和 Lock。然后还要了解一些内建的线程安全的数据结构。&lt;/p>
&lt;h2 id="当我要学习客户端开发iosandroidhybridwebapp">当我要学习客户端开发：iOS/Android/Hybrid/WebAPP&lt;/h2>
&lt;p>随着前后端分离的概念日渐流行，实际上现在包括 Web 领域都可以认为是一个客户端。笔者阅读 REST 这篇论文的时候，最大的感受就是彻底的 C/S 化与无状态化。那么，在这一部分，笔者要解决的问题同样是，当我要学习 Android/iOS/WebAPP 的时候，我应该学些什么。这一部分会比上面的更加复杂，全部的列表可以看&lt;a href="https://github.com/wx-chevalier/Coder-Knowledge-Graph/blob/master/zh/client.md" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;h3 id="language">Language&lt;/h3>
&lt;p>此部分主要介绍用于开发对应程序的语言详情，基本上和上面的编程语言知识体系结构相一致。&lt;/p>
&lt;h3 id="ui界面呈现">UI：界面呈现&lt;/h3>
&lt;p>这一部分基本上是整个客户端开发的最重要的地方，首先在 UI.md 中介绍界面呈现的基本原理，什么 Screen、坐标系之类的。&lt;/p>
&lt;h3 id="components基本组件">Components(基本组件)&lt;/h3>
&lt;p>本部分要介绍系统自带的基本组件，譬如 Android 里面的 Activity、Fragment，iOS 里面的 UIView、UIViewController 等等。此外，还需要介绍：&lt;/p>
&lt;p>(1)Layout &amp;amp; Position
此部分介绍基本的布局与定位的知识。包括基本的布局约束，譬如左边距、右边距、居中等等。然后是基本的定位方式，包括绝对布局、相对布局、弹性布局和线性布局等等。接下来是基本的布局管理器，Android 开发的同学应该对这个概念不陌生。然后就是自动布局或者所谓的响应式布局，对应了 iOS 中的 AutoLayout 和 Web 里面的响应式开发。&lt;/p>
&lt;p>(2)Container
此部分主要介绍经常的作为容器的 View，一个是页卡视图，就是常说的 TabBar，譬如 Android 中的 Tab、iOS 中的 TabbarController 等等。还有导航视图，就是 NavigationView，譬如 iOS 中的 UINavigationController。最后是最常用的滚动视图，ScrollView，譬如 Web 中的 Swiper 等等。滚动视图还要解决几个问题：Infinite Scroll、上拉下拉刷新以及像 ViewPager 这样的基于页面的滑页式滚动。&lt;/p>
&lt;p>(3)Router：页面路由譬如 ui-router 等等。&lt;/p>
&lt;h4 id="interaction用户交互">Interaction(用户交互)&lt;/h4>
&lt;p>本部分主要介绍用户交互相关知识。&lt;/p>
&lt;p>(1)Event&amp;amp;Gesture(事件与手势操作)
这里对于用户常见的点击、拖拽等事件进行响应处理，包括了基本事件的绑定与监听、事件捕获传递与分发机制以及复杂手势的监听与识别，譬如多点触控、拖拽、滚动】缩放和摇晃等。&lt;/p>
&lt;p>(2)Media(音视频播放、录制与相关操作)
主要包括了对于相机的基本操作、对于 Audio 的基本操作以及对于 Video 的播放。还包括譬如语音输入啊、直播啊等等。&lt;/p>
&lt;p>(3)Sensor
本部分主要包括对于各种传感器，包括陀螺仪、重力传感器等的使用，譬如 iOS 的 HealthKit 就是放在这里的。&lt;/p>
&lt;p>(4)Notification
这里记录对于通知栏的操作，包括本地通知与远程推送的通知。&lt;/p>
&lt;h4 id="dvisual绘图以及数据可视化">DVisual(绘图以及数据可视化)&lt;/h4>
&lt;p>本部分主要对于基本的绘图与数据可视化进行了记录，包括但不限于：&lt;/p>
&lt;p>(1)Graphics
这里记录了基本的绘图、画笔的使用，包括了像颜色与取色、头像啊、表情啊之类的处理。&lt;/p>
&lt;p>(2)Style&amp;amp;Theme
样式与主题的处理，在 Android 中就会经常涉及到样式与主题的概念，还有什么夜间模式、日间模式之类的。&lt;/p>
&lt;p>(3)Filter
这里进行基本的滤镜与过滤的处理，注意，这里与图片部分的滤镜区别在于这里的滤镜是面向于某个 View，而不仅仅是图片进行的。&lt;/p>
&lt;p>(4)Chart
这里记录各种图表，什么折线图、饼状图等等。&lt;/p>
&lt;p>(5)Map
这里记录地图相关，像对于百度地图的使用就放在这里。&lt;/p>
&lt;p>(6)Barcode
这里记录二维码、条形码相关的内容。&lt;/p>
&lt;h4 id="animation动画与变换">Animation(动画与变换)&lt;/h4>
&lt;p>本部分主要记录动画以及常见的变换的内容，包括了动画构造库以及常见的动画集合。动画构造库的话又会分为帧动画与属性控制这两种。&lt;/p>
&lt;h4 id="widgets界面插件">Widgets(界面插件)&lt;/h4>
&lt;p>这里存放各式各样的插件，算是最复杂的一块。全部的列表可以看&lt;a href="https://github.com/wx-chevalier/Coder-Knowledge-Graph/blob/master/zh/client.md" target="_blank" rel="noopener">这里&lt;/a>。&lt;/p>
&lt;p>(1)Dialog：对话框插件包括了模态对话框、弹出层与提示层、覆盖层、Action Sheet 等等。&lt;/p>
&lt;p>(2)Indicator：指示器包括了介绍或者引导页、时间显示、进度显示、文本显示以及效果、标签显示以及效果等等。&lt;/p>
&lt;p>(3)Picker：输入器包括了按钮、菜单、状态栏/工具栏、选择器、文本输入、时间与日期输入等等。&lt;/p>
&lt;p>(4)TableGrid：网格与表单包括了基本的列表的使用、网格的使用以及卡片式界面的使用。譬如 iOS 的 UITableView、Android 的 CardView、RecycleView 都要放在这里。&lt;/p>
&lt;p>(5)Gallery：画廊包括了图片的基本操作，譬如图片的加载、懒加载、缓存、动图的播放与控制、图片滤镜、图片标签、图片贴纸、图片裁剪与美化等等。还有图片相册的浏览、图片轮播、瀑布流方式图片展示、焦点图浏览等等。&lt;/p>
&lt;p>(6)WebView
包括了 WebView 的基本使用、本地交互以及 Cordova 的集成等等。&lt;/p>
&lt;h3 id="network网络调用">Network：网络调用&lt;/h3>
&lt;p>本部分主要讲解网络调用，包括了：&lt;/p>
&lt;p>(1)网络管理譬如网络可达性判断、打开网络等等放在这。&lt;/p>
&lt;p>(2)Socket&lt;/p>
&lt;p>(3)HttpClient
常见的网络客户端的使用，譬如 Android 中的 okHttp、iOS 中的 AFNetwork 等等的基本使用都放在这，基本的请求管理、并发请求等等。注意，这里还有一个叫 HTTPStubs 或者 MockServer，是方便开发或者测试进行的本地伪装网络请求。&lt;/p>
&lt;p>(4)Push
本部分进行推送与长连接实现的内容。&lt;/p>
&lt;p>(5)FileTransfer
本部分进行基本的文件传输，上传和下载的记录。&lt;/p>
&lt;p>(6)Serialization
本部分进行常见的譬如 JSON、FlatBuffer 以及 MsgPack 序列化的研究。&lt;/p>
&lt;h3 id="storage存储">Storage：存储&lt;/h3>
&lt;p>本部分主要对于存储相关的内容进行记录，包括：&lt;/p>
&lt;p>(1)DataBase(数据库)
像 iOS 的 CoreData、SQLite 的使用，以及最近比较火的 Realm 的使用。&lt;/p>
&lt;p>(2)File(文件)
这里记录了基本的文件浏览与访问，还有对于配置文件、资源文件的使用等等。&lt;/p>
&lt;p>(3)Cache(缓存系统)&lt;/p>
&lt;h3 id="sysproc系统与进程">SysProc：系统与进程&lt;/h3>
&lt;p>(1)组件之间的通信像 Android 中利用 AIDL 进行通信、利用 ContentProvider 进行通信等等。&lt;/p>
&lt;p>(2)并发与异步&lt;/p>
&lt;p>(3)服务&lt;/p>
&lt;p>(4)RPC：远程服务调用&lt;/p>
&lt;h3 id="testrelease-1">TestRelease&lt;/h3>
&lt;p>本部分主要记录测试与发布相关的内容：&lt;/p>
&lt;p>(1)Debug(调试与记录)
包括日志、线程与 Crash 的监控等等&lt;/p>
&lt;p>(2)Test
包括了单元测试、界面测试以及第三方测试等等。&lt;/p>
&lt;p>(3)Release
包括了 Android 中的签名、iOS 里面的提交到 AppStore 的流程还有类似于云测这样的第三方测试。&lt;/p>
&lt;p>(4)Optimization
优化&lt;/p>
&lt;p>(5)Plugin &amp;amp; Dynamic Patch(插件化与动态更新)
这个在 Android 中用的比较多，像阿里的那个可以动态更新的工具。&lt;/p>
&lt;p>(6)APM：应用状态追踪与评分&lt;/p>
&lt;h2 id="当我要学习服务端开发springmvclaravelrails">当我要学习服务端开发：SpringMVC/Laravel/Rails&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://segmentfault.com/image?src=http://ww3.sinaimg.cn/large/697e0967jw1ew4b6sp4zyj20qo0k0gmh.jpg&amp;amp;objectId=1190000004612590&amp;amp;token=b7276db14b59303821d8b1b86828ba1d" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>Introduction&lt;/li>
&lt;li>Quick Start
&lt;ul>
&lt;li>Installation&lt;/li>
&lt;li>Generator&lt;/li>
&lt;li>Dependence Managent：依赖管理与自定义模块导入&lt;/li>
&lt;li>Deployment&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Application
&lt;ul>
&lt;li>LifeCycle&lt;/li>
&lt;li>Configuration&lt;/li>
&lt;li>Multiple Modules&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Route&lt;/li>
&lt;li>Controller
&lt;ul>
&lt;li>Request&lt;/li>
&lt;li>Session&lt;/li>
&lt;li>Response&lt;/li>
&lt;li>Pagination&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Model
&lt;ul>
&lt;li>Relational DataBase
&lt;ul>
&lt;li>ORM&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MySQL&lt;/li>
&lt;li>Oracle&lt;/li>
&lt;li>SQLServer&lt;/li>
&lt;li>PostgreSQL&lt;/li>
&lt;li>NoSQL&lt;/li>
&lt;li>MongoDB&lt;/li>
&lt;li>Cache&lt;/li>
&lt;li>Redis&lt;/li>
&lt;li>Memcache&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>View
&lt;ul>
&lt;li>Template&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Middleware
&lt;ul>
&lt;li>Auth&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Service
&lt;ul>
&lt;li>IoC/DI&lt;/li>
&lt;li>Log&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Test&lt;/li>
&lt;li>Concurrence
&lt;ul>
&lt;li>Queue&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>笔者在这里打个广告，介绍下笔者自己借鉴了微服务、Redux 等等杂七杂八东西之后对于 RESTful 深入理解提出的一些构想：&lt;a href="https://segmentfault.com/a/1190000004600730" target="_blank" rel="noopener">Reactive Abstract Resource Flow&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="当我要学习数据科学machinelearningnlpdeeplearningstatistic">当我要学习数据科学：MachineLearning/NLP/DeepLearning/Statistic&lt;/h2>
&lt;blockquote>
&lt;p>这是笔者自己的一个数据科学的&lt;a href="https://wx-chevalier.gitbooks.io/datascience-practice-handbook/content/" target="_blank" rel="noopener">Gitbook&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>对于数据科学这部分，笔者自己也正在完善中，只能是大概如下：&lt;/p>
&lt;ul>
&lt;li>Methodology：方法理论
&lt;ul>
&lt;li>DataProcess：数据处理&lt;/li>
&lt;li>MachineLearning：机器学习的计算算法&lt;/li>
&lt;li>ANN：人工神经网络&lt;/li>
&lt;li>Clustering：聚类&lt;/li>
&lt;li>Regression：回归&lt;/li>
&lt;li>SVM&lt;/li>
&lt;li>NLP：自然语言处理&lt;/li>
&lt;li>PatternMatch：模式识别&lt;/li>
&lt;li>SentimentAnalysis：情感分析&lt;/li>
&lt;li>TopicModel：主题模型&lt;/li>
&lt;li>Word2Vec：词向量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Library：开发库
&lt;ul>
&lt;li>ClusterComputing&lt;/li>
&lt;li>MLib&lt;/li>
&lt;li>Madout&lt;/li>
&lt;li>Java&lt;/li>
&lt;li>Weka&lt;/li>
&lt;li>Deeplearning4j&lt;/li>
&lt;li>MATLAB&lt;/li>
&lt;li>Python&lt;/li>
&lt;li>Scikit&lt;/li>
&lt;li>TensorFlow&lt;/li>
&lt;li>R&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Application：应用
&lt;ul>
&lt;li>Classification：分类&lt;/li>
&lt;li>CommunityDetection：社团发现&lt;/li>
&lt;li>Personas：用户标签画像&lt;/li>
&lt;li>Recognition：模式识别&lt;/li>
&lt;li>RecommendSystem：推荐系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="当我要学习云计算与大数据的基础架构分布式计算运维存储虚拟化">当我要学习云计算与大数据的基础架构：分布式计算/运维/存储/虚拟化&lt;/h2>
&lt;p>云计算和大数据的概念很火啊，作为一个程序狗，笔者也是算是从四年前就开始接触到这方面的技术，不过讲真，因为没去过大公司，只能看着啥阿里、美团在 InfoQ、程序员杂志上分享自己的高可用平台眼馋。很多技术笔者在自己的电脑上用过，也一直保持关注，但还真没投入过实战。这一部分在笔者笔记内的代号是 Infrastructure，就是基础架构，主要包括了 DCE(分布式计算环境)、Distributed(分布式)、OM(运维)、Storage(存储)以及 Virtualization(虚拟化)这几个方面。&lt;/p>
&lt;h3 id="dce分布式计算环境">DCE：分布式计算环境&lt;/h3>
&lt;p>分布式计算环境主要会介绍基于批式计算和流式计算的常见的框架和原理，这里推荐一波笔者翻译的：&lt;a href="https://segmentfault.com/a/1190000004593949?_ea=665564" target="_blank" rel="noopener">Apache 流处理框架对比&lt;/a>。常见的批处理框架就是 Hadoop 的 MapReduce 和 Spark(不知道有没有理解错)，而流处理框架包括但不限于 Flink、Storm 还有 Spark Streaming。&lt;/p>
&lt;h3 id="distributed分布式系统">Distributed:分布式系统&lt;/h3>
&lt;p>分布式系统这部分，一方面要了解分布式系统的基本的知识原理，另一方面就是应用了，笔者主要分为了以下几个部分：&lt;/p>
&lt;ul>
&lt;li>JobSchedule：任务调度与管理，譬如 Disque&lt;/li>
&lt;li>MOM：消息中间件，像 Kafka、RabbitMQ、ZeroMQ 这些&lt;/li>
&lt;li>ProgramModel：编程模型&lt;/li>
&lt;li>ResManager：资源管理，典型的就是 Yarn 和 Mesos&lt;/li>
&lt;li>ServiceCoordination：服务发现和服务调度，典型的就是 Zookeeper 和 Etcd，话说阿里的 Dubbo 我也放在这了，确实不错的。&lt;/li>
&lt;/ul>
&lt;h3 id="om运维管理">OM：运维管理&lt;/h3>
&lt;p>这部分是运维管理，也包含了 DevOps 的很多理念在这边，主要就是：&lt;/p>
&lt;ul>
&lt;li>ContinuousDelivery：持续交付，也包括了 CI 的概念，像 Jenkins 这样的工具介绍&lt;/li>
&lt;li>Log：日志
&lt;ul>
&lt;li>ELK&lt;/li>
&lt;li>Flume&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MonitorAnalytic：应用追踪与分析&lt;/li>
&lt;/ul>
&lt;h3 id="storage存储-1">Storage：存储&lt;/h3>
&lt;p>这部分就是介绍各种各样的存储系统：&lt;/p>
&lt;ul>
&lt;li>Cache：缓存，著名的 Memcache 就放在这&lt;/li>
&lt;li>DataBase：数据库系统
&lt;ul>
&lt;li>ColumnOriented：列数据库，譬如 HBase&lt;/li>
&lt;li>Document：文档型数据库，譬如 Mongodb、Cassandra&lt;/li>
&lt;li>Graph：图数据库&lt;/li>
&lt;li>KeyValue：键值数据库，譬如 Redis&lt;/li>
&lt;li>Relational：关系型数据库&lt;/li>
&lt;li>MySQL&lt;/li>
&lt;li>Oracle&lt;/li>
&lt;li>SQLServer&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DataWareHouse：数据仓库，譬如 Hive&lt;/li>
&lt;li>ETL：数据存储过程，譬如 Kettle&lt;/li>
&lt;li>FileSystem：文件系统
&lt;ul>
&lt;li>NTFS&lt;/li>
&lt;li>ext4&lt;/li>
&lt;li>RAMFS：譬如 Taycon&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="virtualization虚拟化">Virtualization：虚拟化&lt;/h3>
&lt;p>这部分主要介绍虚拟化的相关知识和原理，大概如下：&lt;/p>
&lt;ul>
&lt;li>Container：容器技术，很火的，不多说
&lt;ul>
&lt;li>Docker&lt;/li>
&lt;li>Rocket&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>OpenStack&lt;/li>
&lt;li>SandBox：传统的沙箱的技术&lt;/li>
&lt;li>Hypervisor
&lt;ul>
&lt;li>Xen&lt;/li>
&lt;li>VShpere&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="当我要学习信息安全移动安全计算机取证渗透测试逆向工程加固">当我要学习信息安全：移动安全/计算机取证/渗透测试/逆向工程/加固&lt;/h2>
&lt;p>笔者本科里学习的是信息安全，当时做 Windows 驱动开发的，每天扒 MSDN 的文档，当时是以越向下为荣，现在想想就觉得好凄惨。后来笔者的第一份兼职也是和信息安全相关，也搞过站抓过鸡，不过后来觉得唔至少在自己浅薄的认知里，做安全很大程度上是去发现现有系统的问题，不能说无聊，只能说没有做工程开发那样让我来的有兴趣。笔者在自己的信息安全相关的学习中，大概进行了如下归类：&lt;/p>
&lt;ul>
&lt;li>ComputerForensics：计算机取证相关&lt;/li>
&lt;li>Cryptology：密码学与编码相关&lt;/li>
&lt;li>MobileSecurity：移动安全，包括像应用程序的逆向还有木马啊、系统破解啊之类的，笔者当年也研究过 Xposed，还弄了个&lt;a href="https://github.com/wx-chevalier/Android-AppMonitorDroid" target="_blank" rel="noopener">Android-AppMonitorDroid&lt;/a>&lt;/li>
&lt;li>Reinforce：主机加固啊之类的&lt;/li>
&lt;li>ReverseEngineering：逆向工程，就是传统的用 OD、IDA 进行破解的，还有免杀也属于这一块&lt;/li>
&lt;li>PenetrationTesting：渗透测试，这波就比较大了
&lt;ul>
&lt;li>Tools：常见的渗透测试工具的介绍，像 Kali、Backtrack、MSF 之类的&lt;/li>
&lt;li>Vulns：漏洞和 0Day 的总结&lt;/li>
&lt;li>Application：应用程序的漏洞，像什么 ECShop 之类的&lt;/li>
&lt;li>DataBase：数据库漏洞&lt;/li>
&lt;li>Middleware：中间件漏洞&lt;/li>
&lt;li>OS：操作系统漏洞&lt;/li>
&lt;li>Tech&lt;/li>
&lt;li>踩点扫描，啥社会工程啊之类的&lt;/li>
&lt;li>漏洞利用，DDOS 之类的&lt;/li>
&lt;li>内网渗透，内网监听、DNS 投毒之类的&lt;/li>
&lt;li>前端安全，啥 SQL 注入、XSS、CSRF 属于这一块&lt;/li>
&lt;li>无线安全&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>2015-我的前端之路</title><link>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/2015-%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/2015-%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/</guid><description>&lt;blockquote>
&lt;p>本文从属于笔者的&lt;a href="https://github.com/wx-chevalier/Web-Frontend-Introduction-And-Best-Practices" target="_blank" rel="noopener">Web 前端入门与最佳实践&lt;/a>，2016 年度版本在：&lt;a href="https://zhuanlan.zhihu.com/p/24575395" target="_blank" rel="noopener">2016-我的前端之路:工具化与工程化&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>撰写本文的时候笔者阅读了以下文章，不可避免的会借鉴或者引用其中的一些观点与文字，若有冒犯，请随时告知。文列如下：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/phodal/repractise/blob/gh-pages/chapters/frontend.md" target="_blank" rel="noopener">RePractise 前端篇: 前端演进史&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/amfe/article/issues/28" target="_blank" rel="noopener">前端的变革&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/" target="_blank" rel="noopener">致我们终将组件化的 Web&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://bbear.me/wo-suo-gan-jue-dao-de-qian-duan-bian-hua/" target="_blank" rel="noopener">我感觉到的前端变化&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.infoq.com/cn/articles/2015-review-frontend" target="_blank" rel="noopener">解读 2015 之前端篇：工业时代 野蛮发展&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kuitos/kuitos.github.io/issues/29" target="_blank" rel="noopener">前端工程化知识要点回顾&amp;amp;思考&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.position-absolute.com/javascript/thoughts-about-react-redux-javascript-in-2016/" target="_blank" rel="noopener">Thoughts about React, Redux &amp;amp; javascript in 2016&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果你想进行 WebAPP 的学习，建议先看下&lt;a href="https://segmentfault.com/a/1190000004612590" target="_blank" rel="noopener">我的编程之路：知识管理与知识体系&lt;/a>相关内容&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>顺便推广下笔者总结的泛前端知识点纲要总结：&lt;a href="http://segmentfault.com/a/1190000003963329" target="_blank" rel="noopener">Coder Essential 之客户端知识索引(iOS/Android/Web) &lt;/a>、&lt;a href="http://segmentfault.com/a/1190000003738148" target="_blank" rel="noopener">Coder Essential 之编程语言学习知识点纲要&lt;/a>、&lt;a href="http://segmentfault.com/a/1190000003756500" target="_blank" rel="noopener">Coder Essential 之编程语言语法特性概论&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="2015-我的前端之路数据流驱动的界面">2015-我的前端之路：数据流驱动的界面&lt;/h1>
&lt;p>几年前初入大学，才识编程的时候，崇尚的是一路向下，那个时候喜欢搞 Windows、Linux 底层相关的东西，觉得那些做网页的太 Low 了。直到后来偶然的机会接触到 HTML、JavaScript、CSS，很长一段时间觉得这种这么不严谨的，毫无工程美学的搭配不过是&lt;strong>诗余&lt;/strong>罢了。后来，深入了，才发现，能够有幸在这片星辰大海里游荡，可以以几乎领先于其他方向的技术变革速度来感受这个时代的脉动，是多么幸运的一件事。这是一个最坏的时代，因为一不小心就发现自己 Out 了；这也是一个最好的时代，我们永远在前行。繁华渐欲，万马齐鸣！&lt;/p>
&lt;p>借用苏宁前端结构师的总结，任何一个编程生态都会经历三个阶段，第一个是原始时期，由于需要在语言与基础的 API 上进行扩充，这个阶段会催生大量的 Tools。第二个阶段，随着做的东西的复杂化，需要更多的组织，会引入大量的设计模式啊，架构模式的概念，这个阶段会催生大量的 Frameworks。第三个阶段，随着需求的进一步复杂与团队的扩充，就进入了工程化的阶段，各类分层 MVC，MVP，MVVM 之类，可视化开发，自动化测试，团队协同系统。这个阶段会出现大量的小而美的 Library。当然，笔者以 Tools-Frameworks-Library 只是想说明我个人感觉的变化。&lt;/p>
&lt;p>笔者从 jQuery 时代一路走来，经历了以 BootStrap 为代表的基于 jQuery 的插件式框架与 CSS 框架的兴起，到后面以 Angular 1 为代表的 MVVM 框架，以及到现在以 React 为代表的组件式框架的兴起。从最初的认为前端就是切页面，加上一些交互特效，到后面形成一个完整的 webapp，总体的变革上，笔者以为有以下几点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>移动优先与响应式开发&lt;/p>
&lt;/li>
&lt;li>
&lt;p>前端组件化与工程化的变革&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从直接操作 Dom 节点转向以状态/数据流为中心&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>笔者在本文中的叙事方式是按照自己的认知过程，夹杂了大量个人主观的感受，看看就好，不一定要当真，毕竟我菜。梳理来说，有以下几条线：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>交互角度的从 PC 端为中心到 Mobile First&lt;/p>
&lt;/li>
&lt;li>
&lt;p>架构角度的从以 DOM 为中心到 MVVM/MVP 到以数据/状态为驱动。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>工程角度的从随意化到模块化到组件化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>工具角度的从人工到 Grunt/Gulp 到 Webpack/Browserify。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在正文之前，重要的事情说三遍，我是菜鸟！我是菜鸟！我是菜鸟！从来都没有最好的技术，而只有合适的技术与懂它的人。我感谢这些伟大的类库/框架，感恩它们的 Contributor，给我呈现了一个何其广阔的世界。虽然 2015 的前端领域有点野蛮生长，但是也体现了前端一直是开源领域的扛鼎之处，希望有一天我也能为它的繁荣做出自己的贡献。&lt;/p>
&lt;h2 id="基石与催化剂">基石与催化剂&lt;/h2>
&lt;h3 id="浏览器的跃进">浏览器的跃进&lt;/h3>
&lt;p>现在 H5 已经成为了一个符号，基本上所有具有绚丽界面或者交互的 Web 界面，无论是 PC 还是 Mobile 端，都被称为基于 H5。笔者一直认为，H5 技术的发展以及带来的一系列前端的变革，都离不开现代浏览器的发展与以 IE 为典型代表的老的浏览器的消逝。目前浏览器的市场分布可以由如下两个图：&lt;/p>
&lt;ul>
&lt;li>浏览器分布图&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://camo.githubusercontent.com/cc49022be14438a65cc405400e6456c2d33c1164/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69322f5442314c794c594b465858585862755870585857434b35507058582d3732312d3331322e706e67" alt="浏览器分布率" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>国际浏览器分布图&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://camo.githubusercontent.com/9c951acd78914ecda41febc489328f3e5cf1c908/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69332f5442313231484b4b4658585858584a585658585372742e565858582d3532322d3435362e706e67" alt="国际浏览器分布率" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>这里顺嘴说下，如果想要明确某个属性是否可以使用可以参考&lt;a href="http://caniuse.com/" target="_blank" rel="noopener">Can I Use&lt;/a>。话说虽然微信内置的某 X5 内核浏览器连 Flexbox 都不支持，不过它帮我们屏蔽了大量手机的底层差异，笔者还是非常感恩的。当然了，在有了 Webpack 之后，用 Flexbox 不是问题，可以查看这&lt;a href="http://segmentfault.com/a/1190000004139009" target="_blank" rel="noopener">嘎达&lt;/a>。&lt;/p>
&lt;h3 id="ecmascript">ECMAScript&lt;/h3>
&lt;p>2015 年是 JavaScript 诞生的 20 周年。同时又是 ES6 标准落地的一年。ES6 是迄今为止 ECMAScript 标准最大的变革(如果不算上胎死腹中的 ES4 的话)，带来了一系列令开发者兴奋的新特性。从目前 es 的进化速度来看，es 后面应该会变成一个个的 feature 发布而不是像以前那样大版本号的方式，所以现在官方也在推荐 ES+年份这种叫法而不是 ES+版本。在 ES2015 中，笔者觉得比较欣赏的特性如下，其他完整的特性介绍可以参考这篇文章&lt;a href="https://github.com/bevacqua/es6" target="_blank" rel="noopener">ES6 Overview in 350 Bullet Points&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>Module &amp;amp; Module Loader：ES2015 中加入的原生模块机制支持可谓是意义最重大的 feature 了，且不说目前市面上五花八门的 module/loader 库，各种不同实现机制互不兼容也就罢了(其实这也是非常大的问题)，关键是那些模块定义/装载语法都丑到爆炸，但是这也是无奈之举，在没有语言级别的支持下，js 只能做到这一步，正所谓巧妇难为无米之炊。ES2016 中的 Module 机制借鉴自 CommonJS，同时又提供了更优雅的关键字及语法(虽然也存在一些问题)。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>Class：准确来说 class 关键字只是一个 js 里构造函数的语法糖而已，跟直接 function 写法无本质区别。只不过有了 Class 的原生支持后，js 的面向对象机制有了更多的可能性，比如衍生的 extends 关键字(虽然也只是语法糖)。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>Promise &amp;amp; Reflect API：Promise 的诞生其实已经有几十年了，它被纳入 ES 规范最大意义在于，它将市面上各种异步实现库的最佳实践都标准化了。至于 Reflect API，它让 js 历史上第一次具备了元编程能力，这一特性足以让开发者们脑洞大开。&lt;/li>
&lt;/ul>
&lt;p>除此之外，ES2016 的相关草案也已经确定了一大部分其他 new features。这里提两个我比较感兴趣的 new feature：&lt;/p>
&lt;ul>
&lt;li>async/await：协程。ES2016 中 async/await 实际是对 Generator&amp;amp;Promise 的上层封装，几乎同步的写法写异步比 Promise 更优雅更简单，非常值得期待。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>decorator：装饰器，其实等同于 Java 里面的注解。注解机制对于大型应用的开发的作用想必不用我过多赘述了。用过的同学都说好。&lt;/li>
&lt;/ul>
&lt;p>更让人兴奋的是，JavaScript 慢慢不再局限于前端开发中，NodeJs 的提出让人们感受到了利用 JavaScript 进行全栈开发的能力，从此大大提高了开发的效率(至少不用多学习一门语言)。JavaScript 在物联网中的应用也曾经引起一些追捧与风潮，不过今年物联网社区更加冷静地看待着这个问题，但是并不影响各大厂商对于 JavaScript 的支持，可以参阅&lt;a href="http://www.sitepoint.com/javascript-beyond-the-web-in-2015/" target="_blank" rel="noopener">javascript-beyond-the-web-in-2015&lt;/a>这篇文章。笔者还是很看好 JavaScript 在其他领域继续大放异彩，毕竟 ECMAScript 6，7 已经是如此的优秀。&lt;/p>
&lt;h3 id="webassembly">WebAssembly&lt;/h3>
&lt;p>WebAssembly 选择了跟 ES2015 在同一天发布，其项目领头人是大名鼎鼎的 js 之父 Brendan Eich。WebAssembly 旨在解决 js 作为解释性语言的先天性能缺陷，试图通过在浏览器底层加入编译机制从而提高 js 性能。WebAssembly 所做的正是为 Web 打造一套专用的字节码，这项标准在未来应用场景可能是这样的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>开发应用，但使用任何一门可被编译为 WebAssembly 的语言编写源代码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用编译器将源代码转换为 WebAssembly 字节码，也可按需转换为汇编代码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在浏览器中加载字节码并运行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://cdn2.infoqstatic.com/statics_s1_20160105-0313u5/resource/news/2015/10/webassembly-7-things/zh/resources/1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>需要注意的是，WebAssembly 不会替代 JavaScript。越来越多的语言和平台想在 Web 上大展手脚，这会迫使 JavaScript 和浏览器厂商不得不加快步伐来补充缺失的功能，其中某些功能通过复杂的 JavaScript 语义来实现并不合适，所以 WebAssembly 可以作为 JavaScript 的补集加入到 Web 阵营中来。WebAssembly 最一开始的设计初衷就是作为不依赖于 JavaScript 的编译目标而存在，进而获得了主流浏览器厂商的广泛支持。很期待有一天 WebAssembly 能够发展起来，到那个时候，我们用 JavaScript 编写的应用也会像现在用汇编语言写出的大型程序的感觉咯~&lt;/p>
&lt;h2 id="渐隐的-jquery-与服务端渲染">渐隐的 jQuery 与服务端渲染&lt;/h2>
&lt;h3 id="html附庸之徒">HTML：附庸之徒&lt;/h3>
&lt;blockquote>
&lt;p>前端用于数据展示&lt;/p>
&lt;/blockquote>
&lt;p>在笔者最早接触前端的时候，那个时候还不知道前端这个概念，只是知道 HTML 文件可以在浏览器中显示。彼时连 GET/POST/AJAX 这些概念都不甚明了，还记得那个时候看到一本厚厚的 AJAX 实战手册不明觉厉。笔者阅读过&lt;a href="http://www.ics.uci.edu/%7Efielding/" target="_blank" rel="noopener">Roy Thomas Fielding&lt;/a>博士的&lt;a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">Architectural Styles andthe Design of Network-based Software Architectures&lt;/a>这篇论文，也就是 RESTful 架构风格的源处。在这篇文章里，笔者反而感觉最有感触的是从 BS 到 CS 架构的跃迁。一开始我觉得网页是典型的 BS 的，咋说呢，就是网页是数据、模板与样式的混合，即以经典的 APS.NET、PHP 与 JSP 为例，是由服务端的模板提供一系列的标签完成从业务逻辑代码到页面的流动。所以，前端只是用来展示数据。&lt;/p>
&lt;p>那个时候笔者更菜，对于 CSS、JS 都不甚明了，一切的数据渲染都是放在服务端完成的。笔者第一次学 HTML 的时候，惊呆了，卧槽，这能算上一门语言嘛？太简单了吧。。。原来做个网页这么简单啊，然后生活就华丽丽打了脸。那个时候，根本不会以&lt;code>script&lt;/code>或者&lt;code>link&lt;/code>的方式将资源载入，而是全部写在一个文件里，好吧，那时候连 jQuery 都不会用。记得那个时候 Ajax 都是自己手写的，长长的毫无美感的大量重复冗余的代码真是日了狗。&lt;/p>
&lt;p>为什么说 HTML 只是附庸之徒呢，那个时候我们没有把 Browser 的地位与其他的 Client 并列，换言之，在经典的 Spring MVC 框架里，如下所示，用户所有的逻辑操作的核心我们都会放置到 Java 代码中，根本不会想到用 JavaScript 进行控制。另一个方面，因为没有 AJAX 的概念，导致了每次都是表单提交-后台判断-重新渲染这种方式。这样导致了每一个渲染出来的网页都是无状态的，换言之，网页是依赖于后端逻辑反应不同有不同的呈现，自身没有一个完整的状态管理。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://camo.githubusercontent.com/c82bedc2d28bc1893df46969665804e194900e0b/687474703a2f2f726570726163746973652e70686f64616c2e636f6d2f696d672f66726f6e74656e642f736572766963652d6d76632e706e67" alt="Service MVC" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>&lt;em>图片来源于《前端篇：前端演进史》&lt;/em>&lt;/p>
&lt;h3 id="ajax-与客户端开发">AJAX 与客户端开发&lt;/h3>
&lt;p>笔者最早的区分 CS 与 BS 架构，抽象来说，会认为 CS 是客户端与服务器之间的双向通信，而 BS 是客户端与服务端之间的单向通信。换言之，网页端本身也变成了有状态。从初始打开这个网页到最终关闭，网页本身也有了一套自己的状态，而拥有这种变化的状态的基础就是 AJAX，即从单向通信变成了双向通信。图示如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://camo.githubusercontent.com/91852dab9e4d37f88353fcb9b5f3205a87d72de0/687474703a2f2f726570726163746973652e70686f64616c2e636f6d2f696d672f66726f6e74656e642f6d6963726f73657276696365732e706e67" alt="Micro Services" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h3 id="渐隐的-jquery">渐隐的 jQuery&lt;/h3>
&lt;p>jQuery 作为了影响一代前端开发者的框架，是 Tools 的典型代表，它留下了璀璨的痕迹与无法磨灭的脚印。笔者在这里以 jQuery 作为一个符号，来代表以 Dom 节点的操作为核心的一代的前端开发风格。那个年代里，要插入数据或者更改数据，都是直接操作 Dom 节点，或者手工的构造 Dom 节点。譬如从服务端获得一个用户列表之后，会通过构造&lt;code>&amp;lt;i&amp;gt;&lt;/code>节点的方式将数据插入到 Dom 树中。&lt;/p>
&lt;p>但是不得不承认，在未来相当长的一段时间内，jQuery 并不会直接退出历史的舞台，笔者个人认为一个重要的原因就是现在仍然存在着很大比重的各式各样的基于 jQuery 的插件或者应用，对于崇尚拿来主义的我们，不可避免的会继续使用着它。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/oneuijs/You-Dont-Need-jQuery/" target="_blank" rel="noopener">You-Dont-Need-jQuery&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>jQuery 引领了一个辉煌的时代，但是随着技术的演进它也慢慢在很多项目中隐去。jQuery 这个框架本身非常的优秀并且在不断的完善中，但是它本身的定位，作为早期的跨浏览器的工具类屏蔽层在今天这个浏览器 API 逐步统一并且完善的今天，逐渐不是那么关键。因此，笔者认为 jQuery 会逐渐隐去的原因可能为：&lt;/p>
&lt;ul>
&lt;li>现代浏览器的发展与逐步统一的原生 API&lt;/li>
&lt;/ul>
&lt;p>由于浏览器的历史原因，曾经的前端开发为了兼容不同浏览器怪癖，需要增加很多成本。jQuery 由于提供了非常易用的 API，屏蔽了浏览器差异，极大地提高了开发效率。这也导致很多前端只懂 jQuery。其实这几年浏览器更新很快，也借鉴了很多 jQuery 的 API，如 &lt;code>querySelector&lt;/code>，&lt;code>querySelectorAll&lt;/code> 和 jQuery 选择器同样好用，而且性能更优。&lt;/p>
&lt;ul>
&lt;li>前端由以 DOM 为中心到以数据/状态为中心&lt;/li>
&lt;/ul>
&lt;p>jQuery 代表着传统的以 DOM 为中心的开发模式，但现在复杂页面开发流行的是以 React 为代表的以&lt;strong>数据/状态&lt;/strong>为中心的开发模式。应用复杂后，直接操作 DOM 意味着手动维护状态，当状态复杂后，变得不可控。React 以状态为中心，自动帮我们渲染出 DOM，同时通过高效的 DOM Diff 算法，也能保证性能。&lt;/p>
&lt;ul>
&lt;li>不支持同构渲染与跨平台渲染&lt;/li>
&lt;/ul>
&lt;p>React Native 中不支持 jQuery。同构就是前后端运行同一份代码，后端也可以渲染出页面，这对 SEO 要求高的场景非常合适。由于 React 等流行框架天然支持，已经具有可行性。当我们在尝试把现有应用改成同构时，因为代码要运行在服务器端，但服务器端没有 DOM，所以引用 jQuery 就会报错。这也是要移除 jQuery 的迫切原因。同时不但要移除 jQuery，在很多场合也要避免直接操作 DOM。&lt;/p>
&lt;ul>
&lt;li>性能缺陷&lt;/li>
&lt;/ul>
&lt;p>jQuery 的性能已经不止一次被诟病了，在移动端兴起的初期，就出现了 Zepto 这样的轻量级框架，Angular 1 也内置了 jqlite 这样的小工具。前端开发一般不需要考虑性能问题，但你想在性能上追求极致的话，一定要知道 jQuery 性能很差。原生 API 选择器相比 jQuery 丰富很多，如 &lt;code>document.getElementsByClassName&lt;/code> 性能是 &lt;code>$(classSelector)&lt;/code> 的 50 多倍！&lt;/p>
&lt;p>&lt;a href="https://camo.githubusercontent.com/b1f3d997150c7103b566d6afc76b839f6ae15236/687474703a2f2f7365676d656e746661756c742e636f6d2f696d672f625672676b57" target="_blank" rel="noopener">
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://camo.githubusercontent.com/b1f3d997150c7103b566d6afc76b839f6ae15236/687474703a2f2f7365676d656e746661756c742e636f6d2f696d672f625672676b57" alt="jQuery VS Native AP" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/a>&lt;/p>
&lt;p>说这么多，只是想在以后技术选型的时候，能有一个通盘考虑，毕竟，这是曾经的 Best Love。&lt;/p>
&lt;h2 id="蛋疼的模块化与-spa">蛋疼的模块化与 SPA&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>如果当时的移动网络速度可以更快的话，我想很多 SPA 框架就不存在了&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>随着踩得坑越来越多与类似于 Backbone、AngularJs 这样的更加纯粹全面的客户端框架的兴起，Single Page Application 流行了起来。至此，在网页开发领域也就完全变成了 CS 这种理念。至此之后，我们会考虑在前端进行更多的用户交互与状态管理，而不是一股脑的全部交给后台完成。特别是页面的切换与不同数据的呈现不再是需要用户进行页面的跳转，从而在弱网情况下使用户获得更好的体验与更少的流量浪费。与此同时，前端就变得更加的复杂化，我们也迫切的需要更加完善的代码分割与管理方案，于是，笔者开始尝试接触模块化的东西。笔者自 RequireJs、SeaJs 兴起以来一直关注，但是从未在实际项目中投入使用。额，第一次用这两个框架的时候，发现貌似需要对现有的代码或者喜欢的 jQuery Plugins 进行封装，当时我这种懒人就有点心理阴影了。不过 SeaJs 作为早期国人开发的有一定影响力的前端辅助工具，笔者还是非常敬佩的。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.awesomes.cn/source/9" target="_blank" rel="noopener">前端扫盲-之打造一个自动化的前端项目&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="模块化的进步与不足">模块化的进步与不足&lt;/h3>
&lt;p>在笔者知道模块化这个概念之前，文件夹是这么分的：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://cdn.alloyteam.com/wp-content/uploads/2015/11/mulu_right.png" alt="mulu_right" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>看上去非常的工整，但是稍微有个多人协作的项目，或者稍微多用一点 jQuery 的插件，看着那十来二十个不知道里面到底是啥的 JS 文件，笔者是崩溃的。笔者最早打算使用模块化的动力来源于避免作用域污染，那个时候经常发现的问题是一不小心引进来的两个第三方文件就打架了，你还不知道怎么去修改。&lt;/p>
&lt;p>模块一般指能够独立拆分且通用的代码单元，在 ES6 正式出来规范之前，我们会选择使用 RequireJs 或者 SeaJs 来进行有点像依赖注入的东西：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">require&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;Tmpl!../tmpl/list.html&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;lib/qqapi&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;module/position&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;module/refresh&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;module/page&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;module/net&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">],&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">listTmpl&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">QQapi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Position&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Refresh&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">NET&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>大概是这样子的，但是笔者就是觉得好烦啊，并且它整个页面的逻辑还是面向过程编码的。换言之，我如果页面上稍微换了个布局或者有那么三四个有交集的页面，那就日了狗了，根本谈不上复用。&lt;/p>
&lt;h3 id="backbonejsmvc-方式的-spa">Backbone.js：MVC 方式的 SPA&lt;/h3>
&lt;p>Backbone 是笔者较早期接触到的，以数据为驱动的一种框架。Backbone 诞生于 2010 年，和响应式设计出现在同一个年代里，但他们似乎在同一个时代里火了起来。如果 CSS3 早点流行开来，似乎就没有 Backbone 啥事了。不过移动网络还是限制了响应式的流行，只是在今天这些都有所变化。换言之，就是将数据的处理与页面的渲染分离了出来。算是在以 jQuery 那种以 DOM 操作为核心的基础上完成了一次变革。同样的笔者用过的框架还有&lt;code>easy-ui&lt;/code>，不过它是一个封装的更加完全的框架。开发时，不需要考虑怎么去写大量的 HTML/CSS 代码，只需要在他的组件内填充不同的逻辑与配置即可。很方便，也很不方便，记得笔者想稍稍修改下他的表格的功能都蛋疼了好一阵子。&lt;/p>
&lt;p>Backbone 相对而言会更开放一点，在笔者大量使用 Angular 的时候也有同学提议使用 Backbone + avaon 这种更轻量级的方案。我们用 Ajax 向后台请求 API，然后 Mustache Render 出来，这里已经会开始将 Web 端视作一个完整的 Client 而不仅仅是个附庸的存在。一个典型的 Backbone 组件的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//《前端篇：前端演进史》
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">define&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;zepto&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;underscore&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;mustache&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;js/ProductsView&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;json!/configure.json&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;text!/templates/blog_details.html&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;js/renderBlog&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">],&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">$&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Mustache&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ProductsView&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">configure&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">blogDetailsTemplate&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">GetBlog&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">BlogDetailsView&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">Backbone&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">View&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">extend&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">el&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;#content&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">initialize&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;#content&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getBlog&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">slug&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">getblog&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">GetBlog&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">params&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">configure&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;blogPostUrl&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">slug&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">blogDetailsTemplate&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">getblog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">renderBlog&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">BlogDetailsView&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看见，在 Backbone 中已经将 DOM 元素与数据渲染以及逻辑剥离了开来，这样就有助于进行团队内的分工与协作，以及大量的代码复用。那个时候经常会将 Backbone 与 Angular 进行对比，二者各有优劣。Backbone 在显示模板、创建数据绑定和连接组件方面给使用者更多的选择。与之相反，Angular 为这些问题提供了规定的方案，不过在创建模型与控制器方面的限制就比较少一些。笔者当时是因为想要用一套 Framework 来解决问题，所以还是投入了 Angular 的怀抱。&lt;/p>
&lt;h3 id="angularjs-10mvvm-方式的-spa">AngularJs 1.0：MVVM 方式的 SPA&lt;/h3>
&lt;p>AngularJs 是第一个我真正喜欢的 Framework，不仅仅是因为它提出的 MVVM 的概念，还有因为它自带的 DI 以及模块化的组织方式。或许正是因为使用了 AngularJs 1.0，笔者才没有深入使用 RequireJs、SeaJs 这些吧。AngularJs 1.0 的优秀与槽点就不细说了，在那个时代他成功让笔者有了一点完整的前端项目的概念，而不是多个分离的互相之间跳转的 HTML 文件。最近，AngularJs 2.0 终于出了 Beta 版本，笔者也一直保持关注。不过个人感觉唱衰的声音还是会大于褒扬之声，从笔者个人感觉而言，一个大而全的框架可能不如多个小而美的框架更加的灵活，关于这个对比可以参考下文的&lt;code>Web Components VS Reactive Components&lt;/code>这一章节。此外，对于 AngularJs 中一直诟病的性能问题，Facebook 提出的 Virtual DOM 的算法毫无疑问为前端的性能优化指明了一条新的道路，笔者这里推荐一个&lt;a href="https://auth0.com/blog/2016/01/07/more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/" target="_blank" rel="noopener">Performance Benchmarks&lt;/a>，其中详细对比了多个 DOM 操作的库。笔者在这里只贴一张图，别的可以去原文查看：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://cdn.auth0.com/blog/newdombenchs/MajorGC.svg" alt="Major GC collection times" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>总体而言，Vue 偏轻量，适合移动端，ng 适应 pc 端，avalon 适合兼容老浏览器的项目。虽然 Vue.js 现在也有组件化的实现，包括类似于 Flux 的 Vuex 这样的 Single State Tree 的框架，但是笔者还是比较倾向于把它当做一个 MVVM 模型来对待。&lt;/p>
&lt;h2 id="组件化的未来与-mobile-first">组件化的未来与 Mobile-First&lt;/h2>
&lt;p>最初随着 React 的风靡，组件化的概念深入人心。笔者一直坚信组件化是非常值得去做的事情，它在工程上会大大提升项目的可维护性及拓展性，同时会带来一些代码可复用的附加效果。但这里要强调的一点是，组件化的指导策略一定是分治而不是复用，分治的目的是为了使得组件之间解耦跟正交，从而提高可维护性及多人协同开发效率。如果以复用为指导原则那么组件最后一定会发展到一个配置繁杂代码臃肿的状态。组件化最著名的标准无疑是 W3C 制定的 Web Components 标准，它主要包含以下几个方面：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>&amp;lt;template&amp;gt;&lt;/code>模板能力&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ShadowDom 封装组件独立的内部结构&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义原生标签&lt;/p>
&lt;/li>
&lt;li>
&lt;p>imports 解决组件间的依赖&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>不过这个标准本身还没发扬光大就被 Angular、React 这样的框架完爆了，不过他还是指明了我们组件化的几个准则：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>资源高内聚：有点像 Vue 提到的理念，Single File Component。组件资源内部高内聚，组件资源由自身加载控制&lt;/p>
&lt;/li>
&lt;li>
&lt;p>作用域独立：内部结构密封，不与全局或其他组件产生影响&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义标签：可以像使用 HTML 的预设标签一样方便地使用组件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可相互组合：组件正在强大的地方，组件间组装整合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接口规范化：组件接口有统一规范，或者是生命周期的管理&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="web-components-vs-reactive-components">Web Components VS Reactive Components&lt;/h3>
&lt;p>对于 Web 组件化的典型代表，应该是 React 与 Angular 2。Angular 2 基本上完全革了 Angular 1 的命，Angular 开发团队最早于 2014 年 3 月提出路线图，直到 2015 年底才进入 alpha 阶段。笔者自 Angular 2 开发之始就一直保持关注，见证了其规范或者接口的更迭。不可否认 Angular 2 在性能以及设计理念上都会比 Angular 1 先进很多，但是随着 2014 年中到 2015 年初以 React 为代表的组件式 UI 框架以及 Flux/Redux 为代表的响应式数据流驱动兴起，可能 Angular 2 并不会达到 Angular 1 的高度。笔者也在断断续续地更新一些 Angular 2 的指导与学习文档，不过确实，除了从零开始的大型项目，Angular 2 还是太笨重了。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://developer.telerik.com/featured/will-angular-2-be-a-success-you-bet/" target="_blank" rel="noopener">Will Angular 2 be a success? You bet!&lt;/a>(注意，评论更精彩)&lt;/li>
&lt;/ul>
&lt;p>实际上，在我们选择一个库或者所谓的框架时，为我们的组件选择一个合适的抽象可能会比觉得哪个框架更好更有意义。目前 Web 的组件化开发分为两个大的趋势，一个是以 Angular 2、Polymer 为代表的 Web Components，另一个是以 React、Vue、Riot 为代表的 Reactive Components。目前 Web Components 方面因为各个库之间无法就如何定义它们达成一致，导致了类似于 Angular 2、Aurelia 这样的框架用它们自己的核心来定义 Web Components。只有 Polymer 100%实践了 Web Components 的规范。Web Components 有点类似于 Google，而 React 更像 Facebook。&lt;/p>
&lt;p>另外，当我们选择一个框架时，还需要考虑清楚我们是需要一个包含了所有的功能的固执己见的框架，就像 Angular2、Ember 2 这样的，还是一系列小的专精的框架的组合，就像 React、Flux 以及 React Router 这样的。当然，我们在选择一个框架时还必须考虑进它潜在的变化的代价与难度，以及与其他的技术集成的难度，还有就是他有没有一个完善的生态系统。&lt;/p>
&lt;p>就像笔者在自己的&lt;a href="">AARF&lt;/a>提及的，无论前后端，在这样一样敏捷式开发与快速迭代地背景下，我们需要更多独立的分离的可以方便组合的类似于插件一样的模块。&lt;/p>
&lt;h3 id="响应式解决方案">响应式解决方案&lt;/h3>
&lt;p>随着 WAP 的出现与移动智能终端的飞速普及，开发者们不得不面临一个问题，大量的流量来自于手机端而不再是 PC 端，传统的 PC 端布局的网页，在手机上显示的根本不友好，什么鬼！最早的时候人们考虑的是面向 PC 端与 WAP 设计不同的页面，不过这样就毫无疑问将原来的工作量乘以二，并且产品管理与发布上也会存在着一定的问题，特别是在那个组件化与工程化理念还没有流行的时代里。于是，人们开始设计一套能够针对不同的屏幕响应式地自反馈的布局方案，也就是这里提到的响应式设计。&lt;/p>
&lt;blockquote>
&lt;p>响应式设计不得不提到的一个缺点是：&lt;strong>他只是将原本在模板层做的事，放到了样式(CSS)层来完成&lt;/strong>。复杂度同力一样不会消失，也不会凭空产生，它总是从一个物体转移到另一个物体或一种形式转为另一种形式。&lt;/p>
&lt;/blockquote>
&lt;p>笔者最早接触到的响应式设计来自于 BootStrap，它的 Media Query 功能给当时的笔者很大的惊喜的感觉。特别是 CSS3 中 Flexbox 的提出，更是能方便地践行响应式设计的原则。不过，就以淘宝首页为例，如果用响应式方式完成一套代码在 PC 端与手机端不同的完全适应的展示效果，我觉得还不如直接写两套呢。不可否认响应式设计在例如菜单啊，瀑布流布局啊这些功能组件上起到了非常巧妙的作用，但是为了单纯的追寻响应式布局而把整个 CSS 的逻辑判断搞得那么复杂，那我是拒绝的。特别是现在组件化这么流行的今天，我宁可在根控件中自由的组织各个组件，也好过不断地自适应判断。&lt;/p>
&lt;p>笔者不是非常提倡响应式解决方案来解决从 PC 端到移动端的迁移，笔者个人觉得 PC 端和移动端就是额，不是同一种画风的东西。话说笔者接触过不少完全用代码控制的响应式布局，譬如融云的&lt;a href="https://github.com/rongcloud/demo-web-sdk" target="_blank" rel="noopener">Demo&lt;/a>，它可以根据你显示器屏幕控制元素的显隐和事件。不可否认设计很精巧，但是在没有组件的那个时候，这种代码复杂度和性价比，在下服了。笔者在自己的实践中，对于纯移动端的响应式开发，譬如微信中的 H5，还是比较喜欢使用&lt;a href="https://github.com/peunzhang/pageResponse" target="_blank" rel="noopener">pageResponse&lt;/a>这种方式或者它的一些改进版本。&lt;/p>
&lt;h3 id="移动优先">移动优先&lt;/h3>
&lt;p>响应式解决方案，代表着随着不同的分辨率下智能的响应式布局。而移动优先的概念，笔者认为则是在界面设计之初即考虑到适应移动端的布局。当然，还有一个方面就是要照顾到移动端的浏览器的语法支持度、它的流量以及各种各样的 Polyfill。&lt;/p>
&lt;h3 id="hybridwebview-vs-cross-compilation">Hybrid：WebView VS Cross Compilation&lt;/h3>
&lt;p>笔者很懒，最早的时候只是有一点 Android 开发经验，那个时候 Hybrid 技术刚刚兴起，天天看 DZone 上 N 多的炫耀自己的 Hybrid 开发多快、性能多好的文章，立马激发起了我的懒癌。写一波就能跨平台运行，多爽啊！Hybrid 技术分为两个大的分支，一个以 Cordova 为代表的基于系统的 WebView 与本地调用。另一种早期以 Titanium、Tamarin，如今以 React Native 这样为代表的 Cross Compilation，即跨平台编译技术。&lt;/p>
&lt;blockquote>
&lt;p>在我们需要学习 C 语言的时候，GCC 就有了这样的跨平台编译。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在我们开发桌面应用的时候，QT 就有了这样的跨平台能力。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在我们构建 Web 应用的时候，Java 就有了这样的跨平台能力。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在我们需要开发跨平台应用的时候，Cordova 就有了这样的跨平台能力。&lt;/p>
&lt;/blockquote>
&lt;p>于是乎，在笔者第一次正式创业时，我斩钉截铁的跟投资人说，用 Hybrid 开发，用 Cordova，没错的。记得那时候笔者还不懂 iOS 开发，所以在第一次正式做 App 的时候选择了 Ionic 1.0。其实最早是打算用 jQuery Mobile，不过写了第一个小的 tab 的 Demo 然后在自己的千元机上运行的时候，打开应用竟然花了 20 多秒，当时投资人看到的时候脸是绿的，心是凉的。估计是那时候还不会用 jQuery Mobile 吧(虽然现在也不会)，但确实不是一个可行方案。后来笔者转到了 Ionic 1.0，确实一开始感觉不错，速度还阔以。但是当时笔者还小，犯了一个很大的认知错误，就是打算完全摒弃掉 Native 全部用 Web 技术开发，于是，一个简单地文件上传分分钟就教我做了人。最后产品做出来了，但是压根用不了。插一句，一开始为了在 Android 老版本设备上解决 WebView 的兼容性问题，打算用 Crosswalk。笔者第一次用 Crosswalk 编译完成之后，吓尿了。速度上确实快了一点，但是包体上实在增加的太大了，臣妾做不到啊！至此之后，笔者熄灭了完全依赖于 Cordova 进行 APP 开发的理念。&lt;/p>
&lt;blockquote>
&lt;p>结果&lt;strong>时间轴又错了&lt;/strong>，人们总是&lt;strong>超前一个时期做错了一个在未来是正确的决定&lt;/strong>。大概是那个时候机器性能还不是足够的好吧。&lt;/p>
&lt;/blockquote>
&lt;p>Cordova 或者 Webview 这种方向是没错的，现在也大量的存在于笔者的 APP 中，但是对于中大型 APP 而言，如果直接架构在 Cordova 之上，笔者还是不推荐的。Build Once，Run Everywhere，貌似做不到了，或者说差强人意。那就考虑 Learn Once，Write Everywhere。React Native 又引领了一波时代潮流。&lt;/p>
&lt;p>Cross Compilation 的典型代表是 NativeScript 与 React Native。笔者自然是更喜欢 React Native 的，毕竟背靠整个 React 生态圈，对于原生组件的支持度也是很好的。React 框架本身虽好，但是还是有许多可以与之媲美的优秀的框架的，但是 React 依靠 Virtual DOM 以及组件化等概念，依赖 Facebook 工程师强大的工程与架构能力，已经打造了一个完整的生态。特别是 0.14 版本之后的 react 与 react-dom 的分割，愈发的可以看出 React 的雄心壮志。将表现层与具体的界面分离开来，通过 Canvas、Native、Server 乃至未来的 Desktop 这样不同的渲染引擎，保证了代码的高度重用性，特别是逻辑代码的重用性。&lt;/p>
&lt;h2 id="工程化与-builder">工程化与 Builder&lt;/h2>
&lt;h3 id="前端工程化">前端工程化&lt;/h3>
&lt;p>大部分时候我们谈论到工程化这个概念的时候，往往指的是工具化。但是任何一个通向工程化的道路上都不可避免的会走过一段工具化的道路。笔者最早的接触 Java 的时候用的是 Eclipse，那个时候不懂什么构建工具，不懂发布与部署，每次要用类库都要把 jar 包拷贝到 Libs 目录下。以至于多人协作的时候经常出现依赖相互冲突的问题。后来学会了用 Maven、Gradle、Jenkins 这些构建和 CI 工具，慢慢的才形成了一套完整的工作流程。前端工程化的道路，目标就是希望能用工程化的方法规范构建和维护有效、实用和高质量的软件。&lt;/p>
&lt;p>笔者个人感觉的工程化的要素，会有以下几个方面：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>统一的开发规范(语法/流程/工程结构)与编译工具。实际上考虑到浏览器的差异性，本身我们在编写前端代码时，就等于在跨了 N 个“平台”。在早期没有编译工具的时候，我们需要依赖自己去判断浏览器版本(当然也可以用 jQuery 这样人家封装好的)，然后根据不同的版本写大量的重复代码。最简单的例子，就是 CSS 的属性，需要加不同的譬如&lt;code>-o-&lt;/code>、&lt;code>-moz-&lt;/code>这样的前缀。而这样开发时的判断无疑是浪费时间并且存在了大量的冗余代码。开发规范也是这样一个概念，JavaScript 本身作为脚本语言，语法的严谨性一直比较欠缺，而各个公司都有自己的规范，就像当年要实现个类都有好几种写法，着实蛋疼。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模块化/组件化开发。在一个真正的工程中，我们往往需要进行协作开发，之前往往是按照页面来划分，但是会造成大量的重复代码，并且维护起来会非常麻烦。这里的模块化/组件化开发的要素与上面的第一点都是属于开发需求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>统一的组件发布与仓库。笔者在使用 Maven 前后会有很大的一个对比感，没有一个统一的中央仓库与版本管理工具，简直就是一场灾难。这样也无法促进开发者之间的沟通与交流，会造成大量的重复造轮子的现象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>性能优化与项目部署。前端的错误追踪与调试在早期一直是个蛋疼的问题，笔者基本上每次都要大量的交互才能重现错误场景。另一方面，前端会存在着大量的图片或者其他资源，这些的发布啊命名啊也是个很蛋疼的问题。当我们在构建一个 webapp 的完整的流程时，我们需要一套自动化的代码质量检测方案来提高系统的可靠性，需要一套自动化以及高度适应的项目发布/部署方案来提高系统的伸缩性和灵活性。最后，我们需要减少冗余的接口、冗余的资源请求、提高缓存命中率，最终达到近乎极致的性能体验。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="webpack">Webpack&lt;/h3>
&lt;p>Webpack 跟 browserify 本质上都是 module bundler，差异点在于 Webpack 提供更强大的 loader 机制让其更变得更加灵活。当然，Webpack 的流行自然还是离不开背后的 react 跟 facebook。但是从现在 HTTP/2 标准的应用及实施进展来看，Webpack/browserify 这种基于 bundle 的打包工具也面临着被历史车轮碾过的危机，相对的基于 module loader 的 jspm 反而更具前景。Browserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，通过预编译让前端 Javascript 可以直接使用 Node NPM 安装的一些库。相较于 Webpack，Browserify 具有更悠久的历史，记得当年还是看&lt;a href="http://www.oschina.net/translate/browserify-vs-webpack" target="_blank" rel="noopener">这篇文章&lt;/a>才开始慢慢认识到 Webpack，那时候 Webpack 还是一个相当年轻的框架啊。&lt;/p>
&lt;p>Webpack 是前端开发真正意义上成为了工程级别，而不再是随意，可以看看&lt;a href="http://www.infoq.com/cn/articles/frontend-engineering-webpack?hmsr=toutiao.io&amp;amp;utm_campaign=rightbar_v2" target="_blank" rel="noopener">这篇文章&lt;/a>。笔者第一次看 Webpack 的时候，没看懂。当时用 Gulp 用的正顺手，不需要自己往 HTML 文件里引入大量的 Script 文件，还能自动帮你给 CSS 加前后缀，自动地帮你压缩，多好啊。不过 Grunt 和 Gulp 现在存在的问题就是需要自己去组装大量的插件，参差不齐的插件质量导致了大量时间的浪费。并且 Gulp/Grunt 还并不能称为一个完整的编译工具，只是一个辅助工具。&lt;/p>
&lt;p>Webpack 还有很令笔者欣慰的一点，它支持 Lazy Load Component，并且这种懒加载技术是与框架无关的。这样就避免了笔者在编码时还需要考虑固定的组件或者代码分割，毕竟在一个快速迭代的项目中还是很难在一开始就规划好全部的组件分割。这一点对于笔者这种被 SPA JS 加载以及原来的无论是基于 Angular 的懒加载还是 React Router 的懒加载折磨的人是一个大大的福音。同时，Webpack 还支持配合了 React Hot Loader 的代码热插拔，可以大大地提高代码的开发效率。毕竟等着 Browserify 编译好也是很蛋疼的。&lt;/p>
&lt;p>在笔者的个人的感触中，Webpack 是促成了前端真正工程化的不可缺少的一环。记得之前看过美团的前端技术分享，它提出了前端分布式编译系统。大型系统的分布式编译很常见，但是在前端，这典型的脚本与解释执行的领域，出现了大型分布式编译系统，还是很让人震惊的。笔者是个懒惰的人，懒人总希望可以用一套方法去解决全部的问题，所以慢慢的笔者完全切入到了 Webpack。或许未来某天也会离开 Webpack，就像离开 jQuery 一样，但是会永远记得陪我走过的这些岁月。&lt;/p>
&lt;h2 id="响应式数据流驱动的页面">响应式数据流驱动的页面&lt;/h2>
&lt;p>现代这样一个云计算与大数据的时代，Data Driven 的概念早已深入人心。随着 WEB 应用变得越来越复杂，再加上 node 前后端分离越来越流行，那么对数据流动的控制就显得越发重要。笔者在开篇就提及过，前端变革的一个核心路线就是从以 DOM Manipulation 为核心到以 State 为核心，这样也就能将逻辑控制、渲染与交互给分离开来。用一个函数来表示，现在的渲染就是：$UI=f(state)$。在 React 中$f$可以看做是那个 render 函数，可以将 state 渲染成 Virtual DOM，Virtual DOM 再被 React 渲染成真正的 DOM。在控制器中，我们不需要关心 DOM 是如何变更的，只需要在我们的业务逻辑中完成状态转变，React 会自动将这个变更显示在 UI 中。其实在 Angular 中也是这样，只不过 Angular 中采取的数据双向绑定与脏检测的技术，而 React 中采用的是 JSX 这样来完成一种从状态到页面的绑定。&lt;/p>
&lt;p>这样一种以响应式数据流驱动的页面，毫无疑问会将编程工作，特别是复杂的交互与逻辑处理变得更加明晰，也方面了产品迭代与变更，也就是敏捷式开发的理念。采用这样的响应式数据流驱动的方式，还有一个很大的好处就是方便错误追踪与调试。&lt;code>SPA State is hard to reproduce!&lt;/code>而在 Redux 这样的框架中，存在着类似于 Global State Object 这样的可以将页面全部还原，来重现 Bug 的东西。当测试人员/用户遇到问题的时候，主动将当时的 State 发送给开发人员，开发人员就阔以直接根据 State 来还原现场咯。Immutable 的魅力正在于此，灵活的可追踪性。&lt;/p>
&lt;p>Redux 是在 flux 的基础上产生的，在此基础上它引入了函数式编程、单一数据源、不可变数据、中间件等概念，基本思想是保证数据的单向流动，同时便于控制、使用、测试。Redux 不依赖于任意框架(库)，只要 subscribe 相应框架(库)的内部方法，就可以使用该应用框架保证数据流动的一致性。Redux 在一定程度上可以说是今年 React 生态甚至整个前端生态中影响最大的一个框架，它给整个前端技术栈引入了很多新成员，尽管这些概念可能在其他领域已经有了广泛的应用。笔者还是比较推崇响应式开发的，实际工作中用的比较多的还是 FPR 的一些实现，譬如 RxJava 啊这些。Redux 标榜的是 Immutable 的 State Tree，而 Vue 采用的是 Mutable 的 State Tree。&lt;/p>
&lt;p>笔者在不长的代码之路上从 Windows Developer 到 Pentester，到 Android Developer，到 Server-Side Developer，最后选择了 Front-end 作为自己的归宿。不过 Server-Side Architecture 和 Data Science 也是我的最爱，哈哈哈哈哈哈，怎么有一种坐拥后宫的赶脚~&lt;/p>
&lt;p>希望能永远在这条路上，心怀激情，热泪盈眶。&lt;/p></description></item><item><title>如何成为优秀的软件工程师</title><link>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/</guid><description>&lt;p>﻿- &lt;a href="https://medium.com/@swissspidy/how-to-be-a-successful-software-engineer-dfc3f9e63462#.vii2llqfp" target="_blank" rel="noopener">原文地址:How to Be a Successful Software Engineer&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>这篇文章还是挺符合笔者思想的。笔者涉世不深，见识短浅，不过讲真，这么多年来遇到的，笔者觉得真正能做到以下几点的，聊聊无几。这个性质往往不是由你的经验和你已知的决定，而是由你对技术本身的态度决定。笔者现在不玩游戏不看剧，每天看看文章写写代码，本身就是一件非常开心的事情。获得知识与创造的快感，只可意会不可言传。&lt;/p>
&lt;/blockquote>
&lt;p>文首是原作者参加一次会议所感，实际上绝大部分踏入程序猿这个行业的人都会考虑，怎么才能成为一名优秀的程序员，无论是为了物质生活还是精神追求，而本文列举的几点也是原作者所想。&lt;/p>
&lt;blockquote>
&lt;p>需要注意，这篇文章是 Opinionated，请批判的去看。笔者也插入了很多自己的观点，不过主旨上还是和原文保持一致，只是做些讲解。&lt;/p>
&lt;/blockquote>
&lt;h1 id="know-what-youre-not-doing知你不知">Know What You’re Not Doing:知你不知&lt;/h1>
&lt;p>有个非常著名的适用于基本上所有领域的论断，当然肯定也合适与软件开发啦：
&lt;strong>I know that I know nothing:知我所知&lt;/strong>&lt;/p>
&lt;p>牛逼的工程师往往都会选择合适的事情去做，譬如知道你能够完成哪些任务，知道在当前任务下应该选择怎么样的解决方案，知道应该钻研或者关注哪些技术等等。优先做处在关键节点上的事情，相对应地，也需要知道你现在还不懂哪些东西。&lt;/p>
&lt;blockquote>
&lt;p>不要让你已有的东西成为你的阻碍&lt;/p>
&lt;/blockquote>
&lt;p>所有人都会说学习一门语言没啥的，但是人们在选择解决方案或者承接任务的时候不可避免地会受到已会的语言的影响，就像笔者会尽可能避免使用.Net，毕竟不精通。所以你要明白，不要拘泥于你会的，不要沾沾自喜于你的经验，老实说笔者有时候听某些人动不动炫耀自己 N 年的工作经验，还是有点反感的。你应该根据需要学习任何东西，面试官更希望用你未来可以达到的去衡量你，而不是你现在所处的境界与位置。&lt;/p>
&lt;blockquote>
&lt;p>一直记得苏格拉底的一句话，就是认识你自己，映射到程序猿中，就是能知道你可以做的和不可以做的，而尽可能地少去迷惑自己到底能不能做。无论是对于技术选型还是项目规划都适用这个观点，随着学习的深入和了解的东西的增加，自然会越发觉得知识海洋的浩瀚无垠。庄子有云，吾生也有涯，而知也无涯。以有涯随无涯，殆已！笔者之前也一直会问，当我学习的速度远远赶不上新知识出现的速度，莫大的悲哀啊。这好像一个 NP 问题，而笔者自我解决的办法就是建立一个合理的健壮的知识体系，这样我虽然记不住或者没时间深入研究很多东西，但是至少可以把它们放到合适的地方，可以借鉴笔者的&lt;a href="">&lt;/a>。笔者自己目前最主要的信息来源主要是 5 个信息聚合的站点：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://medium.com/@swissspidy/how-to-be-a-successful-software-engineer-dfc3f9e63462#.vii2llqfp" target="_blank" rel="noopener">Medium&lt;/a>:你可以在 Medium 上订阅一些 Tags 或者 Publication 或者 Following Users，笔者自己感觉这个的整个质量和粮草比例最高。不过缺陷是要上这个得自带梯子。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.reddit.com/" target="_blank" rel="noopener">Reddit&lt;/a>:可以订阅譬如 web_dev 等等感兴趣的 subreddit，经常会看到不错的文章与分享。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.infoq.com/cn/" target="_blank" rel="noopener">InfoQ&lt;/a>:挺不错的，经常出现精品，但是也有不少文章感觉太过于阳春白雪。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://toutiao.io/u/142222/subjects" target="_blank" rel="noopener">开发者头条&lt;/a>:笔者一般只会看推荐的头条精选等，还是有很多不错的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>仅笔者自己感觉，如果想成为一名了解前沿的开发者，还是需要多关注 Medium 与 Reddit，整体而言中文咨询的活跃度与质量还是略有差距。其他的譬如 CSDN 每个月的程序员杂志与 InfoQ 的架构师质量也都非常高。&lt;/p>
&lt;/blockquote>
&lt;h1 id="communication-skills沟通技巧">Communication Skills:沟通技巧&lt;/h1>
&lt;p>Dirkjan 与 Carmen 讨论了 Github 的工作氛围以及它们是怎么基于高效的通信来保证工作顺利进行。实际上，沟通能力也是一个至关重要的技巧。譬如，大部分在 Github 上的团队都散布四方，甚至于都不一定有两个雇员在一个城市。并且不同成员之间习惯的沟通方式也大相径庭，有的人喜欢用 Slack，而有的人喜欢用 Issue 或者 Pull 这种方式。因此，如果你也是远程工作并且沟通方式不一致，那么你应该及时记录你说了啥以及和他人达成的一些协议。&lt;/p>
&lt;p>&lt;strong>You don’t want to be known as the guy who writes bad commit messages.你肯定不想成为天天写错误的提交信息的人&lt;/strong>&lt;/p>
&lt;p>你要能够让别人知道你已经理解了他们的问题并且能够合适的表达自己。尽可能地遵循公司统一的 Workflow，如果要和新的伙伴合作，一定要多做些预研。我挺喜欢 Github 的工作方式的，即使你在一间办公室里也不会天天让你开会，不过会基于 Pull 与 Issues 来进行异步的会议。这种方式会让新人不可避免地爱上它。&lt;/p>
&lt;h1 id="do-not-ask-for-work不要等着别人分你分配工作">Do not Ask for Work:不要等着别人分你分配工作&lt;/h1>
&lt;blockquote>
&lt;p>笔者也觉得，搬砖和设计之间的一个很大区别就是会不会自己去划分乃至于发现潜在的任务&lt;/p>
&lt;/blockquote>
&lt;p>我第一次进行远程工作的时候就发现主动性非常重要，工作并不会主动找上门来，就像上帝重不垂青无准备之人。有时候当你发现了问题的时候，并不意味着你的领导也看到了并且会主动让你去修复。这个道理在 FaceBook 是这样的：&lt;/p>
&lt;blockquote>
&lt;p>Nothing at &lt;strong>Facebook&lt;/strong> is &lt;strong>someone else’s problem.&lt;/strong>:Facebook 里，你的问题不一定是别人的问题&lt;/p>
&lt;/blockquote>
&lt;p>把这个认知结合到远程工作中，更不会像传统的办公室里还有人天天盯着你，你主动参与更加重要，这也是你的责任之一：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://7xi5sw.com1.z0.glb.clouddn.com/1-g-xIJKP25SLytKx_re8MRg.jpeg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="take-your-time-to-think留点时间思考">Take Your Time to Think:留点时间思考&lt;/h1>
&lt;p>Basecamp 的 CEO Jason Fried 提到他非常担心现在人们越来越充满压力，像个机器人一样工作。这点也引起了我的自省，我上一次主动思考是在啥时候？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://7xi5sw.com1.z0.glb.clouddn.com/1-ioZgc6wGQotwNxQbSk9vcA.jpeg" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>Fried 建议是不要老在一个地方工作或者每天走走来让你从正在做的事情里暂时抽身出来，多思考思考 how、why、when。很多时候创意就来自于这短短的思考过程，而不会来源于你的朝九晚五。更重要的是，这个对你的身体和精神都很重要哦。&lt;/p>
&lt;h1 id="contribute-to-open-source-software贡献开源社区">Contribute to Open Source Software:贡献开源社区&lt;/h1>
&lt;blockquote>
&lt;p>笔者一直认为，与传统的简历相比，博客与开源项目更能展示你&lt;/p>
&lt;/blockquote>
&lt;p>本次讨论有个主题是&lt;a href="https://speakerdeck.com/swissspidy/from-blogger-to-wordpress-core-committer" target="_blank" rel="noopener">I’ve been advocating myself&lt;/a>，关于贡献开源社区的好处。你不能仅仅因为贡献开源项目会让你的 Github 资料好看就去做，而应该是真的出于你的兴趣。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://7xi5sw.com1.z0.glb.clouddn.com/1-AFF-qyL6gxjtVL-x78x8Tg.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>在反馈给他人和 review 它们的贡献的时候，不仅能增加你自己的编程技巧，还能增加你的远程工作能力与沟通技巧。&lt;/p>
&lt;h1 id="final-notes">Final Notes&lt;/h1>
&lt;blockquote>
&lt;p>Just do it.&lt;/p>
&lt;/blockquote></description></item><item><title>熊写代码这三年： 阅读写作与技术成长</title><link>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/%E7%86%8A%E5%86%99%E4%BB%A3%E7%A0%81%E8%BF%99%E4%B8%89%E5%B9%B4-%E9%98%85%E8%AF%BB%E5%86%99%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/developer-zero-to-mastery/%E6%9F%90%E7%86%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/2015/%E7%86%8A%E5%86%99%E4%BB%A3%E7%A0%81%E8%BF%99%E4%B8%89%E5%B9%B4-%E9%98%85%E8%AF%BB%E5%86%99%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/</guid><description>&lt;blockquote>
&lt;p>本文是非技术向的随笔，慎点！&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/25191664" target="_blank" rel="noopener">熊写代码这三年：阅读写作与技术成长&lt;/a> 从属于 &lt;a href="https://github.com/wx-chevalier/Coder-Knowledge-Graph/tree/master/I-AM-Coder" target="_blank" rel="noopener">程序熊的自我修养&lt;/a>系列。临近毕业，随手写了篇随笔，聊以纪念我过去研究生三年间的技术之路，感谢陪伴我这三年的家人，感谢所有陪我一起打拼过的战友，感谢所有阅读过我文章的陌生人。&lt;/li>
&lt;/ul>
&lt;p>本文是一篇种田流水文，希望以平淡的笔触记录笔者这三年的成长。本文整体大概会包括自我定位、阅读、写作、知识殿堂这几个部分，为了避免过于正式就不分章节了。&lt;/p>
&lt;p>笔者的第一份工作从大三开始，在南京某家安全公司从事安全培训与渗透平台开发，兼职做做讲师；老实说肚子里没几滴墨水却要对着台下数百听众，搜肠刮肚地忽悠他们，很锻炼面皮啊。后来某个来头不小的二代找我说一起创业吧，他想颠覆世界，问我敢不敢一起。于是我就拉着身边的兄弟走了出来，很感谢我的两个舍友那些年里给我的支持与包容，容忍了我做的那些傻逼的事情。现在想起来，我还挺佩服 CEO 勇气的，竟敢找我来创业，真的是年轻啊。那个时候经常逛的是以 DZone 为代表的这类网站，并非说它们不好，不过确实太多的标题党，动辄新一代产品或者性能提升 100%。那时的我太过年轻，才从农村出来尚不知城市套路深，轻信了这些标题党，当然根本原因还是我们毫无经验，结果两个月的时间开发出来的 Hybrid APP 启动时间 20 多秒；当时我还一脸无法理解为什么 CEO 会露出绝望的眼神，毕竟之前参加某软件大赛的作品启动要将近两分钟还得到了好评。经历了技术波折之后我们老老实实回到了原生开发，接下来的一年多时间我技术上不一定成长多少，市面却是见了不少，充分认识到关系不是万能的、产品经理是必须的、需求是不能随便变的、领导的话是不能轻易相信的等等等等。后来，公司黄了，一分钱没赚到。后来，我参与到其他的创业当中，满怀热情，也看着那些年的冬日里熄灭的火苗。次数多了，也就不会痛了，印象比较深刻地还参与过某在线婚庆创业，某 3D 打印创业等等，直至现在有时候会去妹子所在的某建筑行业软件服务公司帮帮忙。如今公司招人，我引以为豪地能拿出来讲夸公司的一大优点就是，我们公司有稳定收入，不会吃了上顿没下顿，不会一朝入冬。想想走过的路，有两个自己打自己脸啪啪响的典型，一个是大二的时候推崇底层开发，裸写机器码，觉得 Web 不过是套模板的毫无前途的活计；另一个是跟运营商接触多了觉得传统软件行业里都是观念陈旧的老技术、毫无创新理念与创新动力。然后我现在主要依托于 Web 技术栈，在于政府合作的建筑投标软件行业里混饭吃。这三年走过大江南北，到过万里之外，见过异域风情，写过数百万字，赚到数十万元。印象最深的是爱人相伴，友人相随，笑过哭过，也有后悔。&lt;/p>
&lt;p>笔者啰啰嗦嗦这么多，想表述的不过是认识你自己。天地不仁，万物刍狗，我们要相信勤奋是会有回报的；念念不忘，必有回响，连机器都能通过大量学习优化模型，何况智人乎？笔者是早产儿，七个月的时候出生，差一点就不能跟这个世界说你好。从小略显愚笨，弱于常人，就像笔者对于数学心有畏惧，这么些年一直没学好算法结构与机器学习。笔者也没有过人的毅力与执着的态度，到现在也没能真正的好好锻炼过，也没能如预期般学完一个课程或者看完一本书。更多的时候我是想着怎么跟自己妥协，寻找到真正能够完成的，精神与肉体上都能接受的方案。另外在将技术相关的东西之前，笔者还是希望读者能认清自己的定位，不是说一定要怀着莫大的热情才能进入 IT 领域，而是尽可能地找到自己的定位。我觉得很好的例子就是我夫人，当年也是在某外包公司做嵌入式码农，每天工作都是痛苦万分；后来慢慢地摸索，发掘了她某个最大的优势：以轻微的强迫症去做产品经理，女生特有的细心与品质决定了她能更好地去催促程序员赶进度。现在她同时实现了自我价值与集体价值，成为了公司运转的核心之一。知前路之漫漫，敢披荆而斩棘，相信大家都能找到合适自己的位置。&lt;/p>
&lt;p>化学中的放射性元素往往有所谓半衰期的概念，即某种特定物质的浓度经过某种反应降低到剩下初始时一半所消耗的时间。同理，知识的半衰期则是用于衡量知识的价值随着时间流逝它消失的速度。相对变更较慢的医学知识的半衰期约 45 年，物理学知识的半衰期是 10 年，而计算机知识的半衰期可能只有两年，一直在激烈变化的互联网领域知识可能只有几个月。沉舟侧畔千帆过，就像笔者在&lt;a href="https://zhuanlan.zhihu.com/p/25435411" target="_blank" rel="noopener">怀着被抛弃的恐惧在奋斗中前行&lt;/a>描述的，鱼与熊掌不可兼得，放弃安逸的铁饭碗而进入竞争激烈的 IT 行业，势必会被后来者超越的，我们只有不断修修打打自己，才能不被这个时代所抛弃。古语有云，开卷有益，对于笔者的阅读相关可以参考&lt;a href="https://zhuanlan.zhihu.com/p/25191664" target="_blank" rel="noopener">某熊的阅读与写作日常&lt;/a> ，这里不作赘述。不过回望自己的阅读流程，我最初是从刷推酷的每日推荐开始，大概每天能看数百篇，选出有价值的放到 Pocket 里面留待后看。后来慢慢的发现每天刷的列表里面仅有两三篇会被留存下来，慢慢的就转向了 Reddit、HackerNews、Medium 这些；老实说笔者并非崇洋媚外，不过目前来看中国的社区相对整个世界还是一汪浅水，所以我默默地把公司默认搜索引擎设置成了 Google。在成长之初碎片化的阅读很有益处，虽然会感觉很痛苦，仿佛被强行填食的鸭子，但是如破茧而出，帮你打开广阔的世界。笔者现在逐步的有强迫自己去看书，虽然有时候跟看文章一样一目十行，蜻蜓点水，但是不得不承认书和论文里成体系的描述介绍不是碎片化的文章所能给予的。这里推荐笔者前一阵子收集的&lt;a href="https://zhuanlan.zhihu.com/p/25642783" target="_blank" rel="noopener">追求技术之上的进阶阅读学习索引&lt;/a>与&lt;a href="https://zhuanlan.zhihu.com/p/25612011" target="_blank" rel="noopener">机器学习、深度学习与自然语言处理领域推荐的书籍列表&lt;/a>。&lt;/p>
&lt;p>文以载道，歌以咏志。当我们阅读积累到了，自然就会形成自己的想法，并且想对这个世界说出来。笔者的写作分为两步，首先是做笔记，而后是写文章，厚积薄发，切不能强求。笔者最初做笔记的时候，很多朋友会质疑，记录的笔记真的会去看吗？是不是记录之后就能记住了？答案自然是否定的，笔者一直以来鼓励自己做笔记的动力并不是让自己不会遗忘，而是希望在下一次需要的时候能够以最快的速度学习让自己回忆起之前的东西。笔者发现身边很多人的学习能力并不弱，但是技术能力难以进步突破的问题却是在于永远都在重复学习，譬如笔者团队中秉持岗位轮换的原则，可能做几个月的服务端再轮换做一些简单的前端，但是每次都需要重新学习，看不出什么进步。罗曼罗兰说过，多数人二十或三十多岁已经死了，他们变成自己的影子，不断重复以前的自己。有时候我们的笔记会是我们生命存在的痕迹，让你能够记得自己走过的路，踩过的坑。笔者现在大概分门别类地有两千多篇笔记，断断续续地写了二百多篇文章；并不是说没有积累就不能写作，而是你没有积累很难去进行长时间的持续地写作。写文章本身不仅是让你的思想曝光于世，让别人帮你发现自己的不足；还是很好的打造个人品牌，增加自己社区影响力的好方法。&lt;/p>
&lt;p>如果你是前端新人或者技术新人，很建议从尝试翻译开始；InfoQ 网站包括其架构师月刊等一直是我认为国内质量比较高的资讯来源之一，年后也有幸成为了其社区编辑。我发现他们有个很不错的任务领取与报酬机制，如果你希望相互督促，也能转点零花钱，那么可以尝试加入这个大社区，跟着大家一起前行。&lt;/p>
&lt;p>记得包法利夫人里面有一句总结，浅薄且不甘平庸是最大的原罪；而在技术之路上，在没有知识体系的情况下，学习的知识都是相互独立，难以互相借鉴，举一反三，阅读也不过是春风拂面，一掠而过，不留痕迹，知识也就难以真正的沉淀下来。笔者非常支持认可碎片化学习的思想，但是否定在没有知识体系的情况下盲目的碎片化学习。特别是对于尚未建立基础知识体系与认知能力的同学，如果突发性地吸收过多的知识，反而会摧毁自己的认知能力。就好像传说中的吸星大法，乱吸的后果就是体内真气斑驳不堪，最终走火入魔，爆体而亡。因此我们必须要建立自己的知识体系与思维宫殿，梭罗在《瓦尔登湖》中写道：知道自己知道什么，也知道自己不知道什么，这就是真正的知识。知我所知是对于自己能力的正确认识，知我所不知则能为自己未来的路明确些方向。笔者关于自己的对于软件世界的认知写在了&lt;a href="https://zhuanlan.zhihu.com/p/24476917" target="_blank" rel="noopener">2016-我的技术之路：编程知识体系结构图&lt;/a>里。Program into Your Language, Not in It.&lt;/p>
&lt;p>前端工程化这个词一直很火，笔者在&lt;a href="https://zhuanlan.zhihu.com/p/24575395" target="_blank" rel="noopener">2016-我的前端之路:工具化与工程化&lt;/a>、&lt;a href="https://segmentfault.com/a/1190000004292245" target="_blank" rel="noopener">2015-我的前端之路:数据流驱动的界面&lt;/a> 这两篇年度总结里都有详细的不成熟的自我思想的介绍。记得面试腾讯的时候面试官问道你这么激进地使用现代语法，使用 Babel 然后导致包体增倍怎么能兼顾老旧浏览器或者带宽上不是很好的地方的用户呢？我默默想起了现在公司碰到的一个有趣的事件，我们做的某个投标工具(Web &amp;amp; Electron)对于浏览器或者系统有较高要求，但是政府客户典型的标配 XP 与 IE。我们思考了好久如何去达成兼容性，最后欧了一波笔记本电脑跟软件产品打包发售，还额外赚了一笔的说。工程做久了，有时候会发现自己陷入到某种瓶颈。本节可能过于主观了，对于我们所熟知的云计算与大数据、服务端应用程序架构(API、微服务与高可用等)、基础架构(数据存储、虚拟化、分布式系统与集群计算等)等等偏工程的进阶之路，老实说并不是螺丝钉们所能轻易实践的。笔者之前一直感慨于混迹在小公司之间，所谓大数据不过镜花水月，很难真正有实践的场景。除了工程向的进阶之外，笔者个人主观感觉还有两个偏理论的进阶向，即使不能有所实际成就也能提升个人品味的方向，一个是偏向于数据学科与人工智能，包括机器学习、深度学习、自然语言处理等等；另一个是偏向编程语言原理、计算机系统基础理论、数据库系统基础理论的方向。笔者本科的时候发了四五篇文章，遗憾的是在南大的三年未能投身学术，一文未发，愧对师长。有时候看着其他同学仰望星空，自己只能默默在沼泽地里蹒跚前行。&lt;/p>
&lt;p>本文最后，笔者还是想对于所有阅读过我的文章的朋友说声谢谢，你们的支持是我前行的动力，希望在未来的岁月里我能够继续完善我的知识体系中的内容，也希望能够帮助到所有花时间阅读我文章的人。诚如罗胖所说，未来的世界是时间的战场，愿意花时间阅读的朋友本身也是一种付出。笔者这些年来一直笔耕不缀，不过写的绝大部分都是属于某个领域中某个技术细节的介绍与实践总结，借这篇随笔之际，笔者也是打算以随笔的方式，描述自己对于编程的认知、感悟、猜想，因为这个系列更多的是非技术性的思考，希望能得到真正的大家指导，与其他人思维碰撞。笔者不敢取名为程序员的自我修养，毕竟笔者自己都不知道自己是否称得上合格的程序员，因此取名为程序熊的自我修养。【&lt;a href="http://6me.us/JltQ8" target="_blank" rel="noopener">程序熊的自我修养&lt;/a>】系列拟会包含以下部分：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>【程序熊的自我修养】知识体系与自我定位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>【程序熊的自我修养】阅读与积累&lt;/p>
&lt;/li>
&lt;li>
&lt;p>【程序熊的自我修养】工具与实战&lt;/p>
&lt;/li>
&lt;li>
&lt;p>【程序熊的自我修养】产品与工程化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>【程序熊的自我修养】编程之道：编程语言、数据结构与算法、编程范式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>【程序熊的自我修养】Web 前端&lt;/p>
&lt;/li>
&lt;li>
&lt;p>【程序熊的自我修养】服务端应用程序架构&lt;/p>
&lt;/li>
&lt;li>
&lt;p>【程序熊的自我修养】数据科学与人工智能&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>