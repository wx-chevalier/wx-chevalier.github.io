<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>npm | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/</link><atom:link href="https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/index.xml" rel="self" type="application/rss+xml"/><description>npm</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>npm</title><link>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/</link></image><item><title>Npm</title><link>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/npm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/npm/</guid><description>&lt;h1 id="npm">Npm&lt;/h1>
&lt;h1 id="npx">npx&lt;/h1>
&lt;p>近日发布的 npm 5.2.0 版本中内置了伴生命令：npx，类似于 npm 简化了项目开发中的依赖安装与管理，该工具致力于提升开发者使用包提供的命令行的体验。npx 允许我们使用本地安装的命令行工具而不需要再定义 npm run-script，并且允许我们仅执行一次脚本而不需要再将其实际安装到本地；同时 npx 还允许我们以不同的 node 版本来运行指定命令、允许我们交互式地开发 node 命令行工具以及便捷地安装来自于 gist 的脚本。&lt;/p>
&lt;p>在传统的命令执行中，我们需要将工具添加到 package.json 的 &lt;code>scripts&lt;/code> 配置中，这种方式还需要我们以 &lt;code>--&lt;/code> 方式传递参数；我们也可以使用 &lt;code>alias npmx=PATH=$(npm bin):$PATH,&lt;/code> 或者 &lt;code>./node_modules/.bin/mocha&lt;/code> 方式来执行命令，虽然都能达到目标，但不免繁杂了许多。而 npx 允许我们以 &lt;code>npx mocha&lt;/code> 这样的方式直接运行本地安装的 mocha 命令。&lt;/p>
&lt;p>完整的 npx 命令提示如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">从 npm 的可执行包执行命令
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  npx &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;命令&amp;gt;&lt;span class="o">[&lt;/span>@版本&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>命令的参数&lt;span class="o">]&lt;/span>...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  npx &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-p&lt;span class="p">|&lt;/span>--package &amp;lt;包&amp;gt;&lt;span class="o">]&lt;/span>... &amp;lt;命令&amp;gt; &lt;span class="o">[&lt;/span>命令的参数&lt;span class="o">]&lt;/span>...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  npx &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> -c &lt;span class="s1">&amp;#39;&amp;lt;命令的字符串&amp;gt;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  npx --shell-auto-fallback &lt;span class="o">[&lt;/span>命令行解释器&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">选项：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --package, -p包安装的路径 &lt;span class="o">[&lt;/span>字符串&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --cachenpm 缓存路径 &lt;span class="o">[&lt;/span>字符串&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --install如果有包缺失，跳过安装&lt;span class="o">[&lt;/span>布尔&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>默认值: true&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --userconfig 当前用户的 npmrc 路径&lt;span class="o">[&lt;/span>字符串&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --call, -c 像执行 &lt;span class="sb">`&lt;/span>npm run-script&lt;span class="sb">`&lt;/span> 一样执行一个字符串 &lt;span class="o">[&lt;/span>字符串&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --shell, -s执行命令用到的解释器，可选 &lt;span class="o">[&lt;/span>字符串&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>默认值: false&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --shell-auto-fallback产生“找不到命令”的错误码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  &lt;span class="o">[&lt;/span>字符串&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>可选值: &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;bash&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;fish&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;zsh&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --ignore-existing忽略 &lt;span class="nv">$PATH&lt;/span> 或工程里已有的可执行文件，这会强制使 npx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 临时安装一次，并且使用其最新的版本 &lt;span class="o">[&lt;/span>布尔&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --quiet, -q隐藏 npx 的输出，子命令不会受到影响&lt;span class="o">[&lt;/span>布尔&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --npm为了执行内部操作的 npm 可执行文件 &lt;span class="o">[&lt;/span>字符串&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>默认值:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;/Users/apple/.nvm/versions/node/v8.1.3/lib/node_modules/npm/bin/npm-cli.js&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --version, -v显示版本号 &lt;span class="o">[&lt;/span>布尔&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  --help, -h 显示帮助信息 &lt;span class="o">[&lt;/span>布尔&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>npx 还允许我们单次执行命令而不需要安装；在某些场景下有可能我们安装了某个全局命令行工具之后一直忘了更新，导致以后使用的时候误用了老版本。而使用 &lt;code>npx create-react-app my-cool-new-app&lt;/code> 来执行 create-react-app 命令时，它会正常地帮我们创建 React 应用而不会实际安装 create-react-app 命令行。
我们还可以使用类似于 &lt;code>$ npx -p node-bin@6 npm it&lt;/code> 的格式来指定 Node 版本，或者使用 &lt;code>npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32&lt;/code> 方式直接运行来自于 Gist 的脚本。&lt;/p>
&lt;h1 id="运行小技巧">运行小技巧&lt;/h1>
&lt;h2 id="多个任务并发执行">多个任务并发执行&lt;/h2>
&lt;p>我们可以利用 concurrently 库来并发执行多个任务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ npm i concurrently --save-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在 Npm 脚本中使用 concurrent 来运行多个命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;dev&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;concurrently --kill-others \&amp;#34;npm run start-watch\&amp;#34; \&amp;#34;npm run wp-server\&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>模块系统</title><link>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="nodejs-modules">NodeJS Modules&lt;/h1>
&lt;h1 id="moduleexports--exports">module.exports &amp;amp; exports&lt;/h1>
&lt;p>我们可以将&lt;code>module.exports&lt;/code>看做&lt;code>require()&lt;/code>的返回值，默认情况下是一个空对象，并且可以被设置为任意的值。而&lt;code>exports&lt;/code>则是对于&lt;code>module.exports&lt;/code>的引用，来减少开发者的代码量。其基本用法如下所示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">exports&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">method&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">…&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">module&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exports&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">method&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="err">…&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在具体的使用中，譬如我们在&lt;code>calculator.js&lt;/code>文件中添加了&lt;code>add&lt;/code>函数，在需要将其导出时，可以进行如下导出&lt;/p>
&lt;pre tabindex="0">&lt;code>// calculator.js
module.exports.add = (a,b) =&amp;gt; a+b
&lt;/code>&lt;/pre>&lt;p>而在使用时&lt;/p>
&lt;pre tabindex="0">&lt;code>// app-use-calculator.js
const calculator = require(&amp;#39;./calculator.js&amp;#39;)
console.log(calculator.add(2,2)) // prints 4
&lt;/code>&lt;/pre>&lt;h1 id="模块搜索顺序">模块搜索顺序&lt;/h1>
&lt;pre tabindex="0">&lt;code>require(X) from module at path Y
1. If X is a core module,
a. return the core module
b. STOP
2. If X begins with &amp;#39;./&amp;#39; or &amp;#39;/&amp;#39; or &amp;#39;../&amp;#39;
a. LOAD_AS_FILE(Y + X)
b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &amp;#34;not found&amp;#34;
LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text. STOP
2. If X.js is a file, load X.js as JavaScript text. STOP
3. If X.json is a file, parse X.json to a JavaScript Object. STOP
4. If X.node is a file, load X.node as binary addon. STOP
LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
a. Parse X/package.json, and look for &amp;#34;main&amp;#34; field.
b. let M = X + (json main field)
c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text. STOP
3. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
4. If X/index.node is a file, load X/index.node as binary addon. STOP
LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
a. LOAD_AS_FILE(DIR/X)
b. LOAD_AS_DIRECTORY(DIR/X)
NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = []
4. while I &amp;gt;= 0,
a. if PARTS[I] = &amp;#34;node_modules&amp;#34; CONTINUE
c. DIR = path join(PARTS[0 .. I] + &amp;#34;node_modules&amp;#34;)
b. DIRS = DIRS + DIR
c. let I = I - 1
5. return DIRS
&lt;/code>&lt;/pre>&lt;p>笔者之前在使用 require 导入模块时，特别是在导入有状态的模块时，笔者会考虑其是否在多次导入情况下依然保持单例特性，或者说对于同一个文件在不同路径下导入时，是否能够识别为一致？本文即是对该特性进行解析。&lt;/p>
&lt;p>NodeJS 的模块默认情况下是单例性质的，不过其并不能保证如我们编程时设想的那样一定是单例，根据 NodeJS 的官方文档中描述，某个模块导入是否为单例受以下两个因素的影响:&lt;/p>
&lt;ul>
&lt;li>Node 模块的缓存机制是大小写敏感的，譬如如果你&lt;code>require('/foo')&lt;/code>与&lt;code>require('/FOO')&lt;/code>会返回两个不同的对象，尽管你的 foo 与 FOO 是完全相同的文件。&lt;/li>
&lt;li>模块是基于其被解析得到的文件名进行缓存的，鉴于不同的模块会依赖于其被调用的路径进行缓存鉴别，因此并不能保证你使用&lt;code>require('foo')&lt;/code>会永远返回相同的对象，可能会根据不同的文件路径得到不同的对象。&lt;/li>
&lt;/ul>
&lt;h1 id="创建新的-nodejs-模块">创建新的 NodeJS 模块&lt;/h1>
&lt;p>根据 NodeJS 文档所述，文件和模块是一一对应的关系。这个也是解释上文提及的模块缓存机制的基础，我们首先创建一个简单的模块:&lt;/p>
&lt;pre tabindex="0">&lt;code>// counter.js
let value = 0
module.exports = {
increment: () =&amp;gt; value++,
get: () =&amp;gt; value,
}
&lt;/code>&lt;/pre>&lt;p>在 counter.js 中我们创建了某个私有变量，并且只能通过公共的 increment 与 get 方法进行操作。在应用中我们可以如下方法使用该模块:&lt;/p>
&lt;pre tabindex="0">&lt;code>// app.js
const counter = require(‘./counter.js’)
counter.increment()
counter.increment()
console.log(counter.get()) // prints 2
console.log(counter.value) // prints undefined as value is private
&lt;/code>&lt;/pre>&lt;h1 id="module-caching">Module Caching&lt;/h1>
&lt;p>NodeJS 会在第一次导入某个模块之后将该模块进行缓存，在官方文档中有如下描述:&lt;/p>
&lt;blockquote>
&lt;p>Every call to require(‘foo’) will get exactly the same object returned, if it would resolve to the same file.&lt;/p>
&lt;/blockquote>
&lt;p>我们也可以通过如下简单的例子来验证这句话:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// app-singleton.js
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">counter1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">‘&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">counter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">js&lt;/span>&lt;span class="err">’&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">counter2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">‘&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">counter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">js&lt;/span>&lt;span class="err">’&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">counter1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">increment&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">counter1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">increment&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">counter2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">increment&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">counter1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">// prints 3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">counter2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">// also prints 3
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出尽管我们两次导入了该模块，但是还是指向了同一个对象。不过并不是每次我们导入同一个模块时，都会得到相同的对象。在 NodeJS 中，模块对象有个内置的方法:Module._resolveFilename()，其负责寻找 require 中合适的模块，在找到正确的文件之后，会根据其文件名作为缓存的键名。官方的搜索算法伪代码为:&lt;/p>
&lt;pre tabindex="0">&lt;code>require(X) from module at path Y
1. If X is a core module,
a. return the core module
b. STOP
2. If X begins with &amp;#39;./&amp;#39; or &amp;#39;/&amp;#39; or &amp;#39;../&amp;#39;
a. LOAD_AS_FILE(Y + X)
1. If X is a file, load X as JavaScript text. STOP
2. If X.js is a file, load X.js as JavaScript text. STOP
3...
4...
b. LOAD_AS_DIRECTORY(Y + X)
1. If X/package.json is a file,
a. Parse X/package.json, and look for &amp;#34;main&amp;#34; field.
b. let M = X + (json main field)
c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JS text. STOP
3...
4...
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &amp;#34;not found&amp;#34;
&lt;/code>&lt;/pre>&lt;p>简单来说，加载的逻辑或者说优先级为:&lt;/p>
&lt;ul>
&lt;li>优先判断是不是核心模块&lt;/li>
&lt;li>如果不是核心模块则搜索 node_modules&lt;/li>
&lt;li>否则在相对路径中进行搜索&lt;/li>
&lt;/ul>
&lt;p>解析之后的文件名可以根据 module 对象或得到:&lt;/p>
&lt;pre tabindex="0">&lt;code>// counter-debug.js
console.log(module.filename) // prints absolute path to counter.js
console.log(__filename) // prints same as above
// i get: &amp;#34;/Users/laz/repos/medium/modules/counter-debug.js&amp;#34;
let value = 0
module.exports = {
increment: () =&amp;gt; value++,
get: () =&amp;gt; value,
&lt;/code>&lt;/pre>&lt;p>在上述的例子中我们可以看出，解析得到的文件名即使被加载模块的绝对路径。而根据文件与模块一一映射的原则，我们可以得出下面两个会破坏模块导入单例性的特例。&lt;/p>
&lt;h2 id="case-sensitivity">Case Sensitivity&lt;/h2>
&lt;p>在大小写敏感的文件系统中或者操作系统中，不同的解析之后的文件可能会指向相同的文件，但是其缓存键名会不一致，即不同的导入会生成不同的对象。&lt;/p>
&lt;pre tabindex="0">&lt;code>// app-no-singleton-1.js
const counter1 = require(&amp;#39;./counter.js&amp;#39;)
const counter2 = require(&amp;#39;./COUNTER.js&amp;#39;)
counter1.increment()
console.log(counter1.get()) // prints 1
console.log(counter2.get()) // prints 0, not same object as counter1
/*
We have two different resolved filenames:
- “Users/laz/repos/medium/modules/counter.js”
- “Users/laz/repos/medium/modules/COUNTER.js”
*/
&lt;/code>&lt;/pre>&lt;p>在上面的例子中，我们分别用&lt;code>counter&lt;/code>、&lt;code>COUNTER&lt;/code>这仅仅是大小写不同的方式导入相同的某个文件，如果是在某个大小写敏感的系统中，譬如 UBUNTU 中会直接抛出异常:&lt;/p>
&lt;h2 id="解析为不同的文件名">解析为不同的文件名&lt;/h2>
&lt;p>当我们使用&lt;code>require(x)&lt;/code>并且 x 不属于核心模块时，其会自动搜索&lt;code>node_modules&lt;/code>文件夹。而在 npm3 之前，项目会以嵌套的方式安装依赖。因此当我们的项目依赖 module-a 与 module-b，并且 module-a 与 module-b 也相互依赖时，其会生成如下文件路径格式:&lt;/p>
&lt;pre tabindex="0">&lt;code>// npm2 installed dependencies in nested way
app.js
package.json
node_modules/
|---module-a/index.js
|---module-b/index.js
|---node_modules
|---module-a/index.js
&lt;/code>&lt;/pre>&lt;p>这样的话，我们对于同一个模块就有两个副本，那当我们在应用中导入 module-a 时，岂会载入如下文件:&lt;/p>
&lt;pre tabindex="0">&lt;code> // app.js
const moduleA = require(‘module-a’)
loads: “/node_modules/module-a/index.js”
&lt;/code>&lt;/pre>&lt;p>而从 module-b 中载入 module-a 时，其载入的是如下文件:&lt;/p>
&lt;pre tabindex="0">&lt;code> // /node_modules/module-b/index.js
const moduleA = require(‘module-a’)
loads “/node_modules/module-b/node_modules/module-a/index.js”
&lt;/code>&lt;/pre>&lt;p>不过在 npm3 之后，其以扁平化方式进行文件加载，其文件目录结构如下所示:&lt;/p>
&lt;pre tabindex="0">&lt;code> // npm3 flattens secondary dependencies by installing in same folder
app.js
package.json
node_modules/
|---module-a/index.js
|---module-b/index.js
&lt;/code>&lt;/pre>&lt;p>不过此时就存在另一个场景，即我们应用本身依赖 &lt;a href="mailto:module-a@v1.1">module-a@v1.1&lt;/a> 与 module-b，而 module-b 又依赖于 &lt;a href="mailto:module-a@v1.2">module-a@v1.2&lt;/a>，在这种情况下还是会采用类似于 npm3 之前的嵌套式目录结构。这样的话对于 module-a 一样会产生不同的对象，不过此时本身就是不同的文件了，因此相互之间不会产生冲突。&lt;/p></description></item><item><title>依赖管理</title><link>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/node-notes/01.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/npm/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="依赖管理">依赖管理&lt;/h1>
&lt;h1 id="peerdependencies">peerDependencies&lt;/h1>
&lt;h2 id="引言">引言&lt;/h2>
&lt;p>想必前端同学对 npm 的 devDependencies 和 dependencies 都比较熟悉，但是对 peerDependencies 可能就有点陌生，尤其是没有写过 npm 包插件的同学，比如之前使用 grunt 自动化工具的相关插件（如 grunt-contrib-jasmine 等）或者目前基于某个框架的 ui 组件库等等，这些都是需要对 peerDependencies 有一定了解的。下面我们就来说说 peerDependencies。&lt;/p>
&lt;h2 id="npm2-中-dependencies-与-peerdependencies-区别">npm2 中 dependencies 与 peerDependencies 区别&lt;/h2>
&lt;p>假设我们当前的项目是 MyProject，项目中有一些依赖，比方其中有一个依赖包&lt;strong>PackageA&lt;/strong>，该包的&lt;strong>package.json&lt;/strong>文件指定了对&lt;strong>PackageB&lt;/strong>的依赖：&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;dependencies&amp;#34;: {
&amp;#34;PackageB&amp;#34;: &amp;#34;1.0.0&amp;#34;
}
}
&lt;/code>&lt;/pre>&lt;p>如果我们在我们的 MyProject 项目中执行&lt;code>npm install PackageA&lt;/code>, 我们会发现我们项目的目录结构会是如下形式：&lt;/p>
&lt;pre tabindex="0">&lt;code>MyProject
|- node_modules
|- PackageA
|- node_modules
|- PackageB
&lt;/code>&lt;/pre>&lt;p>那么在我们的项目中，我们能通过下面语句引入&amp;quot;PackageA&amp;quot;：&lt;/p>
&lt;pre tabindex="0">&lt;code>var packageA = require(&amp;#39;PackageA&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>但是，如果你想在项目中直接引用 PackageB:&lt;/p>
&lt;pre tabindex="0">&lt;code>var packageA = require(&amp;#39;PackageA&amp;#39;)
var packageB = require(&amp;#39;PackageB&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>这是不行的，即使 PackageB 被安装过；因为 Node 只会在“MyProject/node_modules”目录下查找 PackageB，它不会在进入 PackageA 模块下的 node_modules 下查找。&lt;/p>
&lt;p>所以，为了解决这个问题，在 MyProject 项目 package.json 中我们必须直接声明对 PackageB 的依赖并安装。&lt;/p>
&lt;p>但是，有时我们不用在当前项目中声明对 PackageB 的依赖就可以直接引用，尤其是，PackageA 是一个类似于&lt;strong>grunt&lt;/strong>的插件，例如 grunt-contrib-jshint。&lt;/p>
&lt;p>为什么在项目中不用声明就可以直接使用呢？这就不得不说说 peerDependencies 的作用了。&lt;/p>
&lt;h2 id="peerdependencies-的引入">peerDependencies 的引入&lt;/h2>
&lt;p>为了解决这种问题：&lt;/p>
&lt;pre tabindex="0">&lt;code>如果你安装我，那么你最好也安装X,Y和Z.
&lt;/code>&lt;/pre>&lt;p>于是&lt;code>peerDependencies&lt;/code>就被引入了。例如上面 PackageA 的&lt;strong>package.json&lt;/strong>文件如果是下面这样：&lt;/p>
&lt;pre tabindex="0">&lt;code>{
&amp;#34;peerDependencies&amp;#34;: {
&amp;#34;PackageB&amp;#34;: &amp;#34;1.0.0&amp;#34;
}
}
&lt;/code>&lt;/pre>&lt;p>那么，它会告诉 npm：如果某个 package 把我列为依赖的话，那么那个 package 也必需应该有对 PackageB 的依赖。&lt;/p>
&lt;p>也就是说，如果你&lt;code>npm install PackageA&lt;/code>，你将会得到下面的如下的目录结构：&lt;/p>
&lt;pre tabindex="0">&lt;code>MyProject
|- node_modules
|- PackageA
|- PackageB
&lt;/code>&lt;/pre>&lt;p>你可能注意到：&lt;/p>
&lt;blockquote>
&lt;p>在 npm2 中，即使当前项目 MyProject 中没有直接依赖 PackageB，该 PackageB 包依然会安装到当前项目的 node_modules 文件夹中。&lt;/p>
&lt;/blockquote>
&lt;p>下面的代码现在可以正常工作了，因为两个包在&amp;quot;MyProject/node_modules&amp;quot;中被安装了：&lt;/p>
&lt;pre tabindex="0">&lt;code>var packageA = require(&amp;#39;PackageA&amp;#39;)
var packageB = require(&amp;#39;PackageB&amp;#39;)
&lt;/code>&lt;/pre>&lt;p>总结一句话，&lt;code>peerDependencies&lt;/code>的具体作用：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>peerDependencies&lt;/code>的目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者 require 所依赖的包的时候，永远都是引用宿主环境统一安装的 npm 包，最终解决插件与所依赖包不一致的问题。&lt;/p>
&lt;/blockquote>
&lt;p>举个例子，就拿目前基于 react 的 ui 组件库&lt;strong>&lt;a href="mailto:ant-design@3.x">ant-design@3.x&lt;/a>&lt;/strong>来说，因该 ui 组件库只是提供一套 react 组件库，它要求宿主环境需要安装指定的 react 版本。具体可以看它&lt;a href="https://github.com/ant-design/ant-design/blob/master/package.json#L37" target="_blank" rel="noopener">package.json&lt;/a>中的配置：&lt;/p>
&lt;pre tabindex="0">&lt;code> &amp;#34;peerDependencies&amp;#34;: {
&amp;#34;react&amp;#34;: &amp;#34;&amp;gt;=16.0.0&amp;#34;,
&amp;#34;react-dom&amp;#34;: &amp;#34;&amp;gt;=16.0.0&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>它要求宿主环境安装 react@&amp;gt;=16.0.0 和 react-dom@&amp;gt;=16.0.0 的版本，而在每个 antd 组件的定义文件顶部：&lt;/p>
&lt;pre tabindex="0">&lt;code>import * as React from &amp;#39;react&amp;#39;;
import * as ReactDOM from &amp;#39;react-dom&amp;#39;;
&lt;/code>&lt;/pre>&lt;p>组件中引入的 react 和 react-dom 包其实都是宿主环境提供的依赖包。&lt;/p>
&lt;h2 id="npm2-和-npm3-中-peerdependencies-的区别">npm2 和 npm3 中 peerDependencies 的区别&lt;/h2>
&lt;p>正如上一节谈论的，在 npm2 中，PackageA 包中&lt;code>peerDependencies&lt;/code>所指定的依赖会随着&lt;code>npm install PackageA&lt;/code>一起被强制安装，所以不需要在宿主环境的 package.json 文件中指定对 PackageA 中&lt;code>peerDependencies&lt;/code>内容的依赖。&lt;/p>
&lt;p>但是在 npm3 中，&lt;code>peerDependencies&lt;/code>的表现与 npm2 不同：&lt;/p>
&lt;blockquote>
&lt;p>npm3 中不会再要求 peerDependencies 所指定的依赖包被强制安装，相反 npm3 会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示。&lt;/p>
&lt;/blockquote>
&lt;p>就拿上面的例子来说，如果我们 npm install PackageA 安装 PackageA 时，你会得到一个警告提示说：&lt;/p>
&lt;pre tabindex="0">&lt;code>PackageB是一个需要的依赖，但是没有被安装。
&lt;/code>&lt;/pre>&lt;p>这时，你需要手动的在 MyProject 项目的 package.json 文件指定 PackageB 的依赖。&lt;/p>
&lt;p>另外，在 npm3 的项目中，可能存在一个问题就是你所依赖的一个 package 包更新了它 peerDependencies 的版本，那么你可能也需要在项目的 package.json 文件中手动更新到正确的版本。否则会出现类似下图所示的警告信息：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2019/11/13/MGF5kj.png" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p></description></item></channel></rss>