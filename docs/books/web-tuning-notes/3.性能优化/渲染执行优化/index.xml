<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>渲染执行优化 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/</link><atom:link href="https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><description>渲染执行优化</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>渲染执行优化</title><link>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/</link></image><item><title>布局与渲染策略</title><link>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E5%B8%83%E5%B1%80%E4%B8%8E%E6%B8%B2%E6%9F%93%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E5%B8%83%E5%B1%80%E4%B8%8E%E6%B8%B2%E6%9F%93%E7%AD%96%E7%95%A5/</guid><description>&lt;h1 id="布局与渲染策略">布局与渲染策略&lt;/h1>
&lt;h1 id="布局优化">布局优化&lt;/h1>
&lt;h1 id="virtual-dom">Virtual DOM&lt;/h1>
&lt;h1 id="预加载">预加载&lt;/h1>
&lt;h1 id="懒加载">懒加载&lt;/h1>
&lt;h1 id="按需加载">按需加载&lt;/h1>
&lt;h1 id="分页加载">分页加载&lt;/h1></description></item><item><title>交互与动画</title><link>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%8A%A8%E7%94%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E4%BA%A4%E4%BA%92%E4%B8%8E%E5%8A%A8%E7%94%BB/</guid><description>&lt;h1 id="交互与动画">交互与动画&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">LeashedOne&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">React&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Component&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">props&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">props&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">onChange&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">onChange&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">bind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">onChangeDebounce&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">debounce&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">value&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">props&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">onChange&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">300&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">onChange&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">onChangeDebounce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">render&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">input&lt;/span> &lt;span class="nx">onChange&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">onChange&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="o">/&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="页面帧率-fps">页面帧率 FPS&lt;/h1>
&lt;h1 id="重渲染策略">重渲染策略&lt;/h1></description></item><item><title>脚本解析与执行</title><link>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C/</guid><description>&lt;h1 id="脚本解析与执行">脚本解析与执行&lt;/h1>
&lt;h1 id="javascript-脚本初始化">JavaScript 脚本初始化&lt;/h1>
&lt;h1 id="javascript-函数执行优化">JavaScript 函数执行优化&lt;/h1>
&lt;h2 id="debounce-防抖动">Debounce: 防抖动&lt;/h2>
&lt;h2 id="throttling-限流">Throttling: 限流&lt;/h2>
&lt;h1 id="css-解析与应用">CSS 解析与应用&lt;/h1>
&lt;h1 id="dom-manipulation-optimization-dom-操作优化">DOM Manipulation Optimization: DOM 操作优化&lt;/h1>
&lt;p>随着现代 Web 技术的发展与用户交互复杂度的增加，我们的网站变得日益臃肿，也要求着我们不断地优化网站性能以保证友好的用户体验。本文作者则着眼于 JavaScript 启动阶段优化，首先以大量的数据分析阐述了语法分析、编译等步骤耗时占比过多是很多网站的性能瓶颈之一。然后作者提供了一系列用于在现代浏览器中进行性能评测的工具，还分别从开发者工程实践与 JavaScript 引擎内部实现的角度阐述了应当如何提高解析与编译速度。&lt;/p>
&lt;p>在 Web 开发中，随着需求的增加与代码库的扩张，我们最终发布的 Web 页面也逐渐膨胀。不过这种膨胀远不止意味着占据更多的传输带宽，其还意味着用户浏览网页时可能更差劲的性能体验。浏览器在下载完某个页面依赖的脚本之后，其还需要经过语法分析、解释与运行这些步骤。而本文则会深入分析浏览器对于 JavaScript 的这些处理流程，挖掘出那些影响你应用启动时间的罪魁祸首，并且根据我个人的经验提出相对应的解决方案。回顾过去，我们还没有专门地考虑过如何去优化 JavaScript 解析/编译这些步骤；我们预想中的是解析器在发现&lt;code>&amp;lt;script&amp;gt;&lt;/code>标签后会瞬时完成解析操作，不过这很明显是痴人说梦。下图是对于 V8 引擎工作原理的概述：&lt;/p>
&lt;p>下面我们深入其中的关键步骤进行分析。&lt;/p>
&lt;h1 id="到底是什么拖慢了我们应用的启动时间">到底是什么拖慢了我们应用的启动时间？&lt;/h1>
&lt;p>在启动阶段，语法分析，编译与脚本执行占据了 JavaScript 引擎运行的绝大部分时间。换言之，这些过程造成的延迟会真实地反应到用户可交互时延上；譬如用户已经看到了某个按钮，但是要好几秒之后才能真正地去点击操作，这一点会大大影响用户体验。&lt;/p>
&lt;p>上图是我们使用 Chrome Canary 内置的 V8 RunTime Call Stats 对于某个网站的分析结果；需要注意的是桌面浏览器中语法解析与编译占用的时间还是蛮长的，而在移动端中占用的时间则更长。实际上，对于 Facebook, Wikipedia, Reddit 这些大型网站中语法解析与编译所占的时间也不容忽视：&lt;/p>
&lt;p>上图中的粉色区域表示花费在 V8 与 Blink&amp;rsquo;s C++ 中的时间，而橙色和黄色分别表示语法解析与编译的时间占比。Facebook 的 Sebastian Markbage 与 Google 的 Rob Wormald 也都在 Twitter 发文表示过 JavaScript 的语法解析时间过长已经成为了不可忽视的问题，后者还表示这也是 Angular 启动时主要的消耗之一。&lt;/p>
&lt;p>随着移动端浪潮的涌来，我们不得不面对一个残酷的事实：移动端对于相同包体的解析与编译过程要花费相当于桌面浏览器 2~5 倍的时间。当然，对于高配的 iPhone 或者 Pixel 这样的手机相较于 Moto G4 这样的中配手机表现会好很多；这一点提醒我们在测试的时候不能仅用身边那些高配的手机，而应该中高低配兼顾：&lt;/p>
&lt;p>上图是部分桌面浏览器与移动端浏览器对于 1MB 的 JavaScript 包体进行解析的时间对比，显而易见的可以发现不同配置的移动端手机之间的巨大差异。当我们应用包体已经非常巨大的时候，使用一些现代的打包技巧，譬如代码分割，TreeShaking，Service Workder 缓存等等会对启动时间有很大的影响。另一个角度来看，即使是小模块，你代码写的很糟或者使用了很糟的依赖库都会导致你的主线程花费大量的时间在编译或者冗余的函数调用中。我们必须要清醒地认识到全面评测以挖掘出真正性能瓶颈的重要性。&lt;/p>
&lt;h1 id="javascript-语法解析与编译是否成为了大部分网站的瓶颈">JavaScript 语法解析与编译是否成为了大部分网站的瓶颈？&lt;/h1>
&lt;p>我曾不止一次听到有人说，我又不是 Facebook，你说的 JavaScript 语法解析与编译到底会对其他网站造成什么样的影响呢？对于这个问题我也很好奇，于是我花费了两个月的时间对于超过 6000 个网站进行分析；这些网站囊括了 React，Angular，Ember，Vue 这些流行的框架或者库。大部分的测试是基于 WebPageTest 进行的，因此你可以很方便地重现这些测试结果。&lt;strong>光纤接入的桌面浏览器大概需要 8 秒的时间才能允许用户交互，而 3G 环境下的 Moto G4 大概需要 16 秒 才能允许用户交互。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>大部分应用在桌面浏览器中会耗费约 4 秒的时间进行 JavaScript 启动阶段(语法解析、编译、执行)&lt;/strong>：&lt;/p>
&lt;p>而在移动端浏览器中，大概要花费额外 36% 的时间来进行语法解析：&lt;/p>
&lt;p>另外，统计显示并不是所有的网站都甩给用户一个庞大的 JS 包体，用户下载的经过 Gzip 压缩的平均包体大小是 410KB，这一点与 HTTPArchive 之前发布的 420KB 的数据基本一致。不过最差劲的网站则是直接甩了 10MB 的脚本给用户，简直可怕。&lt;/p>
&lt;p>通过上面的统计我们可以发现，包体体积固然重要，但是其并非唯一因素，语法解析与编译的耗时也不一定随着包体体积的增长而线性增长。总体而言小的 JavaScript 包体是会加载地更快(忽略浏览器、设备与网络连接的差异)，但是同样 200KB 的大小，不同开发者的包体在语法解析、编译上的时间却是天差地别，不可同日而语。&lt;/p>
&lt;h1 id="现代-javascript-语法解析--编译性能评测">现代 JavaScript 语法解析 &amp;amp; 编译性能评测&lt;/h1>
&lt;h2 id="chrome-devtools">Chrome DevTools&lt;/h2>
&lt;p>打开 Timeline( Performance panel ) &amp;gt; Bottom-Up/Call Tree/Event Log 就会显示出当前网站在语法解析/编译上的时间占比。如果你希望得到更完整的信息，那么可以打开 V8 的 Runtime Call Stats。在 Canary 中，其位于 Timeline 的 Experims &amp;gt; V8 Runtime Call Stats 下。&lt;/p>
&lt;h2 id="chrome-tracing">Chrome Tracing&lt;/h2>
&lt;p>打开 about:tracing 页面，Chrome 提供的底层的追踪工具允许我们使用&lt;code>disabled-by-default-v8.runtime_stats&lt;/code>来深度了解 V8 的时间消耗情况。V8 也提供了&lt;a href="https://docs.google.com/presentation/d/1Lq2DD28CGa7bxawVH_2OcmyiTiBn74dvC6vn2essroY/edit#slide=id.g1a504e63c9_2_84" target="_blank" rel="noopener">详细的指南&lt;/a>来介绍如何使用这个功能。&lt;/p>
&lt;h2 id="webpagetest">WebPageTest&lt;/h2>
&lt;p>WebPageTest 中 Processing Breakdown 页面在我们启用 Chrome &amp;gt; Capture Dev Tools Timeline 时会自动记录 V8 编译、EvaluateScript 以及 FunctionCall 的时间。我们同样可以通过指明&lt;code>disabled-by-default-v8.runtime_stats&lt;/code>的方式来启用 Runtime Call Stats。&lt;/p>
&lt;p>更多使用说明参考我的&lt;a href="https://gist.github.com/addyosmani/45b135900a7e3296e22673148ae5165b" target="_blank" rel="noopener">gist&lt;/a>。&lt;/p>
&lt;h2 id="user-timing">User Timing&lt;/h2>
&lt;p>我们还可以使用 Nolan Lawson 推荐的&lt;a href="https://w3c.github.io/user-timing/#dom-performance-mark" target="_blank" rel="noopener">User Timing API&lt;/a>来评估语法解析的时间。不过这种方式可能会受 V8 预解析过程的影响，我们可以借鉴 Nolan 在 optimize-js 评测中的方式，在脚本的尾部添加随机字符串来解决这个问题。我基于 Google Analytics 使用相似的方式来评估真实用户与设备访问网站时候的解析时间：&lt;/p>
&lt;h2 id="devicetiming">DeviceTiming&lt;/h2>
&lt;p>Etsy 的 &lt;a href="https://github.com/danielmendel/DeviceTiming" target="_blank" rel="noopener">DeviceTiming&lt;/a> 工具能够模拟某些受限环境来评估页面的语法解析与执行时间。其将本地脚本包裹在了某个仪表工具代码内从而使我们的页面能够模拟从不同的设备中访问。可以阅读 Daniel Espeset 的&lt;a href="http://talks.desp.in/unpacking-the-black-box" target="_blank" rel="noopener">Benchmarking JS Parsing and Execution on Mobile Devices&lt;/a> 一文来了解更详细的使用方式。&lt;/p>
&lt;h1 id="我们可以做些什么以降低-javascript-的解析时间">我们可以做些什么以降低 JavaScript 的解析时间？&lt;/h1>
&lt;ul>
&lt;li>减少 JavaScript 包体体积。我们在上文中也提及，更小的包体往往意味着更少的解析工作量，也就能降低浏览器在解析与编译阶段的时间消耗。&lt;/li>
&lt;li>使用代码分割工具来按需传递代码与懒加载剩余模块。这可能是最佳的方式了，类似于&lt;a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank" rel="noopener">PRPL&lt;/a>这样的模式鼓励基于路由的分组，目前被 Flipkart, Housing.com 与 Twitter 广泛使用。&lt;/li>
&lt;li>Script streaming: 过去 V8 鼓励开发者使用&lt;code>async/defer&lt;/code>来基于&lt;a href="https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html" target="_blank" rel="noopener">script streaming&lt;/a>实现 10-20% 的性能提升。这个技术会允许 HTML 解析器将相应的脚本加载任务分配给专门的 script streaming 线程，从而避免阻塞文档解析。V8 推荐尽早加载较大的模块，毕竟我们只有一个 streamer 线程。&lt;/li>
&lt;li>评估我们依赖的解析消耗。我们应该尽可能地选择具有相同功能但是加载地更快的依赖，譬如使用 Preact 或者 Inferno 来代替 React，二者相较于 React 体积更小具有更少的语法解析与编译时间。Paul Lewis 在最近的&lt;a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank" rel="noopener">一篇文章&lt;/a>中也讨论了框架启动的代价，与 Sebastian Markbage 的&lt;a href="https://twitter.com/sebmarkbage/status/829733454119989248" target="_blank" rel="noopener">说法&lt;/a>不谋而合：最好地评测某个框架启动消耗的方式就是先渲染一个界面，然后删除，最后进行重新渲染。第一次渲染的过程会包含了分析与编译，通过对比就能发现该框架的启动消耗。&lt;/li>
&lt;/ul>
&lt;p>如果你的 JavaScript 框架支持 AOT(ahead-of-time)编译模式，那么能够有效地减少解析与编译的时间。Angular 应用就受益于这种模式：&lt;/p>
&lt;h1 id="现代浏览器是如何提高解析与编译速度的">现代浏览器是如何提高解析与编译速度的？&lt;/h1>
&lt;p>不用灰心，你并不是唯一纠结于如何提升启动时间的人，我们 V8 团队也一直在努力。我们发现之前的某个评测工具 Octane 是个不错的对于真实场景的模拟，它在微型框架与冷启动方面很符合真实的用户习惯。而基于这些工具，V8 团队在过去的工作中也实现了大约 25% 的启动性能提升：&lt;/p>
&lt;p>本部分我们就会对过去几年中我们使用的提升语法解析与编译时间的技巧进行阐述。&lt;/p>
&lt;h2 id="代码缓存">代码缓存&lt;/h2>
&lt;p>Chrome 42 开始引入了所谓的&lt;a href="http://v8project.blogspot.com/2015/07/code-caching.html" target="_blank" rel="noopener">代码缓存&lt;/a>的概念，为我们提供了一种存放编译后的代码副本的机制，从而当用户二次访问该页面时可以避免脚本抓取、解析与编译这些步骤。除以之外，我们还发现在重复访问的时候这种机制还能避免 40% 左右的编译时间，这里我会深入介绍一些内容：&lt;/p>
&lt;ul>
&lt;li>代码缓存会对于那些在 72 小时之内重复执行的脚本起作用。&lt;/li>
&lt;li>对于 Service Worker 中的脚本，代码缓存同样对 72 小时之内的脚本起作用。&lt;/li>
&lt;li>对于利用 Service Worker 缓存在 Cache Storage 中的脚本，代码缓存能在脚本首次执行的时候起作用。&lt;/li>
&lt;/ul>
&lt;p>总而言之，对于主动缓存的 JavaScript 代码，最多在第三次调用的时候其能够跳过语法分析与编译的步骤。我们可以通过&lt;code>chrome://flags/#v8-cache-strategies-for-cache-storage&lt;/code>来查看其中的差异，也可以设置&lt;code>js-flags=profile-deserialization&lt;/code>运行 Chrome 来查看代码是否加载自代码缓存。不过需要注意的是，代码缓存机制仅会缓存那些经过编译的代码，主要是指那些顶层的往往用于设置全局变量的代码。而对于类似于函数定义这样懒编译的代码并不会被缓存，不过 IIFE 同样被包含在了 V8 中，因此这些函数也是可以被缓存的。&lt;/p>
&lt;h2 id="script-streaming">Script Streaming&lt;/h2>
&lt;p>&lt;a href="https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html" target="_blank" rel="noopener">Script Streaming&lt;/a>允许在后台线程中对异步脚本执行解析操作，可以对于页面加载时间有大概 10% 的提升。上文也提到过，这个机制同样会对同步脚本起作用。&lt;/p>
&lt;p>这个特性倒是第一次提及，因此 V8 会允许所有的脚本，即使阻塞型的&lt;code>&amp;lt;script src=''&amp;gt;&lt;/code>脚本也可以由后台线程进行解析。不过缺陷就是目前仅有一个 streaming 后台线程存在，因此我们建议首先解析大的、关键性的脚本。在实践中，我们建议将&lt;code>&amp;lt;script defer&amp;gt;&lt;/code>添加到&lt;code>&amp;lt;head&amp;gt;&lt;/code>块内，这样浏览器引擎就能够尽早地发现需要解析的脚本，然后将其分配给后台线程进行处理。我们也可以查看 DevTools Timeline 来确定脚本是否被后台解析，特别是当你存在某个关键性脚本需要解析的时候，更需要确定该脚本是由 streaming 线程解析的。&lt;/p>
&lt;h2 id="语法解析--编译优化">语法解析 &amp;amp; 编译优化&lt;/h2>
&lt;p>我们同样致力于打造更轻量级、更快的解析器，目前 V8 主线程中最大的瓶颈在于所谓的非线性解析消耗。譬如我们有如下的代码片：&lt;/p>
&lt;pre tabindex="0">&lt;code>(function (global, module) { … })(this, function module() { my functions })
&lt;/code>&lt;/pre>&lt;p>V8 并不知道我们编译主脚本的时候是否需要&lt;code>module&lt;/code>这个模块，因此我们会暂时放弃编译它。而当我们打算编译&lt;code>module&lt;/code>时，我们需要重分析所有的内部函数。这也就是所谓的 V8 解析时间非线性的原因，任何一个处于 N 层深度的函数都有可能被重新分析 N 次。V8 已经能够在首次编译的时候搜集所有内部函数的信息，因此在未来的编译过程中 V8 会忽略所有的内部函数。对于上面这种&lt;code>module&lt;/code>形式的函数会是很大的性能提升，建议阅读&lt;a href="https://docs.google.com/presentation/d/1214p4CFjsF-NY4z9in0GEcJtjbyVQgU0A-UqEvovzCs/edit#slide=id.p" target="_blank" rel="noopener">The V8 Parser(s) — Design, Challenges, and Parsing JavaScript Better&lt;/a>来获取更多内容。V8 同样在寻找合适的分流机制以保证启动时能在后台线程中执行 JavaScript 编译过程。&lt;/p>
&lt;h2 id="预编译-javascript">预编译 JavaScript？&lt;/h2>
&lt;p>每隔几年就有人提出引擎应该提供一些处理预编译脚本的机制，换言之，开发者可以使用构建工具或者其他服务端工具将脚本转化为字节码，然后浏览器直接运行这些字节码即可。从我个人观点来看，直接传送字节码意味着更大的包体，势必会增加加载时间；并且我们需要去对代码进行签名以保证能够安全运行。目前我们对于 V8 的定位是尽可能地避免上文所说的内部重分析以提高启动时间，而预编译则会带来额外的风险。不过我们欢迎大家一起来讨论这个问题，虽然 V8 目前专注于提升编译效率以及推广利用 Service Worker 缓存脚本代码来提升启动效率。我们在 BlinkOn7 上与 Facebook 以及 Akamai 也讨论过&lt;a href="https://gist.github.com/addyosmani/4009ee1238c4b1ff6f2a2d8a5057c181" target="_blank" rel="noopener">预编译相关内容&lt;/a>。&lt;/p>
&lt;h2 id="optimize-js-优化">Optimize JS 优化&lt;/h2>
&lt;p>类似于 V8 这样的 JavaScript 引擎在进行完整的解析之前会对脚本中的大部分函数进行预解析，这主要是考虑到大部分页面中包含的 JavaScript 函数并不会立刻被执行。&lt;/p>
&lt;p>预编译能够通过只处理那些浏览器运行所需要的最小函数集合来提升启动时间，不过这种机制在 IIFE 面前却反而降低了效率。尽管引擎希望避免对这些函数进行预处理，但是远不如&lt;a href="https://github.com/nolanlawson/optimize-js" target="_blank" rel="noopener">optimize-js&lt;/a>这样的库有作用。optimize-js 会在引擎之前对于脚本进行处理，对于那些立即执行的函数插入圆括号从而保证更快速地执行。这种预处理对于 Browserify, Webpack 生成包体这样包含了大量即刻执行的小模块起到了非常不错的优化效果。尽管这种小技巧并非 V8 所希望使用的，但是在当前阶段不得不引入相应的优化机制。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>启动阶段的性能至关重要，缓慢的解析、编译与执行时间可能成为你网页性能的瓶颈所在。我们应该评估页面在这个阶段的时间占比并且选择合适的方式来优化。我们也会继续致力于提升 V8 的启动性能，尽我所能！&lt;/p>
&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/PEjEfP9HwqnYt34YN6E8Zw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PEjEfP9HwqnYt34YN6E8Zw&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>渲染策略</title><link>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E7%AD%96%E7%95%A5/</guid><description>&lt;h1 id="virtual-dom">Virtual DOM&lt;/h1></description></item><item><title>资源请求与缓存</title><link>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/web-tuning-notes/3.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96/%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%BC%93%E5%AD%98/</guid><description>&lt;h1 id="资源请求与缓存">资源请求与缓存&lt;/h1>
&lt;h1 id="数据压缩与流式加载">数据压缩与流式加载&lt;/h1>
&lt;h1 id="http-缓存">HTTP 缓存&lt;/h1>
&lt;h2 id="cdn">CDN&lt;/h2>
&lt;h1 id="http2-服务端推送">HTTP/2 服务端推送&lt;/h1>
&lt;h1 id="使用-https-安全传输">使用 HTTPS 安全传输&lt;/h1>
&lt;h1 id="font--字体">Font | 字体&lt;/h1>
&lt;h2 id="custom-web-fonts">Custom Web Fonts&lt;/h2>
&lt;p>我们首先回顾下浏览器是如何使用自定义字体的，当浏览器识别到用户在 CSS 中基于&lt;code>@font-size&lt;/code>定义的字体时，会尝试下载该字体文件。而在下载的过程中，浏览器是不会展示该字体所属的文本内容，最终导致了所谓的&lt;code>Flash of Invisible Text&lt;/code>现象。现在很多的网站都存在这个问题，这也是导致用户体验差的一个重要原因，即会影响用户最主要的内容浏览这一操作。而我们的优化点即在于首先将字体设置为默认字体，而后在自定义的 Web Font 下载完毕之后对标准字体再进行替换操作，并且重新渲染整个文本块。而如果自定义的字体下载失败，整个内容还是能保证基本的可读性，不会对用户体验造成毁灭性的打击。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://cdn.css-tricks.com/wp-content/uploads/2016/08/voorhoede-fonts.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>首先，我们会为需要使用到的 Web Fonts 创建最小子集，即只将那些需要使用的字体提取出来，而并不需要让用户下载整个字体集，这里推荐使用&lt;a href="https://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="noopener">Font squirrel webfont generator&lt;/a>。另外，我们还需要为字体的下载设置监视器，即保证能够在字体下载完毕之后自动回调，这里我们使用的是&lt;a href="https://github.com/bramstein/fontfaceobserver" target="_blank" rel="noopener">fontfaceobserver&lt;/a>，它会为页面自动创建一个监视器，在侦测到所有的自定义 Web Fonts 下载完毕后，会为整个页面添加默认的类名:&lt;/p>
&lt;pre tabindex="0">&lt;code>html {font-family: Georgia, serif;}
html.fonts-loaded {font-family: Noto, Georgia, serif;}
&lt;/code>&lt;/pre>&lt;p>不过现在 CSS 的&lt;code>font-display&lt;/code>属性也原生提供了我们这种替换功能，更多详情可见&lt;a href="https://developers.google.com/web/updates/2016/02/font-display" target="_blank" rel="noopener">font-display&lt;/a>属性。&lt;/p>
&lt;h1 id="服务端与缓存">服务端与缓存&lt;/h1>
&lt;p>高性能的前端离不开服务端的支持，在我们的实践中也发现不同的服务端配置同样会影响到前端的性能。目前我们主要使用 Apache Web Server 作为中间件，并且通过 HTTPS 来安全地传递内容。&lt;/p>
&lt;h2 id="configuration">Configuration&lt;/h2>
&lt;p>我们首先对于合适的服务端配置做了些调研，这里推荐是使用&lt;a href="https://github.com/h5bp/server-configs-apache" target="_blank" rel="noopener">H5BP Boilerplate Apache Configuration&lt;/a>作为配置模板，它是个不错的兼顾了性能与安全性的配置建议。同样地它也提供了面向其他服务端环境的配置。我们对于大部分的 HTML、CSS 以及 JavaScript 都开启了 GZip 压缩选项，并且对于大部分的资源都设置了缓存策略，详见下文的 File Level Caching 章节。&lt;/p>
&lt;h2 id="https">HTTPS&lt;/h2>
&lt;p>使用 HTTPS 可以保证站点的安全性，但是也会影响到你网站的性能表现，性能损耗主要发生在建立 SSL 握手协议的时候，这会导致很多的延迟，不过我们同样可以通过某些设置来进行优化。&lt;/p>
&lt;ul>
&lt;li>设置 HTTP Strict Transport Security 请求头可以让服务端告诉浏览器其只允许通过 HTTPS 进行交互，这就避免了浏览器从 HTTP 再重定向到 HTTPS 的时间消耗。&lt;/li>
&lt;li>设置 TLS false start 允许客户端在第一轮 TLS 中就能够立刻传递加密数据。握手协议余下的操作，譬如确认没有人进行中间人监听可以同步进行，这一点也能节约部分时间。&lt;/li>
&lt;li>设置 TLS Session Resumption，当浏览器与服务端曾经通过 TLS 进行过通信，那么浏览器会自动记录下 Session Identifier，当下次需要重新建立连接的时候，其可以复用该 Identifier，从而解决了一轮的时间。&lt;/li>
&lt;/ul>
&lt;p>这里推荐扩展阅读下&lt;a href="https://www.youtube.com/watch?v=YMfW1bfyGSY" target="_blank" rel="noopener">Mythbusting HTTPS: Squashing security’s urban legends by Emily Stark&lt;/a>。&lt;/p>
&lt;h2 id="cookies">Cookies&lt;/h2>
&lt;p>我们并没有使用某个服务端框架，而是直接使用了静态的 Apache Web Server，不过 Apache Web Server 也是能够读取 Cookie 并且进行些简单的操作。譬如在下面这个例子中我们将 CSS 缓存信息存放在了 Cookie 中，然后交付 Apache 进行判断是否需要重复加载 CSS 文件:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!-- #if expr=&amp;#34;($HTTP_COOKIE!=/css-loaded/) || ($HTTP_COOKIE=/.*css-loaded=([^;]+);?.*/ &amp;amp;&amp;amp; ${1} != &amp;#39;0d82f.css&amp;#39; )&amp;#34;--&amp;gt;
&amp;lt;noscript&amp;gt;&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;0d82f.css&amp;#34;&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;script&amp;gt;
(function() {
function loadCSS(url) {...}
function onloadCSS(stylesheet, callback) {...}
function setCookie(name, value, expInDays) {...}
var stylesheet = loadCSS(&amp;#39;0d82f.css&amp;#39;);
onloadCSS(stylesheet, function() {
setCookie(&amp;#39;css-loaded&amp;#39;, &amp;#39;0d82f&amp;#39;, 100);
});
}());
&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;/* Critical CSS here */&amp;lt;/style&amp;gt;
&amp;lt;!-- #else --&amp;gt;
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;0d82f.css&amp;#34;&amp;gt;
&amp;lt;!-- #endif --&amp;gt;
&lt;/code>&lt;/pre>&lt;p>这里 Apache Server 中的逻辑控制代码就是有点类似于注释形式的&lt;code>&amp;lt;!-- #&lt;/code>，其主要包含以下步骤:&lt;/p>
&lt;ul>
&lt;li>&lt;code>$HTTP_COOKIE!=/css-loaded/&lt;/code> 检测是否有设置过 CSS 缓存相关的 Cookie&lt;/li>
&lt;li>&lt;code>$HTTP_COOKIE=/.*css-loaded=([^;]+);?.*/ &amp;amp;&amp;amp; ${1} != '0d82f.css'&lt;/code>检测缓存的 CSS 版本是否为当前版本&lt;/li>
&lt;li>If &lt;code>&amp;lt;!-- #if expr=&amp;quot;...&amp;quot; --&amp;gt;&lt;/code> 值为&lt;code>true&lt;/code> 我们便能假设该用户是第一次访问该站点&lt;/li>
&lt;li>如果用户是首次浏览，我们添加了一个&lt;code>&amp;lt;noscript&amp;gt;&lt;/code>标签，里面还包含了一个阻塞型的&lt;code>&amp;lt;link rel=&amp;quot;stylesheet&amp;quot;&amp;gt;&lt;/code>标签。添加该标签的意义在于我们在下面是使用 JavaScript 来异步加载 CSS 文件，而在用户禁止 JavaScript 的情况下也能保证可以通过该标签来正常加载 CSS 文件。&lt;/li>
&lt;li>&lt;code>&amp;lt;!-- #else --&amp;gt;&lt;/code> 表达式在用户二次访问该页面时，我们可以认为 CSS 文件已经被加载过了，因此可以直接从本地缓存中加载而不需要重复请求。&lt;/li>
&lt;/ul>
&lt;p>上述策略同样可以应用于 Web Fonts 的加载，最终的 Cookie 如下所示:
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://cdn.css-tricks.com/wp-content/uploads/2016/08/voorhoede-cookies.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="file-level-caching">File Level Caching&lt;/h2>
&lt;p>在上文可以发现，我们严重依赖于浏览器缓存来处理用户重复访问时资源加载的问题，理想情况下我们肯定希望能够永久地缓存 CSS、JS、Fonts 以及图片文件，然后在某个文件发生变化的时候将缓存设置为失效。这里我们设置了以&lt;code>https://www.voorhoede.nl/assets/css/main.css?v=1.0.4&lt;/code>形式，即在请求路径上加上版本号的方式进行缓存。不过这种方式的缺陷在于如果我们更换了资源文件的存放地址，那么所有的缓存也就自然失效了。这里我们使用了&lt;a href="https://github.com/sindresorhus/gulp-rev" target="_blank" rel="noopener">gulp-rev&lt;/a>以及&lt;a href="https://github.com/jamesknelson/gulp-rev-replace" target="_blank" rel="noopener">gulp-rev-replace&lt;/a>来为文件添加 Hash 值，从而保证了仅当文件内容发生变化的时候文件请求路径才会发生改变，即将每个文件的缓存验证独立开来。&lt;/p>
&lt;h1 id="result">Result&lt;/h1>
&lt;p>上面我们介绍了很多的优化手段，这里我们以实验的形式来对优化的结果与效果进行分析。我们可以用类似于&lt;a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">PageSpeed Insights&lt;/a>或者&lt;a href="http://www.webpagetest.org/" target="_blank" rel="noopener">WebPagetest&lt;/a>来进行性能测试或者网络分析。我觉得最好的测试你站点渲染性能的方式就是在限流的情况下观察页面的呈现效果，Google Chrome 内置了限流的功能：
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://cdn.css-tricks.com/wp-content/uploads/2016/08/voorhoede-network-analysis.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
这里我们将我们的网络环境设置为了 50KB/S 的 GPRS 网络环境，我们总共花费了 2.27 秒完成了首屏渲染。上图中黄线左侧的时间即指明了从 HTML 文件开始下载到下载完成所耗费的时间，该 HTML 文件中已经包含了关键的 CSS 代码，因此整个页面已经保证了基本的可用性与可交互型。而剩下的比较大的资源都会进行延时加载，这正是我们想要达到的目标。我们也可以使用 PageSpeed 来测试下网站的性能，可以看出我们得分很不错:
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://cdn.css-tricks.com/wp-content/uploads/2016/08/pagespeed-insights-voorhoede.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
而在 WebPagetest 中，我们看出了如下的结果:
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://cdn.css-tricks.com/wp-content/uploads/2016/08/webpagetest-voorhoede.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="roadmap">Roadmap&lt;/h2>
&lt;p>优化之路漫漫，永无止境，我们在未来也会关注以下几个方面：&lt;/p>
&lt;ul>
&lt;li>HTTP/2:我们目前已经开始尝试使用 HTTP/2，而本篇文章中提到的很多的优化的要点都是面向 HTTP/1.1 的。简言之，HTTP/1.1 诞生之初还是处于 Table 布局与行内样式流行的时代，它并没有考虑到现在所面对的 2.6MB 大小，包含 200 多个网络请求的页面。为了弥合这老的协议的缺陷，我们不得不连接 JS 与 CSS 文件、使用行内样式、对于小图片使用 Data URL 等等。这些操作都是为了节约请求次数，而 HTTP/2 中允许在同一个 TCP 请求中进行多个并发的请求，这样就会允许我们不需要再去进行大量的文件合并操作。&lt;/li>
&lt;li>Service Workers:这是现代浏览器提供的后台工作线程，可以允许我们为网站添加譬如离线支持、推送消息、后台同步等等很多复杂的操作。&lt;/li>
&lt;li>CDN:目前我们是自己维护网站，而在真实的应用场景下可以考虑使用 CDN 服务来减少服务端与客户端之间的物理距离，从而减少传输时延。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>最多三秒钟渲染完成单屏或者使用 Loading&lt;/li>
&lt;li>基于 3G/4G 移动网络下，每屏幕资源不超过 1024KB&lt;/li>
&lt;/ol>
&lt;h6 id="加载优化">加载优化&lt;/h6>
&lt;ul>
&lt;li>合并 CSS、JavaScript&lt;/li>
&lt;li>合并小图片、使用雪碧图&lt;/li>
&lt;li>缓存一切可以缓存的资源，部分资源 css、js 使用&lt;code>src=&amp;quot;abc.css?cacheVersion=1&amp;quot;&lt;/code>来控制版本&lt;/li>
&lt;li>使用长 Cache&lt;/li>
&lt;li>压缩 HTML、CSS、JS&lt;/li>
&lt;li>启用&lt;code>GZip&lt;/code>&lt;/li>
&lt;li>使用首屏加载&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>使用按需加载&lt;/li>
&lt;li>使用滚屏加载&lt;/li>
&lt;li>增加进度指示器&lt;/li>
&lt;li>减少&lt;code>Cookie&lt;/code>&lt;/li>
&lt;li>避免重定向&lt;/li>
&lt;li>异步加载第三方资源&lt;/li>
&lt;/ul>
&lt;h6 id="css-优化">CSS 优化&lt;/h6>
&lt;ul>
&lt;li>CSS 写在头部，JS 写到尾部或者异步&lt;/li>
&lt;li>避免图片和&lt;code>iFrame&lt;/code>等的 SRC 为空&lt;/li>
&lt;li>尽量避免重设图片大小&lt;/li>
&lt;li>图片尽量避免使用&lt;code>DataURL&lt;/code>&lt;/li>
&lt;li>尽量避免在 HTML 标签中写 Style&lt;/li>
&lt;li>避免 CSS 表达式&lt;/li>
&lt;li>移除空的 CSS 规则&lt;/li>
&lt;li>正确使用 Display 的属性&lt;/li>
&lt;li>不滥用&lt;code>Float&lt;/code>&lt;/li>
&lt;li>不滥用 Web 字体&lt;/li>
&lt;li>不声明过多的&lt;code>Font-size&lt;/code>&lt;/li>
&lt;li>值为 0 时候不需要任何单位&lt;/li>
&lt;li>标准化各种浏览器的前缀&lt;/li>
&lt;li>避免让选择符看起来像正则表达式&lt;/li>
&lt;/ul>
&lt;h6 id="图片优化">图片优化&lt;/h6>
&lt;ul>
&lt;li>使用 &lt;code>CSS3、SVG、IconFont&lt;/code>代替图片&lt;/li>
&lt;li>使用 Srcset&lt;/li>
&lt;li>WebP 优于 JPG&lt;/li>
&lt;li>PNG8 优于 GIF&lt;/li>
&lt;li>首次加载不大于 1024KB 单页&lt;/li>
&lt;li>图片不宽于 640&lt;/li>
&lt;/ul>
&lt;h6 id="脚本优化">脚本优化&lt;/h6>
&lt;ul>
&lt;li>减少重绘&lt;/li>
&lt;li>缓存 Dom 选择与计算&lt;/li>
&lt;li>缓存列表的长度&lt;/li>
&lt;li>尽量使用事件代理，避免批量绑定事件&lt;/li>
&lt;li>尽量使用 ID 选择器&lt;/li>
&lt;li>使用 touch 代理 click&lt;/li>
&lt;/ul>
&lt;h6 id="渲染优化">渲染优化&lt;/h6>
&lt;ul>
&lt;li>HTML 使用 ViewPort&lt;/li>
&lt;li>减少 Dom 节点&lt;/li>
&lt;li>尽量使用 CSS3 动画&lt;/li>
&lt;li>合理使用&lt;code>requestAnimationFrame&lt;/code>动画代替 setTimeout&lt;/li>
&lt;li>适当使用 Canvas 动画&lt;/li>
&lt;li>&lt;code>touchmove，scroll&lt;/code>事件会导致多次渲染&lt;/li>
&lt;li>使用 &lt;code>CSS3-transitions、CSS3-3D、Opacity、Canvas、WebGL、Video&lt;/code>来触发 GPU 渲染&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>本文从属于笔者的&lt;a href="https://github.com/wx-chevalier/web-frontend-practice-handbook" target="_blank" rel="noopener">Web 前端入门与最佳实践&lt;/a>中&lt;a href="https://github.com/wx-chevalier/web-frontend-practice-handbook#optimization%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">前端性能优化&lt;/a>系列，同时也归纳于笔者的&lt;a href="https://github.com/wx-chevalier/Coder-Knowledge-Graph/blob/master/interview/my-frontend-backend-interview.md" target="_blank" rel="noopener">我的校招准备之路:从 Web 前端到服务端应用架构&lt;/a>这篇综述。&lt;/p>
&lt;/blockquote>
&lt;p>前端优化的根本目的是为了有一个更好地用户体验的同时尽可能减少后端负载压力。即保证更少的加载时间、更快的首屏渲染、更流畅的用户交互。在笔者自己的知识体系内，当我们想为用户呈现更好的视觉效果与用户体验时，我们往往会从&lt;a href="https://github.com/wx-chevalier/web-frontend-practice-handbook/blob/master/advanced/Optimization/FrontendOptimization-Benchmark.md" target="_blank" rel="noopener">性能评测与监控&lt;/a>、&lt;a href="https://github.com/wx-chevalier/web-frontend-practice-handbook/blob/master/advanced/Optimization/FrontendOptimization-Resource-Request.md" target="_blank" rel="noopener">资源与请求优化&lt;/a>、&lt;a href="https://github.com/wx-chevalier/web-frontend-practice-handbook/blob/master/advanced/Optimization/FrontendOptimization-Load.md" target="_blank" rel="noopener">加载策略&lt;/a>、&lt;a href="https://github.com/wx-chevalier/web-frontend-practice-handbook/blob/master/advanced/Optimization/FrontendOptimization-HomePage-CriticalPath.md" target="_blank" rel="noopener">首页与关键路径&lt;/a>、&lt;a href="https://github.com/wx-chevalier/web-frontend-practice-handbook/blob/master/advanced/Optimization/FrontendOptimization-Render.md" target="_blank" rel="noopener">渲染优化&lt;/a>这几个方面进行考虑。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000002884052" target="_blank" rel="noopener">让 web app 更快的 HTML5 最佳实践&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.cnblogs.com/zichi/p/4713031.html" target="_blank" rel="noopener">高性能 JavaScript DOM 编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.helloweba.com/view-blog-369.html" target="_blank" rel="noopener">移动 Web 开发规范摘录&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651221573&amp;amp;idx=1&amp;amp;sn=776c6188071f571455e98d98e30f2fac&amp;amp;scene=0#wechat_redirect" target="_blank" rel="noopener">百度移动端首页前端速度那些事儿 &lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aotu.io/notes/2016/04/12/jcloud-opt/" target="_blank" rel="noopener">京东凹凸实验室:前端优化实践总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developers.google.com/web/fundamentals/performance/?hl=zh-cn" target="_blank" rel="noopener">Google Developers：优化性能&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="编码与压缩">编码与压缩&lt;/h1>
&lt;h1 id="image-optimization图片使用与显示优化">Image Optimization:图片使用与显示优化&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/24315362" target="_blank" rel="noopener">前端图片引入方式神演算&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.creativebloq.com/features/10-ways-to-optimise-images-for-better-performance" target="_blank" rel="noopener">http://www.creativebloq.com/features/10-ways-to-optimise-images-for-better-performance&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.freecodecamp.com/you-need-to-stop-making-these-6-mistakes-with-your-img-s-e242c02d14be#.rc8caa9fp" target="_blank" rel="noopener">you-need-to-stop-making-these-6-mistakes-with-your-img-s&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://css-tricks.com/responsive-images-css/" target="_blank" rel="noopener">responsive-images-css&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="webp">WebP&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000007482148" target="_blank" rel="noopener">把网站的图片升级到 WebP 格式吧&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="http-cache">HTTP Cache&lt;/h1>
&lt;p>静态网站非常简单，它就是通过一个 url 访问 web 服务器上的一个网页，web 服务器接收到请求后在网络上使用 http 协议将网页返回给浏览器，浏览器通过解析 http 协议 最终将页面展示在浏览器里，有时这个网页会比较复杂点，里面包含了一些额外的资源例如：图片、外部的 css 文件、外部的 js 文件以及一些 flash 之类的 多媒体资源，这些资源会单独使用 http 协议把信息返回给浏览器，浏览器从页面里的 src，href、Object 这样的标签将这些资源和页面组合在一 起，最终在浏览器里展示页面。但是不管什么类型的资源，这些资源如果我们不是手动的改变它们，那么我们每次请求获得结果都是一样的。这就说明静态网页的一 个特点：静态网页的资源基本是不会发生变化的。因此我们第一次访问一个静态网页和我们以后访问这个静态网页都是一个重 复的请求，这种网站加载的速度基本都是由网络传输的速度，以及每个资源请求的大小所决定，既然访问的资源基本不会发生变化，那么我们重复请求这些资源，自 己在那里空等不是很浪费时间吗？如是乎，浏览器出现了缓存技术，我们开发时候可以对那些不变的资源在 http 协议上编写相应指令，这些指令会让浏览器第一 次访问到静态资源后缓存起这些静态资源，用户第二次访问这个网页时候就不再需要重复请求了，因为请求资源本地缓存，那么获取它的效率就变得异常高效。&lt;/p>
&lt;h1 id="cdn-1">CDN&lt;/h1>
&lt;h2 id="多域名资源存放">多域名资源存放&lt;/h2>
&lt;ol>
&lt;li>静态内容和动态内容分服务器存放，使用不同的服务器处理请求。处理动态内容的只处理动态内容，不处理别的，提高效率，这样使得 CDN(内容分发网络)缓存更方便&lt;/li>
&lt;/ol>
&lt;p>2、突破浏览器并发限制 (你随便挑一个 G 家的 url: &lt;a href="https://lh4.googleusercontent.com/-" target="_blank" rel="noopener">https://lh4.googleusercontent.com/-&lt;/a> si4dh2myPWk/T81YkSi__AI/AAAAAAAAQ5o/LlwbBRpp58Q/w497-h373/IMG_20120603_163233.jpg, 把前面的 lh4 换成 lh3,lh6 啥的，都照样能够访问，像地图之类的需要大量并发下载图片的站点，这个非常重要。)&lt;/p>
&lt;p>3、跨域不会传 cookie,节省宽带；举例说一下：
twitter 的主站 &lt;a href="http://twitter.com" target="_blank" rel="noopener">http://twitter.com&lt;/a>，用户的每次访问，都会带上自己的 cookie，挺大的。假如 twitter 的图片放在主站域名下，那么用户每次访问图片时，request header 里就会带有自己的 cookie，header 里的 cookie 还不能压缩，而图片是不需要知道用户的 cookie 的，所以这部分带宽就白白浪费了。
写主站程序时，set-cookie 也不要 set 到图片的域名上。
在小流量的网站，这个 cookie 其实节省不了多少带宽，当流量如 facebook twitter 时，节省下来就很可观了。&lt;/p>
&lt;p>关于多域名，也不是越多越好，虽然服务器端可以做泛解释，浏览器做 dns 解释也是耗时间的，而且太多域名，如果要走 https 的话，还有要多买证书和部署的问题&lt;/p>
&lt;h2 id="static-content网站静态化">Static Content:网站静态化&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.cnblogs.com/sharpxiajun/p/4282789.html" target="_blank" rel="noopener">关于大型网站技术演进的思考(九)&amp;ndash;网站静态化处理&amp;ndash;总述(1)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。由此可见，网站静态化处理的核心就是动静分离和缓存两大方面，上篇我简单讲述了动静整合的基础知识，本篇将会讲述两大核心之一的动静分离策略，只有把动静分离策略做好了，缓存才能发挥出它应有的效果。&lt;/p>
&lt;h1 id="请求优化">请求优化&lt;/h1>
&lt;h1 id="throttling-限流">Throttling: 限流&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">ajaxThrottle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">url&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">params&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timeout&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 这里的缓存暂时挂载在 window 命名空间下
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ajaxThrottleContext&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ajaxThrottleContext&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">token&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">url&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">JSON&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stringify&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">params&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">lastAjaxTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ajaxThrottleContext&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">token&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 判断是否已经过时
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">lastAjaxTime&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">now&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">lastAjaxTime&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nx">timeout&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// console.log(`Request Abort: ${token}`);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ajaxThrottleContext&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">token&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">Date&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">now&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/beaudurrant/Ajax-Debounce-jQuery-Plugin/blob/master/jquery.ajaxDebounce.js" target="_blank" rel="noopener">jquery.ajaxDebounce&lt;/a>&lt;/p>
&lt;h1 id="资源预抓取">资源预抓取&lt;/h1>
&lt;p>譬如 &lt;a href="https://github.com/instantpage/instant.page" target="_blank" rel="noopener">instant.page&lt;/a> 能够利用即时预加载 - 它在用户点击之前预先加载页面。在用户点击链接之前，他们将鼠标悬停在该链接上；大概在 65 毫秒时，他们可能才会实际点击该链接，instant.page 此时开始预加载，平均超过 300 毫秒，以便页面预加载。在移动设备上，用户在释放之前开始触摸他们的显示器，平均花费 90 毫秒来预加载页面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">prefetcher&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;link&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">preload&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">url&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">prefetcher&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">href&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">url&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">touchstartListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">event&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">linkElement&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">event&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">closest&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;a&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">linkElement&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">addEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;touchcancel&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">touchendAndTouchcancelListener&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">passive&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">linkElement&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">addEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;touchend&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">touchendAndTouchcancelListener&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">passive&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">urlToPreload&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">linkElement&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">href&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">preload&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">linkElement&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">href&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="links">Links&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://medium.com/@asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff" target="_blank" rel="noopener">https://medium.com/@asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>