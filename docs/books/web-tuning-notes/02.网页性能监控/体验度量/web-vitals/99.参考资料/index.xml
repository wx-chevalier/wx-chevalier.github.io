<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>99.参考资料 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/web-tuning-notes/02.%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/%E4%BD%93%E9%AA%8C%E5%BA%A6%E9%87%8F/web-vitals/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link>
      <atom:link href="https://ng-tech.icu/books/web-tuning-notes/02.%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/%E4%BD%93%E9%AA%8C%E5%BA%A6%E9%87%8F/web-vitals/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml" />
    <description>99.参考资料</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>99.参考资料</title>
      <link>https://ng-tech.icu/books/web-tuning-notes/02.%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/%E4%BD%93%E9%AA%8C%E5%BA%A6%E9%87%8F/web-vitals/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link>
    </image>
    
    <item>
      <title>2020-Performance 与 Web Vitals 介绍</title>
      <link>https://ng-tech.icu/books/web-tuning-notes/02.%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/%E4%BD%93%E9%AA%8C%E5%BA%A6%E9%87%8F/web-vitals/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-performance-%E4%B8%8E-web-vitals-%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/web-tuning-notes/02.%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/%E4%BD%93%E9%AA%8C%E5%BA%A6%E9%87%8F/web-vitals/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2020-performance-%E4%B8%8E-web-vitals-%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;h1 id=&#34;performance-与-web-vitals-介绍&#34;&gt;Performance 与 Web Vitals 介绍&lt;/h1&gt;
&lt;h2 id=&#34;1--processing-model-和-performance-timing-api&#34;&gt;1 / Processing Model 和 Performance Timing API&lt;/h2&gt;
&lt;h3 id=&#34;w3c-定义的-processing-model&#34;&gt;W3C 定义的 Processing Model&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.w3.org/TR/navigation-timing/#:~:text=The&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing&lt;/a&gt; timing attribute represents the,defined by the PerformanceTiming interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-1.png&#34; alt=&#34;Navigation Timing&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.w3.org/TR/navigation-timing-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing Level 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-2.png&#34; alt=&#34;Navigation Timing Level 2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;web-api&#34;&gt;Web API&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PerformanceNavigationTiming &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Performanceresourcetiming&lt;/code&gt; 接口扩展了 &lt;code&gt;Performance Timeline&lt;/code&gt; 中的 &lt;code&gt;PerformanceEntry&lt;/code&gt; 接口，提供了用于存储和检索有关浏览器文档事件的指标的方法和属性。 例如，此接口可用于确定加载或卸载文档需要多少时间。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;performance.getEntries()&lt;/code&gt; 可以访问页面上每个资源的一组关键网络计时属性，之后便可以用 &lt;code&gt;responseEnd&lt;/code&gt; 和 &lt;code&gt;startTime&lt;/code&gt; 之间的差值来计算所用的时间。&lt;/p&gt;
&lt;p&gt;此外，我们可以依此计算出众多指标。以 FPT 为例，我们会用到如下两个属性进行复合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存&lt;/li&gt;
&lt;li&gt;fetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如 DOM 解析耗时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;domInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件&lt;/li&gt;
&lt;li&gt;responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上所提及两个指标，分别用前者属性值减去后者属性值，即能得到指标取值。&lt;/p&gt;
&lt;h3 id=&#34;兼容性表现&#34;&gt;兼容性表现&lt;/h3&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-3.png&#34; alt=&#34;Performance%20%E4%B8%8E%20Web%20Vitals%20%E4%BB%8B%E7%BB%8D%20ba0da8d57b59479ba5ad99812a9e4b25/Untitled%202.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数据截取自 &lt;a href=&#34;https://caniuse.com/?search=PerformanceNavigationTiming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://caniuse.com/?search=PerformanceNavigationTiming&lt;/a&gt; (2020.12.01)&lt;/p&gt;
&lt;h2 id=&#34;2--performance-metrics&#34;&gt;2 / Performance Metrics&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;到底如何准确衡量网站的性能？我们拆解成四个部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;是否发生？&lt;/strong&gt; 导航是否成功启动？服务器是否有响应？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否有用？&lt;/strong&gt; 是否已渲染可以与用户互动的足够内容？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否可用？&lt;/strong&gt; 用户可以与页面交互，还是页面仍在忙于加载？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否令人愉快？&lt;/strong&gt; 交互是否顺畅而自然，没有滞后和卡顿？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;第一个问题是否发生&#34;&gt;&lt;strong&gt;第一个问题，是否发生&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当用户访问一个网站的时候，关心的第一个问题永远是“是否发生”——浏览器是否成功地把我的请求发送出去，而服务器是否已经知道并开始处理我的请求？&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-4.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;TTFB (Time to First Byte)&lt;/strong&gt; 首字节到达的时间点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FP (First Paint)&lt;/strong&gt; 首次绘制，标记浏览器渲染任何在视觉上不同于导航前屏幕内容的时间点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FCP (First Contentful Paint)&lt;/strong&gt; 首次内容绘制，标记浏览器渲染来自 DOM 第一位内容的时间点，内容可能是文本、图像等元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TTFB、FP 和 FCP 这些指标标记出浏览器开始绘制内容的时间点，这些时刻等同于告诉用户：&lt;strong&gt;“浏览器已经开始处理服务器的返回了，你的请求已经发生了！”&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;第二个问题是否有用&#34;&gt;&lt;strong&gt;第二个问题，是否有用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当用户确定自己的请求发生了后，就会开始关心第二个问题：“是否有用？”&lt;/p&gt;
&lt;p&gt;例如，用户在使用天气应用，在确定页面有反应了后，就开始关心，什么时候能展现有用的内容，从而得知今天的天气。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-5.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;FMP (First Meaningful Paint)&lt;/strong&gt; 首次有效绘制，是指首次绘制对用户有用内容的时间点。有用的内容，是指 Youtube 上的视频；Twitter 上的推文；天气应用中的天气预测……这些内容或元素，也被称为主角元素**（Hero Elements）**，能够向用户提供有用的内容。但是这些元素难以界定，所以后来用 LCP 来取代 FMP。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LCP (Largest Contentful Paint&lt;/strong&gt; 最大内容绘制时间，计算从页面开始加载到用户与页面发生交互（点击，滚动）这段时间内，最大元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SI (Speed Index)&lt;/strong&gt; 速度指标，填充页面内容的速度，取开始加载到最后完成渲染，每一时刻页面未完成度的积分。页面的视觉完成度（visually complete）是基于 SSIM(Structural similarity Index) 计算的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下为 LCP 的示意图。LCP 标记出浏览器绘制最大内容的时间点，并默认认为页面中最大的元素是对用户最有用的内容。LCP 试图标记出用户是在什么时刻得到有用内容的，而越早得到有用内容，用户的体验自然就越好。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-6.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;SI 反应出填充页面内容的速度。例如下图，虽然都是最后时刻填充完内容，但显然，上面会有种页面加载更快的感觉。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-7.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;第三个问题是否可用&#34;&gt;&lt;strong&gt;第三个问题，是否可用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在用户得到了有用的信息后，用户就会基于得到的信息作出反应，这就是页面“是否可用？”例如看到了新闻后，想要评论；知道了天气后，想要转发提醒朋友等等。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-8.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在解释这些指标之前，我们先要理解为什么页面有时候不能及时响应用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Long Tasks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;耗时任务。浏览器是单线程，所有任务会被添加到主线程的队列中逐个执行。如果有任务耗时过长，主线程就会被阻塞，其他任务就只能等待，包括那些由用户交互产生的任务，从而无法及时响应用户。根据 Jakob Nielsen 的研究 &lt;strong&gt;*Response Times: The 3 Important Limits*&lt;/strong&gt;，页面应该在 100 ms 内响应用户输入，否则就会被用户认为卡顿。要实现小于 100 ms 的响应，单个任务必须在 50 ms 内完成。这样即使用户的输入行为发生在某个任务刚开始的时候，并且耗时 50 ms，在这个任务结束后，主线程仍有 50 ms 时间来响应用户输入，总响应时间在 100 ms 内。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-9.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过 Chrome DevTools 或 &lt;strong&gt;Long Task API&lt;/strong&gt; 能方便地发现这些耗时任务。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-10.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. TTI (Time to Interactive)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可交互时间，用于标记页面已进行视觉渲染并能可靠响应用户输入的时间点。页面可能会因为多种原因而无法响应用户输入，例如页面组件运行所需的 Javascript 尚未加载，或者耗时较长的任务阻塞主线程。TTI 指标可识别页面初始 JavaScript 已加载且主线程处于空闲状态（没有耗时较长的任务）的时间点。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-11.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. TBT (Total Blocking Time&lt;/strong&gt; &lt;a href=&#34;https://web.dev/tbt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://web.dev/tbt/&lt;/a&gt; &lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总共阻塞时间，计算的是从 FCP 到 TTI 之间，主线程阻塞的总时间。阻塞时间是指单次任务占用主线程超过 50 ms 的部分。&lt;/p&gt;
&lt;p&gt;例如下面的例子是页面加载过程中从 FCP 到 TTI 之间主线程的运行情况，一共执行了 5 个任务，分别耗时 250 ms，90 ms，35 ms，30 ms，155 ms，其中 3 个任务耗时超过 50 ms，将它们阻塞的时间累加起来 250 - 50 + 90 - 50 + 155 - 50 = 345 ms，得到 TBT。越低的 TBT 证明页面的有用性，可交互性越好。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-12.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-13.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-14.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. FID (First Input Delay)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首次输入延迟，指用户首次输入到页面响应的时间。我们都知道第一印象的重要性，网站亦是如此。首次输入延迟会成为用户对网站很重要的第一印象，决定用户有可能成为忠实用户或者弃之而去。值得注意的是，FID 仅关注用户离散的操作，如点击，轻击，按键等，其他交互如滚动和缩放，并不是 FID 关注的，因为通常浏览器会用一个单独的线程来处理它们。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-15.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;最后一个问题是否令人愉快&#34;&gt;&lt;strong&gt;最后一个问题，是否令人愉快&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;先来举个不愉快的例子。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-16.gif&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，你本想点击按钮 B，页面突然发生偏移，你不幸点到了按钮 A。“是否令人愉快？”是用户在整个应用使用过程中都会发生的问题，它不仅包含之前说的 Long Tasks，要包含一些不符合预期的布局偏移，即 CLS。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. CLS (Cumulative Layout Shift)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;累计布局偏移。测量在页面的整个生命周期中发生的每个意外的样式移动所造成的布局偏移分数的总和。某次布局偏移分数 = 影响分数 * 距离分数。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-17.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不知道你有没有意识到一个问题，什么叫意外的偏移？如何区分下面两种情况，前者是意外的偏移，后者则是点击搜索按钮展开，是符合预期的。所以 CLS 在计算过程中会忽略用户交互后 0.5s 内的布局偏移；同时 CLS 也会忽略动画，忽略 transform 的变化。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-18.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-19.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;3--core-web-vitals&#34;&gt;3 / Core Web Vitals&lt;/h2&gt;
&lt;p&gt;概括来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是 Google 为了提升网络整体性能的努力；&lt;/li&gt;
&lt;li&gt;是 Web Vitals 的子集，其核心基础指标 LCP，FID 和 CLS；&lt;/li&gt;
&lt;li&gt;是未来网页排名算法中新的因子；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;strong&gt;今年 5 月&lt;/strong&gt;，Google 在 &lt;strong&gt;Chromium Blog&lt;/strong&gt; (&lt;a href=&#34;https://blog.chromium.org/2020/05/introducing-web-vitals-essential-metrics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.chromium.org/2020/05/introducing-web-vitals-essential-metrics.html&lt;/a&gt;) 中提出的 Web Vitals，旨在提供统一的指标来量化用户在站点上的体验，囊括了之前在性能指标上的努力。同时，Google 认为不用每个人都成为网站性能方面的专家，大家只需要关注那些最核心最有价值的指标即可，于是提出了 Core Web Vitals，它是 Web Vitals 的子集，包含 LCP (Largest Contentful Paint)，FID (First Input Delay) 和 CLS (Cumulative Layout Shift)。&lt;/p&gt;
&lt;p&gt;评估用户体验质量涉及多个指标，评估用户体验质量涉及多个指标，尽管部分用户体验是跟网站和内容相关，但还是有些共通信号，而 &lt;strong&gt;Core Web Vitals&lt;/strong&gt; 体现了最关键的几项指标。此类&lt;a href=&#34;https://web.dev/user-centric-performance-metrics/#defining-metrics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;核心用户体验需求&lt;/a&gt;包括页面内容的加载体验、交互性和视觉稳定性，这些方面共同组成 2020 Core Web Vitals 的基础。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-20.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://web.dev/lcp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最大内容绘制&lt;/a&gt;评估页面主要内容可能已完成加载时的感知加载速度，并在页面加载时间轴上标记时间点。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://web.dev/fid/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;首次输入延迟&lt;/a&gt;评估用户首次尝试与网页交互时的网页响应速度，并量化用户感知体验。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://web.dev/cls/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;累积布局偏移&lt;/a&gt;评估可见页面内容的视觉稳定性，并量化内容的意外布局偏移量。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有上述指标均捕获以用户为中心的重要体验结果，可&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/speed-tools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;现场测量&lt;/a&gt;，并具有支持性实验室诊断等效指标和工具。例如，虽然最大内容绘制是最重要的负载指标，但其也高度依赖于&lt;a href=&#34;https://web.dev/fcp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;首次内容绘制&lt;/a&gt; (FCP) 和&lt;a href=&#34;https://web.dev/time-to-first-byte/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;首字节响应时间&lt;/a&gt; (TTFB)，这些指标对监控和改进均具有非常重要的意义。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-21.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Google 用 75 分位来代表网站某一指标的整体结果 [6]。例如，网站 75% 的访问中，LCP 都小于 2s，那么网站的 LCP 指标就是好；相反，网站超过 25% 的访问中，FID 都超过 300ms，那么网站的 FID 就是差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么是 ≤ 2500ms, ≤ 100ms, ≤ 0.1？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于 Google 的调查研究 &lt;strong&gt;The Science Behind Web Vitals&lt;/strong&gt; (&lt;a href=&#34;https://blog.chromium.org/2020/05/the-science-behind-web-vitals.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.chromium.org/2020/05/the-science-behind-web-vitals.html&lt;/a&gt;)，满足上述标准的网站，是能给用户带来良好的体验。&lt;/p&gt;
&lt;p&gt;其次，这些指标也是可以达到的，在推出这些指标和阈值之前，已经基于 CrUX (Chrome User Experience Report) 的数据发现有 10% 的网站是能满足上述指标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工具及周边&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下为相关工具的支持情况。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://hijiangtao.github.io/assets/in-post/2020-12-01-Web-Vitals-and-Performance-22.webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;4--附录&#34;&gt;4 / 附录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;附 1 PerformanceResourceTiming 属性表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;属性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entryType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EntryType 的类型 resource&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;name&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;resources URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;startTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在资源提取开始的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;duration&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;整个流程消耗的时间=responseEnd-startTime&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;initiatorType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;发起资源请求的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nextHopProtocol&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取资源的网络协议的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;workerStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果 Service Worker 线程已在运行,则在调用 FetchEvent 之前立即返回 DOMHighResTimeStamp，如果尚未运行，则在启动 Service Worker 线程之前立即返回 DOMHighResTimeStamp。 如果资源未被 Service Worker 拦截，则该属性将始终返回 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;初始重定向的开始获取时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;紧接在收到最后一次重定向响应的最后一个字节后&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;拉取资源开始时间，紧接在浏览器开始获取资源之前&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;紧接在浏览器启动资源的域名查找之前&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domainLookupEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示浏览器完成资源的域名查找后的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开始 TCP 连接：紧接在浏览器检索资源，开始建立与服务器的连接之前&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;结束 TCP 连接：紧接在浏览器完成与服务器的连接以检索资源之后&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;secureConnectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开始 SSL 连接：紧接在浏览器启动握手过程之前，以保护当前连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;requestStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;紧接在浏览器开始从服务器请求资源之前&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;紧接在浏览器收到服务器响应的第一个字节后&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;紧接在浏览器收到资源的最后一个字节之后或紧接在传输连接关闭之前，以先到者为准&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;secureConnectionStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SSL / 初始连接时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;transferSize&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示获取资源的大小（以八位字节为单位）的数字。 包括响应头字段和响应 payload body 的大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;encodedBodySize&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在删除任何应用的内容编码之前，从 payload body 的提取（HTTP 或高速缓存）接收的大小（以八位字节为单位）的 number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;decodedBodySize&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在删除任何应用的内容编码之后，从消息正文( message body )的提取（HTTP 或缓存）接收的大小（以八位字节为单位）的 number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;serverTiming&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包含服务器时序度量( timing metrics )的 PerformanceServerTiming 条目数组，可用于服务器传数据到前端&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;附 2 部分性能基础指标计算方式&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;基础指标&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;计算方式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;准备新页面耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fetchStart - navigationStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rdc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重定向时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectEnd - redirectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dns&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DNS 解析耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domainLookupEnd - domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tcp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCP 连接耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd - connectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ssl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SSL 安全连接耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd - secureConnectionStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;只在 HTTPS 下有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ttfb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to First Byte（TTFB），网络请求耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart - requestStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TTFB 有多种计算方式，ARMS 以 Google Development 定义为准&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;trans&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据传输耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd - responseStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dom&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DOM 解析耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive - responseEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;res&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源加载耗时&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart - domContentLoadedEventEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示页面中的同步加载资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fbt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;首包时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart - domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fpt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;First Paint Time, 首次渲染时间 / 白屏时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd - fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;从请求开始到浏览器开始解析第一批 HTML 文档字节的时间差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tti&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to Interact，首次可交互时间（非准确，仅做参考）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive - fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;浏览器完成所有 HTML 解析并且完成 DOM 构建，此时浏览器开始加载资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;load&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;页面完全加载时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart - fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;load = 首次渲染时间 + DOM 解析耗时 + 同步 JS 执行 + 资源加载耗时&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>2021-Web Vitals：谷歌的新一代 Web 性能体验和质量指标</title>
      <link>https://ng-tech.icu/books/web-tuning-notes/02.%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/%E4%BD%93%E9%AA%8C%E5%BA%A6%E9%87%8F/web-vitals/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-web-vitals%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%96%B0%E4%B8%80%E4%BB%A3-web-%E6%80%A7%E8%83%BD%E4%BD%93%E9%AA%8C%E5%92%8C%E8%B4%A8%E9%87%8F%E6%8C%87%E6%A0%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/web-tuning-notes/02.%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/%E4%BD%93%E9%AA%8C%E5%BA%A6%E9%87%8F/web-vitals/99.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/2021-web-vitals%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%96%B0%E4%B8%80%E4%BB%A3-web-%E6%80%A7%E8%83%BD%E4%BD%93%E9%AA%8C%E5%92%8C%E8%B4%A8%E9%87%8F%E6%8C%87%E6%A0%87/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5MTg2NDA3MQ==&amp;amp;mid=2651937086&amp;amp;idx=1&amp;amp;sn=fdfe9777cf41d266836dcbf98c21afa1&amp;amp;chksm=bd4afd568a3d7440ec1fd999a7022653269f34a9e387eab510704d6764f5e8aa73e2584539b1&amp;amp;scene=27&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;web-vitals--谷歌的新一代-web-性能体验和质量指标&#34;&gt;Web Vitals —— 谷歌的新一代 Web 性能体验和质量指标&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐：Google 开发了许多实用指标和工具，帮助衡量用户体验和质量，从而发掘优化点。一项名为 Web Vitals 的计划降低了学习成本，为网站体验提供了一组统一的质量衡量指标 &amp;ndash; Core Web Vitals，其中包括加载体验、交互性和页面内容的视觉稳定性，构成了 2020 年核心 Web 健康指标的基础。本文详细的介绍了每个指标及其使用方式，推荐了用于测量这些指标的实用工具，快来一起看看吧～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicyeqQ0Lic2yjsiceazzTAlhCA6hny1NbuhVSomaHQI2JC0tmObsjyYziaiaw/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Nathan Dumlao 摄影作品（发表于 Unsplash）&lt;/p&gt;
&lt;p&gt;有很多方法可以优化网站的用户体验。若能预先了解最佳的优化衡量方法，可以大大节省时间和成本。&lt;/p&gt;
&lt;p&gt;Google 在 2020 年 5 月 5 日提出了新的用户体验量化方式 Web Vitals 来衡量网站的用户体验，并将这些衡量结果用作其排名算法的一部分。为了更好的理解这些内容，让我们来看看这些重要指标是什么。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE19oQoHYGMNGUcyM9qsCGib3vNHczoPzCZzvreSo3bqyrSwT0pFF0az0YvJ7v3Pjzw7moARibnYGRtQ/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Google 在使用者体验量化发展的相关成果&lt;/p&gt;
&lt;h1 id=&#34;01&#34;&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/h1&gt;
&lt;h1 id=&#34;core-web-vitals-与-web-vitals&#34;&gt;&lt;strong&gt;Core Web Vitals 与 Web Vitals&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;什么是 Web Vitals，Google 给出的定义是&lt;strong&gt;一个良好网站的基本指标&lt;/strong&gt;（Essential metrics for a healthy site），过去要衡量一个网站的好坏，需要使用的指标太多了，Web Vitals 可以简化指标的学习曲线，只需聚焦于 Web Vitals 指标的表现即可。&lt;/p&gt;
&lt;p&gt;“你不需要成为任何领域的专家就可以了解 Web Vitals。它们很简单，比如移动友好性、浏览安全性、HTTPS、交互性、视觉稳定性、加载时间等。”&lt;/p&gt;
&lt;p&gt;在这些 Web Vitals 中，Google 确定了三个主要衡量指标，即&lt;strong&gt;在所有类型的网站中通用的 Core Web Vitals[1]：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（[1]Core Web Vitals 是应用于所有 Web 页面的 Web Vitals 的子集，是其最重要的核心）&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicyHAkl8Rx0Qib4UibxevUBeTbsQXUiaq6Lr9TBtqx9ibjib4aOribHskshNMSw/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Core Web Vitals 与 Web Vitals&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加载性能（LCP）&lt;/strong&gt; &amp;ndash; 显示最大内容元素所需时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交互性（FID）&lt;/strong&gt; &amp;ndash; 首次输入延迟时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视觉稳定性（CLS）&lt;/strong&gt; &amp;ndash; 累积布局配置偏移&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个指标已经经过了一段时间的验证，如 LCP 在 WICG 已经孵化至少 1 年以上，FID 在 Google Chrome Labs 上已经实施 2 年以上，LCP 和 CLS（相关 Layout Instability API）已于今年入 W3C 草拟标准。&lt;/p&gt;
&lt;p&gt;让我们一起详细了解下 Core Web Vitals。&lt;/p&gt;
&lt;h3 id=&#34;1-lcp----最大内容绘制&#34;&gt;&lt;strong&gt;1. LCP &amp;ndash; 最大内容绘制&lt;/strong&gt;&lt;/h3&gt;
&lt;h3 id=&#34;加载性能&#34;&gt;&lt;strong&gt;加载性能&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicy567r7XDtzvekLuZBLIpd6pc0ibFJOFH13FAfmEky7jyf0RzHY2siaSUg/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;LCP 的基准时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LCP&lt;/strong&gt;（Largest Contentful Paint）&lt;strong&gt;用于衡量加载体验，&lt;strong&gt;从真实用户的角度衡量网页的加载速度。它是&lt;/strong&gt;从页面刚开始加载到呈现出所有内容时的持续时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“换句话说，LCP 是度量网页上可见区域加载时间的方法”&lt;/p&gt;
&lt;p&gt;让我们比较一下有图像和没有图像的媒体文章的 LCP。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicyWib1BZl1wW7rV3iabh3IgPZfJDia6nBsq3IEYXA78zQkBJA8Fnd0568fg/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;LCP 对比&lt;/p&gt;
&lt;p&gt;有图片的文章用了 3.57 秒加载，而没有图片的文章只用了 2.32 秒载入。&lt;/p&gt;
&lt;p&gt;“谷歌坚称，所有开发者和产品所有者都会定期测量其应用程序的 Core Web Vitals，并提供工具来辅助测量。”&lt;/p&gt;
&lt;h3 id=&#34;2-fid----首次输入延迟&#34;&gt;&lt;strong&gt;2. FID &amp;ndash; 首次输入延迟&lt;/strong&gt;&lt;/h3&gt;
&lt;h3 id=&#34;交互行为&#34;&gt;&lt;strong&gt;交互行为&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicymHJ2MibPVhhx9ibKRzuVb8x1MKYtAjkDmhtPfoSMnH1Lja5kNBibGLGzA/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;FID 的基准时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FID&lt;/strong&gt;（First Input Delay）涉及到用户与 web 页面之间的交互性，用于衡量网站操作的顺畅程度。它**测量了用户第一次产生交互行为，**到浏览器响应该用户操作的持续时间。这些用户交互行为可以是单击按钮、点击链接或任何基于 JavaScript 的自定义控件。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE3hY4bxicIWnQ5gA81kK0wIaNY1ySJa1nBEn5h7YoxEUZmksPvTMt0ApoRoMhSybpTJy8TO3ZXmJcw/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 TTI 的时间内第一个互动事件的开始时间与浏览器回应事件的时间差&lt;/p&gt;
&lt;p&gt;为什么要取在 TTI[2] 发生的第一次的操作事件，Google 给的理由有以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用者的第一次互动体验印象相当重要；&lt;/li&gt;
&lt;li&gt;当今网页最大的互动性问题通常发生在一开始载入时；&lt;/li&gt;
&lt;li&gt;页面载入完后的第二次操作事件延迟，有其他专门的改善解决建议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（[2]互动时间 TTI 是衡量负载响应能力的重要实验室指标。它有助于确定页面看起来是交互式但实际上不是交互式的情况。快速的 TTI 有助于确保页面可用。TTI 度量标准衡量的是从页面开始加载到页面主要子资源加载之间的时间，它能够快速可靠地响应用户输入。）&lt;/p&gt;
&lt;p&gt;“根据 Google 的基准测试，交互的最佳持续时间应该在 100ms 以下，而任何超过 300ms 的时间都被认为是较差的。”&lt;/p&gt;
&lt;p&gt;人们可能会说这些时间间隔很小，调整几百毫秒也没什么区别。但实际上，这些微小的变化可能会对最终用户产生重大影响。&lt;/p&gt;
&lt;h3 id=&#34;3-cls----累计布局偏移&#34;&gt;&lt;strong&gt;3. CLS &amp;ndash; 累计布局偏移&lt;/strong&gt;&lt;/h3&gt;
&lt;h3 id=&#34;视觉稳定性&#34;&gt;&lt;strong&gt;视觉稳定性&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicy4TtA9CqOX0EB01lIu2QoyhowyvtpkzghrWVYC2qcP1icz7kxdWpic5Pw/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CLS 的基准时间&lt;/p&gt;
&lt;p&gt;你可能已经注意到某些时候网页中的元素在加载时出现移动，我敢肯定这不是用户期待的优秀体验。在这样的场景中，&lt;strong&gt;CLS&lt;/strong&gt;（Cumulative Layout Shift）**测量在页面的整个生命周期中发生的每个意外的样式移动的所有单独布局更改得分的总和，可以方便地用来度量 web 页面的视觉表现。**布局的移动可能发生在可见元素从一帧到下一帧改变位置的任何时候。为了提供良好的用户体验，网站应努力使 CLS 分数小于 0.1。&lt;/p&gt;
&lt;p&gt;“CLS 显示页面加载时组件移动的次数。正如大家所理解的，CLS 需要尽可能少地次数来实现良好的用户体验。”&lt;/p&gt;
&lt;p&gt;下图显示了 medium.com 和视觉不稳定网站之间的 CLS 差异。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicylSNMmAyzLFCGRkb2ozZmtib5MyibYv0F3icZibJ5ulXXhu0Pgic8QDhMGjQ/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;视觉稳定性测量&lt;/p&gt;
&lt;p&gt;在上面的例子中，medium.com 网站显示其 CLS 为 0.097。&lt;/p&gt;
&lt;p&gt;“这是不是意味着 medium.com 网站加载时主页移动了 0.097 次？→ 不是！！”&lt;/p&gt;
&lt;p&gt;计算此值时要考虑视窗大小以及两个渲染帧之间视窗中不稳定元素的移动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;布局偏移系数&lt;/strong&gt;（Layout Shift Score） = &lt;strong&gt;影响范围系数&lt;/strong&gt;（Impact Fraction） x &lt;strong&gt;移动距离系数&lt;/strong&gt;（Distance Fraction）&lt;/p&gt;
&lt;p&gt;CLS 值（布局偏移系数）可以使用上述公式轻松计算。此公式中的影响系数是指不稳定元素对视窗的影响，而距离系数是指不稳定元素移动的距离。&lt;/p&gt;
&lt;p&gt;例如，假设一个不稳定的元素覆盖了总窗口大小的 40%，当页面加载时它向下移动了 20%。在这种情况下，因为不稳定元素占用了总窗口的 60%，影响系数将为 0.6。又由于不稳定元素向下移动了 20%，因此距离系数将为 0.2。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;最终布局偏移系数 = 0.6 x 0.2 = 0.12&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE3hY4bxicIWnQ5gA81kK0wIaDSvA7YPxIkuZ7ReIAyYPMaWibCicABhNpR2iacyiaIa50AqTonhW51pAaA/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如上图的实例，影响范围（红色区域）占比总窗口 75% ，箭头（紫色）移动占总窗口高度的 25%，故 0.75 x 0.25 = 0.1875。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：使用 Bit（于 Github 里）可在项目之间共享可复用组件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bit 使得在项目之间共享、记录和复用独立组件变得简单。使用它可以最大限度地复用代码，能够保持设计一致、帮助团队协作、加快交付并构建可扩展的应用程序。&lt;/p&gt;
&lt;p&gt;Bit 支持 Node，TypeScript，React，Vue，Angular 等。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_gif/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicyFrUy4u3JvRFKXZeme55cUvbe3iciaS2lfWYfN3nfibOzia0JVHY9ibtduHA/640.png?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例：探索在 Bit.dev 上共享的可复用的 React 组件&lt;/p&gt;
&lt;p&gt;我觉得现在你应该已经很好地理解了 Core Web Vitals 和它们的职责。所以，现在是时候学习如何测量了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;测量-web-vitals-比你想象的要容易得多&#34;&gt;&lt;strong&gt;测量 Web Vitals 比你想象的要容易得多&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;正如我开始提到的，测量 Web Vitals 是一个简单的过程，任何人都可以做到。实际有很多工具可以用来测量 Web 的重要信息，包括一些浏览器插件。&lt;/p&gt;
&lt;p&gt;“Lighthouse、Chrome DevTools、PageSpeed Insights、Chrome UX Report 和 Web Vitals Extension 位列榜首。”&lt;/p&gt;
&lt;p&gt;虽然这些工具的用途相同，但可以进一步分为实验室测试工具和现场测试工具两类。&lt;/p&gt;
&lt;h4 id=&#34;1-实验室测试工具&#34;&gt;&lt;strong&gt;1. 实验室测试工具&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;实验室测试工具的主要目的是 在开发过程中测试性能，以确保在发布之前达到所需的标准。ChromeDevTools 和 Lighthouse 可用于在开发环境中测量 Core Web Vitals。&lt;/p&gt;
&lt;p&gt;“但是这些实验室测试工具无法测量 FID，因为没有用户来计算其交互性。但是，这些工具使用了一种称为 Total Blocking Time（TBT）的等效测量方法。”&lt;/p&gt;
&lt;p&gt;下图显示了使用 Lighthouse 的网页的性能测试结果：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicy0WdbGib8NEfkLCpf7FoAQJJRMv0W66AYkV8e78m3kAwutaSxoMszNZw/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 Lighthouse 测量 Core Web Vitals&lt;/p&gt;
&lt;h4 id=&#34;2-现场测试工具&#34;&gt;&lt;strong&gt;2. 现场测试工具&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;**实验室测试工具的结果不是 100% 准确的，因为没有真正的用户试用网页。**现场测试工具可以用来填补这个漏洞。此外，与实验室测试工具不同的是，现场测试工具可以按原样测量所有 3 个 Core Web Vitals。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PageSpeed Insights、Chrome UX Report&lt;/strong&gt; 和 &lt;strong&gt;Web Vitals Extension&lt;/strong&gt; 是一些现场测试工具，我们可以使用这些工具在真实用户交互时测量 Core Web Vitals。这些现场测试工具匿名地从网页上收集实时数据，使我们无需手动运行任何操作即可检查 Vitals。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicyiceJQSkl2FPibFv5WiaG3stV7ncYBsYqLyyyeNrNBr6C8k5BEVK6GkoFA/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 Lighthouse 测量 Core Web Vitals&lt;/p&gt;
&lt;p&gt;让我们假设你已经测量了网站的 Core web Vitals，而结果并不符合预期。那么，做什么能提高这些分数呢？&lt;/p&gt;
&lt;h1 id=&#34;03&#34;&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/h1&gt;
&lt;h1 id=&#34;改善-web-vitals-的步骤&#34;&gt;&lt;strong&gt;改善 Web Vitals 的步骤&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;既然你现在知道如何测量 Web Vitals，那么让我们看看如果存在问题，如何改进你的网站。&lt;/p&gt;
&lt;p&gt;众所周知，对于性能相关问题的技术修复并不是那么简单。大多数时候它们非常复杂耗时。但是，可以遵循一些通用的指导方法来改进这些 Core Web Vitals。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 可以通过以下方式改进网站的 LCP：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除或避免使用消耗太多时间加载的大型页面元素。通过分析前面讨论的测量工具结果，可以很容易地发现这些元素及其影响；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicyVkZoI9UlFtfPxtQFxldPcbY1I8ibgLwLfIaVbt9S4ux7UV5uFbhNIAw/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Lighthouse 分析结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免不必要的第三方 JavaScript 库。下面的分析表明，使用第三方库已将主线程阻塞 2700 毫秒；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicymjib3ib2Ol42sEdmVImcNub1GH626sDKa3D8lhccCRFQzZT9QJNoxmdQ/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Lighthouse 分析结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置延迟加载和延迟加载图像；&lt;/li&gt;
&lt;li&gt;减少服务器响应时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 与 LCP 类似，可以遵循以下几点来提高网站的 FID 值：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用高效的缓存策略更快地加载页面内容；&lt;/li&gt;
&lt;li&gt;与 LCP 类似，可以通过提交不必要的 JavaScript 库来增强 FID 值；&lt;/li&gt;
&lt;li&gt;最小化将提高页面加载时间，用户将能够立即与页面交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Xn6nDZ2tCE03GN5C3DoW4oMr1qgmicxicypjacnXCQpkJ71CTtPtlwOn2NQjiaFQMz9IG3taGV8IRfsvpHZ0mlWCQ/640.png?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Lighthouse 分析结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Core Web Vitals 最终测量的是 CLS，可以通过以下方式提高 CLS 分数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对图像和视频使用固定尺寸；&lt;/li&gt;
&lt;li&gt;如果网站存在广告显示，一定要为他们留下必要的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;结论&#34;&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;我希望你们已经明白了维护优秀网站的重要性。这些测量方法为保持网站的用户体验友好性提供了有力支持。&lt;/p&gt;
&lt;p&gt;尽管这些测量方法非常有前途，但在某些情况下，也需要临时修改这些测量方法来确保良好的用户体验。所以请保持注意。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
