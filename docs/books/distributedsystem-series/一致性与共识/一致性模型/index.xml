<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>一致性模型 | Next-gen Tech Edu</title>
    <link>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</link>
      <atom:link href="https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/index.xml" rel="self" type="application/rss+xml" />
    <description>一致性模型</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://ng-tech.icu/media/sharing.png</url>
      <title>一致性模型</title>
      <link>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</link>
    </image>
    
    <item>
      <title>其他一致性模型</title>
      <link>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E5%85%B6%E4%BB%96%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E5%85%B6%E4%BB%96%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h1 id=&#34;其他一致性模型&#34;&gt;其他一致性模型&lt;/h1&gt;
&lt;h1 id=&#34;弱一致性&#34;&gt;弱一致性&lt;/h1&gt;
&lt;p&gt;弱一致性指的是系统的某个数据被更新后，后续对该数据的读取操作，取到的可能是更新前的值，也可能是更新后的值，全部用户完全读取到更新后的数据，需要经过一段时间，这段时间称作“不一致性窗口”。&lt;/p&gt;
&lt;p&gt;系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别(比如秒级别)之后，可以让数据达到一致性状态。&lt;/p&gt;
&lt;h1 id=&#34;读己所写一致性&#34;&gt;读己所写一致性&lt;/h1&gt;
&lt;p&gt;因果一致性的特定形式。一个进程总可以读到自己更新的数据。&lt;/p&gt;
&lt;h1 id=&#34;会话一致性&#34;&gt;会话一致性&lt;/h1&gt;
&lt;p&gt;读己所写一致性的特定形式。进程在访问存储系统同一个会话内，系统保证该进程读己之所写。&lt;/p&gt;
&lt;h1 id=&#34;单调读一致性&#34;&gt;单调读一致性&lt;/h1&gt;
&lt;p&gt;如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。&lt;/p&gt;
&lt;h1 id=&#34;单调写一致性&#34;&gt;单调写一致性&lt;/h1&gt;
&lt;p&gt;系统保证对同一个进程的写操作串行化。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>顺序一致性</title>
      <link>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h1 id=&#34;顺序一致性&#34;&gt;顺序一致性&lt;/h1&gt;
&lt;p&gt;顺序一致性（Sequential Consistency），也同样有两个条件，其一与前面强一致性的要求一样，也是可以马上读到最近写入的数据，然而它的第二个条件就弱化了很多，它允许系统中的所有进程形成自己合理的统一的一致性，不需要与全局时钟下的顺序都一致。这里的第二个条件的要点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统的所有进程的顺序一致，而且是合理的，就是说任何一个进程中，这个进程对同一个变量的读写顺序要保持，然后大家形成一致。&lt;/li&gt;
&lt;li&gt;不需要与全局时钟下的顺序一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，顺序一致性在顺序要求上并没有那么严格，它只要求系统中的所有进程达成自己认为的一致就可以了，即错的话一起错，对的话一起对，同时不违反程序的顺序即可，并不需要个全局顺序保持一致。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/8CZ9pcLJ/image.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;图 a 是满足顺序一致性，但是不满足强一致性的。原因在于，从全局时钟的观点来看，P2 进程对变量 X 的读操作在 P1 进程对变量 X 的写操作之后，然而读出来的却是旧的数据。但是这个图却是满足顺序一致性的，因为两个进程 P1,P2 的一致性并没有冲突。从这两个进程的角度来看，顺序应该是这样的：Write(y,2), Read(x,0), Write(x,4), Read(y,2)，每个进程内部的读写顺序都是合理的，但是显然这个顺序与全局时钟下看到的顺序并不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图 b 满足强一致性，因为每个读操作都读到了该变量的最新写的结果，同时两个进程看到的操作顺序与全局时钟的顺序一样，都是 Write(y,2), Read(x,4), Write(x,4), Read(y,2)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图 c 不满足顺序一致性，当然也就不满足强一致性了。因为从进程 P1 的角度看，它对变量 Y 的读操作返回了结果 0。那么就是说，P1 进程的对变量 Y 的读操作在 P2 进程对变量 Y 的写操作之前，这意味着它认为的顺序是这样的：write(x,4), Read(y,0), Write(y,2), Read(x,0)，显然这个顺序又是不能被满足的，因为最后一个对变量 x 的读操作读出来也是旧的数据。因此这个顺序是有冲突的，不满足顺序一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;顺序保证&#34;&gt;顺序保证&lt;/h1&gt;
&lt;p&gt;线性一致寄存器的行为就好像只有单个数据副本一样，且每个操作似乎都是在某个时间点以原子性的方式生效的。这个定义意味着操作是按照某种良好定义的顺序执行的。我们通过操作（似乎）执行完毕的顺序来连接操作。顺序这个词也曾反复地出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;领导者在单主复制中的主要目的就是，在复制日志中确定写入顺序（order of write），也就是从库应用这些写入的顺序。如果不存在一个领导者，则并发操作可能导致冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可序列化，是关于事务表现的像按某种序列顺序（some sequential order）执行的保证。它可以通过字面意义上地序列顺序（serial order）执行事务来实现，或者通过允许并行执行，同时防止序列化冲突来实现（通过锁或中止事务）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在分布式系统中使用时间戳和时钟是另一种将顺序引入无序世界的尝试，例如，确定两个写入操作哪一个更晚发生。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺序，线性一致性和共识之间有着深刻的联系。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>线性一致性</title>
      <link>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h1 id=&#34;线性一致性&#34;&gt;线性一致性&lt;/h1&gt;
&lt;p&gt;所谓的线性一致性(Linearizability)，也称为原子一致性（Atomic Consistency）、强一致性（Strict Consistency）、强一致性（strong consistency）、立即一致性（immediate consistency）或外部一致性（external consistency）。在一个线性一致的系统中，只要一个客户端成功完成写操作，所有客户端从数据库中读取数据必须能够看到刚刚写入的值。线性一致性对多副本的系统能够对外表现地像只有单个副本一样，即系统能保障读到的值是最近的、最新的而不是来自过时的缓存或副本。换言之，线性一致性是一个新鲜度保证（recency guarantee）。下图即使某个非线性一致性系统的例子：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/12/1Hvm28.md.png&#34; alt=&#34;这个系统是非线性一致的，导致了球迷的困惑&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Alice 和 Bob 正坐在同一个房间里，都盯着各自的手机，关注着 2014 年 FIFA 世界杯决赛的结果。在最后得分公布后，Alice 刷新页面，看到宣布了获胜者，并兴奋地告诉 Bob。Bob 难以置信地刷新了自己的手机，但他的请求路由到了一个落后的数据库副本上，手机显示比赛仍在进行。如果 Alice 和 Bob 在同一时间刷新并获得了两个不同的查询结果，也许就没有那么令人惊讶了。因为他们不知道服务器处理他们请求的精确时刻。然而 Bob 是在听到 Alice 惊呼最后得分之后，点击了刷新按钮（启动了他的查询），因此他希望查询结果至少与爱丽丝一样新鲜。但他的查询返回了陈旧结果，这一事实违背了线性一致性的要求。综上所述，线性一致性对一致性的要求两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何一次读都能读到某个数据的最近一次写的数据。&lt;/li&gt;
&lt;li&gt;系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;强一致性要求无论数据的更新操作是在哪个副本上执行，之后所有的读操作都要能够获取到更新的最新数据。对于单副本的数据来说，读和写都是在同一份数据上执行，容易保证强一致性，但对于多副本数据来说，若想保障强一致性，就需要等待各个副本的写入操作都执行完毕，才能提供数据的读取，否则就有可能数据不一致，这种情况需要通过分布式事务来保证操作的原子性，并且外界无法读到系统的中间状态。显然这强一致性对全局时钟有非常高的要求。强一致性，只是存在理论中的一致性模型，比它要求更弱一些的，就是顺序一致性。&lt;/p&gt;
&lt;h1 id=&#34;什么使得系统线性一致&#34;&gt;什么使得系统线性一致？&lt;/h1&gt;
&lt;p&gt;线性一致性背后的基本思想很简单：使系统看起来好像只有一个数据副本。然而确切来讲，实际上有更多要操心的地方。为了更好地理解线性一致性，让我们再看几个例子。下图显示了三个客户端在线性一致数据库中同时读写相同的键 x。在分布式系统文献中，x 被称为寄存器（register），例如，它可以是键值存储中的一个键，关系数据库中的一行，或文档数据库中的一个文档。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/12/1biSnf.md.png&#34; alt=&#34;如果读取请求与写入请求并发，则可能会返回旧值或新值&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;每个柱都是由客户端发出的请求，其中柱头是请求发送的时刻，柱尾是客户端收到响应的时刻。因为网络延迟变化无常，客户端不知道数据库处理其请求的精确时间，只知道它发生在发送请求和接收响应的之间的某个时刻。在这个例子中，寄存器有两种类型的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$read(x)⇒v$ 表示客户端请求读取寄存器 x 的值，数据库返回值 v。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$write(x,v)⇒r$ 表示客户端请求将寄存器 x 设置为值 v，数据库返回响应 r（可能正确，可能错误）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;x 的值最初为 0，客户端 C 执行写请求将其设置为 1。发生这种情况时，客户端 A 和 B 反复轮询数据库以读取最新值。A 和 B 的请求可能会收到怎样的响应？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端 A 的第一个读操作，完成于写操作开始之前，因此必须返回旧值 &lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;客户端 A 的最后一个读操作，开始于写操作完成之后。如果数据库是线性一致性的，它必然返回新值 &lt;code&gt;1&lt;/code&gt;：因为读操作和写操作一定是在其各自的起止区间内的某个时刻被处理。如果在写入结束后开始读取，则必须在写入之后处理读取，因此它必须看到写入的新值。&lt;/li&gt;
&lt;li&gt;与写操作在时间上重叠的任何读操作，可能会返回 &lt;code&gt;0&lt;/code&gt;或&lt;code&gt;1&lt;/code&gt;，因为我们不知道读取时，写操作是否已经生效。这些操作是并发（concurrent）的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，这还不足以完全描述线性一致性：如果与写入同时发生的读取可以返回旧值或新值，那么读者可能会在写入期间看到数值在旧值和新值之间来回翻转。这不是我们所期望的仿真“单一数据副本”的系统。为了使系统线性一致，我们需要添加另一个约束：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/12/1biWVS.md.png&#34; alt=&#34;任何一个读取返回新值后，所有后续读取（在相同或其他客户端上）也必须返回新值&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在一个线性一致的系统中，我们可以想象，在 x 的值从 0 自动翻转到 1 的时候（在写操作的开始和结束之间）必定有一个时间点。因此，如果一个客户端的读取返回新的值 1，即使写操作尚未完成，所有后续读取也必须返回新值。上图中的箭头说明了这个时序依赖关系，客户端 A 是第一个读取新的值 1 的位置。在 A 的读取返回之后，B 开始新的读取。由于 B 的读取严格在发生于 A 的读取之后，因此即使 C 的写入仍在进行中，也必须返回 1。除了读写之外，还增加了第三种类型的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$cas(x, v_{old}, v_{new})⇒r$ 表示客户端请求进行原子性的比较与设置操作。如果寄存器 $x$ 的当前值等于 $v_{old}$，则应该原子地设置为 $v_{new}$ 。如果 $x≠v_{old}$，则操作应该保持寄存器不变并返回一个错误。$r$ 是数据库的响应（正确或错误）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图中每个操作都在我们认为执行操作的时候用竖线标出（在每个操作的条柱之内）。这些标记按顺序连在一起，其结果必须是一个有效的寄存器读写序列（每次读取都必须返回最近一次写入设置的值）。线性一致性的要求是，操作标记的连线总是按时间（从左到右）向前移动，而不是向后移动。这个要求确保了我们之前讨论的新鲜性保证：一旦新的值被写入或读取，所有后续的读都会看到写入的值，直到它被再次覆盖。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/12/1bFnxI.md.png&#34; alt=&#34;可视化读取和写入看起来已经生效的时间点，B 的最后读取不是线性一致性的&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个客户端 B 发送一个读取 x 的请求，然后客户端 D 发送一个请求将 x 设置为 0，然后客户端 A 发送请求将 x 设置为 1。尽管如此，返回到 B 的读取值为 1（由 A 写入的值）。这是可以的：这意味着数据库首先处理 D 的写入，然后是 A 的写入，最后是 B 的读取。虽然这不是请求发送的顺序，但这是一个可以接受的顺序，因为这三个请求是并发的。也许 B 的读请求在网络上略有延迟，所以它在两次写入之后才到达数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在客户端 A 从数据库收到响应之前，客户端 B 的读取返回 1，表示写入值 1 已成功。这也是可以的：这并不意味着在写之前读到了值，这只是意味着从数据库到客户端 A 的正确响应在网络中略有延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此模型不假设有任何事务隔离：另一个客户端可能随时更改值。例如，C 首先读取 1，然后读取 2，因为两次读取之间的值由 B 更改。可以使用原子比较并设置（cas）操作来检查该值是否未被另一客户端同时更改：B 和 C 的 cas 请求成功，但是 D 的 cas 请求失败（在数据库处理它时，x 的值不再是 0）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户 B 的最后一次读取（阴影条柱中）不是线性一致性的。该操作与 C 的 cas 写操作并发（它将 x 从 2 更新为 4）。在没有其他请求的情况下，B 的读取返回 2 是可以的。然而，在 B 的读取开始之前，客户端 A 已经读取了新的值 4，因此不允许 B 读取比 A 更旧的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是线性一致性背后的直觉。正式的定义更准确地描述了它。通过记录所有请求和响应的时序，并检查它们是否可以排列成有效的顺序，测试一个系统的行为是否线性一致性是可能的（尽管在计算上是昂贵的）。&lt;/p&gt;
&lt;h1 id=&#34;线性一致性与可序列化&#34;&gt;线性一致性与可序列化&lt;/h1&gt;
&lt;p&gt;线性一致性容易和可序列化相混淆，因为两个词似乎都是类似“可以按顺序排列”的东西。但它们是两种完全不同的保证，区分两者非常重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可序列化：可序列化（Serializability）是事务的隔离属性，每个事务可以读写多个对象（行，文档，记录）。它确保事务的行为，与它们按照某种顺序依次执行的结果相同（每个事务在下一个事务开始之前运行完成）。这种执行顺序可以与事务实际执行的顺序不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线性一致性：线性一致性（Linearizability）是读取和写入寄存器（单个对象）的新鲜度保证。它不会将操作组合为事务，因此它也不会阻止写偏差等问题，除非采取其他措施（例如物化冲突）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个数据库可以提供可串行性和线性一致性，这种组合被称为严格的可串行性或强的单副本强可串行性（strong-1SR）。基于两阶段锁定的可串行化实现或实际串行执行通常是线性一致性的。但是，可序列化的快照隔离不是线性一致性的：按照设计，它可以从一致的快照中进行读取，以避免锁定读者和写者之间的争用。一致性快照的要点就在于它不会包括比快照更新的写入，因此从快照读取不是线性一致性的。&lt;/p&gt;
&lt;h1 id=&#34;线性一致性的案例&#34;&gt;线性一致性的案例&lt;/h1&gt;
&lt;h2 id=&#34;锁定和领导选举&#34;&gt;锁定和领导选举&lt;/h2&gt;
&lt;p&gt;一个使用单主复制的系统，需要确保领导真的只有一个，而不是几个（脑裂）。一种选择领导者的方法是使用锁：每个节点在启动时尝试获取锁，成功者成为领导者。不管这个锁是如何实现的，它必须是线性一致的：所有节点必须就哪个节点拥有锁达成一致，否则就没用了。诸如 Apache ZooKeeper 和 etcd 之类的协调服务通常用于实现分布式锁和领导者选举。它们使用一致性算法，以容错的方式实现线性一致的操作。还有许多微妙的细节来正确地实现锁和领导者选择，而像 Apache Curator 这样的库则通过在 ZooKeeper 之上提供更高级别的配方来提供帮助。但是，线性一致性存储服务是这些协调任务的基础。&lt;/p&gt;
&lt;p&gt;分布式锁也在一些分布式数据库（如 Oracle Real Application Clusters（RAC））中以更细的粒度使用。RAC 对每个磁盘页面使用一个锁，多个节点共享对同一个磁盘存储系统的访问权限。由于这些线性一致的锁处于事务执行的关键路径上，RAC 部署通常具有用于数据库节点之间通信的专用集群互连网络。&lt;/p&gt;
&lt;h2 id=&#34;约束和唯一性保证&#34;&gt;约束和唯一性保证&lt;/h2&gt;
&lt;p&gt;唯一性约束在数据库中很常见：例如，用户名或电子邮件地址必须唯一标识一个用户，而在文件存储服务中，不能有两个具有相同路径和文件名的文件。如果要在写入数据时强制执行此约束（例如，如果两个人试图同时创建一个具有相同名称的用户或文件，其中一个将返回一个错误），则需要线性一致性。这种情况实际上类似于一个锁：当一个用户注册你的服务时，可以认为他们获得了所选用户名的“锁定”。该操作与原子性的比较与设置非常相似：将用户名赋予声明它的用户，前提是用户名尚未被使用。&lt;/p&gt;
&lt;p&gt;如果想要确保银行账户余额永远不会为负数，或者不会出售比仓库里的库存更多的物品，或者两个人不会都预定了航班或剧院里同一时间的同一个位置。这些约束条件都要求所有节点都同意一个最新的值（账户余额，库存水平，座位占用率）。在实际应用中，处理这些限制有时是可以接受的（例如，如果航班超额预订，你可以将客户转移到不同的航班并为其提供补偿）。在这种情况下，可能不需要线性一致性。然而，一个硬性的唯一性约束（关系型数据库中常见的那种）需要线性一致性。其他类型的约束，如外键或属性约束，可以在不需要线性一致性的情况下实现。&lt;/p&gt;
&lt;h2 id=&#34;跨信道的时序依赖&#34;&gt;跨信道的时序依赖&lt;/h2&gt;
&lt;p&gt;例如，假设有一个网站，用户可以上传照片，一个后台进程会调整照片大小，降低分辨率以加快下载速度（缩略图）。图像缩放器需要明确的指令来执行尺寸缩放作业，指令是 Web 服务器通过消息队列发送的。Web 服务器不会将整个照片放在队列中，因为大多数消息代理都是针对较短的消息而设计的，而一张照片的空间占用可能达到几兆字节。取而代之的是，首先将照片写入文件存储服务，写入完成后再将缩放器的指令放入消息队列。该系统的架构和数据流如下图所示。&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/12/1babyn.png&#34; alt=&#34;Web服务器和图像调整器通过文件存储和消息队列进行通信，打开竞争条件的可能性&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果文件存储服务是线性一致的，那么这个系统应该可以正常工作。如果它不是线性一致的，则存在竞争条件的风险：消息队列（步骤 3 和 4）可能比存储服务内部的复制更快。在这种情况下，当缩放器读取图像（步骤 5）时，可能会看到图像的旧版本，或者什么都没有。如果它处理的是旧版本的图像，则文件存储中的全尺寸图和略缩图就产生了永久性的不一致。出现这个问题是因为 Web 服务器和缩放器之间存在两个不同的信道：文件存储与消息队列。没有线性一致性的新鲜性保证，这两个信道之间的竞争条件是可能的。线性一致性并不是避免这种竞争条件的唯一方法，但它是最容易理解的。如果你可以控制额外信道，则可以使用在“读己之写”讨论过的备选方法，不过会有额外的复杂度代价。&lt;/p&gt;
&lt;h1 id=&#34;实现线性一致的系统&#34;&gt;实现线性一致的系统&lt;/h1&gt;
&lt;p&gt;我们已经见到了几个线性一致性有用的例子，让我们思考一下，如何实现一个提供线性一致语义的系统。由于线性一致性本质上意味着“表现得好像只有一个数据副本，而且所有的操作都是原子的”，所以最简单的答案就是，真的只用一个数据副本。但是这种方法无法容错：如果持有该副本的节点失效，数据将会丢失，或者至少无法访问，直到节点重新启动。&lt;/p&gt;
&lt;h2 id=&#34;单主复制可能线性一致&#34;&gt;单主复制（可能线性一致）&lt;/h2&gt;
&lt;p&gt;在具有单主复制功能的系统中，主库具有用于写入的数据的主副本，而追随者在其他节点上保留数据的备份副本。如果从主库或同步更新的从库读取数据，它们可能（protential）是线性一致性的。然而，并不是每个单主数据库都是实际线性一致性的，无论是通过设计（例如，因为使用快照隔离）还是并发错误。对单领域数据库进行分区（分片），以便每个分区有一个单独的领导者，不会影响线性一致性，因为线性一致性只是对单一对象的保证。&lt;/p&gt;
&lt;p&gt;从主库读取依赖一个假设，你确定领导是谁。正如在“真理在多数人手中”中所讨论的那样，一个节点很可能会认为它是领导者，而事实上并非如此——如果具有错觉的领导者继续为请求提供服务，可能违反线性一致性。使用异步复制，故障切换时甚至可能会丢失已提交的写入，这同时违反了持久性和线性一致性。&lt;/p&gt;
&lt;h2 id=&#34;共识算法线性一致&#34;&gt;共识算法（线性一致）&lt;/h2&gt;
&lt;p&gt;共识算法与单领导者复制类似。然而，共识协议包含防止脑裂和陈旧副本的措施。由于这些细节，共识算法可以安全地实现线性一致性存储。例如，Zookeeper 和 etcd 就是这样工作的。&lt;/p&gt;
&lt;h2 id=&#34;多主复制非线性一致&#34;&gt;多主复制（非线性一致）&lt;/h2&gt;
&lt;p&gt;具有多主程序复制的系统通常不是线性一致的，因为它们同时在多个节点上处理写入，并将其异步复制到其他节点。因此，它们可能会产生冲突的写入，需要解析。这种冲突是因为缺少单一数据副本人为产生的。&lt;/p&gt;
&lt;h2 id=&#34;无主复制也许不是线性一致的&#34;&gt;无主复制（也许不是线性一致的）&lt;/h2&gt;
&lt;p&gt;对于无领导者复制的系统，有时候人们会声称通过要求法定人数读写（$w + r&amp;gt; n$）可以获得“强一致性”。这取决于法定人数的具体配置，以及强一致性如何定义（通常不完全正确）。直觉上在 Dynamo 风格的模型中，严格的法定人数读写应该是线性一致性的。但是当我们有可变的网络延迟时，就可能存在竞争条件：&lt;/p&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/12/1bwC4S.md.png&#34; alt=&#34;非线性一致的执行，尽管使用了严格的法定人数&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上图中 $x$ 的初始值为 0，写入客户端通过向所有三个副本（$n = 3, w = 3$）发送写入将 $x$ 更新为 1。客户端 A 并发地从两个节点组成的法定人群（$r = 2$）中读取数据，并在其中一个节点上看到新值 1 。客户端 B 也并发地从两个不同的节点组成的法定人数中读取，并从两个节点中取回了旧值 0 。&lt;/p&gt;
&lt;p&gt;仲裁条件满足（$w + r&amp;gt; n$），但是这个执行是非线性一致的：B 的请求在 A 的请求完成后开始，但是 B 返回旧值，而 A 返回新值。有趣的是，通过牺牲性能，可以使 Dynamo 风格的法定人数线性化：读取者必须在将结果返回给应用之前，同步执行读修复，并且写入者必须在发送写入之前，读取法定数量节点的最新状态。然而，由于性能损失，Riak 不执行同步读修复。Cassandra 在进行法定人数读取时，确实在等待读修复完成；但是由于使用了最后写入为准的冲突解决方案，当同一个键有多个并发写入时，将不能保证线性一致性。而且，这种方式只能实现线性一致的读写；不能实现线性一致的比较和设置操作，因为它需要一个共识算法。总而言之，最安全的做法是：假设采用 Dynamo 风格无主复制的系统不能提供线性一致性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>因果一致性</title>
      <link>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h1 id=&#34;casual-consistency--因果一致性&#34;&gt;Casual Consistency | 因果一致性&lt;/h1&gt;
&lt;p&gt;如果 A 进程在更新之后向 B 进程通知更新的完成，那么 B 的访问操作将会返回更新的值。如果没有因果关系的 C 进程将会遵循最终一致性的规则。因果一致性(Casual Consistency)在一致性的要求上，又比顺序一致性降低了：它仅要求有因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓。&lt;/p&gt;
&lt;p&gt;因果相关的要求是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地顺序：本进程中，事件执行的顺序即为本地因果顺序。&lt;/li&gt;
&lt;li&gt;异地顺序：如果读操作返回的是写操作的值，那么该写操作在顺序上一定在读操作之前。&lt;/li&gt;
&lt;li&gt;闭包传递：和时钟向量里面定义的一样，如果 a-&amp;gt;b，b-&amp;gt;c，那么肯定也有 a-&amp;gt;c。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.postimg.cc/MpMvbfpx/image.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;图 a 满足顺序一致性，因此也满足因果一致性，因为从这个系统中的四个进程的角度看，它们都有相同的顺序也有相同的因果关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图 b 满足因果一致性但是不满足顺序一致性，这是因为从进程 P3、P4 看来，进程 P1、P2 上的操作因果有序，因为 P1、P2 上的写操作不存在因果关系，所以它们可以任意执行。不满足一致性的原因，同上面一样是可以推导出冲突的情况来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;顺序和因果&#34;&gt;顺序和因果&lt;/h1&gt;
&lt;p&gt;顺序反复出现有几个原因，其中一个原因是，它有助于保持因果关系（causality）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个对话的观察者首先看到问题的答案，然后才看到被回答的问题。这是令人困惑的，因为它违背了我们对因（cause）与果（effect）的直觉：如果一个问题被回答，显然问题本身得先在那里，因为给出答案的人必须看到这个问题（假如他们并没有预见未来的超能力）。我们认为在问题和答案之间存在因果依赖（causal dependency）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三位领导者之间的复制，并注意到由于网络延迟，一些写入可能会“压倒”其他写入。从其中一个副本的角度来看，好像有一个对尚不存在的记录的更新操作。这里的因果意味着，一条记录必须先被创建，然后才能被更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在并发写入中，如果有两个操作 A 和 B，则存在三种可能性：A 发生在 B 之前，或 B 发生在 A 之前，或者 A 和 B 并发。这种此前发生（happened before）关系是因果关系的另一种表述：如果 A 在 B 前发生，那么意味着 B 可能已经知道了 A，或者建立在 A 的基础上，或者依赖于 A。如果 A 和 B 是并发的，那么它们之间并没有因果联系；换句话说，我们确信 A 和 B 不知道彼此。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在事务快照隔离的上下文中，我们说事务是从一致性快照中读取的。但此语境中“一致”到底又是什么意思？这意味着与因果关系保持一致（consistent with causality）：如果快照包含答案，它也必须包含被回答的问题。在某个时间点观察整个数据库，与因果关系保持一致意味着：因果上在该时间点之前发生的所有操作，其影响都是可见的，但因果上在该时间点之后发生的操作，其影响对观察者不可见。读偏差（read skew）意味着读取的数据处于违反因果关系的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务之间写偏差（write skew）的例子也说明了因果依赖：爱丽丝被允许离班，因为事务认为鲍勃仍在值班，反之亦然。在这种情况下，离班的动作因果依赖于对当前值班情况的观察。可序列化的快照隔离通过跟踪事务之间的因果依赖来检测写偏差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在爱丽丝和鲍勃看球的例子中，在听到爱丽丝惊呼比赛结果后，鲍勃从服务器得到陈旧结果的事实违背了因果关系：爱丽丝的惊呼因果依赖于得分宣告，所以鲍勃应该也能在听到爱丽斯惊呼后查询到比分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因果关系对事件施加了一种顺序：因在果之前；消息发送在消息收取之前。而且就像现实生活中一样，一件事会导致另一件事：某个节点读取了一些数据然后写入一些结果，另一个节点读取其写入的内容，并依次写入一些其他内容，等等。这些因果依赖的操作链定义了系统中的因果顺序，即，什么在什么之前发生。如果一个系统服从因果关系所规定的顺序，我们说它是因果一致（causally）的。例如，快照隔离提供了因果一致性：当你从数据库中读取到一些数据时，你一定还能够看到其因果前驱（假设在此期间这些数据还没有被删除）。&lt;/p&gt;
&lt;h1 id=&#34;因果顺序不是全序的&#34;&gt;因果顺序不是全序的&lt;/h1&gt;
&lt;p&gt;全序（total order）允许任意两个元素进行比较，所以如果有两个元素，你总是可以说出哪个更大，哪个更小。例如，自然数集是全序的：给定两个自然数，比如说 5 和 13，那么你可以告诉我，13 大于 5。然而数学集合并不完全是全序的：{a, b} 比 {b, c} 更大吗？好吧，你没法真正比较它们，因为二者都不是对方的子集。我们说它们是无法比较（incomparable）的，因此数学集合是偏序（partially order）的：在某些情况下，可以说一个集合大于另一个（如果一个集合包含另一个集合的所有元素），但在其他情况下它们是无法比较的。&lt;/p&gt;
&lt;p&gt;全序和偏序之间的差异反映在不同的数据库一致性模型中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线性一致性：在线性一致的系统中，操作是全序的：如果系统表现的就好像只有一个数据副本，并且所有操作都是原子性的，这意味着对任何两个操作，我们总是能判定哪个操作先发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因果性：如果两个操作都没有在彼此之前发生，那么这两个操作是并发的。换句话说，如果两个事件是因果相关的（一个发生在另一个事件之前），则它们之间是有序的，但如果它们是并发的，则它们之间的顺序是无法比较的。这意味着因果关系定义了一个偏序，而不是一个全序：一些操作相互之间是有顺序的，但有些则是无法比较的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，根据这个定义，在线性一致的数据存储中是不存在并发操作的：必须有且仅有一条时间线，所有的操作都在这条时间线上，构成一个全序关系。可能有几个请求在等待处理，但是数据存储确保了每个请求都是在唯一时间线上的某个时间点自动处理的，不存在任何并发。并发意味着时间线会分岔然后合并，在这种情况下，不同分支上的操作是无法比较的（即并发操作）。如果你熟悉像 Git 这样的分布式版本控制系统，那么其版本历史与因果关系图极其相似。通常，一个提交（Commit）发生在另一个提交之后，在一条直线上。但是有时你会遇到分支（当多个人同时在一个项目上工作时），合并（Merge）会在这些并发创建的提交相融合时创建。&lt;/p&gt;
&lt;h2 id=&#34;线性一致性强于因果一致性&#34;&gt;线性一致性强于因果一致性&lt;/h2&gt;
&lt;p&gt;线性一致性隐含着（implies）因果关系：任何线性一致的系统都能正确保持因果性。特别是，如果系统中有多个通信通道，线性一致性可以自动保证因果性，系统无需任何特殊操作（如在不同组件间传递时间戳）。线性一致性确保因果性的事实使线性一致系统变得简单易懂，更有吸引力。不过使系统线性一致可能会损害其性能和可用性，尤其是在系统具有严重的网络延迟的情况下（例如，如果系统在地理上散布）。出于这个原因，一些分布式数据系统已经放弃了线性一致性，从而获得更好的性能，但它们用起来也更为困难。&lt;/p&gt;
&lt;p&gt;好消息是存在折衷的可能性。线性一致性并不是保持因果性的唯一途径，还有其他方法。一个系统可以是因果一致的，而无需承担线性一致带来的性能折损（尤其对于 CAP 定理不适用的情况）。实际上在所有的不会被网络延迟拖慢的一致性模型中，因果一致性是可行的最强的一致性模型。而且在网络故障时仍能保持可用。&lt;/p&gt;
&lt;p&gt;在许多情况下，看上去需要线性一致性的系统，实际上需要的只是因果一致性，因果一致性可以更高效地实现。基于这种观察结果，研究人员正在探索新型的数据库，既能保证因果一致性，且性能与可用性与最终一致的系统类似。&lt;/p&gt;
&lt;h2 id=&#34;捕获因果关系&#34;&gt;捕获因果关系&lt;/h2&gt;
&lt;p&gt;为了维持因果性，你需要知道哪个操作发生在哪个其他操作之前（happened before）。这是一个偏序：并发操作可以以任意顺序进行，但如果一个操作发生在另一个操作之前，那它们必须在所有副本上以那个顺序被处理。因此，当一个副本处理一个操作时，它必须确保所有因果前驱的操作（之前发生的所有操作）已经被处理；如果前面的某个操作丢失了，后面的操作必须等待，直到前面的操作被处理完毕。&lt;/p&gt;
&lt;p&gt;为了确定因果依赖，我们需要一些方法来描述系统中节点的“知识”。如果节点在发出写入 Y 的请求时已经看到了 X 的值，则 X 和 Y 可能存在因果关系。这个分析使用了那些在欺诈指控刑事调查中常见的问题：CEO 在做出决定 Y 时是否知道 X ？因果一致性需要跟踪整个数据库中的因果依赖，而不仅仅是一个键，可以推广版本向量以解决此类问题。为了确定因果顺序，数据库需要知道应用读取了哪个版本的数据。在 SSI 的冲突检测中会出现类似的想法，如可序列化的快照隔离（SSI）中所述：当事务要提交时，数据库将检查它所读取的数据版本是否仍然是最新的。为此，数据库跟踪哪些数据被哪些事务所读取。&lt;/p&gt;
&lt;h1 id=&#34;案例分析&#34;&gt;案例分析&lt;/h1&gt;
&lt;p&gt;在 InfoQ 分享的腾讯朋友圈的设计中，他们在设计数据一致性的时候，使用了因果一致性这个模型。用于保证对同一条朋友圈的回复的一致性，比如这样的情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A 发了朋友圈内容为梅里雪山的图片。&lt;/li&gt;
&lt;li&gt;B 针对内容 a 回复了评论：“这里是哪里？”&lt;/li&gt;
&lt;li&gt;C 针对 B 的评论进行了回复：”这里是梅里雪山“。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，这条朋友圈的显示中，显然 C 针对 B 的评论，应该在 B 的评论之后，这是一个因果关系，而其他没有因果关系的数据，可以允许不一致。微信的做法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个数据中心，都自己生成唯一的、递增的数据 ID，确保能排重。在下图的示例中，有三个数据中心，数据中心 1 生成的数据 ID 模 1 为 0，数据中心 1 生成的数据 ID 模 2 为 0，数据中心 1 生成的数据 ID 模 3 为 0，这样保证了三个数据中心的数据 ID 不会重复全局唯一。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每条评论都比本地看到所有全局 ID 大，这样来确保因果关系，这部分的原理前面提到的向量时钟一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
















  &lt;figure  &gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz/vxCq1iahXotiaFs84SvDRF5U3gefsfA2F8cp2O082gPUZEbkiawXfogQ3DI8ghhhtFZqicbatRvrklGwxe8JlmrlOw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有了这个模型和原理，就很好处理前面针对评论的评论的顺序问题了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;假设 B 在数据中心 1 上，上面的 ID 都满足模 1 为 0，那么当 B 看到 A 的朋友圈时，发表了评论，此时给这个评论分配的 ID 是 1，因此 B 的时钟向量数据是[1]。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设 C 在数据中心 2 上，上面的 ID 都满足模 2 为 0，当 C 看到了 B 的评论时，针对这个评论做了评论，此时需要给这个评论分配的 ID 肯定要满足模 2 为 0 以及大于 1，评论完毕之后 C 上面的时钟向量是[1,2]。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设 A 在数据中心 3 上，上面的 ID 都满足模 3 为 0，当 A 看到 B、C 给自己的评论时，很容易按照 ID 进行排序和合并&amp;ndash;即使 A 在收到 C 的数据[1,2]之后再收到 B 的数据[1]，也能顺利的完成合并。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>最终一致性</title>
      <link>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ng-tech.icu/books/distributedsystem-series/%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h1 id=&#34;最终一致性&#34;&gt;最终一致性&lt;/h1&gt;
&lt;p&gt;弱一致性的特定形式，系统保证用户最终能够读取到某个操作对系统的更新。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。&lt;/p&gt;
&lt;p&gt;最终一致性同样存在着很多的变种，最终一致性的不同方式可以进行组合，例如单调读一致性和读己之所写一致性就可以组合实现。并且从实践的角度来看，这两者的组合，读取自己更新的数据，和一旦读取到最新的版本不会再读取旧版本，对于此架构上的程序开发来说，会少很多额外的烦恼。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
