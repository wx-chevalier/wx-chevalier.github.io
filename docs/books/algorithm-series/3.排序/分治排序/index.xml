<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分治排序 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%8E%92%E5%BA%8F/%E5%88%86%E6%B2%BB%E6%8E%92%E5%BA%8F/</link><atom:link href="https://ng-tech.icu/books/algorithm-series/3.%E6%8E%92%E5%BA%8F/%E5%88%86%E6%B2%BB%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml"/><description>分治排序</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>分治排序</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%8E%92%E5%BA%8F/%E5%88%86%E6%B2%BB%E6%8E%92%E5%BA%8F/</link></image><item><title>归并排序</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%8E%92%E5%BA%8F/%E5%88%86%E6%B2%BB%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/algorithm-series/3.%E6%8E%92%E5%BA%8F/%E5%88%86%E6%B2%BB%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="归并排序">归并排序&lt;/h1>
&lt;p>合并排序也是典型的分而治之的思想，其将复杂的问题分割为多个子问题，对子问题分别求解然后合并为最终的结果。合并排序主要包含两个步骤：分割与合并，将两个长为 N/2 的有序数组，在 N 个操作内合并为某个长为 N 的有序数组。在分割过程中，数组会被逐步切分为多个单元数组，而在合并过程中，会从单元数组开始逐步向上合并。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://i.postimg.cc/NFLkJtfq/image.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="算法思想">算法思想&lt;/h2>
&lt;p>归并排序的步骤如下：&lt;/p>
&lt;ul>
&lt;li>判断参数的有效性，也就是递归的出口；&lt;/li>
&lt;li>首先什么都不管，直接把数组平分成两个子数组；&lt;/li>
&lt;li>递归调用划分数组函数，最后划分到数组中只有一个元素，这也意味着数组是有序的了；&lt;/li>
&lt;li>然后调用排序函数，把两个有序的数组合并成一个有序的数组；&lt;/li>
&lt;li>排序函数的步骤，让两个数组的元素进行比较，把大的/小的元素存放到临时数组中，如果有一个数组的元素被取光了，那就直接把另一数组的元素放到临时数组中，然后把临时数组中的元素都复制到实际的数组中；&lt;/li>
&lt;/ul>
&lt;p>归并排序的伪代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">array&lt;/span> &lt;span class="nx">mergeSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">array&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">end&lt;/span> &lt;span class="k">if&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// recursive calls
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">left_array&lt;/span> &lt;span class="nx">right_array&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">split_into_2_equally_sized_arrays&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">array&lt;/span> &lt;span class="nx">new_left_array&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">mergeSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">left_array&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">array&lt;/span> &lt;span class="nx">new_right_array&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">mergeSort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">right_array&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// merging the 2 small ordered arrays into a big one
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">array&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">new_left_array&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">new_right_array&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="复杂度与稳定性">复杂度与稳定性&lt;/h2>
&lt;p>归并排序的时间复杂度主要体现在两个方面，分别是数组划分函数 mergeSort 与有序数组归并函数 merge。其中 merge 函数的时间复杂度为 O(n)，因为代码中有 2 个长度为 n 的循环(非嵌套)，所以时间复杂度则为 O(n)。归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：&lt;code>n + logn&lt;/code>，所以空间复杂度为 &lt;code>O(n)&lt;/code>。&lt;/p>
&lt;p>归并排序被广泛使用在数据库引擎中，因为其包含以下特性：&lt;/p>
&lt;ul>
&lt;li>合并排序也是所谓的 In-place 算法，我们可以通过直接修改输入序列而不不是创建新的序列来节省内存空间&lt;/li>
&lt;li>合并排序并不需要将所有的数据都加载到内存中，可以只向内存中加载当前处理的部分，在仅仅 100MB 的内存缓冲区内排序一个几个 GB 的表；从而同时使用磁盘空间和少量内存而避免巨量磁盘 IO。&lt;/li>
&lt;li>合并排序支持并发操作，能够在多处理器、多线程以及多服务器上运行。&lt;/li>
&lt;/ul>
&lt;h2 id="代码实现">代码实现&lt;/h2></description></item><item><title>快速排序</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%8E%92%E5%BA%8F/%E5%88%86%E6%B2%BB%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/algorithm-series/3.%E6%8E%92%E5%BA%8F/%E5%88%86%E6%B2%BB%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="快速排序">快速排序&lt;/h1>
&lt;p>快速排序由 C. A. R. Hoare 在 1962 年提出。它的基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p>
&lt;p>核心思想:&lt;/p>
&lt;ul>
&lt;li>在待排序的元素任取一个元素作为基准(通常选第一个元素，称为基准元素）&lt;/li>
&lt;li>将待排序的元素进行分块，比基准元素大的元素移动到基准元素的右侧，比基准元素小的移动到作左侧，从而一趟排序过程，就可以锁定基准元素的最终位置&lt;/li>
&lt;li>对左右两个分块重复以上步骤直到所有元素都是有序的（递归过程）&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://pic.imgdb.cn/item/611783105132923bf885c6c6.jpg" alt="快速排序图解" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h1 id="复杂度与稳定性">复杂度与稳定性&lt;/h1>
&lt;h1 id="代码实现">代码实现&lt;/h1>
&lt;h2 id="java">Java&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">partition&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 选定左侧的为标杆
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">pivotKey&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从右侧开始,寻找到第一个小于标杆的数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">pivotKey&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span>&lt;span class="o">--;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 把小的移动到左边
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从左侧开始,寻找到第一个大于标杆的数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">pivotKey&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 把大的移动到右边
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 到这里 left 和 right 必然重合
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">assert&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后把 pivot 赋值到中间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pivotKey&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// QuickSort.sort(arr);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 判断是否只剩下最后一个数了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果还有多个数,则先进行划分,划分的结果即是左侧肯定比右侧小
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">pivotPos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">partition&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 对于左侧进行排序
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">pivotPos&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 对于右侧进行排序
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">pivotPos&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>