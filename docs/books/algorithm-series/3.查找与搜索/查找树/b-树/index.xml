<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>B 树 | Next-gen Tech Edu</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/%E6%9F%A5%E6%89%BE%E6%A0%91/b-%E6%A0%91/</link><atom:link href="https://ng-tech.icu/books/algorithm-series/3.%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/%E6%9F%A5%E6%89%BE%E6%A0%91/b-%E6%A0%91/index.xml" rel="self" type="application/rss+xml"/><description>B 树</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><image><url>https://ng-tech.icu/media/sharing.png</url><title>B 树</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/%E6%9F%A5%E6%89%BE%E6%A0%91/b-%E6%A0%91/</link></image><item><title>B-Tree</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/%E6%9F%A5%E6%89%BE%E6%A0%91/b-%E6%A0%91/b-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/algorithm-series/3.%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/%E6%9F%A5%E6%89%BE%E6%A0%91/b-%E6%A0%91/b-tree/</guid><description>&lt;h1 id="b-tree">B-Tree&lt;/h1>
&lt;p>为了描述 B-Tree，首先定义一条数据记录为一个二元组[key, data]，key 为记录的键值，对于不同数据记录，key 是互不相同的；data 为数据记录除 key 外的数据。&lt;/p>
&lt;p>那么 B-Tree 是满足下列条件的数据结构：&lt;/p>
&lt;ul>
&lt;li>一个节点中的 key 从左到右非递减排列。所有节点组成树结构。每个指针要么为 null，要么指向另外一个节点。&lt;/li>
&lt;li>每个叶节点最少包含一个 key 和两个指针，最多包含 2d-1 个 key 和 2d 个指针。key 和指针互相间隔，节点两端是指针。&lt;/li>
&lt;li>叶子节点的指针均为 null，所有子叶节点具有相同的深度，等于树高 h。&lt;/li>
&lt;/ul>
&lt;p>B-Tree 还中的父子节点还满足以下排序规则：&lt;/p>
&lt;ul>
&lt;li>如果某个指针在节点 node 最左边且不为 null，则其指向节点的所有 key 小于 v(key1)，其中 v(key1)为 node 的第一个 key 的值。&lt;/li>
&lt;li>如果某个指针在节点 node 最右边且不为 null，则其指向节点的所有 key 大于 v(keym)，其中 v(keym)为 node 的最后一个 key 的值。&lt;/li>
&lt;li>如果某个指针在节点 node 的左右相邻 key 分别是 keyi 和 keyi+1 且不为 null，则其指向节点的所有 key 小于 v(keyi+1)且大于 v(keyi)。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://assets.ng-tech.icu/item/20230407224316.png" alt="B-Tree 示意" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由于 B-Tree 的特性，在 B-Tree 中按 key 检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败。B-Tree 上查找算法的伪代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">BTree_Search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">returnnull&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">==&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nf">BTree_Search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nf">BTree_Search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="nf">BTree_Search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">my_key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于 B-Tree 有一系列有趣的性质，例如一个度为 d 的 B-Tree，设其索引 N 个 key，则其树高 h 的上限为 logd((N+1)/2)，检索一个 key，其查找节点个数的渐进复杂度为 O(logdN)。从这点可以看出，B-Tree 是一个非常有效率的索引数据结构。&lt;/p></description></item><item><title>B+Tree</title><link>https://ng-tech.icu/books/algorithm-series/3.%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/%E6%9F%A5%E6%89%BE%E6%A0%91/b-%E6%A0%91/b+tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ng-tech.icu/books/algorithm-series/3.%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%90%9C%E7%B4%A2/%E6%9F%A5%E6%89%BE%E6%A0%91/b-%E6%A0%91/b+tree/</guid><description>&lt;h1 id="b-树">B+ 树&lt;/h1>
&lt;p>刚才讨论的日志结构索引正处在逐渐被接受的阶段，但它们并不是最常见的索引类型。使用最广泛的索引结构在 1970 年被引入，不到 10 年后变得“无处不在”，B 树经受了时间的考验。在几乎所有的关系数据库中，它们仍然是标准的索引实现，许多非关系数据库也使用它们。&lt;/p>
&lt;p>像 SSTables 一样，B 树保持按键排序的键值对，这允许高效的键值查找和范围查询。但这就是相似之处的结尾：B 树有着非常不同的设计理念。我们前面看到的日志结构索引将数据库分解为可变大小的段，通常是几兆字节或更大的大小，并且总是按顺序编写段。相比之下，B 树将数据库分解成固定大小的块或页面，传统上大小为 4KB（有时会更大），并且一次只能读取或写入一个页面。这种设计更接近于底层硬件，因为磁盘也被安排在固定大小的块中。&lt;/p>
&lt;p>每个页面都可以使用地址或位置来标识，这允许一个页面引用另一个页面：类似于指针，但在磁盘而不是在内存中。我们可以使用这些页面引用来构建一个页面树：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://s2.ax1x.com/2020/02/06/1y1Y1U.md.png" alt="使用 B 树索引查找一个键" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>一个页面会被指定为 B 树的根；在索引中查找一个键时，就从这里开始。该页面包含几个键和对子页面的引用。每个子页面负责一段连续范围的键，引用之间的键，指明了引用子页面的键范围。譬如在上例中，我们正在寻找关键字 251，所以我们知道我们需要遵循边界 200 和 300 之间的页面引用。这将我们带到一个类似的页面，进一步打破了 200 - 300 到子范围。最后，我们可以看到包含单个键（叶页）的页面，该页面包含每个键的内联值，或者包含对可以找到值的页面的引用。&lt;/p>
&lt;h1 id="btree">B+Tree&lt;/h1>
&lt;p>B-Tree 有许多变种，其中最常见的是 B+Tree，例如 MySQL 就普遍使用 B+Tree 实现其索引结构。与 B-Tree 相比，B+Tree 有以下不同点：&lt;/p>
&lt;ul>
&lt;li>每个节点的指针上限为 2d 而不是 2d+1。&lt;/li>
&lt;li>内节点不存储 data，只存储 key；叶子节点不存储指针。&lt;/li>
&lt;/ul>
&lt;p>下图是一个简单的 B+Tree 示意。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://ww1.sinaimg.cn/large/007rAy9hly1g162uiayzzj30cq037jrf.jpg" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;p>由于并不是所有节点都具有相同的域，因此 B+Tree 中叶节点和内节点一般大小不同。这点与 B-Tree 不同，虽然 B-Tree 中不同节点存放的 key 和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中 B-Tree 往往对每个节点申请同等大小的空间。&lt;/p>
&lt;p>一般来说，B+Tree 比 B-Tree 更适合实现外存储索引结构。&lt;/p></description></item></channel></rss>