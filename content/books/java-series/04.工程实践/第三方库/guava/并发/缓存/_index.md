
---
title: 缓存
linktitle: 缓存
type: book
commentable: true
---

# Guava 缓存

缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用。在日长开发有很多场合，有一些数据量不是很大，不会经常改动，并且访问非常频繁。但是由于受限于硬盘 IO 的性能或者远程网络等原因获取可能非常的费时。会导致我们的程序非常缓慢，这在某些业务上是不能忍的！而缓存正是解决这类问题的神器！

缓存在很多系统和架构中都用广泛的应用,例如：

- CPU 缓存
- 操作系统缓存
- HTTP 缓存
- 数据库缓存
- 静态文件缓存
- 本地缓存
- 分布式缓存

可以说在计算机和网络领域，缓存是无处不在的。可以这么说，只要有硬件性能不对等，涉及到网络传输的地方都会有缓存的身影。缓存总体可分为两种 集中式缓存 和 分布式缓存，“集中式缓存"与"分布式缓存"的区别其实就在于“集中”与"非集中"的概念，其对象可能是服务器、内存条、硬盘等。

# 和 Map 比较

Guava Cache 与 ConcurrentMap 很相似，但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache 为了限制内存占用，通常都设定为自动回收元素。在某些场景下，尽管 LoadingCache 不回收元素，它也是很有用的，因为它会自动加载缓存。

Guava Cache 是在内存中缓存数据，相比较于数据库或 redis 存储，访问内存中的数据会更加高效。Guava 官网介绍，下面的这几种情况可以考虑使用 Guava Cache：

- 愿意消耗一些内存空间来提升速度。
- 预料到某些键会被多次查询。
- 缓存中存放的数据总量不会超出内存容量。

所以，可以将程序频繁用到的少量数据存储到 Guava Cache 中，以改善程序性能。看一下三种基于时间的清理或刷新缓存数据的方式：

- expireAfterAccess： 当缓存项在指定的时间段内没有被读或写就会被回收。
- expireAfterWrite：当缓存项在指定的时间段内没有更新就会被回收。
- refreshAfterWrite：当缓存项上一次更新操作之后的多久会被刷新。

    