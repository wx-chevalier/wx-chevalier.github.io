
---
title: 顺序一致性
linktitle: 顺序一致性
type: book
commentable: true
---

# 顺序一致性

顺序一致性（Sequential Consistency），也同样有两个条件，其一与前面强一致性的要求一样，也是可以马上读到最近写入的数据，然而它的第二个条件就弱化了很多，它允许系统中的所有进程形成自己合理的统一的一致性，不需要与全局时钟下的顺序都一致。这里的第二个条件的要点在于：

- 系统的所有进程的顺序一致，而且是合理的，就是说任何一个进程中，这个进程对同一个变量的读写顺序要保持，然后大家形成一致。
- 不需要与全局时钟下的顺序一致。

可见，顺序一致性在顺序要求上并没有那么严格，它只要求系统中的所有进程达成自己认为的一致就可以了，即错的话一起错，对的话一起对，同时不违反程序的顺序即可，并不需要个全局顺序保持一致。

![](https://i.postimg.cc/8CZ9pcLJ/image.png)

- 图 a 是满足顺序一致性，但是不满足强一致性的。原因在于，从全局时钟的观点来看，P2 进程对变量 X 的读操作在 P1 进程对变量 X 的写操作之后，然而读出来的却是旧的数据。但是这个图却是满足顺序一致性的，因为两个进程 P1,P2 的一致性并没有冲突。从这两个进程的角度来看，顺序应该是这样的：Write(y,2), Read(x,0), Write(x,4), Read(y,2)，每个进程内部的读写顺序都是合理的，但是显然这个顺序与全局时钟下看到的顺序并不一样。

- 图 b 满足强一致性，因为每个读操作都读到了该变量的最新写的结果，同时两个进程看到的操作顺序与全局时钟的顺序一样，都是 Write(y,2), Read(x,4), Write(x,4), Read(y,2)。

- 图 c 不满足顺序一致性，当然也就不满足强一致性了。因为从进程 P1 的角度看，它对变量 Y 的读操作返回了结果 0。那么就是说，P1 进程的对变量 Y 的读操作在 P2 进程对变量 Y 的写操作之前，这意味着它认为的顺序是这样的：write(x,4), Read(y,0), Write(y,2), Read(x,0)，显然这个顺序又是不能被满足的，因为最后一个对变量 x 的读操作读出来也是旧的数据。因此这个顺序是有冲突的，不满足顺序一致性。

# 顺序保证

线性一致寄存器的行为就好像只有单个数据副本一样，且每个操作似乎都是在某个时间点以原子性的方式生效的。这个定义意味着操作是按照某种良好定义的顺序执行的。我们通过操作（似乎）执行完毕的顺序来连接操作。顺序这个词也曾反复地出现：

- 领导者在单主复制中的主要目的就是，在复制日志中确定写入顺序（order of write），也就是从库应用这些写入的顺序。如果不存在一个领导者，则并发操作可能导致冲突。

- 可序列化，是关于事务表现的像按某种序列顺序（some sequential order）执行的保证。它可以通过字面意义上地序列顺序（serial order）执行事务来实现，或者通过允许并行执行，同时防止序列化冲突来实现（通过锁或中止事务）。

- 在分布式系统中使用时间戳和时钟是另一种将顺序引入无序世界的尝试，例如，确定两个写入操作哪一个更晚发生。

顺序，线性一致性和共识之间有着深刻的联系。

    