
---
title: 碰撞解决
linktitle: 碰撞解决
type: book
commentable: true
---

# 哈希碰撞解决

两个不同的输入值，根据同一散列函数计算出的哈希值相同的现象叫做碰撞。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：

- 开放定址法：开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要哈希表足够大，空的散列地址总能找到，并将记录存入。
- 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。
- 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。
- 建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

# 开放定址法

所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要哈希表足够大，空的散列地址总能找到，并将记录存入。公式为：

```
fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)
```

用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在哈希表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一 个开放的地址(即该地址单元为空)为止(若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元)。查找时探测到开放的地址则表明表中无待查 的关键字，即查找失败。比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},表长为 12。我们用散列函数 f(key) = key mod l2。

当计算前 S 个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入：

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_04.png)

计算 key = 37 时，发现 f(37) = 1，此时就与 25 所在的位置冲突。

于是我们应用上面的公式 f(37) = (f(37)+1) mod 12 = 2。于是将 37 存入下标为 2 的位置。这其实就是房子被人买了于是买下一间的作法：。

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_05.png)

接下来 22,29,15,47 都没有冲突，正常的存入：

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_06.png)

到了 key=48，我们计算得到 f(48) = 0，与 12 所在的 0 位置冲突了，不要紧，我们 f(48) = (f(48)+1) mod 12 = 1，此时又与 25 所在的位置冲突。于是 f(48) = (f(48)+2) mod 12=2，还是冲突……一直到 f(48) = (f(48)+6) mod 12 = 6 时，才有空位，机不可失，赶快存入：

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_07.png)

我们把这种解决冲突的开放定址法称为[线性探测](http://www.nowamagic.net/academy/tag/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B)法。

从这个例子我们也看到，我们在解决冲突的时候，还会碰到如 48 和 37 这种本来都不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是査找效率都会大大降低。

## 二次探测法

考虑深一步，如果发生这样的情况，当最后一个 key=34，f(key)=10,与 22 所在的位置冲突，可是 22 后面没有空位置了，反而它的前面有一个空位置，尽管可以 不断地求余数后得到结果，但效率很差。因此我们可以改进 di = 12, -12, 22, -22,……, q2, -q2 (q <= m/2),这样就等于是可以双向寻找到可能的空位置。对于 34 来说，我 们取 di 即可找到空位置了。另外增加平方运算的目的是为了不让关键字都聚集在 某一块区域。我们称这种方法为二次探测法。

```
fi(key) = (f(key)+di) MOD m (di = 12, -12, 22, -22,……, q2, -q2, q <= m/2)
```

## 随机探测法

还有一种方法是，在冲突时，对于位移量 di 采用随机函数计算得到，我们称之为随机探测法。此时一定会有人问，既然是随机，那么查找的时候不也随机生成办吗？如何可以获得相同的地址呢？这是个问题。这里的随机其实是伪随机数。伪随机数是说，如果我们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在査找时，用同样的随机种子，它每次得到的数列是相同的，相同的 di 当然可以得到相同的散列地址。

```
fi(key) = (f(key)+di) MOD m (di是一个随机数列)
```

总之，开放定址法只要在哈希表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的办法。

## 链地址法

将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在哈希表中只存储所有同义词子表的头指针。对于关键字集合{12,67,56,16,25,37, 22,29,15,47,48,34}，我们用前面同样的 12 为除数，进行除留余数法:

![](http://www.nowamagic.net/librarys/images/201303/2013_03_14_01.png)

拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的哈希表长度为 m，则可将哈希表定义为一个由 m 个头指针组成的指针数组 T[0..m-1]。凡是散列地址为 i 的结点，均插入到以 T[i]为头指针的单链表中。T 中各分量的初值均应为空指针。在拉链法中，装填因子 α 可以大于 1，但一般均取 α≤1。与开放定址法相比，拉链法有如下几个优点：

- 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
- 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
- 开放定址法为减少冲突，要求装填因子 α 较小，故当结点规模较大时会浪费很多空间。而拉链法中可取 α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
- 在用拉链法构造的哈希表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的哈希表，删除结点不能简单地将被 删结 点的空间置为空，否则将截断在它之后填人哈希表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的哈希表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

拉链法的缺点：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大哈希表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

    