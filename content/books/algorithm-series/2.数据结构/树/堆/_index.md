
---
title: 堆
linktitle: 堆
type: book
commentable: true
---

# 堆

堆(也叫优先队列)，是一棵完全二叉树，它的特点是父节点的值大于(小于)两个子节点的值(分别称为大顶堆和小顶堆)。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：

- 父结点的键值总是大于或等于(小于或等于)任何一个子节点的键值。
- 每个结点的左子树和右子树都是一个二叉堆(都是最大堆或最小堆)。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。下图展示一个最小堆：

![](http://hi.csdn.net/attachment/201108/22/0_1314014666d5oe.gif)

# 堆存储

堆的存储上一般都用数组来表示堆，i 结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为 2 _ i + 1 和 2 _ i + 2。如第 0 个结点左右子结点下标分别为 1 和 2。

![](http://hi.csdn.net/attachment/201108/22/0_1314014706gZqn.gif)

# 堆建立

操作主要是将数组 A 转化成一个大顶堆。思想是，先找到堆的最后一个非叶子节点(即为第 n/2 个节点)，然后从该节点开始，从后往前逐个调整每个子树，使之称为堆，最终整个数组便是一个堆。子数组 A[(n/2)+1..n]中的元素都是树中 的叶子，因此都可以看作是只含有一个元素的堆。![](http://hi.csdn.net/attachment/201108/22/0_1314014725K5k6.gif) 很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即 20，60，65，4，49 都分别是一个合法的堆。只要从 A[4]=50 开始向下调整就可以了。然后再取 A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9 分别作一次向下调整操作就可以了。下图展示了这些步骤: ![](http://hi.csdn.net/attachment/201108/22/0_1314014735kbBA.gif)

# 插入与删除

下面先给出《数据结构 C++语言描述》中最小堆的建立插入删除的图解，再给出本人的实现代码，最好是先看明白图后再去看代码。

![](http://hi.csdn.net/attachment/201108/24/0_131415207877s7.gif)

### 堆的插入

每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于**直接插入排序**中将一个数据并入到有序区间中，对照[《白话经典算法系列之二 直接插入排序的三种实现》](http://blog.csdn.net/morewindows/article/details/6665714)不难写出插入一个新数据时堆的调整代码：

```
    //  新加入i结点  其父结点为(i - 1) / 2
    void MinHeapFixup(int a[], int i)
    {
        int j, temp;

        temp = a[i];
        j = (i - 1) / 2;      //父结点
        while (j >= 0 && i != 0)
        {
            if (a[j] <= temp)
                break;

            a[i] = a[j];     //把较大的子结点往下移动,替换它的子结点
            i = j;
            j = (i - 1) / 2;
        }
        a[i] = temp;
    }
```

更简短的表达为：

```
void MinHeapFixup(int a[], int i)
{
	for (int j = (i - 1) / 2; (j >= 0 && i != 0)&& a[i] > a[j]; i = j, j = (i - 1) / 2)
		Swap(a[i], a[j]);
}
```

插入时：

```
    //在最小堆中加入新的数据nNum
    void MinHeapAddNumber(int a[], int n, int nNum)
    {
        a[n] = nNum;
        MinHeapFixup(a, n);
    }
```

### 堆的删除

按定义，堆中每次都只能删除第 0 个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。下面给出代码：

```
//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2
void MinHeapFixdown(int a[], int i, int n)
{
    int j, temp;

	temp = a[i];
	j = 2 * i + 1;
	while (j < n)
	{
		if (j + 1 < n && a[j + 1] < a[j]) //在左右孩子中找最小的
			j++;

		if (a[j] >= temp)
			break;

		a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点
		i = j;
		j = 2 * i + 1;
	}
	a[i] = temp;
}
//在最小堆中删除数
void MinHeapDeleteNumber(int a[], int n)
{
	Swap(a[0], a[n - 1]);
	MinHeapFixdown(a, 0, n - 1);
}
```

    