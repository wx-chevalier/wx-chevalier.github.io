
---
title: 希尔排序
linktitle: 希尔排序
type: book
commentable: true
---

# 希尔排序

## Complexity: 算法复杂度

### 稳定性

希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，

插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比 O(n^2) 好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以 shell 排序是不稳定的。

希尔排序的实质就是分组插入排序，该方法又称缩小增量排序，因 DL．Shell 于 1959 年提出而得名。该方法的基本思想是：先将整个待排元素序列分割成若干个子序列(由相隔某个 “ 增量 ” 的元素组成的)分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序(增量足够小)时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下(接近最好情况)，效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

以 n=10 的一个数组 49, 38, 65, 97, 26, 13, 27, 49, 55, 4 为例

第一次 gap = 10 / 2 = 5

49 38 65 97 26 13 27 49 55 4

1A 1B

2A 2B

3A 3B

4A 4B

5A 5B

1A,1B，2A,2B 等为分组标记，数字相同的表示在同一组，大写字母表示是该组的第几个元素，每次对同一组的数据进行直接插入排序。即分成了五组 (49, 13) (38, 27) (65, 49) (97, 55) (26, 4) 这样每组排序后就变成了 (13, 49) (27, 38) (49, 65) (55, 97) (4, 26)，下同。

第二次 gap = 5 / 2 = 2

排序后

13 27 49 55 4 49 38 65 97 26

1A 1B 1C 1D 1E

2A 2B 2C 2D 2E

第三次 gap = 2 / 2 = 1

4 26 13 27 38 49 49 55 97 65

1A 1B 1C 1D 1E 1F 1G 1H 1I 1J

第四次 gap = 1 / 2 = 0 排序完成得到数组：

4 13 26 27 38 49 49 55 65 97

```
  void shellsort3(int a[], int n)
  {
  int i, j, gap;

  for (gap = n / 2; gap > 0; gap /= 2)
  for (i = gap; i < n; i++)
  for (j = i - gap; j >= 0 && a[j] > a[j + gap]; j -= gap)
  Swap(a[j], a[j + gap]);
  }
```

    