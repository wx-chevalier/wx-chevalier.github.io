
---
title: 聚合计算
linktitle: 聚合计算
type: book
commentable: true
---

# Sort

## 简单排序

对输入文件中数据进行排序。输入文件中的每行内容均为一个数字，即一个数据。要求在输出中每行有两个间隔的数字，其中，第一个代表原始数据在原始数据集中的位次，第二个代表原始数据。样例输入：

```
1)file1：

    2

    32

    654

    32

    15

    756

    65223


2)file2：

    5956

    22

    650

    92


3)file3：

    26

    54

    6


样例输出：

    1    2

    2    6

    3    15

    4    22

    5    26

    6    32

    7    32

    8    54

    9    92

    10    650

    11    654

    12    756

    13    5956

    14    65223
```

这个实例仅仅要求对输入数据进行排序，熟悉 MapReduce 过程的读者会很快想到在 MapReduce 过程中就有排序，是否可以利用这个默认的排序，而不需要自己再实现具体的排序呢？答案是肯定的。

但是在使用之前首先需要了解它的默认排序规则。它是按照 key 值进行排序的，如果 key 为封装 int 的 IntWritable 类型，那么 MapReduce 按照数字大小对 key 排序，如果 key 为封装为 String 的 Text 类型，那么 MapReduce 按照字典顺序对字符串排序。

了解了这个细节，我们就知道应该使用封装 int 的 IntWritable 型数据结构了。也就是在 map 中将读入的数据转化成 IntWritable 型，然 后作为 key 值输出(value 任意)。reduce 拿到<key，value-list>之后，将输入的 key 作为 value 输出，并根据 value-list 中元素的个数决定输出的次数。输出的 key(即代码中的 linenum)是一个全局变量，它统计当前 key 的位次。需要注意的是这个 程序中没有配置 Combiner，也就是在 MapReduce 过程中不使用 Combiner。这主要是因为使用 map 和 reduce 就已经能够完成任务 了。

```java
    public class Sort {


        //map将输入中的value化成IntWritable类型，作为输出的key

        public static class Map extends

　　　　　　　　Mapper<Object, Text, IntWritable, IntWritable>

        {

            private static IntWritable data = new IntWritable();

            //实现map函数

        public void map(Object key, Text value, Context context)

                throws IOException, InterruptedException {

            String line = value.toString();

            data.set(Integer.parseInt(line));

            context.write(data, new IntWritable(1));

        }

    }


    //reduce将输入中的key复制到输出数据的key上，

    //然后根据输入的value-list中元素的个数决定key的输出次数

    //用全局linenum来代表key的位次

    public static class Reduce extends

            Reducer<IntWritable, IntWritable, IntWritable, IntWritable> {


        private static IntWritable linenum = new IntWritable(1);


        //实现reduce函数

        public void reduce(IntWritable key, Iterable<IntWritable> values, Context context)

                throws IOException, InterruptedException {

            for (IntWritable val : values) {

                context.write(linenum, key);

                linenum = new IntWritable(linenum.get() + 1);

            }


        }


    }


    public static void main(String[] args) throws Exception {

        Configuration conf = new Configuration();

        //这句话很关键

        conf.set("mapred.job.tracker", "192.168.1.2:9001");


        String[] ioArgs = new String[]{"sort_in", "sort_out"};

        String[] otherArgs = new GenericOptionsParser(conf, ioArgs).getRemainingArgs();

        if (otherArgs.length != 2) {

            System.err.println("Usage: Data Sort <in> <out>");

            System.exit(2);

        }


        Job job = new Job(conf, "Data Sort");

        job.setJarByClass(Sort.class);


        //设置Map和Reduce处理类

        job.setMapperClass(Map.class);

        job.setReducerClass(Reduce.class);


        //设置输出类型

        job.setOutputKeyClass(IntWritable.class);

        job.setOutputValueClass(IntWritable.class);


        //设置输入和输出目录

        FileInputFormat.addInputPath(job, new Path(otherArgs[0]));

        FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));

        System.exit(job.waitForCompletion(true) ? 0 : 1);
    }
}
```

    